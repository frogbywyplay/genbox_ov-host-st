Add support for kernel modules that contain a gnu_debuglink section
pointing at a separate debug info file.

Patch by Fred Riss <frederic.riss@st.com>

Signed-off-by: Chris Smith <chris.smith@st.com>

Index: gdb-6.8/gdb/linux-awareness.c
===================================================================
--- gdb-6.8.orig/gdb/linux-awareness.c
+++ gdb-6.8/gdb/linux-awareness.c
@@ -44,7 +44,7 @@
 
 #include "linux-awareness.h"
 
-static int r32, r38, r48;
+char *find_separate_debug_file (bfd *objfile);
 
 /*************************** Copied from breakpoint.c *************************/
 
@@ -1531,6 +1531,16 @@ create_sections (bfd *abfd, asection *se
 	    && strcmp (bfd_get_section_name (abfd, sectp), "__versions") == 0))
 	return;
 
+    /* Make sure the section at 0 gets the SEC_LOAD flag, otherwise
+       the symbol at 0 will get discarded by the dwarf reader. This is
+       normally the case as this section is .text or .init.text, but
+       with separate debuginfo files, these sections are marked NOBITS
+       and thus not loadable. As the generated binary file won't get
+       loaded anyway, there's no harm in forcing that flag here. */
+    if (! (flags & SEC_DEBUGGING)
+	&& bfd_get_section_vma(abfd, sectp) == 0)
+	flags |= SEC_LOAD;
+
     DEBUG (MODULE, 3, "Adding section %s to new file at %s.\n",
 	   bfd_get_section_name (abfd, sectp),
 	   paddr(bfd_get_section_vma(abfd, sectp)));
@@ -2035,9 +2045,9 @@ linux_aware_find_and_open_solib(char *in
     int found_file = -1;
     char realfile[SO_NAME_MAX_PATH_SIZE];
     char soname[SO_NAME_MAX_PATH_SIZE];
-    bfd *abfd;
+    bfd *abfd, *sbfd;
     struct lm_info *lm_info;
-    char *c;
+    char *c, *sep_file;
     strcpy (soname, in_soname+1);
     soname[strlen(soname)-1] = '\0';
 
@@ -2070,7 +2080,7 @@ but didn't find the module file.\n\
 Current module-search-path is:\n%s\n", soname, realfile, *module_search_path);
     }
 
-    abfd = bfd_openr (*temp_pathname, gnutarget);
+    sbfd = abfd = bfd_openr (*temp_pathname, gnutarget);
     if (!abfd) {
 	close (found_file);
 	error ("Could not open `%s' as an executable file: %s",
@@ -2095,9 +2105,20 @@ Current module-search-path is:\n%s\n", s
 	return found_file;
     }
 
+    sep_file = find_separate_debug_file (abfd);
+    if (sep_file != NULL) {
+	sbfd = bfd_openr (sep_file, gnutarget);
+
+	if (!bfd_check_format (sbfd, bfd_object)) {
+	    error ("\"%s\": not in executable format: %s.",
+		   sep_file, bfd_errmsg (bfd_get_error ()));
+	}
+	xfree (sep_file);
+    }
+
     lm_info->real_file = xmalloc (strlen (*temp_pathname)+1);
     strcpy (lm_info->real_file, *temp_pathname);
-    found_file = make_temporary_bfd (abfd, lm_info, temp_pathname);
+    found_file = make_temporary_bfd (sbfd, lm_info, temp_pathname);
 
     if (found_file >= 0) {
 	lm_info->relocated_file = xmalloc (strlen (*temp_pathname)+1);
@@ -2107,6 +2128,9 @@ Current module-search-path is:\n%s\n", s
     }
 
     bfd_close (abfd);
+    if (sbfd != abfd)
+	bfd_close (sbfd);
+
     return found_file;
 }
 
Index: gdb-6.8/gdb/symfile.c
===================================================================
--- gdb-6.8.orig/gdb/symfile.c
+++ gdb-6.8/gdb/symfile.c
@@ -140,7 +140,7 @@ static void add_filename_language (char 
 
 static void info_ext_lang_command (char *args, int from_tty);
 
-static char *find_separate_debug_file (struct objfile *objfile);
+char *find_separate_debug_file (bfd *abfd);
 
 static void init_filename_language_table (void);
 
@@ -1104,7 +1104,7 @@ symbol_file_add_with_addrs_or_offsets (b
      `.dynsym'/`.symtab' go to MSYMBOLS, `.debug_info' goes to SYMTABS/PSYMTABS.
      `.gnu_debuglink' may no longer be present with `.note.gnu.build-id'.  */
   if (objfile->psymtabs == NULL)
-    debugfile = find_separate_debug_file (objfile);
+    debugfile = find_separate_debug_file (objfile->obfd);
   if (debugfile)
     {
       if (addrs != NULL)
@@ -1336,7 +1336,7 @@ build_id_to_debug_filename (struct build
 }
 
 static char *
-get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
+get_debug_link_info (bfd *abfd, unsigned long *crc32_out)
 {
   asection *sect;
   bfd_size_type debuglink_size;
@@ -1345,22 +1345,22 @@ get_debug_link_info (struct objfile *obj
   int crc_offset;
   unsigned char *p;
 
-  sect = bfd_get_section_by_name (objfile->obfd, ".gnu_debuglink");
+  sect = bfd_get_section_by_name (abfd, ".gnu_debuglink");
 
   if (sect == NULL)
     return NULL;
 
-  debuglink_size = bfd_section_size (objfile->obfd, sect);
+  debuglink_size = bfd_section_size (abfd, sect);
 
   contents = xmalloc (debuglink_size);
-  bfd_get_section_contents (objfile->obfd, sect, contents,
+  bfd_get_section_contents (abfd, sect, contents,
 			    (file_ptr)0, (bfd_size_type)debuglink_size);
 
   /* Crc value is stored after the filename, aligned up to 4 bytes. */
   crc_offset = strlen (contents) + 1;
   crc_offset = (crc_offset + 3) & ~3;
 
-  crc32 = bfd_get_32 (objfile->obfd, (bfd_byte *) (contents + crc_offset));
+  crc32 = bfd_get_32 (abfd, (bfd_byte *) (contents + crc_offset));
 
   *crc32_out = crc32;
   return contents;
@@ -1400,8 +1400,8 @@ The directory where separate debug symbo
 #define DEBUG_SUBDIRECTORY ".debug"
 #endif
 
-static char *
-find_separate_debug_file (struct objfile *objfile)
+char *
+find_separate_debug_file (bfd *abfd)
 {
   asection *sect;
   char *basename;
@@ -1414,7 +1414,7 @@ find_separate_debug_file (struct objfile
   int i;
   struct build_id *build_id;
 
-  build_id = build_id_bfd_get (objfile->obfd);
+  build_id = build_id_bfd_get (abfd);
   if (build_id != NULL)
     {
       char *build_id_name;
@@ -1422,7 +1422,8 @@ find_separate_debug_file (struct objfile
       build_id_name = build_id_to_debug_filename (build_id);
       free (build_id);
       /* Prevent looping on a stripped .debug file.  */
-      if (build_id_name != NULL && strcmp (build_id_name, objfile->name) == 0)
+      if (build_id_name != NULL
+	  && strcmp (build_id_name, bfd_get_filename(abfd)) == 0)
         {
 	  warning (_("\"%s\": separate debug info file has no debug info"),
 		   build_id_name);
@@ -1432,12 +1433,12 @@ find_separate_debug_file (struct objfile
         return build_id_name;
     }
 
-  basename = get_debug_link_info (objfile, &crc32);
+  basename = get_debug_link_info (abfd, &crc32);
 
   if (basename == NULL)
     return NULL;
 
-  dir = xstrdup (objfile->name);
+  dir = xstrdup (bfd_get_filename(abfd));
 
   /* Strip off the final filename part, leaving the directory name,
      followed by a slash.  Objfile names should always be absolute and
@@ -2546,7 +2547,7 @@ reread_separate_symbols (struct objfile 
 
   /* Does the updated objfile's debug info live in a
      separate file?  */
-  debug_file = find_separate_debug_file (objfile);
+  debug_file = find_separate_debug_file (objfile->obfd);
 
   if (objfile->separate_debug_objfile)
     {
