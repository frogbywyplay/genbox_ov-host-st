diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/breakpoint.c insight/gdb/breakpoint.c
--- gdb-6.8/gdb/breakpoint.c	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/breakpoint.c	2009-03-03 18:28:03.000000000 +0000
@@ -3,7 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
-   Copyright (c) 2008 STMicroelectronics 
+   Copyright (c) 2008, 2009 STMicroelectronics
 
    This file is part of GDB.
 
@@ -898,7 +898,7 @@
      is different from out-of-scope watchpoint.  */
   if (within_current_scope && b->exp)
     {
-      struct value *v, *next;
+      struct value *v, *result, *next;
 
       /* Evaluate the expression and make sure it's not lazy, so that
 	 after target stops again, we have a non-lazy previous value
@@ -910,18 +910,18 @@
 	 In addition, we look at all values which were created
 	 during evaluation, and set watchoints at addresses as needed.
 	 Those values are explicitly deleted here.  */
-      v = evaluate_expression (b->exp);
+      result = evaluate_expression (b->exp);
       /* Avoid setting b->val if it's already set.  The meaning of
 	 b->val is 'the last value' user saw, and we should update
 	 it only if we reported that last value to user.  As it
 	 happens, the code that reports it updates b->val directly.  */
       if (b->val == NULL)
-	b->val = v;
-      value_contents (v);
+	b->val = result;
+      value_contents (result);
       value_release_to_mark (mark);
 
       /* Look at each value on the value chain.  */
-      for (; v; v = next)
+      for (v = result; v; v = next)
 	{
 	  /* If it's a memory location, and GDB actually needed
 	     its contents to evaluate the expression, then we
@@ -934,7 +934,7 @@
 	      /* We only watch structs and arrays if user asked
 		 for it explicitly, never if they just happen to
 		 appear in the middle of some value chain.  */
-	      if (v == b->val
+	      if (v == result
 		  || (TYPE_CODE (vtype) != TYPE_CODE_STRUCT
 		      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
 		{
@@ -2573,7 +2573,8 @@
 
       struct value *mark = value_mark ();
       struct value *new_val = evaluate_expression (b->exp);
-      if (!value_equal (b->val, new_val))
+      if (!value_equal (b->val, new_val)
+	  || !value_contents_equal (b->val, new_val))
 	{
 	  release_value (new_val);
 	  value_free_to_mark (mark);
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/ChangeLog.st40 insight/gdb/ChangeLog.st40
--- gdb-6.8/gdb/ChangeLog.st40	1970-01-01 01:00:00.000000000 +0100
+++ insight/gdb/ChangeLog.st40	2009-05-29 14:07:59.000000000 +0100
@@ -0,0 +1,108 @@
+2009-05-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl30302:
+	* shtdi.c (shtdi_close): Update shtdi_target_state appropriately.
+	(shtdi_close_cleanup): Call shdbg_DeInitialise if not disconnected.
+	(shtdi_open): Replace do_cleanups with discard_cleanups.
+	(shtdi_open_cleanup): Update.
+
+2009-04-17  Antony King  <antony.king@st.com>
+
+	Fix INSbl30134:
+	* elfread.c (elf_symtab_read): Call bfd_is_local_label to
+	filter out local labels. Also special case "L0\001".
+
+	Fix INSbl30133:
+	* shtdi.c (shtdi_continue_after_exit): New global variable.
+	(shtdi_mourn_inferior_1): Renamed from shtdi_mourn_inferior.
+	(shtdi_kill): Use shtdi_mourn_inferior_1 instead of
+	target_mourn_inferior.
+	(shtdi_disconnect): Likewise.
+	(shtdi_mourn_inferior): New function.
+	(show_shtdi_continue_after_exit): Likewise.
+	(_initialize_shtdi): Add new set/show shtdi subcommand.
+
+2009-04-03  Antony King  <antony.king@st.com>
+
+	Fix INSbl30083:
+	* shtdi.c (shtdi_files_info): Implement.
+
+2009-03-03  Antony King  <antony.king@st.com>
+
+	Fix INSbl29762:
+	* breakpoint.c (update_watchpoints): Update.
+	(watchpoint_check): Check value contents.
+
+2009-02-27  Antony King  <antony.king@st.com>
+
+	Fix INSbl29964:
+	* sh-tdep.c (sh_frame_cache): Update.
+
+2009-01-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl29741:
+	* infrun.c (prepare_to_proceed): Move fix for INSbl29191 from here ...
+	(restore_proceed_thread): ... to here. New function.
+	(proceed): Call restore_proceed_thread.
+
+2009-01-19  Antony King  <antony.king@st.com>
+
+	Fix INSbl29720:
+	* shtdi.c (shtdi_targetconnected): Remove.
+	(shtdi_target_state): New global variable.
+	(shtdi_open): Replace shtdi_targetconnected with shtdi_target_state.
+	(shtdi_close_cleanup): Likewise.
+	(shtdi_close): Likewise.
+	(rtos_reset_command): Likewise.
+	(shtdi_new_objfile): Likewise.
+
+2008-11-25  Antony King  <antony.king@st.com>
+
+	Fix INSbl29601:
+	* sh-tdep.c (sh_in_function_epilogue_p): Assume last line in function
+	is epilogue.  Relax hueristic.
+	(sh_is_epilogue_inst): New function.
+
+2008-11-18  Antony King  <antony.king@st.com>
+
+	Fix INSbl29581:
+	* sh-tdep.c (sh_skip_prologue): Use skip_prologue_using_sal instead
+	of determining symbol and line info directly.
+	(after_prologue): Remove.
+
+2008-11-13  Joel Brobecker  <brobecker@adacore.com>
+
+	* printcmd.c: define PRINTF_HAS_LONG_LONG only if not yet defined.
+
+2008-10-23  Denis Pilat <denis.pilat@st.com>
+
+	* utils.c (defaulted_query): Return the default value when using MI
+	interpreter.
+
+2008-10-17  Antony King  <antony.king@st.com>
+
+	Fix INSbl29438:
+	* sh-tdep.c (sh_analyze_prologue): Update.
+
+2008-10-10  Antony King  <antony.king@st.com>
+
+	Fix INSbl29407:
+	* shtdi.c (shtdi_mourn_inferior): Clear shtdi_rtos_launched.
+	(shtdi_create_inferior): Call init_thread_list.
+
+	Fix INSbl29403:
+	* shtdi.c (shtdi_mourn_inferior): Remove breakpoints before
+	clearing RTOS state.
+
+	* version.in: Add '-ST40' to version.
+
+2008-09-22  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* symtab.c (skip_prologue_using_sal): Treat two consecutive lines
+	at the same address as a prologue marker.  Do not skip an entire
+	function.
+
+2008-06-27  Joseph Myers  <joseph@codesourcery.com>
+
+	* dfp.c (decimal_convert): Call match_endianness before and after
+	conversion.
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/dfp.c insight/gdb/dfp.c
--- gdb-6.8/gdb/dfp.c	2008-01-16 16:16:44.000000000 +0000
+++ insight/gdb/dfp.c	2009-04-01 15:43:26.000000000 +0100
@@ -395,7 +395,12 @@
 		 int len_to)
 {
   decNumber number;
+  gdb_byte dec[16];
 
-  decimal_to_number (from, len_from, &number);
-  decimal_from_number (&number, to, len_to);
+  match_endianness (from, len_from, dec);
+
+  decimal_to_number (dec, len_from, &number);
+  decimal_from_number (&number, dec, len_to);
+
+  match_endianness (dec, len_to, to);
 }
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/elfread.c insight/gdb/elfread.c
--- gdb-6.8/gdb/elfread.c	2008-01-01 22:53:09.000000000 +0000
+++ insight/gdb/elfread.c	2009-04-17 17:09:34.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2009 STMicroelectronics
 
    Written by Fred Fish at Cygnus Support.
 
@@ -238,6 +239,9 @@
 	 but have some other target-specific meaning.  */
       if (bfd_is_target_special_symbol (objfile->obfd, sym))
 	continue;
+      /* Skip local labels that have "leaked" into the executable.  */
+      else if (bfd_is_local_label (objfile->obfd, sym))
+	continue;
 
       offset = ANOFFSET (objfile->section_offsets, sym->section->index);
       if (type == ST_DYNAMIC
@@ -378,6 +382,10 @@
 		   I encourage people to fix this in the assembler
 		   instead of adding checks here).  */
 		continue;
+	      else if (strcmp (sym->name, "L0\001") == 0)
+		/* Looks like a "fake" assembler label (when performing
+		   relaxation on the SH). Skip it.  */
+		continue;
 	      else
 		{
 		  ms_type = mst_file_text;
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/infrun.c insight/gdb/infrun.c
--- gdb-6.8/gdb/infrun.c	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/infrun.c	2009-01-21 21:36:57.000000000 +0000
@@ -4,7 +4,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
-   Copyright (c) 2008 STMicroelectronics
+   Copyright (c) 2008, 2009 STMicroelectronics
 
    This file is part of GDB.
 
@@ -682,10 +682,10 @@
   bpstat_clear (&stop_bpstat);
 }
 
-/* This should be suitable for any targets that support threads. */
+/* Adjust current thread depending on target capability. */
 
-static int
-prepare_to_proceed (int step)
+static void
+restore_proceed_thread (void)
 {
   ptid_t wait_ptid;
   struct target_waitstatus wait_status;
@@ -693,13 +693,6 @@
   /* Get the last target status returned by target_wait().  */
   get_last_target_status (&wait_ptid, &wait_status);
 
-  /* Make sure we were stopped at a breakpoint.  */
-  if (wait_status.kind != TARGET_WAITKIND_STOPPED
-      || wait_status.value.sig != TARGET_SIGNAL_TRAP)
-    {
-      return 0;
-    }
-
   /* Switch to WAIT_PID if target unable to control threads.  */
   if (!ptid_equal (wait_ptid, minus_one_ptid)
       && !ptid_equal (inferior_ptid, wait_ptid)
@@ -709,6 +702,25 @@
 		       target_pid_to_str (wait_ptid));
       switch_to_thread (wait_ptid);
     }
+}
+
+/* This should be suitable for any targets that support threads. */
+
+static int
+prepare_to_proceed (int step)
+{
+  ptid_t wait_ptid;
+  struct target_waitstatus wait_status;
+
+  /* Get the last target status returned by target_wait().  */
+  get_last_target_status (&wait_ptid, &wait_status);
+
+  /* Make sure we were stopped at a breakpoint.  */
+  if (wait_status.kind != TARGET_WAITKIND_STOPPED
+      || wait_status.value.sig != TARGET_SIGNAL_TRAP)
+    {
+      return 0;
+    }
 
   /* Switched over from WAIT_PID.  */
   if (!ptid_equal (wait_ptid, minus_one_ptid)
@@ -755,6 +767,8 @@
 {
   int oneproc = 0;
 
+  restore_proceed_thread ();
+
   if (step > 0)
     step_start_function = find_pc_function (read_pc ());
   if (step < 0)
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/mipsread.c insight/gdb/mipsread.c
--- gdb-6.8/gdb/mipsread.c	2008-01-01 22:53:12.000000000 +0000
+++ insight/gdb/mipsread.c	2009-06-05 12:12:35.000000000 +0100
@@ -39,6 +39,7 @@
 #include "libcoff.h"		/* Private BFD COFF information.  */
 #include "libecoff.h"		/* Private BFD ECOFF information.  */
 #include "elf/common.h"
+#include "elf/internal.h"
 #include "elf/mips.h"
 
 static void
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/printcmd.c insight/gdb/printcmd.c
--- gdb-6.8/gdb/printcmd.c	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/printcmd.c	2009-04-20 14:52:41.000000000 +0100
@@ -47,7 +47,7 @@
 #include "tui/tui.h"		/* For tui_active et.al.   */
 #endif
 
-#if defined(__MINGW32__)
+#if defined(__MINGW32__) && !defined(PRINTF_HAS_LONG_LONG)
 # define USE_PRINTF_I64 1
 # define PRINTF_HAS_LONG_LONG
 #else
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/sh-tdep.c insight/gdb/sh-tdep.c
--- gdb-6.8/gdb/sh-tdep.c	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/sh-tdep.c	2009-03-02 17:51:24.000000000 +0000
@@ -2,7 +2,7 @@
 
    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
    2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
-   Copyright (C) 2007 STMicroelectronics
+   Copyright (C) 2007-2009 STMicroelectronics
 
    This file is part of GDB.
 
@@ -411,7 +411,7 @@
    mov.l	r14,@-r15
    sts.l	pr,@-r15
    mov.l	<regs>,@-r15
-   sub		<room_for_loca_vars>,r15
+   sub		<room_for_local_vars>,r15
    mov		r15,r14
 
    Actually it can be more complicated than this but that's it, basically.
@@ -420,83 +420,107 @@
 #define GET_SOURCE_REG(x)	(((x) >> 4) & 0xf)
 #define GET_TARGET_REG(x)	(((x) >> 8) & 0xf)
 
-/* JSR @Rm         0100mmmm00001011 */
+/* JSR @Rm			0100mmmm00001011 */
 #define IS_JSR(x)		(((x) & 0xf0ff) == 0x400b)
 
-/* STS.L PR,@-r15  0100111100100010
-   r15-4-->r15, PR-->(r15) */
-#define IS_STS(x)		((x) == 0x4f22)
-
-/* STS.L MACL,@-r15  0100111100010010
-   r15-4-->r15, MACL-->(r15) */
-#define IS_MACL_STS(x)		((x) == 0x4f12)
-
-/* MOV.L Rm,@-r15  00101111mmmm0110
-   r15-4-->r15, Rm-->(R15) */
+/* MOV.L Rm,@-Rn		0010nnnnmmmm0110  n = 15 */
 #define IS_PUSH(x)		(((x) & 0xff0f) == 0x2f06)
 
-/* MOV r15,r14     0110111011110011
-   r15-->r14  */
-#define IS_MOV_SP_FP(x)		((x) == 0x6ef3)
-
-/* ADD #imm,r15    01111111iiiiiiii
-   r15+imm-->r15 */
-#define IS_ADD_IMM_SP(x)	(((x) & 0xff00) == 0x7f00)
+/* STS.L PR,@-Rm		0100mmmm00100010  m = 15 */
+#define IS_PUSH_PR(x)		((x) == 0x4f22)
 
-#define IS_MOV_R3(x)		(((x) & 0xff00) == 0x1a00)
-#define IS_SHLL_R3(x)		((x) == 0x4300)
+/* STS.L MACL,@-Rm		0100mmmm00010010  m = 15 */
+#define IS_PUSH_MACL(x)		((x) == 0x4f12)
 
-/* ADD r3,r15      0011111100111100
-   r15+r3-->r15 */
-#define IS_ADD_R3SP(x)		((x) == 0x3f3c)
-
-/* FMOV.S FRm,@-Rn  Rn-4-->Rn, FRm-->(Rn)     1111nnnnmmmm1011
-   FMOV DRm,@-Rn    Rn-8-->Rn, DRm-->(Rn)     1111nnnnmmm01011
-   FMOV XDm,@-Rn    Rn-8-->Rn, XDm-->(Rn)     1111nnnnmmm11011 */
-/* CV, 2003-08-28: Only suitable with Rn == SP, therefore name changed to
-		   make this entirely clear. */
-/* #define IS_FMOV(x)		(((x) & 0xf00f) == 0xf00b) */
+/* FMOV.S FRm,@-Rn		1111nnnnmmmm1011
+   FMOV DRm,@-Rn		1111nnnnmmm01011
+   FMOV XDm,@-Rn		1111nnnnmmm11011  n = 15 */
 #define IS_FPUSH(x)		(((x) & 0xff0f) == 0xff0b)
 
-/* MOV Rm,Rn          Rm-->Rn        0110nnnnmmmm0011  4 <= m <= 7 */
+/* MOV Rm,Rn			0110nnnnmmmm0011  n = 14, m = r15  */
+#define IS_MOV_SP_TO_FP(x)	((x) == 0x6ef3)
+
+/* ADD #imm,Rm			0111mmmmiiiiiiii  m = 15 */
+#define IS_ADD_IMM_TO_SP(x)	(((x) & 0xff00) == 0x7f00)
+
+/* MOV #imm,Rm			1110mmmmiiiiiiii  m = 3 */
+#define IS_MOV_IMM_TO_R3(x)	(((x) & 0xff00) == 0xe300)
+
+/* SHLL Rm			0100mmmm00000000  m = 3 */
+#define IS_SHLL_R3(x)		((x) == 0x4300)
+
+/* ADD Rm,Rn			0011nnnnmmmm1100  n = 15, m = 3 */
+#define IS_ADD_R3_TO_SP(x)	((x) == 0x3f3c)
+
+/* MOV Rm,Rn			0110nnnnmmmm0011  4 <= m <= 7 */
 #define IS_MOV_ARG_TO_REG(x) \
 	(((x) & 0xf00f) == 0x6003 && \
 	 ((x) & 0x00f0) >= 0x0040 && \
 	 ((x) & 0x00f0) <= 0x0070)
-/* MOV.L Rm,@Rn               0010nnnnmmmm0010  n = 14, 4 <= m <= 7 */
+
+/* MOV.L Rm,@Rn			0010nnnnmmmm0010  n = 14, 4 <= m <= 7 */
 #define IS_MOV_ARG_TO_IND_R14(x) \
 	(((x) & 0xff0f) == 0x2e02 && \
 	 ((x) & 0x00f0) >= 0x0040 && \
 	 ((x) & 0x00f0) <= 0x0070)
-/* MOV.L Rm,@(disp*4,Rn)      00011110mmmmdddd  n = 14, 4 <= m <= 7 */
+
+/* MOV.L Rm,@(disp*4,Rn)	0001nnnnmmmmdddd  n = 14, 4 <= m <= 7 */
 #define IS_MOV_ARG_TO_IND_R14_WITH_DISP(x) \
 	(((x) & 0xff00) == 0x1e00 && \
 	 ((x) & 0x00f0) >= 0x0040 && \
 	 ((x) & 0x00f0) <= 0x0070)
 
-/* MOV.W @(disp*2,PC),Rn      1001nnnndddddddd */
+/* MOV.W @(disp*2,PC),Rm	1001mmmmdddddddd */
 #define IS_MOVW_PCREL_TO_REG(x)	(((x) & 0xf000) == 0x9000)
-/* MOV.L @(disp*4,PC),Rn      1101nnnndddddddd */
+
+/* MOV.L @(disp*4,PC),Rm	1101mmmmdddddddd */
 #define IS_MOVL_PCREL_TO_REG(x)	(((x) & 0xf000) == 0xd000)
-/* MOVI20 #imm20,Rn           0000nnnniiii0000 */
+
+/* MOVI20 #imm20,Rm		0000mmmmiiii0000 */
 #define IS_MOVI20(x)		(((x) & 0xf00f) == 0x0000)
-/* SUB Rn,R15                 00111111nnnn1000 */
+
+/* SUB Rm,Rn			0011nnnnmmmm1000  n = 15 */
 #define IS_SUB_REG_FROM_SP(x)	(((x) & 0xff0f) == 0x3f08)
 
+/* The following instructions are used for epilogue testing. */
+
+/* MOV.L @Rn+,Rm		0110nnnnmmmm0110  n = 15 */
+#define IS_POP(x)		(((x) & 0xff0f) == 0x6f06)
+
+/* LDS.L @Rm+,PR		0100mmmm00100110  m = 15 */
+#define IS_POP_PR(x)		((x) == 0x4f26)
+
+/* LDS.L @Rm+,MACL		0100mmmm00010110  m = 15 */
+#define IS_POP_MACL(x)		((x) == 0x4f16)
+
+/* FMOV.S @Rn+,FRm		1111nnnnmmmm1001
+   FMOV @Rn+,DRm		1111nnnnmmm01001
+   FMOV @Rn+,XDm		1111nnnnmmm11001  n = 15 */
+#define IS_FPOP(x)		(((x) & 0xff0f) == 0xff09)
+
+/* RTS				0000000000001011 */
+#define IS_RTS(x)		((x) == 0x000b)
+
+/* BRA #imm			1010iiiiiiiiiiii */
+#define IS_BRA(x)		(((x) & 0xf000) == 0xa000)
+
+/* JMP @Rm			0100mmmm00101011 */
+#define IS_JMP(x)		(((x) & 0xf0ff) == 0x402b)
+
+/* MOV Rm,Rn			0110nnnnmmmm0011  n = 15, m = r14  */
+#define IS_MOV_FP_TO_SP(x)	((x) == 0x6fe3)
+
+/* ADD Rm,Rn			0011nnnnmmmm1100  n = 14 */
+#define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
+
+/* ADD #imm,Rm			0111mmmmiiiiiiii  m = 14 */
+#define IS_ADD_IMM_TO_FP(x)	(((x) & 0xff00) == 0x7e00)
+
 #define SR_RB			(1 << 29)
 #define FPSCR_PR		(1 << 19)
 #define FPSCR_SZ		(1 << 20)
 #define FPSCR_FR		(1 << 21)
 
-/* The following instructions are used for epilogue testing. */
-#define IS_RESTORE_FP(x)	((x) == 0x6ef6)
-#define IS_RTS(x)		((x) == 0x000b)
-#define IS_LDS(x)		((x) == 0x4f26)
-#define IS_MACL_LDS(x)		((x) == 0x4f16)
-#define IS_MOV_FP_SP(x)		((x) == 0x6fe3)
-#define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
-#define IS_ADD_IMM_FP(x)	(((x) & 0xff00) == 0x7e00)
-
 /* Disassemble an instruction.  */
 static int
 gdb_print_insn_sh (bfd_vma memaddr, disassemble_info * info)
@@ -512,9 +536,9 @@
   ULONGEST inst;
   CORE_ADDR opc;
   int offset;
-  int sav_offset = 0;
+  int sav_offset[14] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
   int r3_val = 0;
-  int reg, sav_reg = -1;
+  int reg;
 
   if (pc >= current_pc)
     return current_pc;
@@ -529,17 +553,17 @@
 	  cache->saved_regs[GET_SOURCE_REG (inst)] = cache->sp_offset;
 	  cache->sp_offset += 4;
 	}
-      else if (IS_STS (inst))
+      else if (IS_PUSH_PR (inst))
 	{
 	  cache->saved_regs[PR_REGNUM] = cache->sp_offset;
 	  cache->sp_offset += 4;
 	}
-      else if (IS_MACL_STS (inst))
+      else if (IS_PUSH_MACL (inst))
 	{
 	  cache->saved_regs[MACL_REGNUM] = cache->sp_offset;
 	  cache->sp_offset += 4;
 	}
-      else if (IS_MOV_R3 (inst))
+      else if (IS_MOV_IMM_TO_R3 (inst))
 	{
 	  r3_val = ((inst & 0xff) ^ 0x80) - 0x80;
 	}
@@ -547,70 +571,54 @@
 	{
 	  r3_val <<= 1;
 	}
-      else if (IS_ADD_R3SP (inst))
+      else if (IS_ADD_R3_TO_SP (inst))
 	{
 	  cache->sp_offset += -r3_val;
 	}
-      else if (IS_ADD_IMM_SP (inst))
+      else if (IS_ADD_IMM_TO_SP (inst))
 	{
 	  offset = ((inst & 0xff) ^ 0x80) - 0x80;
 	  cache->sp_offset -= offset;
 	}
       else if (IS_MOVW_PCREL_TO_REG (inst))
 	{
-	  if (sav_reg < 0)
+	   reg = GET_TARGET_REG (inst);
+	   if (reg < 14)
 	    {
-	      reg = GET_TARGET_REG (inst);
-	      if (reg < 14)
-		{
-		  sav_reg = reg;
-		  offset = (inst & 0xff) << 1;
-		  sav_offset =
-		    read_memory_integer ((pc + 4) + offset, 2);
-		}
+	      offset = (inst & 0xff) << 1;
+	      sav_offset[reg] = read_memory_integer ((pc + 4) + offset, 2);
 	    }
 	}
       else if (IS_MOVL_PCREL_TO_REG (inst))
 	{
-	  if (sav_reg < 0)
+	  reg = GET_TARGET_REG (inst);
+	  if (reg < 14)
 	    {
-	      reg = GET_TARGET_REG (inst);
-	      if (reg < 14)
-		{
-		  sav_reg = reg;
-		  offset = (inst & 0xff) << 2;
-		  sav_offset =
-		    read_memory_integer (((pc & 0xfffffffc) + 4) + offset, 4);
-		}
+	      offset = (inst & 0xff) << 2;
+	      sav_offset[reg] = read_memory_integer (((pc & 0xfffffffc) + 4) + offset, 4);
 	    }
 	}
       else if (IS_MOVI20 (inst))
 	{
-	  if (sav_reg < 0)
+	  reg = GET_TARGET_REG (inst);
+	  if (reg < 14)
 	    {
-	      reg = GET_TARGET_REG (inst);
-	      if (reg < 14)
-		{
-		  sav_reg = reg;
-		  sav_offset = GET_SOURCE_REG (inst) << 16;
-		  /* MOVI20 is a 32 bit instruction! */
-		  pc += 2;
-		  sav_offset |= read_memory_unsigned_integer (pc, 2);
-		  /* Now sav_offset contains an unsigned 20 bit value.
-		     It must still get sign extended.  */
-		  if (sav_offset & 0x00080000)
-		    sav_offset |= 0xfff00000;
-		}
+	      sav_offset[reg] = GET_SOURCE_REG (inst) << 16;
+	      /* MOVI20 is a 32 bit instruction! */
+	      pc += 2;
+	      sav_offset[reg] |= read_memory_unsigned_integer (pc, 2);
+	      /* Now sav_offset contains an unsigned 20 bit value.
+		 It must still get sign extended.  */
+	      if (sav_offset[reg] & 0x00080000)
+		sav_offset[reg] |= 0xfff00000;
 	    }
 	}
       else if (IS_SUB_REG_FROM_SP (inst))
 	{
 	  reg = GET_SOURCE_REG (inst);
-	  if (sav_reg > 0 && reg == sav_reg)
-	    {
-	      sav_reg = -1;
-	    }
-	  cache->sp_offset += sav_offset;
+	  if (reg >= 14 || sav_offset[reg] == -1)
+	    error (_("bad unwind value for sp adjust"));
+	  cache->sp_offset += sav_offset[reg];
 	}
       else if (IS_FPUSH (inst))
 	{
@@ -623,7 +631,7 @@
 	      cache->sp_offset += 4;
 	    }
 	}
-      else if (IS_MOV_SP_FP (inst))
+      else if (IS_MOV_SP_TO_FP (inst))
 	{
 	  cache->uses_fp = 1;
 	  /* At this point, only allow argument register moves to other
@@ -662,10 +670,10 @@
 	     then setting a breakpoint on this function will cause it to
 	     appear to be called after the function it is calling via the
 	     jsr, which will be very confusing.  Most likely the next
-	     instruction is going to be IS_MOV_SP_FP in the delay slot.  If
-	     so, note that before returning the current pc. */
+	     instruction is going to be IS_MOV_SP_TO_FP in the delay slot.
+	     If so, note that before returning the current pc. */
 	  inst = read_memory_integer (pc + 2, 2);
-	  if (IS_MOV_SP_FP (inst))
+	  if (IS_MOV_SP_TO_FP (inst))
 	    cache->uses_fp = 1;
 	  break;
 	}
@@ -682,56 +690,36 @@
 
 /* Skip any prologue before the guts of a function */
 
-/* Skip the prologue using the debug information. If this fails we'll
-   fall back on the 'guess' method below. */
 static CORE_ADDR
-after_prologue (CORE_ADDR pc)
+sh_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
+  CORE_ADDR skip_pc, func_addr;
   struct symtab_and_line sal;
-  CORE_ADDR func_addr, func_end;
-
-  /* If we can not find the symbol in the partial symbol table, then
-     there is no hope we can determine the function's start address
-     with this code.  */
-  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
-    return 0;
-
-  /* Get the line associated with FUNC_ADDR.  */
-  sal = find_pc_line (func_addr, 0);
-
-  /* There are only two cases to consider.  First, the end of the source line
-     is within the function bounds.  In that case we return the end of the
-     source line.  Second is the end of the source line extends beyond the
-     bounds of the current function.  We need to use the slow code to
-     examine instructions in that case.  */
-  if (sal.end < func_end)
-    return sal.end;
-  else
-    return 0;
-}
-
-static CORE_ADDR
-sh_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
-{
-  CORE_ADDR pc;
   struct sh_frame_cache cache;
 
+  /* If we're in a dummy frame, don't even try to skip the prologue.  */
+  if (deprecated_pc_in_call_dummy (pc))
+    return pc;
+
   /* See if we can determine the end of the prologue via the symbol table.
      If so, then return either PC, or the PC after the prologue, whichever
      is greater.  */
-  pc = after_prologue (start_pc);
+  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
+    {
+      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
+      if (post_prologue_pc != 0)
+	return max (pc, post_prologue_pc);
+    }
 
-  /* If after_prologue returned a useful address, then use it.  Else
-     fall back on the instruction skipping code. */
-  if (pc)
-    return max (pc, start_pc);
+  /* Can't determine prologue from the symbol table, need to examine
+     instructions.  */
 
   cache.sp_offset = -4;
-  pc = sh_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache, 0);
+  skip_pc = sh_analyze_prologue (pc, (CORE_ADDR) -1, &cache, 0);
   if (!cache.uses_fp)
-    return start_pc;
+    return pc;
 
-  return pc;
+  return skip_pc;
 }
 
 /* The ABI says:
@@ -1949,7 +1937,7 @@
 
   printf_filtered
     (pr ? "XD0-XD6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-        : "XF0-XF7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+	: "XF0-XF7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 0),
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 1),
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 2),
@@ -1960,7 +1948,7 @@
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 7));
   printf_filtered
     (pr ? "XD8-XD14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-        : "XF8-XF15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+	: "XF8-XF15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 8),
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 9),
      (long) get_frame_register_unsigned (frame, XF0_REGNUM + 10),
@@ -2605,15 +2593,6 @@
   cache = sh_alloc_frame_cache ();
   *this_cache = cache;
 
-  /* In principle, for normal frames, fp holds the frame pointer,
-     which holds the base address for the current stack frame.
-     However, for functions that don't need it, the frame pointer is
-     optional.  For these "frameless" functions the frame pointer is
-     actually the frame pointer of the calling frame. */
-  cache->base = frame_unwind_register_unsigned (next_frame, FP_REGNUM);
-  if (cache->base == 0)
-    return cache;
-
   cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
   current_pc = frame_pc_unwind (next_frame);
   if (cache->pc != 0)
@@ -2623,20 +2602,28 @@
       sh_analyze_prologue (cache->pc, current_pc, cache, fpscr);
     }
 
-  if (!cache->uses_fp)
+  if (cache->uses_fp)
     {
-      /* We didn't find a valid frame, which means that CACHE->base
-	 currently holds the frame pointer for our calling frame.  If
-	 we're at the start of a function, or somewhere half-way its
-	 prologue, the function's frame probably hasn't been fully
-	 setup yet.  Try to reconstruct the base address for the stack
-	 frame by looking at the stack pointer.  For truly "frameless"
-	 functions this might work too.  */
+      /* For normal frames, fp holds the frame pointer, which holds the
+	 base address for the current stack frame.  */
+      cache->base = frame_unwind_register_unsigned (next_frame, FP_REGNUM);
+    }
+  else
+    {
+      /* No valid frame pointer was found.  If we are at the start of a
+	 function, or somewhere in its prologue, the function's frame
+	 probably has not been fully setup yet.  Instead assume that the
+	 base address of the current stack frame is the stack pointer.
+	 For truly "frameless" functions this might work too.  */
       cache->base = frame_unwind_register_unsigned
 		    (next_frame,
 		     gdbarch_sp_regnum (get_frame_arch (next_frame)));
     }
 
+  /* No discoverable stack frame.  */
+  if (cache->base == 0)
+    return cache;
+
   /* Now that we have the base address for the stack frame we can
      calculate the value of sp in the calling frame.  */
   cache->saved_sp = cache->base + cache->sp_offset;
@@ -2771,9 +2758,27 @@
   sh_frame_base_address
 };
 
+/* Check if a possible epilogue instruction. Note that on an SH2A a
+   MOVI20 is allowed for the epilogue.  */
+static int
+sh_is_epilogue_inst (ULONGEST inst, int is_a_sh2a)
+{
+  return IS_RTS (inst)
+      || IS_BRA (inst)
+      || IS_JMP (inst)
+      || IS_POP (inst)
+      || IS_POP_PR (inst)
+      || IS_POP_MACL (inst)
+      || IS_FPOP (inst)
+      || IS_MOV_FP_TO_SP (inst)
+      || IS_ADD_REG_TO_FP (inst)
+      || IS_ADD_IMM_TO_FP (inst)
+      || (is_a_sh2a && IS_MOVI20 (inst));
+}
+
 /* The epilogue is defined here as the area at the end of a function,
-   either on the `ret' instruction itself or after an instruction which
-   destroys the function's stack frame. */
+   either on the return instruction itself or the instructions which
+   destroy the function's stack frame.  */
 static int
 sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 {
@@ -2781,75 +2786,72 @@
 
   if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
     {
-      ULONGEST inst;
-      /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
-	 for a nop and some fixed data (e.g. big offsets) which are
-	 unfortunately also treated as part of the function (which
-	 means, they are below func_end. */
-      CORE_ADDR addr = func_end - 28;
-      if (addr < func_addr + 4)
-	addr = func_addr + 4;
-      if (pc < addr)
-	return 0;
-
-      /* First search forward until hitting an rts. */
-      while (addr < func_end
-	     && !IS_RTS (read_memory_unsigned_integer (addr, 2)))
-	addr += 2;
-      if (addr >= func_end)
-	return 0;
-
-      /* At this point we should find a mov.l @r15+,r14 instruction,
-	 either before or after the rts.  If not, then the function has
-	 probably no "normal" epilogue and we bail out here. */
-      inst = read_memory_unsigned_integer (addr - 2, 2);
-      if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2)))
-	addr -= 2;
-      else if (!IS_RESTORE_FP (read_memory_unsigned_integer (addr + 2, 2)))
-	return 0;
-
-      inst = read_memory_unsigned_integer (addr - 2, 2);
-
-      /* Step over possible lds.l @r15+,macl. */
-      if (IS_MACL_LDS (inst))
+      int is_a_sh2a =
+	gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a
+	|| gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu;
+
+      struct symtab_and_line sal = find_pc_line(func_end, 1);
+
+      /* Assume last sal in a function is the epilogue.  Note this will
+	 be incorrect if the function does not return (has no epilogue)
+	 or has multiple epilogues.  Check instruction at PC to confirm
+	 sal is actually the epilogue.  */
+      if ((sal.line != 0) && (sal.pc > func_addr) && (sal.end <= func_end))
 	{
-	  addr -= 2;
-	  inst = read_memory_unsigned_integer (addr - 2, 2);
-	}
+	  if (pc >= sal.pc)
+	    {
+	      ULONGEST inst = read_memory_unsigned_integer (pc, 2);
 
-      /* Step over possible lds.l @r15+,pr. */
-      if (IS_LDS (inst))
-	{
-	  addr -= 2;
-	  inst = read_memory_unsigned_integer (addr - 2, 2);
+	      if (sh_is_epilogue_inst (inst, is_a_sh2a))
+		return 1;
+	    }
 	}
-
-      /* Step over possible mov r14,r15. */
-      if (IS_MOV_FP_SP (inst))
+      else /* No line information so analyse instructions. */
 	{
-	  addr -= 2;
-	  inst = read_memory_unsigned_integer (addr - 2, 2);
-	}
+	  /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
+	     for a nop and some fixed data (e.g. big offsets) which are
+	     unfortunately also treated as part of the function (which
+	     means, they are below func_end. */
+	  ULONGEST inst;
+	  CORE_ADDR addr = func_end - 28;
+
+	  if (addr < func_addr + 4)
+	    addr = func_addr + 4;
+	  if (pc < addr)
+	    return 0;
+
+	  /* First search forwards for the end of the epilogue. This will be
+	     indicated by an RTS, a BRA (for relaxed code) or a JMP (for
+	     tail-call optimised code).  */
+	  while (addr < func_end)
+	    {
+	      inst = read_memory_unsigned_integer (addr, 2);
+	      if (IS_RTS (inst) || IS_BRA (inst) || IS_JMP (inst))
+	      	break;
+	      addr += 2;
+	    }
 
-      /* Now check for FP adjustments, using add #imm,r14 or add rX, r14
-	 instructions. */
-      while (addr > func_addr + 4
-	     && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
-	{
-	  addr -= 2;
+	  /* No epilogue found */
+	  if (addr >= func_end)
+	    return 0;
+
+	  /* Now search backwards for the start of the epilogue.  */
 	  inst = read_memory_unsigned_integer (addr - 2, 2);
-	}
+	  while (sh_is_epilogue_inst (inst, 0))
+	    {
+	      addr -= 2;
+	      inst = read_memory_unsigned_integer (addr - 2, 2);
+	    }
 
-      /* On SH2a check if the previous instruction was perhaps a MOVI20.
-	 That's allowed for the epilogue.  */
-      if ((gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a
-	   || gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu)
-	  && addr > func_addr + 6
-	  && IS_MOVI20 (read_memory_unsigned_integer (addr - 4, 2)))
-	addr -= 4;
+	  /* For the SH2A a MOVI20 is allowed in the epilogue.  */
+	  if (is_a_sh2a
+	    && (addr > func_addr + 6)
+	    && IS_MOVI20 (read_memory_unsigned_integer (addr - 4, 2)))
+	      addr -= 4;
 
-      if (pc >= addr)
-	return 1;
+	  if (pc >= addr)
+	    return 1;
+	}
     }
   return 0;
 }
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/shtdi.c insight/gdb/shtdi.c
--- gdb-6.8/gdb/shtdi.c	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/shtdi.c	2009-05-29 14:07:57.000000000 +0100
@@ -1,6 +1,6 @@
 /* STMicroelectronics Host-Target Debug Interface.
 
-   Copyright (C) 2006, 2007, 2008 STMicroelectronics  */
+   Copyright (C) 2006, 2007, 2008, 2009 STMicroelectronics  */
 
 #if defined(__MINGW32__) || defined(__CYGWIN__)
 #include <windows.h>
@@ -30,8 +30,13 @@
 #endif
 
 /**************************************************************************/
-/* Are we connected to a target?  */
-static int shtdi_targetconnected = 0;
+/* State of the target interface.  */
+static enum
+{
+  shtdi_state_none,
+  shtdi_state_initialized,
+  shtdi_state_attached
+} shtdi_target_state = shtdi_state_none;
 
 /* The name of the silicon target currently connected.  */
 static char *shtdi_targetName = NULL;
@@ -52,6 +57,9 @@
 /* Read all target registers?  */
 static int shtdi_read_all_registers = 1;
 
+/* Allow debugging to continue after exit?  */
+static int shtdi_continue_after_exit = 0;
+
 /**************************************************************************/
 /* SHDEBUG DLL loading routines */
 
@@ -1365,7 +1373,7 @@
   rtosReset = strtok (args, " ");
   if (strcmp (rtosReset, "all") == 0)
     {
-      if (shtdi_targetconnected)
+      if (shtdi_target_state == shtdi_state_attached)
 	{
 	  shdbg_RtosClearState ();
 	  if  (symfile_objfile != NULL)
@@ -1376,7 +1384,7 @@
     }
   else if (strcmp (rtosReset, "thread") == 0)
     {
-      if (shtdi_targetconnected)
+      if (shtdi_target_state == shtdi_state_attached)
 	shdbg_RtosClearTasks ();
     }
   else
@@ -1498,6 +1506,8 @@
 static int shtdi_stopped_by_watchpoint_p = 0;
 static CORE_ADDR shtdi_watch_data_address;
 
+static void shtdi_mourn_inferior_1 (void);
+
 /* GDB target routines.  */
 
 static void
@@ -1683,19 +1693,14 @@
  * Opens SHDEBUG DLL and sets up function pointers
  */
 static void
-shtdi_open_cleanup (void *nocleanup)
+shtdi_open_cleanup (void *d)
 {
-  int docleanup = !*((int *) nocleanup);
-
-  xfree (nocleanup);
-  if (docleanup)
-    unpush_target (&shtdi_ops);
+  unpush_target (&shtdi_ops);
 }
 
 static void
 shtdi_open (char *args, int from_tty)
 {
-  int *nocleanupflag = NULL;
   struct cleanup *old_chain = NULL;
 
   int argi = 0, argc = 0;
@@ -1705,7 +1710,7 @@
   char *shdbgdllname = NULL;
 
   /* Check if already connected using shtdi interface */
-  if (shtdi_targetconnected)
+  if (shtdi_target_state != shtdi_state_none)
     error (_("shtdi target interface already in use,"
 	     " please disconnect first"));
 
@@ -1842,27 +1847,25 @@
     shtdi_init_simulator_hook ();
 
   /* Ensure that we undo everything from this point on error */
-  nocleanupflag = xcalloc (1, sizeof (int));
-  old_chain = make_cleanup (shtdi_open_cleanup, nocleanupflag);
+  old_chain = make_cleanup (shtdi_open_cleanup, NULL);
 
   /* Attempt to load SHDEBUG DLL */
   shtdi_load_shdebug (shdbgdllname);
 
 #if SHDEBUGAPI_VERSION_MAX(1, 0)
   if (!shdbg_Initialise (argc, argv, shdbg_error_message_callback))
-    {
 #else
   if (!shdbg_Initialise (argc, argv, shdbg_print_message_callback,
 			 shdbg_error_message_callback))
-    {
 #endif
+    {
       if (shtdi_targetissimulator)
 	error (_("Unable to connect to simulator target"));
       else
 	error (_("Unable to connect to remote target %s"), shtdi_targetName);
     }
   else
-    shtdi_targetconnected = 1;
+    shtdi_target_state = shtdi_state_initialized;
   xfree (argv);
 
   push_target (&shtdi_ops);
@@ -1881,23 +1884,24 @@
       execute_command (inicommand, from_tty);
 
       /* Maybe disconnected from target, if so return immediately */
-      if (!shtdi_targetconnected)
+      if (shtdi_target_state == shtdi_state_none)
 	return;
     }
 
 #if SHDEBUGAPI_VERSION_MAX(1, 0)
   if (!shdbg_Attach ())
-    {
 #else
   /* Attach to target using default attach type */
   if (!shdbg_Attach (-1))
-    {
 #endif
+    {
       if (shtdi_targetissimulator)
 	error (_("Unable to attach to simulator target"));
       else
 	error (_("Unable to attach to remote target %s"), shtdi_targetName);
     }
+  else
+    shtdi_target_state = shtdi_state_attached;
 
   /* Enable access to target state */
   target_mark_running (&shtdi_ops);
@@ -1912,13 +1916,16 @@
   inferior_ptid = pid_to_ptid (MAGIC_TARGET_PID);
   start_remote (from_tty);
 
-  *nocleanupflag = 1;		/* Discard cleanups */
-  do_cleanups (old_chain);
+  discard_cleanups (old_chain);
 }
 
 static void
 shtdi_close_cleanup (void *d)
 {
+  /* Force disconnect */
+  if (shtdi_target_state != shtdi_state_none)
+    (void) shdbg_DeInitialise ();
+
   /* Reset state to initial values on target close */
   xfree (shtdi_targetName);
   shtdi_targetName = NULL;
@@ -1926,7 +1933,7 @@
   xfree (shtdi_execName);
   shtdi_execName = NULL;
 
-  shtdi_targetconnected = 0;
+  shtdi_target_state = shtdi_state_none;
   shtdi_targetissimulator = 0;
   shtdi_args_passed = 0;
   ioconsole_launched = 0;
@@ -1950,7 +1957,7 @@
 
   ioconsole_close ();
 
-  if (shtdi_targetconnected)
+  if (shtdi_target_state != shtdi_state_none)
     {
       delete_generic_cmds ();
       if (shtdi_targetissimulator)
@@ -1963,28 +1970,35 @@
 
       target_mark_exited (&shtdi_ops);
 
-#if SHDEBUGAPI_VERSION_MAX(1, 1)
-      if (!shdbg_Detach ())
+      if (shtdi_target_state == shtdi_state_attached)
 	{
+	  shtdi_target_state = shtdi_state_initialized;
+#if SHDEBUGAPI_VERSION_MAX(1, 1)
+	  if (!shdbg_Detach ())
 #else
-      /* Detach target using default detach type */
-      if (!shdbg_Detach (-1))
-	{
+	  /* Detach target using default detach type */
+	  if (!shdbg_Detach (-1))
 #endif
-	  if (shtdi_targetissimulator)
-	    error (_("Unable to detach from simulator target"));
-	  else
-	    error (_("Unable to detach from remote target %s"),
-		   shtdi_targetName);
+	    {
+	      if (shtdi_targetissimulator)
+		error (_("Unable to detach from simulator target"));
+	      else
+		error (_("Unable to detach from remote target %s"),
+		       shtdi_targetName);
+	    }
 	}
 
-      if (!shdbg_DeInitialise ())
+      if (shtdi_target_state == shtdi_state_initialized)
 	{
-	  if (shtdi_targetissimulator)
-	    error (_("Unable to disconnect from simulator target"));
-	  else
-	    error (_("Unable to disconnect from remote target %s"),
-		   shtdi_targetName);
+	  shtdi_target_state = shtdi_state_none;
+	  if (!shdbg_DeInitialise ())
+	    {
+	      if (shtdi_targetissimulator)
+		error (_("Unable to disconnect from simulator target"));
+	      else
+		error (_("Unable to disconnect from remote target %s"),
+		       shtdi_targetName);
+	    }
 	}
     }
 
@@ -2162,7 +2176,7 @@
 static void
 shtdi_kill (void)
 {
-  target_mourn_inferior ();
+  shtdi_mourn_inferior_1 ();
 }
 
 static void
@@ -2218,6 +2232,7 @@
   do_cleanups (old_chain);
 
   /* Tell wait_for_inferior that we've started a new process.  */
+  init_thread_list ();
   init_wait_for_inferior ();
 
   inferior_ptid = pid_to_ptid (MAGIC_TARGET_PID);
@@ -2516,6 +2531,10 @@
 static void
 shtdi_files_info (struct target_ops *target)
 {
+  if (shtdi_targetissimulator)
+    printf_filtered (_("Connected to a simulator target\n"));
+  else
+    printf_filtered (_("Connected to remote target %s\n"), shtdi_targetName);
 }
 
 static int
@@ -2748,18 +2767,31 @@
 }
 
 static void
-shtdi_mourn_inferior (void)
+shtdi_mourn_inferior_1 (void)
 {
-  shdbg_RtosClearState ();
   remove_breakpoints ();
+  shdbg_RtosClearState ();
+  shtdi_rtos_launched = 0;
   generic_mourn_inferior ();
 }
 
 static void
-shtdi_disconnect (struct target_ops *ops, char *args, int from_tty)
+shtdi_mourn_inferior (void)
+{
+  if (shtdi_continue_after_exit)
+    return;
+
+  shtdi_mourn_inferior_1 ();
+}
+
+static void
+shtdi_disconnect (struct target_ops *target, char *args, int from_tty)
 {
-  target_mourn_inferior ();
-  unpush_target (ops);
+  if (args)
+    error (_("Argument given to \"disconnect\" when remotely debugging."));
+
+  shtdi_mourn_inferior_1 ();
+  unpush_target (target);
 }
 
 static void
@@ -2850,7 +2882,7 @@
 static void
 shtdi_new_objfile (struct objfile *objfile)
 {
-  if (shtdi_targetconnected
+  if ((shtdi_target_state == shtdi_state_attached)
       && objfile == symfile_objfile)  /* Only check top objfile.  */
     rtos_check_symbols (objfile);
 }
@@ -2891,16 +2923,21 @@
 show_shtdi_rtos_thread_information (struct ui_file *file, int from_tty,
 				    struct cmd_list_element *c, const char *value)
 {
-  fprintf_filtered (file,
-    _("RTOS thread information is %s.\n"), value);
+  fprintf_filtered (file, _("RTOS thread information is %s.\n"), value);
 }
 
 static void
 show_shtdi_read_all_registers (struct ui_file *file, int from_tty,
 			       struct cmd_list_element *c, const char *value)
 {
-  fprintf_filtered (file,
-    _("Read all target registers is %s.\n"), value);
+  fprintf_filtered (file, _("Read all target registers is %s.\n"), value);
+}
+
+static void
+show_shtdi_continue_after_exit (struct ui_file *file, int from_tty,
+				struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("Continue after exit is %s.\n"), value);
 }
 
 /* For "set shtdi" and "show shtdi".  */
@@ -3029,6 +3066,15 @@
     show_shtdi_read_all_registers,
     &shtdi_set_cmdlist, &shtdi_show_cmdlist);
 
+  add_setshow_boolean_cmd ("continue-after-exit", class_stm,
+    &shtdi_continue_after_exit,
+    _("Set continue after exit."),
+    _("Show continue after exit."),
+    NULL,
+    NULL,
+    show_shtdi_continue_after_exit,
+    &shtdi_set_cmdlist, &shtdi_show_cmdlist);
+
   add_prefix_cmd ("shtdi", class_maintenance, maintenance_shtdi_command,
     _("Maintenance command for SHTDI internal state."),
     &shtdi_maintenance_cmdlist, "maintenance shtdi ", 0,  &maintenancelist);
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/symtab.c insight/gdb/symtab.c
--- gdb-6.8/gdb/symtab.c	2008-02-05 22:17:40.000000000 +0000
+++ insight/gdb/symtab.c	2008-11-18 21:01:42.000000000 +0000
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -4081,6 +4082,7 @@
   struct symtab_and_line prologue_sal;
   CORE_ADDR start_pc;
   CORE_ADDR end_pc;
+  struct block *bl;
 
   /* Get an initial range for the function.  */
   find_pc_partial_function (func_addr, NULL, &start_pc, &end_pc);
@@ -4089,11 +4091,35 @@
   prologue_sal = find_pc_line (start_pc, 0);
   if (prologue_sal.line != 0)
     {
+      /* For langauges other than assembly, treat two consecutive line
+	 entries at the same address as a zero-instruction prologue.
+	 The GNU assembler emits separate line notes for each instruction
+	 in a multi-instruction macro, but compilers generally will not
+	 do this.  */
+      if (prologue_sal.symtab->language != language_asm)
+	{
+	  struct linetable *linetable = LINETABLE (prologue_sal.symtab);
+	  int exact;
+	  int idx = 0;
+
+	  /* Skip any earlier lines, and any end-of-sequence marker
+	     from a previous function.  */
+	  while (linetable->item[idx].pc != prologue_sal.pc
+		 || linetable->item[idx].line == 0)
+	    idx++;
+
+	  if (idx+1 < linetable->nitems
+	      && linetable->item[idx+1].line != 0
+	      && linetable->item[idx+1].pc == start_pc)
+	    return start_pc;
+	}
+
       /* If there is only one sal that covers the entire function,
 	 then it is probably a single line function, like
 	 "foo(){}". */
       if (prologue_sal.end >= end_pc)
 	return 0;
+
       while (prologue_sal.end < end_pc)
 	{
 	  struct symtab_and_line sal;
@@ -4115,7 +4141,14 @@
 	  prologue_sal = sal;
 	}
     }
-  return prologue_sal.end;
+
+  if (prologue_sal.end < end_pc)
+    /* Return the end of this line, or zero if we could not find a
+       line.  */
+    return prologue_sal.end;
+  else
+    /* Don't return END_PC, which is past the end of the function.  */
+    return prologue_sal.pc;
 }
 
 struct symtabs_and_lines
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/utils.c insight/gdb/utils.c
--- gdb-6.8/gdb/utils.c	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/utils.c	2008-10-29 17:20:50.000000000 +0000
@@ -1172,7 +1172,7 @@
 
   /* Automatically answer the default value if input is not from the user
      directly, or if the user did not want prompts.  */
-  if (!input_from_terminal_p () || !caution)
+  if (!input_from_terminal_p () || !caution || ui_out_is_mi_like_p (uiout))
     return def_value;
 
   if (deprecated_query_hook)
diff -Naur --exclude gdbtk --exclude tk --exclude tcl --exclude sim --exclude itcl --exclude libgui gdb-6.8/gdb/version.in insight/gdb/version.in
--- gdb-6.8/gdb/version.in	2009-07-06 13:36:42.000000000 +0100
+++ insight/gdb/version.in	2008-10-10 12:10:12.000000000 +0100
@@ -1 +1 @@
-6.8-ST-2.0
+6.8-ST-2.0-ST40
