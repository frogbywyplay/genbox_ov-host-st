Patch by Fred Riss <frederic.riss@st.com> to fix hardware single-stepping
through TLB misses.

Signed-off-by: Chris Smith <chris.smith@st.com>

Index: gdb-6.8/gdb/linux-awareness.c
===================================================================
--- gdb-6.8.orig/gdb/linux-awareness.c
+++ gdb-6.8/gdb/linux-awareness.c
@@ -1357,12 +1357,16 @@ become unreliable due to code memory get
 breakpoints have been disabled.");
 }
 
+static int stepping;
+
 static void
 linux_aware_resume (ptid_t pid, int step, enum target_signal sig)
 {
     DEBUG (TARGET, 1,"Resuming %i with sig %i (step %i)\n",
 	   (int)ptid_get_pid(pid), (int)sig, step);
 
+    stepping = step;
+
     if (linux_awareness_ops->lo_pre_exec_start) {
 	thread_awareness_inhibit ();
 	linux_awareness_ops->lo_pre_exec_start ();
@@ -3154,6 +3158,7 @@ static ptid_t
 linux_aware_wait (ptid_t ptid, struct target_waitstatus *status)
 {
     ptid_t res = linux_aware_pid_to_ptid (0);
+    static CORE_ADDR last_stop_pc;
 
     if (!loaded || thread_awareness_inhibited ()) {
 	res = linux_aware_ops.beneath->to_wait (ptid, status);
@@ -3170,6 +3175,16 @@ linux_aware_wait (ptid_t ptid, struct ta
     res = linux_aware_ops.beneath->to_wait (ptid, status);
     running = 0;
 
+    if (!use_software_singlestep && stepping
+	&& !linux_aware_in_dynsym_resolve_code (last_stop_pc)) {
+	while (linux_aware_in_dynsym_resolve_code (read_pc ())) {
+	    linux_aware_ops.beneath->to_resume (pid_to_ptid (-1), 1, TARGET_SIGNAL_0);
+	    registers_changed ();
+
+	    res = linux_aware_ops.beneath->to_wait (ptid, status);
+	}
+    }
+
     if (linux_awareness_ops->lo_post_exec_stop)
 	linux_awareness_ops->lo_post_exec_stop ();
 
@@ -3180,6 +3195,8 @@ linux_aware_wait (ptid_t ptid, struct ta
 	ptid_t ptid = linux_aware_pid_to_ptid (pid);
 	int new_last_pid = -1;
 
+	last_stop_pc = pc;
+
 	if (HAS_ADDR(init_pid_ns)) {
 	    /* Since STLinux 2.3 (2.6.23) */
 	    new_last_pid = read_signed_field(ADDR(init_pid_ns),
