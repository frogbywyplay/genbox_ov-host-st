diff -Naur gdb-6.8/bfd/archures.c stsgdb-6.8/bfd/archures.c
--- gdb-6.8/bfd/archures.c	2008-02-04 19:15:50.000000000 +0000
+++ stsgdb-6.8/bfd/archures.c	2008-09-11 10:34:22.000000000 +0100
@@ -3,6 +3,7 @@
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
    Hacked by John Gilmore and Steve Chamberlain of Cygnus Support.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -264,6 +265,11 @@
 .#define bfd_mach_sh4        0x40
 .#define bfd_mach_sh4_nofpu  0x41
 .#define bfd_mach_sh4_nommu_nofpu  0x42
+.#define bfd_mach_st40_300   0x430
+.#define bfd_mach_st40_300_nofpu 0x431
+.#define bfd_mach_st40_300_nofpu_or_sh2a_nofpu 0x432
+.#define bfd_mach_st40_300_nofpu_or_sh4a_nofpu 0x433
+.#define bfd_mach_st40_300_or_sh4a 0x434
 .#define bfd_mach_sh4a       0x4a
 .#define bfd_mach_sh4a_nofpu 0x4b
 .#define bfd_mach_sh4al_dsp  0x4d
diff -Naur gdb-6.8/bfd/bfd.c stsgdb-6.8/bfd/bfd.c
--- gdb-6.8/bfd/bfd.c	2008-01-25 16:18:40.000000000 +0000
+++ stsgdb-6.8/bfd/bfd.c	2008-09-11 10:34:22.000000000 +0100
@@ -850,6 +850,7 @@
        BFD_VERSION_STRING, file, line);
   (*_bfd_error_handler) (_("Please report this bug.\n"));
   _exit (EXIT_FAILURE);
+  exit(EXIT_FAILURE);  /* Make sure the compiler knows this doesn't return.  */
 }
 
 /*
diff -Naur gdb-6.8/bfd/bfd-in2.h stsgdb-6.8/bfd/bfd-in2.h
--- gdb-6.8/bfd/bfd-in2.h	2008-02-20 15:17:56.000000000 +0000
+++ stsgdb-6.8/bfd/bfd-in2.h	2008-09-11 10:34:22.000000000 +0100
@@ -10,6 +10,7 @@
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    Contributed by Cygnus Support.
 
@@ -1941,6 +1942,11 @@
 #define bfd_mach_sh4        0x40
 #define bfd_mach_sh4_nofpu  0x41
 #define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_st40_300   0x430
+#define bfd_mach_st40_300_nofpu 0x431
+#define bfd_mach_st40_300_nofpu_or_sh2a_nofpu 0x432
+#define bfd_mach_st40_300_nofpu_or_sh4a_nofpu 0x433
+#define bfd_mach_st40_300_or_sh4a 0x434
 #define bfd_mach_sh4a       0x4a
 #define bfd_mach_sh4a_nofpu 0x4b
 #define bfd_mach_sh4al_dsp  0x4d
diff -Naur gdb-6.8/bfd/ChangeLog.sts-gdb stsgdb-6.8/bfd/ChangeLog.sts-gdb
--- gdb-6.8/bfd/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/bfd/ChangeLog.sts-gdb	2008-09-11 10:34:22.000000000 +0100
@@ -0,0 +1,18 @@
+2007-09-14  Antony King  <antony.king@st.com>
+
+	Fix INSbl27871:
+	* config.bfd: Add sh*-superh-elf* target.
+
+2006-10-17  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* bfd.c (_bfd_abort): Add exit to silence a warning from GCC 2.95.2.
+
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* archures.c: Add st40-300 variants.
+	* bfd-in2.h: Likewise.
+	* cpu-sh.c: Likewise.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* po/Make-in: Do the 'chmod -w' after the move. Cygwin prefers it.
diff -Naur gdb-6.8/bfd/config.bfd stsgdb-6.8/bfd/config.bfd
--- gdb-6.8/bfd/config.bfd	2008-02-14 15:20:24.000000000 +0000
+++ stsgdb-6.8/bfd/config.bfd	2008-09-11 10:34:22.000000000 +0100
@@ -1262,7 +1262,7 @@
     ;;
 
 #ifdef BFD64
-  shl*-*-elf* | sh[1234]l*-*-elf* | sh3el*-*-elf* | shl*-*-kaos*)
+  sh*-superh-elf* | shl*-*-elf* | sh[1234]l*-*-elf* | sh3el*-*-elf* | shl*-*-kaos*)
     targ_defvec=bfd_elf32_shl_vec
     targ_selvecs="bfd_elf32_sh_vec shlcoff_vec shcoff_vec shlcoff_small_vec shcoff_small_vec bfd_elf32_sh64_vec bfd_elf32_sh64l_vec bfd_elf64_sh64_vec bfd_elf64_sh64l_vec"
     targ_underscore=yes
diff -Naur gdb-6.8/bfd/cpu-sh.c stsgdb-6.8/bfd/cpu-sh.c
--- gdb-6.8/bfd/cpu-sh.c	2007-07-03 15:26:40.000000000 +0100
+++ stsgdb-6.8/bfd/cpu-sh.c	2008-09-11 10:34:22.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright 1993, 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
    2007 Free Software Foundation, Inc.
    Hacked by Steve Chamberlain of Cygnus Support.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -45,6 +46,11 @@
 #define SH2A_NOFPU_OR_SH3_NOMMU_NEXT       arch_info_struct + 17
 #define SH2A_OR_SH4_NEXT                   arch_info_struct + 18
 #define SH2A_OR_SH3E_NEXT                  arch_info_struct + 19
+#define ST40_300_NOFPU_OR_SH2A_NOFPU_NEXT  arch_info_struct + 20
+#define ST40_300_NOFPU_OR_SH4A_NOFPU_NEXT  arch_info_struct + 21
+#define ST40_300_NOFPU_NEXT                arch_info_struct + 22
+#define ST40_300_OR_SH4A_NEXT              arch_info_struct + 23
+#define ST40_300_NEXT                      arch_info_struct + 24
 #define SH64_NEXT                          NULL
 
 static const bfd_arch_info_type arch_info_struct[] =
@@ -316,6 +322,76 @@
     SH2A_OR_SH3E_NEXT
   },
   {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_nofpu_or_sh2a_nofpu,
+    "sh",			/* Architecture name.  */
+    "st40-300-nofpu-or-sh2a-nofpu",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NOFPU_OR_SH2A_NOFPU_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_nofpu_or_sh4a_nofpu,
+    "sh",			/* Architecture name.  */
+    "st40-300-nofpu-or-sh4a-nofpu",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NOFPU_OR_SH4A_NOFPU_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_nofpu,
+    "sh",			/* Architecture name.  */
+    "st40-300-nofpu",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NOFPU_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_or_sh4a,
+    "sh",			/* Architecture name.  */
+    "st40-300-or-sh4a",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_OR_SH4A_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300,
+    "sh",			/* Architecture name.  */
+    "st40-300",			/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NEXT
+  },
+  {
     64,				/* 64 bits in a word.  */
     64,				/* 64 bits in an address.  */
     8,				/* 8 bits in a byte.  */
@@ -378,6 +454,12 @@
   { bfd_mach_sh4_nofpu,       arch_sh4_nofpu,       arch_sh4_nofpu_up },
   { bfd_mach_sh4_nommu_nofpu, arch_sh4_nommu_nofpu, arch_sh4_nommu_nofpu_up },
   { bfd_mach_sh4a_nofpu,      arch_sh4a_nofpu,      arch_sh4a_nofpu_up },
+
+  { bfd_mach_st40_300_nofpu_or_sh2a_nofpu,           arch_st40_300_nofpu_or_sh2a_nofpu,	  arch_st40_300_nofpu_or_sh2a_nofpu_up },
+  { bfd_mach_st40_300_nofpu_or_sh4a_nofpu,           arch_st40_300_nofpu_or_sh4a_nofpu,	  arch_st40_300_nofpu_or_sh4a_nofpu_up },
+  { bfd_mach_st40_300_nofpu,  arch_st40_300_nofpu,   arch_st40_300_nofpu_up },
+  { bfd_mach_st40_300_or_sh4a,arch_st40_300_or_sh4a, arch_st40_300_or_sh4a_up },
+  { bfd_mach_st40_300,        arch_st40_300,         arch_st40_300_up },
   { 0, 0, 0 }   /* Terminator.  */
 };
 
diff -Naur gdb-6.8/bfd/doc/archures.texi stsgdb-6.8/bfd/doc/archures.texi
--- gdb-6.8/bfd/doc/archures.texi	2008-03-27 18:25:38.000000000 +0000
+++ stsgdb-6.8/bfd/doc/archures.texi	2008-09-11 10:34:11.000000000 +0100
@@ -229,6 +229,11 @@
 #define bfd_mach_sh4        0x40
 #define bfd_mach_sh4_nofpu  0x41
 #define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_st40_300   0x430
+#define bfd_mach_st40_300_nofpu 0x431
+#define bfd_mach_st40_300_nofpu_or_sh2a_nofpu 0x432
+#define bfd_mach_st40_300_nofpu_or_sh4a_nofpu 0x433
+#define bfd_mach_st40_300_or_sh4a 0x434
 #define bfd_mach_sh4a       0x4a
 #define bfd_mach_sh4a_nofpu 0x4b
 #define bfd_mach_sh4al_dsp  0x4d
diff -Naur gdb-6.8/bfd/doc/bfd.info stsgdb-6.8/bfd/doc/bfd.info
--- gdb-6.8/bfd/doc/bfd.info	2008-03-27 18:25:38.000000000 +0000
+++ stsgdb-6.8/bfd/doc/bfd.info	2008-09-11 10:34:11.000000000 +0100
@@ -1,4 +1,4 @@
-This is bfd.info, produced by makeinfo version 4.8 from bfd.texinfo.
+This is bfd.info, produced by makeinfo version 4.11 from bfd.texinfo.
 
 START-INFO-DIR-ENTRY
 * Bfd: (bfd).                   The Binary File Descriptor library.
@@ -7102,9 +7102,9 @@
 each object file or archive which is to be linked (typically these are
 the files named on the command line, but some may also come from the
 linker script).  The entry point is responsible for examining the file.
-For an object file, BFD must add any relevant symbol information to
-the hash table.  For an archive, BFD must determine which elements of
-the archive should be used and adding them to the link.
+For an object file, BFD must add any relevant symbol information to the
+hash table.  For an archive, BFD must determine which elements of the
+archive should be used and adding them to the link.
 
    The a.out version of this entry point is
 `NAME(aout,link_add_symbols)'.
@@ -8993,20 +8993,19 @@
      H. Include an unaltered copy of this License.
      I. Preserve the section entitled "History", and its title, and add
      to    it an item stating at least the title, year, new authors, and
-       publisher of the Modified Version as given on the Title Page.
-     If    there is no section entitled "History" in the Document,
-     create one    stating the title, year, authors, and publisher of
-     the Document as    given on its Title Page, then add an item
+       publisher of the Modified Version as given on the Title Page.  If
+       there is no section entitled "History" in the Document, create
+     one    stating the title, year, authors, and publisher of the
+     Document as    given on its Title Page, then add an item
      describing the Modified    Version as stated in the previous
      sentence.
      J. Preserve the network location, if any, given in the Document for
-       public access to a Transparent copy of the Document, and
-     likewise    the network locations given in the Document for
-     previous versions    it was based on.  These may be placed in the
-     "History" section.     You may omit a network location for a work
-     that was published at    least four years before the Document
-     itself, or if the original    publisher of the version it refers
-     to gives permission.
+       public access to a Transparent copy of the Document, and likewise
+       the network locations given in the Document for previous versions
+       it was based on.  These may be placed in the "History" section.
+       You may omit a network location for a work that was published at
+       least four years before the Document itself, or if the original
+      publisher of the version it refers to gives permission.
      K. In any section entitled "Acknowledgements" or "Dedications",
      preserve the section's title, and preserve in the section all the
       substance and tone of each of the contributor acknowledgements
@@ -10629,67 +10628,67 @@
 
 
 Tag Table:
-Node: Top1045
-Node: Overview1384
-Node: History2435
-Node: How It Works3381
-Node: What BFD Version 2 Can Do4924
-Node: BFD information loss6239
-Node: Canonical format8771
-Node: BFD front end13143
-Node: Memory Usage40479
-Node: Initialization41707
-Node: Sections42166
-Node: Section Input42649
-Node: Section Output44014
-Node: typedef asection46500
-Node: section prototypes71081
-Node: Symbols80761
-Node: Reading Symbols82356
-Node: Writing Symbols83463
-Node: Mini Symbols85172
-Node: typedef asymbol86146
-Node: symbol handling functions91407
-Node: Archives96749
-Node: Formats100475
-Node: Relocations103423
-Node: typedef arelent104150
-Node: howto manager119961
-Node: Core Files187149
-Node: Targets188966
-Node: bfd_target190936
-Node: Architectures211241
-Node: Opening and Closing233527
-Node: Internal244791
-Node: File Caching251124
-Node: Linker Functions253038
-Node: Creating a Linker Hash Table254711
-Node: Adding Symbols to the Hash Table256449
-Node: Differing file formats257349
-Node: Adding symbols from an object file259074
-Node: Adding symbols from an archive261225
-Node: Performing the Final Link263639
-Node: Information provided by the linker264881
-Node: Relocating the section contents266035
-Node: Writing the symbol table267786
-Node: Hash Tables270828
-Node: Creating and Freeing a Hash Table272026
-Node: Looking Up or Entering a String273276
-Node: Traversing a Hash Table274529
-Node: Deriving a New Hash Table Type275318
-Node: Define the Derived Structures276384
-Node: Write the Derived Creation Routine277465
-Node: Write Other Derived Routines280089
-Node: BFD back ends281404
-Node: What to Put Where281674
-Node: aout281854
-Node: coff288172
-Node: elf312649
-Node: mmo313512
-Node: File layout314440
-Node: Symbol-table320087
-Node: mmo section mapping323856
-Node: GNU Free Documentation License327508
-Node: BFD Index347237
+Node: Top1046
+Node: Overview1385
+Node: History2436
+Node: How It Works3382
+Node: What BFD Version 2 Can Do4925
+Node: BFD information loss6240
+Node: Canonical format8772
+Node: BFD front end13144
+Node: Memory Usage40480
+Node: Initialization41708
+Node: Sections42167
+Node: Section Input42650
+Node: Section Output44015
+Node: typedef asection46501
+Node: section prototypes71082
+Node: Symbols80762
+Node: Reading Symbols82357
+Node: Writing Symbols83464
+Node: Mini Symbols85173
+Node: typedef asymbol86147
+Node: symbol handling functions91408
+Node: Archives96750
+Node: Formats100476
+Node: Relocations103424
+Node: typedef arelent104151
+Node: howto manager119962
+Node: Core Files187150
+Node: Targets188967
+Node: bfd_target190937
+Node: Architectures211242
+Node: Opening and Closing233528
+Node: Internal244792
+Node: File Caching251125
+Node: Linker Functions253039
+Node: Creating a Linker Hash Table254712
+Node: Adding Symbols to the Hash Table256450
+Node: Differing file formats257350
+Node: Adding symbols from an object file259075
+Node: Adding symbols from an archive261226
+Node: Performing the Final Link263640
+Node: Information provided by the linker264882
+Node: Relocating the section contents266036
+Node: Writing the symbol table267787
+Node: Hash Tables270829
+Node: Creating and Freeing a Hash Table272027
+Node: Looking Up or Entering a String273277
+Node: Traversing a Hash Table274530
+Node: Deriving a New Hash Table Type275319
+Node: Define the Derived Structures276385
+Node: Write the Derived Creation Routine277466
+Node: Write Other Derived Routines280090
+Node: BFD back ends281405
+Node: What to Put Where281675
+Node: aout281855
+Node: coff288173
+Node: elf312650
+Node: mmo313513
+Node: File layout314441
+Node: Symbol-table320088
+Node: mmo section mapping323857
+Node: GNU Free Documentation License327509
+Node: BFD Index347226
 
 End Tag Table
diff -Naur gdb-6.8/bfd/doc/ChangeLog.sts-gdb stsgdb-6.8/bfd/doc/ChangeLog.sts-gdb
--- gdb-6.8/bfd/doc/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/bfd/doc/ChangeLog.sts-gdb	2008-09-11 10:34:11.000000000 +0100
@@ -0,0 +1,5 @@
+2007-10-02  Antony King  <antony.king@st.com>
+
+	* chew.c (main): Add calls to CYGPATH() and CYGPATH_FREE().
+	* Makefile.am: Add libiberty.a to $(MKDOC).
+	* Makefile.in: Regenerate.
diff -Naur gdb-6.8/bfd/doc/chew.c stsgdb-6.8/bfd/doc/chew.c
--- gdb-6.8/bfd/doc/chew.c	2007-10-15 03:00:28.000000000 +0100
+++ stsgdb-6.8/bfd/doc/chew.c	2008-09-11 10:34:11.000000000 +0100
@@ -84,6 +84,7 @@
    Foo.  */
 
 #include "ansidecl.h"
+#include "libiberty.h"
 #include <assert.h>
 #include <stdio.h>
 #include <ctype.h>
@@ -1532,11 +1533,14 @@
 	{
 	  if (av[i][1] == 'f')
 	    {
+	      char *s = av[i + 1];
 	      string_type b;
 	      FILE *f;
 	      init_string (&b);
 
-	      f = fopen (av[i + 1], "r");
+	      CYGPATH (s);
+	      f = fopen (s, "r");
+	      CYGPATH_FREE (s);
 	      if (!f)
 		{
 		  fprintf (stderr, "Can't open the input file %s\n",
diff -Naur gdb-6.8/bfd/doc/Makefile.am stsgdb-6.8/bfd/doc/Makefile.am
--- gdb-6.8/bfd/doc/Makefile.am	2007-04-09 16:36:44.000000000 +0100
+++ stsgdb-6.8/bfd/doc/Makefile.am	2008-09-11 10:34:11.000000000 +0100
@@ -62,7 +62,7 @@
 $(MKDOC): $(srcdir)/chew.c
 	$(CC_FOR_BUILD) -o chew.$$$$ $(srcdir)/chew.c \
 	  $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $(H_CFLAGS) \
-	  $(INCLUDES); \
+	  $(INCLUDES) ../../libiberty/libiberty.a; \
 	$(SHELL) $(srcdir)/../../move-if-change chew.$$$$ $(MKDOC)
 
 chew.o: chew.c
diff -Naur gdb-6.8/bfd/doc/Makefile.in stsgdb-6.8/bfd/doc/Makefile.in
--- gdb-6.8/bfd/doc/Makefile.in	2008-02-14 15:20:26.000000000 +0000
+++ stsgdb-6.8/bfd/doc/Makefile.in	2008-09-11 10:34:11.000000000 +0100
@@ -613,7 +613,7 @@
 $(MKDOC): $(srcdir)/chew.c
 	$(CC_FOR_BUILD) -o chew.$$$$ $(srcdir)/chew.c \
 	  $(CFLAGS_FOR_BUILD) $(LDFLAGS_FOR_BUILD) $(H_CFLAGS) \
-	  $(INCLUDES); \
+	  $(INCLUDES) ../../libiberty/libiberty.a; \
 	$(SHELL) $(srcdir)/../../move-if-change chew.$$$$ $(MKDOC)
 
 chew.o: chew.c
diff -Naur gdb-6.8/bfd/po/Make-in stsgdb-6.8/bfd/po/Make-in
--- gdb-6.8/bfd/po/Make-in	2007-08-17 02:04:48.000000000 +0100
+++ stsgdb-6.8/bfd/po/Make-in	2008-09-11 10:34:16.000000000 +0100
@@ -1,6 +1,7 @@
 # Makefile for program source directory in GNU NLS utilities package.
 # Copyright (C) 1995, 1996, 1997 by Ulrich Drepper <drepper@gnu.ai.mit.edu>
 # Copyright 2001, 2003, 2006 Free Software Foundation, Inc.
+# Copyright (C) 2006 STMicroelectronics
 #
 # This file may be copied and used freely without restrictions.  It can
 # be used in projects which are not available under the GNU Public License
@@ -257,8 +258,8 @@
 	            -e '/^[ 	]*$$/d' \
 		    -e "s@.*@	$$posrcprefix& \\\\@" < $(srcdir)/$@.in \
 		| sed -e '$$s/\\$$//') > $@-t \
-	    && chmod a-w $@-t \
-	    && mv $@-t $@ )
+	    && mv $@-t $@ \
+	    && chmod a-w $@ )
 
 BLD-POTFILES: BLD-POTFILES.in
 	  ( rm -f $@-t $@ \
@@ -266,8 +267,8 @@
 	            -e '/^[ 	]*$$/d' \
 		    -e "s@.*@	../& \\\\@" < $(srcdir)/$@.in \
 		| sed -e '$$s/\\$$//') > $@-t \
-	    && chmod a-w $@-t \
-	    && mv $@-t $@ )
+	    && mv $@-t $@ \
+	    && chmod a-w $@ )
 
 SRC-POTFILES.in: @MAINT@ ../Makefile
 	cd .. && $(MAKE) po/SRC-POTFILES.in
diff -Naur gdb-6.8/ChangeLog stsgdb-6.8/ChangeLog
--- gdb-6.8/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/ChangeLog	2008-09-11 10:35:42.000000000 +0100
@@ -0,0 +1,11378 @@
+2006-05-14  Ben Elliston  <bje@au.ibm.com>
+
+	* config.sub, config.guess: Update from upstream sources.
+
+2006-05-12  Ben Elliston  <bje@au.ibm.com>
+
+	* config.sub, config.guess: Update from upstream sources.
+
+2006-05-04  Steve Ellcey  <sje@cup.hp.com>
+
+	* blt, iwidgets, mmalloc: Remove directories.
+
+2006-05-01  DJ Delorie  <dj@redhat.com>
+
+	* configure.in: Restore CFLAGS if GMP isn't present.
+	* configure: Regenerate.
+
+2006-04-18  DJ Delorie  <dj@redhat.com>
+
+	* configure.in (m32c): Build libstdc++-v3.  Pass flags to
+	reference libgloss so that libssp can be built in a combined
+	tree.
+	* configure: Regenerate.
+
+2006-04-10  Ben Elliston  <bje@au.ibm.com>
+
+	* contrib: Remove directory.
+
+2006-04-06  Carlos O'Donell <carlos@codesourcery.com>
+
+	* Makefile.tpl: Add install-html target.
+	* Makefile.def: Add install-html target.
+	* Makefile.in: Regenerate.
+	* configure.in: Add --with-datarootdir, --with-docdir,
+	and --with-htmldir options.
+	* configure: Regenerate.
+
+2006-03-31  Ben Elliston  <bje@au.ibm.com>
+
+	PR binutils/1860
+	* configure.in: Require makeinfo 4.4 or higher.
+	* configure: Regenerate.
+
+2006-03-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.in: Regenerate.
+
+2006-03-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync with gcc:
+	2006-03-10  Aldy Hernandez  <aldyh@redhat.com>
+
+        * configure.in: Handle --disable-<component> generically.
+        * configure: Regenerate.
+
+	2006-02-21 Rafael Avila de Espindola <rafael.espindola@gmail.com>
+        
+        * Makefile.tpl  (BUILD_CONFIGDIRS): Remove.
+        (TARGET_CONFIGDIRS): Remove.
+        * configure.in: Remove AC_SUBST(target_configdirs).
+        * Makefile.in, configure: Regenerated.
+
+
+2006-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libgcj/17311
+	* ltmain.sh: Don't use "$finalize_rpath" for compile.
+
+2006-02-20  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/25670
+
+	* Makefile.tpl ([+compare-target+]): Print explanation messages.
+
+	* Makefile.def (ADAFLAGS, BOOT_ADAFLAGS, LANGUAGES): New flags_to_pass.
+	* Makefile.tpl (BASE_FLAGS_TO_PASS): Support optional flags_to_pass.
+	(EXTRA_GCC_FLAGS): Remove ADAFLAGS, BOOT_ADAFLAGS, LANGUAGES,
+	BUILD_PREFIX, BUILD_PREFIX_1.
+	* configure.in: (BUILD_PREFIX, BUILD_PREFIX_1): Don't substitute.
+
+	* Makefile.def (bootstrap stage 1): Pass LIBCFLAGS too.
+	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Override LIBCFLAGS too.
+
+	* Makefile.tpl (configure-stage[+id+]-[+prefix+][+module+],
+	all-stage[+id+]-[+prefix+][+module+], : Use $(current_stage) instead
+	of `cat stage_current`.  Always provide the `r' and `s' variables.
+	(clean-stage[+id+]-[+prefix+][+module+]): Likewise, and make it into
+	a single shell execution.
+	(configure-[+prefix+][+module+], all-[+prefix+][+module+]): For
+	bootstrapped modules, make the stage1 module if the build was not
+	started yet, else build the current stage.
+	(all-host, all-target): Omit bootstrapped modules (if bootstrapping).
+	(all-build, all-host, all-target, [+make_target+]-host,
+	[+make_target+]-target): Do not use \-continued lines.
+	(target modules): Depend on stage_last, not all-gcc, if bootstrapping.
+	(current_stage, restrap, stage_last): New.
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2006-02-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc:
+
+	2006-01-31  Richard Guenther  <rguenther@suse.de>
+		    Paolo Bonzini  <bonzini@gnu.org>
+
+        * Makefile.def (target_modules): Add libgcc-math target module.
+        * configure.in (target_libraries): Add libgcc-math target library.
+        (--enable-libgcc-math): New configure switch.
+        * Makefile.in: Re-generate.
+        * configure: Re-generate.
+        * libgcc-math: New toplevel directory.
+
+	2006-01-18  Richard Henderson  <rth@redhat.com>
+	            Jakub Jelinek  <jakub@redhat.com>
+	            Diego Novillo  <dnovillo@redhat.com>
+
+        * libgomp: New directory.
+        * Makefile.def: Add target_module libgomp.
+        * Makefile.in: Regenerate.
+        * configure.in (target_libraries): Add target-libgomp.
+        * configure: Regenerate.
+
+2006-02-14  Paolo Bonzini  <bonzini@gnu.org>
+	    Andreas Schwab  <schwab@suse.de>
+	 
+	* configure: Regenerate.
+
+2006-01-16  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Set with_gnu_as, with_gnu_ld, with_newlib earlier.
+	Set md_exec_prefix.  Use ACX_CHECK_INSTALLED_TARGET_TOOL to find
+	the assembler, linker and binutils.
+	* configure: Regenerate.
+
+2006-01-16  Nick Clifton  <nickc@redhat.com>
+
+	* config.sub, config.guess: Sync from config repository.
+
+2006-01-05  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (clean-stage[+id+]-[+prefix+][+module+]): Remove
+	@ from continuation.
+	* Makefile.in: Rebuilt.
+
+2006-01-04  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc:
+
+	2006-01-04  Paolo Bonzini  <bonzini@gnu.org>
+
+        PR bootstrap/24252
+
+        * Makefile.def (flags_to_pass): Add STAGE1_CFLAGS and STAGE1_LANGUAGES.
+        * Makefile.tpl (OBJDUMP): New.
+        (EXTRA_HOST_FLAGS): Add it.
+        (EXTRA_GCC_FLAGS): Remove flags already specified in flags_to_pass.
+
+        * Makefile.tpl (stage[+id+]-start, stage[+id+]-end): Do not try
+        to use symbolic links between directories.  Avoid race conditions
+        or make them harmless.
+        * configure.in: Do not try to use symbolic links between directories.
+
+        * Makefile.def (LEAN): Pass.
+        * Makefile.tpl (LEAN): Define.
+        (stage[+id+]-start): Accept that the previous directory does not
+        exist, if the bootstrap is lean.
+        (stage[+id+]-bubble): Invoke lean bootstrap commands after
+        stage[+id+]-start.  Use a makefile variable and an `if' instead of a
+        configure substitution.
+        ([+compare-target+]): Likewise.
+        ([+bootstrap-target+]-lean): New.
+        * configure.in: Remove lean bootstrap support from here.
+
+        * Makefile.in: Regenerate.
+        * configure: Regenerate.
+
+	2006-01-02  Andreas Schwab  <schwab@suse.de>
+
+        * configure.in: When reconfiguring remove Makefile in
+        all stage directories.
+        * configure: Regenerate.
+
+2005-12-27  Leif Ekblad  <leif@rdos.net>
+
+	* configure.in: Add support for RDOS target.
+	* configure: Regenerate.
+
+2005-12-27  Nick Clifton  <nickc@redhat.com>
+
+	PR binutils/1990
+	* libtool.m4: Synchronize with version in GCC sources.
+
+2005-12-20  Paolo Bonzini  <bonzini@gnu.org>
+
+        Revert Ada-related part of the previous change.
+
+        * Makefile.def (ADAFLAGS, BOOT_ADAFLAGS, ADAFLAGS_FOR_TARGET):
+        Do not pass.
+        * Makefile.tpl (BOOT_ADAFLAGS): Do not define.
+        * Makefile.in: Regenerate.
+        * configure.in: Do not include mt-ppc-aix target fragment.
+        * configure: Regenerate.
+
+2005-12-19  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Select appropriate fragments for PowerPC/AIX.
+	* configure: Regenerate.
+
+	* Makefile.def (flags_to_pass): Add ADAFLAGS, BOOT_ADAFLAGS,
+	BOOT_CFLAGS, BOOT_LDFLAGS.
+	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Handle BOOT_ADAFLAGS,
+	BOOT_CFLAGS, BOOT_LDFLAGS.
+	(TARGET_FLAGS_TO_PASS): Handle ADAFLAGS_FOR_TARGET.
+	(stage[+id+]-bubble): Pass flags recursively to the comparison target.
+	(stage): Fail if we cannot complete the work.
+	* Makefile.in: Regenerate.
+
+2005-12-16  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update copyright year for default
+	copyright.
+
+2005-12-15  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all, do-[+make_target+], do-check, install,
+	install-host-nogcc): Don't invoke $(stage) at the end.
+	* Makefile.in: Regenerate.
+
+2005-12-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Flip the top-level bootstrap switch.
+	* configure: Regenerate.
+
+	Merge from gcc:
+
+	2005-12-14  Daniel Jacobowitz  <dan@codesourcery.com>
+
+        * Makefile.tpl: Throughout the file, use : $(MAKE) along with
+        $(stage) and $(unstage).
+        (EXTRA_TARGET_FLAGS): Correct double-quoting.
+        (all): Remove stray semicolon.
+        (local-distclean): Don't handle multilib.tmp and multilib.out.
+        (install.all): Set $s for consistency.
+        (configure-[+prefix+][+module+]): Instead of [+deps+], handle
+        check_multilibs setting.  Always make the install directory.
+        (configure-stage[+id+]-[+prefix+][+module+]): Likewise.
+        Correct @if/@endif.
+        (all-stage[+id+]-[+prefix+][+module+]): Correct @if/@endif.
+        ($(TARGET_SUBDIR)/[+module+]/multilib.out): Remove.
+        (stage[+id+]-start, stage[+id+]-end): Stage $(TARGET_SUBDIR).
+        (multilib.out): Remove.
+        * Makefile.in: Regenerated.
+
+2005-12-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* config.sub: Replace ms1 arch with mt.  Allow ms1 as alias.
+	* configure.in: Replace ms1 arch with mt.
+	* configure: Rebuilt.
+
+2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync with gcc:
+
+2005-12-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* config.sub: Replace ms1 arch with mt.  Allow ms1 as alias.
+	* configure.in: Replace ms1 arch with mt.
+	* configure: Rebuilt.
+
+2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync with gcc:
+
+	2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
+
+        * configure.in (CONFIGURED_BISON, CONFIGURED_YACC, CONFIGURED_M4,
+        CONFIGURED_FLEX, CONFIGURED_LEX, CONFIGURED_MAKEINFO): Remove
+        "CONFIGURED_" from the AC_CHECK_PROGS invocation.  Move below.
+        Find in-tree tools if available.
+        (EXPECT, RUNTEST, LIPO, STRIP): Find them and substitute them.
+        (CONFIGURED_*_FOR_TARGET): Don't set nor substitute.
+        (*_FOR_TARGET): Set them with GCC_TARGET_TOOL.
+        (COMPILER_*_FOR_TARGET): New.
+        * Makefile.tpl (HOST_EXPORTS): Add *_FOR_TARGET symbols that gcc needs.
+        (BASE_TARGET_EXPORTS): Use COMPILER_*_FOR_TARGET symbols.
+        (CONFIGURED_*, USUAL_*): Remove.
+        (BISON, YACC, FLEX, LEX, M4, MAKEINFO, EXPECT, RUNTEST, LIPO,
+        STRIP): Use autoconf substitutions.
+        (COMPILER_AS_FOR_TARGET, COMPILER_LD_FOR_TARGET,
+        COMPILER_NM_FOR_TARGET): New.
+        (EXTRA_HOST_FLAGS): Pass LIPO and STRIP.
+
+        (all): Make all-host and all-target in parallel.
+        (do-[+make_target+], do-check, install, [+compare-target+]): Ensure
+        that $$r and $$s are set before invoking a recursive make.
+        (stage[+id+]-bubble): Likewise, and invoke the comparison at the end.
+        ([+bootstrap-target+]): Inline most of the `all' target.
+
+	2005-11-29  Ben Elliston  <bje@au.ibm.com>
+
+        * Makefile.tpl (clean-target-libgcc): Invoke clean-target-libgcc
+        from the gcc build directory.
+        * Makefile.in: Regenerate.
+
+	2005-11-29  Ben Elliston  <bje@au.ibm.com>
+
+        * Makefile.def: Add new libdecnumber host_module.  Make all-gcc
+        depend on all-libdecnumber.
+        * configure.in (host_libs): Include libdecnumber.
+        * Makefile.in: Regenerate.
+        * configure: Likewise.
+
+	2005-11-21  Kean Johnston  <jkj@sco.com>
+
+        * config.sub, config.guess: Sync from upstream sources.
+
+2005-11-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* Makefile.def: Remove gdb dependencies for gdbtk.
+	* Makefile.tpl (CONFIGURE_GDB_TK, INSTALL_GDB_TK): New variables.
+	(configure-gdb, install-gdb): New rules.
+	* configure.in: Set CONFIGURE_GDB_TK and INSTALL_GDB_TK.
+	* Makefile.in, configure: Regenerated.
+
+2005-10-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/24297
+	* Makefile.tpl (do-[+make-target+], do-check, install,
+	stage[+id+]-bubble, [+compare-target+]): Ensure $$r and $$s
+	are set before recursing.
+	* Makefile.in: Regenerate.
+
+2005-10-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR bootstrap/18939
+	* Makefile.def (gcc) <target>: Fix thinko.
+	* Makefile.in: Regenerate.
+
+2005-10-17  Bernd Schmidt  <bernd.schmidt@analog.com>
+
+	* configure.in (bfin-*-*): Use test, not brackets, in if statement.
+	* configure: Regenerate.
+
+2005-10-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	* configure.in (arm-*-linux-gnueabi): Add to noconfigdirs
+	target-libffi, target-qthreads, target-libjava, and
+	targetlibobjc.
+	* configure: Regenerate.
+
+2005-10-06  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* Makefile.def (flags_to_pass): Add OBJDUMP_FOR_TARGET.
+	* Makefile.tpl (BASE_TARGET_EXPORTS): Add OBJDUMP.
+	(OBJDUMP_FOR_TARGET, CONFIGURED_OBJDUMP_FOR_TARGET)
+	(USUAL_OBJDUMP_FOR_TARGET): New.
+	(EXTRA_TARGET_FLAGS): Add OBJDUMP.
+	* configure.in: Check for $OBJDUMP_FOR_TARGET.
+	* configure, Makefile.in: Regenerated.
+
+2005-10-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all) [gcc-no-bootstrap]: Make prebootstrap packages
+	before other host packages.
+
+2005-10-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/22340
+
+	* configure.in (default_target): Remove.
+	* Makefile.tpl (all): Do not use prerequisites as subroutines
+	(all) [gcc-bootstrap]: Bootstrap gcc first if it was not done yet.
+	(do-[+make_target+], check, install, [+bootstrap_target+]): Do not
+	use prerequisites as subroutines.
+	(check-host, check-target): New.
+	(bootstrap configure & all targets): Do not use stage*-start
+	if the directory layout is already ok.
+	(non-bootstrap configure & all targets): Prepend a $(unstage).
+	(stage[+id+]-bubble): Do that here.  Do not use NOTPARALLEL.
+	(NOTPARALLEL): Remove.
+	(unstage, stage variables): New variables.
+	(unstage, stage targets): Simply expand to those variables.
+
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2005-10-04  James E Wilson  <wilson@specifix.com>
+
+	* Makefile.def (lang_env_dependencies): Add libmudflap.
+	* Makefile.in: Regenerate.
+
+2005-10-03  Catherine Moore  <clm@cm00re.com>
+
+	* configure.in (bfin-*-*): Support bfin.
+	* configure: Regenerated.
+
+2005-09-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.in (*-*-darwin*): Build bfd, binutils and opcodes.
+	* configure: Regenerated.
+
+2005-09-28  Geoffrey Keating  <geoffk@apple.com>
+
+	* Makefile.tpl (BASE_TARGET_EXPORTS): Add LIPO, STRIP.
+	(LIPO_FOR_TARGET): New.
+	(CONFIGURED_LIPO_FOR_TARGET): New.
+	(USUAL_LIPO_FOR_TARGET): New.
+	(STRIP_FOR_TARGET): New.
+	(CONFIGURED_STRIP_FOR_TARGET): New.
+	(USUAL_STRIP_FOR_TARGET): New.
+	* Makefile.def (flags_to_pass): Add LIPO_FOR_TARGET and
+	STRIP_FOR_TARGET.
+	* configure.in: Set LIPO_FOR_TARGET, STRIP_FOR_TARGET,
+	CONFIGURED_LIPO_FOR_TARGET, CONFIGURED_STRIP_FOR_TARGET.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+	
+2005-09-19  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in (powerpc-*-aix*): Add target-libssp to noconfigdirs.
+	(rs6000-*-aix*): Same.
+	* configure: Regenerate.
+
+2005-09-14  Francois-Xavier Coudert  <coudert@clipper.ens.fr>
+
+	* configure.in: Recognize f95 in the --enable-languages option,
+	and substitute it for fortran, issuing a warning.
+	* configure: Regenerate.
+
+2005-09-07  Ben Elliston  <bje@au.ibm.com>
+
+	Import from Autoconf sources:
+
+	2005-09-06  Paul Eggert  <eggert@cs.ucla.edu>
+	* move-if-change: Don't output "$2 is unchanged"; suggested by Ben
+	Elliston.  Handle weird characters correctly.
+
+2005-08-30  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in (*-*-vxworks*):  Add target-libstdc++-v3 to noconfigdirs.
+	* configure:  Regenerated.
+
+2005-08-20  Richard Earnshaw  <richard.earnshaw@arm.com>
+
+        * Makefile.def (libssp): Add to lang_env_dependencies.
+        * Makefile.in: Regenerate.
+
+2005-08-17  Christian Groessler  <chris@groessler.org>
+
+	* Makefile.tpl: (USUAL_CC_FOR_TARGET): Add missing trailing slash.
+	* Makefile.in: Regenerate.
+
+2005-08-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Replace NCN_STRICT_CHECK_TOOL with
+	NCN_STRICT_CHECK_TOOLS, and likewise for NCN_STRICT_CHECK_TARGET_TOOLS.
+	Look for alternate names of the target cc and c++
+	* configure: Regenerate.
+
+2005-08-08  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in (CC_FOR_TARGET, CXX_FOR_TARGET, GCJ_FOR_TARGET,
+	GCC_FOR_TARGET, RAW_CXX_FOR_TARGET, GFORTRAN_FOR_TARGET): Find
+	them with NCN_STRICT_CHECK_TARGET_TOOL, like the other target
+	tools; remove code to manually set them.
+	(Target tools): Look in the environment for them.
+	* Makefile.tpl (CC_FOR_TARGET, CXX_FOR_TARGET, GCJ_FOR_TARGET,
+	GCC_FOR_TARGET, RAW_CXX_FOR_TARGET, GFORTRAN_FOR_TARGET): Redefine.
+	(AS_FOR_TARGET, LD_FOR_TARGET, NM_FOR_TARGET): Look into gcc
+	build directory.
+	(CONFIGURED_CC_FOR_TARGET, CONFIGURED_CXX_FOR_TARGET,
+	CONFIGURED_GCJ_FOR_TARGET, CONFIGURED_GCC_FOR_TARGET,
+	CONFIGURED_GFORTRAN_FOR_TARGET, USUAL_CC_FOR_TARGET,
+	USUAL_CXX_FOR_TARGET, USUAL_GCJ_FOR_TARGET, USUAL_GCC_FOR_TARGET,
+	USUAL_RAW_CXX_FOR_TARGET, USUAL_GFORTRAN_FOR_TARGET): New.
+	(CXX_FOR_TARGET_FOR_RECURSIVE_MAKE,
+	RAW_CXX_FOR_TARGET_FOR_RECURSIVE_MAKE, RECURSE_FLAGS): Delete.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2005-07-27  Mark Mitchell  <mark@codesourcery.com>
+
+	* Makefile.tpl (EXTRA_TARGET_FLAGS): Set LDFLAGS=LDFLAGS_FOR_TARGET.
+	* Makefile.def (flags_to_pass): Add LDFLAGS_FOR_TARGET. 
+	* Makefile.in: Regenerated.
+
+2005-07-26  Mark Mitchell  <mark@codesourcery.com>
+
+	* Makefile.tpl (SYSROOT_CFLAGS_FOR_TARGET): New variable.
+	(CFLAGS_FOR_TARGET): Use it.
+	(CXXFLAGS_FOR_TARGET): Likewise.
+	* Makefile.in: Regenerated.
+	* configure.in (--with-build-sysroot): New option.
+	* configure: Regenerated.
+
+2005-07-24  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Wrap install between unstage and stage
+	* Makefile.in: Regenerate.
+
+2005-07-16  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* all files: Update FSF address.
+
+2005-07-14  Jim Blandy  <jimb@redhat.com>
+
+	* configure.in: Add cases for Renesas m32c.
+	* configure: Regenerated.
+	
+2005-07-14  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* COPYING, compile, config-ml.in, config.guess,
+	config.sub, install-sh, missing, mkinstalldirs,
+	symlink-tree, ylwrap: Sync from upstream sources.
+
+2005-07-13  Eric Christopher  <echristo@redhat.com>
+
+	* configure.in: Add toplevel noconfigdir support for tpf.
+	* configure: Regenerate.
+
+2005-07-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* Makefile.def (target_modules): Add libssp.
+	* configure.in (target_libraries): Add target-libssp.
+	* configure: Rebuilt.
+	* Makefile.in: Rebuilt.
+
+2005-07-11  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR ada/22340
+
+	* Makefile.def: Sync with gcc.
+	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Fix pasto.
+	* Makefile.in: Regenerate.
+
+2005-07-07  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.def (flags_to_pass): Add CFLAGS_FOR_BUILD.
+	* Makefile.tpl (EXTRA_GCC_FLAGS): Don't pass CFLAGS_FOR_BUILD here.
+	* Makefile.in: Regenerated.
+
+2005-07-07  Kazu Hirata  <kazu@codesourcery.com>
+
+	* configure.in: Add --enable-libssp and --disable-libssp.
+	* configure: Regenerate with autoconf-2.13.
+
+2005-07-06  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in: Don't build sim or rda when targetting darwin.
+	* configure: Regenerate.
+
+2005-07-04  Ben Elliston  <bje@gnu.org>
+
+	* src-release (do-proto-toplev): Remove dejagnu bits.
+	(DEJAGNU_SUPPORT_DIRS): Remove.
+	(dejagnu.tar.bz2, dejagnu.tar): Likewise.
+	(GDBD_SUPPORT_DIRS): Likewise.
+	(gdb+dejagnu.tar.bz2, gdb+dejagnu.tar): Likewise.
+	(INSIGHTD_SUPPORT_DIRS): Likewise.
+	(insight+dejagnu.tar.bz2, insight+dejagnu.tar): Likewise.
+
+2005-06-30  Ben Elliston  <bje@gnu.org>
+
+	* setup.com (mpw): Remove unused directive.
+
+2005-06-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (stagefeedback): Come after profile.
+	Define profiledbootstrap target.
+	* Makefile.tpl (profiledbootstrap): Remove.
+	(stageprofile-end): Zap stagefeedback.
+	(stagefeedback-start): Copy all .gcda files, not only GCC's.
+	* Makefile.in: Regenerate.
+
+2005-06-13  Zack Weinberg  <zack@codesourcery.com>
+
+	* depcomp: Update from automake CVS.  Add 'ia64hp' stanza.
+	In 'cpp' stanza, support '#line' as well as '# '.
+
+2005-06-07  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (unsupported_languages): New macro.
+	<mmix-knuth-mmixware>: Set unsupported_languages.  Name explicit
+	non-ported target libraries in noconfigdirs.
+	<cris-*, crisv32-*> Ditto, except for non-aout, non-elf,
+	non-linux-gnu.  Remove libgcj_ex_libffi.
+ 	<lang_frag loop>: Set add_this_lang=no if the language is in
+	unsupported_languages.
+	* configure: Regenerate.
+
+2005-06-04  Tobias Schl"uter  <tobias.schlueter@physik.uni-muenchen.de>
+
+	* configure.in: Fix typo in handling of --with-mpfr-dir.
+	* configure: Regenerate.
+
+2005-06-02  Jim Blandy  <jimb@redhat.com>
+
+	* config.sub: Add cases for the Renesas m32c.  (This patch has been
+	accepted into the master sources.)
+
+2005-06-02  Aldy Hernandez  <aldyh@redhat.com>
+            Michael Snyder  <msnyder@redhat.com>
+            Stan Cox  <scox@redhat.com>
+
+        * configure.in: Set noconfigdirs for ms1.
+
+        * configure: Regenerate.
+
+2005-05-25  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (stage[+id+]-start): Iterate over target module as well.
+	(Dependencies): Consider target modules for bootstrap dependencies.
+	Make target bootstrap modules depend on each stage's gcc.
+	* Makefile.in: Regenerate.
+
+2005-05-20  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (configure-gcc): Depend on binutils having been built.
+	(all-gcc): No need to do it here.
+	* Makefile.in: Regenerate.
+
+2005-05-19  Paul Brook  <paul@codesourcery.com>
+
+	* configure.in: Rewrite misleading error message when requested 
+	language cannot be built.
+	* configure: Regenerate.
+
+2005-05-15  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* ylwrap: Import from Automake 1.9.5.
+
+2005-05-04  Mike Stump  <mrs@apple.com>
+
+	* configure.in: Always pass --target to target configures as
+	otherwise rebuilds that do --recheck will fail.
+	* configure: Rebuilt.
+
+2005-05-04  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (POSTSTAGE1_HOST_EXPORTS): Rename from
+	STAGE_HOST_EXPORTS.
+	(configure, all): Add bootstrap support.
+	(Host modules, target modules): Pass post-stage1 flags and exports.
+	(Top-level bootstrap): Remove bootstrap rules, expanded elsewhere.
+	* Makefile.in: Regenerate.
+
+2005-04-29  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc:
+
+	2005-04-22  Bernd Schmidt  <bernd.schmidt@analog.com>
+
+        * config.sub: Update from master copy.
+
+	2005-04-19  Hans-Peter Nilsson  <hp@axis.com>
+
+        * configure.in <crisv32-*-*, cris-*-*>: New local variable
+        libgcj_ex_libffi.  Have specific match for *-*-linux*.  Separate
+        matches for "*-*-aout" and "*-*-elf".  Don't disable libffi for
+        "*-*-elf" and "*-*-linux*".
+        * configure: Regenerate.
+
+2005-04-06  Paolo Bonzini  <bonzini@gnu.org>
+
+        * Makefile.tpl (BUILD_CONFIGARGS): Include --with-build-subdir.
+	(TARGET_CONFIGARGS): Include --with-target-subdir.
+	(configure, all): New macros.  Use them throughout.
+
+2005-04-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Sync with gcc.
+	* Makefile.in: Regenerate.
+
+2005-03-30  J"orn Rennecke <joern.rennecke@st.com>
+
+	* config/mh-mingw32: Delete.
+	* configure.in: Don't use it.
+	* configure: Regenerate.
+
+2005-03-31  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (bfd, opcodes, libstdc++-v3, libmudflap): Set lib_path.
+	* Makefile.tpl (SET_LIB_PATH, REALLY_SET_LIB_PATH): Remove.
+	(HOST_EXPORTS, STAGE_HOST_EXPORTS, TARGET_EXPORTS): Set $(RPATH_ENVVAR).
+	(HOST_LIB_PATH): Generate from Makefile.def.
+	(TARGET_LIB_PATH): Likewise.
+	(Old bootstrap targets): Include TARGET_LIB_PATH into RPATH_ENVVAR.
+	* Makefile.in: Regenerate.
+	* configure.in (set_lib_path, SET_LIB_PATH, SET_GCC_LIB_PATH): Remove.
+	(RPATH_ENVVAR): Include Darwin case.
+	* configure: Regenerate.
+
+2005-03-25  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in (RPATH_ENVVAR): Set to DYLD_LIBRARY_PATH on Darwin.
+	* configure: Regenerate.
+
+2005-03-21  Zack Weinberg  <zack@codesourcery.com>
+
+	* Makefile.def: Remove libstdcxx_incdir, libsubdir, gxx_include_dir,
+	gcc_version, and gcc_version_trigger from set of flags to pass.
+	* Makefile.tpl: Remove definitions of above variables.
+	(config.status): Remove dependency on $(gcc_version_trigger).
+	* Makefile.in: Regenerate.
+	* configure.in: Do not reference config/gcc-version.m4 nor
+	config/gxx-include-dir.m4.  Do not invoke TL_AC_GCC_VERSION nor
+	TL_AC_GXX_INCLUDE_DIR.  Do not set gcc_version_trigger.
+	* configure: Regenerate.
+
+2005-03-16  Manfred Hollstein  <manfred.h@gmx.net>
+	    Andrew Pinski <pinskia@physics.uc.edu>
+
+	* Makefile.tpl (check-[+module+]): Fix shell statement inside if ... fi.
+	* Makefile.in: Regenerate.
+
+2005-03-01  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR libgcj/20160
+	* ltmain.sh: Avoid creating archives with components that have
+	duplicate basenames.
+
+2005-02-28  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR bootstrap/20250
+	* Makefile.tpl (HOST target installs): Fix copy and pasto, use install
+	instead of check.
+	* Makefile.in: Regenerate.
+
+2005-02-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc.
+
+	2005-02-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/17383
+	* Makefile.def (target_modules): Remove "stage", now unnecessary.
+	* Makefile.tpl (HOST_SUBDIR): New substitution.
+	(STAGE_HOST_EXPORTS, EXPECT, HOST_LIB_PATH, USUAL_AR_FOR_TARGET,
+	USUAL_AS_FOR_TARGET, USUAL_DLLTOOL_FOR_TARGET, USUAL_GCC_FOR_TARGET,
+	USUAL_LD_FOR_TARGET, USUAL_NM_FOR_TARGET, USUAL_OBJDUMP_FOR_TARGET,
+	USUAL_RANLIB_FOR_TARGET, USUAL_WINDRES_FOR_TARGET): Use it.
+	(Host modules, Bootstrapped modules): Use it.
+	(Build modules, Target modules): Do not create symlink trees,
+	always configure out-of-srcdir.
+	(distclean): Try removing $(host_subdir) with rm before using rm -rf.
+	* configure.in (FLAGS_FOR_TARGET, CC_FOR_TARGET, GCJ_FOR_TARGET,
+	GFORTRAN_FOR_TARGET, CXX_FOR_TARGET, RAW_CXX_FOR_TARGET): Use
+	$(HOST_SUBDIR).  Create a symlink for host_subdir.
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+	Merged from libada-gnattools-branch:
+	2004-11-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def: Add gnattools as a module, depending on target-libada.
+	* Makefile.in: Regenerate.
+	* configure.in: Include gnattools in host_tools; disable it if ada
+	is disabled.
+	* configure: Regenerate.
+
+2005-02-23  Nick Clifton  <nickc@redhat.com>
+
+	* configure: Regenerate.
+
+2005-02-22  Paul Schlie  <schlie@comcast.net>
+
+	* configure.in: Allow darwin targeted ports to build tk, itcl and
+	libgui.
+
+2005-02-21  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR libgcj/10353
+	* configure.in (noconfigdirs) <sparc-*-solaris2.[0-6]>: Add libgcj.
+	* configure: Regenerate.
+
+2005-02-08  Andrew Cagney  <cagney@gnu.org>
+
+	* MAINTAINERS: Delete reference to dejagnu/ and mmalloc/ from the
+	gdb/ section.  Update GDB's URL.
+
+2005-01-31  Andrew Cagney  <cagney@gnu.org>
+
+	* gettext.m4: Only set ENABLE_NLS when gettext is present.
+
+2005-01-29  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (noconfigdirs) <crisv32-*-*>: Match like cris-*-*.
+	<crisv32-*-*, cris-*-*>: Only disable target-newlib and
+	target-libgloss when not *-*-elf and *-*-aout.
+	* configure: Regenerate.
+
+2005-01-27  Andrew Cagney  <cagney@gnu.org>
+
+	* gettext.m4: Don't use NONE as a default for CATOBJEXT.
+
+2005-01-24  Andrew Cagney  <cagney@gnu.org>
+
+	* gettext.m4: Only fall back to ../intl/ when it's present.
+
+2005-01-17  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* install-sh, config.sub: Import from upstream.
+
+2005-01-17  Kelley Cook  <kcook@gcc.gnu.org>
+
+	PR bootstrap/18222
+	* Makefile.def: Pass CPPFLAGS_FOR_TARGET.
+	* Makefile.tpl: Define target CPPFLAGS on CPPFLAGS_FOR_TARGET.
+	* Makefile.in: Regenerate.
+
+2005-01-03  Paolo Bonzini  <bonzini@gnu.org>
+
+	Revert 2004-12-28 Makefile changes, a better fix will be
+	applied to mainline and src after GCC 4.0 branches.
+
+2004-12-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/17383
+
+	* Makefile.def (target_modules): Remove stage parameter,
+	it is always true now.
+	* Makefile.tpl (configure-build-[+module+],
+	configure-target-[+module+]): Always build symlink tree
+	for the directory and for include.  BUILD_SUBDIR and
+	TARGET_SUBDIR cannot be . anymore.
+	* Makefile.in: Regenerate.
+
+2004-12-25  David Edelsohn  <edelsohn@gnu.org>
+
+	Revert 2004-12-08 Makefile changes.
+
+2004-12-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.in (sh64-*-*): Reenable gprof.
+	* configure: Regenerate.
+
+2004-12-09  Jim Blandy  <jimb@redhat.com>
+
+	* MAINTAINERS: List 'depcomp' as part of automake.
+
+2004-12-08  David Edelsohn  <edelsohn@gnu.org>
+
+	* Makefile.def (flags_to_pass): Add PICFLAG_FOR_TARGET.
+	* Makefile.tpl (EXTRA_HOST_FLAGS): Add PICFLAG.
+	(EXTRA_TARGET_FLAGS): Add PICFLAG.
+	* Makefile.in: Regenerate.
+
+2004-12-07  Matt Kraai  <kraai@ftbfs.org>
+
+	* Makefile.tpl: Generate normal dependencies if the LHS module is
+	not bootstrapped.
+	* Makefile.in: Regenerate.
+
+2004-12-03  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in: Include config/gxx-include-dir.m4.  Use
+	TL_AC_GXX_INCLUDE_DIR.  Remove some now-redundant AC_SUBSTs.
+	* configure: Regenerate.
+
+2004-12-03  Richard Sandiford  <rsandifo@redhat.com>
+
+	* config.if: Delete.
+	* configure.in: Set libstdcxx_incdir directly.
+	* configure: Regenerate.
+	* MAINTAINERS: Remove mention of config.if.
+	* src-release (DEVO_SUPPORT): Remove config.if.
+
+2004-12-02  Eric Christopher  <echristo@redhat.com>
+
+	* Makefile.tpl (clean-target-libgcc): Add stmp-dirs to list
+	of things to remove.
+	* Makefile.in: Regenerate.
+
+2004-12-02  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in: Clear gcc_version_trigger if the file doesn't exist.
+	* configure: Regenerate.
+
+2004-12-02  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in: Include config/gcc-version.m4.  Use TL_AC_GCC_VERSION
+	to set gcc_version_trigger.  Remove some now-redundant AC_SUBSTs.
+	* configure: Regenerate.
+
+2004-11-26  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* configure.in (hppa*-*-linux*): Don't add libgcj to noconfigdirs.
+	(hppa*64*-*-*): Delete incorrect comment.
+	* configure: Rebuilt.
+
+2004-11-15  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* install-sh, compile: Import from automake.
+
+2004-11-15  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* config.guess, config.sub:  Import from savannnah.
+
+2004-11-12  Mike Stump  <mrs@apple.com>
+
+	* Makefile.def: Add html support.
+	* Makefile.tpl: Likewise.
+	* Makefile.in: Regenerate.
+
+2004-11-11  Geoffrey Keating  <geoffk@apple.com>
+
+	PR 18423
+	* configure.in: Remove all instances of build-fixincludes from
+	noconfigdirs.
+	(build_configargs): Supply --target to subdirectories.
+	* configure: Regenerate.
+
+	* Makefile.def: Make gcc install depend on fixincludes install.
+	* Makefile.in: Regenerate.
+
+2004-11-08  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [mmix-*-*]: Disable
+	target-libgfortran.
+	* configure: Regenerate.
+
+2004-11-07  David Edelsohn  <edelsohn@gnu.org>
+
+	* config-ml.in: Pass FCFLAGS for multilibs, handle GFORTRAN
+	like CC.
+
+2004-11-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (host fixincludes): Specify missing targets.
+	* Makefile.in: Regenerate.
+
+2004-11-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR other/17783
+	* configure.in: Set up LD_LIBRARY_PATH by default for gcc.
+	* configure: Regenerated.
+
+2004-11-04  Daniel Jacobowitz  <dan@debian.org>
+
+	* configure.in (arm-*-oabi*, thumb-*-oabi*): Remove.
+	* configure: Regenerated.
+
+2004-10-28  Eric B. Weddington  <ericw@evcohs.com>
+
+	PR target/18151
+	* configure.in (case ${target}): Do not build fixincludes for avr.
+	* configure: Regenerated.
+
+2004-10-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in (case ${target}): Do not build fixincludes
+	on platforms where it is not used.
+	* configure: Regenerated.
+
+2004-10-23  Daniel Jacobowitz  <dan@debian.org>
+
+	* configure.in: Use an absolute path to install-sh.
+	* configure: Regenerated.
+
+2004-10-19  Andrew Cagney  <cagney@gnu.org>
+
+	* src-release (do-djunpack, do-md5sum): Install the generated file
+	directly into the proto-toplev/ directory.
+
+2004-10-19  Andrew Cagney  <cagney@gnu.org>
+
+	* src-release (GDB_SUPPORT_DIRS): Remove utils and intl.
+
+2004-10-12  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.in (*-*-cygwin*): Supress warning if newlib not present.
+	* configure: Regenerate.
+
+2004-10-06  Paolo Bonzini  <bonzini@gnu.org>
+
+	Fix wrong conflict resolution in:
+
+	2004-08-16  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.in: Regenerate.
+	* Makefile.tpl (Autogenerated `all-*' targets): Invoke $(TARGET-*)
+	in the recursive `make', instead of hardwiring `all'.
+	(Autogenerated TARGET-* variables): New.
+
+2004-10-05  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	Merged from GCC / libtool upstream:
+	2004-10-02  P.J. Darcy  <darcypj@us.ibm.com>
+	* ltcf-c.sh (tpf*): Add ld_shlibs=yes.
+	* ltcf-cxx.sh (tpf*): Likewise.
+	* ltconfig (tpf*): Add TPF OS configuration support.
+
+2004-09-30  Tomer Levi  <Tomer.Levi@nsc.com>
+
+	* configure.in: Enable target-libgloss for crx-*-*.
+	* configure: Regenerate.
+
+2004-09-24  Michael Roth  <mroth@nessie.de>
+
+	* configure.in (--without-headers): Add missing double quotes.
+	* configure: Regenerate.
+
+2004-09-24  Kelley Cook <kcook@gcc.gnu.org>
+
+	* ylwrap: Revert to previous version.
+
+2004-09-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR bootstrap/17369
+	* Makefile.tpl (REALLY_SET_LIB_PATH): Add @SET_GCC_LIB_PATH@.
+	(HOST_EXPORTS]): Add @SET_GCC_LIB_PATH@. Set and export
+	SET_GCC_LIB_PATH_CMD.
+	(BASE_TARGET_EXPORTS): Likewise.
+	* Makefile.in: Regenerated.
+
+	* configure.in (SET_GCC_LIB_PATH): Set and substitute.
+	* configure: Regenerated.
+
+2004-09-23  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* config.guess: New upstream version
+	* compile, depcomp, install-sh, ylwrap: Likewise.
+
+2004-09-19  Roger Sayle  <roger@eyesopen.com>
+
+	* config/mh-x86omitfp: New host makefile fragment.  Add
+	-fomit-frame-pointer to the default BOOT_CFLAGS.
+	* configure.in: Use it to speed up bootstrap on some IA-32 hosts.
+	* configure: Regenerate.
+
+2004-09-15  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR target/11572
+	* configure.in (*-*-darwin*): Renable libobjc.
+	* configure: Regenerate.
+
+2004-09-09  Daniel Berlin  <dberlin@dberlin.org>
+
+	* Makefile.def: Remove libbanshee.
+	* Makefile.tpl: Ditto.
+	* configure.in: Ditto.
+	* Makefile.in: Regen.
+	* configure: Ditto.
+
+2004-09-07  Paolo Bonzini  <bonzini@gnu.org>
+
+	* missing: Import latest version from master repository.
+
+2004-09-04  Nick Clifton  <nickc@redhat.com>
+
+	* config.sub: Import latest version from master repository.
+	* config.guess: Likewise.
+	This includes these changes:
+
+	2004-08-27  Hans-Peter Nilsson  <hp@axis.com>
+
+	* config.sub: Handle crisv32, alias etraxfs.
+	* config.guess (crisv32:Linux:*:*): Handle.
+
+	2004-08-13  Brad Smith  <brad@comstyle.com>
+
+	* config.guess (*:OpenBSD:*:*): Remove defunct MIPS machines.
+	(sgi:OpenBSD:*:*): Emit mips64, not mipseb.
+
+	2004-08-11  Paul Eggert  <eggert@cs.ucla.edu>
+
+	* config.guess (*:Darwin:*:*): If uname -p reports "unknown",
+	assume the processor is a powerpc.  This is because coreutils
+	uname (at least versions 4.5.7 through 5.2.1) outputs "unknown"
+	in this case, due to a MacOS X bug that causes
+	sysctl ((int[]) {CTL_HW, HW_MACHINE_ARCH}, 2, buffer, &bufsize, 0, 0)
+	to return a negative number.
+	Problem reported by Petter Reinholdtsen in:
+	http://lists.gnu.org/archive/html/bug-gnu-utils/2003-02/msg00201.html
+
+	2004-07-19  Ben Elliston  <bje@gnu.org>
+
+	* config.guess (S7501:*:4.0:3.0): Handle NCR System V UNIX machine.
+
+	2004-06-24  Ben Elliston  <bje@gnu.org>
+
+	* config.guess: Update copyright years.
+	* config.sub: Likewise.
+
+	2004-06-22  Robert Millan  <robertmh@gnu.org>
+
+	* config.guess (*:FreeBSD:*:*): Remove check for glibc (unneeded
+	since GNU/kFreeBSD systems match *:GNU/*:*:* instead).
+
+	2004-06-22  Stanley F. Quayle <stan@stanq.com>
+
+	* config.guess (*:*VMS:*:*): New entry. Replaces
+	Alpha:OpenVMS:*. Recognize and advertise all VMS flavors as dec
+	manufacturer.
+
+	2004-06-22  Ben Elliston  <bje@gnu.org>
+
+	* config.guess: Cray fixes from Wendy Palm <wendyp@cray.com>.
+	* config.sub: Likewise.
+
+	2004-06-22  Ben Elliston  <bje@gnu.org>
+
+	Reported by Hans-Peter Nilsson <hp@bitrange.com>:
+	* config.sub: Correctly handle mmix-knuth and mmix-knuth-mmixware.
+
+	2004-06-11  Ben Elliston  <bje@gnu.org>
+
+	* config.guess (pegasos:OpenBSD:*:*): Remove.
+
+	2004-06-11  Ben Elliston  <bje@gnu.org>
+
+	From Wouter Verhelst <wouter@grep.be>:
+	* config.guess (M68*:*:R3V[5678]:*): Detect R3V8.
+
+	2004-06-11  Ben Elliston  <bje@gnu.org>
+
+	* config.guess (luna88k:OpenBSD:*:*): New.
+
+	2004-03-12  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>
+
+	* config.guess (m32r*:Linux:*:*): New case.
+	* config.sub: Handle m32rle.
+
+	2004-03-12  Ben Elliston  <bje@wasabisystems.com>
+
+	From Jens Petersen  <petersen@redhat.com>:
+	* config.sub: Handle sparcv8.
+
+	2004-03-03  Ben Elliston  <bje@wasabisystems.com>
+
+	From Tom Smith <smith@cag.lkg.hp.com>:
+	* config.guess: Version suffixes are equally significant on Tru64
+	V4.* and V5.*, so do not ignore them on V5.*.  Handle a version
+	prefix of "P" (patched kernel).
+
+	2004-02-23  Tal Agmon  <Tal.Agmon@nsc.com>
+
+	* config.sub: Add support for National Semiconductor CRX target.
+
+2004-09-03  Jan Beulich  <jbeulich@novell.com>
+
+	* configure.in: Remove target-libstdc++-v3 from noconfigdirs for
+	*-*-netware, but add target-libmudflap.
+	Consolidate *-*-netware targets (of which really only i?86 exists)
+	into a single entry.
+	* configure: Likewise.
+
+2004-09-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (sorry): Remove.
+	(clean-stage[+id+], clean-stage[+id+]-module): New targets.
+	(cleanstrap targets): Depend on distclean, not distclean-stage1.
+	(do-clean): Clean per-stage directories too.
+	(do-distclean): Run distclean-stage1 too.
+	(.NOTPARALLEL): Enable during toplevel bootstrap.
+	(stage[+id+]-bubble): Enable parallel execution during
+	the recursive invocation.
+	* Makefile.in: Regenerate.
+
+	Sync from gcc (moving the Makefile.in change to Makefile.tpl):
+
+	2004-08-31  Robert Bowdidge <bowdidge@apple.com>
+
+	* Makefile.in: Move BOOT_CFLAGS above host makefile fragment include.
+	* configure.in: add test for powerpc-*-darwin* to specify makefile frag
+	* configure: regenerate
+	* config/mh-ppc-darwin: create file, override BOOT_CFLAGS for
+	-mdynamic-no-pic
+
+2004-08-31  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Move BOOT_CFLAGS above host makefile fragment
+	include.
+	* configure.in: Fix indentation.
+	* configure: Regenerate.
+
+2004-08-31  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (build_modules): Add fixincludes.
+	(dependencies): Make gcc depend on fixincludes.
+	* configure.in (build_tools): Add fixincludes.
+	(build_configdirs): Always include build_libs.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2004-08-30  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (bootstrap stages): Add 'lean' parameter.
+	* Makefile.tpl (configure-stageN-*, all-stageN-*): Turned into
+	phony targets; do not generate timestamp files.
+	(distclean-stageN): Remove references to their timestamp files.
+	(restageN, touch-stageN): Remove.
+	(stageN-bubble): Rewritten.
+	(compare): Support lean bootstraps.
+	* Makefile.in: Regenerate.
+
+	* configure.in: Only warn when bootstrapping but
+	build != host or build != target.  Support lean bootstraps.
+	* configure: Regenerate.
+
+	Sync from gcc:
+	2004-08-26  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in:  Give a better error message if GMP/MPFR are missing
+	and a language needing them has been requested.
+	* configure:  Regenerated.
+
+	2004-08-25  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in:  Print a list of available language front-ends if
+	a requested one is missing.  Tidy stray tab characters.
+	* configure:  Regenerated.
+
+2004-08-17  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+	* Makefile.def (bootstrap-stage): Rename extra_*_flags to
+	stage_*_flags.
+	* Makefile.tpl (configure-[+module+], all-[+module+]): Exit
+	for bootstrapped modules if toplevel bootstrap is going.
+	(GCC bootstrap): Generate per-stage targets for all bootstrapped
+	modules.  Adjust for changes in Makefile.def.  Enable several
+	rules even in non-bootstrap mode, just to avoid peppering the
+	template with unnecessary "@if/@endif gcc-bootstrap" pairs.
+	(stage-[+prev+]-bubble): Remove.
+
+	* Makefile.def (Dependencies): Depend on all-build-bison,
+	all-build-flex, all-build-byacc, all-build-texinfo, rather
+	than the host variations.
+	* Makefile.tpl (BUILD_DIR_PREFIX): Remove.  Replace throughout
+	with BUILD_SUBDIR.
+	(BISON): Update for recent Bisons.
+	(YACC): Fix typo.
+	(cross): Depend on all-build.
+	(all): Do not depend on all-build.
+	(prebootstrap): Remove.
+	(dep-kind): Accept separate prefixes for MODULE and ON variables.
+	(Prebootstrap dependencies): Add them to the per-stage targets
+	and to all-prebootstrap.
+	* configure.in (build_configdirs): Always enable build_tools.
+	(BUILD_DIR_PREFIX): Remove.
+
+	* Makefile.def (gcc): Add target variable.
+	(gdb, expect, guile, tk, tix): Replace with_x with extra_make_flags.
+	* Makefile.tpl (Autogenerated `all-*' targets): Invoke $(TARGET-*)
+	in the recursive `make', instead of hardwiring `all'.
+	(Autogenerated TARGET-* variables): New.
+
+2004-08-17  Robert Millan  <robertmh@gnu.org>
+
+	* configure.in: In noconfigdirs check, match GNU/k*BSD with GNU/Linux
+	(instead of FreeBSD).
+	* configure: Regenerate.
+
+2004-08-12  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def, configure.in, src-release: Remove useless, bogus
+	references to tix.
+	* Makefile.in, configure: Regenerate.
+
+	* src-release: Stop distributing mmalloc with gdb (which doesn't
+	use it).
+	* Makefile.def: GDB doesn't depend on mmalloc anymore.
+	* Makefile.in: Regenerate.
+
+2004-08-09  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in (arm*-*-eabi*): New target.
+	* configure: Regenerate.
+
+2004-08-01  Robert Millan  <robertmh@gnu.org>
+
+	* configure.in: Turn mt-linux into mt-gnu. Use mt-gnu and enable
+	libmudflap for all GNU-based systems (with Glibc).
+	* configure: Regenerate.
+
+2004-08-06  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (bfd, opcodes, gcc, zlib): Mark as bootstrap module.
+	(bison, byacc, flex, texinfo): Do not mark as bootstrap module.
+	(Dependencies): New section.
+	* Makefile.tpl (Dependencies): Generate from Makefile.def.
+	(configure-target-[+module+]): Depend on maybe-all-gcc
+	(all-prebootstrap): New name of all-bootstrap.  Changed throughout.
+	(toplevel profiledbootstrap): Fix dependencies.
+	* Makefile.in: Regenerate.
+
+2004-08-03  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in (arm*-*-symbianelf*): Add ${libgcj} and
+	target-libiberty to noconfigdirs.
+
+2004-08-03  Paul Brook  <paul@codesourcery.com>
+
+	* configure.in: Check for MPFR as well as GMP.
+	* configure: Regenerate.
+
+2004-08-03 Paolo Bonzini <bonzini@gnu.org>
+
+	* Makefile.def (host-modules): Add gcc.
+	* Makefile.in: Regenerate.
+	* Makefile.tpl (sorry): New rule.
+	(configure-host, all-host, [+make_target+]-host, do-check,
+	install-host): Do not add gcc as a special case.
+	(host modules): Add a small special-casing for gcc.  Export
+	extra_make_flags through the environment.
+	(maybe-configure-gcc, configure-gcc, maybe-all-gcc, all-gcc,
+	maybe-check-gcc, check-gcc, maybe-install-gcc, install-gcc,
+	other recursive targets for gcc): Remove.
+
+	(all, do-[+make_target+], do-check): Wrap between unstage and stage.
+	(stage, unstage): New rules.
+	(stage[+id+]-start, stage[+id+]-end, [+compare-target+],
+	distclean-stage[+id+]): Use stage_current.
+	([+bootstrap-target+], profiledbootstrap): Do not invoke manually
+	the stage*-start rules.
+
+2004-07-19  Robert Millan  <robertmh@gnu.org>
+
+	Synced from gcc:
+
+	2004-04-26  Robert Millan  <robertmh@gnu.org>
+
+	Add patches from libtool CVS.
+	* libtool.m4: Add kfreebsd*-gnu and knetbsd*-gnu.
+	* ltconfig: Likewise.
+	* ltcf-c.sh: Likewise.
+	* ltcf-cxx.sh: Likewise.
+	* ltcf-gcj.sh: Likewise.
+
+2004-07-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Add noconfigdirs for crx-*-*.
+	* configure: Regenerate.
+
+2004-07-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	Synced from gcc:
+
+	2004-07-09  Loren J. Rittle <ljrittle@acm.org>
+
+	* configure.in: Build libmudflap by default on FreeBSD.
+	* configure: Regenerated.
+
+	2004-07-09  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in: Do not build libmudflap by default on non-GNU/Linux
+	systems.
+	* configure: Regenerated.
+
+	2004-07-08 John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/16344
+	* Makefile.tpl (profiledbootstrap): Build runtime libraries with
+	feedback based compiler.
+	* Makefile.in: Rebuilt.
+
+	2004-07-05  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in:  Do not prepend $srcdir to /dev/null in
+	makefile fragments.
+	* configure:  Regenerate.
+
+2004-07-08  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.def (host_modules): Set bootstrap=true for flex.
+	* Makefile.tpl (all-gcc): Depend on texinfo and flex.
+	* Makefile.in: Rebuilt.
+
+2004-07-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (build_modules): Add bison, byacc, flex,
+	m4, texinfo.
+	(flags_to_pass): Add FLEX.
+	* Makefile.tpl (BUILD_DIR_PREFIX, BASE_EXPORTS): New.
+	(BUILD_EXPORTS, HOST_EXPORTS, BASE_TARGET_EXPORTS): Include it.
+	(DEFAULT_YACC, USUAL_YACC, DEFAULT_LEX, USUAL_LEX, DEFAULT_M4,
+	DEFAULT_MAKEINFO): Remove.
+	(CONFIGURED_YACC, CONFIGURED_FLEX, CONFIGURED_BISON,
+	CONFIGURED_LEX, CONFIGURED_M4, CONFIGURED_MAKEINFO): Substitute.
+	(YACC, FLEX, BISON, LEX, M4, MAKEINFO): Define to look into
+	objdir or else use configured tool.
+	(all-build): New.
+	(all): Depend on it.
+	(Build module dependencies): Add.
+	* Makefile.in: Regenerate.
+	* configure.in: Better support for multiple build modules,
+	matching what is done for host/target modules.  Do not look
+	for "plausible" locations of build tools if Canadian cross.
+	Use autoconf's AC_PROG_CC to find a C compiler.  Define
+	BUILD_DIR_PREFIX.  Look for flex, makeinfo and m4.
+	* configure: Regenerate.
+
+2004-06-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (HOST_EXPORTS): Fix pasto.
+	* Makefile.in: Regenerate.
+
+2004-06-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (configure-build-[+module+],
+	configure-[+module+], configure-target-[+module+]): Pass
+	[+extra_configure_args+].
+	(all-build-[+module+], all-[+module+], check-[+module+],
+	install-[+module+], [+make_target+]-[+module+],
+	all-target-[+module+], check-target-[+module+],
+	install-target-[+module+], [+make_target+]-target-[+module+]):
+	Pass [+extra_make_args+].
+	(HOST_EXPORTS): Include the former GCC_HOST_EXPORTS.
+	(GCC_HOST_EXPORTS): Remove.
+	(configure-gcc, all-gcc, GCC_STRAP_TARGETS, profiledbootstrap,
+	cross, check-gcc, check-gcc-c++, install-gcc,
+	gcc-no-fixedincludes, [+make_target+]-gcc, stage[+id+]-bubble):
+	Replace GCC_HOST_EXPORTS with HOST_EXPORTS.
+	* Makefile.in: Regenerate.
+
+2004-06-21  Christopher Faylor  <cgf@alum.bu.edu>
+
+	* configure.in: Check for srcdir/winsup rather than build directory
+	winsup.
+	* configure: Regenerate.
+
+2004-06-17  Corinna Vinschen  <vinschen@redhat.com>
+
+	* configure.in: Don't build Cygwin native newlib if winsup
+	directory is missing.  Emit warning instead.
+	* configure: Regenerate.
+
+2004-06-09  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (touch-stage[+id+]): New.
+	(restage[+prev+]): Depend on touch-stage[+id+].
+
+	* Makefile.tpl (RECURSE_FLAGS_TO_PASS): New.
+	Use it throughout.
+
+	* Makefile.def: Add profile and feedback bootstrap stages.
+	Remove next field from bootstrap stages.
+	* Makefile.tpl (LN, LN_S): Substitute.
+	(stageN-start, stageN-end): Use double-colon rules, to
+	provide a hook for additional setup commands.
+	(distclean-stageN-gcc, restageN): Create dependencies from
+	[+prev+], not from [+next+].
+	(stageN-bubble): Add commands for successive stages from
+	[+prev+], using double-colon rules.
+	(all-stageN-gcc): Fix typo.
+	(stagefeedback-start, profiledbootstrap): New.
+	* Makefile.in: Regenerate.
+	* configure.in: Call ACX_PROG_LN.
+	* configure: Regenerate.
+
+2004-06-03  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Fix --enable-bootstrap breakage introduced in trees
+	without gcc.
+	* configure: Regenerate.
+
+2004-06-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Fix typo.
+	* Makefile.in: Regenerate.
+
+2004-06-01  Paolo Bonzini <bonzini@gnu.org>
+
+	* configure.in: Remove new- prefix from toplevel
+	bootstrap targets.
+	* configure: Regenerate.
+
+2004-06-01  Paolo Bonzini <bonzini@gnu.org>
+
+	Merge this patch from the gcc tree:
+
+	2004-05-30  Andreas Jaeger  <aj@suse.de>
+		    Jim Wilson <wilson@specifixinc.com>
+
+	* config-ml.in: Pass FFLAGS and ADAFLAGS for multilibs, handle F77
+	like CC.
+
+2004-06-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all.normal): Rename to all.
+	(all): Replace with a rule to pick the default
+	target from configure.
+	(all-gcc, configure-gcc): Use conditionals to
+	do nothing when toplevel bootstrap is going on.
+	(GCC directory bootstrap) [gcc-bootstrap]: Disable.
+	(Toplevel bootstrap) [gcc-no-bootstrap]: Disable.
+	* configure.in: Support --enable-bootstrap.
+
+	* Makefile.def: Remove new- prefix from toplevel
+	bootstrap targets.
+	* Makefile.tpl: Likewise.
+
+	* Makefile.def: Add bootstrap_stage 4.  Add bootstrap2
+	target.
+
+	* Makefile.tpl (Toplevel bootstrap): Pass $(BASE_FLAGS_TO_PASS)
+	$(RECURSE_FLAGS) to recursive invocation of make.
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2004-05-27  Daniel Jacobowitz  <dan@debian.org>
+
+	* configure.in: Fix sed invocation for GFORTRAN_FOR_TARGET.
+	* configure: Regenerate.
+
+2004-05-25  Daniel Jacobowitz  <drow@false.org>
+
+	* Makefile.tpl (BUILD_EXPORTS, HOST_EXPORTS, GCC_HOST_EXPORTS)
+	(STAGE_HOST_EXPORTS, BASE_TARGET_EXPORTS, RAW_CXX_TARGET_EXPORTS)
+	(NORMAL_TARGET_EXPORTS): New macros.  Use them in all the recursive
+	targets.
+	* Makefile.in: Regenerate.
+
+2005-05-24  Paolo Bonzini <bonzini@gnu.org>
+
+	* configure.in: Test the ability to symlink directories.
+	* configure: Regenerate.
+
+	* Makefile.def (bootstrap-stage): New definitions.
+	* Makefile.tpl (configure-stage1-gcc,
+	configure-stage2-gcc, configure-stage3-gcc,
+	all-stage1-gcc, all-stage2-gcc, all-stage3-gcc,
+	new-bootstrap, new-cleanstrap, new-restage1, new-restage2,
+	new-restage3, compare): Autogenerate, see Makefile.in
+	entry for behavioral changes.
+	(distclean-stage1, new-stage1-start, new-stage1-end,
+	new-stage1-bubble, distclean-stage2, new-stage2-start,
+	new-stage2-end, new-stage2-bubble, distclean-stage3,
+	new-stage3-start, new-stage3-end): New autogenerated targets.
+	(objext, prebootstrap, BOOT_CFLAGS,
+	POSTSTAGE1_FLAGS_TO_PASS): Move above the autogenerated
+	targets.
+
+	* Makefile.in: Regenerate.
+	(distclean-stage1, new-stage1-start, new-stage1-end,
+	new-stage1-bubble, distclean-stage2, new-stage2-start,
+	new-stage2-end, new-stage2-bubble, distclean-stage3,
+	new-stage3-start, new-stage3-end): New targets.
+	(all-stage1-gcc): Move prebootstrap dependency from here...
+	(configure-stage1-gcc): ...to here.
+	(new-bootstrap): Use bubble targets.
+	(new-cleanstrap, new-restage1, new-restage2, new-restage3):
+	Use per-stage distclean targets.
+	(configure-stage1-gcc, configure-stage2-gcc,
+	configure-stage3-gcc, all-stage1-gcc,
+	all-stage2-gcc, all-stage3-gcc, new-bootstrap):
+	Use new-stageN-start to prepare the tree.
+
+2004-05-23  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (host_modules): add libcpp.
+	* Makefile.tpl: Add dependencies on and for libcpp.
+	* Makefile.in: Regenerate.
+	* configure.in: Add libcpp host module.
+	* configure: Regenerate.
+
+2004-05-17  Zack Weinberg  <zack@codesourcery.com>
+
+	* Makefile.def, Makefile.tpl, configure.in: Remove all mention
+	of libf2c.
+	* configure, Makefile.in: Regenerate.
+
+2004-05-13  Diego Novillo  <dnovillo@redhat.com>
+
+	Merge from tree-ssa-20020619-branch.
+
+	* Makefile.def: Add libbanshee, libmudflap and libgfortran.
+	* Makefile.tpl (BUILD_CONFIGDIRS): Add libbanshee.
+	(HOST_GMPLIBS): Define.
+	(HOST_GMPINC): Define.
+	(TARGET_LIB_PATH): Add libmudflap.
+	(GFORTRAN_FOR_TARGET): Define.
+	(configure-build*): Export GFORTRAN.
+	(configure-gcc): Export GMPLIBS and GMPINC.
+	(all-gcc): Add maybe-all-libbanshee.
+	(configure-target-libgfortran): Define.
+	* Makefile.in: Regenerate.
+	* configure.in (host_libs): Add libbanshee.
+	(target_libraries): Add target-libmudflap and target-libgfortran.
+	Add --with-libbanshee.
+	Handle --disable-libmudflap.
+	(*-*-freebsd*): Use with_gmp.
+	Add $(libgcj) to noconfigdirs.
+	* configure: Regenerate.
+	* depcomp: New file.
+	* MAINTAINERS: Add tree-ssa maintainers.
+
+2004-04-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	* config/acx.m4: Fix fastcompare support for new-bootstrap.
+	* configure: Regenerate.
+
+2004-04-27  Paolo Bonzini  <bonzini@gnu.org>
+
+	Revert:
+	2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (flags_to_pass): Remove *dir variables that
+	are passed to the modules via TOPLEVEL_CONFIGURE_ARGUMENTS,
+	as well as prefix and exec_prefix.
+	* Makefile.in: Regenerate.
+
+2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (host_modules): Mark with the bootstrap
+	flag packages on which gcc depends.
+	* Makefile.tpl (all-bootstrap): Use it.
+	* Makefile.in: Regenerate.
+
+2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (flags_to_pass): Remove *dir variables that
+	are passed to the modules via TOPLEVEL_CONFIGURE_ARGUMENTS,
+	as well as prefix and exec_prefix.
+	* Makefile.in: Regenerate.
+
+2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Invoke ACX_PROG_CMP_IGNORE_INITIAL.
+	* configure: Regenerate.
+	* config/acx.m4: Mutuate ACX_PROG_CMP_IGNORE_INITIAL from gcc.
+	* gcc/Makefile.tpl (compare): Use the result of the test.
+	* gcc/Makefile.in: Regenerate.
+
+2004-04-23  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all-stage1-gcc, all-stage2-gcc, all-stage3-gcc):
+	Always relocate gcc and prev-gcc to the original names, even
+	if the build fails.
+	(new-cleanstrap, new-restage1, new-restage2, new-restage3):
+	New targets.
+
+2004-04-19  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in (mips*-*-irix5*): Enable ld.
+	* configure: Regenerate.
+
+2004-04-15  James E Wilson  <wilson@specifixinc.com>
+
+	* Makefile.tpl (configure-[+module+], configure-gcc,
+	configure-stage1-gcc, configure-stage2-gcc, configure-stage3-gcc):
+	Set and export LDFLAGS.
+	* Makefile.in: Regenerate.
+
+2004-04-09  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/14871
+	* Makefile.tpl: If we don't have built-in-tree target tools,
+	use the ones found by configure rather than hacking around with
+	program_transform_name.
+	* configure.in: Give Makefile.tpl the information necessary
+	to do that.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2004-04-06  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/14760
+	* configure.in: When computing baseargs, strip *all* copies of
+	offending options.  Also, don't match/substitute the trailing space,
+	so that this actually works when two similar options are separated by
+	only one space.
+	* configure: Regenerate.
+
+2004-04-06  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in (powerpc-*-aix*): Remove target-libada from noconfigdirs.
+	(rs6000-*-aix*): Same.
+	* configure: Regenerate.
+
+2004-03-25  Stan Shebs  <shebs@apple.com>
+
+	Remove MPW support, no longer used.
+	* mpw-README, mpw-build.in, mpw-config.in, mpw-configure,
+	mpw-install: Remove files.
+	* src-release (DEVO_SUPPORT): Remove names of removed files.
+	* MAINTAINERS: Likewise.
+
+2004-03-24  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl (top level bootstrap support): Remove now-unneeded
+	STRICT_WARN, WARN_CFLAGS flags passed down to make.
+	* Makefile.in: Regenerate.
+
+	* configure.in (top level bootstrap support): Rework --enable-werror
+	to set @stage2_werror_flag@.
+	* configure: Regenerate.
+	* Makefile.tpl (top level bootstrap support): Pass
+	@stage2_werror_flag@ down to configure in stages 2 and 3.
+	* Makefile.in: Regenerate.
+
+2004-03-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl (new-bootstrap): Set CC and CC_FOR_BUILD in configure
+	for stages 2 and 3 as well as in make.  As a consequence, remove
+	OUTPUT_OPTION (now detected by configure) from the flags passed down
+	to make.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl (new-bootstrap): Fix typo.
+	* Makefile.in: Regenerate.
+
+2004-03-22  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Rearrange by moving recursive_targets rules
+	into their proper sections.
+	* Makefile.tpl (top level bootstrap support): Move disabling
+	of coverage flags from 'make' to 'configure'; improve comments.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl (experimental top level bootstrap) Move stage1
+	language setting from all- target to configure- target; disable
+	intermodule optimization in stage 1; prevent gratuitous rebuilds
+	of stage 1.
+	* Makefile.in: Regenerate.
+	* configure.in: Comma-separate stage 1 language list for top
+	level bootstrap.
+	* configure: Regenerate.
+
+	* Makefile.tpl: Clean up experimental top level bootstrap support:
+	note known problems; set CONFIG_SHELL; don't set BUILD_CC; relocate
+	prev-gcc in configure- targets as well as all- targets.
+	* Makefile.in: Regenerate.
+
+2004-03-17  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Remove symbolic link section.
+	* configure: Regenerate.
+	* Makefile.tpl (links): Remove.
+	* Makefile.in: Regenerate.
+
+2004-03-15  Paolo Bonzini  <bonzini@gnu.org>
+	    Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in (DEFAULT_YACC, DEFAULT_M4, DEFAULT_LEX):
+	Set with AC_CHECK_PROGS.
+	* configure.in: Fix comment typo from last patch.
+	* configure: Regenerate.
+
+2004-03-15  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Introduce experimental top level bootstrap support.
+	* Makefile.in: Regenerate.
+	* configure.in: Introduce support for top level bootstrap.
+	* configure: Regenerate.
+
+2004-03-12  Eric Botcazou  <ebotcazou@gcc.gnu.org>
+	    Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/14522
+	* configure.in: Cope with shells that do not support unquoted ^
+	* configure: Regenerate.
+
+2004-03-11  Eric Botcazou  <ebotcazou@gcc.gnu.org>
+	    Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/14522
+	* configure.in: Cope with shell that do not support nesting
+	quotes inside quoted backquote substitutions.
+	* configure: Regenerate.
+
+2004-03-10  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR bootstrap/14522
+	* configure.in: Fix escaping of $.
+	* configure: Regenerate.
+
+2004-03-11  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Regenerate.
+
+2004-03-08  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR ada/14131
+	Move language detection to the top level.
+	* configure.in: Find default values for the tools as
+	soon as possible.  Disable ada if GNAT is not found.
+	Emit error message about missing languages.  Expand
+	--enable-languages=all for the gcc subdirectory.
+
+2004-03-01  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in (mips64*-*-linux*): Override mips*-*-linux* case
+	and disable libgcj.
+	* configure: Regenerated.
+
+2004-02-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/7087
+	* Makefile.tpl: Guard XFOO sed statements better.
+	* Makefile.tpl: Add dependency for configure-target-libada.
+	* Makefile.in: Regenerate (incidentally fixes broken
+	commit when libada-branch was merged).
+
+2004-02-28  Andrew Cagney  <cagney@redhat.com>
+
+	* src-release (CVS_NAMES): Define.
+	(do-tar, do-tar): Prune $(CVS_NAMES).
+
+2004-02-23  Andrew Cagney  <cagney@redhat.com>
+
+	* texinfo/texinfo.tex: Update from version 2003-02-03.16 to
+	2004-02-19.09.
+
+2004-02-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/11932
+	* mkinstalldirs, install-sh: Import from automake CVS HEAD.
+
+2004-02-19  Andrew Cagney  <cagney@redhat.com>
+
+	* config.guess: Update from version 2003-06-12 to 2004-02-16.
+	* config.sub: Update from version 2003-06-13 to 2004-02-16.
+
+2004-02-11  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in (powerpc-*-aix*): Add target-libada to noconfigdirs.
+	(rs6000-*-aix*): Same.
+	* configure: Regenerate.
+
+2004-02-11  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.in (host): Add in missing $noconfigdirs to defines.
+	* configure: Regenerate.
+
+2004-02-10  Arnaud Charlet  <charlet@act-europe.fr>,
+	    Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR ada/6637, PR ada/5911
+	Merge with libada-branch:
+	* configure.in, Makefile.tpl, Makefile.def: Add target-libada,
+	with appropriate dependencies. Add --enable-libada configure switch.
+	* configure, Makefile.in: Regenerate.
+
+2004-02-05  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in: Don't pass --with-stabs on IRIX 5 either.
+	* configure: Regenerate.
+
+2004-02-02  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update Red Hat license to 2004.
+
+2004-01-23  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.def (target_modules) [libiberty]: Don't stage.
+	* Makefile.in: Rebuilt.
+
+2004-01-23  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update to include copyrights for new
+	iconv code.
+
+2004-01-15  Andrew Cagney  <cagney@redhat.com>
+
+	* src-release: Update copyright year.
+	(do-proto-toplev): Configure using i686-pc-linux-gnu.
+	(NEWLIB_SUPPORT_DIRS): Delete macro.
+	(newlib.tar.bz2): Delete rule.
+
+2004-01-14  Loren J. Rittle <ljrittle@acm.org>
+
+	* Makefile.def (target_modules) [libtermcap, libiberty, zlib]: Stage.
+	* Makefile.tpl (configure-target-[+module+]): Support stage.
+	* Makefile.in: Rebuilt.
+
+2003-01-14  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>
+
+	* gettext.m4: Quote names of macros to be defined by AC_DEFUN
+	throughout.
+
+2004-01-04  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Use ./config.cache, not config.cache.
+	* configure: Regenerate.
+	* Makefile.tpl: Special-casing not needed for GCC any more.
+	* Makefile.in: Regenerate.
+
+	* configure.in: Don't share a cache file for host dirs.
+	* configure: Regenerate.
+
+	* config-ml.in: Don't mess with the cache file.
+
+2004-01-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make GCC use a separate config.cache.
+	* Makefile.in: Regenerate.
+
+	PR bootstrap/11932, PR bootstrap/11933
+	(I don't know if it will fix either of them, but it relates
+	to them.)
+	* configure.in: Don't use shared config.cache for target
+	directories.
+	* configure: Regenerate.
+
+2003-12-31  Roger Sayle  <roger@eyesopen.com>
+
+	* configure.in (ia64*-*-hpux*): Disable building java libraries.
+	* configure: Regenerated.
+
+2003-12-21  Bernardo Innocenti  <bernie@develer.com>
+
+ 	* configure.in (*-*-uclinux): Exclude newlib, libgloss and rda.
+ 	* configure: Regenerated.
+
+2003-12-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	Port change over from GCC:
+	2003-11-20  Kelley Cook  <kcook@gcc.gnu.org>
+	* Makefile.tpl (BASE_FLAGS_TO_PASS): Pass along CONFIG_SHELL.
+	(configure-build-[+module+], configure-[+module+]): Likewise.
+	(configure-target-[+module+], configure-gcc, config.status): Likewise.
+	* Makefile.in: Regenerate.
+
+2003-12-08  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (raw_libstdcxx_flags): Remove the leading space.
+	* configure: Regenerate.
+
+2003-11-27  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Add license info for long long routines added to
+	stdlib.
+
+2003-11-14  Arnaud Charlet  <charlet@act-europe.fr>
+
+	* Makefile.tpl (EXTRA_GCC_FLAGS): Pass BOOT_ADAFLAGS.
+	* Makefile.in: Regenerate.
+
+2003-10-20  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in (*-*-vxworks):  Add target-libiberty to noconfdirs.
+	* configure:  Regenerate.
+
+2003-10-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make GCC_FLAGS_TO_PASS a superset of
+	HOST_FLAGS_TO_PASS.
+	* Makefile.in: Regenerate.
+
+2003-10-05  Mohan Embar  <gnustuff@thisiscool.com>
+
+	* configure.in: Allow explicit specification of CFLAGS_FOR_BUILD.
+	* configure: Rebuilt
+	* Makefile.tpl: Use CFLAGS_FOR_BUILD computed by configure
+	* Makefile.in: Rebuilt
+
+2003-10-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* ltconfig (sys_lib_search_path_spec): Fix a typo for HPUX.
+
+2003-10-01  Phil Edwards  <pme@gcc.gnu.org>
+
+	* config-ml.in:  Use ac_configure_args directly instead of
+	ml_arguments.  Only set ml_norecursion if --no[-]recursion is
+	actually seen.
+
+2003-10-01  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* config-ml.in: Propagate INSTALL variables.
+
+2003-09-21  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in: Pass a computed --program-transform-name
+	to subconfigures.
+	* configure: Regenerated.
+
+2003-09-20  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Don't pass down obsolete ENQUIRE variable.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Don't pass (unused) DLLTOOL or WINDRES to gcc.
+	* Makefile.in: Regenerate.
+
+2003-09-17  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in (TOPLEVEL_CONFIGURE_ARGUMENTS, baseargs): Fix
+	quoting.
+	* configure: Regenerated.
+
+2003-09-12  Michael Chastain  <mec@shout.net>
+
+	Fix PR gdb/857.
+	* src-release (do-proto-topleve): Remove junk files
+	intl/config.cache, intl/config.status,
+	intl/config.h, intl/stamp-h.
+
+2003-09-14  Andrew Cagney  <cagney@redhat.com>
+
+	* src-release (dejagnu.tar): New target.
+	(dejagnu.tar.bz2): Recursively call "gdb-taz" rule.
+	(do-djunpack): Use $(PACKAGE) for the package name.
+
+2003-09-04  DJ Delorie  <dj@redhat.com>
+
+	* configure: Regenerate.
+
+2003-09-04  Robert Millan  <robertmh@gnu.org>
+
+	* configure.in: Match GNU/KFreeBSD with new kfreebsd*-gnu triplet.
+
+2003-09-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* configure.in: Ensure arguments to sed are properly spaced.
+	* configure: Regenerate.
+
+2003-08-28  Daniel Jacobowitz  <drow@mvista.com>
+
+	Merge from gcc:
+	2003-07-20  Phil Edwards  <pme@gcc.gnu.org>
+	* install-sh:  Update to newer upstream versions (associated with
+	aclocal 1.7).
+	* missing:  Likewise, plus $1Help2man -> $1 typo fix.
+
+2003-08-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in: Set RAW_CXX_FOR_TARGET if unset.
+	* configure: Regenerated.
+
+2003-08-23  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure.in:  Use newline instead of semicolon when assuming
+	shell arguments in a for loop.
+	* configure:  Regenerated.
+
+2003-08-20  Geoffrey Keating  <geoffk@apple.com>
+
+	PR 8180
+	* configure.in: When testing with_libs and with_headers, treat
+	'no' as unset.  Based on a patch by Dan Kegel <dank@kegel.com>.
+	* configure: Regenerate.
+
+	* configure.in (TOPLEVEL_CONFIGURE_ARGUMENTS): Quote properly for
+	make, shell, etc.
+	(baseargs): Likewise.
+	* configure: Regenerate.
+
+2003-08-19  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in: Disable libgcj for darwin not on powerpc.
+	* configure: Rebuild.
+
+2003-08-15  Michael Chastain  <mec@shout.net>
+
+	* src-release (do-proto-toplev): Remove junk files
+	dejagnu/example/calc/config.status,
+	dejagnu/example/calc/config.log.
+
+2003-08-14  Alexandre Duret-Lutz  <adl@gnu.org>
+
+	* config-ml.in, symlink-tree: Add license.
+
+2003-08-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	Merge from gcc:
+
+	2003-08-01  Matt Kraai  <kraai@alumni.cmu.edu>
+	* Makefile.tpl (check, check-c++): Express dependencies using
+	dependencies rather than commands.
+	* Makefile.in: Regenerate.
+
+	2003-07-31  Geoffrey Keating  <geoffk@apple.com>
+	* Makefile.tpl (libsubdir): Use gcc instead of gcc-lib.
+	* Makefile.in: Update.
+
+2003-08-01  Andrew Cagney  <cagney@redhat.com>
+
+	* configure.in (noconfigdirs): Do not add GDB when m32r-*-*.
+	* configure: Ditto.
+
+2003-07-30  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* configure.in: Enable libgcj for darwin.
+	* configure: Rebuild.
+
+2003-07-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* mkinstalldirs: Import autoconf 2.57 / automake 1.7 version.
+
+2003-07-27  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Use 'mkinstalldirs' rather than 'mkdir' when
+	creating target and build subdirs to build all parent dirs as needed.
+	* Makefile.in: Rebuild.
+	* configure.in: Don't build dirs explicitly here.
+	* configure: Rebuild.
+
+2003-07-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (all-make): Depend on intl.
+	* Makefile.in: Rebuilt.
+
+2003-07-16  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* config.if: Remove unused libc_interface determination.
+
+2003-07-14  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.in: Regenerate, correctly this time.
+
+2003-07-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Set INSTALL and friends using autoconf.  Remove
+	unused INSTALL_PROGRAM_ARGS.
+	* configure.in: Use AC_PROG_INSTALL.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2003-07-10  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure: Rebuilt.
+	2001-09-26  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in (noconfigdirs) [am33_2.0-*-linux*]: Don't build
+	newlib nor libgloss.
+	Wed May  9 10:07:19 2001  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in (am33_2.0-*-linux*): Added.
+
+2003-07-09  Bob Wilson  <bob.wilson@acm.org>
+
+	* configure.in: Add ${libgcj} to noconfigdirs for xtensa-*-* targets.
+	* configure: Regenerate.
+
+2003-07-06  H.J. Lu <hongjiu.lu@intel.com>
+
+	* config-ml.in: Replace PWD with PWD_COMMAND.
+	* Makefile.tpl: Likewise.
+	* Makefile.in: Regenerated.
+
+2003-06-27  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Clean up config-lang.in handling.  Delete
+	useless assignment to "subdirs".
+	* configure: Regenerate.
+
+2003-06-26  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Rename 'target_libs' to 'target_libraries'.
+	Remove useless reference to 'target_libs'.
+	* configure: Regenerate.
+
+2003-06-23  Keith Seitz  <kseitz@sources.redhat.com>
+
+	* Makefile.tpl: Add maybe-configure-itcl to configure-gdb.
+	* Makefile.in: Regenerate.
+
+2003-06-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def: Introduce flags_to_pass.
+	* Makefile.tpl: Generate BASE_FLAGS_TO_PASS using it.
+	* Makefile.in: Regenerate.
+
+2003-06-23  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) <cris-*-*>: Disable target-newlib
+	and target-libgloss.
+	<d30v-*-*, fr30-*-*, i960-*-*, m32r-*-*>: Disable gdb.
+	<h8300*-*-*>: Disable libf2c and ${libgcj}.
+	* configure: Regenerate.
+
+2003-06-17  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* configure.in: Update testsuite_flags to new location.
+	* configure. Regenerate.
+
+2003-06-18  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Remove BUILD_CC stuff.
+	* Makefile.in: Regenerate.
+
+2003-06-14  H.J. Lu <hongjiu.lu@intel.com>
+
+	* config.guess: Update to 2003-06-12 version.
+	* config.sub: Update to 2003-06-13 version.
+
+2003-06-12  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+
+	* MAINTAINERS: Add myself as MIPS co-maintainer.
+
+2003-06-12  H.J. Lu <hongjiu.lu@intel.com>
+
+	* config.guess: Update to 2003-06-06 version.
+	* config.sub: Update to 2003-06-06 version.
+
+2003-06-11  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in: Don't pass --with-stabs for mips*-sgi-irix6*o32.
+	* configure. Regenerate.
+
+2003-06-10  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Disable serial configure by default.
+	* configure: Regenerate.
+	* Makefile.tpl: Abolish .NOTPARALLEL.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Replace {build,host,target}_canonical by
+	{build,host,target}.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Fix stupid pasto.
+	* Makefile.in: Regenerate.
+
+2003-06-09  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Remove bogus conditional.
+	* Makefile.in: Regenerate.
+
+2003-06-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make 'recursive targets' using autogen rather
+	than shell loop.  Remove duplicate 'clean' targets and false
+	comments.
+	* Makefile.def: Add systematic dependencies to 'recursive' targets.
+	Add systematic method of specifying missing targets in subdirs.
+	Add copyright boilerplate.
+	* Makefile.in: Regenerate.
+	* configure.in: Add 'recursive targets' to maybe list.
+	* configure: Regenerate.
+
+	* Makefile.tpl: Rename [+target+] to [+make_target+].
+	* Makefile.def: Rename 'target' to 'make_target'.
+
+2003-05-30  Nick Clifton  <nickc@redhat.com>
+
+	* README-maintainer-mode: Update URL for locating blessed config
+	tools.
+
+2003-05-29  Robert Millan  <rmh@debian.org>
+
+	* ltconfig: Import this patch and modify for use with current
+	version of ltconfig:
+
+	2003-05-21  Bruno Haible  <bruno@clisp.org>
+
+	* libtool.m4 (AC_LIBTOOL_SYS_DYNAMIC_LINKER): Add support for
+	GNU/FreeBSD.
+
+2003-05-28  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl: Make maybe-check-gcc .PHONY.
+	* Makefile.in: Regenerate.
+
+2003-05-28  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Add license info for newlib/libc/sys/linux/stdlib.
+
+2003-05-21  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl (configure-target-libiberty): Depend only on gcc, not
+	newlib or libgloss.
+	* Makefile.in: Regenerate.
+
+2003-05-21  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl: Add missing empty maybe-check-gcc target.
+	* Makefile.in: Regenerate.
+
+2003-05-20  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>
+
+	* configure.in: Use curly braces in the definition of tooldir.
+	* configure: Regenerate.
+
+2003-05-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Switch more things to use maybe dependencies.
+	* Makefile.tpl: Switch more things to use maybe dependencies.
+	Factor out common code from autogen IF statements.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2003-05-14  Kelley Cook  <kelleycook@wideopenwest.com>
+
+	* configure.in: Accept i[3456789]86 for machine type.
+	* configure: Regenerate.
+
+2003-05-18  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Switch more things to use maybe dependencies.
+	Rearrange a little.  Use GCC_TOPLEV_SUBDIRS.
+	* configure: Regenerate.
+	* Makefile.tpl: Switch more things to use maybe dependencies.
+	* Makefile.in: Regenerate.
+
+2003-05-16  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl (install-opcodes): Define.
+	* Makefile.in: Rebuild.
+
+2003-05-13  Andreas Jaeger  <aj@suse.de>
+
+	* config.guess: Update to 2003-05-09 version.
+	* config.sub: Update to 2003-05-09 version.
+
+2003-05-13  Michael Eager <eager@mvista.com>
+
+	* configure.in: Correct sed script so that options in quotes are not
+	deleted.
+	* configure: Rebuild.
+
+2003-05-12  Corinna Vinschen  <corinna@vinschen.de>
+
+	* configure.in (FLAGS_FOR_TARGET): Remove $$s/newlib/libc/sys/cygwin
+	and $$s/newlib/libc/sys/cygwin32 include paths.
+	* configure: Ditto.
+
+2003-05-05  H.J. Lu <hjl@gnu.org>
+
+	* config-ml.in: Restored from gcc repository.
+
+2003-05-02  Chris Demetriou  <cgd@broadcom.com>
+
+	* Makefile.tpl: Require "makeinfo" from texinfo 4.2 or later.
+	* Makefile.in: Regenerate.
+
+2003-04-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	* src-release (DEVO_SUPPORT): Add src-release, Makefile.tpl,
+	and Makefile.def.
+
+2003-04-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	* Makefile.tpl: Clean $(BUILD_SUBDIR).
+	* Makefile.in: Regenerated.
+
+2003-04-18  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>
+
+	* Makefile.tpl (MAKEINFOFLAGS): Default to --split-size=5000000.
+	* Makefile.in: Regenerate.
+
+2003-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (powerpc64*-*-linux*): Remove.
+	* configure: Rebuilt.
+
+2003-04-17  Phil Edwards  <pme@gcc.gnu.org>
+
+	* Makefile.tpl (GCC_STRAP_TARGETS):  New variable containing all the
+	previous bootstrap targets, plus bubblestrap, quickstrap, cleanstrap,
+	and restrap.
+	* Makefile.in:  Regenerate.
+
+2003-04-16  Richard Earnshaw  <rearnsha@arm.com>
+
+	* configure.in (arm-*-netbsdelf*): Enable building java libraries.
+	* configure: Regenerated.
+
+2003-04-11  Alexandre Oliva  <aoliva@redhat.com>
+
+	* libtool.m4 (lt_cv_deplibs_check_method): Use pass_all on mips*.
+	* */configure: Rebuilt.
+
+2003-03-14  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Move .NOEXPORT, MAKEOVERRIDES back down.
+	* Makefile.in: Regenerate.
+
+2003-03-14  Michael Chastain  <mec@shout.net>
+
+	* Makefile.in: Regenerate with correct Makefile.def.
+
+2003-03-12  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Move .NOEXPORT, MAKEOVERRIDES up.  Delete unused
+	Make macro.
+	* Makefile.in: Regenerate.
+	* configure.in: Clean up gxx_include_dir logic.
+	* configure: Regenerate.
+
+2003-03-09  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* configure.in (gxx_include_dir): Fix typo.
+	* configure: Regenerated.
+
+2003-03-06  Andrew Cagney  <cagney@redhat.com>
+
+	* texinfo/texinfo.tex: Import version 2003-02-03.16.
+
+2003-03-04  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in: Include $(build_tooldir)/sys-include in
+	FLAGS_FOR_TARGET.
+	* configure: Regenerated.
+
+2003-03-04  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Reindent.
+	* Makefile.in: Regenerate.
+	* configure.in: Reindent.  Don't set unused variables.
+	* configure: Regenerate.
+
+	* Makefile.tpl: Always pass down RANLIB.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Don't set unused enable_shared, enable_threads macros.
+	* Makefile.in: Regenerate.
+	* configure.in: Remove unused logic relating to --enable-shared
+	and --enable-threads.  Remove bogus comments.  Remove redundant
+	noconfigdirs.
+	* configure: Regenerate.
+
+	* configure.in: Replace ${libstdcxx_version} by its value.
+	Remove reference to mh-dgux.
+	* configure: Regenerate.
+
+2003-02-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Rearrange.
+	* Makefile.in: Regenerate.
+
+2003-02-25  Nick Clifton  <nickc@redhat.com>
+
+	* configure: Remove site-file supprot - it is obsolete.
+
+2003-02-24  Uwe Stieber <uwe@wwws.de>
+
+	* configure.in: Add support for kaOS as cross build target system.
+	* configure: Regenerated.
+
+2003-02-20  Sean McNeil  <sean@blue.mcneil.com>
+
+	* Makefile.tpl: Add definition of CPPFLAGS to pass into
+	configure-target-* as some target builds may require additional
+	flags for preprocessor tests.
+	* Makefile.in: Regenerated.
+
+2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
+
+	* libtool.m4 (LD): Append -melf* option to LD on IRIX with GNU ld.
+	* ltconfig: Handle it.
+	* ltcf-cxx.sh: Use with_gnu_ld passed as a shell variable instead of
+	auto-detecting it.
+
+2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-cxx.sh: Replace $linker_flags with $compiler_flags wherever
+	it is used as argument to $CC.
+	* ltcf-gcj.sh: Likewise.
+
+2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Introduce --enable-maintainer-mode.
+	* configure: Rebuilt.
+	* Makefile.tpl (Makefile.in, configure): Enable dependencies only
+	for maintainer mode.
+	* Makefile.in: Rebuilt.
+
+2003-02-19  Andrew Cagney <ac131313@redhat.com>
+
+	* configure: Regenerate using autoconf 2.13.
+
+2003-02-19  Alan Modra  <amodra@bigpond.net.au>
+
+	* config.guess: Import latest version.
+	* config.sub: Import latest version.
+
+2003-02-18  Jason Merrill  <jason@redhat.com>
+
+	* Makefile.tpl (check-c++): Allow parallelism.
+
+2003-02-17  Andrew Cagney  <ac131313@redhat.com>
+
+	* configure: Regenerate using autoconf 000227.
+
+2003-02-15  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in (*-*-darwin*): Rename from powerpc*-*-darwin*,
+	don't configure target-libobjc.
+	* configure: Regenerate.
+
+2003-02-14  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* Makefile.tpl (RANLIB): Define.
+	* Makefile.in: Regenerate.
+
+2003-02-06  Keith R Seitz  <keiths@redhat.com>
+
+	* Makefile.def: Remove "snavigator", "grep", and "db" modules.
+	* Makefile.tpl: Remove "all-snavigator" and "all-grep".
+	* Makefile.in: Regenerated.
+	* configure.in: Remove all traces of snavigator, db, and grep.
+	* configure: Regenerated.
+
+2003-01-31  Frank Ch. Eigler  <fche@redhat.com>
+
+	* Makefile.tpl (all-sid): Add libiberty/bfd/opcodes dependencies.
+	* Makefile.in: Regenerated.
+
+2003-01-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config.if: Copy from GCC.
+
+2003-01-27  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure.in:  Revert 24Jan change.
+	* configure:  Regenerate.
+
+2003-01-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Revert previous change.
+	* configure: Regenerate.
+
+2003-01-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Make rda native-only.
+	* configure: Regenerate.
+
+2003-01-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Add missing \.
+	* configure: Rebuilt.
+
+2003-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (baseargs): Avoid using \| in sed regular
+	expressions.
+	* configure: Rebuilt.
+
+2003-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (baseargs): Remove all supported forms of
+	--cache-file, --srcdir, --host, --build and --target options
+	from argument lists.
+	* configure: Rebuilt.
+
+2003-01-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs): Don't skip gas on IRIX 6.
+	* configure: Rebuilt.
+
+2003-01-09  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Substitute TOPLEVEL_CONFIGURE_ARGUMENTS.
+	* Makefile.tpl: Pass TOPLEVEL_CONFIGURE_ARGUMENTS to gcc.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2003-01-09  Christian Cornelssen  <ccorn@cs.tu-berlin.de>
+
+	* Makefile.tpl (BASE_FLAGS_TO_PASS): Also pass DESTDIR.
+	(install-info, dir.info): Prepend $(DESTDIR) to $(infodir).
+	* Makefile.in: Regenerate.
+
+2003-01-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Remove Makefile in build, host and target modules
+	unless configure was run with --no-recursion.
+	* configure: Rebuilt.
+
+2003-01-08  Chris Demetriou  <cgd@broadcom.com>
+
+	* config.guess: Update to 2003-01-03 version.
+	* config.sub: Update to 2003-01-03 version.
+
+2003-01-07  Christopher Faylor  <cgf@redhat.com>
+
+	* configure: Regenerate with proper autoconf 2.13.
+
+2003-01-07  Christopher Faylor  <cgf@redhat.com>
+
+	* configure.in: Add AC_PREREQ for consistency.
+	* configure: Regenerate.
+
+2003-01-06  Andrew Cagney  <ac131313@redhat.com>
+
+	* configure.in (GDB_TK): Add tcl directories conditional on
+	gdb/gdbtk directory being present.
+	* configure: Regenerate.
+
+2003-01-04 John David Anglin  <dave.anglin@nrc.ca>
+
+	* configure.in (LD): Improve test for gcc.  Try to set LD to the ld used
+	by gcc if LD is not defined and we are not doing a Canadian Cross.
+	* configure: Rebuilt.
+
+2003-01-01  Daniel Jacobowitz  <drow@mvista.com>
+
+	* src-release (ETC_SUPPORT): Add fdl.texi and texi2pod.pl.
+
+2002-12-31  Tom Tromey  <tromey@redhat.com>
+
+	* Makefile.in: Rebuilt.
+	* Makefile.def (target_modules) [libffi]: Allow installation.
+
+2002-12-31  Andreas Schwab  <schwab@suse.de>
+
+	* configure.in: Fix use of $program_transform_name.
+	* configure: Regenerated.
+
+2002-12-30  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in (baseargs): Don't remove first configure argument.
+	* configure: Regenerated.
+
+2002-12-29  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (local-distclean): Don't remove...
+	(multilib.ts): ... this.  Moved into...
+	(multilib.out): ... this.  Don't use sub-make.
+	($(BUILD_SUBDIR)/[+module+]/Makefile, [+module+]/Makefile,
+	$(TARGET_SUBDIR)/[+module+]/Makefile, gcc/Makefile): Moved into...
+	(configure-build-[+module+], configure-[+module+],
+	configure-target-[+module+], configure-gcc): ... these.  Test
+	for Makefile existence.  Drop config.status from dependencies.
+	* Makefile.in: Rebuilt.
+	* configure.in: Move gcc-version-trigger to the end of
+	ac_configure_args.  Add comments to maybedep.tmp and
+	serdep.tmp.  Introduce --disable-serial-configure.  Remove
+	nonopt from baseargs, matching and removing corresponding
+	whitespace while at it.
+	* configure: Rebuilt.
+
+2002-12-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (host_configargs): Replace reference to
+	no-longer-defined buildopts with --build=${build_alias}.
+	* configure: Rebuilt.
+
+2002-12-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl ($(NOTPARALLEL)): Move to the end.  Bring uses of
+	program_transform_name to standard idiom.
+	(AUTOGEN, AUTOCONF): Define.
+	(Makefile.in): Use $(AUTOGEN).
+	(Makefile): Depend on config.status, and use autoconf-style rule to
+	build it.  Move original commands to...
+	(config.status): ... this new target.
+	(configure): Add $(srcdir).  Depend on config/acx.m4.  Use
+	$(AUTOCONF).
+	* Makefile.in: Rebuilt.
+
+2002-12-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Fix dramatic bustage due to change in
+	program_transform_name.
+	* Makefile.in: Regenerate.
+
+	* configure.in: Remove unnecessary PATH setting.
+	* configure: Regnerate.
+
+	* configure.in: Don't default to unprefixed tools unless
+	the native tools will work.
+	* configure: Regenerate.
+
+	* configure.in: Convert to autoconf script.  Blow away lots
+	of now-redundant Makefile fragments.
+	* configure: Generate using Autoconf.
+	* Makefile.tpl: Rewrite to reflect autoconfiscation.
+	* Makefile.in: Regenerate.
+
+2002-12-27  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Remove unneeded 'export's.  Make CC_FOR_TARGET,
+	CXX_FOR_TARGET, GCJ_FOR_TARGET substituted in configure.in only.
+
+	* ChangeLog: Move a couple of entries from here to winsup/cygwin,
+	where they belong.
+
+2002-12-24  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl (multilib.out): Fix missing space.
+	* Makefile.in: Regenerate.
+
+2002-12-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Use shared multilib.out.  Use move-if-change for it.
+	Convert (cd foo; make) to (cd foo && make).  Clean up multilib.out.
+	* Makefile.in: Regenerate.
+	* configure.in: Remove unnecessary leftovers.
+
+2002-12-21  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in (extra_ranlibflags_for_target): New variable.
+	(*-*-darwin): Add -c to ranlib commands.
+	* configure (tooldir): Handle extra_ranlibflags_for_target.
+
+2002-12-20  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Updated.
+	* COPYING.LIBGLOSS: Ditto.
+
+2002-12-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Revert HJL's change.
+	* Makefile.in: Regenerated.
+	* configure.in: Put build_prefix before $(BUILD_SUBDIR) here, and
+	always.
+
+2002-12-19  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl, configure.in: Substitute libstdcxx_incdir.
+	* Makefile.in: Regenerate.
+
+2002-12-18  H.J. Lu <hjl@gnu.org>
+
+	* Makefile.tpl: Add @build_prefix@ before $(BUILD_SUBDIR).
+	* Makefile.in: Regenerated.
+
+	* configure.in (build_prefix): New. Substitute.
+
+2002-12-18  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Don't let real targets depend on phony targets.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl (do-info): Depend on maybe-all-texinfo, not all-texinfo.
+	* Makefile.in: Regenerate.
+
+2002-12-16  Jason Merrill  <jason@redhat.com>
+
+	* Makefile.tpl (all-gcc): Use 'make quickstrap' if there was a
+	previous 'make bootstrap'.
+	* Makefile.in: Regenerate.
+
+2002-12-17  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [mmix-*-*]: Disable libgloss and gdb.
+
+2002-12-13  Jason Merrill  <jason@redhat.com>
+
+	* Makefile.tpl (check-gcc-c++): Renamed from check-c++.  Don't run
+	library tests.
+	(check-c++): Just depend on it and check-target-libstdc++-v3.
+	* Makefile.in: Regenerate.
+
+2002-12-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in, Makefile.tpl, Makefile.def: Remove tclX.
+	* Makefile.in: Regenerate.
+
+2002-12-12  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update list of alternate Regent of California
+	licenses and discuss official revoking of advertising clause.
+	* COPYING.LIBGLOSS: Ditto.
+
+2002-12-12  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (configure-target-rda): Depend on $(ALL_GCC_C).
+	* Makefile.in: Rebuilt.
+
+2002-12-10  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Fix bug put in by gremlins.
+
+	* Makefile.tpl: Substitute more autoconfily.
+	* configure: Substitute more autoconfily.
+	* Makefile.in: Regenerate.
+
+2002-12-08  Andrew Cagney  <ac131313@redhat.com>
+
+	* Makefile.tpl (all-sim): Depend on maybe-configure-gdb.
+	* Makefile.in (all-sim): Ditto.
+
+2002-12-06  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl: Change configure dependencies to not have real
+	targets depend on phony targets.
+
+2002-12-05  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Revert unintentional change.
+
+	* src-release: Configure host subdirs.
+
+	* Makefile.tpl: Change dependency for */multilib.out so that
+	it works when gcc isn't in the tree.
+
+	* configure.in: Substitute more.
+	* configure: Run subconfigures from the Makefile.
+	* Makefile.tpl: Run subconfigures from the Makefile; add a few
+	convenience targets.  Make sure gcc isn't rebuilt after bootstrap.
+
+2002-12-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Add targets for configuring host subdirs in Makefile,
+	and corresponding dependencies.
+	* Makefile.in: Regenerate.
+
+	* configure.in (host_tools): Order binutils, gas and ld for
+	convenience in running the testsuites.
+
+	* Makefile.tpl: Introduce rules to serialize subconfigure runs.
+	* Makefile.in: Regenerate.
+	* configure.in: Introduce rules to serialize subconfigure runs.
+
+	* configure.in: Introduce BASE_CC_FOR_TARGET.
+	* Makefile.tpl: Reorganize and comment.  Introduce HOST_CONFIGARGS.
+	Realize configure-build-* targets.  Realize configure-target-* targets.
+	* Makefile.in: Regenerate.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Move gcc_version_trigger stuff from here...
+	* configure.in: ...to here.
+
+	* configure.in: Separate subconfigure options added by this file from
+	options given by the user.  Add machinery to put args for host
+	subconfigures into the Makefile.
+
+	* Makefile.tpl: Remove 'vault' targets.
+	* Makefile.tpl: Reorder and comment dependencies.
+	* Makefile.in: Regenerate.
+
+2002-11-28  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in: Move host-specific darwin noconfigdirs into
+	the host-specific section.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Restore bkorb's style patch, accidentally lost
+	during replay.
+	* Makefile.in: Regenerate.
+
+	(finishing slow-motion replay)
+	* configure: Remove skip-this-dir support.
+	* Makefile.tpl: Remove skip-this-dir support.
+
+	* Makefile.tpl: Remove leftover support for non-autoconfiscated
+	subdirectories.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Strip out useless setting of 'dir'.
+	* Makefile.in: Regenerate.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(finishing slow-motion replay)
+	* configure.in: Fix deeply stupid bug.
+
+	* configure.in: Introduce RAW_CXX_FOR_TARGET and simplify embedded
+	shell code in CXX_FOR_TARGET
+	* Makefile.def: Introduce raw_cxx.
+	* Makefile.tpl: Use raw_cxx to select between CXX_FOR_TARGET and
+	RAW_CXX_FOR_TARGET.
+	* Makefile.in: Regenerate.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(finishing slow-motion replay)
+	* Makefile.tpl: Remove unnecessary ifs.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Implement soft dependency machinery.  Maybe-ize
+	dependencies.  Maybe-ize build-libiberty.  Create dummy install
+	targets for 'no_install' modules.
+	* configure: Move GDB_TK substitution to configure.in.  Move
+	build_modules stuff to configure.in.
+	* configure.in: Implement soft dependency machinery.  Maybe-ize
+	GDB_TK, rearrange slightly.  Move build_modules stuff from configure.
+	* Makefile.in: Regenerate.
+
+2002-12-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(continuing slow-motion replay)
+	* Makefile.tpl: Make all-target, install-target behave similarly
+	to all, install (only hitting configured targets).  Eliminate
+	unused macro defintions.
+
+	* Makefile.tpl: Add all-gcc: all-build-libiberty dependency when
+	build != host.
+
+	* Makefile.tpl: Add all-gcc: all-libiberty dependency.
+
+	* ltcf-c.sh, ltcf-gcj.sh, Makefile.tpl: Correct BUILD/HOST confusion.
+
+	* configure.in: Produce lists of subdir targets we're actually
+	configuring.  Remove references to "dosrel".
+	* Makefile.tpl: Let configure set which subdir targets are hit.
+	Remove install-cross; clean up install; remove ALL.  Remove
+	references to "dosrel".  Remove "EXTRA_TARGET_HOST" hackery.
+	Autogenerate host module targets.  Remove empty dependency lines
+	and redundant dependency; rearrange slightly.
+	* Makefile.def: Add host-side libtermcap, utils.
+
+	* Makefile.in: Regenerate.
+
+2002-12-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* Makefile.def: Add list of recursive targets to autogenerate.
+	Add build_modules.
+	* Makefile.tpl: Autogenerate do-* targets.  Autogenerate *-target-*
+	targets.  Autogenerate *-build-* targets.
+	* Makefile.in: Regenerate.
+
+2002-11-30  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* configure: More autoconf-style substitutions.
+	* Makefile.tpl: More autoconf-style substitutions.
+	* Makefile.in: Regenerate.
+
+2002-11-30  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* configure: Substitute more variables in a more autoconf-friendly
+	way.  Simplify slightly.
+	* Makefile.tpl: Make more variables substitutable in an
+	autoconf-friendly way.
+	* Makefile.in: Regenerate.
+
+2002-11-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* configure.in (v810*): Remove special setting of tools.
+
+	* configure: Add support for extra required flags for ar or nm.
+	* configure.in (aix4.3+): Use above support for target-specific
+	issues, rather than using config/mt-aix43.
+
+2002-11-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Starting slow-motion replay merge from gcc 3.4 b-i-b branch)
+	* configure: Remove 'removing', which doesn't work.  Replace $subdir
+	with . everywhere.  Replace $subdirs with ''.  Replace $makesrcdir
+	with $srcdir.  Reformat indentation.  Substitute some variables
+	formerly hard-coded in the Makefile for build=host.
+	* Makefile.tpl: Autogenerate more; make more autoconf-friendly.
+	* Makefile.def: Autogenerate more.
+	* Makefile.in: Regenerate.
+
+2002-11-13  Bruce Korb  <bkorb@gnu.org>
+
+	* Makefile.tpl: syntactic cleanup
+
+2002-11-04  Kevin Buettner  <kevinb@redhat.com>
+
+	* Makefile.def (host_modules): Add rda.
+	* Makefile.in: Regenerate.
+	* configure.in (target_tool): Add target-rda to list.
+
+2002-10-25  Phil Edwards  <pme@gcc.gnu.org>
+
+	* Makefile.tpl (bootstrap):  Add bubblestrap, quickstrap, cleanstrap,
+	and restrap targets to this rule.
+	* Makefile.in:  Regenerate.
+
+2002-10-24  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (i[3456]86-*-linux*): Add check to disable
+	${libgcj} for glibc1.
+
+2002-10-07  Svein E. Seldal  <Svein.Seldal@solidas.com>
+
+	* configure.in: Add tic4x target.
+
+2002-10-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make SET_LIB_PATH substitution more autoconfy.
+	* Makefile.tpl: Make RPATH_ENVVAR substitution more autoconfy.
+	* configure.in: Make SET_LIB_PATH substitution more autoconfy.
+	* configure.in: Make RPATH_ENVVAR substitution more autoconfy.
+	* Makefile.in: Regenerate.
+
+2002-10-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Eliminate reference to all-gui, all-libproc.
+	* Makefile.in: Regenerate.
+
+	* Makefile.def: Remove order dependency comments.
+	* Makefile.tpl: Add explicit install-install dependencies.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Remove material now in src-release.  (Finally!)
+	* Makefile.in: Regenerate.
+
+	* configure: Restore my original patch by syncing with gcc version.
+
+	* Bring following over from gcc:
+
+2002-09-30  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* configure.in (s390*-*-linux*): Enable libgcj.
+
+2002-10-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.in: Regenerate.  This really ought to fix things. :sigh:
+
+2002-10-02  Alan Modra  <amodra@bigpond.net.au>
+
+	* configure: Move stray lines back to where they belong.
+
+2002-10-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Insert configure-target target, for src-release.
+
+	* configure: Finish reverting change which Andrew Cagney started
+	reverting.  Should fix bustage.
+
+	* src-release (BINUTILS_SUPPORT_DIRS): Add cpu directory.
+	* src-release: New file.  Contains material for making net
+	releases for gdb, binutils, et al., formerly in Makefile.in.
+
+2002-09-30  Nick Clifton  <nickc@redhat.com>
+
+	* cpu: New top level directory.  Intended to hold input files for
+	CGEN which have FSF copyright assignment.
+	* Makefile.in (BINUTILS_SUPPORT_DIRS): Add cpu directory.
+
+2002-09-29  Andrew Cagney  <ac131313@redhat.com>
+
+	Revert below (note that src does not contain Makefile.tpl):
+	* Makefile.tpl: Make subsituted variables more autoconfy.
+	* Makefile.in: Regenerate.
+
+2002-09-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Revert accidentally applied changes.
+
+	* Makefile.tpl: Make more autoconf-friendly.
+	* Makefile.in: Regenerate.
+	* configure: Make substitution more autoconf-like.
+
+2002-09-28  Richard Earnshaw  <rearnsha@arm.com>
+
+	* configure.in (arm-*-coff, strongarm-*-coff, xscale-*-coff): Use a
+	single entry to handle all these.
+	(arm-*-elf, strongarm-*-elf, xscale-*-elf): Likewise.  Also enable
+	libjava on arm-*-elf.
+
+2002-09-27  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in (powerpc-*-darwin*): Don't configure BFD, TK, or the
+	things that depend on them.
+
+2002-09-25  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make subsituted variables more autoconfy.
+	* Makefile.in: Regenerate.
+	* configure: Make seds more autoconfy.
+
+2002-09-25  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Rewrite substituted lines to look autoconfy.
+	* Makefile.in: Regenerate.
+	* configure.in: Rewrite sed statements to look autoconfy.
+
+	* Makefile.tpl: Autogenerate *-target-* lists, dependencies of
+	all-target-foo on configure-target-foo.
+	* Makefile.def: Ditto.
+	* Makefile.in: Rebuild.
+
+2002-09-22  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def: New file.
+	* Makefile.tpl: New file.
+	* Makefile.in: Generate from Makefile.tpl with 'autogen Makefile.def'.
+
+	* configure.in: Minor rearrangement.  Simplify tests.
+
+2002-09-23  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (with_headers): Skip copy if value is "yes".
+	(with_libs): Likewise.
+
+2002-09-20  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in (*-*-netbsd*): Use noconfigdirs, not skipdirs.
+	* configure.in (sh*-*-pe*): Ditto.
+	* configure.in (mips*-*-pe*): Ditto.
+	* configure.in (*arm-wince-pe): Ditto.
+
+	* configure.in: Rearrange.
+
+2002-09-12  Nick Clifton  <nickc@redhat.com>
+
+	* Import these changes from the config master repository:
+
+	2002-09-05  Svein E. Seldal  <Svein.Seldal@solidas.com>
+
+		* config.sub: Add tic4x target.
+
+	2002-09-03  Ben Elliston  <bje@redhat.com>
+
+		* config.guess: Detect NSR-D machines for nsr-tandem-nsk.
+		Reported by <Duncan_Stodart@insession.com>.
+
+2002-09-10  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: More updates.
+
+2002-09-09  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update.
+
+2002-08-23  Andrew Cagney  <ac131313@redhat.com>
+
+	* texinfo/texinfo.tex: Import version 2002-06-04.06.
+
+	* config.guess: Import version 2002-08-23.
+	* config.sub: Import version 2002-08-22.
+
+2002-08-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (GCC_FOR_TARGET): Prepend STAGE_CC_WRAPPER.
+	* configure.in (CC_FOR_TARGET, GCJ_FOR_TARGET, CXX_FOR_TARGET,
+	CXX_FOR_TARGET_FOR_RECURSIVE_MAKE): Likewise.
+
+2002-08-06  Federico G. Schwindt <fgsch@olimpo.com.br>
+
+	* configure.in (hppa*-*-openbsd*): Treat like hppa*-*-*elf*.
+
+2002-08-04  H.J. Lu  (hjl@gnu.org)
+
+	* configure.in (mips*-*-linux*): Don't skip target-libffi.
+
+2002-07-31  Alan Modra  <amodra@bigpond.net.au>
+
+	* configure.in: Move generic linux case to end.	 Copy generic
+	linux noconfigdirs to mips*-*-linux* entry and new
+	powerpc64*-*-linux* entry.  Add target-libffi for the latter.
+
+2002-07-19  Chris Demetriou  <cgd@broadcom.com>
+
+	* MAINTAINERS: Clarify on config.guess and config.sub, and add
+	one instance of them which was missed to the list to update.
+
+2002-07-16  Chris Demetriou  <cgd@broadcom.com>
+
+	* config.guess: Update to 2002-07-09 version.
+	* config.sub: Update to 2002-07-03 version.
+
+2002-07-11  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Remove two redundant tests.
+
+2002-07-11  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in (mips*-*-irix6*o32): Enable stabs.
+
+2002-07-08  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Don't build grez.
+	* Makefile.in: Ditto.
+
+	* Makefile.in: Remove references to bsp, cygmon, libstub.
+	* configure.in: Ditto.
+
+	* configure.in: Remove leftover reference to gdbtest.
+
+2002-07-08  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure.in (gxx_include_dir):  Change to match versioned
+	C++ headers if --enable-version-specific-runtime-libs is used.
+
+2002-07-04  Steve Ellcey  <sje@cup.hp.com>
+
+	* ltcf-cxx.sh (hpux*): Modify to support ia64-*-hpux*.
+
+2002-07-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Make --without-x work.
+
+2002-07-03  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* contrib: New directory.  Created to contain a copy of the
+	texi2pod.pl script so that it is in the same place as the version in
+	the FSF GCC sources.
+
+2002-07-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Rearrange target Makefile fragment collection.
+
+	* Makefile.in: Don't try to build gdbtest, tgas, ispell, inet, or
+	cvs[src].
+	* configure.in: Ditto.
+
+2002-07-01  Nathanael Nerode <neroden@gcc.gnu.org>
+
+	* Makefile.in: Eliminate 'apache' targets.
+	* configure.in: Eliminate 'apache' targets.
+
+	* configure.in: Eliminate redundant tests.  Reorganize.
+
+	* Makefile.in: Eliminate last reference to LIBGCC1_TEST.
+
+	* config-ml.in: Eliminate references to Cygnus configure.
+
+	* Makefile.in: Eliminate references to building emacs.
+
+2002-07-01  Denis Chertykov  <denisc@overta.ru>
+
+	* configure.in: Add support for ip2k.
+
+2002-06-24  Ben Elliston  <bje@redhat.com>
+
+	* configure.in (host_tools): Remove cgen.
+
+	* Makefile.in (all-cgen): Remove; runs from its source directory.
+	(check-cgen, install-cgen, clean-cgen): Likewise.
+	(all-opcodes): No not depend on all-cgen.
+	(all-sim): Likewise.
+
+2002-06-22  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Fix AIX configury bug.
+
+2002-06-19  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Replace ${topsrcdir} with ${srcdir}.
+
+	* configure.in: Move definition of libstdcxx_flags right above
+	usage, rather than way earlier.
+
+	* configure.in: Pull definition of is_cross_compiler earlier.
+
+	* configure.in: Rearrange a little.
+
+	* configure.in: Remove references to librx.
+	* Makefile.in: Remove references to librx.
+
+2002-06-19  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Eliminate ${gasdir} variable.
+
+2002-06-18  Dave Brolley  <brolley@redhat.com>
+
+	* configure.in: Add support for frv.
+	* config.sub: Add support for frv.
+
+2002-06-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* Makefile.in (CFLAGS_FOR_TARGET): Add -O2.
+
+2002-06-08  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (vax-*-netbsd*): Re-enable gas.
+
+2002-05-31  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* Makefile.in: Replace HOST_PREFIX, HOST_PREFIX_1 with BUILD_PREFIX,
+	BUILD_PREFIX_1, to correct nomenclature.
+	* configure: Likewise.
+
+	* Makefile.in: Eliminate version-specific references to tcl8.1, tk8.1.
+	* configure.in: Eliminate version-specific references to tcl8.1, tk8.1.
+
+2002-05-31  Olaf Hering  <olh@suse.de>
+
+	* config-ml.in: Propogate DESTDIR also.
+
+2002-05-29  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (vax-*-netbsd*): Don't build gas for this
+	platform.
+
+2002-05-28  Marek Michalkiewicz  <marekm@amelek.gda.pl>
+
+	* configure.in (noconfigdirs): Don't compile libiberty, libstdcxx
+	and libgcj for AVR.
+
+2002-05-28  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* config.sub: Add DLX target.
+
+2002-05-22  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* config.guess: Update to 2002-05-22 version.
+	* config.sub: Likewise.
+
+2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* Makefile.in: Allow for PWDCMD to override hardcoded pwd.
+	* config-ml.in: Likewise.
+	* configure: Likewise.
+	* configure.in: Likewise.
+
+2002-05-13  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Simplify makefile fragment collection.
+
+	* configure.in: Remove code to build emacs.
+
+	* configure.in : Remove --srcdir argument from targargs and buildargs
+	(it's always overridden in the Makefile anyway).  Rearrange a bit.
+
+	* configure: Move some logic to configure.in.
+	* configure.in: Move some logic from configure.
+
+2002-05-07  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.LIBGLOSS: New file.
+
+2002-05-07  Federico G. Schwindt <fgsch@olimpo.com.br>
+
+	* Makefile.in: Honour DESTDIR.
+
+2002-05-05  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs): Don't disable libgcj on
+	sparc64-*-solaris* and sparcv9-*-solaris*.
+
+2002-05-03  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Revert 2002-04-18's patch; fixed in libjava.
+
+2002-05-03  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Do not add
+	-B$$r/$(TARGET_SUBDIR)/newlib/ when compiling newlib natively
+	on i[3456]86-*-linux*.
+
+2002-05-01  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (noconfigdirs): Replace [ ] with test.
+
+	* configure.in (noconfigdirs): Do not add target-newlib if
+	target == i[3456]86-*-linux*, and host == target.
+
+2002-04-29  Mark Mitchell  <mark@codesourcery.com>
+
+	* config.guess: Updated to 2002-04-26's version.
+	* config.sub: Updated to 2002-04-26's version.
+
+2002-04-29  Nathanael Nerode  <neroden@doctormoo.dyndns.org>
+
+	* configure.in: delete reference to absent file
+
+	* configure.in: replace '[' with 'test'
+
+	* configure.in: Eliminate references to gash.
+	* Makefile.in: Eliminate references to gash.
+
+	* configure.in: remove useless references to 'pic' makefile fragments.
+
+	* configure.in: (*-*-windows*) Finish removing.
+
+	* configure.in: Eliminate redundant test for libgui.
+
+2002-04-26  Joel Sherrill  <joel@OARcorp.com>
+
+	* configure.in (h8300*-*-rtems*): Disable libf2c and libgcj.
+	(sparc-*-elf*, sparc64-*-elf*): Disable libgcj.
+
+2002-04-19  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: remove references to dead files
+
+2002-04-18  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Disallow configuring libgcj when it is already
+	installed and we're using Solaris 2.8 linker.  Do enable libgcj on
+	Solaris 2.8 by default.  For PR libgcj/6158.
+
+2002-04-17  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in:  Move default CC setting out of config/mh-* fragments
+	directly into here.
+
+2002-04-17  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: don't even try to configure or make a subdirectory
+	if there's no configure script for it.
+
+2002-04-15  Mark Mitchell  <mark@codesourcery.com>
+
+	* MAINTAINERS: Remove chill maintainers.
+	* Makefile.in (CHILLFLAGS): Remove.
+	(CHILL_LIB): Remove.
+	(TARGET_CONFIGDIRS): Remove libchill.
+	(CHILL_FOR_TARGET): Remove.
+	(BASE_FLAGS_TO_PASS): Don't pass CHILLFLAGS, CHILL_FOR_TARGET, or
+	CHILL_LIB.
+	(CONFIGURE_TARGET_MODULES): Remove configure-target-libchill.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(configure-target-libchill): Remove.
+	(all-target-libchill): Remove.
+	* configure.in (target_libs): Remove target-libchill.
+	Do not compute CHILL_FOR_TARGET.
+	* libchill: Remove directory.
+
+2002-04-15  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.in, configure.in, configure: Sync with gcc, entries
+	follow...
+
+2002-04-08  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Add FLAGS_FOR_TARGET to GCJ_FOR_TARGET.
+	Fixes PR libgcj/6068.
+
+2002-03-30  Krister Walfridsson  <cato@df.lth.se>
+
+	* configure.in (i*86-*-netbsdelf*): Don't disable libgcj.
+
+2002-03-27  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in (alpha*-dec-osf*): Enable libgcj.
+
+2002-03-24  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	Fix for: PR bootstrap/3591, target/5676
+	* configure.in (mcore-pe): Disable the configuration of
+	libstdc++-v3 since exceptions are not supported.
+
+2002-03-20  Anthony Green  <green@redhat.com>
+
+	* configure.in: Enable libgcj for xscale-elf target.
+
+2002-02-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Don't add libstdc++-v3 flags for
+	libjava.
+	(CXX_FOR_TARGET): Explain why -shared-libgcc here.
+
+2002-02-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CXX_FOR_TARGET): Add -shared-libgcc for
+	libstdc++-v3 and libjava.
+
+2002-02-11  Adam Megacz <adam@xwt.org>
+
+	* gcc/Makefile.in: Removed libstdc++-v3 dependancy for libjava and
+	boehm-gc
+
+2002-02-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config.guess: Updated to 2002-01-30's version.
+	* config.sub: Updated to 2002-02-01's version.
+	Contribute sh64-elf.
+	2000-12-01  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in: Added sh64-*-*.
+
+2002-01-17  H.J. Lu <hjl@gnu.org>
+
+	* Makefile.in (all-fastjar): Also depend on all-libiberty.
+	(all-target-fastjar): Also depend on all-target-libiberty.
+
+Wed Dec  5 07:33:45 2001  Douglas B. Rupp  <rupp@gnat.com>
+
+	* configure, configure.in: Use temp file for long sed commands.
+
+2001-11-14  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [h8300*-*-*, h8500-*-*]: Disable
+	libf2c.
+
+2001-11-03  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [mmix-*-*]: Disable libgcj.
+
+2001-10-11  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (noconfigdirs) [cris-*-*]: Disable libgcj.
+
+2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* configure: Handle temporary files securely using mkdir.
+
+2001-09-26  Will Cohen <wcohen@redhat.com>
+
+	* configure.in (*-*-linux*): Disable configuration of target-newlib
+	and target-libgloss.
+
+2001-09-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (EXTRA_TARGET_FLAGS): Pass RANLIB_FOR_TARGET for
+	RANLIB.
+
+2001-08-11  Graham Stott  <grahams@redhat.com>
+
+	* Makefile.in (check-c++): Add missing semicolon.
+
+2001-07-25  Andrew Haley  <aph@cambridge.redhat.com>
+
+	* configure.in (sh-*-linux*): New.
+
+2001-07-12  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* configure.in (noconfigdirs): Don't compile libiberty, libstdcxx
+	and libgcj on m68hc11/m68hc12.
+
+2001-06-27  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile (CFLAGS_FOR_BUILD): New.
+	(EXTRA_GCC_FLAGS): Add CFLAGS_FOR_BUILD.
+
+2001-06-01  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (libstdcxx_flags): Do not try to execute
+	libstdc++-v3/testsuite_flags until it exists.
+
+2001-05-18  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* configure.in (libstdcxx_flags): Remove reference to libstdc++.INC.
+
+2001-05-09  Jeffrey Oldham  <oldham@codesourcery.com>
+
+	* ltcf-cxx.sh: Add -nostdlib to IRIX 6 archive_cmds.
+
+Mon Apr 23 09:15:03 2001  Anthony Green  <green@redhat.com>
+
+	* configure.in: Move *-chorusos target case to the proper switch.
+	Disable libgcj.
+
+2001-04-13  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* Makefile.in (STAGE1_CFLAGS): Pass down.
+
+2001-04-13  Alan Modra  <amodra@one.net.au>
+
+	* config.guess: Add hppa64-linux support.  Note for next import that
+	this is already in the master file.
+	* configure.in: Likewise.  Accept `parisc' alias for `hppa'.
+
+2001-03-22  Colin Howell  <chowell@redhat.com>
+
+	* Makefile.in (DO_X): Do not backslash single-quotes in
+	backquotes (two places).
+
+2001-03-18  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in (DO_X): Quote nested quotes.
+
+2001-03-15  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in (DO_X): Use double quotes for quoting
+	"RANLIB=$${RANLIB}".
+
+2001-03-09  Nicola Pero <n.pero@mi.flashnet.it>
+
+	* configure.in: Only use `lang_requires' for languages athat are
+	actually enabled.
+
+2001-03-07  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Allow config-lang.in to set `lang_requires' to list
+	of other required languages.
+
+2001-03-06  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in: Remove RANLIB definition. Use RANLIB
+	in RANLIB_FOR_TARGET, EXTRA_HOST_FLAGS, EXTRA_TARGET_FLAGS,
+	EXTRA_GCC_FLAGS, $(DO_X) targets only when the RANLIB is set.
+
+2001-02-28  Benjamin Kosnik  <bkoz@redhat.com>
+	    Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (check-c++): Use tabs, not spaces.
+
+2001-02-19  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* Makefile.in (check-c++): New rule.
+
+	* configure.in (target_libs): Remove libg++.
+	(noconfigdirs): Remove libg++.
+	(noconfigdirs): Same.
+	(noconfigdirs): Same.
+	(noconfigdirs): Same.
+
+	* config-ml.in: Remove libg++ references.
+
+	* Makefile.in (TARGET_CONFIGDIRS): Remove libio, libstdc++, libg++.
+	(ALL_TARGET_MODULES): Same.
+	(configure-target-libg++): Remove.
+	(all-target-libg++): Remove.
+	(configure-target-libio): Remove.
+	(all-target-libio): Remove.
+	(check-target-libio): Remove.
+	(.PHONY): Remove.
+	(libg++.tar.bz2): Remove.
+	(all-target-cygmon): Remove libio.
+	(all-target-libstdc++): Remove.
+	(configure-target-libstdc++): Remove.
+	(TARGET_LIB_PATH): Remove libstdc++.
+	(ALL_GCC_CXX): Remove libstdc++.
+	(all-target-gperf): Correct.
+
+2001-02-15  Anthony Green  <green@redhat.com>
+
+	* configure: Introduce GCJ_FOR_TARGET.
+	* configure.in: Ditto.
+	* Makefile.in: Ditto.
+
+2001-02-08  Chandrakala Chavva <cchavva@redhat.com>
+
+	* configure.in: for *-chorusos, don't config target-newlib and
+	target-libgloss.
+
+2001-02-04  Mark Mitchell  <mark@codesourcery.com>
+
+	Remove V2 C++ library.
+	* configure.in: Remove --enable-libstdcxx_v3 support.
+
+2001-01-27  Richard Henderson  <rth@redhat.com>
+
+	* configure.in (target_makefile_frag) [alpha*-*]: Use mt-alphaieee.
+
+2001-01-26  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Allow libgcj to be built on Sparc Solaris.
+
+2001-01-23  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* configure.in: Enable libgcj on several additional platforms.
+
+2001-01-22  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* configure.in: Enable libgcj for linux targets.
+
+2001-01-09  Mike Stump  <mrs@wrs.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Pass back configuration
+	failures of subdirectories.
+
+2001-01-02  Laurynas Biveinis  <lauras@softhome.net>
+
+	* configure: handle DOS-style absolute paths.
+
+2001-01-02  Laurynas Biveinis  <lauras@softhome.net>
+
+	* configure.in: remove supported directories from $noconfigdirs for DJGPP.
+
+2000-12-18  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Alphabetize.
+	(libstdcxx_incdir): Pass down.
+	* config.if: Remove expired bits for cxx_interface, add stub.
+	(libstdcxx_incdir): Add variable for g++ include directory.
+	* configure.in (gxx_include_dir): Use it.
+
+2000-12-15  Andreas Jaeger  <aj@suse.de>
+
+	* configure.in: Handle lang_dirs.
+
+2000-12-13  Anthony Green  <green@redhat.com>
+
+	* configure.in: Disable libgcj for any target not specifically
+	listed.  Disable libgcj for x86 and Alpha Linux until compatible
+	with g++ abi.
+
+2000-12-13  Mike Stump  <mrs@wrs.com>
+
+	* Makefile.in (local-distclean): Also remove fastjar.
+
+2000-12-10  Anthony Green  <green@redhat.com>
+
+	* configure.in: Define libgcj.  Disable libgcj target libraries for
+	most targets.
+
+2000-12-09  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* configure.in (target_libs): Revert 2000-12-08 patch.
+	(noconfigdirs): Added target-libjava.
+
+2000-12-09  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in: handle DOS-style absolute paths.
+
+2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* Makefile.in (TARGET_CONFIGDIRS): Wrong place. Removed note about
+	libjava.
+	* configure.in (target_libs): Removed `target-libjava'.
+
+2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* Makefile.in (TARGET_CONFIGDIRS): Added note about libjava.
+	(ALL_MODULES): Added fastjar.
+	(NATIVE_CHECK_MODULES, INSTALL_MODULES, CLEAN_MODULES): Likewise.
+	(all-target-libjava): all-fastjar replaces all-zip.
+	(all-fastjar): Added.
+	(configure-target-fastjar, all-target-fastjar): Likewise.
+	* configure.in (host_tools): Added fastjar.
+
+2000-12-07  Mike Stump  <mrs@wrs.com>
+
+	* Makefile.in (local-distclean): Remove leftover built files.
+
+2000-11-16  Fred Fish  <fnf@be.com>
+
+	* configure.in (enable_libstdcxx_v3): Fix typo,
+	libstd++ -> libstdc++.
+
+2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* configure: Provide the original toplevel configure arguments
+	(including $0) to subprocesses in the environment rather than
+	through gcc/configargs.h.
+
+2000-11-12  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure: Turn on libstdc++ V3 by default.
+
+2000-10-16  Michael Meissner  <meissner@redhat.com>
+
+	* configure (gcc/configargs.h): Only create if there is a build GCC
+	directory created.
+
+2000-10-05  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure: Save configure arguments to gcc/configargs.h.
+
+2000-10-04  Andris Pavenis  <pavenis@latnet.lv>
+
+	* Makefile.in (bootstrap): avoid recursion if subdir missing
+	(cross): ditto
+	(do-proto-toplev): ditto
+
+Wed Sep 13 11:11:29 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Do not build byacc for hppa64.  Provide paths to the
+	X11 libraries for hppa64.
+
+2000-09-02  Anthony Green  <green@cygnus.com>
+
+	* Makefile.in (all-gcc): Depend on all-zlib.
+	(CLEAN_MODULES): Add clean-zlib.
+	(ALL_MODULES): Add all-zlib.
+	* configure.in (host_libs): Add zlib.
+
+2000-08-25  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Use $target_configdirs and
+	$targargs to tell whether newlib is going to be built.
+
+	* configure.in [disable-libstdcxx-v3] (libstdcxx_flags): Search
+	$$r/TARGET_SUBDIR/libio for _G_config.h.
+
+2000-08-14  Zack Weinberg  <zack@wolery.cumb.org>
+
+	* configure.in (libstdcxx_flags): Remove -isystem $$s/libio/stdio.
+
+	* configure: Make enable_threads and enable_shared defaults
+	explicit.  Substitute enable_threads into generated Makefiles.
+	* configure.in: Accept *-*-linux* not just *-*-linux-gnu*.
+	* libtool.m4: Accept *-*-linux* not just *-*-linux-gnu*.
+
+2000-08-02  Manfred Hollstein  <manfredh@redhat.com>
+
+	* configure.in: Re-enable all references to libg++ and librx.
+
+2002-04-09  Loren James Rittle  <rittle@labs.mot.com>
+
+	* configure.in: Add *-*-freebsd* configurations.
+
+2002-04-07  Andrew Cagney  <ac131313@redhat.com>
+
+	* Makefile.in (do-tar-bz2): Delete rule.  Replace with ...
+	(do-tar, do-bz2): New rules.
+	(taz): Update.  Replace do-tar-bz2 with do-tar and do-bz2.
+	(gdb-tar): New rule.
+	(gdb-taz): Rewrite.  Use gdb-tar and do-bz2.
+	(insight_dejagnu.tar): New rule.
+	(insight.tar): New rule.
+	(gdb+dejagnu.tar): New rule.
+	(gdb.tar): New rule.
+
+2002-04-07  Andrew Cagney  <ac131313@redhat.com>
+
+	* MAINTAINERS: Update dejagnu/
+
+2002-03-16  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltmain.sh (relink_command): Fix typo in previous change.
+
+2002-03-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltmain.sh (taglist): Initialized.  Don't let `CC' tag out of it.
+	(relink_command): Added --tag flags.
+	(mode=install): If relinking fails; error out.
+
+2002-03-12  Richard Henderson  <rth@redhat.com>
+
+	* Makefile.in (NOTPARALLEL): New.  Use it instead of explicit
+	.NOTPARALLEL tag.
+	(do-check): Rename from check.
+	(check): Allow parallel check.
+
+2002-03-11  Richard Henderson  <rth@redhat.com>
+
+	* Makefile.in (.NOTPARALLEL): Add fake tag.
+
+2002-03-07  H.J. Lu  (hjl@gnu.org)
+
+	* configure.in: Enable gprof for mips*-*-linux*.
+
+2002-02-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Don't add libstdc++-v3 flags for
+	libjava.
+	(CXX_FOR_TARGET): Add -shared-libgcc for libstdc++-v3 and libjava.
+
+2002-02-24  Andrew Cagney  <ac131313@redhat.com>
+
+	* texinfo/texinfo.tex: Update to version 2002-02-14.08.
+
+2002-02-23  Daniel Jacobowitz  <drow@mvista.com>
+
+	* config.guess: Import from master sources, rev 1.232.
+	* config.sub: Import from master sources, rev 1.246.
+
+2002-02-23  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (MAKEINFO): Don't assume makeinfo will be built just
+	because its Makefile is there; test for the executable instead.
+
+2002-02-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	Contribute sh64-elf.
+	2000-12-01  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in: Added sh64-*-*.
+
+2002-02-04  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Remove advertising clause from
+	Berkeley and Red Hat licenses.
+
+2002-02-01  Mo DeJong  <supermo@bayarea.net>
+
+	* Makefile.in: Add all-tix to deps for all-snavigator
+	so that tix is built when building snavigator.
+
+2002-02-01  Ben Elliston  <bje@redhat.com>
+
+	* config.guess: Import from master sources, rev 1.229.
+	* config.sub: Import from master sources, rev 1.240.
+
+2002-01-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	From Steve Ellcey <sje@cup.hp.com>:
+	* libtool.m4 (HPUX_IA64_MODE): Set to 32 or 64 based on ABI.
+	(lt_cv_deplibs_check_method, lt_cv_file_magic_cmd,
+	lt_cv_file_magic_test_file): Set to appropriate values for HP-UX
+	IA64.
+	* ltcf-c.sh (archive_cmds, hardcode_*): Ditto.
+	* ltconfig (shlibpath_*, dynamic_linker, library_names_spec,
+	soname_spec, sys_lib_search_path_spec): Ditto.
+
+2002-01-26  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (*-*-netbsd*): New.  Skip target-newlib,
+	target-libiberty, and target-libgloss.  Skip Java-related
+	libraries if not supported for NetBSD on target CPU.
+
+2002-01-23  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* configure.in: Import StrongARM and XScale target_configdirs from
+	FSF GCC version.
+
+2002-01-16  H.J. Lu  (hjl@gnu.org)
+
+	* config.guess: Import from master sources, rev 1.225.
+	* config.sub: Import from master sources, rev 1.238.
+
+	* MAINTAINERS: Updated notes on config.guess and config.sub.
+
+2002-01-11  Steve Ellcey  <sje@cup.hp.com>
+
+	* configure.in (ia64*-*-hpux*): New target for IA64 HP-UX,
+	ld and gdb are not supported.
+
+2002-01-07  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* Change reference to Cygnus Solutions to be Red Hat.
+
+2002-01-07  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update generic copyright date.
+
+2002-01-07  Mark Salter  <msalter@redhat.com>
+
+	* configure.in: Remove target-bsp and target-cygmon from arm builds.
+	  Allow target-libgloss to be built for arm, strongarm, and xscale.
+
+2002-01-03  Ben Elliston  <bje@redhat.com>
+
+	* MAINTAINERS: Update URL for config.* scripts.
+
+2001-12-18  Alan Modra  <amodra@bigpond.net.au>
+
+	* config.sub: Import latest version.
+	* config.guess: Likewise.
+
+2001-12-13  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Remove -nostdinc and -isystem
+	options for i[3456]86-pc-linux* native builds.
+
+2001-12-05  Laurent Guerby  <guerby@acm.org>
+
+	* MAINTAINERS: gcc adopts symlink-tree, refer more to
+	libiberty.
+
+	Import this patch from gcc:
+
+	2000-12-09  Laurynas Biveinis  <lauras@softhome.net>
+
+	    * symlink-tree: handle DOS-style absolute paths.
+
+2001-11-28  DJ Delorie <dj@redhat.com>
+	    Zack Weinberg  <zack@codesourcery.com>
+
+	When build != host, create libiberty for the build machine.
+
+	* Makefile.in (TARGET_CONFIGARGS, BUILD_CONFIGARGS): Replace
+	CONFIG_ARGUMENTS.
+	(ALL_BUILD_MODULES_LIST, BUILD_CONFIGDIRS, BUILD_SUBDIR):
+	New variables.
+	(ALL_BUILD_MODULES, CONFIGURE_BUILD_MODULES): New variables
+	and rules.
+	(all.normal): Depend on ALL_BUILD_MODULES.
+	(CONFIGURE_TARGET_MODULES rule): Use TARGET_CONFIGARGS.
+	(all-build-libiberty): Depend on configure-build-libiberty.
+
+	* configure: Calculate and substitute proper value for
+	ALL_BUILD_MODULES.
+	* configure.in: Create the build subdirectory.
+	Calculate and substitute TARGET_CONFIGARGS (formerly
+	CONFIG_ARGUMENTS); also BUILD_SUBDIR and BUILD_CONFIGARGS (new).
+
+2001-11-26  Geoffrey Keating  <geoffk@redhat.com>
+
+	* config.sub: Update to version 1.232 on subversion.
+
+2001-11-20  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* Makefile.in (do-proto-toplev): Use msgfmt to generate .gmo
+	files from .po files for a distribution.
+
+2001-11-19  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* COPYING.NEWLIB: Mention preserved notice in specific parts.
+
+2001-11-13  Jeff Holcomb  <jeffh@redhat.com>
+
+	Merged from net gcc:
+	2001-07-30  Jeff Sturm  <jsturm@one-pont.com>
+	* ltcf-c.sh: Use $objext, not $ac_objext.
+	2001-07-27  Mark Kettenis  <kettenis@gnu.org>
+	* ltcf-cxx.sh: Add support for GNU.
+	2001-07-22  Timothy Wall  <twall@redhat.com>
+	* ltcf-c.sh: Don't disable shared libraries for AIX5/IA64.  Preserve
+	default settings if using GNU tools with that configuration.
+	* ltcf-cxx.sh: Ditto.
+	* ltcf-gcj.sh: Ditto.
+	2001-07-21  Michael Chastain  <chastain@redhat.com>
+	* ltconfig: Set max_cmd_len to a maximum of 512Kb, as it seems some
+	HPUX 11.0 systems have trouble with 1MB.  Mark as gcc-local.
+	* ltmain.sh: Mark as gcc-local.
+
+2001-11-13  Jeff Holcomb  <jeffh@redhat.com>
+
+	* Makefile.in (all-bison): Revert 2001-10-24.
+	Don't depend on texinfo.
+
+2001-11-12  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* COPYING.NEWLIB: Add BSD-style license/copyright blurb for my work.
+
+2001-11-08  Phil Edwards  <pedwards@disaster.jaj.com>
+
+	* configure.in (--enable-languages): Be more permissive about
+	syntax.  Check for empty lists better.  Warn about $LANGUAGES.
+
+2001-11-06  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* Makefile.in (MAKEINFO): Use "missing" for makeinfo older than 4.0.
+
+2001-10-24  Jeff Holcomb  <jeffh@redhat.com>
+
+	Makefile.in (all-bison): Don't depend on texinfo.
+
+2001-10-03  Alan Modra  <amodra@bigpond.net.au>
+
+	* gettext.m4: Test po/POTFILES.in exists before trying to read.
+
+2001-09-29  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (configure-target-gperf): Depend on $(ALL_GCC_CXX).
+
+2001-09-28  Hans-Peter Nilsson  <hp@axis.com>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-09-21  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (AS_FOR_TARGET, LD_FOR_TARGET,
+	DLLTOOL_FOR_TARGET, WINDRES_FOR_TARGET, AR_FOR_TARGET,
+	RANLIB_FOR_TARGET, NM_FOR_TARGET): Don't use double quotes to
+	avoid quotes nesting problems.
+	(NATIVE_CHECK_MODULES): Ditto, just for consistency.
+	(DO_X): Export only variables that are set.
+
+2001-09-19  Ben Elliston  <bje@redhat.com>
+
+	* configure.in (sparc-sun-solaris2*): Don't use /usr/bin/which on
+	Solaris when testing for the /usr/ucb/cc compiler; it has incorrect
+	semantics.  Use the shell built-in "type" command instead.
+
+2001-09-15  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+
+	* config.sub: Reverted the earlier change, this version is not the
+	master file.
+
+2001-09-14  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+
+	* config.sub: Change machine triplets from mipsel*-* to mips*el-*.
+	Add support for mips64.
+
+2001-09-03  Jeff Holcomb  <jeffh@redhat.com>
+
+	* configure.in: Enable libstdc++-v3 for h8300 targets.
+
+2001-08-30  Eric Christopher  <echristo@redhat.com>
+	    Jason Eckhardt  <jle@redhat.com>
+
+	* config.sub: Add support for mipsisa32.
+
+2001-08-30  Eric Christopher  <echristo@redhat.com>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-08-20  Alan Modra  <amodra@bigpond.net.au>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-07-26  DJ Delorie  <dj@redhat.com>
+
+	* MAINTAINERS: Clarify libiberty merge rules and procedures.
+
+2001-06-19  Alan Modra  <amodra@bigpond.net.au>
+
+	* Makefile.in: Revert 2001-06-17.
+	(VER): If AM_INIT_AUTOMAKE uses BFD_VERSION, get version from bfd/.
+
+2001-06-17  H.J. Lu <hjl@gnu.org>
+
+	* Makefile.in (gas.tar.bz2): Pass TOOL=bfd PACKAGE=gas to make.
+	(gas+binutils.tar.bz2): Likewise.
+	(binutils.tar.bz2): Pass TOOL=bfd PACKAGE=binutils to make.
+
+Fri Jun  8 11:14:02 2001  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (VER): When present, extract the version number from
+	the file version.in.
+
+2001-06-08  Alexandre Oliva  <aoliva@redhat.com>, Jeff Sturm  <jsturm@one-point.com>
+
+	* Makefile.in (AS_FOR_TARGET, LD_FOR_TARGET, NM_FOR_TARGET): If
+	gcc/xgcc is built, use -print-prog-name to find out the program
+	name to use.
+
+2001-06-04  Mark Mitchell  <mark@codesourcery.com>
+
+	* ltcf-c.sh (archive_cmds, archive_expsym_cmds) [solaris,
+	with_gcc]: Use `gcc -shared' to build a shared library.
+
+2001-06-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>
+
+	* ltcf-c.sh (archive_cmd) [hpux, with_gcc]: Use gcc to link shared
+	archives.
+
+2001-05-28  Simon Patarin <simon.patarin@inria.fr>
+
+	* ltcf-cxx.sh (osf3/osf4/osf5): Support creation of C++  shared
+	libraries when using g++ with native linker.
+
+2001-05-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh: Upgrade to libtool 1.4a 1.641.2.256.
+
+2001-05-24  Tom Rix <trix@redhat.com>
+
+	* configure.in : enable ld for aix
+
+2001-05-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-cxx.sh (allow_undefined_flag, no_undefined_flag)
+	[aix4*|aix5*]: Prepend blank.
+
+2001-05-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh, ltcf-cxx.sh,
+	ltcf-gcj.sh: Upgraded to libtool 1.4a 1.641.2.254.  Rebuilt a number
+	of subdir/configure scripts to use the new libtool.m4.
+
+2001-05-14  H.J. Lu <hjl@gnu.org>
+
+	* config.if (libc_interface): Set to -libc6.2- for cross
+	compiling to Linux/glibc 2.2.
+
+2001-05-03  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs) [*-cygwin*, *-mingw*, *-beos]: Disable
+	libgcj.
+
+2001-04-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs): Don't reset it from scratch in the
+	target case; only append to it.
+
+2001-04-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs) [hppa*-*-*, mips*-*-irix6*,
+	sparc-*-solaris2.8]: Disable ${libgcj}.
+
+2001-04-25  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libgcj_saved): Copy from $libgcj.
+	(libgcj): Zero out if --enable-libgcj; add to noconfigdirs is
+	--disable-libgcj.
+
+2001-04-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, ltcf-cxx.sh: Upgraded to libtool 1.4a
+	1.641.2.228.
+
+2001-04-12  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh, ltcf-cxx.sh,
+	ltcf-gcj.sh: Upgraded to libtool 1.4a 1.641.2.226.
+
+2001-04-01  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (CXX_FOR_TARGET_FOR_RECURSIVE_MAKE, RECURSE_FLAGS):
+	New macros.
+	(bootstrap, cross): Use RECURSE_FLAGS.
+	* configure.in: Subst CXX_FOR_TARGET_FOR_RECURSIVE_MAKE.
+
+2001-03-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CXX_FOR_TARGET): Use xgcc for libstdc++-v3.
+
+2001-03-23  Nick Clifton  <nickc@redhat.com>
+
+	* README-maintainer-mode: Add note about inability to use "make
+	distclean" in maintainer mode.
+
+2001-03-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	Re-installed:
+	2001-01-02  Laurynas Biveinis  <lauras@softhome.net>
+	* ltcf-c.sh: Clear ac_cv_prog_cc_pic for DJGPP.  Do not add
+	'-DPIC' to ac_cv_prog_cc_pic for DJGPP.
+	* ltcf-cxx.sh: Likewise.
+	* ltcf-gcj.sh: Likewise.
+
+2001-03-22  Philip Blundell  <philb@gnu.org>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-03-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh, ltcf-cxx.sh,
+	ltcf-gcj.sh: Upgraded to libtool 1.4a 1.641.2.198.
+
+2001-03-20  Michael Chastain  <chastain@redhat.com>
+
+	* Makefile.in: all-m4 depends on all-texinfo.
+
+2001-03-08  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (ALL_GCC, ALL_GCC_C, ALL_GCC_CXX): Set before use.
+
+2001-02-22  Jeff Johnston <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Remove DJ Delorie's address because it is no
+	longer valid.
+
+2001-02-16  Nick Clifton  <nickc@redhat.com>
+
+	* configure.in (noconfigdirs): Allow configuration of texinfo
+	for Cygwin hosts.
+
+2001-02-09  Martin Schwidefsky  <schwidefsky@de.ibm.com>
+
+	* config.guess: Add linux target for S/390.
+	* config.sub: Likewise.
+	* configure.in: Likewise.
+
+2001-02-06  Ben Elliston  <bje@redhat.com>
+
+	* configure: Output host type to stdout, not stderr.
+
+2001-02-04  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* config.guess: Import from subversions.gnu.org (revision 1.181).
+	* config.sub: Import from subversions.gnu.org (revision 1.199).
+
+2001-01-30  Alan Modra  <alan@linuxcare.com.au>
+
+	* config.guess: Handle hppa64-linux systems.
+
+2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* ltcf-cxx.sh (ac_cv_prog_cc_pic_works, ac_cv_prog_cc_static_works):
+	Don't unset, it's non-portable and no longer necessary, set to empty
+	instead.
+
+2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>,  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* ltconfig: Shell portability fix for the tagname validity check.
+
+2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* ltcf-cxx.sh: Use parentheses around eval $ac_compile.
+
+2001-01-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-c.sh (ld_shlibs) [aix5*]: Disable on unknown CPU types.
+	* ltcf-cxx.sh, ltcf-gcj.sh: Likewise.
+
+2001-01-24  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltmain.sh (TAG disable-shared, TAG disable-static): Make sure we
+	keep at least one of build_libtool_libs or build_old_libs set to
+	yes.
+
+2001-01-24  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-gcj.sh (lt_simple_link_test_code): Remove stray `(0)'.
+	* libtool.m4 (_AC_LIBTOOL_GCJ): Pass $CPPFLAGS on.
+
+2000-11-07  Philip Blundell  <pb@futuretv.com>
+
+	* Makefile.in (ETC_SUPPORT): Also add configbuild.* and configdev.*.
+
+2000-11-03  Philip Blundell  <pb@futuretv.com>
+
+	* Makefile.in (ETC_SUPPORT): Add configure.texi and associated info
+	files.
+
+2001-01-15  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Put into source repository.
+
+2001-01-15  Ben Elliston  <bje@redhat.com>
+
+	* configure.in (host_tools): Add sid.
+	Always configure cgen.
+	* Makefile.in (all-sid): New target.
+	(check-sid, clean-sid, install-sid): Likewise.
+
+2001-01-07  Andreas Jaeger  <aj@suse.de>
+
+	* config.sub, config.guess: Update from subversions.
+
+2000-12-12  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Disable language-specific target libraries for
+	languages that aren't enabled.
+
+2000-11-24  Nick Clifton  <nickc@redhat.com>
+
+	* configure.in (xscale-elf): Add target.
+	(xscale-coff): Add target.
+	(c4x, c5x, tic54x): Move after ARM targets.
+
+2000-11-23  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-gcj.sh: Added file, required by 2000-11-18 merge.
+
+2000-11-20  Ian Lance Taylor  <ian@zembu.com>
+
+	* ltcf-cxx.sh: Added file, required by 2000-11-18 merge.
+
+2000-11-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in: Merge with GCC and libgcj.
+	(ALL_GCC_C, ALL_GCC_CXX): New macros.  Use them as dependencies of
+	configure-target-<library> when their configure scripts need the C
+	or C++ library to have already been built to work properly.
+	(do_proto_toplev): Set them to an empty string.
+
+2000-11-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (HOST_LIB_PATH, TARGET_LIB_PATH): New macros.
+	(REALLY_SET_LIB_PATH): Use them.
+
+2000-11-06  Christopher Faylor <cgf@cygnus.com>
+
+	* config.sub: Add support for Sun Chorus
+
+2000-11-02  Per Lundberg  <plundis@chaosdev.org>
+
+	* config.sub: Add support for the *-storm-chaos OS.
+
+2000-10-30  Stephane Carrez  <stcarrez@worldnet.fr>
+
+	* configure.in (noconfigdirs): Don't compile some
+	of the libraries for 68HC11 & 68hc12 targets.
+
+2000-09-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4: Updated from libtool
+	multi-language branch, to work around Solaris' /bin/sh bug.  Rebuilt
+	all affected `configure' scripts.
+
+2000-09-25  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (DEVO_SUPPORT): Added gettext.m4, libtool.m4 and
+	ltcf-c.sh.
+
+2000-09-12  Philip Blundell  <philb@gnu.org>
+
+	* config.sub, config.guess: Update from subversions.
+
+2000-09-06  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (all-zlib): Added dummy target.
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh: Updated from libtool
+	multi-language branch.
+
+2000-09-05  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (all-bootstrap): Added all-texinfo and all-zlib.
+	(bootstrap*): Depend on all-bootstrap.
+
+2000-09-02  Alexandre Oliva  <aoliva@redhat.com>, DJ Delorie  <dj@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Use -nostdinc even for Canadian
+	crosses, but add gcc/include to the header search path for them.
+
+2000-08-31  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh: Updated from libtool multi-language branch.
+	* libtool.m4, ltcf-c.sh: Copied from libtool multi-language branch.
+	* gettext.m4: New file, extracted from aclocal.m4.
+
+2000-08-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config-ml.in (CC, CXX): Avoid trailing whitespace.
+	(LD_LIBRARY_PATH, SHLIB_PATH): Adjust for multilibs and export to
+	sub-configures.
+
+2000-08-20  Doug Evans  <dje@casey.transmeta.com>
+
+	* Makefile.in (ALL_MODULES): Add all-cgen.
+	(CROSS_CHECK_MODULES,INSTALL_MODULES,CLEAN_MODULES): Similarily.
+	(all-cgen): New target.
+	(all-opcodes,all-sim): Depend on all-cgen.
+	* configure.in (host_tools): Add cgen.
+	Only configure cgen if --enable-cgen-maint.
+
+2000-08-17  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config-ml.in (CC, CXX): Don't introduce a leading space.
+
+2000-08-16  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Use
+	libstdc++-v3/src/libstdc++.INC.
+
+2000-08-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Use libstdc++-v3/src/INCLUDES.
+
+2000-08-11  Jason Merrill  <jason@redhat.com>
+
+	* configure.in (CC_FOR_TARGET, CHILL_FOR_TARGET,
+	CXX_FOR_TARGET): Add -B$$r/gcc/ here.
+	(FLAGS_FOR_TARGET): Not here.
+	(CHILL_FOR_TARGET, CXX_FOR_TARGET): Don't check the list of languages.
+
+2000-08-07  DJ Delorie  <dj@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): invert test for xgcc, should mean
+	"if we're also building gcc, and it's a gcc that will run on the
+	build machine, we want to use its includes instead of the system's
+	default includes".
+
+2000-08-03  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Don't use `"'.
+
+	* config-ml.in: Adjust multilib search paths to the
+	appropriate multilib tree.
+
+2000-08-02  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CHILL_FOR_TARGET, CXX_FOR_TARGET): Convert blanks to
+	commas in $LANGUAGES.
+
+2000-08-01  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (qCXX_FOR_TARGET): Use echo instead of expr.
+
+2000-07-31  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (qCXX_FOR_TARGET): Quote `&' characters in
+	CXX_FOR_TARGET for sed.
+
+2000-07-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CC_FOR_TARGET, CHILL_FOR_TARGET, CXX_FOR_TARGET):
+	Do not override if already set in the environment or in configure.
+	Don't duplicate $(FLAGS_FOR_TARGET) if it already appears in them.
+	(FLAGS_FOR_TARGET): Don't use host directories on Canadian crosses.
+
+2000-07-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (FLAGS_FOR_TARGET): New macro.
+	(GCC_FOR_TARGET): Use it.
+	(CC_FOR_TARGET, CXX_FOR_TARGET, CHILL_FOR_TARGET): Now defined...
+	* configure.in: ... here.
+	(FLAGS_FOR_TARGET): Define.  Add ld build dir to -L path.
+	(libstdcxx_flags): Define and append to CXX_FOR_TARGET.
+
+2000-07-24  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (configure-target-libf2c): Depend on $(ALL_GCC).
+	(configure-target-libchill, configure-target-libobjc): Likewise.
+
+	* configure.in: Use the same cache file for all target libs.
+	* config-ml.in: But different cache files per multilib variant.
+
+2000-07-23  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* configure (topsrcdir): Don't use dirname.
+
+2000-07-20  Jason Merrill  <jason@redhat.com>
+
+	* configure.in: Remove all references to libg++ and librx.
+
+	* configure, configure.in, Makefile.in: Unify gcc and binutils.
+
+2000-07-20  Hans-Peter Nilsson  <hp@axis.com>
+
+	* config.sub: Update to subversions version 2000-07-06.
+
+2000-07-12  Andrew Haley  <aph@cygnus.com>
+
+	* configure.in (host_makefile_frag): Use mh-ia64pic on IA-64 hosts.
+	(target_makefile_frag): Use mt-ia64pic on IA-64 targets.
+
+2000-07-07  Phil Edwards  <pme@sourceware.cygnus.com>
+
+	* symlink-tree:  Check number of arguments.
+
+2000-06-06  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* texinfo/texinfo.tex: Update to version 2000-05-28.15.
+
+2000-07-05  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (CXX_FOR_TARGET): Add libstdc++ to the library
+	search path for a g++ extracted from the build tree.  This
+	will allow link tests run by configure scripts in
+	subdirectories to succeed.
+
+2000-07-01  Koundinya K  <kk@ddeorg.soft.net>
+
+	* ltconfig: Add support for mips-dde-sysv4.2MP
+
+2000-06-28  Corinna Vinschen  <vinschen@cygnus.com>
+
+	* ltconfig: Check for host_os beeing one of `cygwin', `mingw' or
+	`os2'. Force ac_cv_exeext to be ".exe" in that case.
+
+2000-06-19  Timothy Wall  <twall@cygnus.com>
+
+	* configure.in (noconfigdirs): Set noconfigdirs for tic54x target.
+	* config.sub: Add tic54x target.
+
+2000-06-07  Phillip Thomas  <pthomas@suse.de>
+
+	* README-maintainer-mode: New file: Contains notes on using
+	--enable-maintainer-mode with binutils.
+
+2000-05-29  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* texinfo/texinfo.tex: Update. Version from makeinfo 4.0.
+
+2000-05-30  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* config.sub: Import CVS version 1.167 Tue May 30 09:00:07 2000.
+	* config.guess: Import CVS version 1.148 Tue May 30 09:00:06 2000
+
+20000-05-21  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile.in (CC_FOR_TARGET): Make sure as/ld in the gcc
+	directory are used if they exist. Make sure
+	$(build_tooldir)/include is searched for header files,
+	$(build_tooldir)/lib/ for library files.
+	(GCC_FOR_TARGET): Likewise.
+	(CXX_FOR_TARGET): Likewise.
+
+2000-05-18  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (hppa*64*-*-*): Do build ld for this configuration.
+
+2000-05-17  Alexandre Oliva  <aoliva@cygnus.com>
+
+	* Makefile.in (configure-target-libiberty): Depend on
+	configure-target-newlib.
+
+2000-05-16  Alexandre Oliva  <aoliva@cygnus.com>
+
+	* configure.in, Makefile.in: Merge all libffi-related
+	configury stuff from the libgcj tree.
+
+2000-05-16  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	Thu Apr 27 11:01:48 2000 Andrew Cagney <cagney@b1.cygnus.com>:
+	* Makefile.in (do-tar-bz2, do-md5sum): Skip CVS directories.
+
+2000-05-16  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	Wed Apr 26 17:03:53 2000 Andrew Cagney <cagney@b1.cygnus.com>:
+	* Makefile.in (do-djunpack): New target. Update djunpack.bat with
+	current version information.  Add to proto-toplev directory.
+	(gdb-taz): Build do-djunpack.
+
+2000-05-15  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in: Special case powerpc*-*-aix* target_makefile_frag.
+
+2000-05-13 Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* ltmain.sh: Preserve in relink_command any environment
+	variables that may affect the linker behavior.
+
+2000-05-12  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub (basic_machine): Recognize hppa64 as a valid cpu type.
+
+2000-05-10  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (ia64*-*-elf*): Add gdb and friends to noconfigdirs.
+
+2000-05-08  Eli Zaretskii  <eliz@is.elta.co.il>
+
+	* djunpack.bat: Change the Sed script to replace @V@ in fnchange.lst
+	with the version name.
+
+2000-05-01  Benjamin Kosnik  <bkoz@cygnus.com>
+
+	* config.if: Tweak.
+
+2000-04-23  Eli Zaretskii  <eliz@is.elta.co.il>
+
+	* djunpack.bat: New file.
+
+2000-04-19  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (taz, gdb-taz, gas.tar.bz2, binutils.tar.bz2,
+	gas+binutils.tar.bz2, libg++.tar.bz2, gnats.tar.bz2, gdb.tar.bz2,
+	dejagnu.tar.bz2, gdb+dejagnu.tar.bz2, insight.tar.bz2,
+	insight+dejagnu.tar.bz2, newlib.tar.bz2): Pass MD5PROG to sub-make.
+
+2000-04-16  Dave Pitts  <dpitts@cozx.com>
+
+	* config.sub (case $basic_machine): Change default for "ibm-*"
+	to "openedition".
+
+2000-04-12  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (gdb-taz): New target.  GDB specific archive.
+	(do-md5sum): New target.
+	(MD5PROG): Define.
+	(PACKAGE): Default to TOOL.
+	(VER): Default to a shell script.
+	(taz): Rewrite target.  Move real work to do-proto-toplev.  Include
+	md5 checksum generation.
+	(do-proto-toplev): New target. Create $(PACKAGE)-$(VER) link.
+	(do-tar-bz2): Delete creation of $(PACKAGE)-$(VER) link.
+	(gdb.tar.bz2, dejagnu.tar.bz2, gdb+dejagnu.tar.bz2,
+	insight.tar.bz2): Use gdb-taz to create archive.
+
+2000-04-07  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure (warn_cflags): Delete.
+
+2000-04-05  Benjamin Kosnik  <bkoz@cygnus.com>
+	    Martin v. Loewis  <martin@loewis.home.cs.tu-berlin.de>
+
+	* configure.in (enable_libstdcxx_v3): Add.
+	(target_libs): Add bits here to switch between libstdc++-v2 and
+	libstdc++-v3.
+	* config.if: And this file too.
+	* Makefile.in: Add libstdc++-v3 targets.
+
+2000-04-05  Michael Meissner  <meissner@redhat.com>
+
+	* config.sub (d30v): Add d30v as a basic machine type.
+
+2000-03-29  Jason Merrill  <jason@casey.cygnus.com>
+
+	* configure.in: -linux-gnu*, not -linux-gnu.
+
+2000-03-03  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (taz): Set PACKAGE to TOOL when not defined.
+	(do-tar-bz2): Replace TOOL with PACKAGE.
+	(gdb.tar.bz2): Remove GDBTK from GDB package.
+	(gdb+dejagnu.tar.bz2, insight.tar.bz2, insight+dejagnu.tar.bz2,
+	dejagnu.tar.bz2): New packages.
+
+2000-02-27  Andreas Jaeger  <aj@suse.de>
+
+	* configure.in: Add entry for mips*-*-linux*, move catch all
+	*-*-*linux* entry below this one.
+
+2000-02-27  Ian Lance Taylor  <ian@zembu.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.3.4.
+
+2000-02-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Support an OS of "wince".
+
+2000-02-24  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* config.guess, config.sub: Updated to match config's 2000-02-15
+	version.
+
+2000-02-23  Linas Vepstas <linas@linas.org>
+
+	* config.sub: Add support for Linux/IBM 370.
+	* configure.in: Likewise.
+
+2000-02-22  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add mips-pe, sh-pe and arm-wince-pe targets.
+
+2000-02-20  Christopher Faylor <cgf@cygnus.com>
+
+	* config.guess: Guess "cygwin" rather than "cygwin32".
+
+2000-02-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* configure (gcc_version): When setting, narrow search to
+	lines containing `version_string'.
+
+2000-02-15  Denis Chertykov  <denisc@overta.ru>
+
+	* config.sub: Add support for avr target.
+
+2000-02-01  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* config.sub: Add mmix-knuth-mmixware.
+
+2000-01-27  Christopher Faylor <cgf@redhat.com>
+
+	* Makefile.in (CC_FOR_TARGET): Add new winsup directory
+	structure stuff to -L library search.
+	(CXX_FOR_TARGET): Ditto.
+	(CROSS_CHECK_MODULES): Fix spelling mistake.
+
+2000-01-24  Mark Mitchell  <mark@codesourcery.com>
+
+	* Makefile.in (CXX_FOR_TARGET): Use g++, not xgcc, to invoke
+	the C++ compiler.
+
+2000-01-12  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: Don't build some bits for beos.
+
+2000-01-12  Joel Sherrill (joel@OARcorp.com)
+
+	* Makefile.in (CC_FOR_TARGET): Use newlib libraries as well
+	as include files.
+
+2000-01-06  Geoff Keating  <geoffk@cygnus.com>
+
+	* configure.in: Use mt-aix43 to handle *_TARGET defs,
+	not mh-aix43.
+
+1999-12-14  Richard Henderson  <rth@cygnus.com>
+
+	* config.guess (alpha-osf, alpha-linux): Detect ev67.
+	* config.sub: Accept alphaev[78], alphaev8.
+
+1999-12-03  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* config.guess, config.sub: Update from autoconf.
+
+Tue Nov 23 00:57:41 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* config-ml.in (sparc*-*-*): Disable sparcv9 support if the
+	necessary libraries are missing.
+
+1999-10-25  Andreas Schwab  <schwab@suse.de>
+
+	* configure: Fix quoting inside arguments of eval.
+
+1999-10-21  Nick Clifton  <nickc@cygnus.com>
+
+	* config-ml.in: Allow suppression of some ARM multilibs.
+
+Tue Sep  7 23:33:57 1999  Linas Vepstas  <linas@linas.org>
+
+	* config.guess: Add OS/390 match pattern.
+	* config.sub: Add mvs, openedition targets.
+	* configure.in (i370-ibm-opened*): New.
+
+1999-09-04  Steve Chamberlain  <sac@pobox.com>
+
+	* config.sub: Add support for configuring for pj.
+
+1999-08-31  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub (maybe_os): Add support for configuring for fr30.
+
+1999-08-25  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Do not configure or build ld for AIX
+	platforms.  ld is known to be broken on these platforms.
+
+Wed Aug 25 01:12:25 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* config-ml.in: Pass compiler flag corresponding to multidirs to
+	subdir configures.
+
+1999-08-09  Ian Lance Taylor  <ian@zembu.com>
+
+	* Makefile.in (LDFLAGS): Define.
+
+1999-08-08  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* configure.in (i[3456]-*-mingw32*): Don't put gprof in
+	noconfigdirs.
+	(*-*-cygwin*): Likewise.
+
+1999-08-08  Ian Lance Taylor  <ian@zembu.com>
+
+	* mkdep: New file.
+	* Makefile.in (GAS_SUPPORT_DIRS): Add mkdep.
+	(BINUTILS_SUPPORT_DIRS): Add mkdep.
+
+	From Eli Zaretskii <eliz@is.elta.co.il>:
+	* configure (tmpfile): Change cONf$$ to cNf$$ to avoid an overly
+	long file name when using DJGPP on MS-DOS.
+
+Wed Aug  4 02:07:14 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub (vxworks case): Use os=-vxworks, not os=vxworks.
+
+1999-07-30  Alan Modra  <alan@spri.levels.unisa.edu.au>
+
+	* Makefile.in (check-target-libio): Remove all-target-libstdc++
+	dependency as this causes "make check" to globally "make all"
+
+Tue Jun 22 23:45:18 1999  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in (target_libs): Added target-zlib.
+	* Makefile.in (ALL_TARGET_MODULES): Added zlib.
+	(CONFIGURE_TARGET_MODULES): Likewise.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(configure-target-zlib): New target.
+	(all-target-zlib): Likewise.
+	(all-target-libjava): Depend on all-target-zlib.
+	(configure-target-libjava): Depend on configure-target-zlib.
+
+	* Makefile.in (configure-target-libjava): Depend on
+	configure-target-newlib.
+	(configure-target-boehm-gc): New target.
+	(configure-target-qthreads): New target.
+
+	* configure.in (target_libs): Added target-qthreads.
+	* Makefile.in (ALL_TARGET_MODULES): Added qthreads.
+	(CONFIGURE_TARGET_MODULES): Likewise.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(all-target-qthreads): New target.
+	(configure-target-libjava): Depend on configure-target-qthreads.
+	(all-target-libjava): Depend on all-target-qthreads.
+
+	* Makefile.in (ALL_TARGET_MODULES): Added libjava, boehm-gc.
+	(CONFIGURE_TARGET_MODULES): Likewise.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(all-target-libjava): New target.
+	(all-target-boehm-gc): Likewise.
+	* configure.in (target_libs): Added libjava, boehm-gc.
+
+1999-07-22  Ian Lance Taylor  <ian@zembu.com>
+
+	* Makefile.in (binutils.tar.bz2): Don't pass makeall.bat and
+	configure.bat in SUPPORT_FILES.
+	(gas+binutils.tar.bz2): Likewise.
+
+	* makeall.bat: Remove; obsolete.
+
+1999-07-21  Ian Lance Taylor  <ian@zembu.com>
+
+	From Mark Elbrecht:
+	* configure.bat: Remove; obsolete.
+
+1999-07-11  Ian Lance Taylor  <ian@zembu.com>
+
+	* configure: Add -W -Wall to the default CFLAGS when compiling with
+	gcc.
+
+Thu Jul  8 12:32:23 1999  John David Anglin <dave@hiauly1.hia.nrc.ca>
+
+	* configure.in: Build ld, binutils & gas for hppa*-*-linux-gnu*.
+
+1999-06-30  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in: Build ld on IRIX6.
+
+1999-06-12  Ian Lance Taylor  <ian@zembu.com>
+
+	* Makefile.in: Change distribution targets to use bzip2 instead of
+	gzip.
+	(TEXINFO_SUPPORT): Set to just texinfo/texinfo.tex.
+	(taz): Don't use texinfo/gpl.texinfo or texinfo/lgpl.texinfo.
+
+1999-06-04  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Add mcore target.
+
+1999-05-30  Cort Dougan  <cort@cs.nmt.edu>
+
+	* config.guess (ppc-*-linux-gnu): Also use ld emul elf32ppclinux.
+
+1999-05-25  H.J. Lu  (hjl@gnu.org)
+
+	* config.guess (dummy): Changed to $dummy.
+
+1999-05-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Tidied up case statements.
+
+1999-05-22  Ben Elliston  <bje@cygnus.com>
+
+	* config.guess: Handle NEC UX/4800. Contributed by Jiro Takabatake
+	<jiro@din.or.jp>.
+
+	* config.guess: Merge with FSF version. Future changes will be
+	more accurately recorded in this ChangeLog.
+	* config.sub: Likewise.
+
+1999-05-20   Stephen L Moshier  <moshier@world.std.com>
+
+	 * Makefile.in (GCC_FOR_TARGET): Add -I$(build_tooldir)/include.
+
+1999-04-30  Tom Tromey  <tromey@cygnus.com>
+
+	* ltmain.sh: [mode link] Always use CC given by ltconfig.
+
+1999-04-23  Tom Tromey  <tromey@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2f.
+
+1999-04-20  Drew Moseley  <dmoseley@cygnus.com>
+
+	* configure.in (noconfigdirs): Don't build libstub for arm-elf targets.
+	(noconfigdirs): Don't build any bsp stuff for for arm-oabi targets.
+	Bad merge removed these two changes.
+
+Tue Apr 13 22:50:54 1999  Donn Terry (donn@interix.com)
+			  Martin Heller (Ing.-Buero_Heller@t-online.de)
+
+	* config.guess (interix Alpha): Add.
+
+1999-04-11  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in (i?86-*-beos*): Do config gperf; don't config
+	gdb, newlib, or libgloss.
+
+1999-04-11  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* config-ml.in: On mips*-*-*, if multidirs contains mabi=64, try to
+	link a trivial program with -mabi=64.  If it fails, remove mabi=64
+	from multidirs.
+
+1999-04-10  Philipp Thomas  (kthomas@gwdg.de)
+
+	* config.sub: Set basic_machine to i586 when target_alias = k6-*.
+
+1999-04-08  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Add support for mcore targets.
+
+1999-04-07  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*): Use config/mt-d30v as makefile fragment,
+	not mt-ospace, in order to shut up assembler warning about using
+	symbols that are named the same as registers.
+
+1999-04-07  Drew Moseley  <dmoseley@cygnus.com>
+
+	* Makefile.in (all-target-cygmon): Added all-target-bsp to the
+	dependency list for all-target-cygmon.
+
+1999-04-05  Doug Evans  <devans@casey.cygnus.com>
+
+	* config-ml.in: Check $host, not $target, for selective multilibs.
+	(arm-*-*): Allow disabling of biendian, h/w fp, 26 bit apcs,
+	thumb interworking, and underscore prefix multilibs.
+
+1999-04-04  Ian Lance Taylor  <ian@zembu.com>
+
+	* missing: Update to version from current automake.
+
+Fri Apr  2 15:11:32 1999  H.J. Lu  (hjl@gnu.org)
+
+	* configure (gxx_include_dir): Removed.
+
+	* configure.in (gxx_include_dir): Handle it.
+	* Makefile.in: Likewise.
+
+1999-03-29  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config.sub (mips64vr4111,mips64vr4111el) Add.
+
+1999-03-21  Ben Elliston  <bje@cygnus.com>
+
+	* config.guess: Correct typo for detecting ELF on FreeBSD.
+
+Thu Mar 18 00:17:50 1999  Mark Elbrecht <snowball3@usa.net>
+
+	* configure.in (pc-msdosdjgpp): Set host_makefile_frag to
+	config/mh-djgpp.
+
+Thu Mar 11 18:37:23 1999  Drew Moseley  <dmoseley@cygnus.com>
+
+	* Makefile.in (all-target-bsp): Added all-gcc all-binutils and
+	all-target-newlib to dependency list for all-target-bsp.
+
+Thu Mar 11 01:19:31 1999  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* config.sub: Add i386-uwin support.
+	* config.guess: Likewise.
+
+Thu Mar 11 01:07:55 1999  Franz Sirl <Franz.Sirl-kernel@lauterbach.com>
+
+	* configure.in: cleanup, add mh-*pic handling for arm, special
+	case powerpc*-*-aix*
+
+Wed Mar 10 18:35:07 1999  Jeff Johnston  <jjohnstn@cygnus.com>
+
+	* configure.in (noconfigdirs): Removed target-libgloss so libnosys.a
+	can be built.
+
+Wed Mar 10 17:39:09 1999  Drew Moseley  <dmoseley@cygnus.com>
+
+	* configure.in: Added bsp support to arm-*-coff and arm-*-elf
+	targets.
+
+1999-03-02  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Rename CYGNUS LOCAL to EGCS LOCAL
+
+1999-02-28  Geoffrey Noer  <noer@cygnus.com>
+
+	* config.sub: Check for "cygwin*" rather than "cygwin32*"
+
+1999-02-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Fix typo in arm recognition.
+
+1999-02-24  Drew Moseley  <dmoseley@cygnus.com>
+
+	* configure.in (noconfigdirs): Changed target_configdirs to
+	include target-bsp only for m68k-*-elf* and m68k-*-coff*
+	rather than m68k-*-* since it is not known to work on
+	m68k-aout. Ditto for arm-*-*oabi.
+
+1999-02-24  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* configure.in (*-*-windows*): Remove, no longer used.
+
+1999-02-19  Ben Elliston <bje@cygnus.com>
+
+	* config.guess: Automatically recognise ELF on FreeBSD. From Niall
+	Smart and improved by Andrew Cagney.
+
+1999-02-18  Marc Espie <espie@cvs.openbsd.org>
+
+	* config.guess: Recognize openbsd-*-hppa.
+
+1999-02-17  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile.in (REALLY_SET_LIB_PATH): Append $$$(RPATH_ENVVAR)
+	only if it is not empty.
+
+1999-02-17  Nick Clifton  <nickc@cygnus.com>
+
+	Patch from: Scott Bambrough <scottb@corelcomputer.com>
+
+	* config.guess: Modified to recognize uname's armv* syntax.
+
+	* config.sub: Modified to recognize uname's armv* syntax.
+
+1999-02-17  Mark Salter  <msalter@cygnus.com>
+
+	* configure.in: Added target-bsp for sparclite.
+
+1999-02-08  Richard Henderson  <rth@cygnus.com>
+
+	* config.sub: Recognize alphapca5[67] and up to alphaev8.
+
+1999-02-08  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add support for strongarm port.
+	* config.sub: Add support for strongarm target.
+
+1999-02-07  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* configure.in (*-*-cygwin32*): Use config/mh-cygwin instead of
+	the old name config/mh-cygwin32.
+	Enable texinfo.
+
+1999-02-04  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Do build ld for ix86 Solaris.
+
+1999-02-02  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS):  Set AR to $AR instead of
+	$AR_FOR_TARGET.  Likewise for RANLIB.
+
+1999-02-02  Catherine Moore  <clm@cygnus.com>
+
+	* config.sub (oabi):  Recognize.
+	* configure.in (arm-*-oabi):  Handle.
+
+1999-01-30  Robert Lipe  (robertlipe@usa.net)
+
+	* config.guess: Improve detection of i686 on UnixWare 7.
+
+1999-01-30  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* config.guess: Add support for i386-pc-interix.
+	* config.sub: Likewise.
+	* configure.in: Likewise.
+
+1999-01-18  Christopher Faylor <cgf@cygnus.com>
+
+	* Makefile.in: Remove unneeded all-target-libio from
+	from all-target-winsup target since it is now unneeded.
+	Add all-target-libtermcap in its place since it is now
+	needed.
+
+1998-12-30  Christopher Faylor <cgf@cygnus.com>
+
+	* configure.in: makefile stub for cygwin target is probably
+	unnecessary.  Remove it for now.
+
+1998-12-30  Christopher Faylor <cgf@cygnus.com>
+
+	* configure.in: libtermcap.a should be built when cygwin is the
+	target as well as the host.
+	* config.guess: Allow mixed case in cygwin uname output.
+	* Makefile.in: Add libtermcap target.
+
+1998-12-23  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Clean up handling of hppa2.0.
+
+1998-12-22  Rodney Brown  (rodneybrown@pmsc.com)
+
+	* config.guess: Use C code to identify more HP machines.
+
+Thu Dec 17 01:22:30 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Handle hppa2.0.
+
+Tue Dec 15 17:02:58 1998  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in: Add cygmon for x86-coff and x86-elf. Configure
+	cygmon for all sparclite targets, regardless of object format.
+
+1998-12-15  Mark Salter  <msalter@cygnus.com>
+
+	* configure.in: Added target-bsp for several target architectures.
+
+	* Makefile.in: Added rules for bsp.
+
+Fri Dec  4 01:34:02 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Improve detection of hppa2.0 processors.
+
+Fri Dec  4 01:33:05 1998  Niall Smart <nialls@euristix.ie>
+
+	* config.guess: Recognize FreeBSD using ELF automatically.
+
+1998-11-26  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (skip-this-dir): Add handling for new shell script, which
+	might be created by a sub-directory's configure to indicate, this particular
+	directory is "unwanted".
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): Likewise.
+
+Wed Nov 18 18:28:45 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* ltconfig: import from libtool, after changing libtool to
+	account for the cygwin name change.
+
+Wed Nov 18 18:09:14 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: CC_FOR_TARGET and CXX_FOR_TARGET should also
+	include newlib/libc/sys/cygwin and newlib/libc/sys/cygwin32.
+
+Wed Nov 18 20:13:29 1998  Christopher Faylor <cgf@cygnus.com>
+
+	* configure.in: Add libtermcap to list of cygwin dependencies.
+
+1998-11-17  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: modify CC_FOR_TARGET and CXX_FOR_TARGET so that
+	they include winsup/include when it's a cygwin target.
+
+1998-11-12  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in (host_tools): Added zip.
+	* Makefile.in (all-target-libjava): Depend on all-zip.
+	(all-zip): New target.
+	(ALL_MODULES): Added all-zip.
+	(NATIVE_CHECK_MODULES): Added check-zip.
+	(INSTALL_MODULES): Added install-zip.
+	(CLEAN_MODULES): Added clean-zip.
+
+1998-11-12  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: lose "32" from comment about cygwin.
+
+1998-11-05  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Use -Os to build target libraries for the fr30.
+
+1998-11-04  Dave Brolley  <brolley@cygnus.com>
+
+	* config.sub: Add fr30.
+
+1998-11-02  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: drop "32" from config/mh-cygwin32.  Check
+	cygwin* instead of cygwin32*.
+	* config.sub: Check cygwin* instead of cygwin32*.
+
+1998-10-22  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: Match any version of Unixware7.
+
+1998-10-20  Syd Polk  <spolk@cygnus.com>
+
+	* Makefile.in configure.in: Add the ability to use tcl8.1 and tk8.1
+	if desired.
+
+1998-10-18  Jeffrey A Law  (law@cygnus.com)
+
+	* config.if (cxx_interface, libstdcxx_interface): Do not try to set
+	these if the appropriate directories and files to not exist.
+
+1998-10-14  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (DEVO_SUPPORT): Add config.if.
+
+1998-10-13  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure: Add pattern to replace "build_tooldir"'s
+	definition in the generated Makefile with "tooldir"'s
+	actual value.
+
+Tue Oct 13 09:17:06 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Bring back lost sparcv9.
+
+	* Makefile.in (all-snvavigator): Remove all-flexlm dependency.
+
+Mon Oct 12 12:09:44 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (CHILL_FOR_TARGET): Mirror recent changes to
+	CC_FOR_TARGET and friends.
+
+Mon Oct 12 12:09:30 1998  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* Makefile.in (build_tooldir): New variable, same as tooldir.
+	(CC_FOR_TARGET, GCC_FOR_TARGET, CXX_FOR_TARGET): Add
+	-B$(build_tooldir)/bin/.
+	(BASE_FLAGS_TO_PASS): Pass build_tooldir down.
+
+Wed Sep 30 22:20:50 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.sub: Add support for i[34567]86-pc-udk.
+	* configure.in: Likewise.
+
+Wed Sep 30 19:23:48 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: add bzip2 package building bits for user
+	tools module
+	* configure.in: ditto
+
+Wed Sep 30 03:00:05 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS): Add libobjc.
+	(ALL_TARGET_MODULES): Add all-target-libobjc.
+	(CONFIGURE_TARGET_MODULES, CHECK_TARGET_MODULES): Similarly.
+	(INSTALL_TARGET_MODULES, CLEAN_TARGET_MODULES): Similarly.
+	(all-target-libchill): Add dependencies.
+	* configure.in (target_libs): Add libchill.
+
+1998-09-30  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure.in (target_subdir): Remove duplicate line.
+
+Tue Sep 29 22:45:41 1998  Felix Lee  <flee@cygnus.com>
+
+	* Makefile.in (all-automake): fix dependencies.
+
+Mon Sep 28 04:04:27 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Minor cleanups for building in the $(target_alias)
+	subdir.
+
+1998-09-22  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (bootstrap): Set r and s before make all.  Use
+	BASE_FLAGS_TO_PASS in make all.
+	(cross): Likewise.
+
+1998-09-20  Mark Mitchell  <mark@markmitchell.com>
+
+	* Makefile.in (bootstrap): Pass TARGET_FLAGS_TO_PASS to `make all'.
+
+Sun Sep 20 00:13:02 1998  Richard Henderson  <rth@cygnus.com>
+
+	* config.sub: Fix typo in last change.
+
+1998-09-19  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>
+
+	* config.sub: Add support for C4x target.
+	* configure.in: Likewise.
+
+1998-09-13  David S. Miller  <davem@pierdol.cobaltmicro.com>
+
+	* config.sub: Recognize sparcv9 just like sparc64.
+
+Wed Sep  9 15:44:52 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: Match "Pent II" or "PentII" for OpenServer.
+
+Tue Sep  8 01:18:39 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Correctly identify Pentium II sco boxes.
+
+	* config.guess: Fix "tr" code.  From Weiwen Liu.
+
+Sat Sep  5 13:56:52 1998  John Hughes  <john@Calva.COM>
+
+	* configure.in: Do not assume x86-svr4 or x86-unixware can handle
+	stabs.
+
+Sat Sep  5 02:12:02 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS): Add libchill.
+	(ALL_TARGET_MODULES): Add all-target-libchill.
+	(CONFIGURE_TARGET_MODULES, CHECK_TARGET_MODULES): Similarly.
+	(INSTALL_TARGET_MODULES, CLEAN_TARGET_MODULES): Similarly.
+	(all-target-libchill): Add dependencies.
+	* configure.in (target_libs): Add libchill.
+
+Sun Aug 30 22:27:02 1998  Lutz Wohlrab <lutz.wohlrab@informatik.tu-chemnitz.de>
+
+	* config.guess: Avoid assumptions about "tr" behaves when
+	LANG is set to something other than English.
+
+Sun Aug 30 22:14:44 1998  H.J. Lu  (hjl@gnu.org)
+
+	* configure (gxx_include_dir): Changed to
+	'${prefix}/include/g++'-${libstdcxx_interface}.
+
+	* config.if: New to determine the interfaces.
+
+Sun Aug 30 21:15:19 1998  Mark Klein (mklein@dis.com)
+
+	* config.guess: Detect and handle MPE/IX.
+	* config.sub: Deal with MPE/IX.
+
+Sat Aug 29 14:32:55 1998  David Edelsohn  <edelsohn@mhpcc.edu>
+
+	* configure.in: Use mh-aix43.
+
+1998-07-29  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure: Fix --without/--disable cases for gxx-include-dir.
+
+Fri Aug 28 12:28:26 1998  Per Bothner  <bothner@cygnus.com>
+
+	* mdata-sh:  Imported.  Needed for automake support.
+
+Thu Aug 13 12:49:29 1998  H.J. Lu  <hjl@gnu.org>
+
+	* Makefile.in (taz): Try "chmod -R og=u ." before
+	"chmod og=u `find . -print`".
+
+Fri Jul 31 09:38:33 1998  Catherine Moore  <clm@cygnus.com>
+
+	* configure.in: Add arm-elf and thumb-elf support.
+
+Mon Jul 27 16:23:58 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* Makefile.in: Undo previous patch.
+
+Fri Jul 24 19:55:24 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* Makefile.in (INSTALL_TARGET): Move EXTRA_TARGET_HOST_INSTALL_MODULES
+	to here ...
+	(install-no-fixedincludes): and here
+	(INSTALL_MODULES): ... from here.
+
+Fri Jul 24 17:01:42 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with FSF.
+
+	* config.guess: Merge with FSF.
+
+Fri Jul 24 08:43:36 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* configure (extraconfigdirs): New variable.
+	(SUBDIRS): Add extraconfigdirs and recurse on them too.
+	* Makefile.in (all): Move higher in file.
+	(EXTRA_TARGET_HOST_ALL_MODULES): New variable.
+	(EXTRA_TARGET_HOST_{INSTALL,CHECK}_MODULES): New variables.
+	(ALL_MODULES): Add EXTRA_TARGET_HOST_ALL_MODULES.
+	(CROSS_CHECK_MODULES): Add EXTRA_TARGET_HOST_CHECK_MODULES.
+	(INSTALL_MODULES): Add EXTRA_TARGET_HOST_INSTALL_MODULES.
+
+1998-07-23  Brendan Kehoe  <brendan@cygnus.com>
+
+	* Makefile.in (all-target-libjava): Depend on all-gcc and
+	all-target-newlib.
+	(configure-target-libjava): Depend on $(ALL_GCC).
+
+Sat Jul 18 14:32:43 CDT 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: (*-pc-sco3.2v5) Add detection for Pentium II.
+	(*-pc-unixware7) Add detection for Pentium II, Pentium Pro.
+
+Fri Jul 17 13:30:18 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ylwrap: Change absolute path checks to check for DOS style path
+	names.
+
+	* ylwrap: Don't use a full path name if the source file is in the
+	same directory.  From hjl@lucon.org (H.J. Lu).
+
+	* config-ml.in: Default to being verbose, to match Feb 18 change to
+	configure.
+
+Thu Jul 16 12:29:51 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	Brought over from egcs:
+
+	Sat Jun 27 22:46:32 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (target_subdir): Set to ${target_alias} instead
+	of "libraries".
+
+	Mon Sep  1 16:45:44 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (target_subdir): Set to libraries if enable_multilib.
+
+Wed Jul 15 01:00:54 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): If there are any
+	multilibs, force reconfiguration the first time we create
+	multilib.out in a subdirectory, in case TARGET_SUBDIR is `.'.
+
+Tue Jul 14 23:41:03 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Strip any --no option from CONFIG_ARGUMENTS, to
+	avoid confusion with --no-recursion.
+
+Tue Jul 14 15:37:41 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: Win32 hosts shouldn't use install -x
+	* install-sh: remove -x option, and special .exe-handling
+	hack.
+
+Tue Jul 14 15:28:41 1998  Richard Henderson  <rth@cygnus.com>
+
+	* config.guess: Recognize i586-pc-beos.
+	* configure.in: Don't build some bits for beos.
+
+Tue Jul 14 13:22:18 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If CC is set but CFLAGS is not, and CC is gcc, make
+	CFLAGS default to -O2.
+
+	* ltmain.sh: Add some hacks to make SunOS --enable-shared work
+	when using GNU ld.
+
+Fri Jul 10 13:18:23 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltmain.sh: Correct install when using a different shell.
+
+Tue Jul  7 15:24:38 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2b.
+
+Thu Jul  2 13:57:36 1998  Klaus Kaempf  <kkaempf@rmi.de>
+
+	* makefile.vms: Update to build binutils/makefile.vms.  Add install
+	target.
+
+Wed Jul  1 16:45:21 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig: Update to correct AIX handling.
+
+Sat Jun 27 22:46:32 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Add TARGET_SUBDIR.
+
+	* configure.in (target_subdir): Set to ${target_alias} instead
+	of "libraries".
+
+1998-06-26  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Add gcc_version_trigger.
+	(Makefile): Depend on $(gcc_version_trigger).
+
+	* configure (gcc_version): Change default initializer to empty
+	string.
+	(gcc_version_trigger): New variable; pass this variable down
+	to subdir configures to enable them checking gcc's version
+	themselves. Emit make macros for both gcc_version vars.
+	(topsrcdir): Initialize reliably.
+	(recursion line): Remove --with-gcc-version=${gcc_version}.
+
+1998-06-24  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (enable_version_specific_runtime_libs): Implement new flag
+	--enable-version-specific-runtime-libs which installs C++ runtime stuff
+	in $(libsubdir); emit definition in each generated Makefile.
+	(gxx_include_dir): Initialize depending on
+	$enable_version_specific_runtime_libs.
+
+1998-06-24  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (gcc_version): Initialize properly depending on
+	how and where configure is started.
+	(recursion line): Pass a --with-gcc-version=${gcc_version}
+	to configures in subdirs.
+
+Wed Jun 24 16:01:59 1998  John Metzler  <jmetzler@cygnus.com>
+
+	* configure.in (noconfigdirs): Add configure pattern for mips tx39
+	cygmon
+
+Tue Jun 23 22:42:32 1998  Mark Alexander  <marka@cygnus.com>
+
+	* configure.in: Add cygmon and libstub support for mn10200.
+
+1998-06-19  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (gcc_version): Add new variable describing the
+	particular gcc version we're building.
+	* Makefile.in (libsubdir): Add new macro for the directory
+	in which the compiler finds executables, libraries, etc.
+	(BASE_FLAGS_TO_PASS): Pass down gcc_version, target_alias
+	and libsubdir.
+
+Fri Jun 19 02:36:59 1998  Alexandre Oliva <oliva@dcc.unicamp.br>
+
+	* Makefile.in (local-clean): Remove *.log.
+	(warning.log): Built with warn_summary from build.log.
+	(mail-report.log): Run test_summary.
+	(mail-report-with-warnings.log): Run test_summary including
+	warning.log in the report.
+
+Thu Jun 18 11:26:03 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: Detection of Pentium II for *-sco-3.2v5*.
+
+Mon Jun 15 14:53:54 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (grep): Grep no longer depends on libiberty.
+
+Fri Jun 12 14:03:34 1998  Syd Polk  <spolk@cygnus.com>
+
+	* Makefile.in: all-snavigator needs all-libgui.
+
+Thu Jun 11 19:43:47 1998  Mark Alexander  <marka@cygnus.com>
+
+	* configure.in: Add cygmon and libstub support for mn10300.
+
+Wed Jun 10 11:19:47 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* missing: Update to version from automake 1.3.
+
+	* ltmain.sh: On installation, don't get confused if the same name
+	appears more than once in the list of library names.
+
+Wed Jun  3 14:51:42 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Accept m68060 and m5200 as CPU names.
+
+Mon Jun  1 17:25:16 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Use && rather than using -a in test, because odd
+	strings can confuse test.
+	* configure.in: Likewise.
+
+Thu May 28 19:31:13 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Bring in Visual C++ support.
+
+Sat May 23 23:44:13 1998  Alexandre Oliva <oliva@dcc.unicamp.br>
+
+	* Makefile.in (boostrap2-lean, bootstrap3-lean,
+	bootstrap4-lean): New targets.
+
+Mon May 11 23:55:56 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* mpw-* Delete.  Not used.
+
+Mon May 11 23:11:34 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* COPYING.LIB: Update FSF address.
+
+Fri May  8 01:30:20 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2a.
+
+	* Makefile.in (GASB_SUPPORT_DIRS): Remove intl; already included via
+	GAS_SUPPORT_DIRS.
+
+Thu May  7 17:27:35 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Avoid producing a version number if
+	-version-info was not used.
+
+Tue May  5 18:02:24 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Add --with-newlib to CONFIG_ARGUMENTS if we are
+	building with newlib.
+
+1998-04-30  Paul Eggert  <eggert@twinsun.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Remove backslash at end;
+	Solaris `make' causes it to continue to next definition.
+
+Tue Apr 28 16:24:24 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* Makefile.in (install-gdbtk): Call this 'install-gdb' so that
+	the right GUI libraries and files are installed along with GDB.
+
+Tue Apr 28 18:11:24 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Change alpha to alpha* in several places.
+
+Tue Apr 28 07:42:00 1998  Mark Alexander  <marka@cygnus.com>
+
+	* config.sub: Recognize sparc86x.
+
+Tue Apr 28 07:35:02 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (--enable-target-optspace): Remove debug echo.
+
+Thu Apr 23 21:31:16 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* configure: Set CXXFLAGS from CXXFLAGS, not CFLAGS.
+
+Thu Apr 23 12:26:38 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig: Update cygwin32 support.
+
+	* Makefile.in (GAS_SUPPORT_DIRS): Add intl.
+	(BINUTILS_SUPPORT_DIRS, GASB_SUPPORT_DIRS): Likewise.
+	(GDB_SUPPORT_DIRS): Likewise.
+
+Wed Apr 22 12:30:10 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (target_makefile_frag): If --enable-target-optspace,
+	use -Os to compile target libraries rather than -O2.  Default to
+	using -Os for d10v and m32r if --{enable,disable}-target-optspace is
+	not used.
+	* configure.in (target_cflags): Ditto for d30v.
+
+Tue Apr 21 23:06:54 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (all-bfd): Depend on all-intl.
+	(all-binutils): Likewise.
+	(all-gas): Likewise.
+	(all-gprof): Likewise.
+	(all-ld): Likewise.
+
+1998-04-19  Brendan Kehoe  <brendan@cygnus.com>
+
+	* configure.in (host_tools): Fix typo, lbtool -> libtool.
+
+Fri Apr 17 16:20:42 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (all-bfd): Depend upon all-libiberty.
+
+	* ltconfig, ltmain.sh: Bring in newer cygwin32 support.
+
+Fri Apr 17 12:22:22 1998  Bob Manson  <manson@charmed.cygnus.com>
+
+	* Makefile.in: Add libstub.
+
+	* configure.in: Ditto. Build libstub for targets that have cygmon
+	support.
+
+Tue Apr 14 18:01:55 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't set PICFLAG on ix86-cygwin32.
+
+Tue Apr 14 12:24:45 1998  J. Kean Johnston  <jkj@sco.com>
+
+	* configure.in: Recognise i[3456]96-*-sysv5* as a valid host, and
+	use mh-sysv5 if specified.  Support gprof on SCO Open Server.
+
+Tue Apr 14 11:33:51 1998  Krister Walfridsson <cato@df.lth.se>
+
+	* configure: Define DEFAULT_M4 by searching PATH.
+	* Makfile.in: Use DEFAULT_M4.
+
+Mon Apr 13 15:37:24 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig: Add cygwin32 support.
+
+	* Makefile.in, configure.in: Add libtool as a native only directory
+	to configure and build.
+
+Sun Apr 12 20:58:46 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_MODULES): Remove texinfo.
+
+Wed Apr  8 13:18:56 1998  Philippe De Muyter  <phdm@macqel.be>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): XFOO lines shortened.
+
+Thu Apr  2 14:48:44 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: add ash make rules
+	* configure.in: add ash to native_only and host_tools lists
+
+Thu Mar 26 12:53:20 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (all-gettext, all-intl): New targets.
+	(ALL_MODULES): Added all-gettext, all-intl.
+	(CROSS_CHECK_MODULES): Added check-gettext, check-intl.
+	(INSTALL_MODULES): Added install-gettext, install-intl.
+	(CLEAN_MODULES): Added clean-gettext, clean-intl.
+
+	* configure.in (host_tools): Added gettext.
+	(native_only): Likewise.
+	(noconfigdirs) [various cases]: Likewise.
+	(host_libs): Added intl.
+
+Thu Mar 26 15:00:11 1998  Keith Seitz  <keiths@onions.cygnus.com>
+
+	* configure: Do not disable building gdbtk for cygwin32 hosts.
+
+Wed Mar 25 10:04:18 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add thumb-coff target.
+	* config.sub: Add thumb-coff target.
+
+Wed Mar 25 11:49:12 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* Makefile.in: Revert yesterday's change.
+	(all-target-winsup):  all-target-librx stays out of here.
+
+Tue Mar 24 16:58:29 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS, ALL_TARGET_MODULES,
+	CONFIGURE_TARGET_MODULES, CHECK_TARGET_MODULES,
+	INSTALL_TARGET_MODULES, CLEAN_TARGET_MODULES, all-target-winsup):
+	Remove references to librx and libg++.
+
+Tue Mar 24 18:28:12 1998  Eric Mumpower  <nocturne@cygnus.com>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Pass $(lispdir) down to
+	recursive makes
+
+Tue Mar 24 11:37:45 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET): Use $(TARGET_SUBDIR) when passing -B
+	for newlib directory.
+	(CXX_FOR_TARGET): Likewise.
+
+Mon Mar 23 11:30:21 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* ltconfig: Update after libtool/ltconfig.in change for
+	hpux11.
+
+Fri Mar 20 18:51:43 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2.
+
+Fri Mar 20 09:32:14 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (install-gcc): Don't specify LANGUAGES here.
+	(install-gcc-cross): Instead, override LANGUAGES here.
+
+1998-03-18  Dave Love  <d.love@dl.ac.uk>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): Set CONFIG_SITE to a
+	non-existent file since /dev/null loses with bash 2.0/autoconf 2.12.
+
+Wed Mar 18 09:24:59 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add Thumb-pe target.
+
+Tue Mar 17 16:59:00 1998  Syd Polk <spolk@cygnus.com>
+
+	* Makefile.in - changed sn targets to snavigator
+	* configure.in - changed sn targets to snavigator
+
+Tue Mar 17 10:33:28 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* config-ml.in: After building symlink tree call make distclean
+	if a Makefile got linked into ${ml_dir}/${ml_libdir}; this happens
+	to be the case for libiberty.
+
+Tue Mar 17 10:22:37 1998  H.J. Lu  (hjl@gnu.ai.mit.edu)
+
+	* configure: When making link, also check the current
+	directory. The configure scripts may create one.
+
+Fri Mar  6 01:02:03 1998  Richard Henderson  <rth@cygnus.com>
+
+	* config.sub: Accept alphapca56 and alphaev6 properly.
+
+Fri Mar  6 00:14:55 1998  Franz Sirl <Franz.Sirl-kernel@lauterbach.com>
+
+	* configure.in: Revert 3 Jan change for powerpc-linux-gnulibc1.
+
+Mon Feb 23 15:09:18 1998  Bruno Haible <bruno@linuix.mathematik.uni-karlsruhe.de
+
+	* config.sub (sco5): Fix typo.
+
+Mon Feb 23 14:46:06 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_MODULES): Move install-tcl before
+	install-itcl.
+	(install-itcl): Remove dependency on install-tcl.
+
+Mon Feb 23 09:53:28 1998  Mark Alexander  <marka@cygnus.com>
+
+	* configure.in: Remove libgloss from noconfigdirs for MN10300.
+
+Thu Feb 19 13:40:41 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't build libgui for a cygwin32 target when not on
+	a cygwin32 host.
+
+Wed Feb 18 12:29:00 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* configure (redirect): Set to null, so default behavior of
+	configure is now --verbose.
+
+1998-02-16  Dave Love  <d.love@dl.ac.uk>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): Run configure with
+	CONFIG_SITE=/dev/null to forestall lossage with site configuration.
+
+Mon Feb 16 12:23:53 1998  Manfred Hollstein  <Manfred.Hollstein@ks.sel.alcatel.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS, EXTRA_TARGET_FLAGS): Really add
+	this change to sync Makefile.in with its ChangeLog entries.
+
+Thu Feb 12 15:03:08 1998  H.J. Lu  <hjl@gnu.org>
+
+	* ltmain.sh (mkdir): Check that the directory doesn't exist
+	before we exit with error, so that we don't get races during
+	parallel builds.
+
+Sat Feb  7 15:19:18 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update from libtool 1.0i.
+
+Fri Feb  6 01:33:52 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Don't pass PICFLAG and
+	PICFLAG_FOR_TARGET.
+	(EXTRA_TARGET_FLAGS): Don't pass PICFLAG_FOR_TARGET.
+
+	* configure: Emit a definition for the new macro enable_shared
+	into each Makefile.
+
+Thu Feb  5 17:01:12 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* configure.in (host_tools, native_only): Add libtool.
+
+Wed Feb  4 16:53:58 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: add target-gperf to noconfigdirs for Cygwin32.
+	Fix typo in ming config comment.
+
+Wed Feb  4 18:56:13 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update from libtool 1.0h.
+
+Mon Feb  2 19:38:19 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Add tic30 cases, and map c30 to tic30.
+
+Sun Feb  1 02:40:41 1998  Richard Henderson  <rth@cygnus.com>
+
+	* Makefile.in (TARGET_CONFIGDIRS): Add libf2c.
+	(ALL_TARGET_MODULES, CONFIGURE_TARGET_MODULES): Similarly
+	(CHECK_TARGET_MODULES, INSTALL_TARGET_MODULES): Similarly
+	(CLEAN_TARGET_MODULES): Similarly
+	(all-target-libf2c): Add dependences.
+	* configure.in (target_libs): Add libf2c.
+
+Fri Jan 30 17:18:32 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: Remove expect from noconfigdirs when target
+	is cygwin32.  OK to build expect and dejagnu with Canadian
+	Cross.
+
+Wed Jan 28 12:58:49 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Do build expect, dejagnu, and cvssrc for a cygwin32
+	host.
+
+	* config.guess: Use ${UNAME_MACHINE} rather than i386 for cygwin32
+	and mingw32.
+
+Wed Jan 28 10:26:37 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Remove passing $(local_prefix)
+	here as it is not defined in the toplevel Makefile.
+
+Tue Jan 27 23:25:06 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (package_makefile_rules_frag): New variable, which names
+	a file with generic rules, ...
+	Change comment to mention we now have FIVE parts.
+	* configure: Undo last change.
+
+Tue Jan 27 23:15:55 1998  Lassi A. Tuura  <lat@iki.fi>
+
+	* config.guess: More accurate determination of HP processor types.
+	* config.sub: More accurate determination of HP processor types.
+
+Sat Jan 24 01:59:45 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (package_makefile_frag): Move inserting the
+	${package_makefile_frag} to where it should be according
+	to the comment.
+
+Fri Jan 23 00:29:28 1998  Philip Blundell  <pb@nexus.co.uk>
+
+	* config.guess: Add support for Linux/ARM.
+
+Thu Jan 22 15:14:01 1998  Fred Fish  <fnf@cygnus.com>
+
+	* .cvsignore: Remove *-info and *-install since they match
+	release-info and mpw-install, which we don't want to just ignore.
+
+Thu Jan 22 01:38:33 1998  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: Revert 3 Jan change for alpha-linux-gnulibc1.
+
+Sat Jan 17 21:28:08 1998  Pieter Nagel <pnagel@epiuse.co.za>
+
+	* Makefile.in (FLAGS_TO_PASS): Pass down gcc_include_dir and
+	local_prefix to sub-make invocations.
+
+Sat Jan 17 21:04:59 1998 H.J. Lu  (hjl@gnu.org)
+
+	* configure.in: Check makefile fragments in the source
+	directory.
+
+Fri Jan 16 00:41:37 1998  Alexandre Oliva <oliva@dcc.unicamp.br>
+
+	* configure.in: Check whether host and target makefile
+	fragments exist before adding them to *_makefile_frag.
+
+Wed Jan 14 23:39:10 1998  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in (target_configdirs): Add cygmon for sparc64-elf.
+
+Wed Jan 14 12:48:07 1998  Keith Seitz  <keiths@pizza.cygnus.com>
+
+	* configure.in: Make sure we only replace RPATH_ENVVAR on
+	lines which begin with RPATH_ENVVAR, i.e. add "^" to the
+	regexp to sed.
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Pass RRPATH_ENVVAR down
+	to sub-makes.
+
+1998-01-13  Lee Iverson   (leei@ai.sri.com)
+
+	* config-ml.in (multi-do): LDFLAGS must include multilib
+	designator.
+
+Tue Jan 13 01:13:24 1998   Robert Lipe (robertl@dgii.com)
+
+	* config.guess: Recognize i[3456]-i586-UnixWare7-sysv5.
+
+Sun Jan  4 01:06:55 1998  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* config.sub: Add mingw32 support.
+	* configure.in: Likewise.
+
+Sat Jan  3 12:11:05 1998 Franz Sirl <franz.sirl-kernel@lauterbach.com>
+
+	* configure.in: Finalize support for {alpha|powerpc}*-*-linux-gnulibc1
+
+Sun Dec 28 11:28:58 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_TARGET): Do install-gcc first.
+	* configure (gxx_include_dir): Provide a definition for subdirs
+	which do not use autoconf.
+
+Wed Dec 24 22:46:55 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Sync with egcs.  Picks up new alpha support,
+	BeOS & some additional linux support.
+
+Tue Dec 23 12:44:24 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: HP 9000/803 is a PA1.1 machine.
+
+Mon Dec 22 02:39:24 1997  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: It's alpha*-...
+
+Sun Dec 21 16:53:12 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)
+
+	* configure.in (host_makefile_frag, target_makefile_frag):
+	Handle multiple config files.
+	(alpha-*-linux*): Treat alpha-*-linux* as alpha-*-linux* and
+	alpha-*-*.
+
+Thu Dec 18 13:13:03 1997  Doug Evans  <devans@canuck.cygnus.com>
+
+	* mkdep: New file.
+
+Wed Dec 17 09:53:02 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Allow configuring of libide, vmake, etc.
+
+Tue Dec 16 17:36:05 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Add libgui directory.
+	(GDB_TK): Add all-libgui.
+	* configure.in: Add libgui directory.
+	* configure: Add all-libgui to GDB_TK.
+
+Mon Dec 15 16:12:28 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config-ml.in (multidirs): Add m32r to multilib list.
+
+Fri Dec 12 10:43:31 1997  Brendan Kehoe  <brendan@canuck.cygnus.com>
+
+	* Makefile.in (all-target-gperf): Change dependency to
+	all-target-libstdc++.
+
+Thu Dec 11 23:30:51 1997  Fred Fish  <fnf@ninemoons.com>
+
+	* config.guess: Add BeOS support.
+
+Wed Dec 10 15:10:38 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	Source directory cvs renamed to cvssrc:
+	* configure.in (host_tools): Change cvs to cvssrc.
+	(native_only): Likewise.
+	(noconfigdirs) [various cases]: Likewise.
+	* Makefile.in (ALL_MODULES): Change all-cvs to all-cvssrc.
+	(CROSS_CHECK_MODULES): Change check-cvs to check-cvssrc.
+	(INSTALL_MODULES): Change install-cvs to install-cvssrc.
+	(CLEAN_MODULES): Change clean-cvs to clean-cvssrc.
+	(all-cvssrc): Rename target from all-cvs.
+
+Wed Dec  3 07:55:59 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* configure (gxx_include_dir): Fix thinko.
+
+Tue Dec  2 10:55:34 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_TARGET_CROSS): Define.
+	(install-cross, install-gcc-cross): New targets.
+
+Tue Dec  2 10:08:31 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (noconfigdirs): Add support for Thumb target.
+
+	* config.sub (maybe_os): Add support for Thumb target.
+
+Sun Nov 30 16:12:27 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* Makefile.in: Add rules for cygmon.
+
+	* configure.in: Build cygmon for sparc-elf and sparclite-aout.
+
+Thu Nov 27 01:31:30 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_TARGET): Do install-gcc first.
+	* configure (gxx_include_dir): Provide a definition for subdirs
+	which do not use autoconf.
+
+Wed Nov 26 11:53:33 1997  Keith Seitz  <keiths@onions.cygnus.com>
+
+	* Makefile.in, configure, configure.in, ChangeLog: merge with foundry's
+	11/18/97 build
+
+Wed Nov 26 16:08:50 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* From Franz Sirl.
+	* config.guess (powerpc*-*-linux): Handle glibc2 beta release
+	found on RedHat Linux systems.
+
+Fri Nov 21 09:51:01 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess (alpha stuff): Merge with FSF to avoid incorrect
+	guesses.
+
+Thu Nov 13 11:38:37 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (i[3456]86-ncr-sysv4.3*): Tweak.
+
+Mon Nov 10 15:23:21 1997  H.J. Lu  <hjl@gnu.ai.mit.edu>
+
+	* ltmain.sh: If mkdir fails, check whether the directory was created
+	anyhow by some other process.
+
+Mon Nov 10 14:38:03 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure all directories.
+
+Sun Nov  9 17:36:20 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure newlib, libiberty directories
+	for the D30V.
+
+Sat Nov  8 14:42:59 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure target-libgloss on the D30V.
+
+Fri Nov  7 10:34:09 1997  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* include/libiberty.h: Add extern "C" { so it can be used with C++
+	progrms.
+	* include/remote-sim.h:  Add extern "C" { so it can be used with C++
+	programs.
+
+Thu Oct 30 11:09:29 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure GCC now.
+
+Mon Oct 27 13:17:24 1997  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* configure.in: Remove a "second pass" of tweaking noconfigdirs,
+	is no longer needed.
+
+Mon Oct 27 12:03:53 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in: check-target-libio depends on all-target-libstdc++.
+
+Sun Oct 26 11:48:27 1997  Manfred Hollstein  (manfred@s-direktnet.de)
+
+	* Makefile.in (bootstrap-lean): Combined with `normal' bootstrap
+	targets using "$@" to provide support for similar but not identical
+	targets without having to duplicate code.
+
+Mon Oct 20 15:28:49 1997  Klaus K"ampf  <kkaempf@progis.de>
+
+	* makefile.vms: Fix to work with DEC C.
+
+Tue Oct  7 23:58:57 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Add mips-tx39-elf to marketing names.
+
+Tue Oct  7 14:24:41 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltmain.sh: Handle symlinks in generated script.
+
+Wed Oct  1 13:11:27 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Handle autoconf style directory options: --bindir,
+	--datadir, --includedir, --infodir, --libdir, --libexecdir,
+	--mandir, --oldincludedir, --sbindir, --sharedstatedir,
+	--sysconfdir.
+	* Makefile.in (sbindir, libexecdir, sysconfdir): New variables.
+	(sharedstatedir, localstatedir, oldincludedir): New variables.
+	(BASE_FLAGS_TO_PASS): Pass down bindir, datadir, includedir,
+	infodir, libdir, libexecdir, localstatedir, mandir, oldincludedir,
+	sbindir, sharedstatedir, and sysconfdir.
+
+Mon Sep 29 00:38:08 1997 Aaron Jackson <jackson@negril.msrce.howard.edu>
+
+	* Makefile.in (bootstrap-lean): New target.
+
+Wed Sep 24 18:06:27 1997  Stu Grossman  <grossman@babylon-5.cygnus.com>
+
+	* configure.in (d30v):  Remove tcl, tk, expect, gdb, itcl, tix, db,
+	sn, and gnuserv from noconfigdirs.
+
+Wed Sep 24 15:18:32 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltmain.sh: Tweak shell pattern to avoid bug in NetBSD /bin/sh.
+
+Thu Sep 18 23:58:27 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (cross): New target.
+
+Thu Sep 18 21:43:23 1997  Alexandre Oliva  <oliva@dcc.unicamp.br>
+			  Jeff Law	   <law@cygnus.com>
+
+	* Makefile.in (bootstrap2, bootstrap3): New targets.
+	(all-bootstrap): Remove outdated and confusing target.
+	(bootstrap, bootstrap2, bootstrap3): Don't pass BOOT_CFLAGS down.
+
+Thu Sep 18 15:37:42 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure (tooldir): enable_gdbtk=YES for cygwin32, NO for
+	windows.  Consistent with gdb/configure.
+
+1997-09-15 02:37  Ulrich Drepper  <drepper@cygnus.com>
+
+	* configure.in: Name Linux target fragment.
+
+	* configure: Rewrite so that project Makefile fragment is inserted
+	first and appears last in the resulting Makefile.
+
+Tue Sep 16 09:55:07 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (install-itcl): Install tcl first.
+
+Fri Sep 12 16:19:20 1997  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: remove bison from noconfigdirs for Cygwin32 host
+
+Thu Sep 11 16:40:46 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)
+
+	* Makefile.in (local-distclean): Also remove mh-frag mt-frag.
+
+	* configure.in (skipdirs): Add target-librx for Linux.
+	(alpha-*-linux*): Use config/mh-elfalphapic and config/mt-elfalphapic.
+
+Wed Sep 10 21:29:54 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (bootstrap): New target.
+
+Wed Sep 10 15:19:22 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Accept 'amigados' for backward compatability.
+
+Mon Sep  8 20:46:20 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.guess: Merge with FSF.
+
+Sun Sep  7 23:18:32 1997  Fred Fish  <fnf@ninemoons.com>
+
+	* config.sub: Change 'amigados' to 'amigaos' to match current usage.
+
+Sun Sep  7 15:55:28 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Add "marketing-names" patch.
+
+Fri Sep  5 16:11:28 1997  Joel Sherrill  (joel@OARcorp.com)
+
+	* configure.in (*-*-rtems*): Do not build libgloss for rtems.
+
+Fri Sep  5 12:27:17 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Handle v850-elf.
+
+Wed Sep  3 22:01:58 1997  Fred Fish  <fnf@ninemoons.com>
+
+	* .cvsignore (*-install): Remove.
+
+Wed Sep  3 12:15:24 1997  Chris Provenzano  <proven@cygnus.com>
+
+	* ltconfig: Set CONFIG_SHELL in libtool.
+	* ltmain.sh: Use CONFIG_SHELL instead of /bin/sh
+
+Mon Sep  1 16:45:44 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (target_subdir): Set to libraries if enable_multilib.
+
+Wed Aug 27 16:15:11 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* config.guess: Update from gcc directory.
+
+Tue Aug 26 16:46:46 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (all-sim): Depends on all-readline.
+
+Wed Aug 20 19:57:37 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (BISON, YACC): Use $$s.
+	(all-bison): Depend on all-texinfo.
+
+Tue Aug 19 01:41:32 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (BISON): Add -L flag.
+	(YACC): Likewise.
+
+Mon Aug 18 11:30:50 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (noconfigdirs): Add support for v850e target.
+
+	* config.sub (maybe_os): Add support for v850e target.
+
+Mon Aug 18 11:30:50 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (noconfigdirs): Add support for v850ea target.
+
+	* config.sub (maybe_os): Add support for v850ea target.
+
+Mon Aug 18 09:24:06 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Add mipstx39.  Delete r3900.
+
+Mon Aug 18 17:20:10 1997  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* Makefile.in (all-autoconf): Depends on all-texinfo.
+
+Fri Aug 15 23:09:26 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* config-ml.in ({powerpc,rs6000}*-*-*): Update to current AIX and
+	eabi targets.
+
+Thu Aug 14 14:42:17 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Get CFLAGS and CXXFLAGS from Makefile, if possible.
+
+	* configure: When handling a Canadian Cross, handle YACC as well as
+	BISON.  Just set BISON to bison.  When setting YACC, prefer bison.
+	* Makefile.in (all-bison): Depend upon all-texinfo.
+
+Tue Aug 12 20:09:48 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (BISON): bison, not byacc or bison -y.
+	(YACC): bison -y or byacc or yacc.
+	(various): Add *-bison as appropriate.
+	(taz): No need to mess with BISON anymore.
+
+Tue Aug 12 22:33:08 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If OSTYPE matches *win32*, try to find a good value for
+	CONFIG_SHELL.
+
+Sun Aug 10 14:41:11 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (taz): Get the version number from AM_INIT_AUTOMAKE in
+	configure.in if it is present.
+
+Sat Aug  9 00:58:01 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (LD_FOR_TARGET): Change ld.new to ld-new.
+
+Fri Aug  8 16:30:13 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: Recognize `arc' cpu.
+	* configure.in: Likewise.
+	* config-ml.in: Likewise.
+
+Thu Aug  7 11:02:34 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in ($(INSTALL_X11_MODULES)): Depend upon installdirs.
+
+Wed Aug  6 16:27:29 1997  Chris Provenzano  <proven@cygnus.com>
+
+	* configure: Changed sed delimiter from ':' to '|' when
+	attempting to substitute ${config_shell} for SHELL. On
+	NT ${config_shell} may contain a ':' in it.
+
+Wed Aug  6 12:29:05 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Fix for non-bash shells.
+
+Wed Aug  6 00:42:35 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (AS_FOR_TARGET): Change as.new to as-new.
+
+Tue Aug  5 14:08:51 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (NM_FOR_TARGET): Change nm.new to nm-new.
+
+	* ylwrap: If the program is a relative path, force it to be
+	absolute.
+
+Tue Aug  5 12:12:44 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure (tooldir): Set BISON to `bison -y' and not just bison.
+
+Mon Aug  4 22:59:02 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET): When winsup/Makefile present,
+	correctly specify the target build directory $(TARGET_SUBDIR)/winsup
+	for libraries.
+
+Mon Aug  4 12:40:24 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Fix handling of macros with values
+	separated by spaces.
+
+Thu Jul 31 19:49:49 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ylwrap: New file.
+	* Makefile.in (DEVO_SUPPORT): Add ylwrap.
+
+	* ltmain.sh: Handle /bin/sh at start of install program.
+
+	* Makefile.in (DEVO_SUPPORT): Add ltconfig, ltmain.sh, and missing.
+
+	* ltconfig, ltmain.sh: New files, from libtool 1.0.
+	* missing: New file, from automake 1.2.
+
+Thu Jul 24 12:57:56 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Treat tix like tk, putting it in X11_MODULES.  Add
+	check-tk to CHECK_X11_MODULES.
+
+Wed Jul 23 17:03:29 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with FSF.
+
+Tue Jul 22 19:08:29 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.guess: Merge with FSF.
+
+Tue Jul 22 14:50:42 1997  Robert Hoehne <robert.hoehne@Mathematik.TU-Chemnitz.DE>
+
+	* configure: Treat msdosdjgpp like go32.
+	* configure.in: Likewise.  Don't remove gprof for go32.
+
+	* configure: Change Makefile.tem2 to Makefile.tm2.
+
+Mon Jul 21 10:31:26 1997  Stephen Peters  <speters@cygnus.com>
+
+	* configure.in (noconfigdirs): For alpha-dec-osf*, don't ignore grep.
+
+Tue Jul 15 14:33:03 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* install-sh (chmodcmd): Set to null if the DST directory already
+	exists.  Same as Nov 11th change.
+
+Mon Jul 14 11:01:15 1997  Martin M. Hunt  <hunt@cygnus.com>
+
+	* configure (GDB_TK): Needs itcl and tix.
+
+Mon Jul 14 00:32:10 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* config.guess: Update from FSF.
+
+Fri Jul 11 11:57:11 1997  Martin M. Hunt  <hunt@cygnus.com>
+
+	* Makefile.in (GDB_TK): Depend on itcl and tix.
+
+Fri Jul  4 13:25:31 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_PROGRAM_ARGS): New variable.
+	(INSTALL_PROGRAM): Use $(INSTALL_PROGRAM_ARGS).
+	(INSTALL_SCRIPT): New variable.
+	(BASE_FLAGS_TO_PASS): Pass down INSTALL_SCRIPT.
+	* configure.in: If host is *-*-cygwin32*, set INSTALL_PROGRAM_ARGS
+	to -x.
+	* install-sh: Add support for -x option.
+
+Mon Jun 30 15:51:30 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in, Makefile.in: Treat tix like itcl.
+
+Thu Jun 26 13:59:19 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (WINDRES): New variable.
+	(WINDRES_FOR_TARGET): New variable.
+	(BASE_FLAGS_TO_PASS): Add WINDRES_FOR_TARGET.
+	(EXTRA_HOST_FLAGS): Add WINDRES.
+	(EXTRA_TARGET_FLAGS): Add WINDRES.
+	(EXTRA_GCC_FLAGS): Add WINDRES.
+	($(DO_X)): Pass down WINDRES.
+	($(CONFIGURE_TARGET_MODULES)): Set WINDRES when configuring.
+	* configure: Treat WINDRES like DLLTOOL, and WINDRES_FOR_TARGET like
+	DLLTOOL_FOR_TARGET.
+
+Wed Jun 25 15:01:26 1997  Felix Lee  <flee@cygnus.com>
+
+	* configure.in: configure sim before gdb for win32-x-ppc
+
+Wed Jun 25 12:18:54 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	Move gperf into the toplevel, from libg++.
+	* configure.in (target_tools): Add target-gperf.
+	(native_only): Add target-gperf.
+	* Makefile.in (all-target-gperf): New target, depend on
+	all-target-libg++.
+	(configure-target-gperf): Empty rule.
+	(ALL_TARGET_MODULES): Add all-target-gperf.
+	(CONFIGURE_TARGET_MODULES): Add configure-target-gperf.
+	(CHECK_TARGET_MODULES): Add check-target-gperf.
+	(INSTALL_TARGET_MODULES): Add install-target-gperf.
+	(CLEAN_TARGET_MODULES): Add clean-target-gperf.
+
+Mon Jun 23 10:51:53 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub (mn10200): Recognize new basic machine.
+
+Thu Jun 19 14:16:42 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: Don't set ENABLE_MULTILIB, so we'll be passing
+	--enable-multilib down to subdirs; setting TARGET_SUBDIR was enough.
+
+Tue Jun 17 15:31:20 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: If we're building mips-sgi-irix6* native, turn on
+	ENABLE_MULTILIB and set TARGET_SUBDIR.
+
+Tue Jun 17 12:20:59 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (all-sn): Depend on all-grep.
+
+Mon Jun 16 11:11:10 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Use mh-ppcpic and mt-ppcpic for powerpc*-* targets.
+
+	* configure: Set CFLAGS and CXXFLAGS, and substitute them into
+	Makefile.  From Jeff Makey <jeff@cts.com>.
+	* Makefile.in: Add comment for CFLAGS and CXXFLAGS.
+
+	* Makefile.in (DISTBISONFILES): Remove.
+	(taz): Don't futz with DISTBISONFILES.  Change BISON to use
+	$(DEFAULT_YACC).
+
+	* configure.in: Build itl, db, sn, etc., when building for native
+	cygwin32.
+
+	* Makefile.in (LD): New variable.
+	(EXTRA_HOST_FLAGS): Pass down LD.
+	($(DO_X)): Likewise.
+
+Mon Jun 16 11:10:35 1997  Philip Blundell  <Philip.Blundell@pobox.com>
+
+	* Makefile.in (INSTALL): Use $(SHELL) when executing install-sh.
+
+Fri Jun 13 10:22:56 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in (targargs): Strip out any supplied --build argument
+	before adding our own. Always add --build.
+
+Thu Jun 12 21:12:28 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in (targargs): Pass --build if we're doing
+	a cross-compile.
+
+Fri Jun  6 21:38:40 1997  Rob Savoye  <rob@chinadoll.cygnus.com>
+
+	* configure: Use '|' instead of ":" as the separator in
+	sed. Otherwise sed chokes on NT path names with drive
+	designators. Also look for "?:*" as the leading characters in an
+	absolute pathname.
+
+Mon Jun  2 13:05:20 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Support for r3900.
+
+Wed May 21 17:33:31 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Use install-sh, not install.sh.
+
+Wed May 14 16:06:51 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (taz): Improve check for BISON so it doesn't try to
+	apply it twice.
+
+Fri May  9 17:22:05 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_MODULES): Put install-opcodes before
+	install-binutils.
+
+Thu May  8 17:29:50 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Add automake targets.
+	* configure.in (host_tools): Add automake.
+
+Tue May  6 15:49:52 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Default CXX to c++, not gcc.
+	* Makefile.in (CXX): Set to c++, not gcc.
+	(CXX_FOR_TARGET): When cross, transform c++, not gcc.
+
+Thu May  1 10:11:43 1997  Geoffrey Noer  <noer@cygnus.com>
+
+	* install-sh: try appending a .exe if source file doesn't
+	exist
+
+Wed Apr 30 12:05:36 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* configure.in: Turn on multilib by default.
+	(cross_only): Remove target-libiberty.
+
+	* Makefile.in (all-gcc): Don't depend on libiberty.
+
+Mon Apr 28 18:39:45 1997  Michael Snyder  <msnyder@cleaver.cygnus.com>
+
+	* config.guess: improve algorithm for recognizing Gnu Hurd x86.
+
+Thu Apr 24 19:30:07 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Add mpw-install.
+	(DISTBISONFILES): Add ld/Makefile.in
+
+Tue Apr 22 17:17:28 1997  Geoffrey Noer  <noer@pizza.cygnus.com>
+
+	* configure.in: if target is cygwin32 but host isn't cygwin32,
+	don't configure gdb tcl tk expect, not just gdb.
+
+Mon Apr 21 13:33:39 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in: Added gnuserv everywhere sn appears.
+
+	* Makefile.in (ALL_MODULES): Added all-gnuserv.
+	(CROSS_CHECK_MODULES): Added check-gnuserv.
+	(INSTALL_MODULES): Added install-gnuserv.
+	(CLEAN_MODULES): Added clean-gnuserv.
+	(all-gnuserv): New target.
+
+Thu Apr 17 13:57:06 1997  Per Fogelstrom  <pefo@openbsd.org>
+
+	* config.guess: Fixes for MIPS OpenBSD systems.
+
+Tue Apr 15 12:21:07 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_XFORM): Remove.
+	(BASE_FLAGS_TO_PASS): Remove INSTALL_XFORM.
+
+	* mkinstalldirs: New file, copied from automake.
+	* Makefile.in (installdirs): Rename from install-dirs.  Use
+	mkinstalldirs.  Change all users.
+	(DEVO_SUPPORT): Add mkinstalldirs.
+
+Mon Apr 14 11:21:38 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* install-sh: Rename from install.sh.
+	* Makefile.in (INSTALL): Change install.sh to install-sh.
+	(DEVO_SUPPORT): Likewise.
+
+	* configure: Use ${config_shell} with ${moveifchange}.  From Thomas
+	Graichen <graichen@rzpd.de>.
+
+Fri Apr 11 16:37:10 1997  Niklas Hallqvist  <niklas@appli.se>
+
+	* config.guess: Recognize OpenBSD systems correctly.
+
+Fri Apr 11 17:07:04 1997  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* README, Makefile.in (ETC_SUPPORT): Remove references to
+	cfg-paper*, configure.{texi,man,info*}._
+
+Sun Apr  6 18:47:57 1997  Andrew Cagney  <cagney@kremvax.cygnus.com>
+
+	* Makefile.in (all.normal): Ensure that gcc is built after all
+	the x11 - ie gdb - targets.
+
+Tue Apr  1 16:28:50 1997  Klaus Kaempf  <kkaempf@progis.de>
+
+	* makefile.vms: Don't run conf-a-gas.
+
+Mon Mar 31 16:26:55 1997  Joel Sherrill  <joel@oarcorp.com>
+
+	* configure.in (hppa1.1-*-rtems*): New target, like hppa-*-*elf*.
+
+Sun Mar 30 12:38:27 1997  Fred Fish  <fnf@cygnus.com>
+
+	* configure.in: Remove noconfigdirs case since gdb also
+	configures and builds for tic80-coff.
+
+Fri Mar 28 18:28:52 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Set cache_file to config.cache.
+	* Makefile.in (local-distclean): Remove config.cache.
+
+Wed Mar 26 18:49:39 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* COPYING: Update FSF address.
+
+Wed Mar 26 10:38:25 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (tic80-*-*): Remove G++ libraries and libgloss from
+	noconfigdirs.
+
+Mon Mar 24 15:02:39 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (install-dirs): Don't crash if prefix, and hence
+	MAKEDIRS, is empty.
+
+Mon Mar 24 12:40:55 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: Tweak mn10300 entry.
+
+Fri Mar 21 15:35:27 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (host_tools): Put sim before gdb, so gdb's
+	configure.tgt can determine if the simulator was configured.
+
+Sun Mar 16 16:07:08 1997  Fred Fish  <fnf@cygnus.com>
+
+	* config.sub: Move BeOS $os case to be with other Cygnus
+	local cases.
+
+Sun Mar 16 01:34:55 1997  Martin Hunt <hunt@cygnus.com>
+
+	* config.sub: Remove misplaced comment that broke Linux.
+
+Sat Mar 15 22:50:15 1997  Fred Fish  <fnf@cygnus.com>
+
+	* config.sub: Add BeOS support.
+
+Mon Mar 10 13:30:11 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (CHECK_X11_MODULES): Don't run check-tk.
+
+Wed Mar  5 12:09:29 1997  Martin  <hunt@cygnus.com>
+
+	* configure.in (noconfigdirs): Remove tcl and tk from
+	noconfigdirs for cygwin32 builds.
+
+Fri Feb 28 18:20:15 1997  Fred Fish  <fnf@cygnus.com>
+
+	* configure.in (tic80-*-*): Remove ld from noconfigdirs.
+
+Thu Feb 27 14:57:26 1997  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (GAS_SUPPORT_DIRS, BINUTILS_SUPPORT_DIRS): Remove
+	make-all.com, use makefile.vms instead.
+
+Tue Feb 25 18:46:14 1997  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* config.sub: Accept -lnews*.
+
+Tue Feb 25 13:19:14 1997  Andrew Cagney  <cagney@kremvax.tpgi.com.au>
+
+	* configure.in (noconfigdirs): Disable target-newlib,
+	target-examples and target-libiberty for d30v.
+
+Fri Feb 21 17:56:25 1997  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (noconfigdirs): Enable ld for d30v.
+
+Fri Feb 21 20:58:51 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (tic80-*-*): Build compiler.
+
+Sun Feb 16 15:41:09 1997  Andrew Cagney  <cagney@critters.cygnus.com>
+
+	* configure.in (d30v-*): Remove sim directory from list of
+	unsupported d30v directories
+
+Tue Feb 18 17:32:42 1997  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* config.sub, configure.in: Add d30v target cpu.
+
+Thu Feb 13 22:04:44 1997  Klaus Kaempf  <kkaempf@progis.de>
+
+	* makefile.vms: New file.
+	* make-all.com: Remove.
+
+Wed Feb 12 12:54:18 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Add LIBGCC2_DEBUG_CFLAGS.
+
+Sat Feb  8 20:36:49 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* Makefile.in (all-itcl): The rule is all-itcl, not all-tcl.
+
+Tue Feb  4 11:39:29 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Added all-db.
+	(CROSS_CHECK_MODULES): Addec check-db.
+	(INSTALL_MODULES): Added install-db.
+	(CLEAN_MODULES): Added clean-db.
+
+Mon Feb  3 13:29:36 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.guess: Merge with latest FSF sources.
+
+Tue Jan 28 09:20:37 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Added all-itcl.
+	(CROSS_CHECK_MODULES): Added check-itcl.
+	(INSTALL_MODULES): Added install-itcl.
+	(CLEAN_MODULES): Added clean-itcl.
+
+Thu Jan 23 01:44:27 1997  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: build gdb for mn10200
+
+Fri Jan 17 15:32:15 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (all-target-winsup): Depend on all-target-libio.
+
+Mon Jan 13 22:46:54 1997  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (tic80-*-*): Turn off most targets right now.
+
+Fri Jan  3 16:04:03 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (MAKEINFO): Check for the existence of the Makefile,
+	rather than the makeinfo program.
+	(do-info): Depend upon all-texinfo.
+
+Tue Dec 31 16:00:31 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Remove uses of config/mh-linux.
+
+	* config.sub, config.guess: Merge with latest FSF sources.
+
+Fri Dec 27 23:04:33 1996  Fred Fish  <fnf@cygnus.com>
+
+	* config.sub (case $basic_machine): Add tic80 entries.
+
+Fri Dec 27 12:07:59 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub, config.guess: Merge with latest FSF sources.
+
+Wed Dec 18 22:46:39 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-build.in: Build ld before gcc, use NewFolderRecursive.
+	* mpw-config.in: Test for NewFolderRecursive.
+	* mpw-install: Use symbolic name for startup filename.
+	* mpw-README: Add various additional details.
+
+Wed Dec 18 13:11:46 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (mips*-sgi-irix6*): Remove binutils from noconfigdirs.
+
+Wed Dec 18 10:29:31 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Do build gcc and the target libraries for
+	the mn10200.
+
+Wed Dec  4 16:53:05 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: don't avoid building gdb for mn10300 any more
+	* Makefile.in: double-quote GCC_FOR_TARGET line in EXTRA_GCC_FLAGS
+	instead of single-quoting it.
+
+Tue Dec  3 23:26:50 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* configure.in: Don't use --with-stabs on IRIX 6.
+
+Tue Dec  3 09:05:25 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in (m32r): Build gdb, libg++ now.
+
+Sun Dec  1 00:18:59 1996  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* configure.in (mips*-sgi-irix6*):  Remove gdb and related
+	directories from noconfigdirs.
+
+Tue Nov 26 11:45:33 1996  Kim Knuttila  <krk@cygnus.com>
+
+	* config.sub (basic_machine): added mips16 configuration
+
+Sat Nov 23 19:26:22 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.sub: Handle d10v-unknown.
+
+Sat Nov 23 10:23:01 1996  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Handle v850-unknown.
+
+Thu Nov 21 16:19:44 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: add findutils
+	* configure.in: add findutils to list of host_tools
+
+Wed Nov 20 10:09:01 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Handle mn10200 and mn10300.
+
+Tue Nov 19 16:35:14 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (d10v-*): Do not build librx.
+
+Mon Nov 18 13:28:41 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (mn10300): Build everything except gdb & libgloss.
+
+Wed Nov 13 14:59:46 1996  Per Bothner  <bothner@deneb.cygnus.com>
+
+	* config.guess:  Patch for Dansk Data Elektronik servers,
+	from Niels Skou Olsen <nso@dde.dk>.
+
+	For ncr, use /bin/uname rather than uname, since GNU uname does not
+	support -p.  Suggested by Mark Mitchell <mmitchell@usa.net>.
+
+	Patch for MIPS R4000 running System V,
+	from Eric S. Raymond <esr@snark.thyrsus.com>.
+
+	Fix thinko for nextstep.
+
+	Patch for OSF1 in i?86, from Dan Murphy <dlm@osf.org> via Harlan Stenn.
+
+	Sat Jun 24 18:58:17 1995  Morten Welinder  <terra+@cs.cmu.edu>
+	* config.guess: Guess mips-dec-mach_bsd4.3.
+
+	Thu Oct 10 04:07:04 1996  Harlan Stenn <harlan@pfcs.com>
+	* config.guess (i?86-ncr-sysv*):  Emit just enough of the minor
+	release numbers.
+	* config.guess (mips-mips-riscos*):  Emit just enough of the
+	release number.
+
+	Tue Oct  8 10:37:22 1996  Frank Vance <fvance@waii.com>
+	* config.guess (sparc-auspex-sunos*):  Added.
+	(f300-fujitsu-*): Added.
+
+	Wed Sep 25 22:00:35 1996  Jeff Woolsey <woolsey@jlw.com>
+	* config.guess:  Recognize a Tadpole as a sparc.
+
+Wed Nov 13 00:53:09 1996  David J. MacKenzie  <djm@churchy.gnu.ai.mit.edu>
+
+	* config.guess: Don't assume that NextStep version is either 2 or
+	3.  NextStep 4 (aka OpenStep 4) has come out now.
+
+Mon Nov 11 23:52:03 1996  David J. MacKenzie  <djm@churchy.gnu.ai.mit.edu>
+
+	* config.guess: Support Cray T90 that reports itself as "CRAY TS".
+	From Rik Faith <faith@cs.unc.edu>.
+
+Fri Nov  8 11:34:58 1996  David J. MacKenzie  <djm@geech.gnu.ai.mit.edu>
+
+	* config.sub: Contributions from bug-gnu-utils to:
+	Support plain "hppa" (no version given) architecture, reported by
+	OpenStep.
+	OpenBSD like NetBSD.
+	LynxOs is not a hardware supplier.
+
+	* config.guess: Contributions from bug-gnu-utils to add support for:
+	OpenBSD like NetBSD.
+	Stratus systems.
+	More Pyramid systems.
+	i[n>4]86 Intel chips.
+	M680[n>4]0 Motorola chips.
+	Use unknown instead of lynx for hardware manufacturer.
+
+Mon Nov 11 10:09:08 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* install.sh (chmodcmd): Set to null if the DST directory already
+	exists.
+
+Mon Nov 11 10:43:41 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpc*-{eabi,elf,linux,rtem,sysv,solaris}*): Do
+	not use mt-ppc target Makefile fragment any more.
+
+Sun Nov  3 19:17:07 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in (*-*-windows):  Exclude everything but those dirs
+	needed to build windows.
+
+Tue Oct 29 16:41:31 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (all-target-winsup): Depend on all-target-librx.
+
+Mon Oct 28 17:32:46 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  Exclude mmalloc from i386-windows.
+
+Thu Oct 24 09:22:46 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* Undo my previous change.
+
+Thu Oct 24 12:12:04 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Pass down GCC_FOR_TARGET
+	unconditionally.
+	(MAKEOVERRIDES): Define (revert this part of October 18 change).
+
+Thu Oct 24 09:02:07 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* Makefile.in (FLAGS_TO_PASS):  Add $(HOST_FLAGS) to allow the
+	host to add it's own flags.
+
+Tue Oct 22 15:20:26 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Handle GCC_FOR_TARGET like CC_FOR_TARGET.
+
+Fri Oct 18 13:37:13 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET): Check for xgcc, not Makefile.
+	(CXX_FOR_TARGET): Likewise.
+	(GCC_FOR_TARGET): Define.
+	(BASE_FLAGS_TO_PASS): Remove GCC_FOR_TARGET.
+	(EXTRA_GCC_FLAGS): Define GCC_FOR_TARGET based on whether
+	CC_FOR_TARGET was specified on the command line.
+	(MAKEOVERRIDES): Don't define.
+
+Thu Oct 17 10:27:56 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in (m32r): Fix spelling of libg++ libs.
+
+Thu Oct 10 10:37:17 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* config.sub (-apple*): Remove, now redundant.
+
+Thu Oct 10 12:30:54 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Don't get confused by CPU-VENDOR-linux-gnu.
+
+	* configure: Rework yesterday's sed script patch.
+
+	* config.sub: Merge with FSF.
+
+Wed Oct  9 17:24:59 1996  Per Bothner  <bothner@deneb.cygnus.com>
+
+	* config.guess:  Merge from FSF.
+
+	1996-09-12  Richard Stallman  <rms@ethanol.gnu.ai.mit.edu>
+	* config.guess: Use pc instead of unknown, for pc clone systems.
+	Change linux to linux-gnu.
+
+	Mon Jul 15 23:51:11 1996  Karl Heuer  <kwzh@gnu.ai.mit.edu>
+	* config.guess: Avoid non-portable tr syntax.
+
+Wed Oct  9 06:06:46 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* test-build.mk (HOLES): Add "xargs" for gdb.
+
+	* configure: Avoid hpux10.20 sed bug.
+
+Tue Oct  8 08:32:48 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  Add support for windows host
+	(that is a build done under the Microsoft build environment).
+
+Tue Oct  8 10:39:08 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Replace all uses of srcroot with s, to shrink
+	command line lengths.
+
+	Patches from Geoffrey Noer <noer@cygnus.com>:
+	* configure.in: If configuring for newlib, pass --with-newlib to
+	subdirectories.
+	* Makefile.in (CC_FOR_TARGET): If winsup/Makefile exists, pass a
+	-Bnewlib/ and -Lwinsup to gcc.
+	(CXX_FOR_TARGET): Likewise.
+
+Mon Oct  7 10:59:35 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (ETC_SUPPORT): Add configure.
+
+Fri Oct  4 12:22:58 1996  Angela Marie Thomas (angela@cygnus.com)
+
+	* configure.in: Use config/mh-dgux386 for i[345]86-dg-dgux
+	host configuration file.
+
+Thu Oct  3 09:28:25 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Break mn10x00 support into separate
+	mn10200 and mn10300 configurations.
+	* config.sub: Likewise.
+
+Wed Oct  2 22:27:52 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Add lots of stuff to noconfigdirs for
+	the mn10x00 targets.
+
+	* config.sub, configure.in: Add mn10x00 support.
+
+Wed Oct  2 15:52:36 1996  Klaus Kaempf  <kkaempf@progis.de>
+
+	* make-all.com: Call conf-a-gas, not config-a-gas.
+
+Tue Oct  1 01:28:41 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* configure.in (noconfigdirs): Don't build libgloss for arm-coff
+	targets.
+
+Mon Sep 30 14:24:01 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-README: Add much more detail for native PowerMac.
+	* mpw-install: New file.
+	* mpw-configure: Add --norecursion and --help options.
+	* mpw-config.in: Translate readme and install files when
+	copying to objdir.
+	* mpw-build.in: Don't always depend on byacc and flex.
+	(install-only-top): New action.
+
+Fri Sep 27 17:39:44 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  You can now configure GDB for the v850.
+
+Tue Sep 24 19:05:12 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* configure.in (noconfigdirs): Don't configure any C++ dirs
+	if targeting D10V.
+
+Tue Sep 17 12:15:31 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Recognize mips64vr5000.
+
+Mon Sep 16 17:00:52 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Use a single line for host_tools and native_only.
+
+Mon Sep  9 12:21:30 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub, configure.in: Add entries for m32r.
+
+Thu Sep  5 13:52:47 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (inet-install): Don't run install-gzip.
+
+Wed Sep  4 17:26:13 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  Don't config lots of things for *-*-windows*.
+
+Sat Aug 31 11:45:57 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-config.in: Test for mpw-true, true, and null-command scripts.
+	(host_libs, host_tools): Copy from configure.in.
+	* mpw-configure: Don't complain about directories not found.
+
+Thu Aug 29 16:44:58 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (i[345]86): Recognize i686 for pentium pro.
+	(i[3456]86-*-dgux*): Use config/mh-sysv for the host configuration
+	file.
+
+	* config.guess (i[345]86): Ditto.
+
+Mon Aug 26 18:34:42 1996  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (noconfigdirs): Removed gdb for D10V.
+
+Thu Aug 22 17:13:52 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Remove ld, target-libio, target-libg++, and
+	target-libstdc++ from noconfigdirs.
+
+Wed Aug 21 18:56:38 1996  Fred Fish  <fnf@cygnus.com>
+
+	* configure: Fix three locations where shell scripts were
+	being run directly rather than with config_shell.
+
+Tue Aug 20 13:08:47 1996  J.T. Conklin  <jtc@hippo.cygnus.com>
+
+	* configure.in (v850-*-*): Set up initial $noconfigdirs.
+	* config.sub (basic_machine): Recognize v850.
+
+Thu Aug 15 12:19:33 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Handle multiple enable/disable options and
+	pass them down recursively, handle -c and -s flags appropriately
+	depending on choice of compiler, add escape mechanism for
+	quoted arguments to gC.
+
+Mon Aug 12 13:15:13 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpc*-*-*): For eabi, system V.4, Linux, and
+	solaris targets, use config/mt-ppc to set C{,XX}FLAGS_FOR_TARGETS
+	so that -mrelocatable-lib and -mno-eabi are used.
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): If target compiler does
+	not support --print-multi-lib, don't abort.
+
+Thu Aug  8 12:18:59 1996  Klaus Kaempf  <kkaempf@progis.de>
+
+	* make-all.com: Run config-a-gas.
+	* setup.com: Don't copy subdirectory files around.
+
+Tue Jul 30 17:49:31 1996  Brendan Kehoe  <brendan@cygnus.com>
+
+	* configure.in (*-*-ose): Remove exclusion of libgloss for this
+	target, it now compiles correctly.
+
+Sat Jul 27 15:10:43 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-config.in: Generate Mac include for elf/dwarf2.h.
+
+Tue Jul 23 10:47:04 1996  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (d10v-*-*): Remove ld from $noconfigdirs.
+
+Mon Jul 22 13:28:51 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in (native_only): Add prms.
+
+Mon Jul 22 12:27:58 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (GAS_SUPPORT_DIRS): Add make-all.com and setup.com.
+	(BINUTILS_SUPPORT_DIRS): Likewise.
+
+Thu Jul 18 12:55:40 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (d10v-*-*): Don't configure ld or gdb until the
+	d10v support is added.
+
+Wed Jul 17 14:33:09 1996  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (d10v-*-*): New target.
+
+Mon Jul 15 11:53:00 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess (HP 9000/811): Recognize this as a PA1.1
+	machine.
+
+Fri Jul 12 23:21:17 1996  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (do-tar-gz): New target, split out from tail end of
+	taz target.  Run each command separately, don't use pipes.
+	(taz): Use it.
+
+Fri Jul 12 12:08:04 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Look for g-mpw-make.sed in config/mpw.
+	* mpw-build.in: No builds should depend on building byacc or flex,
+	they are assumed to be installed already.
+
+Fri Jul 12 09:52:52 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Set r environment
+	variable that CC_FOR_TARGET needs.
+
+Thu Jul 11 10:09:45 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Determine if the multlib
+	options have changed since the last time the subdirectory was
+	configured, and if it has, reconfigure.
+	(CLEAN_TARGET_MODULES): Delete multilib.out and tmpmulti.out, which
+	CONFIGURE_TARGET_MODULES uses to remember the old multilib options.
+
+Wed Jul 10 18:56:59 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (ALL_MODULES,CROSS_CHECK_MODULES,INSTALL_MODULES,
+	CLEAN_MODULES): Add bash.
+	(all-bash): New target.
+
+Mon Jul  8 17:33:14 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (mips-sgi-irix6*): Use mh-irix6 instead of mh-irix5.
+
+Mon Jul  1 13:31:35 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.sub (basic_machine): Recognize d10v as a valid processor.
+
+Fri Jun 28 12:14:35 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Add support for --bindir.
+	* mpw-build.in: Use a GCC-specific build script for GCC actions.
+
+Wed Jun 26 17:20:12 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: add bash, time, gawk to list of hosttools and things
+	to only build for native toolchains
+
+Tue Jun 25 23:09:03 1996  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* Makefile.in (docdir): Remove.
+
+Tue Jun 25 19:00:08 1996  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* Makefile.in (datadir): Set to $(prefix)/share.
+
+Mon Jun 24 23:26:07 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: build diff and patch for cygwin32-hosted
+	toolchains.
+
+Mon Jun 24 15:01:12 1996  Joel Sherrill  <joel@merlin.gcs.redstone.army.mil>
+
+	* config.sub: Accept -rtems*.
+
+Sun Jun 23 22:41:54 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: enable dosrel for cygwin32-hosted builds,
+		remove diff from the list of things not buildable
+		via Canadian Cross
+
+Sat Jun 22 11:39:01 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (TARGET_SUBDIR): Move comment to previous line so we
+	don't get ". ".
+
+Fri Jun 21 17:24:48 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (mips*-sgi-irix6*): Set noconfigdirs appropriately.
+
+Thu Jun 20 16:57:40 1996  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (taz): Handle case where tex3patch didn't even get
+	checked out.  Also, if it was found, put the symlink in a new util
+	subdirectory.
+
+Thu Jun 20 12:20:33 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.guess (*:Linux:*:*): Add support for PowerPC Linux.
+
+Tue Jun 18 14:24:12 1996  Klaus Kaempf  (kkaempf@progis.de)
+
+	* config.sub: Recognize -openvms.
+	* configure.in (alpha*-*-*vms*): Set noconfigdirs.
+	* make-all.com, setup.com: New files.
+
+Mon Jun 17 16:34:46 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (taz): tex3patch moved to texinfo/util.
+
+Sat Jun 15 17:13:25 1996  Geoffrey Noer <noer@cygnus.com>
+
+	* configure: enable_gdbtk=no for cygwin32-hosted toolchains
+	* configure.in: remove make from disable-if-Can-Cross list
+		enable gdb if ${host} and ${target} are cygwin32
+
+Fri Jun  7 18:16:52 1996  Harlan Stenn <harlan@pfcs.com>
+
+	* config.guess (i?86-ncr-sysv*):  Emit minor release numbers.
+	Recognize the NCR 4850 machine and NCR Pentium-based platforms.
+
+Wed Jun  5 00:09:17 1996  Per Bothner  <bothner@wombat.gnu.ai.mit.edu>
+
+	* config.guess:  Combine mips-mips-riscos cases, and use cpp to
+	distinguish sysv/svr4/bsd variants.
+	Based on a patch from Harlan Stenn <harlan@pfcs.com>.
+
+Fri Jun  7 14:24:49 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* configure.in: Added copyright notice.
+	* move-if-change: Added copyright notice.
+
+Thu Jun  6 16:27:05 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpcle-*-solaris*): Until we get shared
+	libraries working, don't build gdb, sim, make, tcl, tk, or
+	expect.
+
+Tue Jun  4 20:41:45 1996  Per Bothner  <bothner@deneb.cygnus.com>
+
+	* config.guess:  Merge with FSF:
+
+	Mon Jun  3 08:49:14 1996  Karl Heuer  <kwzh@gnu.ai.mit.edu>
+	* config.guess (*:Linux:*:*): Add guess for sparc-unknown-linux.
+
+	Fri May 24 18:34:53 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
+	* config.guess (AViiON:dgux:*:*): Fix typo in recognizing mc88110.
+
+	Fri Apr 12 20:03:59 1996  Per Bothner  <bothner@spiff.gnu.ai.mit.edu>
+	* config.guess:  Combine two OSF1 rules.
+	Also recognize field test versions.  From mjr@zk3.dec.com.
+	* config.guess (dgux):  Use /usr/bin/uname rather than uname,
+	because GNU uname does not support -p.  From pmr@pajato.com.
+
+Tue Jun  4 11:07:25 1996  Tom Tromey  <tromey@csk3.cygnus.com>
+
+	* Makefile.in (MAKEDIRS): Removed $(tooldir).
+
+Tue May 28 12:30:50 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-README: Document GCCIncludes.
+
+Sun May 26 15:16:27 1996  Fred Fish  <fnf@cygnus.com>
+
+	* configure.in (alpha-*-linux*): Set enable_shared to yes.
+
+Tue May 21 15:41:39 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Handle --enable-FOO and --disable-FOO.
+
+Mon May 20 10:12:29 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in (*-*-cygwin32): Configure make.
+
+Tue May  7 14:19:42 1996  Tom Tromey  <tromey@snuffle.cygnus.com>
+
+	* Makefile.in (inet-install): Quote value of INSTALL_MODULES.
+
+Fri May  3 08:57:17 1996  Tom Tromey  <tromey@lisa.cygnus.com>
+
+	* Makefile.in (all-inet): Depend on all-perl.
+
+	* Makefile.in (inet-install): New target.
+
+	* Makefile.in (all-inet): Depend on all-tcl.
+	(all-inet): Depend on all-send-pr.
+
+Tue Apr 30 13:55:51 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpcle-*-solaris*): Turn off tk and tcl
+	temporarily.
+
+Thu Apr 25 11:48:20 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure --with-gnu-ld on AIX.
+
+Thu Apr 25 06:33:36 1996  Michael Meissner  <meissner@wogglebug.tiac.net>
+
+	* configure.in (powerpcle-*-solaris*): Turn off gdb temporarily.
+
+Tue Apr 23 09:07:39 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Added all-inet.
+	(CROSS_CHECK_MODULES): Added check-inet.
+	(INSTALL_MODULES): Added install-inet.
+	(CLEAN_MODULES): Added clean-inet.
+	(all-indent): New target.
+
+	* configure.in (host_tools): Added inet.
+	(native_only): Added inet.
+	(noconfigdirs): Added inet.
+
+Fri Apr 19 15:35:29 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure libgloss if we are not configuring
+	newlib.
+
+Wed Apr 17 19:30:01 1996  Rob Savoye  <rob@chinadoll.cygnus.com>
+
+	* configure.in: Don't configure libgloss for unsupported
+	architectures.
+
+Tue Apr 16 11:17:05 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (CLEAN_MODULES): Add clean-apache.
+
+Mon Apr 15 15:09:05 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Include all-apache.
+	(CROSS_CHECK_MODULES): Include check-apache.
+	(INSTALL_MODULES): Include install-apache.
+	(all-apache): New target.
+
+	* configure.in: Added apache everywhere perl is seen.
+
+Mon Apr 15 14:59:13 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in: Add support for clean-{module} and
+	clean-target-{module} rules.
+
+Wed Apr 10 21:37:41 PDT 1996  Marilyn E. Sander <msander@cygnus.com>
+
+	* configure.in (*-*-ose) do not build libgloss.
+
+Mon Apr  8 16:16:20 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.guess (prep*:SunOS:5.*:*): Turn into
+	powerpele-unknown-solaris2.
+
+Mon Apr  8 14:45:41 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Permit --enable-shared to specify a list of
+	directories.
+
+Fri Apr  5 08:17:57 1996  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (host==solaris): Pass only the first word of $CC
+	to /usr/bin/which when checking if we're using /usr/ccs/bin/cc.
+
+Fri Apr  5 03:16:13 1996  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): pass down $(MAKE).
+
+Thu Mar 28 14:11:11 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Include all-perl.
+	(CROSS_CHECK_MODULES): Include check-perl.
+	(INSTALL_MODULES): Include install-perl.
+	(ALL_X11_MODULES): Include all-guile.
+	(CHECK_X11_MODULES): Include check-guile.
+	(INSTALL_X11_MODULES): Include install-guile.
+	(all-perl): New target.
+	(all-guile): New target.
+
+	* configure.in (host_tools): Include perl and guile.
+	(native_only): Include perl and guile.
+	(noconfigdirs): Don't build guile and perl; no ports have been
+	done.
+
+Tue Mar 26 21:18:50 1996  Andrew Cagney  <cagney@kremvax.highland.com.au>
+
+	* configure (--enable-*): Handle quoted option lists such as
+	--enable-sim-cflags='-g0 -O' better.
+
+Thu Mar 21 11:53:08 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in ({,inst}all-target): New rule so we can make and
+	install all of the target directories easily.
+
+Wed Mar 20 18:10:57 1996  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* configure.in: Add missing global flag in sed substitution when
+	deleting `target-' from ${configdirs}.
+
+Thu Mar 14 19:15:06 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DO_X): Don't get confused if CC contains `=' in an
+	option.
+
+	* configure.in (mips*-nec-sysvr4*): Use a host_makefile_frag of
+	config/mh-necv4.
+
+	* install.sh: Correct misspelling of transformbasename.
+
+	* config.guess: Recognize mips-*-sysv*.
+
+Mon Mar 11 15:36:42 1996  Dawn Perchik  <dawn@critters.cygnus.com>
+
+	* config.sub: Recognize mon960.
+
+Sun Mar 10 13:18:38 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Restore Canadian Cross handling of BISON and LEX,
+	removed in Feb 20 change.
+
+Fri Mar  8 20:07:09 1996  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* README:  Suggestions from Torbjorn Granlund <tege@matematik.su.se>:
+	Mention make install.  Remove the old copyright date as well the
+	clumsy and rather pointless copyright on the README file.
+
+Fri Mar  8 17:51:35 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): If there is a
+	Makefile after running symlink-tree, then run `make distclean' to
+	avoid clobbering any generated files in srcdir.
+
+Tue Mar  5 08:21:44 1996  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (m68k-*-netbsd*): Build everything now.
+
+Wed Feb 28 12:25:46 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (taz): Fix quoting.
+
+Tue Feb 27 11:33:57 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* configure.in (sparclet-*-*): Build everything now.
+
+Tue Feb 27 14:31:51 1996  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* configure.in (m68k-*-linux*): New host.
+
+Mon Feb 26 14:32:44 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Check for bison before byacc.
+
+Tue Feb 20 23:12:35 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* Makefile.in configure:  Change the way LEX and BISON/YACC are
+	set.  configure now defines DEFAULT_LEX and DEFAULT_YACC by
+	searching PATH.  These are used as fallbacks by Makefile.in if
+	flex/bison/byacc aren't in objdir.
+
+Mon Feb 19 11:45:30 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Make everything which depends upon all-bfd also
+	depend upon all-opcodes, in case --with-commonbfdlib is used.
+
+Thu Feb 15 19:50:50 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (host *-*-cygwin32): Don't build gdb if we are
+	building NT native compilers on Unix.
+
+Thu Feb 15 17:42:25 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't get CC from the host Makefile fragment if we
+	can find gcc in PATH, or if this is a Canadian Cross.  Move the
+	Solaris test for /usr/ucb/cc to the post target script, just after
+	the compiler sanity test.
+
+Wed Feb 14 16:57:40 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with FSF.
+
+Tue Feb 13 14:27:48 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (RPATH_ENVVAR): New variable.
+	(REALLY_SET_LIB_PATH): Use it.
+	* configure.in: On HP/UX, set RPATH_ENVVAR to SHLIB_PATH.
+
+Mon Feb 12 15:28:49 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* config.sub, configure.in: Recognize sparclet cpu.
+
+Mon Feb 12 15:33:59 1996  Christian Bauernfeind <chrisbfd@theorie3.physik.uni-erlangen.de>
+
+	* config.guess:  Support m68k-cbm-sysv4.
+
+Sat Feb 10 12:06:42 1996  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* config.guess (*:Linux:*:*): Guess m68k-unknown-linux and
+	m68k-unknown-linuxaout from linker help string.  Put quotes around
+	$ld_help_string.
+
+Thu Dec  7 09:03:24 1995  Tom Horsley  <Tom.Horsley@mail.hcsc.com>
+
+	* config.guess (powerpc-harris-powerunix): Add guess for port
+	to new target.
+
+Thu Feb  8 15:37:52 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* config.guess (UNAME_VERSION): Recognize X4.x as an OSF version.
+
+Mon Feb  5 16:36:51 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: If --enable-shared was used, set SET_LIB_PATH to
+	$(REALLY_SET_LIB_PATH) in Makefile.
+	* Makefile.in (SET_LIB_PATH): New variable.
+	(REALLY_SET_LIB_PATH): New variable.
+	($(DO_X)): Use $(SET_LIB_PATH).
+	(install.all, gcc-no-fixedincludes, $(ALL_MODULES)): Likewise.
+	($(NATIVE_CHECK_MODULES), $(CROSS_CHECK_MODULES)): Likewise.
+	($(INSTALL_MODULES), $(CONFIGURE_TARGET_MODULES)): Likewise.
+	($(ALL_TARGET_MODULES), $(CHECK_TARGET_MODULES)): Likewise.
+	($(INSTALL_TARGET_MODULES), $(ALL_X11_MODULES)): Likewise.
+	($(CHECK_X11_MODULES), $(INSTALL_X11_MODULES)): Likewise.
+	(all-gcc, all-bootstrap, check-gcc, install-gcc): Likewise.
+	(install-dosrel): Likewise.
+	(all-opcodes): Depend upon all-libiberty.
+
+Sun Feb  4 16:51:11 1996  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* config.guess (*:CYGWIN*): New
+
+Sat Feb  3 10:42:35 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (all-target-winsup): All all-target-libiberty.
+
+Fri Feb  2 17:58:56 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (noconfigdirs): Add missing # in front of comment.
+
+Thu Feb  1 14:38:13 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: add second pass to things added to noconfigdirs
+	so *-gm-magic can exclude libgloss properly.
+
+Thu Feb  1 11:10:16 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure (extralibs_name, rez_name): Set correctly
+	for MWC68K compiler.
+
+	* mpw-README: Add more info on the necessary build tools.
+
+Thu Feb  1 10:22:38 1996  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in, config.sub: Recognize cygwin32.
+
+Wed Jan 31 14:17:10 1996  Richard Henderson  <rth@tamu.edu>
+
+	* config.guess, config.sub: Recognize A/UX.
+
+Wed Jan 31 13:52:14 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with gcc/config.sub.
+
+Thu Jan 25 11:01:10 1996  Raymond Jou  <rjou@mexican.cygnus.com>
+
+	* mpw-build.in (do-binutils): Add build of stamps.
+
+Thu Jan 25 17:05:26 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* config.sub: Add recognition for mips64vr4100*-* targets.
+
+Wed Jan 24 12:47:55 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* test-build.mk: Add checking of `hpux9' rather than just `hpux'.
+	Add creation of gconfigargs with `--enable-shared' turned on.
+	($(host)-stamp-stage2-configured): Pass $(gconfigargs).
+	($(host)-stamp-stage3-configured): Likewise.
+	(HOLES): Add chatr and ldd.
+	(i386-ncr-sysv4.3*): Add use of /usr/ccs/bin in the PATH and HOLE_DIRS.
+
+Wed Jan 24 20:32:30 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* configure: Pass --nfp to recursive configures.
+
+Mon Jan 22 10:41:56 1996  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* Makefile.in (DLLTOOL): New.
+	(DLLTOOL_FOR_TARGET): New.
+	(EXTRA_HOST_FLAGS): Pass down DLLTOOL.
+	(EXTRA_TARGET_FLAGS): Ditto.
+	(EXTRA_GCC_FLAGS): Ditto.
+	(CONFIGURE_TARGET_MODULES): Ditto.
+	(DO_X): Ditto.
+	* configure: Add DLLTOOL.
+
+Fri Jan 19 13:30:15 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	SCO OpenServer 5 changes from Robert Lipe <robertl@dgii.com>:
+	* configure.in (i[345]86-*-sco3.2v5*): Use mh-sysv instead of
+	mh-sco, since old workarounds no longer needed, and don't
+	build ld, since libraries have weak symbols in COFF.
+
+Sun Jan 14 23:01:31 1996  Fred Fish  <fnf@cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Add missing ';'.
+
+Fri Jan 12 15:25:35 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Make sure that ${CC} can be used to compile an
+	executable.
+
+Sat Jan  6 07:23:33 1996  Michael Meissner  <meissner@wogglebug.tiac.net>
+
+	* Makefile.in (all-gdb): Depend on $(GDB_TK).
+	* configure (GDB_TK): Set GDB_TK to either "all-tcl all-tk" or
+	nothing depending on whether gdbtk is being built.
+
+Wed Jan  3 17:54:41 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (newlib.tar.gz): Delete building of newlib's info files.
+
+Mon Jan  1 19:09:14 1996  Brendan Kehoe  <brendan@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Put ld or gas in this early, if the
+	user specifically used --with-gnu-ld=no or --with-gnu-as=no.
+
+Sat Dec 30 16:08:57 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config-ml.in: Add support for
+	--disable-{softfloat,m68881,m68000,m68020} on m68*-*-*.
+	Simplify setting of multidirs from --disable-foo.
+
+Fri Dec 29 07:56:11 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): If any of the make variables
+	LANGUAGES, BOOT_CFLAGS, STMP_FIXPROTO, LIMITS_H_TEST,
+	LIBGCC1_TEST, LIBGCC2_CFLAGS, LIBGCC2_INCLUDES, and ENQUIRE are
+	non-empty, pass them on to the	GCC make.
+	(all-bootstrap): New rule that is like all-gcc, except it executes
+	the GCC bootstrap rule instead of the GCC all rule.
+
+Wed Dec 27 15:51:48 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config-ml.in (ml_realsrcdir): New, to account for ${subdir}.
+
+Tue Dec 26 11:45:31 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.guess (AViiON:dgux:*:*): Update from FSF to add pentium
+	DG/UX support.
+
+Fri Dec 15 10:01:27 1995  Stan Cox  <coxs@dg-rtp.dg.com>
+
+	* config.sub (i*86*) Change [345] to [3456]
+
+Wed Dec 20 17:41:40 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in (noconfigdirs): Add gas or ld if --with-gnu-as=no or
+	--with-gnu-ld=no.
+
+Wed Dec 20 15:15:35 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config-ml.in (rs6000*, powerpc*): Add switches to control which
+	AIX multilibs get built.
+
+Mon Dec 18 17:55:46 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (i386-win32): Don't build expect if we're not
+	building the tcl subdir.
+
+Mon Dec 18 11:47:19 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* Makefile.in: (configure-target-examples, all-target-examples):
+	New targets, configure and build example programs.
+
+Fri Dec 15 16:13:03 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: If an mpw-config.in generated a file mk.sed,
+	use it as input to sedit the generated MPW makefile.
+	* mpw-README: Add a suggestion about Gestalt.h.
+
+Wed Dec 13 16:43:51 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Accept *-*-ieee*.
+
+Tue Dec 12 11:52:57 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (local-distclean): Remove $(TARGET_SUBDIR).  From
+	Ronald F. Guilmette <rfg@monkeys.com>.
+
+Mon Dec 11 15:31:58 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (host==powerpc-pe): Add many directories to noconfigdirs
+	for powerpc-pe native.
+	(target==i386-win32): add tcl, make to noconfigdirs if canadian cross.
+	(target==powerpc-pe): duplicate i386-win32 entry.
+
+Sat Dec  9 14:58:28 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* configure.in (noconfigdirs): Exclude target-newlib for all versions
+	of vxworks, not just vxworks5.1.
+
+Mon Dec  4 12:05:40 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Add support for exec-prefix.
+
+Mon Dec  4 10:22:50 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* config.guess: Recognize HP model 816 machines as having
+	a PA1.1 processor.
+
+Mon Dec  4 12:38:15 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Ignore new autoconf configure options.
+
+Thu Nov 30 16:57:33 1995  Per Bothner  <bothner@wombat.gnu.ai.mit.edu>
+
+	* config.guess:  Recognize Pentium under SCO.
+	From Robert Lipe <robertl@arnet.com>.
+
+Wed Nov 29 13:49:08 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable target-libio on v810-*-*.
+
+Wed Nov 29 12:12:01 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure gas for alpha-dec-osf*.
+
+Tue Nov 28 17:16:48 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Default to --with-stabs for some targets for which
+	it makes sense: mips*-*-*, alpha*-*-osf*, i[345]86*-*-sysv4* and
+	i[345]86*-*-unixware*.
+
+Mon Nov 27 13:44:15 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config-ml.in: Get list of multidirs using gcc --print-multi-lib
+	rather than basing it on the target.  Simplify handling of options
+	controlling which directories to configure.  Remove extraneous
+	slash in multi-clean target.
+
+Fri Nov 24 17:29:29 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* config-ml.in: Prefix more variables with ml_ so they don't collide
+	with configure's.
+
+Wed Nov 22 11:27:02 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Don't turn -v into --v.
+
+Tue Nov 21 16:48:02 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* configure.in (targargs): Fix typo.
+
+	* Makefile.in (DEVO_SUPPORT): Add symlink-tree.
+
+Tue Nov 21 14:08:28 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Strip --host and --target options from
+	CONFIG_ARGUMENTS, and always configure for --host only.  Add
+	--with-cross-host option when building with a cross-compiler.
+	* configure: Canonicalize the arguments put into config.status by
+	always using `=' for an option with an argument.  Pass a presumed
+	--host or --target explicitly.
+
+Fri Nov 17 17:50:30 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* config.sub: Merge -macos*, -magic*, -pe*, and -win32 cases
+	into general OS recognition case.
+
+Fri Nov 17 17:42:25 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (target_configdirs): add target-winsup only
+	for win32 target systems.
+
+Thu Nov 16 14:04:47 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (all-target-libgloss): Depend upon
+	configure-target-newlib, since when libgloss is built it looks to
+	see if the newlib directory exists.
+
+Wed Nov 15 14:47:52 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Use config-ml.in instead of
+	cfg-ml-*.in.
+
+Wed Nov 15 11:45:23 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Handle LD and LD_FOR_TARGET when configuring a
+	Canadian Cross.
+
+Tue Nov 14 14:56:11 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (target_libs): add target-winsup.
+	(target==i386-win32): add patch diff flex make to $noconfigdirs.
+	(target==ppcle-pe): remove ld from $noconfigdirs.
+
+Tue Nov 14 01:25:50 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Pass --with-target-subdir.
+	Preserve relative path names in $srcdir.  Build symlink tree if
+	configuring cross target dir and srcdir=. (= no VPATH support).
+	(configure-target-libg++): Depend on configure-target-librx.
+	* cfg-ml-com.in, cfg-ml-pos.in: Deleted.
+	* config-ml.in: New file.
+	* symlink-tree: New file.
+	* configure: Ensure srcdir="." if that's what it is.
+
+Mon Nov 13 12:34:20 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-README: Clarify some phrasing, add notes about CodeWarrior
+	includes and FLEX_SKELETON setting.
+	* mpw-configure (--with-gnu-ld): New option, controls whether
+	to use PPCLink or ld with PowerMac GCC.
+	* mpw-build.in (all-grez, do-grez, install-grez): New targets.
+	* mpw-config.in: Configure grez if targeting Mac.
+
+	* config.sub: Accept pmac and pmac-mpw as names for PowerMacs,
+	accept mpw and mac-mpw as names for m68k Macs, change macos7 to
+	just macos.
+	* configure.in: Configure grez resource compiler if targeting Mac.
+	* Makefile.in (all-grez, install-grez): New targets.
+
+Wed Nov  8 17:33:51 1995  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* configure: CXX defaults to gcc, not g++.  If we find
+	gcc in the path, set CC to gcc -O2.
+
+Tue Nov  7 15:45:17 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Default ${build} correctly.  Avoid picking up extra
+	spaces when reading CC and CXX from Makefile.  When doing a
+	Canadian Cross, use plausible default values for numerous
+	variables.
+	* configure.in: When doing a Canadian Cross, don't try to
+	configure tools whose configure script can't handle it.
+
+Mon Nov  6 19:32:17 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* cfg-ml-com.in (sh-*-*): Add m2 and ml/m2 to multidirs.
+
+Sun Nov  5 00:15:41 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure:  Remove dubious bug reporting address.
+
+Fri Nov  3 08:17:54 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)):  If subdir has
+	configure script, run that instead of this directory's configure.
+	In either case, print a message that we're configuring the sub-dir.
+
+Thu Nov  2 23:23:36 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in: Before checking for the existence of various files,
+	use sed to filter out "target-".
+
+Thu Nov  2 13:24:56 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DO_X): Split rule to decrease command line length
+	for systems with small ARG_MAX values.  From phdm@info.ucl.ac.be
+	(Philippe De Muyter).
+
+Wed Nov  1 15:18:35 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (all-patch): depend on all-libiberty.
+
+Wed Nov  1 12:23:20 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: If the only directory in target_configdirs which
+	actually exists is libiberty, then set target_configdirs to empty,
+	to avoid trying to build a target libiberty in a gas or gdb
+	distribution.
+
+Tue Oct 31 17:52:39 1995  J.T. Conklin  <jtc@slave.cygnus.com>
+
+	* configure.in (host_makefile_frag): Use m68k-sun-sunos* instead
+	of m68k-sun-* when selecting mh-sun3 to avoid matching NetBSD/sun3
+	systems.
+
+Tue Oct 31 16:57:32 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* configure.in (copy_dirs): Use sys-include instead of include
+	for --with-headers option.
+
+Tue Oct 31 10:29:36 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* Makefile.in, configure.in: Make winsup builds work with
+	new scheme.
+
+Mon Oct 30 18:57:09 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Build the linker on AIX.
+
+Mon Oct 30 12:27:16 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET, CXX_FOR_TARGET):  Add $(TARGET_SUBDIR)
+	where needed.
+
+Mon Oct 30 12:45:25 1995  Doug Evans  <dje@cygnus.com>
+
+	* Makefile.in (all-gcc): Fix typo.
+
+Sat Oct 28 10:27:59 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in ($(CHECK_TARGET_MODULES)):  Fix typo.
+
+Fri Oct 27 23:14:12 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in:  Rename libFOO to target-libFOO, and xiberty
+	to target-xiberty, to provide more flexibility.
+	(target_subdir):  Define.  Create if cross.
+	Set TARGET_SUBDIR in Makefile to ${target_subdir}.
+	* Makefile.in:  Rename all-libFOO -> all-target-libFOO, all-xiberty
+	-> all-target-libiberty, configure-libFOO -> configure-target-libFOO,
+	check-libFOO -> check-target-libFOO, etc.
+	($(DO_X)):  Iterate over TARGET_CONFIGDIRS after SUBDIRS.
+	($(CONFIGURE_TARGET_MODULES), $(CHECK_TARGET_MODULES),
+	$(ALL_TARGET_MODULES), $(INSTALL_TARGET_MODULES)): Update accordingly.
+	(configure-target-XXX):  Depend on $(ALL_GCC), not all-gcc, to
+	allow ALL_GCC="" to only configure.
+	(DEVO_SUPPORT):  Add cfg-ml-com.in and cfg-ml-pos.in.
+	(ETC_SUPPORT, ETC_SUPPORT_PFX):  Merge;  update 'taz' accordingly.
+	(LIBGXX_SUPPORT_DIRS):  Remove xiberty.
+
+Sat Oct 28 01:53:49 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (taz): Build "info" in etc explicitly.
+
+Fri Oct 27 09:32:30 1995  Stu Grossman  (grossman@cygnus.com)
+
+	* configure.in:  Make sure that CC is undefined (as opposed to
+	null) if toplevel/config/mh-{host} doesn't define it.  Fixes a
+	problem with autoconf trying to configure on a host without GCC.
+
+Thu Oct 26 22:35:01 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Set host alias from choice of host compiler,
+	only use generic MPW Makefile sed if present, edit a file
+	named "hacked_Makefile.in" instead of "Makefile.in" if present.
+	* mpw-README: Add problem notes about CW6 and CW7.
+
+Thu Oct 26 05:45:10 1995  Ken Raeburn  <raeburn@kr-pc.cygnus.com>
+
+	* Makefile.in (taz): Use ";" instead of ";;".
+
+Wed Oct 25 15:18:24 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (taz):  Grep for '^diststuff:' or '^info:' in
+	sub-directory Makefiles, instead of using DISTSTUFFDIRS and
+	DISTDOCDIRS.
+	(DISTSTUFFDIRS, DISTDOCDIRS):  Removed - no longer used.
+	(newlib.tar.gz):  Don't pass DISTDOCDIRS to recursive make.
+
+Wed Oct 25 14:43:55 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (DISTDOCDIRS):  Remove ld gprof bnutils gas libg++ gdb
+	and gnats, because they are now subsumed by DISTSTUFFDIRS.
+	Move bfd to DISTSTUFFDIRS.
+
+Tue Oct 24 18:19:09 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (X11_LIB): Removed.
+	(X11_FLAGS_TO_PASS): pass only X11_EXTRA_CFLAGS and X11_EXTRA_LIBS.
+
+	* configure.in (host_makefile_frag): mh-aix & mh-sun removed.
+
+Sun Oct 22 13:04:42 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*): Shorten some of the multilib directory
+	names.
+
+Fri Oct 20 18:02:10 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*-eabi*): Add mcall-aixdesc varients.
+
+Thu Oct 19 10:40:57 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in (i[345]86-*-win32): Always build newlib.
+	Don't configure cvs, autoconf or texinfo.
+	* Makefile.in (LD_FOR_TARGET): New.
+	(BASE_FLAGS_TO_PASS, EXTRA_TARGET_FLAGS, CONFIGURE_TARGET_MODULES):
+	Pass down LD_FOR_TARGET.
+
+Wed Oct 18 15:53:56 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* winsup: New directory.
+	* Makefile.in: Build winsup.
+	* configure.in: Winsup is configured when target is win32.
+	Can only build win32 target GDB when native.
+
+Mon Oct 16 09:42:31 1995  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Recognize HP model 819 machines as having
+	a PA 1.1 processor.
+
+Mon Oct 16 10:49:43 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Fix sed loop which substitutes for CC and CXX to
+	avoid bug found in various sed implementations.
+
+Wed Oct 11 16:16:20 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc-*-eabisim): Delete separate rule for
+	simulator.  Use standard powerpc-*-eabi*.
+
+Mon Oct  9 17:21:56 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Stop putting gas and binutils in noconfigdirs for
+	powerpc-*-aix* and rs6000-*-*.
+
+Mon Oct  9 12:38:40 1995  Michael Meissner  <meissner@cygnus.com>
+
+	* cfg-ml-com.in (powerpc*-*-eabisim*): Add support for building
+	-mcall-aixdesc libraries.
+
+Fri Oct  6 16:17:57 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	Mon Sep 25 22:49:32 1995  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* config.sub (arm | armel | armeb): Fix shell syntax.
+
+Fri Oct  6 14:40:28 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in ({powerpc,rs6000}-ibm-aix*): Add multilibs for
+	-msoft-float and -mcpu=common support.
+	(powerpc*-*-eabisim*): Add support for building -mcall-aix
+	libraries.
+
+Thu Oct  5 13:26:37 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: Allow configuration and build of emacs19 for the alpha.
+
+Wed Oct  4 22:05:36 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (CC): Get ^CC, not just any old CC, from
+	${host_makefile_frag}.
+
+Wed Oct  4 21:55:00 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (CC): Try to get CC from
+	${srcdir}/${host_makefile_frag}, not ${host_makefile_frag}.
+
+Wed Oct  4 21:44:12 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS): configure targetdirs
+	only if it exists in $(srcdir).
+
+Wed Oct  4 11:52:31 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If CC and CXX are not set in the environment, set
+	them, based on either an existing Makefile or on searching for gcc
+	in PATH.  Substitute for CC and CXX in Makefile.
+	* configure.in: Remove libm from target_libs.  Separate
+	target_configdirs from configdirs.  If CC is not set in
+	environment, try to get it from a host Makefile fragment.  Rewrite
+	changes of configdirs to use skipdirs instead.  A few minor
+	tweaks.  Take directories out of target_configdirs as they are
+	taken out of configdirs.  Remove existing Makefile files from
+	subdirectories.  Substitute for TARGET_CONFIGDIRS and
+	CONFIG_ARGUMENTS in Makefile.
+	* Makefile.in (TARGET_CONFIGDIRS): New variable, automatically set
+	by configure.in.
+	(CONFIG_ARGUMENTS): Likewise.
+	(CONFIGURE_TARGET_MODULES): New variable.
+	($(DO_X)): Loop over TARGET_CONFIGDIRS as well as SUBDIRS.
+	($(CONFIGURE_TARGET_MODULES)): New target.
+	(configure-libg++, configure-libio): New targets.
+	(all-libg++): Depend upon configure-libg++.
+	(all-libio): Depend upon configure-libio.
+	(configure-libgloss, all-libgloss): New targets.
+	(configure-libstdc++): New target.
+	(all-libstdc++): Depend upon configure-libstdc++.
+	(configure-librx, all-librx): New targets.
+	(configure-newlib): New target.
+	(all-newlib): Depend upon configure-newlib
+	(configure-xiberty): New target.
+	(all-xiberty): Depend upon configure-xiberty.
+
+Sat Sep 30 04:32:59 1995  Jason Molenda (crash@phydeaux.cygnus.com)
+
+	* configure.in (host i[345]86-*-win32):  Expand the
+	noconfigdirs again.
+
+Thu Sep 28 21:18:49 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Fix sed command file name.
+
+Thu Sep 28 17:39:56 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in (host i[345]86-*-win32): Reduce the
+	noconfigdirs again.
+
+Wed Sep 27 12:24:00 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure ld and gdb for powerpc*-*-winnt*
+	or powerpc*-*-pe*, since they are not yet supported.
+
+Tue Sep 26 14:30:01 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	Add PowerMac support and many other enhancements.
+	* mpw-configure: New option --cc to select compiler to use,
+	paste options set according to --cc into the generated
+	Makefile, generate the Makefile by sed'ing the Unix Makefile.in
+	if mpw-make.sed is present.
+	* mpw-config.in: Don't test for gC1, test for mpw-touch,
+	add forward includes for PowerPC include files.
+	* mpw-build.in: Build using Makefile.PPC if present.
+	(do-byacc, etc): Remove separate version resource builds.
+	(do-gas): Build "stamps" before "all".
+	(do-gcc): Build "stamps-h" and "stamps-c" before "all".
+	* mpw-README: Update to reflect --cc option, PowerMac support,
+	and recently-reported compatibility problems.
+
+Fri Sep 22 12:15:42 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* cfg-ml-com.in (m68*-*-*): Only build multilibs for
+	embedded m68k systems (-aout, -coff, -elf, -vxworks).
+	(--with-multilib-top): Pass to recursive invocations.
+
+Tue Sep 19 13:51:05 1995  J.T. Conklin  <jtc@blues.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable libg++ and libstdc++ on
+	v810-*-*.
+
+Mon Sep 18 23:08:26 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable bfd, binutils, gas, gcc,
+	gdb, ld and opcodes on v810-*-*.
+
+Tue Sep 12 18:03:31 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DO_X): Change do-realclean to do-maintainer-clean.
+	(local-maintainer-clean): New target.
+	(maintainer-clean): New target.
+	(realclean): Just depend upon maintainer-clean.
+
+Fri Sep  8 17:11:14 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable gdb on m68k-*-netbsd*.
+
+Fri Sep  8 16:46:29 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Build ld in mips*-*-bsd* case.
+
+Thu Sep  7 20:03:41 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* config.sub: Accept -lites* OS.  From Ian Dall.
+
+Fri Sep  1 08:06:58 1995  James G. Smith  <jsmith@beauty.cygnus.com>
+
+	* config.sub: recognise mips64vr4300 and mips64vr4300el as valid
+	targets.
+
+Wed Aug 30 21:06:50 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in: treat i386-win32 canadian cross the same as
+	i386-go32 canadian cross.
+
+Thu Aug 24 14:53:20 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*-*-eabisim): Add support for PowerPC
+	running under the simulator to build a reduced set of libraries.
+	(powerpc-*-eabiaix): Add fine grained multilib support added to
+	other powerpc targets yesterday.
+
+Wed Aug 23 09:41:56 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*): Add support for -disable-biendian,
+	-disable-softfloat, -disable-relocatable, -disable-aix, and
+	-disable-sysv to control which multilib libraries get built.
+
+Thu Aug 17 16:03:41 1995  Ken Raeburn  <raeburn@kr-laptop.cygnus.com>
+
+	* configure: Add Makefile.tem to list of files to remove in trap
+	handler.
+
+Mon Aug 14 19:27:56 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess (*Linux*):  Add missing "exit"s.
+	Also, need specific check for alpha-unknown-linux (uses COFF).
+
+Fri Aug 11 15:38:20 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Merge with FSF:
+
+	Wed Jun 28 17:57:27 1995  David Edelsohn  <edelsohn@mhpcc.edu>
+	* config.guess (AIX4): More robust release numbering discovery.
+
+	Thu Jun 22 19:01:24 1995  Kenneth Stailey  (kstailey@eagle.dol-esa.gov)
+	* config.guess (i386-sequent-ptx): Properly get version number.
+
+	Thu Jun 22 18:36:42 1995  Uwe Seimet  (seimet@iris1.chemie.uni-kl.de)
+	* config.guess (mips:*:4*:UMIPS): New case.
+
+Mon Aug  7 09:21:35 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in (i386-go32 host): Fix typo (deja-gnu -> dejagnu).
+	(i386-win32 host): Likewise.  Don't build readline.
+
+Sat Aug  5 09:51:49 1995  Fred Fish  <fnf@rtl.cygnus.com>
+
+	* Makefile.in (GDBTK_SUPPORT_DIRS):  Define and pass as part of
+	SUPPORT_FILES to submakes.
+
+Fri Aug  4 13:04:36 1995  Fred Fish  <fnf@cygnus.com>
+
+	* Makefile.in (GDB_SUPPORT_DIRS): Add utils.
+	(DEVO_SUPPORT): Add mpw-README, mpw-build.in, mpw-config.h and
+	mpw-configure.
+
+Wed Aug  2 16:32:40 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* configure.in (appdirs): Use =, not ==, in test expression when
+	trying to build the text to print in the warning message for
+	Solaris users.
+
+Mon Jul 31 09:56:18 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* cfg-ml-com.in (z8k-*-coff): Add 'std' multilib build.
+
+Fri Jul 28 00:16:31 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* config.guess: Recognize lynx-2.3.
+
+Thu Jul 27 15:47:59 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* config.sub (z8ksim): Deleted
+	(z8k-*-coff): New, this is the one true name of the target.
+
+Thu Jul 27 14:33:33 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* cfg-ml-pos.in (dotdot): Work around SunOS sed bug.
+
+Thu Jul 27 13:31:05 1995  Fred Fish  (fnf@cygnus.com)
+
+	* config.guess (*:Linux:*:*): First try asking the linker what the
+	default object file format is (elf, aout, or coff).  Then if this
+	fails, try previous methods.
+
+Thu Jul 27 11:28:17 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in: Don't build newlib for *-*-vxworks5.1.
+
+Thu Jul 27 11:18:47 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: Don't build newlib for a29k-*-vxworks5.1.
+	* test-build.mk: Add setting of --with-headers for a29k-vxworks5.1.
+
+Tue Jul 25 21:25:39 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* cfg-ml-pos.in (MULTITOP): Trim excess trailing "/.".
+
+Fri Jul 21 10:41:12 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* cfg-ml-com.in: New file.
+	* cfg-ml-pos.in: New file.
+
+Wed Jul 19 00:37:27 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* COPYING.NEWLIB: Add HP free copyright to list.
+
+Tue Jul 18 10:58:51 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.sub: Recognize -eabi* for the system, not just -eabi.
+
+Mon Jul  3 13:44:51 1995  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* Makfile.in (DLLTOOL_FOR_TARGET): New name, pass it down.
+	* config.sub, configure.in (win32): New target and host.
+
+Wed Jun 28 23:57:08 1995  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in: Add i386-pe configuration.
+
+Fri Jun 23 14:28:44 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-build.in (install): Install GDB after LD.
+
+Thu Jun 22 17:10:53 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-config.in (elf/mips.h): Always forward-include, needed
+	for GDB to build.
+
+Wed Jun 21 15:17:30 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* testsuite: New directory for customer acceptance and whole tool
+	chain tests.
+
+Wed Jun 21 16:50:29 1995  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* configure: If per-host line isn't found, but AC_OUTPUT is found
+	and a configure script exists, run it instead.
+
+Thu Jun 15 21:09:24 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Update from FSF, for alpha-dec-winnt3.5 and  Crays.
+
+Tue Jun 13 21:43:27 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* configure: Set build_{cpu,vendor,os,alias} to host values when
+	--build isn't specified.
+
+Mon Jun  5 18:26:36 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* Makefile.in (PICFLAG, PICFLAG_FOR_TARGET): New macros.
+	(FLAGS_TO_PASS): Pass them.
+	(EXTRA_TARGET_FLAGS): Ditto.
+
+Wed May 31 22:27:42 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* Makefile.in (all-libg++): Depend on all-libstdc++.
+
+Thu May 25 22:40:59 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Enable all packages for
+	  i386-unknown-netbsd.
+
+Sat May 20 13:22:31 1995  Angela Marie Thomas  <angela@cirdan.cygnus.com>
+
+	* configure.in (noconfigdirs): Don't configure tk for i386-go32
+	hosted builds (DOS builds)
+
+Thu May 18 18:08:49 1995  Ken Raeburn  <raeburn@kr-laptop.cygnus.com>
+
+	Changes for ARM based on patches from Richard Earnshaw:
+	* config.sub: Handle armeb and armel.
+	* configure.in: Omit arm linker only for riscix.
+
+Thu May 11 17:23:26 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Update from FSF.
+
+Tue May  9 15:52:05 1995  Michael Meissner  <meissner@cygnus.com>
+
+	* config.sub: Recognize powerpcle as the little endian varient of
+	the PowerPC.  Recgonize ppc as a PowerPC variant, and ppcle as a
+	powerpcle variant.  Convert pentium into i586, not i486.  Add p5
+	alias for i586.  Map new x86 variants p6, k5, nexgen into i586
+	temporarily.
+
+Tue May  2 16:29:41 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* configure.in (hppa*-*-lites*): Treat like hppa*-*-*elf*.
+
+Sun Apr 30 21:38:09 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* config.sub: Accept -lites* as a basic system type.
+
+Thu Apr 27 11:33:29 1995  Michael Meissner  (meissner@cygnus.com)
+
+	* config.guess (*:Linux:*:*): Check for whether the pre-BFD linker is
+	installed, and if so return linuxoldld as the system name.
+
+Wed Apr 26 10:59:02 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* config.guess: Add hppa1.1-hp-lites support.
+
+Tue Apr 25 11:08:11 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* configure.in: Don't build newlib for m68k-vxworks5.1.
+
+Wed Apr 19 17:02:43 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* configure.in (mips-sgi-irix6): Use mh-irix5.
+
+Fri Apr 14 15:21:17 1995  Doug Evans  <dje@chestnut.cygnus.com>
+
+	* Makefile.in (all-gcc): Depend on all-ld (for libgcc1-test).
+
+Wed Apr 12 16:06:01 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* test-build.mk: Enable building of shared libraries on IRIX 5 and
+	OSF/1.  Fix compiler flags.
+	* build-all.mk: Support Linux and OSF/1 3.0.  Fix compiler flags.
+
+Tue Apr 11 18:55:40 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in: Recognize --with-newlib.
+	(sparc-*-sunos4*): Build sim, dejagnu, expect, tcl if cross target.
+
+Mon Apr 10 14:38:20 1995  Jason Molenda (crash@phydeaux.cygnus.com)
+
+	* Makefile.in: move {all,check,install}-gdb from *_MODULES
+	to *_X11_MODULES due to gdbtk needing X include files et al.
+
+Mon Apr 10 11:42:22 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	Merge in support for Mac MPW as a host.
+	(Old change descriptions retained for informational value.)
+
+	* mpw-config.in: Add generic include forwards for cpu-specific
+	include files in aout and elf directories.
+
+	* mpw-configure: Added copyright.
+	* mpw-config.in: Check for presence of required build tools.
+	(target_libs): Add newlib.
+	(target_tools): Add examples.
+	(Read Me): Generate as "Read Me for MPW" instead.
+	* mpw-build.in: Base sub-builds on all-foo instead of do-foo.
+	(all-byacc, do-byacc, all-flex, do-flex, do-newlib): New actions.
+	(do-gas, do-gcc, do-gdb, do-ld): Build Version.r first.
+
+	* mpw-configure: Remove subdir-specific makefile hackery,
+	delete mk.tmp after using it.
+
+	* mpw-build.in (all): Display start and end times.
+
+	* mpw-configure (host_canonical): Set.
+	(target_cpu): Always add to makefiles.
+	(ARCHDEFS, EMUL): Add to makefile only if nonempty.
+	(TM_FILE, XM_FILE, NM_FILE): No longer add to makefile.
+	(mpw-mh-mpw): Look for in srcdir and srcroot.
+	Use sed instead of mpw-edit-prefix to edit prefix definitions.
+
+	* mpw-build.in: (install-only): New target.
+
+	* mpw-configure (host_alias, target_alias): Rename from hostalias
+	and targetalias, add into generated Makefile.
+	(mk.tmp): If present, add into generated Makefile.
+	* mpw-build.in (all-gas): Build config.h first before gas proper.
+
+	* mpw-configure (config.status): Write only if changed.
+	* mpw-config.in (readline): Configure it (not built, just used for
+	definitions).
+
+	* mpw-config.in (elf/mips.h): Add a forward include.
+
+	* mpw-config.in: Forward-include most .h files in include into
+	extra-include.
+	(readline): Don't build.
+	mpw-build.in (install): Install GDB.
+
+	* mpw-configure (prefix, mpw_prefix): Handle it.
+	* mpw-config.in (mmalloc, readline): Don't configure.
+	* mpw-build.in (thisscript): Rename to ThisScript.
+	Use mpw-build instead of BuildProgram everywhere.
+	(mmalloc, readline): Don't build.
+	* mpw-README: New file, basic documentation about the MPW port.
+
+	* mpw-config.in: Use forward-include to create include files.
+
+	* mpw-configure: Add more things to the top of each configured
+	Makefile, including contents of config/mpw-mh-mpw.
+	* mpw-config.in (extra-include): Create this directory and fill it
+	with Posix-like include files when configuring.
+
+	* config.sub (apple, mac, mpw): Add various aliases.
+
+	* mpw-build.in: New file, top-level build script fragment for MPW.
+	* mpw-configure: New file, configure script for MPW.
+	* mpw-config.in: New file, config fragment for MPW.
+
+Fri Apr  7 19:33:16 1995  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in (host_libs): Remove glob, since it is gone from the
+	sources.
+
+Fri Mar 31 11:36:17 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in: define empty GDB_NLM_DEPS var.
+
+	* configure.in(target_makefile_frag): use config/mt-netware
+	for netware targets.
+
+Thu Mar 30 13:51:43 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge in recent FSF changes.  Remove linux special
+	cases.
+
+Tue Mar 28 14:47:34 1995  Jason Molenda (crash@phydeaux.cygnus.com)
+
+	Revert this change:
+
+	Tue Mar 30 10:03:09 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+		* build-all.mk: Use CC=cc -Xs on Solaris.
+
+Tue Mar 21 10:43:32 1995  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* glob/*: Removed.  Schauer's 24 Feb 1994 readline change made us
+	stop using it.
+	* Makefile.in: Nuke all references to glob subdirectory.
+
+Thu Mar 16 13:35:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* configure.in: Fix --enable-shared logic in per-host.
+
+Mon Mar 13 12:33:15 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in (*-hp-hpux[78]*): Use mh-hpux8.
+
+Mon Mar  6 10:21:58 1995  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in (noconfigdirs): Don't build gas on AIX, for
+	powerpc*-*-aix* as well as for rs6000*-*-aix*.
+
+Wed Mar  1 12:51:53 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Fix --cache-file to work if the file argument is a
+	relative path.
+
+Tue Feb 28 17:36:07 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If the --cache-file is used, pass it down to
+	configure in subdirectories.
+
+Mon Feb 27 12:52:46 1995  Kung Hsu  <kung@mexican.cygnus.com>
+
+	* config.sub: add vxworks29k configuration.
+
+Fri Feb 10 16:12:26 1995  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (taz): Do "diststuff" part quietly.
+
+Sun Feb  5 14:16:35 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: Mini-merge with gcc/config.sub.
+
+Sat Feb  4 12:11:35 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* config.guess (IRIX): Sed - to _.
+
+Fri Feb  3 11:54:42 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* Makefile.in (source-vault, binary-vault): New targets.
+
+Thu Jan 26 13:00:11 1995  Michael Meissner  <meissner@cygnus.com>
+
+	* config.sub: Recognize -eabi as a basic system type.
+
+Thu Jan 12 13:13:23 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* configure.in (enable_shared stuff): Fix typo.
+
+Thu Jan 12 01:36:51 1995  deanm@medulla.LABS.TEK.COM (Dean Messing)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Fix typo in passing LIBCXXFLAGS*.
+
+Wed Jan 11 16:29:53 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* Makefile.in (LIBCXXFLAGS_FOR_TARGET): Add -fno-implicit-templates.
+
+Mon Jan  9 12:48:01 1995  Jim Kingdon  <kingdon@lioth.cygnus.com>
+
+	* configure.in (rs6000-*-*): Don't build gas.
+
+Wed Jan  4 23:53:49 1995  Ian Lance Taylor  <ian@tweedledumb.cygnus.com>
+
+	* Makefile.in: Use /x/x/ instead of /brokensed/brokensed/, to
+	reduce command line length.
+	(AS_FOR_TARGET): Check for as.new, not Makefile.
+	(NM_FOR_TARGET): Check for nm.new, not Makefile.
+
+Wed Jan  4 13:02:39 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Merge from FSF.
+
+Thu Dec 15 17:11:37 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* configure: Don't use $ when handling program_suffix.
+
+Mon Dec 12 12:09:37 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* configure.in:  Configure tk for hppa/hpux.
+
+Fri Dec  2 15:55:38 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (LIBGXX_SUPPORT_DIRS):  Add libstdc++.
+
+Tue Nov 29 19:37:56 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in:  Move -fno-implicit-template from CXXFLAGS
+	to LIBCXXFLAGS.  Tests are better run without it.
+
+Wed Nov 23 10:29:25 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* Makefile.in (all-ispell): Depend on all-emacs19 instead of all-emacs.
+
+Mon Nov 21 11:14:01 1994  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (*-*-netware*): Don't configure xiberty.
+
+Mon Nov 14 08:49:15 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* configure.in:  Remove tk from native_only list.
+
+Fri Nov 11 15:31:26 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* build-all.mk: Add mips-ncd-elf target to sun4 targets
+	  for special NCD build.
+
+Mon Nov  7 20:58:17 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Remove configure.bat and
+	makeall.bat, they're only useful for binutils snapshots.
+	(binutils.tar.gz, gas+binutils.tar.gz): Add configure.bat and
+	makeall.bat to specified SUPPORT_FILES.
+
+Mon Nov  7 17:25:18 1994  Bill Cox  (bill@cirdan.cygnus.com)
+
+	* build-all.mk: Add Ericsson targets to sun4 and solaris
+	  hosts.  Add  BNR's sun4 target to solaris host, so their
+	  build-from-source will be tested in-house first.
+
+Sat Nov  5 18:43:30 1994  Jason Merrill  (jason@phydeaux.cygnus.com)
+
+	* Makefile.in (LIBCFLAGS): New variable.
+	(CFLAGS_FOR_TARGET): Ditto.
+	(LIBCFLAGS_FOR_TARGET): Ditto.
+	(LIBCXXFLAGS): Ditto.
+	(CXXFLAGS_FOR_TARGET): Ditto.
+	(LIBCXXFLAGS_FOR_TARGET): Ditto.
+	(BASE_FLAGS_TO_PASS): Pass them.
+	(EXTRA_TARGET_FLAGS): Ditto.
+
+	* configure.in: Support --enable-shared.
+
+Sat Nov  5 15:44:00 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in (target_libs):  Include libstdc++ again.
+	* config.guess:  Update from FSF (for FreeBSD).
+
+Thu Nov  3 16:32:30 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Include configure.bat and
+	makeall.bat.
+	(DISTDOCDIRS): Add `etc'.
+	(ETC_SUPPORT_PFX): New variable.
+	(taz): Include anything from etc starting with a word in
+	ETC_SUPPORT_PFX.
+
+Wed Oct 26 16:19:35 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* config.sub: Update for recent FSF changes.  Remove obsolete
+	h8300hds entry.  Add -windows* and -osx as basic os.  Minor
+	spacing changes.
+
+Thu Oct 20 18:41:56 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in (target_libs):  Remove libstdc++ for libg++-2.6.1.
+
+	* config.guess:  Merge with FSF.
+	* configure.in:  Match on i?86-ncr-sysv4.3, not i?86-ncr-sysv43.
+
+Thu Oct 20 19:26:56 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* configure: Since the "trap 0" handler will override the exit
+	status on many systems, only use it for "exit 1", and make it set
+	a non-zero exit status; reset it before "exit 0".  Also, check
+	exit status of config.sub, and error out if it failed.
+
+Wed Oct 19 18:49:55 1994  Rob Savoye  (rob@cygnus.com)
+
+	* Makefile.in: (ALL_TARGET_MODULES,INSTALL_TARGET_MODULES) Build
+	and install libgloss.
+
+Tue Oct 18 15:25:24 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* Makefile.in (all-binutils): Depend upon all-byacc.
+
+	* configure.in: Don't build emacs on Irix 5.
+
+Mon Oct 17 16:22:12 1994  J.T. Conklin  (jtc@phishhead.cygnus.com)
+
+	* configure.in (*-*-netware*): Add libio.
+
+Thu Oct 13 15:51:20 1994  Jason Merrill  (jason@phydeaux.cygnus.com)
+
+	* Makefile.in (ALL_TARGET_MODULES): Add libstdc++.
+	(CHECK_TARGET_MODULES): Ditto.
+	(INSTALL_TARGET_MODULES): Ditto.
+	(TARGET_LIBS): Ditto.
+	(all-libstdc++): Note dependencies.
+
+Thu Oct 13 01:43:08 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (BINUTILS_SUPPORT_DIRS): Add gas.
+
+Tue Oct 11 12:12:29 1994  Jason Merrill  (jason@phydeaux.cygnus.com)
+
+	* Makefile.in (CXXFLAGS): Use -fno-implicit-templates instead of
+	-fexternal-templates.
+
+	* configure.in (target_libs): Add libstdc++.
+	(noconfigdirs): Add libstdc++ as appropriate.
+
+Thu Oct  6 18:00:54 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Update from FSF.
+
+Tue Oct  4 12:05:42 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* configure: Use ${config_shell} when running ${configsub}.
+
+Mon Oct  3 14:28:34 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: No longer recognize h8300h.
+
+Mon Oct  3 12:40:54 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* config.sub: Remove extraneous differences between config.sub and
+	gcc/config.sub.
+
+Sat Oct  1 00:23:12 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (DISTSTUFFDIRS): Add gas.
+
+Thu Sep 22 19:04:55 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* COPYING.NEWLIB: New file.
+
+Mon Sep 19 18:25:40 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (HP-UX):  Patch from Harlan Stenn
+	<harlan@landmark.com> to also emit release level.
+
+Wed Sep  7 13:15:25 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* config.guess (sun4*:SunOS:*:*): Change '-JL' to '_JL'.
+
+Tue Sep  6 23:23:18 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Merge nextstep cleanup from FSF.
+
+Mon Sep  5 05:01:30 1994  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure.in (arm-*-*): Don't configure ld for this target.
+
+Thu Sep  1 09:35:00 1994  J.T. Conklin  (jtc@phishhead.cygnus.com)
+
+	* configure.in (*-*-netware): don't configure libg++, libio,
+	  librx, or newlib.
+
+Wed Aug 31 13:52:08 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure.in (alpha-dec-osf*): Use osf*, not osf1*.  Don't
+	configure ld--it works, but it doesn't support shared libraries.
+
+Sun Aug 28 18:13:45 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (*-unknown-freebsd*):  Get rid of possible
+	trailing "(Release)" in version string.
+	Patch from Paul Richards <paul@isl.cf.ac.uk>.
+
+Sat Aug 27 15:00:49 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Fix i486-ncr-sysv43 -> i486-ncr-sysv4.3.
+	Fix type: *-next-neststep -> *-next-nextstep.
+
+	* config.guess:  Merge from FSF:
+
+	Fri Aug 26 18:45:25 1994  Philippe De Muyter (phdm@info.ucl.ac.be)
+
+	* config.guess: Recognize powerpc-ibm-aix3.2.5.
+
+	Wed Apr 20 06:36:32 1994  Philippe De Muyter  (phdm@info.ucl.ac.be)
+
+	* config.guess: Recognize UnixWare 1.1 (UNAME_SYSTEM is SYSTEM_V
+	instead of UNIX_SV for UnixWare 1.0).
+
+Sat Aug 27 01:56:30 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* Makefile.in (all-gdb):  Add dependencies on all-gcc and all-ld
+	to make gdb/nlm/* build after the compiler and linker.
+
+Fri Aug 26 14:30:05 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (netbsd, freebsd, linux):  Accept any machine,
+	not just i[34]86.
+	(m68k-atari-sysv4):  Relocate to match FSF version.
+
+	* config.guess:  More merges from the FSF:
+
+	Add a space before function call or macro invocation.
+
+	Tue May 10 16:53:55 1994  Roland McGrath (roland@churchy.gnu.ai.mit.edu)
+
+	* config.guess: Add trap cmd to remove dummy.c and dummy when
+	interrupted.
+
+	Wed Apr 20 18:07:13 1994  Roland McGrath (roland@churchy.gnu.ai.mit.edu)
+
+	* config.guess (dummy.c): Redirect stderr for `hostinfo' command.
+	(dummy): Redirect stderr from compilation of dummy.c.
+
+	Sat Apr  9 14:59:28 1994  Christian Kranz  (kranz@sent5.uni-duisburg.de)
+
+	* config.guess: Distinguish between NeXTStep 2.1 and 3.x.
+
+Fri Aug 26 13:42:20 1994  Ken Raeburn  (raeburn@kr-laptop.cygnus.com)
+
+	* configure: Accept and ignore --cache*, for compatibility with
+	new autoconf.
+
+Fri Aug 26 13:05:27 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Merge from FSF:
+
+	Thu Aug 25 20:28:51 1994  Richard Stallman  <rms@mole.gnu.ai.mit.edu>
+
+	* config.guess (Pyramid*:OSx*:*:*): New case.
+	(PATH): Add /.attbin at end for finding uname.
+	(dummy.c): Handle i860-alliant-bsd.  Follow whitespace conventions.
+
+	Wed Aug 17 18:21:02 1994  Tor Egge  (tegge@pvv.unit.no)
+
+	* config.guess (M88*:DolphinOS:*:*): New case.
+
+	Thu Aug 11 17:00:13 1994  Stan Cox  (coxs@dg-rtp.dg.com)
+
+	* config.guess (AViiON:dgux:*:*): Use TARGET_BINARY_INTERFACE
+	to select whether to use ELF or COFF.
+
+	Sun Jul 24 16:20:53 1994  Richard Stallman  <rms@mole.gnu.ai.mit.edu>
+
+	* config.guess: Recognize i860-stardent-sysv and i860-unknown-sysv.
+
+	Sun May  1 10:23:10 1994  Richard Stallman  (rms@mole.gnu.ai.mit.edu)
+
+	* config.guess: Guess the OS version for HPUX.
+
+	Tue Mar  1 21:53:03 1994  Karl Heuer  (kwzh@hal.gnu.ai.mit.edu)
+
+	* config.guess (UNAME_VERSION): Recognize aix3.2.4 and aix3.2.5.
+
+Fri Aug 26 11:19:08 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure.in: Recognize --with-headers, --with-libs, and
+	--without-newlib.
+	* Makefile.in (all-xiberty): Depend upon all-ld.
+
+Wed Aug 24 12:36:50 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure.in: Change i[34]86 to i[345]86.
+
+Mon Aug 22 10:58:33 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure (version): A few more tweaks to help message.
+
+Fri Aug 19 12:40:25 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in:  Remove (for now) librx as a host library,
+	now that we're building it for target.
+
+Fri Aug 19 10:49:17 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure: Fix up help message; from karl@owl.hq.ileaf.com
+	(Karl Berry).
+
+Tue Aug 16 16:11:08 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure.in:  Also configure librx.
+
+Mon Aug 15 16:51:45 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in:  Update various rules to reflect that librx
+	is now needed for libg++.
+
+Fri Aug 12 18:07:21 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* config.sub: Accept mips64orion and mips64orionel as a CPU name.
+
+Mon Aug  8 11:36:17 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* configure.in: Configure the examples directory.
+
+Thu Aug  4 16:12:36 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure: Simplify Jun 2 1994 change.
+
+Wed Aug  3 04:58:16 1994  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* change CC to /usr/latest/bin/gcc for lynx host builds, since
+	/bin/gcc isn't good enough to build gcc.
+
+Wed Jul 27 09:07:14 1994  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (GDB_SUPPORT_FILES): Remove
+	(setup-dirs-gdb, gdb.tar.gz, make-gdb.tar.gz):  Remove old rules.
+	(gdb.tar.gz): Add new rule to use standard distribution building
+	mechanism.
+
+Mon Jul 25 11:10:06 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Warn about use of /usr/ucb/cc on Solaris.  From
+	Bill Cox <bill@cygnus.com>.
+
+Sat Jul 23 12:19:46 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Recognize ISC.  Patch from kwzh@gnu.ai.mit.edu.
+
+Fri Jul 22 17:53:59 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* configure:  Search current dir first in .gdbinit.
+
+Fri Jul 22 11:28:30 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Recognize freebsd (merged from gcc config.sub).
+
+Thu Jul 21 14:10:52 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Refer to NeXT's operating system as nextstep.
+
+	* config.sub (case $basic_machine):  Re-order the cases, to match
+	the order in the FSF version (which is mostly alphabethical).
+	Merge in some additions and changes from the FSF.
+
+Sat Jul 16 12:03:08 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* config.guess: Recognize m68k-atari-sysv4 and m88k-harris-csux7.
+	* config.sub: Recognize cxux7.
+	* configure.in: Use mh-cxux for m88k-harris-cxux*.
+
+Mon Jul 11 14:37:39 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Fix typo powerpc -> powerpc-*.
+
+Sat Jul  9 13:03:43 1994  Michael Tiemann  (tiemann@blues.cygnus.com)
+
+	* Makefile.in: `all-emacs19' depends on `all-byacc'.
+
+	* Makefile.in: Add all-emacs19 and install-emacs19 rules (in
+	parallel with all-emacs and install-emacs).  Top-level command
+	`make all-emacs19 CC=gcc' now behaves as `make all-emacs CC=gcc'.
+
+Thu Jun 30 16:53:42 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* test-build.mk ($(host)-stamp-stage2-installed): Remove
+	$(relbindir)/make before doing ``make install'', and use
+	$(GNU_MAKE) while doing it.  Avoids problem on SunOS with
+	installing over running make binary.
+	($(host)-stamp-stage3-installed): Likewise.
+
+Tue Jun 28 13:43:25 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize Mach.
+
+Mon Jun 27 16:41:14 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure: Check ${exec_prefixoption}, not ${exec_prefix}, to
+	see whether --exec-prefix was used.
+
+Sun Jun 26 21:15:54 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* README:  Explicitly mention libg++/README.  (Zoo's idea.)
+
+Tue Jun 21 12:45:55 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Add all-librx target similar to all-libproc.
+
+Wed Jun  8 23:11:55 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* config.guess:  Rearrange tests for Alpha-OSF1 to properly deal
+	with post 1.2 uname bogosity.
+
+Thu Jun  9 00:27:59 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure: Remove temporary files on receipt of a signal.
+
+Tue Jun  7 12:06:24 1994  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: If there is a package_makefile_frag, remove
+	${subdir}/Makefile.tem after copying it in.
+
+Mon Jun  6 21:35:02 1994  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* build_all.mk: support rs6000 lynx identifies itself as
+	rs6000-lynx-lynxos2.2.2.  Also, use /usr/cygnus/progressive/bin/gcc
+	since /bin/gcc is too feeble to compile a modern gcc.
+
+Mon Jun  6 16:06:34 1994  Karen Christiansen (karen@cirdan.cygnus.com)
+
+	* brought devo/test-build.mk update-to-date with progressive/
+	  test-build.mk. Add lynx targets and hppa flag info.
+
+Sat Jun  4 17:23:54 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure.in:  Use mh-ncrsvr43.  Patch from
+	Tom McConnell <tmcconne@sedona.intel.com>.
+
+Fri Jun  3 17:47:24 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (i386-unknown-bsdi):  No longer need to
+	check #if defined(__bsdi__) && defined(__i386__).
+
+Thu Jun  2 18:56:46 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure: Set program_transform_nameoption correctly.
+
+Thu Jun  2 10:57:06 1994  Karen Christiansen (karen@cirdan.cygnus.com)
+
+	* brought build-all.mk update-to-date with progressive build-all.mk,
+	  added new targets and hppa info.
+
+Thu Jun  2 00:12:44 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure: If config.guess result is a prefix of the user
+	specified target, assume a native build and use the user specified
+	target as the host alias.  Remove SunOS patch suffix removal hack.
+	* configure.in: Remove SunOS patch suffix removal hack.
+
+	* Makefile.in (CROSS_CHECK_MODULES): Remove check-flex, since it's
+	in NATIVE_CHECK_MODULES.
+
+Wed Jun  1 10:49:41 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* Makefile.in: Rename HOST_ONLY to NATIVE.
+	* configure: Delete SunOs patch suffix from host_canonical
+	  and build_canonical variables that are prepended to Makefiles.
+	* configure.in: Add comments for easier maintenance.
+
+Tue May 31 19:39:47 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Add all-libproc target similar to all-gui.
+
+Tue May 31 17:16:33 1994  Tom Lord  (lord@cygnus.com)
+
+	* Makefile.in (CHECK_MODULES): split into
+	HOST_ONLY_CHECK_MODULES and CROSS_CHECK_MODULES.
+
+Tue May 31 16:36:36 1994  Paul Eggert  (eggert@twinsun.com)
+
+	* config.guess (i386-unknown-bsdi): New system to guess.
+
+Wed May 25 16:47:10 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Add all-gui target (but not yet build by "all").
+
+Thu May 26 08:53:19 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* config.sub: Move deletion of patch suffix from here...
+	* configure.in: To here, at Ian's suggestion.  The top-
+	  level scripts might need to know of a patch level.
+
+Wed May 25 09:15:54 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* config.sub: Strip off patch suffix so rtl is recognized
+	  as a sunos4.1.3 machine, even though it's been patched.
+
+Fri May 20 08:25:49 1994  Steve Chamberlain  (sac@deneb.cygnus.com)
+
+	* Makefile.in (INSTALL_LAST): Delete.
+	(INSTALL_DOSREL): New.
+
+Thu May 19 17:12:12 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Use ld for i[34]86-*-sysv4* and sparc-*-solaris2*.
+	Don't set use_gnu_ld to no for *-*-sysv4; that only controls
+	whether we pass down --with-gnu-ld anyhow.
+
+Thu May 19 09:29:12 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* Makefile.in (INSTALL_LAST): Change operation so it works
+	on more flavors of make.
+	* configure.in (go32): Don't build libg++ or libio.
+
+Fri May 13 13:28:34 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* Makefile.in (Move HOST_PREFIX_1 and friends up so
+	they can be overriden by templates.
+
+Sat May  7 16:46:44 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* configure.in (target==go32): Don't build gdb.
+	* dosrel: New directory.
+
+Fri May  6 14:19:25 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* configure.in (host==go32): Configure dosrel too.
+	* Makefile.in (INTALL_TARGET): Call INSTALL_LAST last.
+	(HOST_CC, HOST_PREFIX, HOST_PREFIX_1): Undefine, they should
+	be set by incoming names or templates.
+	(INSTALL_LAST): New rule.
+
+Thu May  5 17:35:05 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* config.sub (sparclitefrw, sparclitefrwcompat): Don't set the os.
+
+Thu May  5 20:06:45 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure.in (appdirs): New variable.  Currently empty, but will
+	be used in gas distribution.  If nonempty, lists a set of
+	directories at least one of which must get configured, or top
+	level configuration is considered to have failed.
+	(rs6000-*-lynxos*): Use new file name.
+
+Thu May  5 13:38:36 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	Eliminate XTRAFLAGS.
+	* Makefile.in (CC_FOR_TARGET): If newlib exists, refer to the
+	newlib include files using -idirafter, and also use -nostdinc.
+	(CXX_FOR_TARGET): Likewise.
+	(XTRAFLAGS): Removed.
+	(BASE_FLAGS_TO_PASS): Remove XTRAFLAGS_FOR_TARGET.
+	(EXTRA_HOST_FLAGS): Remove XTRAFLAGS.
+	(EXTRA_TARGET_FLAGS, EXTRA_GCC_FLAGS): Likewise.
+	($(DO_X)): Don't pass down XTRAFLAGS.
+
+Thu May  5 00:16:36 1994  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure.in (mips*-dec-bsd*): New target; do build linker.
+	(mips*-*-bsd*): New target; don't build linker.
+
+Wed May  4 20:10:10 1994  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* configure.in: support rs6000-*-lynxos* configuration.
+	support sunos4 as a cross target.
+
+	* config.sub: look for lynx*, not lynx since the OS version may
+	legitimately be part of the name.
+
+Tue May  3 21:48:11 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure.in (i[34]86-*-sco*): Move to be with other i386
+	targets.
+	(romp-*-*): New target.  Skip various binary utilities.
+	(vax-*-*): New target.  Don't build newlib.
+	(vax-*-vms): Renamed from *-*-vms.  Don't build opcodes or newlib.
+
+Thu Apr 28 15:03:05 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure.in: Only set host_makefile_frag if config
+	directory exists.
+
+Wed Apr 27 12:14:30 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* install.sh: If $dstdir exists, don't check whether each
+	component does.
+
+Tue Apr 26 18:11:33 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* test-build.mk (HOLES): Add sleep; used by rcs/src/conf.sh.
+
+Mon Apr 25 15:06:34 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* configure.in (*-*-lynxos*): Don't configure newlib for either
+	native or cross Lynx.
+
+Sat Apr 16 11:58:16 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub (sparc64-elf): Fix os.
+	(z8k): Remove duplicate.
+
+Thu Apr 14 23:33:17 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* Makefile.in (gcc-no-fixedincludes): Touch gcc/include/fixed, not
+	gcc/stmp-fixproto, to try to prevent fixproto from being run.
+
+Wed Apr 13 15:14:52 1994  Bill Cox  (bill@cygnus.com)
+
+	* configure: Make file links cleanly even if Lynx fails on
+	  an NFS symlink (at least fail cleanly).
+
+Mon Apr 11 10:58:56 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* test-build.mk (CC): For mips-sgi-irix4, change -XNh1500 to
+	-XNh2000.
+
+Sat Apr  9 15:10:45 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Unknown options are fatal again.
+
+Fri Apr  8 12:01:41 1994  David J. Mackenzie  (djm@cygnus.com)
+
+	* configure: Ignore --x-includes and --x-libraries, for Autoconf
+	compatibility.
+
+Thu Apr  7 17:31:43 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* build-all.mk: Add `clean' target.
+
+Wed Apr  6 20:44:56 1994  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* config.guess:  Add SINIX support.
+	* configure.in:  Add mips-*-sysv4* support.
+
+Mon Apr  4 17:41:44 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* build-all.mk: Document all useful targets.
+	If canonhost is sparc-sun-solaris2.3, change it to sparc-sun-solaris2.
+	If canonhost is mips-sgi-irix4.0.5H, change it to mips-sgi-irix4.
+
+Thu Mar 31 04:55:57 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Support --silent, --quiet.
+
+Wed Mar 30 21:37:38 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Support --disable-FEATURE.
+
+Tue Mar 29 19:15:05 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize NCR running SVR4.3.
+
+Mon Mar 28 14:55:15 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Make BSDI generate i386-unknown-bsd386.
+	Patch from Paul Eggert <eggert@twinsun.com>.
+
+Mon Mar 28 12:54:52 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in (powerpc-*-aix*): Treat like rs6000-*-*.
+
+Sat Mar 26 11:25:48 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Make unrecognized options give nonfatal warnings
+	instead of fatal errors, and pass them to any subdirectory
+	configures in case they recognize them.
+	Make --x equivalent to --with-x.
+
+Fri Mar 25 21:52:10 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Add --enable-* options.  Clean up usage message and
+	some comments.
+
+Thu Mar 24 09:12:53 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* Makefile.in (NM_FOR_TARGET): Build tree version is now nm.new.
+
+Sun Mar 20 11:28:22 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* configure.in (hppa*-*-*): Enable binutils.
+
+Sat Mar 19 11:50:16 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.sub: Recognize cisco.
+
+Fri Mar 18 16:42:32 1994  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* Makefile.in (CXXFLAGS): Add -fexternal-templates.
+
+Tue Mar 15 11:25:55 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: about target *-hitachi-hiuxwe2, don't print more
+	than one configuration name.  Add comment.
+
+Sun Mar  6 23:13:38 1994  Hisashi MINAMINO  (minamino@sra.co.jp)
+
+	* config.guess: about target *-hitachi-hiuxwe2, fixed
+	machine guessing order.  [Hitachi's CPU_IS_HP_MC68K
+	macro is incorrect.]
+
+Sun Mar 13 09:10:08 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (TAGS): Just build TAGS in each subdirectory, rather
+	than the "make ls" stuff which used to be here.
+
+Fri Mar 11 12:52:39 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Recognize i[34]86-unknown-freebsd.
+	From Shawn M Carey <smcarey@rodan.syr.edu>.
+
+Thu Mar  3 14:24:21 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure.in (noconfigdirs for alpha): Remove libg++ and libio.
+
+Wed Mar  2 13:28:48 1994  Jim Kingdon  (kingdon@deneb.cygnus.com)
+
+	* config.guess: Check for ptx.
+
+Mon Feb 28 16:46:50 1994  Kung Hsu  (kung@mexican.cygnus.com)
+
+	* config.sub: Add os9k checking.
+
+Thu Feb 24 07:09:04 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* config.guess: Handle OSF1 running on HPPA processors
+
+Fri Feb 18 14:14:00 1994  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure: If subdir configure fails, print out a message with
+	subdirectory name, in case subdir's configure code didn't identify
+	itself.
+
+Fri Feb 18 12:50:15 1994  Doug Evans  (dje@cygnus.com)
+
+	* configure.in: Remove embedded newlines from configdirs.
+	Avoid mismatches of substrings.  Fix matching strings at end
+	of configdirs.
+
+Fri Feb 11 15:33:33 1994  Stu Grossman  (grossman at cygnus.com)
+
+	* config.guess:  Add Lynx/rs6000 config support.
+
+Tue Feb  8 13:41:09 1994  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure.in (alpha-dec-osf1*, alpha*-*-*): Build gas.
+
+Mon Feb  7 15:42:36 1994  Jeffrey A. Law  (law@cygnus.com)
+
+	* configure.in (hppa*-*-osf*): Treat this just like most other
+	PA configurations (eg no binutils or ld).
+	(hppa*-*-*elf*): These configurations have binutils and ld.
+
+Sun Feb  6 16:35:07 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* config.sub (hiux): Fix typo.  From m-kasahr@sramhc.sra.co.JP.
+
+Sat Feb  5 01:00:33 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in (rs6000-*-*): Build gas.
+
+Wed Feb  2 13:57:57 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* Makefile.in:  Avoid bug in losing hpux sed.
+
+Wed Feb  2 14:53:05 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in, test-build.mk: Remove MUNCH_NM; it was only needed
+	for GDB and GDB has been fixed to not need it.
+
+Sun Jan 30 17:58:06 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* config.guess: Recognize vax hosts.
+
+Fri Jan 28 15:29:38 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure (while loop): Don't use "break 2" inside case
+	statement -- the case statement isn't an enclosing loop.
+
+Mon Jan 24 18:40:06 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Clean up NeXT support, to allow nextstep
+	on Intel machines.  Make OS be nextstep.
+
+Sun Jan 23 18:47:22 1994  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)
+
+	* config.guess: Add alternate forms for Convex.
+
+Thu Jan 20 16:13:41 1994  Stu Grossman  (grossman at cygnus.com)
+
+	* configure:  Completely rewrite option processing.  Take
+	advantage of pattern-matching to avoid invoking test frequently.
+	Also clean up host and target defaulting logic.
+
+Mon Jan 17 15:06:56 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* Makefile.in: Replace all occurrances of "rootme" with "r" and
+	"$${rootme}" with "$$r", to increase the likelihood that the do-*
+	commands (plus user environment) will fit SCO limits.
+
+Thu Jan  6 11:20:57 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Don't issue warnings about directories which are
+	not being configured if -norecursion is set.  Correct test for
+	--with-gnu-as and --with-gnu-ld to not get confused by substring
+	matches.
+
+	* configure.in: Don't build gas for alpha-dec-osf1*.
+
+Tue Jan  4 17:10:19 1994  Stu Grossman  (grossman at cygnus.com)
+
+	* configure:  Back out Per's change of 12/19/1993.  It changes the
+	behavior of configure in unexpected and confusing ways.
+
+	Also, use different delim char when calculating
+	program_transform_name so that the name can contain slashes.
+
+Sat Jan  1 13:45:31 1994  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* configure.in, config.sub: Add support for VSTa micro-kernel.
+
+Sat Dec 25 20:00:47 1993  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* configure.in: Nuke hacks which were used to get a special
+	version of GAS for HPPA configurations.
+
+Sun Dec 19 20:40:44 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure:  If only ${target_alias} is given, use that
+	as the default for ${host_alias}.
+	* configure:  Add missing back-slashes before nested quotes.
+
+Wed Dec 15 18:07:18 1993  david d `zoo' zuhn  (zoo@andros.cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): add YACC=$(BISON)
+
+Tue Dec 14 21:25:33 1993  Per Bothner  (bothner@cygnus.com)
+
+	* config.guess:  Recognize some Tektronix configurations.
+	From Kaveh R. Ghazi <ghazi@noc.rutgers.edu>.
+
+Sat Dec 11 11:18:00 1993  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* config.sub: Match any flavor of SH.
+
+Thu Dec  2 17:16:58 1993  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure.in: Don't try to configure newlib for Alpha.
+
+Thu Dec  2 14:35:54 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Don't build ld for Irix 5.  Don't build gas,
+	libg++ or libio for any Alpha target.
+
+	* configure.in (mips*-sgi-irix5*): New target; use mh-irix5.
+
+Wed Dec  1 17:00:33 1993  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* Makefile.in (GZIPPROG): Renamed from GZIP, which gzip uses for
+	default arguments -- so it tried to compress itself.
+
+Tue Nov 30 13:45:15 1993  david d `zoo' zuhn  (zoo@andros.cygnus.com)
+
+	* configure.in (notsupp): ensure that a space is always at the end
+	  of the configdirs list, since the grep checks for an explicit space
+
+Tue Nov 16 15:04:27 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in (target i386-sysv4.2): don't build ld, since static
+	  versions of many libraries are not available.
+
+Tue Nov 16 14:28:12 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize Apollos (using environment variables).
+	* configure.in: Don't configure ld, binutils, or gprof for Apollo.
+
+Thu Nov 11 12:03:50 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize Sony news mips running newsos.
+
+Wed Nov 10 16:57:00 1993  Mark Eichin  (eichin@cygnus.com)
+
+	* Makefile.in (all-cygnus, build-cygnus): "fi else" needs to be
+	"fi ; else" for bash.
+
+Tue Nov  9 15:54:01 1993  Mark Eichin  (eichin@cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): pass SHELL.
+
+Fri Nov  5 08:07:27 1993  D. V. Henkel-Wallace  (gumby@blues.cygnus.com)
+
+	* config.sub: accept unixware as an alias for svr4.2.
+	Fix some inconsistancies with the gcc version.
+
+Fri Nov  5 15:14:12 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (DISTDOCDIRS):  Add gdb.
+
+Fri Nov  5 11:59:42 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in (DISTDOCDIRS):  Add libg++ and libio.
+
+Fri Nov  5 10:35:05 1993  Ken Raeburn  (raeburn@rover.cygnus.com)
+
+	* Makefile.in (taz): Only build "info" in DISTDOCDIRS.
+	(DISTDOCDIRS): Don't assume libg++ and gdb folks necessarily want
+	this now.
+
+Thu Nov  4 18:58:23 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.sub: Accept hiux* as an OS name.
+
+	* Makefile.in: Change RUNTEST_FLAGS back to RUNTESTFLAGS per
+	etc/make-stds.texi.  The underscore came from gcc, and dje now
+	agrees that RUNTESTFLAGS is the correct name.
+
+Thu Nov  4 10:49:01 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* install.sh:  Remove 'set -e'.  It makes any conditionals
+	in the script useless.
+
+	* config.guess: Automatically recognize arm-acorn-riscix
+	Patch from Richard Earnshaw (rwe11@cl.cam.ac.uk).
+
+Thu Nov 04 08:08:04 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* Makefile.in: Change RUNTESTFLAGS to RUNTEST_FLAGS
+
+Wed Nov  3 22:09:46 1993  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* Makefile.in (DISTDOCDIRS): New variable.
+	(taz): Edit local Makefile.in sooner, instead of proto-toplev
+	Makefile.in later.  Build "info" and "dvi" in DISTDOCDIRS.
+
+Wed Nov  3 21:31:52 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in (hppa target): check the source directory for the
+	  pagas sub-directory
+
+Wed Nov  3 11:12:22 1993  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub: Allow -aout* and -elf*.
+
+Wed Nov  3 11:08:33 1993  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure.in: Don't build ld on i386-solaris2, same as for
+	sparc-solaris2.
+
+Tue Nov  2 14:21:25 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in (taz): Add texinfo/lgpl.texinfo (for libg++).
+
+Tue Nov  2 13:38:30 1993  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* configure.in:  Configure gdb for alpha.
+
+Mon Nov  1 10:42:54 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (CXXFLAGS): Add -O.
+
+Wed Oct 27 10:45:06 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* config.guess: added support for DG Aviion
+
+Tue Oct 26 14:37:37 1993  Ken Raeburn  (raeburn@rover.cygnus.com)
+
+	* configure.in: Produce warning message for subdirectories not
+	configurable for this host/target combination.  Don't try to
+	configure gdb for vms.
+
+Mon Oct 25 11:22:15 1993  Ken Raeburn  (raeburn@rover.cygnus.com)
+
+	* Makefile.in (taz): Replace "byacc" with "bison -y" in the
+	appropriate files before making "diststuff".
+	(DISTBISONFILES): New var: list of files to be edited.
+	(DISTSTUFFDIRS): Add binutils.
+
+Fri Oct 22 20:32:15 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* config.sub: also handle mipsel and mips64el (for little endian mips)
+
+Fri Oct 22 07:59:20 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Add * to end of all OS names.
+
+Thu Oct 21 11:38:28 1993  Stan Shebs  (shebs@rtl.cygnus.com)
+
+	* configure.in: Build newlib for LynxOS native.
+
+Wed Oct 20 09:56:12 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Add support for delta 88k running SVR3.
+
+	* configure.in: Add comment about HP compiler vs. emacs.
+
+Tue Oct 19 16:02:22 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: don't build ld on solaris2 (not a viable option
+	  due to bugs in getpwnam & getpwuid)
+
+Tue Oct 19 15:13:56 1993  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure.in: Accept alpha-dec-osf1*, not just -osf1, since
+	config.guess will produce a full version number.
+
+Tue Oct 19 15:58:01 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Build linker and binutils for alpha-dec-osf1.
+
+Tue Oct 19 11:41:55 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Remove -O from CXXFLAGS for consistency with CFLAGS,
+	and gdb/testsuite/Makefile.in.
+
+Sat Oct  9 18:39:07 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: recognize mips*- instead of mips-
+
+Fri Oct  8 14:15:39 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* config.sub: Accept linux*coff and linux*elf as operating
+	systems.
+
+Thu Oct  7 12:57:19 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* config.sub: Recognize mips64, and mips3 as an alias for it.
+
+Wed Oct  6 13:54:21 1993  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* configure.in: Remove alpha-dec-osf*, no longer necessary now that
+	gdb knows how to handle OSF/1 shared libraries.
+
+Tue Oct  5 11:55:04 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Recognize hppa*-*-hiux* (currently synonym for hpux).
+	* config.guess: Recognize Hitachi's HIUX.
+	* config.sub: Recognize h3050r* and hppahitachi.
+	Remove redundant cases for hp9k[23]*.
+
+Mon Oct  4 16:15:09 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: default to '--with-gnu-as' and '--with-gnu-ld'
+	if gas and ld are in the source tree and are in ${configdirs}.
+	If ${use_gnu_as} or ${use_gnu_ld} are 'no', then don't set the
+	--with options (but still pass them down on the command line,
+	if they were explicitly specified).
+
+Fri Sep 24 19:11:13 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure: substitute SHELL value in Makefile.in with
+	${CONFIG_SHELL}
+
+Thu Sep 23 18:05:13 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Build gas, ld, and binutils for *-*-sysv4* and
+	*-*-solaris2* targets.
+
+Sun Sep 19 17:01:41 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in: define M4, and pass it down to sub-makes;
+	all-autoconf now depends on all-m4
+
+Sat Sep 18 00:38:23 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in ({AR,RANLIB}_FOR_TARGET): make contingent on
+	presence of {ar,ranlib} instead of a configured directory
+
+Wed Sep 15 08:41:44 1993  Jim Kingdon  (kingdon@cirdan.cygnus.com)
+
+	* config.guess: Accept 34?? as well as 33?? for NCR.
+
+Mon Sep 13 12:28:43 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: grab mt-hppa for HPPA targets; use 'gas ' instead
+	of 'gas' in sed commands, since 'gash' is now in the tree as well.
+
+Fri Sep 10 11:23:52 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure: grab values for $(CC) and $(CXX) from the
+	environment, so that someone can do "CC=gcc configure; make" and
+	have it work right (matching the way that autoconf works now)
+
+	* configure.in, Makefile.in: add support for gash, the tcl
+	interface to Galaxy
+
+	* config.guess: add NetBSD variants (hp300, x86)
+
+Thu Sep  9 16:48:52 1993  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* install.sh: Support -d option (in the manner of SunOS 4 install,
+	as it is more deterministic than that of GNU install)
+	(chmodcmd): Set file to mode 755 by default (should also do default
+	chgrp and chown, but I don't feel like dealing with that now)
+
+Tue Sep  7 11:59:39 1993  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub: Remove h8300hhms alias.
+
+Tue Aug 31 11:00:09 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Match *-*-solaris2* not *-sun-solaris2*.
+
+Mon Aug 30 18:29:10 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in (gcc-no-fixedincludes): touch stmp-fixproto as well
+	as stmp-fixinc
+
+Wed Aug 25 16:35:59 1993  K. Richard Pixley  (rich@sendai.cygnus.com)
+
+	* config.sub: recognize m88110-bug-coff.
+
+Tue Aug 24 10:23:24 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in (all-libio): all dependencies on the toolchain used
+	to build this (gcc, gas, ld, etc)
+
+Fri Aug 20 17:24:24 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Deal with OSF/1 1.3 on alpha.
+
+Thu Aug 19 11:43:04 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* install.sh: add some 'else true' clauses for portability
+
+	* configure.in: don't build libio for h8[35]00-*-* targets
+
+Tue Aug 17 19:02:31 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in:  Add support for new libio.
+
+Sun Aug 15 20:48:55 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* install.sh: If one command fails, don't try the rest.  Don't try
+	to remove $dsttmp (via trap) unless we have already created it.
+	If $src doesn't exist, detect it and exit with an error.
+
+	* config.guess: Recognize BSD on hp300.
+
+Wed Aug 11 18:35:13 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Map (9000/[34]??:HP-UX:*:*) to m68k-hp-hpux.
+	Bug report from "Hamish (H.I.) Macdonald" <hamish@bnr.ca>.
+
+Wed Aug 11 15:37:51 1993  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* Makefile.in (all-send-pr): depends on all-prms
+
+Wed Aug 11 16:56:03 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Fix typo (9000/8??:4.3bsd -> 9000/7??:4.3bsd).
+
+Fri Aug  6 14:45:02 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* config.guess: From michael@mercury.cs.mun.ca (Michael Rendell):
+	Added test for mips-mips-riscos5.
+
+Thu Aug  5 15:45:08 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: use mh-hp300 for 68k HP hosts
+
+Mon Aug  2 11:56:53 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure: add support for CONFIG_SHELL, so that you can use
+	some alternate shell for evaluating configure scripts
+
+Sun Aug  1 11:36:27 1993  Fred Fish  (fnf@deneb.cygnus.com)
+
+	* Makefile.in (make-gdb.tar.gz):  Sed bug reporting address
+	in configure script to bug-gdb@prep.ai.mit.edu when building
+	distribution archive.
+	* Makefile.in (COMPRESS):  Remove def.
+	* Makefile.in (gdb.tar.gz, make-gdb.tar.gz):  Renamed from
+	gdb.tar.Z and make-gdb.tar.Z respectively.
+	* Makefile.in (make-gdb.tar.gz):  Now only build gzip'd archive.
+	* Makefile.in (make-gdb.tar.gz):  Minor changes to move closer
+	to convergence with 'taz' target in Makefile.in.
+
+Fri Jul 30 12:34:57 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* install.sh (dsttmp): use trap to ensure that tmp files go
+	away on error conditions
+
+Wed Jul 28 11:57:36 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): remove LOADLIBES
+
+Tue Jul 27 12:43:40 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (install-dirs): Deal with a prefix like /gnu;
+	its parent is '/' not ''.
+
+	* Makefile.in (DEVO_SUPPORT): Add comments about ChangeLog.
+
+Fri Jul 23 09:53:37 1993  Jason Merrill  (jason@wahini.cygnus.com)
+
+	* configure: if ${newsrcdir}/configure doesn't exist, don't assume
+	that ${newsrcdir}/configure.in does.
+
+Tue Jul 20 11:28:50 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* test-build.mk: support for CONFIG_SHELL
+
+Mon Jul 19 21:54:46 1993  Fred Fish  (fnf@deneb.cygnus.com)
+
+	* config.sub (netware):  Add as a basic system type.
+
+Wed Jul 14 12:03:11 1993  K. Richard Pixley  (rich@sendai.cygnus.com)
+
+	* Makefile.in (Makefile): depend on configure.in.  Also drop the
+	  $(srcdir)/ from the dependency on Makefile.in.
+
+Tue Jul 13 20:10:58 1993  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub: Recognize h8300hhms as h8300h-hitachi-hms.
+	(h8300hhms is temporary until multi-libraries are implemented).
+	* configure.in: Handle h8300h too.
+
+Sun Jul 11 17:35:27 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize dpx/2 as m68k-bull-sysv3.
+
+Thu Jul  8 18:26:12 1993  John Gilmore  (gnu@cygnus.com)
+
+	* configure:  Remove extraneous output when guessing host type.
+	* config.guess:  Remove extraneous output when guessing using C
+	compiler rather than uname, or when guessing fails.
+
+Wed Jul  7 17:58:14 1993  david d `zoo' zuhn  (zoo at rtl.cygnus.com)
+
+	* Makefile.in: remove all.cross and install.cross targets
+
+	* configure: remove CROSS=-DCROSS_COMPILE and ALL=all.cross
+	  definitions
+
+Tue Jul  6 10:39:44 1993  Steve Chamberlain  (sac@phydeaux.cygnus.com)
+
+	* configure.in (target sh): Build gprof.
+
+Thu Jul  1 16:52:56 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: change -solaris to -solaris2
+
+Thu Jul  1 15:46:16 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Use config/mh-riscos for mips-*-sysv*.
+
+Wed Jun 30 09:31:58 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: Correct error message for missing Makefile.in to
+	print correct directory.
+
+Tue Jun 29 13:52:16 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* install.sh: kludge around 386BSD shell bug
+
+Tue Jun 29 13:06:49 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.guess:  Recognize NeXT.
+	* config.guess:  Recognize i486-ncr-sysv4.
+	* Makefile.in (taz):  rm $(TOOL)-$$VER before linking.
+
+Tue Jun 29 12:50:57 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (MAKEINFOFLAGS): New variable.
+	(FLAGS_TO_PASS): Pass MAKEINFO as MAKEINFO MAKEINFOFLAGS.
+	* build-all.mk, test-build.mk: Pass down --no-split as
+	MAKEINFOFLAGS when hosted on DOS.  Compile DOS hosted without -g.
+
+Thu Jun 24 13:39:11 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (DEVO_SUPPORT):  Add COPYING COPYING.LIB install.sh.
+
+Wed Jun 23 12:59:21 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (libg++.tar.z):  New rule.
+	* Makefile.in (taz):  Replace 'configure -rm' by 'make distclean'.
+	* Makefile.in (taz):  Only do a single chmod.
+
+Fri Jun 18 12:03:10 1993  david d `zoo' zuhn  (zoo at majipoor.cygnus.com)
+
+	* install.sh: don't use dirname anymore (replaced with sed usage)
+
+Thu Jun 17 18:43:42 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in:  Change extension for gzip'd files from '.z' to
+	'.gz' per new FSF standard usage.
+
+Thu Jun 17 16:58:50 1993  david d `zoo' zuhn  (zoo at majipoor.cygnus.com)
+
+	* configure: put quotes around the final value of program_transform_name
+
+Tue Jun 15 16:48:51 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: new install.sh support; update install-info rules
+
+Wed Jun  9 12:31:34 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure.in: Build diff for crosses, but not for go32 host.
+
+	* configure.in: Build gprof only for native, and don't build it
+	for mips-*-*, rs6000-*-*, or i[34]86-*-sco*.
+
+Mon Jun  7 13:12:11 1993  david d `zoo' zuhn  (zoo at deneb.cygnus.com)
+
+	* configure.in: don't build gas,ld,binutils on for *-*-sysv4
+
+Mon Jun  7 11:40:11 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* configure.in (host_tools): Add prms.
+
+Fri Jun  4 13:30:42 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: install gcc, do installation of $(INSTALL_MODULES)
+	with $(FLAGS_TO_PASS) on the command line
+
+	* config.sub: Recognize lynx and lynxos
+
+Fri Jun  4 10:59:56 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub: Accept -ecoff*, not just -ecoff.
+
+Thu Jun  3 17:38:54 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (taz): Use .gz suffix instead of .z.
+	(binutils.tar.gz, gas+binutils.tar.gz, gas.tar.gz): Fixed target
+	names.
+
+Thu Jun  3 00:27:06 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in (vault-install): add an 'else true' (for Ultrix)
+
+Wed Jun  2 18:19:16 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in (install-no-fixedincludes):  install gcc last, so
+	that rebuilds that might happen during 'make install' don't get
+	bogus gcc include files
+
+Wed Jun  2 16:14:10 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	Change from Utah for HPPA support:
+	* config.guess: Recognize hppa1.x-hp-bsd.
+
+Wed Jun  2 11:53:33 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.guess:  Add support for Motorola Delta 68k, up to r3v7.
+	Patch from pot@fly.cnuce.cnr.it (Francesco Potorti`).
+
+Tue Jun  1 17:48:42 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+	* config.sub: Add support for rom68k and bug boot monitors.
+
+Mon May 31 09:36:37 1993  Jim Kingdon  (kingdon@cygnus.com)
+
+	* Makefile.in: Make all-opcodes depend on all-bfd.
+
+Thu May 27 08:05:31 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.guess: Added special check for i[34]86-univel-sysv4*.
+
+Wed May 26 16:33:40 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.guess: For i[34]86-unknown-sysv4 use UNAME_MACHINE for
+	the processor rather than assuming i486.
+
+Wed May 26 09:40:18 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize SunOS6 as Solaris3.
+
+Tue May 25 23:03:11 1993  Per Bothner  (bothner@cygnus.com)
+
+	* config.guess:  Fix typo.  Avoid #elif (not in K&R 1).
+	Recognize SunOS 5.* only (and not [6-9].*) as being Solaris2.
+
+Tue May 25 12:44:18 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk (all-cross): New target for Canadian Cross.
+	Added Q2 go32 targets.
+	* test-build.mk: Configure go32 cross sparclite-aout and
+	mips-idt-ecoff -with-gnu-ld.  Moved build binary directory from
+	PARTIAL_HOLE_DIRS to BUILD_HOLES_DIRS.
+
+Mon May 24 15:30:06 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: fix Alpha GDB typo; also, don't build DejaGnu for
+	GO32 hosted toolchains
+
+Mon May 24 14:18:41 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+	* configure: change  so "-exec-prefix" gets passed down rather
+	than "-exec_prefix" so autoconf generated Makefiles get the
+	exec_prefix set right.
+
+Fri May 21 10:42:25 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.guess: get the Solaris2 minor version number
+
+	* Makefile.in: add standards.texi and make-stds.texi to ETC_SUPPORT
+
+Fri May 21 06:20:52 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* config.guess: Recognize some Sequent platforms.
+
+Thu May 20 14:33:48 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: added the vault-install target
+
+	* configure.in: actually use the Sun3 makefile fragment that's in
+	config, also added the release dir to configdirs
+
+Thu May 20 14:19:18 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (taz): Fix modes on stuff in $(TOOL) dir also.
+
+Tue May 18 20:26:41 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: remove some program from Alpha targetted toolchains
+
+Tue May 18 15:23:19 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* Makefile.in (DISTSTUFFDIRS): Renamed from PROTODIRS.  Add ld and
+	gprof.
+	(taz): Run "make diststuff" in those directories instead of "make
+	proto-dir".  Look for "VERSION=" only at start of line in subdir
+	Makefile.  Use "gzip -9" for compression.
+	(TEXINFO_SUPPORT, DIST_SUPPORT, BINUTILS_SUPPORT_DIRS): New vars.
+	(binutils.tar.z): New target.
+
+Mon May 17 17:01:15 1993  Ken Raeburn  (raeburn@deneb.cygnus.com)
+
+	* Makefile.in (taz): Include gpl.texinfo.
+
+Fri May 14 06:48:38 1993  Ken Raeburn  (raeburn@deneb.cygnus.com)
+
+	* Makefile.in (setup-dirs): Merged into "taz" target.
+	(taz): Only do `proto-dir' stuff if a directory is actually needed
+	for this target.
+
+Wed May 12 13:09:44 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (MUNCH_NM): New variable, defined to be $(NM).
+	(FLAGS_TO_PASS): Pass down MUNCH_NM.
+	(HOST_CC, HOST_PREFIX, HOST_PREFIX_1): New variables.
+	(EXTRA_GCC_FLAGS): Pass down HOST_* variables.
+	(gcc-no-fixedincludes): Correct for current gcc Makefile.
+
+Tue May 11 10:14:25 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  Add configure, config.guess,
+	config.sub, and move-if-change to gdb testsuite distribution
+	archive, so the testsuite can be extracted, configured, and
+	run separately from the gdb distribution.  Blow away the Chill
+	tests that require a Chill compiled executable, since GNU Chill
+	is not yet publically available.
+
+Mon May 10 17:22:26 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* test-build.mk: set environment variables in a single command,
+	instead of a list of assignments and exports
+
+	* config.guess: recognize Alpha/OSF1 systems
+
+Mon May 10 14:55:51 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: Change help message to prefer --options rather than
+	  -options.
+
+Mon May 10 05:58:35 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* config.sub: Convergent Tech. "miniframe" uses m68010, sez
+	zippy@ecst.csuchico.edu.
+	* config.guess: Recognize miniframe.
+
+Sun May  9 17:47:57 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+       * Makefile.in: Use srcroot to find runtest rather than rootme.
+       Pass RUNTESTFLAGS and EXPECT down in BASE_FLAGS_TO_PASS.
+
+Fri May  7 14:55:59 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk: Extensive additions to support building on a
+	machine other than the host.
+
+Wed May  5 08:35:04 1993  Ken Raeburn  (raeburn@deneb.cygnus.com)
+
+	* configure (tooldir): Fix for i386-aix again.
+
+Mon May  3 19:00:27 1993  Per Bothner  (bothner@cygnus.com)
+
+	* configure, Makefile.in:  Change definition of $(tooldir)
+	to match the FSF.
+
+Fri Apr 30 15:55:21 1993  Fred Fish  (fnf@cygnus.com)
+
+	* config.guess:  Recognize i[34]86/SVR4.
+
+Fri Apr 30 15:52:46 1993  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in (all-gdb): gdb depends on sim.
+
+Thu Apr 29 23:30:48 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (gdb.tar.Z):  Make prototype gdb testsuite directory
+	at the same time we make the prototype gdb directory.
+	* Makefile.in (make-gdb.tar.Z):  Make the testsuite distribution
+	files at the same time as the gdb base release distribution.
+
+Thu Apr 29 12:50:37 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (check): Use individual check targets rather than
+	DO_X rule.
+	(check-gcc): Added.
+
+Thu Apr 29 09:50:07 1993  Jim Kingdon  (kingdon@cygnus.com)
+
+	* config.sub: Use sysv3.2 not sysv32 for canonical OS
+	for System V release 3.2.
+
+Thu Apr 29 10:33:22 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* config.sub: Recognize hppaosf.
+	* configure.in: Do configure ld/binutils/gas for it.
+
+Tue Apr 27 06:25:34 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure (tooldir): Alter syntax used to set this, for systems
+	where "\$" isn't handled right, like i386-aix.
+
+Thu Apr 22 08:17:35 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: Pass program-transform-name, not
+	program_transform_name, to recursive configures.
+
+Thu Apr 22 02:58:21 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* Makefile.in (gas+binutils.tar.z): New rule for building snapshots
+	of gas+ld+binutils.
+
+Mon Apr 19 17:41:30 1993  Per Bothner  (bothner@cygnus.com)
+
+	* config.guess:  Recognize AIX3.2 as distinct from 3.1.
+
+Sat Apr 17 17:19:50 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: rename m88k-motorola-m88kbcs to m88k-motorola-sysv
+
+Tue Apr 13 16:52:16 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* Makefile.in (PRMS): Set back to all-prms.
+
+Sat Apr 10 12:04:07 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk: Pass -with-gnu-as for known MIPS native and MIPS
+	targets, rather than for MIPS hosts.
+
+Fri Apr  9 13:51:06 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: add comment for --with-x default values
+
+	* config.guess: handle Motorola Delta88 box for SVR3 and SVR4.
+
+	* Makefile.in: add check-* targets for each of the directories in
+	the tree.  Add a definition of RUNTEST that will use the one we
+	just built, if it exists.  Pass this down via FLAGS_TO_PASS.
+
+Thu Apr  8 09:21:30 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure.in: Removed obsolete references to bfd_target and
+	target_makefile_frag.
+
+	* build-all.mk: Set assorted targets for Q2.
+	* config.sub: Recognize z8k-sim and h8300-hms.
+	* test-build.mk: Really don't pass host to configure.
+	(HOLES): Added uname.
+
+Wed Apr  7 15:48:19 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: Handle an empty program-prefix, program-suffix or
+	program-transform-name correctly.
+
+Tue Apr  6 13:48:41 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: -G 8 no longer required for MIPS targets.
+	* test-build.mk: Don't pass host argument to configure; make it
+	guess.
+
+Tue Apr  6 10:36:53 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (gdb.tar.Z):  Fix for building gzip'd distribution.
+	* Makefile.in (COMPRESS):  New macro, like GZIP.
+
+Fri Apr  2 09:02:31 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk: Use -with-gnu-as for mips-sgi-irix4 as well.
+
+	* build-all.mk: Set GCC to gcc -O -G 8 for MIPS targets, since gcc
+	with gas currently defaults to -G 0.
+
+Thu Apr  1 08:25:42 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (all-flex): flex depends on byacc.
+
+	* build-all.mk: If host not specified, use config.guess.  Pass TAG
+	to test-build.mk as RELEASE_TAG.
+	* test-build.mk (configargs): New variable containing arguments to
+	pass to configure.  Set to -with-gnu-as on mips-dec-ultrix.
+	(FLAGS_TO_PASS): Pass down RELEASE_TAG.
+
+	* config.guess: Use /bin/uname when checking -X argument on SCO,
+	to avoid invoking GNU uname which doesn't understand -X.
+
+	* test-build.mk: Don't use /usr/unsupported/bin/as on AIX.
+
+	* configure.in: Build gas for mips-*-*.
+
+Wed Mar 31 21:20:58 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in (all.normal): insert missing backslash.
+
+Wed Mar 31 12:31:56 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: Bump -XNh value to 1500 to match gcc requirements.
+
+	* Makefile.in: Complete overhaul to merge many almost identical
+	targets.
+
+Tue Mar 30 20:17:01 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (setup-dirs-gdb): Renamed from setup-dirs.
+	(gdb.tar.Z): Adjusted.
+
+	* Makefile.in (setup-dirs, taz): New targets; should be general
+	enough to adapt for gdb sometime.  Build only .z file.
+	(gas.tar.z): New target.
+
+Tue Mar 30 10:03:09 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: Use CC=cc -Xs on Solaris.
+
+Thu Mar 25 15:14:30 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in:  Incorporate changes suggested by wilson@cygnus.com
+	for handling BISON for FSF releases.
+
+Thu Mar 25 06:19:48 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure: Actually implement the change zoo just documented.
+
+Wed Mar 24 13:02:44 1993  david d `zoo' zuhn  (zoo at poseidon.cygnus.com)
+
+	* configure: when using config.guess, only set target_alias when
+	it's not already been set (ie, on the command line)
+
+Mon Mar 22 23:07:39 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: add installcheck target, set PRMS to install-prms
+
+Sun Mar 21 16:46:12 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure: add support for package_makefile_fragment, handle the
+	case where a directory has a configure.in file but no Makefile.in
+	more gracefully (with an actual understandable error message, even);
+	add support for --without (and add this to the usage message); also
+	explicitly add a --host=${host_alias} to the command line when
+	config.guess is used
+
+Sun Mar 21 12:11:58 1993  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* configure: Must use both --host and --target in recursive calls.
+
+Thu Mar 18 12:31:35 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: Change deja-gnu to dejagnu.
+
+Mon Mar 15 15:44:35 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure.in (h8300-*-*, h8500-*-*): Don't build libg++.
+
+Fri Mar 12 18:30:14 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: canonicalize all instances to *-*-solaris2*,
+	also strip out a number of tools to not build for go32 host
+
+Wed Mar 10 12:08:27 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* config.guess: add GPL.
+
+	* Makefile.in, config.guess, config.sub, configure: bump
+	  copyrights to 93.
+
+Wed Mar 10 07:12:48 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (do-info): Removed obsolete check for existence of
+	localenv file.
+
+	* Makefile.in (MAKEOVERRIDES): Define to be empty.
+
+Wed Mar 10 03:11:56 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: a couple of 'else true' for decstation,
+	support for TclX
+
+	* configure.in: configure tclX too; don't remove Tk on RS/6000 anymore
+
+Tue Mar  9 16:06:12 1993  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in (setup-dirs): change invocation of make to $(MAKE).
+
+Mon Mar  8 14:52:11 1993  Ken Raeburn  (raeburn@cambridge)
+
+	* config.guess: Recognize i386-ibm-aix (PS/2).
+	* configure.in: Use config/mh-aix386 file for it.
+
+Mon Mar  8 11:12:43 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (GCC_FOR_TARGET): Eliminated definition; use
+	CC_FOR_TARGET instead.
+	(BASE_FLAGS_TO_PASS): Pass GCC_FOR_TARGET=$(CC_FOR_TARGET).
+
+Wed Mar  3 16:00:28 1993  Steve Chamberlain  (sac@ok.cygnus.com)
+
+	* Makefile.in: Add sim to list of directories sent with gdb
+
+Wed Mar  3 11:42:39 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* configure.in: Put back mips-dec-bsd* case.
+
+Tue Mar  2 21:15:58 1993  Fred Fish  (fnf@cygnus.com)
+
+	(Ultrix 2.2 support from Michael Rendell <michael@mercury.cs.mun.ca>)
+	* configure.in (vax-*-ultrix2*):  Add Ultrix 2.2 triplet.
+	* config.guess:  Change 'VAX*:ULTRIX:*:*' to 'VAX*:ULTRIX*:*:*'.
+
+Tue Mar  2 18:11:03 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: remove no-op mips-dec-bsd* in "case $target"
+
+	* Makefile.in (dir.info): only run gen-info-dir if it exists,
+	(install-info): install dir.info only if it exists,
+	(all-expect, install-expect): pass along X11_FLAGS_TO_PASS
+
+Tue Mar  2 09:01:30 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* configure.in: For vms target, skip bfd, ld, binutils.  Do build
+	gas for mips-dec-bsd.
+
+Tue Mar  2 08:35:24 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure (makesrcdir): If ${srcdir} is relative and not ".",
+	and ${subdir} is not ".", set makesrcdir based on ${invsubdir}.
+
+Tue Feb 23 14:18:28 1993  Mike Werner  (mtw@poseidon.cygnus.com)
+
+	* configure.in: Added "dejagnu" to hosttools list.
+
+Mon Feb 22 23:28:38 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.sub, configure.in, config.guess:  Add support
+	for Bosx, an AIX variant from Bull.
+	Patches from F.Pierresteguy@frcl.bull.fr.
+
+Sun Feb 21 11:15:22 1993  Mike Werner  (mtw@poseidon.cygnus.com)
+
+	* devo/dejagnu: Initial creation of devo/dejagnu.
+	Migrated dejagnu testcases and support files for testing software
+	tools to reside as subdirectories, currently called "testsuite",
+	within the directory of the software tool.  Migrated all programs,
+	support libraries, etc. beloging to dejagnu proper from
+	devo/deja-gnu to devo/dejagnu.	These files were moved "as is"
+	with no modifications.	The changes to these files which will
+	allow them to configure, build, and execute properly will be made
+	in a future update.
+
+Fri Feb 19 20:19:39 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* Makefile.in: Change send_pr to send-pr.
+	* configure.in: Likewise.
+	* send_pr: Renamed directory to send-pr.
+
+Fri Feb 19 19:00:13 1993  Per Bothner  (bothner@cygnus.com)
+
+	* Makefile.in:  Add some extra semi-colons (needed if SHELL=bash).
+
+Fri Feb 19 00:59:33 1993  John Gilmore  (gnu@cygnus.com)
+
+	* README:  Update for gdb-4.8 release.
+	* Makefile.in (gdb.tar.Z):  Add texinfo/tex3patch.  Build
+	gdb-xxx.tar.z (gzip'd) file also.
+
+Thu Feb 18 09:16:17 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: make all-diff depend on all-libiberty
+
+Tue Feb 16 16:06:31 1993  K. Richard Pixley  (rich@cygnus.com)
+
+	* config.guess: add vax-ultrix in the spirit of mips-ultrix.
+
+Tue Feb 16 05:57:15 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in, Makefile.in: add hello, tar, gzip, recode, indent
+
+Tue Feb 16 00:58:20 1993  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in (DEVO_SUPPORT):  Remove etc directory
+	(ETC_SUPPORT):  Only add the files GDB wants from etc/.
+	(gdb.tar.Z):  Use ETC_SUPPORT.  Use byacc when building the file.
+
+Thu Feb 11 20:14:28 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in:  makeinfo binary is in a new location
+
+Tue Feb  9 12:42:27 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub: Accept -ecoff as an OS.
+
+	* Makefile.in: Various changes to eliminate a level of make
+	recursion and reduce the required command line length.
+	(BASE_FLAGS_TO_PASS): New variable holding flags passed to all
+	sub-makes.
+	(EXTRA_HOST_FLAGS, EXTRA_TARGET_FLAGS, EXTRA_GCC_FLAGS): New
+	variables holding settings for specific sub-makes.
+	(FLAGS_TO_PASS, TARGET_FLAGS_TO_PASS, GCC_FLAGS_TO_PASS): Rewrote
+	in terms of BASE_FLAGS_TO_PASS.
+	(TARGET_LIBS): New variable listing directories which use
+	TARGET_FLAGS_TO_PASS.
+	(subdir_do): Eliminated.
+	(do-*): New set of targets to replace subdir_do.
+	(various): All targets which used subdir_do now depend on do-*.
+	(local-clean): Renamed from do_clean.
+	(local-distclean): New target, dependency of distclean and
+	realclean.
+	(install-info): Don't create directories.  Depend on dir.info
+	rather than calling make recursively.
+	(install-dir.info): Eliminated.
+	(install-info-dirs): Create all info directories here.
+	(dir.info): Depend upon do-install-info.
+
+	* test-build.mk (HOLES): Added false.
+
+Sat Feb  6 14:05:09 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.guess:  Recognize BSDI and BSDJ (Jolitz 386bsd).
+
+Thu Feb  4 20:49:18 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in (info): remove dependency on all-texinfo.  The
+	problem was really in texinfo/C, not at this level.
+
+Thu Feb  4 13:38:41 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (info): Added dependency on all-texinfo (PR 2112).
+
+Thu Feb  4 01:50:53 1993  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  Change BISON to 'bison -y' for
+	GDB releases.
+
+Wed Feb  3 17:22:16 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* configure: Include srcdir in message about target of link not
+	being found.  Don't convert `-' to `_' in `with' options being
+	passed to subdirs.
+
+Tue Feb  2 18:57:59 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: add uudecode to host_tools
+
+	* Makefile.in: added {all,install}-uudecode targets, added them to
+	the appropriate lists
+
+Tue Feb  2 11:45:53 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (all-gcc): Added dependency on all-gas.
+
+	* configure.in (mips-*-*): Build ld and binutils.
+
+Mon Feb  1 12:35:41 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: check return code from mkdir, print error message and
+	  exit on failure.
+
+Sat Jan 30 16:40:28 1993  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  New location for texinfo.tex.
+
+Thu Jan 28 15:09:59 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk (HOLES): Added tar, cpio and uudecode.
+
+Wed Jan 27 16:50:32 1993  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* config.sub (h8500):  Recognize this as a cpu type.
+
+Sat Jan 23 20:32:01 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure: source directory missing is no longer a warning
+
+	* configure.in: recognize irix[34]* instead of irix[34]
+
+	* Makefile.in: define and pass down X11_LIB
+
+Sat Jan 23 13:49:40 1993  Per Bothner  (bothner@cygnus.com)
+
+	* guess-systype: Renamed to ...
+	* config.guess:  ... by popular request.
+	* configure.in, Makefile.in:  Update accordingly.
+
+Thu Jan 21 12:20:55 1993  Per Bothner  (bothner@cygnus.com)
+
+	* guess-systype:  Patches from John Eaton <jwe@che.utexas.edu>:
+	+ Add Convex, Cray/Unicos, and Encore/Multimax support.
+	+ Execute ./dummy instead of assuming . is in PATH.
+
+Tue Jan 19 17:18:06 1993  Per Bothner  (bothner@cygnus.com)
+
+	* guess-systype:  New shell script.  Attempts to guess the
+	canonical host name of the executing host.
+	Only a few hosts are supported so far.
+	* configure:  Call guess-systype if no host is specified.
+
+Tue Jan 19 08:26:07 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (gcc-no-fixedincludes): Made to work with current
+	gcc Makefile.
+
+
+Fri Jan 15 10:27:02 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (GCC_FLAGS_TO_PASS): New variable.
+	(all-gcc, install-gcc, subdir_do): Use it.
+
+Wed Jan 13 17:06:45 1993  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* Makefile.in: Rename uninstalled gcc driver from gcc to xgcc.
+
+Wed Jan  6 20:29:16 1993  Mike Werner  (mtw@rtl.cygnus.com)
+
+	* Makefile.in: Removed explicit setting of SUBDIRS. SUBDIRS is now
+	  set exclusively by configure, using configure.in .
+
+Wed Jan  6 13:44:11 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* test-build.mk: set $PATH for all builds
+
+	* Makefile.in: pass TARGET_FLAGS_TO_PASS for xiberty and libm
+
+Wed Jan  6 11:02:10 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (GCC_FOR_TARGET):  Supply a default that matches
+	the one used in gcc/Makefile.in, so that a null expansion doesn't
+	override the one needed to build gcc with a native cc.
+
+
+Tue Jan  5 07:55:12 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* configure: Accept -with arguments.
+
+Sun Jan  3 15:15:09 1993  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in: added h8300sim
+
+Tue Dec 29 15:06:00 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: If canonhost is i386-unknown-sco3.2v4, change it
+	to i386-sco3.2v4.  Set TARGETS and CFLAGS for i386-sco3.2v4.
+	(all-cygnus, native, build-cygnus): Make
+	$(canonhost)-stamp-3stage-done, not $(host)....
+	* test-build.mk (stamp-3stage-compared): Use tail +10c for
+	i386-sco3.2v4.  Added else true to if command.
+
+Mon Dec 28 12:08:56 1992  Ken Raeburn  (raeburn@cygnus.com)
+
+	* config.sub: (from FSF) Sequent uses a BSD-like OS.
+
+Mon Dec 28 08:32:06 1992  Minh Tran-Le  (mtranle@paris.intellicorp.com)
+
+	* configure.in (i[34]86-*-isc*): added; uses mh-sysv.
+
+Thu Dec 24 17:26:24 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: don't remove binutils from Solaris builds
+
+Thu Dec 24 14:08:38 1992 david d`zoo' zuhn  (zoo@cygnus.com)
+
+	* Makefile.in: get rid of earlier definitions for *clean,
+	also handle the recursive info rule better
+
+Thu Dec 24 12:40:21 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (mostlyclean, distclean, realclean):  Fix to
+	do more-or-less the right thing.
+
+Wed Dec 16 10:25:31 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: Add lines defining CC and CXX, and use CXX rather
+	than gcc in definitions of CXX_FOR_BUILD and CXX_FOR_TARGET.
+
+Tue Dec 15 00:34:32 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: change all $(host_cpu)-$(host_vendor)-$(host_os) to
+	$(host_canonical).
+
+	* configure.in: split the configdirs list into 4 categories (native
+	v. cross, library v. tool) and handle the cross-only and native-
+	only in more reasonable (and correct!) way.
+
+Mon Dec 14 17:04:22 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* configure.in (hppa*-*-*):  Don't remove bfd and gdb from
+	configdirs anymore.
+
+Sun Dec 13 00:37:26 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: extensive cleanup::  removed all of the explicit
+	clean-* targets, collapsed many wrappers around subdir_do into
+	one, added additional targets to satisfy standards.texi, deleted
+	some old targets, some changes for consistency
+
+Fri Dec 11 20:18:02 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: handle some programs as cross-only, and others as
+	native only
+
+	* test-build.mk: handle partial holes in a more generic manner
+
+	* Makefile.in: m4 depends on libiberty
+
+Thu Dec  3 21:52:11 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: add m4, textutils, fileutils, sed, shellutils,
+	time, wdiff, and find to configdirs
+
+	* Makefile.in: all, clean, and install rules for the new programs
+	added to configure.in
+
+Mon Nov 30 14:54:34 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: use mh-sun for all *-sun-* hosts
+
+Fri Nov 27 18:35:54 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: define flags for X11 include files and library file
+	locations, pass them down to the programs that need this info
+
+	* build-all.mk: added a 'native' target, to 3stage the native toolchain
+
+Sun Nov 22 18:59:13 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: start building libg++ for HP-UX targets
+
+Wed Nov 18 19:33:11 1992  John Gilmore  (gnu@cygnus.com)
+
+	* README:  Update references to files moved into etc/.
+
+Sun Nov 15 09:36:08 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub (i386sol2, i486sol2):  i[34]86-unknown-solaris2.
+	* configure.in (i[34]86-*-solaris2*):  Use config/mh-sysv4.
+
+Thu Nov 12 08:50:42 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: accept dash as well as underscore in long option
+	names for FSF compatibility.
+
+Wed Nov 11 08:04:37 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub: added -sco3.2v4 support from FSF.
+
+Sun Nov  8 21:14:30 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: expand the section that adds or removes
+	directories from the list of programs to build, to handle native
+	vs. cross in addition to host v. native
+
+Sat Nov  7 18:52:27 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in:  Replace C++ in macro names with CXX.
+	This is less likely to break ...
+
+Sat Nov  7 15:16:58 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* test-build.mk: add -w to GNU_MAKE
+
+Fri Nov  6 23:10:37 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: remove 'sparc'-->'sparc-sun' default transformation,
+	add 'sparc' to list of recognized cpus.  This needed to make
+	'sparc-aout' expand to 'sparc-unknown-aout' instead of 'sparc-sun-aout'.
+	Delete some redundant ose68 variants.  Recognize -wrs as an os,
+	then changes that into $CPU-wrs-vxworks.
+
+	* configure.in: remove most references to gdbtest, regularize
+	target based program removal
+
+	* test-build.mk: import from p3 tree (many fixes and changes)
+
+Fri Nov  6 20:59:00 1992  david d `zoo' zuhn  (zoo@cygnus.com)
+
+	* Makefile.in: added rules to handle tcl, tk, and expect
+
+	* configure.in: handle those directories if they exist
+
+Thu Nov  5 14:35:41 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: removed bogus hppabsd and hppahpux names, since
+	"hppa" is not a valid cpu (hppa1.1 or hppa1.0 are, though)
+
+Thu Oct 29 00:12:41 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: all-gcc now depends on all-binutils.  all-libg++
+	depends upon all-xiberty
+
+	* Makefile.in: changes from p3, including:
+
+	Thu Oct  8 15:00:17 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (XTRAFLAGS): include newlib directories if
+	newlib/Makefile exists, rather than if host != target.
+
+	Fri Sep 25 13:41:52 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -nostdinc to XTRAFLAGS if we are using gcc
+	from the same source tree and not building a cross-compiler.  This
+	matters for the libg++ configuration if reconfiguring a tree that
+	has already been installed.
+
+	Thu Sep 10 10:35:51 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -I for newlib/targ-include to XTRAFLAGS, to
+	pick up the machine and system specific header files.
+
+	* Makefile.in: added AS_FOR_TARGET, passed down in
+	TARGET_FLAGS_TO_PASS.  Added CC_FOR_BUILD, which is intended to be
+	the C compiler to use to create programs which are run in the
+	build environment, set it to default to $(CC), and passed it down
+	in FLAGS_TO_PASS and TARGET_FLAGS_TO_PASS.
+
+	Mon Sep  7 22:34:42 1992  Ian Lance Taylor  (ian@cirdan.cygnus.com)
+
+	* Makefile.in: add $(host) = $(target) tests back to *_FOR_TARGET.
+	We need them for unusual native builds, like systems without
+	ranlib.
+
+	* configure: also define $(host_canonical) and
+	$(target_canonical), which are the full, canonical names for the
+	given host and target
+
+Sun Nov  1 16:38:17 1992  Per Bothner  (bothner@cygnus.com)
+
+	* Makefile.in:  Added separate definitions for C++.
+
+Fri Oct 30 11:37:52 1992  Fred Fish  (fnf@cygnus.com)
+
+	* configure.in (configdirs):  Add deja-gnu.
+
+Fri Oct 23 00:39:18 1992  John Gilmore  (gnu@cygnus.com)
+
+	* README:  Update for configure.texi and gdb-4.7 release.
+
+Wed Oct 21 21:54:27 1992  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in:  Move "all" target to top of file.
+	Previously, first target was ".PHONY" which caused BSD4.4 make
+	to build .PHONY when make was run without arguments.
+
+Mon Oct 19 01:17:54 1992  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in:  Add COPYING.LIB to GDB releases, now that there's
+	Library-copylefted code in libiberty.
+
+Tue Oct 13 01:22:32 1992  John Gilmore  (gnu@cygnus.com)
+
+	* config.sub:  Replace m68kmote with plain old m68k.
+
+Fri Oct  9 03:14:24 1992  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in:  Remove space from blank line, avoid Make complaints.
+
+Thu Oct  8 18:41:45 1992  Ken Raeburn  (raeburn@cygnus.com)
+
+	* config.sub: Complain if no argument is given.  Added support for
+	386bsd as OS and target alias.
+
+Thu Oct  8 15:07:22 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (XTRAFLAGS): include newlib directories if
+	newlib/Makefile exists, rather than if host != target.
+
+Mon Oct  5 03:00:09 1992  Mark Eichin  (eichin at tweedledumber.cygnus.com)
+
+	* config.sub: recognize sparclite-wrs-vxworks.
+
+	* Makefile.in (install-xiberty): added *-xiberty make rules (from
+	p3.) Added clean-xiberty to clean.
+
+Thu Oct  1 17:59:19 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: use *-*-* instead of nested cases for host and target
+
+Tue Sep 29 14:11:18 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -nostdinc to XTRAFLAGS if we are using gcc
+	from the same source tree and not building a cross-compiler.  This
+	matters for the libg++ configuration if reconfiguring a tree that
+	has already been installed.
+
+Sep 20 08:53:10 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub (i486v/i486v4):  Merge in from FSF version.
+
+Fri Sep 18 00:32:00 1992  Mark Eichin  (eichin@cygnus.com)
+
+	* configure: only set PWD if it is already set.
+
+Thu Sep 17 23:05:53 1992  Mark Eichin  (eichin@cygnus.com)
+
+	* configure: just set PWD=`pwd` at the top, since Ultrix sh
+	doesn't have unset and all success paths (and most error paths)
+	out set it anyway. (Note: should change all uses of ${PWD=`pwd`}
+	to just ${PWD} to avoid confusion.)
+
+Tue Sep 15 16:00:54 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: always set $(tooldir) to $(libdir)/$(target_alias),
+	even for a native compilation.
+
+Tue Sep 15 02:22:56 1992  John Gilmore  (gnu@cygnus.com)
+
+	Changes to make the gdb.tar.Z rule work better.
+
+	* Makefile.in (GDB_SUPPORT_DIRS):  Add opcodes.
+	(DEVO_SUPPORT):  Add configure.texi.
+	(bfd-ilrt.tar.Z):  Remove ancient rule.
+
+Thu Sep 10 10:43:19 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -I for newlib/targ-include to XTRAFLAGS, to
+	pick up the machine and system specific header files.
+
+	* configure.in, config.sub: added new target m68010-adobe-scout,
+	with alias of adobe68k.  Changed configure.in to check for
+	-scout before -sco* to avoid a false match.
+
+	* Makefile.in: added AS_FOR_TARGET, passed down in
+	TARGET_FLAGS_TO_PASS.  Added CC_FOR_BUILD, which is intended to be
+	the C compiler to use to create programs which are run in the
+	build environment, set it to default to $(CC), and passed it down
+	in FLAGS_TO_PASS and TARGET_FLAGS_TO_PASS.
+
+Wed Sep  9 12:21:42 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added TARGET_FLAGS_TO_PASS, CC_FOR_TARGET,
+	AR_FOR_TARGET, RANLIB_FOR_TARGET, NM_FOR_TARGET.  Pass
+	TARGET_FLAGS_TO_PASS, which defines CC, AR, RANLIB and NM as the
+	FOR_TARGET variants, to newlib and libg++.
+
+Tue Sep  8 17:28:30 1992  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (all-gas, all-gdb): Require all-opcodes to be built
+	first.
+
+Wed Sep  2 02:50:05 1992  John Gilmore  (gnu@cygnus.com)
+
+	* config.sub:  Accept `elf' as an environment.
+
+Tue Sep  1 15:48:30 1992  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in (all-opcodes):  cd into the right directory
+
+Sun Aug 30 21:12:11 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: added -program_transform_name option, used as
+	argument to sed when installing programs.
+	configure.texi: added documentation for -program_prefix,
+	-program_suffix and -program_transform_name.
+
+Thu Aug 27 21:59:44 1992  John Gilmore  (gnu@cygnus.com)
+
+	* config.sub:  Accept i486 where i386 ok.
+
+Thu Aug 27 13:04:42 1992  Brendan Kehoe  (brendan@rtl.cygnus.com)
+
+	* config.sub: accept we32k
+
+Mon Aug 24 14:05:14 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub, configure.in: accept OSE68000 and OSE68k.
+
+	* Makefile.in: don't create all directories for ``make install'';
+	let the subdirectories create the ones they need.
+
+Tue Aug 11 23:13:17 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* COPYING: new file, GPL v2
+
+Tue Aug  4 01:12:43 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: use the new gen-info-dir, which needs a template
+	argument (which also lives in texinfo)
+
+	* configure.texi, standards.texi: fix INFO-DIR-ENTRY
+
+Mon Aug  3 00:34:17 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub (ncr3000):  Change i386 to i486.
+
+Thu Jul 23 00:12:17 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: add install-rcs, install-grep to
+	install-no-fixedincludes, removed install-bison and install-libgcc
+
+Tue Jul 21 01:01:50 1992  david d `zoo' zuhn (zoo@cygnus.com)
+
+	* configure.in: grab the HPUX makefile fragment if on HPUX
+
+Mon Jul 20 11:02:09 1992  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* Makefile.in: eradicate bison spoor (ditto libgcc).
+	 configure.in: recognise m68{k,000}-ericsson-OSE.
+	 es1800 is alias for m68k-ericsson-OSE
+
+Sun Jul 19 17:49:02 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: rearrange the parts that remove programs from
+	configdirs, based now on HOST==TARGET or by canonical triple.
+
+Fri Jul 17 22:52:49 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* test-build.mk: recurse explicitly with -f test-build.mk when
+	  appropriate.  predicate stage3 and comparison on the existence
+	  of gcc.  That is, if gcc isn't around, we aren't three-staging.
+	  On very clean, also remove ...stamp-co.  Build in-place before
+	  doing other builds.
+
+Thu Jul 16 18:33:09 1992  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in, configure.in: add tgas
+
+Thu Jul 16 16:05:28 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: a number of changes merged in from progressive.
+
+	* configure.in: add libm.
+
+	* .cvsignore: ignore some stuff that comes from test-build.mk.
+
+Tue Jul  7 00:24:52 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub:  Add es1800 (m68k-ericsson-es1800).
+
+Tue Jun 30 20:24:41 1992  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* configure: Add program_suffix (parallel to program_prefix)
+	* Makefile.in: adjust directory-creating script for losing decstation
+
+Mon Jun 22 23:43:48 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure:  Minor $subdir-related fixes.
+
+Mon Jun 22 18:30:26 1992  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* configure: fix various problems with propogating
+	makefile_target_frag in subdirs.
+	* configure.in: config libgcc if its there
+
+Fri Jun 19 15:19:40 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* config.sub:  HPPA merge.
+
+Sun Jun 14 10:29:19 1992  John Gilmore  (gnu at cygnus.com)
+
+	* Makefile.in:  Replace all-bison with all-byacc in all
+	dependency lines for other tools (which now use byacc).
+
+Fri Jun 12 22:21:57 1992  John Gilmore  (gnu at cygnus.com)
+
+	* config.sub:  Add sun4sol2 => sparc-sun-solaris2.
+
+Thu Jun  4 12:07:32 1992  Mark Eichin  (eichin@cygnus.com)
+
+	* Makefile.in: make gprof rules similar to byacc rules (instead of
+	vestigal $(unsubdir) that didn't work...)
+
+Thu Jun  4 00:37:05 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.sub:  Add support for Linux.
+	* Makefile.in:  Use $(FLAGS_TO_PASS) more consistently
+	(at least for libg++).
+
+Tue Jun 02 20:03:00 1992  david d `zoo' zuhn (zoo@cygnus.com)
+
+	* configure.texi: fix doc for the -nfp option to configure
+
+Tue Jun  2 17:20:52 1992  Michael Tiemann  (tiemann@cygnus.com)
+
+	* Makefile.in (all-binutils): ar needs flex, so depend on all-flex.
+
+Sun May 31 15:04:08 1992  Mark Eichin  (eichin at cygnus.com)
+
+	* config.sub: changed [^-]+ to [^-][^-]* so that it works under
+	Sun sed. (BSD 4.3 sed doesn't handle [^-]+ either.)
+	* configure.in: added solaris* host_makefile_frag hook.
+
+Sun May 31 01:10:34 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: changed recognition of m68000 so that various
+	m68k types can be specified via m680[01234]0
+
+Sat May 30 21:01:06 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub (basic_machine): fix sed so that '-foo' isn't
+	completely substituted out while .+'-foo' loses the '-foo'
+
+Wed May 27 23:18:52 1992  Michael Tiemann  (tiemann@rtl.cygnus.com)
+
+	* config.sub ($os): Add -aout.
+
+Fri May 22 14:00:02 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure:  If host_makefile_frag is absolute, don't
+	prefix ${invsubdir} (relevant to libg++ auto-configure).
+
+Thu May 21 18:00:09 1992  Michael Tiemann  (tiemann@rtl.cygnus.com)
+
+	* Makefile.in (tooldir): Define it.
+	(all-ld): Depend on all-flex.
+
+Sun May 10 21:45:59 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (check):  Fix libg++ special case.
+
+Fri May  8 08:31:41 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: do not bury `pwd` into config.status, thus do fewer
+	  pwd's.
+
+	* configure: print the "Building in" message only when building in
+	  other than "." AND verbose.
+
+	* configure: remove -s, rework -v to better accomodate guested
+	  configures.
+
+	* standards.texi: updated to 3 may, fixed librid <-> libdir typo.
+
+Fri May  1 18:00:50 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: macroize flags passed on recursion.  remove
+	  fileutils.
+
+Thu Apr 30 08:56:20 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: get makesrcdir right for subdirs deeper than 1.
+
+	* Makefile.in: pass INSTALL, INSTALL_DATA, INSTALL_PROGRAM on
+	  install.
+
+Fri Apr 24 15:51:51 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: don't print subdir_do or recursion lines.
+
+Fri Apr 24 15:22:04 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* standards.texi: added menu item.
+
+	* Makefile.in: build and install standards.info.
+
+	* standards.texi: new file.
+
+Wed Apr 22 18:06:55 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: test for and move config.status pieces from
+	  ${subdir}/.
+
+Wed Apr 22 14:38:34 1992  Fred Fish  (fnf@cygnus.com)
+
+	* configure:  Test for existance of files before trying to mv
+	them, to avoid numerous non-existance messages.
+
+Tue Apr 21 12:31:33 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: correct final line of config.status.
+
+	* configure: patch from eggert.  Avoids a protection problem if
+	  the original Makefile.in is read only.
+
+	* configure: use move-if-change from gcc to create config.status.
+	  Some makefiles depend on config.status to tell if a directory
+	  has been reconfigured for a different host.  This change
+	  prevents those directories from remaking everything in the case
+	  where the reconfig was only intended to rebuild a Makefile.
+
+	* configure: test for config.sub with "config.sub sun4" rather
+	  than "config.sub ${host_alias}".  Otherwise we can't tell a bad
+	  host alias from a missing config.sub.
+
+Mon Apr 20 18:16:36 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: explicitly pass CFLAGS on recursion. no longer pass
+	  MINUS_G (this can be done with CFLAGS).  Default CFLAGS to -g.
+
+Fri Apr 17 18:27:51 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure: mkdir ${subdir} as needed.
+
+Wed Apr 15 17:37:22 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in,configure.in: added autoconf.
+
+Wed Apr 15 17:27:34 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: no longer pass against on recursion.
+
+	* Makefile.in: added .NOEXPORT: so that stray makefile_frag
+	  definitions are not inherited.
+
+	* configure: correct makesrcdir when subdir is .
+
+Tue Apr 14 11:56:09 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure:  Add support for 'subdirs' variable, which is
+	like 'configdirs', except that configure doesn't re-invoke
+	itself for subdirs, it just creates a Makefile for each subdir.
+	* configure.texi:  Document subdirs.
+
+Mon Apr 13 18:50:16 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: added flex to configdirs
+
+Mon Apr 13 18:43:55 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: remove clean-stamps from clean.
+
+Sat Apr 11 03:52:03 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.in:  Add gdbtest to configdirs.
+
+Fri Apr 10 23:11:49 1992  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (MINUS_G):  Add macro, default to -g, pass on
+	to recursive makes.
+	* configure.in:  Recognize new ncr3000 config.
+
+Wed Apr  8 23:08:12 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in, configure.in: removed references to gdbm.
+
+Tue Apr  7 16:48:20 1992  Per Bothner  (bothner@cygnus.com)
+
+	* config.sub:  Don't canonicalize os value
+	newsos* to bsd (readline needs to check for newsos).
+	(This fix was earlier made Jan 31, but got re-broken.)
+
+Mon Apr  6 14:34:08 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* configure.in:  sco is an os, not a vendor!
+
+	* configure:  Quote $( better.  Keep various shells happy.
+
+Tue Mar 31 16:32:57 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: eliminate stamp-files.
+
+Mon Mar 30 22:20:23 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: add send_pr.  remove "force" from .stmp-gprof rule.
+	  Supress echoing of all the "if [ -d ... $(MAKE)" lines.
+
+Wed Mar 25 15:20:04 1992  Stu Grossman  (grossman@cygnus.com)
+
+	* config.sub:  fix iris/iris3.
+
+Wed Mar 25 10:34:19 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: re-add -rm.
+
+Tue Mar 24 23:50:16 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Maskefile.in: add .stmp-rcs to all.
+
+	* configure.in: remove gas from rs6000 build, use aix host fragment.
+
+Mon Mar 23 19:43:35 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: pass down site_option during recursion.
+
+Thu Mar 19 16:49:36 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in (all.cross):  Add .stmp-bfd .stmp-readline.
+
+Wed Mar 18 15:29:33 1992  Mike Stump  (mrs@cygnus.com)
+
+	* configure: Change exec_prefix so that it really defaults to prefix.
+
+Sat Mar 14 17:20:38 1992  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in, configure.in:  Add support for mmalloc library.
+
+Fri Mar 13 18:44:18 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: add stmp dependencies for a few more things.
+
+Thu Mar 12 04:56:24 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: adjusted error message on objdir/srcdir configure
+	  collision, per john's suggestion.
+
+	* Makefile.in: add libiberty stmp to all and all.cross.
+
+Wed Mar 11 02:07:52 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: remove force dependencies, add grep to all.
+
+Tue Mar 10 21:49:18 1992  K. Richard Pixley  (rich@mars.cygnus.com)
+
+	* Makefile.in: drop flex.  make stamp files work.
+
+	* configure: added test for conflicting configuration in srcdir,
+	  remove trailing slashes from srcdir.  Otherwise emacs gdb mode
+	  gets cranky.  use relative paths for configure and srcdir
+	  whenever possible.  Send some error messages to stderr that were
+	  going to stdout.
+
+Tue Mar 10 18:01:55 1992  Per Bothner  (bothner@cygnus.com)
+
+	* Makefile.in:  Fix libg++ rule to check for gcc directory
+	before using gcc/gcc.  Also pass XTRAFLAGS.
+
+Thu Mar  5 21:45:07 1992  K. Richard Pixley  (rich@sendai)
+
+	* Makefile.in: added stmp-files so that directories aren't polled
+	  when they are already built.
+
+	* configure.texi: fixed a node pointer problem.
+
+Thu Mar  5 12:05:58 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* config.sub configure.in gdb/configure.in
+	gdb/mips-tdep.c gdb/mipsread.c gdb/procfs.c gdb/signame.h
+	gdb/tm-irix3.h gdb/tm-mips.h gdb/xm-irix4.h gdb/config/mt-irix3
+	gdb/config/mh-irix4 texinfo/configure.in:  Port to SGI Irix-4.x.
+
+Wed Mar  4 02:57:46 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: -recurring becomes -silent.  corrected help message
+	  for -site= option.
+
+	* Makefile.in: mkdir $(exec_prefix) and $(tooldir).
+
+Tue Mar  3 14:51:21 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: when building Makefile for crosses, replace
+	  tooldir and program_prefix.  default srcdir from location of
+	  config.sub.  remove "for host in hosts" and "for target in
+	  targets" loops.
+
+Wed Feb 26 19:48:25 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: Do not pass bindir or mandir to cvs.
+
+Wed Feb 26 18:04:40 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in, configure.in: removed traces of namesubdir,
+	  -subdirs, $(subdir), $(unsubdir), some rcs triggers.  Forced
+	  copyrights to '92, changed some from Cygnus to FSF.
+
+	* configure.texi: remove most references to multiple hosts,
+	  multiple targets, subdirs, etc.
+
+	* configure.man: removed rcsid. reference config.sub not
+	  config.subr.
+
+	* Makefile.in: mkdir $(infodir) on install-info.
+
+Wed Feb 19 15:41:13 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.texi:  Explain better about .gdbinit and about
+	the environment that configure.in sections run in.
+
+Fri Feb  7 07:55:00 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.in:  Ultrix is only a decstation if it's a MIPS.
+
+Fri Jan 31 21:54:51 1992  John Gilmore  (gnu at cygnus.com)
+
+	* README:  DOC.configure => cfg-paper.texi.
+
+Fri Jan 31 21:48:18 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* config.sub (near case $os):  Don't convert newsos* to bsd!
+
+Fri Jan 31 02:27:32 1992  John Gilmore  (gnu at cygnus.com)
+
+	* Makefile.in:  Reinstall change from gdb-4.3 that reduces
+	the number of copies of COPYING that go into the GDB tar file.
+
+Thu Jan 30 16:17:30 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* bfd/configure.in, gdb/config/mh-i386sco,
+	gdb/config/mt-i386v32, gdb/configure.in, readline/configure.in:
+	Fix SCO configuration stuff.
+
+Tue Jan 28 23:51:07 1992  Per Bothner  (bothner at cygnus.com)
+
+	* Makefile.in:  For libg++, make sure the -I pointing
+	to the gcc directory goes *after* all the libg++-local -I flags.
+	Also, move just-gcc dependency from just-libg++ to all-libg++.
+
+Tue Jan 28 12:56:24 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* configure:  Change -x to -f to keep Ultrix /bin/test happy.
+
+Sat Jan 18 17:45:11 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  Remove texinfo targets.
+
+Sat Jan 18 17:03:21 1992  Fred Fish  (fnf at cygnus.com)
+
+	* config.sub:  Add stratus configuration frags.  Also
+	submitted to FSF.
+
+Sat Jan 18 15:35:29 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in (DEV_SUPPORT):  add configure.man.
+
+	* config.sub(Decode manufacturer-specific):  add -none*.
+
+Fri Jan 17 17:58:05 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in:  remove form feeds to make Sun's make happy.
+	(DEVO_SUPPORT):  DOC.configure => cfg-paper.texi.
+
+Sat Jan  4 16:11:44 1992  John Gilmore  (gnu at cygnus.com)
+
+	* Makefile.in (AR_FLAGS):  Make quieter.
+
+Thu Jan  2 22:57:12 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.in:  Add libg++.
+	* configure:  When verbose, don't output the command line at each
+	level; it will be unremarkably the same as the previous version,
+	which will be the same as what the user typed.
+
+Fri Dec 27 16:26:47 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* configure.in, Makefile.in: fix clean-info, add flex.  add
+	  fileutils.
+
+	* configure: be less sensitive to spaces in Makefile.in.  Do not
+	  look for sources in "..".  Doing so breaks subdirectories that
+	  might have their own configure.  If a subdir has it's own
+	  configure script, use it.
+
+Thu Dec 26 16:30:26 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* cfg-paper.texi: some changes suggested by rms.
+
+Thu Dec 26 10:13:36 1991  Fred Fish  (fnf at cygnus.com)
+
+	* config.sub:  Merge in some small additions from the FSF version,
+	taken from the gcc distribution, to bring the Cygnus and FSF
+	versions into closer sync.
+
+Fri Dec 20 11:34:18 1991  Fred Fish  (fnf at cygnus.com)
+
+	* configure.in:  Changed svr4 references to sysv4.
+
+Thu Dec 19 15:54:29 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* configure: added -V for version number option.
+
+Wed Dec 18 15:39:34 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* DOC.configure, cfg-paper.texi: revised, updated, and texinfo'd.
+	  renamed from DOC.configure to cfg-paper.texi.
+
+Mon Dec 16 23:05:19 1991  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure, config.subr, config.sub: config.subr is now
+	  config.sub again.
+
+Fri Dec 13 01:17:06 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* configure.texi: new file, in progress.
+
+	* Makefile.in: build info file and install the man page for
+	  configure.
+
+	* configure.man: new file, first cut.
+
+	* configure: find config.subr again now that configuration "none"
+	  has gone.  removed all traces of the -ansi option.  removed all
+	  traces of the -languages option.
+
+	* config.subr: resync from rms.
+
+1991-12-11  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure, config.sub, config.subr: merge config.sub into
+	  config.subr, call the result config.subr, remove config.sub, use
+	  config.subr.
+
+	* Makefile.in: revised install for dir.info.
+
+1991-12-10  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure.in: add decstation host makefile frag.
+
+	* Makefile.in: BISON now bison -y again.  also install-gcc on
+	  install.  clean-gdbm on clean.  infodir belongs in datadir.
+	  Make directories for info install.  Build dir.info here then
+	  install it.
+
+1991-12-09  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* Makefile.in: fix for bad directory tests.
+
+1991-12-07  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure: \{1,2\} appears to be a sysv'ism.  Use a different
+	  regexp.  -srcdir relative was being handled incorrectly.
+
+	* Makefile.in: unwrapped some for loops so that parallel makes
+	  work again and so one can focus one's attention on a particular
+	  package.
+
+1991-12-06  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure: added PWD as a stand in for `pwd` (for speed). use
+	  elif wherever possible.  make -srcdir work without -objdir.
+	  -objdir= commented out.
+
+1991-12-05  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure: +options become --options.  -subdirs commented out.
+	  added -host, -datadir.  Renamed -destdir to -prefix.  Comment in
+	  Makefile now at top of generated Makefile.  Removed cvs log
+	  entries.  added -srcdir.  create .gdbinit only if there is one
+	  in ${srcdir}.
+
+	* Makefile.in: idestdir and ddestdir go away.  Added copyrights
+	  and shift gpl to v2.  Added ChangeLog if it didn't exist. docdir
+	  and mandir now keyed off datadir by default.
+
+1991-11-22  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* Freshly created ChangeLog.
+
+
+Local Variables:
+mode: change-log
+left-margin: 8
+fill-column: 76
+version-control: never
+End:
diff -Naur gdb-6.8/ChangeLog.sts-gdb stsgdb-6.8/ChangeLog.sts-gdb
--- gdb-6.8/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/ChangeLog.sts-gdb	2008-09-11 10:35:42.000000000 +0100
@@ -0,0 +1,17 @@
+2008-07-18  Denis Pilat  <denis.pilat@st.com>
+
+	* libdecnumber: upgraded to latest vresion to fix Solaris compilation problem.
+
+2006-03-23  Denis Pilat  <denis.pilat@st.com>
+
+	* Makefile.def: add pdcurses.
+	* Makefile.in: regenerated.
+
+2006-02-23  Denis Pilat  <denis.pilat@st.com>
+
+	Add the pdcurses directory so that pdcurses.a library can be used by
+	sts-gdb when built for mingw hosts. Pdcurese library replaces the ncurses
+	one available for cygwin and unix.
+	* configure.in: add pdcurses directory in the list of config directories.
+	* configure: Regenerate.
+	* Makefile.in: add pdcurses directory to be configured and made.
diff -Naur gdb-6.8/configure stsgdb-6.8/configure
--- gdb-6.8/configure	2008-02-20 14:26:58.000000000 +0000
+++ stsgdb-6.8/configure	2008-09-11 10:35:42.000000000 +0100
@@ -2011,6 +2011,8 @@
 case "${host}" in
   *-cygwin*)
     configdirs="$configdirs libtermcap" ;;
+  *-mingw*)
+    configdirs="$configdirs pdcurses" ;;
 esac
 
 # A target can indicate whether a language isn't supported for some reason.
diff -Naur gdb-6.8/configure.ac stsgdb-6.8/configure.ac
--- gdb-6.8/configure.ac	2008-03-27 18:27:19.000000000 +0000
+++ stsgdb-6.8/configure.ac	2008-09-11 10:35:42.000000000 +0100
@@ -1,5 +1,6 @@
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 #   2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
+#   Copyright (C) 2007 STMicroelectronics
 #
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -294,6 +295,8 @@
 case "${host}" in
   *-cygwin*)
     configdirs="$configdirs libtermcap" ;;
+  *-mingw*)
+    configdirs="$configdirs pdcurses" ;;
 esac
 
 # A target can indicate whether a language isn't supported for some reason.
diff -Naur gdb-6.8/djunpack.bat stsgdb-6.8/djunpack.bat
--- gdb-6.8/djunpack.bat	2008-03-27 18:27:21.000000000 +0000
+++ stsgdb-6.8/djunpack.bat	2008-09-11 10:35:42.000000000 +0100
@@ -17,8 +17,8 @@
 Rem The following 2 lines need to be changed with each new GDB release, to
 Rem be identical to the name of the top-level directory where the GDB
 Rem distribution unpacks itself.
-set GDBVER=gdb-6.8
-if "%GDBVER%"=="gdb-6.8" GoTo EnvOk
+set GDBVER=insight-6.8
+if "%GDBVER%"=="insight-6.8" GoTo EnvOk
 Rem If their environment space is too small, re-exec with a larger one
 command.com /e:4096 /c %0 %1
 GoTo End
diff -Naur gdb-6.8/etc/configure.info stsgdb-6.8/etc/configure.info
--- gdb-6.8/etc/configure.info	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/etc/configure.info	2008-09-11 10:35:42.000000000 +0100
@@ -1,4 +1,4 @@
-This is configure.info, produced by makeinfo version 4.8 from
+This is configure.info, produced by makeinfo version 4.11 from
 .././etc/configure.texi.
 
 INFO-DIR-SECTION GNU admin
@@ -856,7 +856,7 @@
      AC_OUTPUT(Makefile)
 
    The first four macros in this file, and the last one, were described
-above; see *Note Write configure.in::.  If we omit these macros, then
+above; see *note Write configure.in::.  If we omit these macros, then
 when we run `automake' we will get a reminder that we need them.
 
    The other macros are standard autoconf macros.
@@ -1510,7 +1510,7 @@
      The first three parts of the canonical configuration name.
 
    The shell variables may be used by putting shell code in
-`configure.in'.  For an example, see *Note Using Configuration Names::.
+`configure.in'.  For an example, see *note Using Configuration Names::.
 
 
 File: configure.info,  Node: Specifying the Target,  Next: Using the Target Type,  Prev: Using the Host Type,  Up: Cross Compilation Tools
@@ -2710,64 +2710,64 @@
 
 
 Tag Table:
-Node: Top978
-Node: Introduction1506
-Node: Goals2588
-Node: Tools3312
-Node: History4306
-Node: Building7304
-Node: Getting Started10567
-Node: Write configure.in11080
-Node: Write Makefile.am18331
-Node: Write acconfig.h21508
-Node: Generate files23045
-Node: Getting Started Example25011
-Node: Getting Started Example 125766
-Node: Getting Started Example 227687
-Node: Getting Started Example 330682
-Node: Generate Files in Example33046
-Node: Files34136
-Node: Developer Files34747
-Node: Developer Files Picture35127
-Node: Written Developer Files36415
-Node: Generated Developer Files38967
-Node: Build Files42111
-Node: Build Files Picture42772
-Node: Build Files Description43536
-Node: Support Files45542
-Node: Configuration Names48424
-Node: Configuration Name Definition48924
-Node: Using Configuration Names51247
-Node: Cross Compilation Tools53217
-Node: Cross Compilation Concepts53908
-Node: Host and Target54876
-Node: Using the Host Type56377
-Node: Specifying the Target57726
-Node: Using the Target Type58515
-Node: Cross Tools in the Cygnus Tree61946
-Node: Host and Target Libraries63003
-Node: Target Library Configure Scripts66752
-Node: Make Targets in Cygnus Tree69844
-Node: Target libiberty71192
-Node: Canadian Cross72579
-Node: Canadian Cross Example73420
-Node: Canadian Cross Concepts74539
-Node: Build Cross Host Tools76051
-Node: Build and Host Options77003
-Node: CCross not in Cygnus Tree78789
-Node: CCross in Cygnus Tree79767
-Node: Standard Cygnus CCross80188
-Node: Cross Cygnus CCross81552
-Node: Supporting Canadian Cross84352
-Node: CCross in Configure84967
-Node: CCross in Make88135
-Node: Cygnus Configure89738
-Node: Cygnus Configure Basics90573
-Node: Cygnus Configure in C++ Libraries95251
-Node: Multilibs96258
-Node: Multilibs in gcc97303
-Node: Multilibs in Target Libraries98381
-Node: FAQ102572
-Node: Index106672
+Node: Top979
+Node: Introduction1507
+Node: Goals2589
+Node: Tools3313
+Node: History4307
+Node: Building7305
+Node: Getting Started10568
+Node: Write configure.in11081
+Node: Write Makefile.am18332
+Node: Write acconfig.h21509
+Node: Generate files23046
+Node: Getting Started Example25012
+Node: Getting Started Example 125767
+Node: Getting Started Example 227688
+Node: Getting Started Example 330683
+Node: Generate Files in Example33047
+Node: Files34137
+Node: Developer Files34748
+Node: Developer Files Picture35128
+Node: Written Developer Files36416
+Node: Generated Developer Files38968
+Node: Build Files42112
+Node: Build Files Picture42773
+Node: Build Files Description43537
+Node: Support Files45543
+Node: Configuration Names48425
+Node: Configuration Name Definition48925
+Node: Using Configuration Names51248
+Node: Cross Compilation Tools53218
+Node: Cross Compilation Concepts53909
+Node: Host and Target54877
+Node: Using the Host Type56378
+Node: Specifying the Target57727
+Node: Using the Target Type58516
+Node: Cross Tools in the Cygnus Tree61947
+Node: Host and Target Libraries63004
+Node: Target Library Configure Scripts66753
+Node: Make Targets in Cygnus Tree69845
+Node: Target libiberty71193
+Node: Canadian Cross72580
+Node: Canadian Cross Example73421
+Node: Canadian Cross Concepts74540
+Node: Build Cross Host Tools76052
+Node: Build and Host Options77004
+Node: CCross not in Cygnus Tree78790
+Node: CCross in Cygnus Tree79768
+Node: Standard Cygnus CCross80189
+Node: Cross Cygnus CCross81553
+Node: Supporting Canadian Cross84353
+Node: CCross in Configure84968
+Node: CCross in Make88136
+Node: Cygnus Configure89739
+Node: Cygnus Configure Basics90574
+Node: Cygnus Configure in C++ Libraries95252
+Node: Multilibs96259
+Node: Multilibs in gcc97304
+Node: Multilibs in Target Libraries98382
+Node: FAQ102573
+Node: Index106673
 
 End Tag Table
diff -Naur gdb-6.8/etc/standards.info stsgdb-6.8/etc/standards.info
--- gdb-6.8/etc/standards.info	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/etc/standards.info	2008-09-11 10:35:42.000000000 +0100
@@ -1,4 +1,4 @@
-This is standards.info, produced by makeinfo version 4.8 from
+This is standards.info, produced by makeinfo version 4.11 from
 .././etc/standards.texi.
 
 INFO-DIR-SECTION GNU organization
@@ -3083,7 +3083,7 @@
 of the program.  One combined Index should do for a short manual, but
 sometimes for a complex package it is better to use multiple indices.
 The Texinfo manual includes advice on preparing good index entries, see
-*Note Making Index Entries: (texinfo)Index Entries, and see *Note
+*note Making Index Entries: (texinfo)Index Entries, and see *note
 Defining the Entries of an Index: (texinfo)Indexing Commands.
 
    Don't use Unix man pages as a model for how to write GNU
@@ -4208,8 +4208,8 @@
 
 `lispdir'
      The directory for installing any Emacs Lisp files in this package.
-     By default, it should be `/usr/local/share/emacs/site-lisp', but
-     it should be written as `$(datarootdir)/emacs/site-lisp'.
+     By default, it should be `/usr/local/share/emacs/site-lisp', but it
+     should be written as `$(datarootdir)/emacs/site-lisp'.
 
      If you are using Autoconf, write the default as `@lispdir@'.  In
      order to make `@lispdir@' work, you need the following lines in
@@ -5504,73 +5504,73 @@
 
 
 Tag Table:
-Node: Top804
-Node: Preface2060
-Node: Legal Issues4175
-Node: Reading Non-Free Code4645
-Node: Contributions6375
-Node: Trademarks8613
-Node: Design Advice10248
-Node: Source Language10840
-Node: Compatibility12852
-Node: Using Extensions14480
-Node: Standard C16056
-Node: Conditional Compilation18459
-Node: Program Behavior19857
-Node: Non-GNU Standards20913
-Node: Semantics23194
-Node: Libraries27913
-Node: Errors29158
-Node: User Interfaces31651
-Node: Graphical Interfaces33256
-Node: Command-Line Interfaces34292
-Node: --version36324
-Node: --help42217
-Node: Option Table42771
-Node: Memory Usage57712
-Node: File Usage58743
-Node: Writing C59493
-Node: Formatting60465
-Node: Comments64754
-Node: Syntactic Conventions68306
-Node: Names71768
-Node: System Portability73980
-Node: CPU Portability76870
-Node: System Functions80782
-Node: Internationalization85979
-Node: Character Set89973
-Node: Quote Characters90786
-Node: Mmap92306
-Node: Documentation93014
-Node: GNU Manuals94120
-Node: Doc Strings and Manuals99858
-Node: Manual Structure Details101411
-Node: License for Manuals102829
-Node: Manual Credits103803
-Node: Printed Manuals104196
-Node: NEWS File104882
-Node: Change Logs105560
-Node: Change Log Concepts106314
-Node: Style of Change Logs108403
-Node: Simple Changes110903
-Node: Conditional Changes112345
-Node: Indicating the Part Changed113767
-Node: Man Pages114294
-Node: Reading other Manuals116606
-Node: Managing Releases117397
-Node: Configuration118178
-Node: Makefile Conventions125898
-Node: Makefile Basics126780
-Node: Utilities in Makefiles129954
-Node: Command Variables132099
-Node: DESTDIR135321
-Node: Directory Variables137470
-Node: Standard Targets151963
-Ref: Standard Targets-Footnote-1165478
-Node: Install Command Categories165578
-Node: Releases170111
-Node: References174038
-Node: GNU Free Documentation License179533
-Node: Index201965
+Node: Top805
+Node: Preface2061
+Node: Legal Issues4176
+Node: Reading Non-Free Code4646
+Node: Contributions6376
+Node: Trademarks8614
+Node: Design Advice10249
+Node: Source Language10841
+Node: Compatibility12853
+Node: Using Extensions14481
+Node: Standard C16057
+Node: Conditional Compilation18460
+Node: Program Behavior19858
+Node: Non-GNU Standards20914
+Node: Semantics23195
+Node: Libraries27914
+Node: Errors29159
+Node: User Interfaces31652
+Node: Graphical Interfaces33257
+Node: Command-Line Interfaces34293
+Node: --version36325
+Node: --help42218
+Node: Option Table42772
+Node: Memory Usage57713
+Node: File Usage58744
+Node: Writing C59494
+Node: Formatting60466
+Node: Comments64755
+Node: Syntactic Conventions68307
+Node: Names71769
+Node: System Portability73981
+Node: CPU Portability76871
+Node: System Functions80783
+Node: Internationalization85980
+Node: Character Set89974
+Node: Quote Characters90787
+Node: Mmap92307
+Node: Documentation93015
+Node: GNU Manuals94121
+Node: Doc Strings and Manuals99859
+Node: Manual Structure Details101412
+Node: License for Manuals102830
+Node: Manual Credits103804
+Node: Printed Manuals104197
+Node: NEWS File104883
+Node: Change Logs105561
+Node: Change Log Concepts106315
+Node: Style of Change Logs108404
+Node: Simple Changes110904
+Node: Conditional Changes112346
+Node: Indicating the Part Changed113768
+Node: Man Pages114295
+Node: Reading other Manuals116607
+Node: Managing Releases117398
+Node: Configuration118179
+Node: Makefile Conventions125899
+Node: Makefile Basics126781
+Node: Utilities in Makefiles129955
+Node: Command Variables132100
+Node: DESTDIR135322
+Node: Directory Variables137471
+Node: Standard Targets151964
+Ref: Standard Targets-Footnote-1165479
+Node: Install Command Categories165579
+Node: Releases170112
+Node: References174039
+Node: GNU Free Documentation License179534
+Node: Index201966
 
 End Tag Table
diff -Naur gdb-6.8/gdb/ada-exp.c stsgdb-6.8/gdb/ada-exp.c
--- gdb-6.8/gdb/ada-exp.c	2008-03-27 18:27:13.000000000 +0000
+++ stsgdb-6.8/gdb/ada-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -99,6 +112,7 @@
      OTHERS = 301
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define NULL_PTR 259
 #define CHARLIT 260
@@ -283,9 +297,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 161 "ada-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     struct {
       LONGEST val;
@@ -299,9 +319,10 @@
     struct stoken sval;
     struct block *bval;
     struct internalvar *ivar;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 305 "ada-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 325 "ada-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -312,56 +333,170 @@
 /* Copy the second part of user declarations.  */
 
 
-/* Line 214 of yacc.c.  */
-#line 317 "ada-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 338 "ada-exp.c.tmp"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -371,24 +506,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -406,39 +541,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  55
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   741
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  67
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  31
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  120
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  231
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   301
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -476,7 +605,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,    11,    15,    18,    21,    26,
       31,    32,    40,    41,    48,    55,    59,    61,    63,    65,
@@ -493,8 +622,8 @@
      426
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       68,     0,    -1,    69,    -1,    76,    -1,    69,    60,    76,
       -1,    70,    13,    76,    -1,    70,    11,    -1,    70,    10,
@@ -543,7 +672,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   225,   225,   229,   230,   232,   237,   241,   245,   251,
      270,   270,   282,   286,   288,   296,   307,   317,   321,   324,
@@ -561,9 +690,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "NULL_PTR", "CHARLIT", "FLOAT",
@@ -588,7 +717,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,    61,
@@ -601,7 +730,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    67,    68,    69,    69,    69,    70,    70,    70,    70,
       71,    70,    72,    70,    70,    70,    70,    70,    70,    73,
@@ -619,7 +748,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     3,     3,     2,     2,     4,     4,
        0,     7,     0,     6,     6,     3,     1,     1,     1,     1,
@@ -639,7 +768,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
       84,    85,    88,    86,    87,    89,    91,    17,    84,    84,
       84,    84,    84,    84,    84,     0,     0,     0,     2,    19,
@@ -667,8 +796,8 @@
       11
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,    17,    18,    35,   195,   161,    20,   123,    21,   124,
       23,    24,    25,    26,    27,   118,    28,    29,    30,    31,
@@ -679,7 +808,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -104
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      396,  -104,  -104,  -104,  -104,  -104,    16,  -104,   396,   396,
      137,   137,   396,   396,   282,     2,     6,     9,   -28,   481,
@@ -708,7 +837,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
     -104,  -104,   146,    19,  -104,  -104,     4,    64,   -52,     0,
     -104,  -104,  -104,  -104,  -104,   -59,  -104,  -104,   -15,  -104,
@@ -721,7 +850,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -83
-static const short yytable[] =
+static const yytype_int16 yytable[] =
 {
       22,    54,   119,   120,   169,   112,    33,    57,    58,    55,
       33,    53,    36,    37,    46,     6,    40,    41,    45,    19,
@@ -800,7 +929,7 @@
        0,    85
 };
 
-static const short yycheck[] =
+static const yytype_int16 yycheck[] =
 {
        0,    16,    61,    62,   107,    48,     7,    10,    11,     0,
        7,     9,     8,     9,    14,     9,    12,    13,    14,     0,
@@ -881,7 +1010,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     3,     4,     5,     6,     8,     9,    12,    28,    29,
       30,    32,    36,    37,    56,    58,    64,    68,    69,    70,
@@ -909,22 +1038,6 @@
       61
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -950,30 +1063,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -994,42 +1140,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -1038,45 +1238,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1091,13 +1298,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -1107,45 +1310,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -1155,70 +1360,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+  if (! yyres)
+    return yystrlen (yystr);
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1226,13 +1553,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1241,10 +1568,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1257,14 +1584,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1275,13 +1606,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1292,18 +1629,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1312,9 +1649,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1338,8 +1675,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1352,18 +1688,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1374,21 +1710,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1419,19 +1755,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1446,7 +1780,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1466,22 +1800,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1533,14 +1866,14 @@
 
   case 7:
 #line 242 "ada-exp.y"
-    { write_exp_op_with_string (STRUCTOP_STRUCT, yyvsp[0].sval); }
+    { write_exp_op_with_string (STRUCTOP_STRUCT, (yyvsp[(2) - (2)].sval)); }
     break;
 
   case 8:
 #line 246 "ada-exp.y"
     {
 			  write_exp_elt_opcode (OP_FUNCALL);
-			  write_exp_elt_longcst (yyvsp[-1].lval);
+			  write_exp_elt_longcst ((yyvsp[(3) - (4)].lval));
 			  write_exp_elt_opcode (OP_FUNCALL);
 		        }
     break;
@@ -1548,18 +1881,18 @@
   case 9:
 #line 252 "ada-exp.y"
     {
-			  if (yyvsp[-3].tval != NULL)
+			  if ((yyvsp[(1) - (4)].tval) != NULL)
 			    {
-			      if (yyvsp[-1].lval != 1)
+			      if ((yyvsp[(3) - (4)].lval) != 1)
 				error (_("Invalid conversion"));
 			      write_exp_elt_opcode (UNOP_CAST);
-			      write_exp_elt_type (yyvsp[-3].tval);
+			      write_exp_elt_type ((yyvsp[(1) - (4)].tval));
 			      write_exp_elt_opcode (UNOP_CAST);
 			    }
 			  else
 			    {
 			      write_exp_elt_opcode (OP_FUNCALL);
-			      write_exp_elt_longcst (yyvsp[-1].lval);
+			      write_exp_elt_longcst ((yyvsp[(3) - (4)].lval));
 			      write_exp_elt_opcode (OP_FUNCALL);
 			    }
 			}
@@ -1567,24 +1900,24 @@
 
   case 10:
 #line 270 "ada-exp.y"
-    { type_qualifier = yyvsp[-2].tval; }
+    { type_qualifier = (yyvsp[(1) - (3)].tval); }
     break;
 
   case 11:
 #line 272 "ada-exp.y"
     {
-			  if (yyvsp[-6].tval == NULL)
+			  if ((yyvsp[(1) - (7)].tval) == NULL)
 			    error (_("Type required for qualification"));
 			  write_exp_elt_opcode (UNOP_QUAL);
-			  write_exp_elt_type (yyvsp[-6].tval);
+			  write_exp_elt_type ((yyvsp[(1) - (7)].tval));
 			  write_exp_elt_opcode (UNOP_QUAL);
-			  type_qualifier = yyvsp[-4].tval;
+			  type_qualifier = (yyvsp[(3) - (7)].tval);
 			}
     break;
 
   case 12:
 #line 282 "ada-exp.y"
-    { yyval.tval = type_qualifier; }
+    { (yyval.tval) = type_qualifier; }
     break;
 
   case 13:
@@ -1594,7 +1927,7 @@
 
   case 14:
 #line 289 "ada-exp.y"
-    { if (yyvsp[-5].tval == NULL) 
+    { if ((yyvsp[(1) - (6)].tval) == NULL) 
                             write_exp_elt_opcode (TERNOP_SLICE);
 			  else
 			    error (_("Cannot slice a type"));
@@ -1608,10 +1941,10 @@
 
   case 16:
 #line 308 "ada-exp.y"
-    { if (yyvsp[0].tval != NULL)
+    { if ((yyvsp[(1) - (1)].tval) != NULL)
 			    {
 			      write_exp_elt_opcode (OP_TYPE);
-			      write_exp_elt_type (yyvsp[0].tval);
+			      write_exp_elt_type ((yyvsp[(1) - (1)].tval));
 			      write_exp_elt_opcode (OP_TYPE);
 			    }
 			}
@@ -1619,7 +1952,7 @@
 
   case 17:
 #line 318 "ada-exp.y"
-    { write_dollar_variable (yyvsp[0].sval); }
+    { write_dollar_variable ((yyvsp[(1) - (1)].sval)); }
     break;
 
   case 20:
@@ -1644,36 +1977,36 @@
 
   case 24:
 #line 343 "ada-exp.y"
-    { yyval.lval = 0; }
+    { (yyval.lval) = 0; }
     break;
 
   case 25:
 #line 347 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 26:
 #line 349 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 27:
 #line 351 "ada-exp.y"
-    { yyval.lval = yyvsp[-2].lval + 1; }
+    { (yyval.lval) = (yyvsp[(1) - (3)].lval) + 1; }
     break;
 
   case 28:
 #line 353 "ada-exp.y"
-    { yyval.lval = yyvsp[-4].lval + 1; }
+    { (yyval.lval) = (yyvsp[(1) - (5)].lval) + 1; }
     break;
 
   case 29:
 #line 358 "ada-exp.y"
     { 
-			  if (yyvsp[-2].tval == NULL)
+			  if ((yyvsp[(2) - (4)].tval) == NULL)
 			    error (_("Type required within braces in coercion"));
 			  write_exp_elt_opcode (UNOP_MEMVAL);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_MEMVAL);
 			}
     break;
@@ -1746,7 +2079,7 @@
   case 44:
 #line 423 "ada-exp.y"
     { write_exp_elt_opcode (BINOP_IN_BOUNDS);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(5) - (5)].lval));
 			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
 			}
     break;
@@ -1754,10 +2087,10 @@
   case 45:
 #line 428 "ada-exp.y"
     { 
-			  if (yyvsp[0].tval == NULL)
+			  if ((yyvsp[(3) - (3)].tval) == NULL)
 			    error (_("Right operand of 'in' must be type"));
 			  write_exp_elt_opcode (UNOP_IN_RANGE);
-		          write_exp_elt_type (yyvsp[0].tval);
+		          write_exp_elt_type ((yyvsp[(3) - (3)].tval));
 		          write_exp_elt_opcode (UNOP_IN_RANGE);
 			}
     break;
@@ -1772,7 +2105,7 @@
   case 47:
 #line 440 "ada-exp.y"
     { write_exp_elt_opcode (BINOP_IN_BOUNDS);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(6) - (6)].lval));
 			  write_exp_elt_opcode (BINOP_IN_BOUNDS);
 		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
 			}
@@ -1781,10 +2114,10 @@
   case 48:
 #line 446 "ada-exp.y"
     { 
-			  if (yyvsp[0].tval == NULL)
+			  if ((yyvsp[(4) - (4)].tval) == NULL)
 			    error (_("Right operand of 'in' must be type"));
 			  write_exp_elt_opcode (UNOP_IN_RANGE);
-		          write_exp_elt_type (yyvsp[0].tval);
+		          write_exp_elt_type ((yyvsp[(4) - (4)].tval));
 		          write_exp_elt_opcode (UNOP_IN_RANGE);
 		          write_exp_elt_opcode (UNOP_LOGICAL_NOT);
 			}
@@ -1871,19 +2204,19 @@
 
   case 70:
 #line 527 "ada-exp.y"
-    { write_int (yyvsp[0].lval, type_int ());
+    { write_int ((yyvsp[(3) - (3)].lval), type_int ());
 			  write_exp_elt_opcode (OP_ATR_FIRST); }
     break;
 
   case 71:
 #line 530 "ada-exp.y"
-    { write_int (yyvsp[0].lval, type_int ());
+    { write_int ((yyvsp[(3) - (3)].lval), type_int ());
 			  write_exp_elt_opcode (OP_ATR_LAST); }
     break;
 
   case 72:
 #line 533 "ada-exp.y"
-    { write_int (yyvsp[0].lval, type_int ());
+    { write_int ((yyvsp[(3) - (3)].lval), type_int ());
 			  write_exp_elt_opcode (OP_ATR_LENGTH); }
     break;
 
@@ -1924,21 +2257,21 @@
 
   case 80:
 #line 552 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 81:
 #line 554 "ada-exp.y"
-    { yyval.lval = yyvsp[-1].typed_val.val; }
+    { (yyval.lval) = (yyvsp[(2) - (3)].typed_val).val; }
     break;
 
   case 82:
 #line 559 "ada-exp.y"
     { 
-			  if (yyvsp[0].tval == NULL)
+			  if ((yyvsp[(1) - (1)].tval) == NULL)
 			    error (_("Prefix must be type"));
 			  write_exp_elt_opcode (OP_TYPE);
-			  write_exp_elt_type (yyvsp[0].tval);
+			  write_exp_elt_type ((yyvsp[(1) - (1)].tval));
 			  write_exp_elt_opcode (OP_TYPE); }
     break;
 
@@ -1951,22 +2284,22 @@
 
   case 85:
 #line 577 "ada-exp.y"
-    { write_int ((LONGEST) yyvsp[0].typed_val.val, yyvsp[0].typed_val.type); }
+    { write_int ((LONGEST) (yyvsp[(1) - (1)].typed_val).val, (yyvsp[(1) - (1)].typed_val).type); }
     break;
 
   case 86:
 #line 581 "ada-exp.y"
-    { write_int (convert_char_literal (type_qualifier, yyvsp[0].typed_val.val),
+    { write_int (convert_char_literal (type_qualifier, (yyvsp[(1) - (1)].typed_val).val),
 			       (type_qualifier == NULL) 
-			       ? yyvsp[0].typed_val.type : type_qualifier);
+			       ? (yyvsp[(1) - (1)].typed_val).type : type_qualifier);
 		  }
     break;
 
   case 87:
 #line 588 "ada-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
-			  write_exp_elt_type (yyvsp[0].typed_val_float.type);
-			  write_exp_elt_dblcst (yyvsp[0].typed_val_float.dval);
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_float).type);
+			  write_exp_elt_dblcst ((yyvsp[(1) - (1)].typed_val_float).dval);
 			  write_exp_elt_opcode (OP_DOUBLE);
 			}
     break;
@@ -1979,7 +2312,7 @@
   case 89:
 #line 600 "ada-exp.y"
     { 
-			  write_exp_op_with_string (OP_STRING, yyvsp[0].sval);
+			  write_exp_op_with_string (OP_STRING, (yyvsp[(1) - (1)].sval));
 			}
     break;
 
@@ -1990,72 +2323,72 @@
 
   case 91:
 #line 610 "ada-exp.y"
-    { yyval.tval = write_var_or_type (NULL, yyvsp[0].sval); }
+    { (yyval.tval) = write_var_or_type (NULL, (yyvsp[(1) - (1)].sval)); }
     break;
 
   case 92:
 #line 612 "ada-exp.y"
-    { yyval.tval = write_var_or_type (yyvsp[-1].bval, yyvsp[0].sval); }
+    { (yyval.tval) = write_var_or_type ((yyvsp[(1) - (2)].bval), (yyvsp[(2) - (2)].sval)); }
     break;
 
   case 93:
 #line 614 "ada-exp.y"
     { 
-			  yyval.tval = write_var_or_type (NULL, yyvsp[-1].sval);
-			  if (yyval.tval == NULL)
+			  (yyval.tval) = write_var_or_type (NULL, (yyvsp[(1) - (2)].sval));
+			  if ((yyval.tval) == NULL)
 			    write_exp_elt_opcode (UNOP_ADDR);
 			  else
-			    yyval.tval = lookup_pointer_type (yyval.tval);
+			    (yyval.tval) = lookup_pointer_type ((yyval.tval));
 			}
     break;
 
   case 94:
 #line 622 "ada-exp.y"
     { 
-			  yyval.tval = write_var_or_type (yyvsp[-2].bval, yyvsp[-1].sval);
-			  if (yyval.tval == NULL)
+			  (yyval.tval) = write_var_or_type ((yyvsp[(1) - (3)].bval), (yyvsp[(2) - (3)].sval));
+			  if ((yyval.tval) == NULL)
 			    write_exp_elt_opcode (UNOP_ADDR);
 			  else
-			    yyval.tval = lookup_pointer_type (yyval.tval);
+			    (yyval.tval) = lookup_pointer_type ((yyval.tval));
 			}
     break;
 
   case 95:
 #line 633 "ada-exp.y"
-    { yyval.bval = block_lookup (NULL, yyvsp[-1].sval.ptr); }
+    { (yyval.bval) = block_lookup (NULL, (yyvsp[(1) - (2)].sval).ptr); }
     break;
 
   case 96:
 #line 635 "ada-exp.y"
-    { yyval.bval = block_lookup (yyvsp[-2].bval, yyvsp[-1].sval.ptr); }
+    { (yyval.bval) = block_lookup ((yyvsp[(1) - (3)].bval), (yyvsp[(2) - (3)].sval).ptr); }
     break;
 
   case 97:
 #line 640 "ada-exp.y"
     {
 			  write_exp_elt_opcode (OP_AGGREGATE);
-			  write_exp_elt_longcst (yyvsp[-1].lval);
+			  write_exp_elt_longcst ((yyvsp[(2) - (3)].lval));
 			  write_exp_elt_opcode (OP_AGGREGATE);
 		        }
     break;
 
   case 98:
 #line 648 "ada-exp.y"
-    { yyval.lval = yyvsp[0].lval; }
+    { (yyval.lval) = (yyvsp[(1) - (1)].lval); }
     break;
 
   case 99:
 #line 650 "ada-exp.y"
     { write_exp_elt_opcode (OP_POSITIONAL);
-			  write_exp_elt_longcst (yyvsp[-1].lval);
+			  write_exp_elt_longcst ((yyvsp[(1) - (2)].lval));
 			  write_exp_elt_opcode (OP_POSITIONAL);
-			  yyval.lval = yyvsp[-1].lval + 1;
+			  (yyval.lval) = (yyvsp[(1) - (2)].lval) + 1;
 			}
     break;
 
   case 100:
 #line 656 "ada-exp.y"
-    { yyval.lval = yyvsp[-1].lval + yyvsp[0].lval; }
+    { (yyval.lval) = (yyvsp[(1) - (2)].lval) + (yyvsp[(2) - (2)].lval); }
     break;
 
   case 101:
@@ -2063,32 +2396,32 @@
     { write_exp_elt_opcode (OP_POSITIONAL);
 			  write_exp_elt_longcst (0);
 			  write_exp_elt_opcode (OP_POSITIONAL);
-			  yyval.lval = 1;
+			  (yyval.lval) = 1;
 			}
     break;
 
   case 102:
 #line 667 "ada-exp.y"
     { write_exp_elt_opcode (OP_POSITIONAL);
-			  write_exp_elt_longcst (yyvsp[-2].lval);
+			  write_exp_elt_longcst ((yyvsp[(1) - (3)].lval));
 			  write_exp_elt_opcode (OP_POSITIONAL);
-			  yyval.lval = yyvsp[-2].lval + 1; 
+			  (yyval.lval) = (yyvsp[(1) - (3)].lval) + 1; 
 			}
     break;
 
   case 103:
 #line 675 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 104:
 #line 676 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 105:
 #line 678 "ada-exp.y"
-    { yyval.lval = yyvsp[0].lval + 1; }
+    { (yyval.lval) = (yyvsp[(3) - (3)].lval) + 1; }
     break;
 
   case 106:
@@ -2100,24 +2433,24 @@
 #line 687 "ada-exp.y"
     {
 			  write_exp_elt_opcode (OP_CHOICES);
-			  write_exp_elt_longcst (yyvsp[0].lval);
+			  write_exp_elt_longcst ((yyvsp[(1) - (1)].lval));
 			  write_exp_elt_opcode (OP_CHOICES);
 		        }
     break;
 
   case 108:
 #line 701 "ada-exp.y"
-    { write_name_assoc (yyvsp[-1].sval); }
+    { write_name_assoc ((yyvsp[(1) - (2)].sval)); }
     break;
 
   case 109:
 #line 702 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 110:
 #line 704 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 111:
@@ -2129,22 +2462,22 @@
 
   case 112:
 #line 709 "ada-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 113:
 #line 711 "ada-exp.y"
-    { write_name_assoc (yyvsp[-1].sval); }
+    { write_name_assoc ((yyvsp[(1) - (2)].sval)); }
     break;
 
   case 114:
 #line 712 "ada-exp.y"
-    { yyval.lval = yyvsp[0].lval + 1; }
+    { (yyval.lval) = (yyvsp[(4) - (4)].lval) + 1; }
     break;
 
   case 115:
 #line 714 "ada-exp.y"
-    { yyval.lval = yyvsp[0].lval + 1; }
+    { (yyval.lval) = (yyvsp[(3) - (3)].lval) + 1; }
     break;
 
   case 116:
@@ -2154,7 +2487,7 @@
 
   case 117:
 #line 717 "ada-exp.y"
-    { yyval.lval = yyvsp[0].lval + 1; }
+    { (yyval.lval) = (yyvsp[(6) - (6)].lval) + 1; }
     break;
 
   case 118:
@@ -2173,15 +2506,14 @@
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2512 "ada-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 2180 "ada-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -2210,99 +2542,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2312,15 +2610,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2349,9 +2649,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2359,11 +2660,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2383,21 +2685,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -3199,4 +3519,3 @@
 struct stoken (*dummy_string_to_ada_operator) (struct stoken) 
      = string_to_operator;
 
-
diff -Naur gdb-6.8/gdb/ada-lex.c stsgdb-6.8/gdb/ada-lex.c
--- gdb-6.8/gdb/ada-lex.c	2008-03-27 18:27:12.000000000 +0000
+++ stsgdb-6.8/gdb/ada-lex.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,32 +1,93 @@
 #line 2 "ada-lex.c"
-/* A lexical scanner generated by flex */
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
- */
+#line 4 "ada-lex.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
-#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
 
+/* end standard C headers. */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
 #endif
 
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
 
-#ifdef __cplusplus
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
 
-#include <stdlib.h>
+#endif /* ! FLEXINT_H */
 
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
+#ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
@@ -35,34 +96,17 @@
 
 #if __STDC__
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
 #endif	/* __STDC__ */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -77,71 +121,75 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE yyrestart(yyin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
 
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
 
 extern int yyleng;
+
 extern FILE *yyin, *yyout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
 		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
-typedef unsigned int yy_size_t;
 
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -178,12 +226,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -197,28 +249,38 @@
 	 * just pointing yyin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
 /* yy_hold_char holds the character lost when yytext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
 int yyleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
+static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
 /* Flag which is used to allow yywrap()'s to do buffer switches
@@ -226,66 +288,92 @@
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yyxrealloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyxrealloc (void *,yy_size_t  );
+void yyfree (void *  );
 
 #define yy_new_buffer yy_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
 
 typedef unsigned char YY_CHAR;
+
 FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
 typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
 extern char *yytext;
 #define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yytext_ptr) = yy_bp; \
+	yyleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+	(yy_c_buf_p) = yy_cp;
 
 #define YY_NUM_RULES 51
 #define YY_END_OF_BUFFER 52
-static yyconst short int yy_accept[182] =
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[182] =
     {   0,
         0,    0,    0,    0,   52,   50,    1,    1,   15,   49,
        39,   50,   41,   42,   39,   40,   39,   39,   39,    4,
@@ -309,7 +397,7 @@
         0
     } ;
 
-static yyconst int yy_ec[256] =
+static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -341,7 +429,7 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst int yy_meta[49] =
+static yyconst flex_int32_t yy_meta[49] =
     {   0,
         1,    2,    3,    4,    5,    6,    7,    8,    5,    9,
         5,    5,    5,    5,    5,    5,   10,    5,   11,   11,
@@ -350,7 +438,7 @@
        17,   17,   17,   17,   17,   17,   17,   17
     } ;
 
-static yyconst short int yy_base[203] =
+static yyconst flex_int16_t yy_base[203] =
     {   0,
         0,    0,  575,  568,  573,  712,  712,  712,   43,    0,
       712,   70,  712,  712,  559,  712,  554,  117,  544,  116,
@@ -377,7 +465,7 @@
       684,  695
     } ;
 
-static yyconst short int yy_def[203] =
+static yyconst flex_int16_t yy_def[203] =
     {   0,
       181,    1,    1,    1,  181,  181,  181,  181,  182,  183,
       181,  181,  181,  181,  181,  181,  181,  184,  181,  181,
@@ -404,7 +492,7 @@
       181,  181
     } ;
 
-static yyconst short int yy_nxt[761] =
+static yyconst flex_int16_t yy_nxt[761] =
     {   0,
         6,    7,    8,    7,    6,    9,    6,   10,   11,   12,
        13,   14,   15,   11,   16,   17,   18,   19,   20,   21,
@@ -491,7 +579,7 @@
       181,  181,  181,  181,  181,  181,  181,  181,  181,  181
     } ;
 
-static yyconst short int yy_chk[761] =
+static yyconst flex_int16_t yy_chk[761] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -581,6 +669,9 @@
 static yy_state_type yy_last_accepting_state;
 static char *yy_last_accepting_cpos;
 
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
@@ -590,7 +681,6 @@
 #define YY_RESTORE_YY_MORE_OFFSET
 char *yytext;
 #line 1 "ada-lex.l"
-#define INITIAL 0
 /* FLEX lexer for Ada expressions, for GDB.
    Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2007, 2008
    Free Software Foundation, Inc.
@@ -648,9 +738,54 @@
 
 static int find_dot_all (const char *);
 
+
+#line 743 "ada-lex.c"
+
+#define INITIAL 0
 #define BEFORE_QUAL_QUOTE 1
 
-#line 654 "ada-lex.c"
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -658,65 +793,30 @@
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+extern "C" int yywrap (void );
 #else
-extern int yywrap YY_PROTO(( void ));
-#endif
+extern int yywrap (void );
 #endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
 #endif
 
+    static void yyunput (int c,char *buf_ptr  );
+    
 #ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+static int yy_flex_strlen (yyconst char * );
 #endif
 
 #ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
 
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+static int input (void );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -725,7 +825,6 @@
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
@@ -738,9 +837,10 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
-		int c = '*', n; \
+		int c = '*'; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -750,9 +850,22 @@
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -773,12 +886,18 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
  * have been set up.
@@ -795,27 +914,29 @@
 #define YY_RULE_SETUP \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
-	register char *yy_cp = NULL, *yy_bp = NULL;
+	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
+    
 #line 82 "ada-lex.l"
 
 
-#line 808 "ada-lex.c"
+#line 929 "ada-lex.c"
 
-	if ( yy_init )
+	if ( !(yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
 		if ( ! yyin )
 			yyin = stdin;
@@ -823,34 +944,36 @@
 		if ( ! yyout )
 			yyout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		yy_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
 		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 yy_match:
 		do
 			{
 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
 			if ( yy_accept[yy_current_state] )
 				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
 				}
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
@@ -867,27 +990,26 @@
 		yy_act = yy_accept[yy_current_state];
 		if ( yy_act == 0 )
 			{ /* have to back up */
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			yy_act = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 			case 0: /* must back up */
 			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos;
-			yy_current_state = yy_last_accepting_state;
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos);
+			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
+/* rule 1 can match eol */
 YY_RULE_SETUP
 #line 84 "ada-lex.l"
 { }
@@ -1082,6 +1204,7 @@
 	YY_BREAK
 /* ATTRIBUTES */
 case 30:
+/* rule 30 can match eol */
 YY_RULE_SETUP
 #line 183 "ada-lex.l"
 { return processAttribute (yytext+1); }
@@ -1167,11 +1290,13 @@
 		}
 	YY_BREAK
 case 43:
+/* rule 43 can match eol */
 YY_RULE_SETUP
 #line 223 "ada-lex.l"
 { return DOT_ALL; }
 	YY_BREAK
 case 44:
+/* rule 44 can match eol */
 YY_RULE_SETUP
 #line 225 "ada-lex.l"
 {
@@ -1180,6 +1305,7 @@
 		}
 	YY_BREAK
 case 45:
+/* rule 45 can match eol */
 YY_RULE_SETUP
 #line 230 "ada-lex.l"
 {
@@ -1198,6 +1324,7 @@
 	YY_BREAK
 /* GDB EXPRESSION CONSTRUCTS  */
 case 46:
+/* rule 46 can match eol */
 YY_RULE_SETUP
 #line 247 "ada-lex.l"
 {
@@ -1237,7 +1364,7 @@
 #line 268 "ada-lex.l"
 YY_FATAL_ERROR( "flex scanner jammed" );
 	YY_BREAK
-#line 1241 "ada-lex.c"
+#line 1368 "ada-lex.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(BEFORE_QUAL_QUOTE):
 	yyterminate();
@@ -1245,26 +1372,26 @@
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
 			 * just pointed yyin at a new source and called
 			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -1274,13 +1401,13 @@
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
-			yy_current_state = yy_get_previous_state();
+			yy_current_state = yy_get_previous_state(  );
 
 			/* Okay, we're now positioned to make the NUL
 			 * transition.  We couldn't have
@@ -1293,30 +1420,30 @@
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
 
-		else switch ( yy_get_next_buffer() )
+		else switch ( yy_get_next_buffer(  ) )
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap() )
+				if ( yywrap( ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -1327,7 +1454,7 @@
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -1335,30 +1462,30 @@
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -1369,8 +1496,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of yylex */
-
+} /* end of yylex */
 
 /* yy_get_next_buffer - try to read in a new buffer
  *
@@ -1379,21 +1505,20 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -1413,34 +1538,30 @@
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_current_buffer->yy_n_chars = yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
 
 			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
@@ -1453,8 +1574,7 @@
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yyxrealloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
+					yyxrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
@@ -1464,35 +1584,35 @@
 				YY_FATAL_ERROR(
 				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
 						number_to_move - 1;
-#endif
+
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
 
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
+			yyrestart(yyin  );
 			}
 
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -1500,32 +1620,31 @@
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
 	return ret_val;
-	}
-
+}
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
-	{
+    static yy_state_type yy_get_previous_state (void)
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
 
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
 			}
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
@@ -1537,30 +1656,23 @@
 		}
 
 	return yy_current_state;
-	}
-
+}
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
 	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
+    	register char *yy_cp = (yy_c_buf_p);
 
 	register YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
-		yy_last_accepting_state = yy_current_state;
-		yy_last_accepting_cpos = yy_cp;
+		(yy_last_accepting_state) = yy_current_state;
+		(yy_last_accepting_cpos) = yy_cp;
 		}
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
@@ -1572,81 +1684,73 @@
 	yy_is_jam = (yy_current_state == 181);
 
 	return yy_is_jam ? 0 : yy_current_state;
-	}
-
+}
 
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
 
 	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+	*yy_cp = (yy_hold_char);
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
 		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			*--dest = *--source;
 
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
-		yy_current_buffer->yy_n_chars =
-			yy_n_chars = yy_current_buffer->yy_buf_size;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
 		}
 
 	*--yy_cp = (char) c;
 
-
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
 
 #ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
-	{
-	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
 
-			switch ( yy_get_next_buffer() )
+			switch ( yy_get_next_buffer(  ) )
 				{
 				case EOB_ACT_LAST_MATCH:
 					/* This happens because yy_g_n_b()
@@ -1660,16 +1764,16 @@
 					 */
 
 					/* Reset buffer status. */
-					yyrestart( yyin );
+					yyrestart(yyin );
 
-					/* fall through */
+					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap() )
+					if ( yywrap( ) )
 						return EOF;
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -1679,90 +1783,92 @@
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
 	return c;
-	}
-#endif /* YY_NO_INPUT */
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+}
+#endif	/* ifndef YY_NO_INPUT */
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
 	}
 
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
 	 * is looked at is after yywrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
+	(yy_did_buffer_switch_on_eof) = 1;
+}
 
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
 
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
 	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
@@ -1771,75 +1877,75 @@
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
 	if ( ! b->yy_ch_buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+	yy_init_buffer(b,file );
 
 	return b;
-	}
-
+}
 
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
-
+		yyfree((void *) b->yy_ch_buf  );
 
+	yyfree((void *) b  );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
-	{
-	yy_flush_buffer( b );
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
 
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
 
-	{
-	if ( ! b )
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
 		return;
 
 	b->yy_n_chars = 0;
@@ -1856,29 +1962,121 @@
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
 	}
+}
 
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate xrealloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
 
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
 
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyxrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
 		return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
@@ -1892,56 +2090,51 @@
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+	yy_switch_to_buffer(b  );
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
-#else
-YY_BUFFER_STATE yy_scan_string( yy_str )
-yyconst char *yy_str;
-#endif
-	{
-	int len;
-	for ( len = 0; yy_str[len]; ++len )
-		;
-
-	return yy_scan_bytes( yy_str, len );
-	}
-#endif
+}
 
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param str a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
 
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
 	int i;
-
+    
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
+	b = yy_scan_buffer(buf,n );
 	if ( ! b )
 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
 
@@ -1951,148 +2144,196 @@
 	b->yy_is_our_buffer = 1;
 
 	return b;
-	}
-#endif
-
+}
 
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
 #endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
+/* Redefine yyless() so it works in section 3 code. */
 
-		else
-			yy_start_stack = (int *) yyxrealloc(
-					(void *) yy_start_stack, new_size );
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
 
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
+/* Accessor  methods (get/set functions) to struct members. */
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
 
-	BEGIN(new_state);
-	}
-#endif
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
 
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
 
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
 
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
+/** Get the current token.
+ * 
+ */
 
+char *yyget_text  (void)
+{
+        return yytext;
+}
 
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
 
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
 
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
 
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
 
-/* Redefine yyless() so it works in section 3 code. */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
 
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
 
+    return 0;
+}
 
-/* Internal utility routines. */
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
 	register int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
-	}
+}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
+static int yy_flex_strlen (yyconst char * s )
+{
 	register int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
-	}
+}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
+void *yyalloc (yy_size_t  size )
+{
 	return (void *) xmalloc( size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void *yyxrealloc( void *ptr, yy_size_t size )
-#else
-static void *yyxrealloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
+void *yyxrealloc  (void * ptr, yy_size_t  size )
+{
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -2101,28 +2342,19 @@
 	 * as though doing an assignment.
 	 */
 	return (void *) xrealloc( (char *) ptr, size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyxrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
 #line 268 "ada-lex.l"
 
 
+
 #include <ctype.h>
 #include "gdb_string.h"
 
@@ -2452,3 +2684,4 @@
 { 
   (dummy_function) yyunput
 };
+
diff -Naur gdb-6.8/gdb/breakpoint.c stsgdb-6.8/gdb/breakpoint.c
--- gdb-6.8/gdb/breakpoint.c	2008-02-26 08:14:11.000000000 +0000
+++ stsgdb-6.8/gdb/breakpoint.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -152,10 +153,6 @@
 
 static void create_overlay_event_breakpoint (char *);
 
-static int hw_breakpoint_used_count (void);
-
-static int hw_watchpoint_used_count (enum bptype, int *);
-
 static void hbreak_command (char *, int);
 
 static void thbreak_command (char *, int);
@@ -846,7 +843,8 @@
   for (loc = b->loc; loc;)
     {
       struct bp_location *loc_next = loc->next;
-      remove_breakpoint (loc, mark_uninserted);
+      if (loc->inserted)
+	remove_breakpoint (loc, mark_uninserted);
       xfree (loc);
       loc = loc_next;
     }
@@ -2797,15 +2795,7 @@
 		/* Stop.  */
 		break;
 	      case WP_VALUE_CHANGED:
-		if (b->type == bp_read_watchpoint)
-		  {
-		    /* Don't stop: read watchpoints shouldn't fire if
-		       the value has changed.  This is for targets
-		       which cannot set read-only watchpoints.  */
-		    bs->print_it = print_it_noop;
-		    bs->stop = 0;
-		    continue;
-		  }
+		/* Stop.  */
 		++(b->hit_count);
 		break;
 	      case WP_VALUE_NOT_CHANGED:
@@ -4597,7 +4587,7 @@
   mention (b);
 }
 
-static int
+int
 hw_breakpoint_used_count (void)
 {
   struct breakpoint *b;
@@ -4612,7 +4602,7 @@
   return i;
 }
 
-static int
+int
 hw_watchpoint_used_count (enum bptype type, int *other_type_used)
 {
   struct breakpoint *b;
@@ -4628,7 +4618,7 @@
 	else if ((b->type == bp_hardware_watchpoint ||
 		  b->type == bp_read_watchpoint ||
 		  b->type == bp_access_watchpoint))
-	  *other_type_used = 1;
+	  (*other_type_used)++;
       }
   }
   return i;
@@ -5765,7 +5755,8 @@
 	error (_("Target does not support this type of hardware watchpoint."));
 
       if (target_resources_ok < 0 && bp_type != bp_hardware_watchpoint)
-	error (_("Target can only support one kind of HW watchpoint at a time."));
+	error (_("\
+Target watch resources have been allocated for other watchpoints."));
     }
 
   /* Change the type of breakpoint to an ordinary watchpoint if a hardware
diff -Naur gdb-6.8/gdb/breakpoint.h stsgdb-6.8/gdb/breakpoint.h
--- gdb-6.8/gdb/breakpoint.h	2008-02-01 16:24:46.000000000 +0000
+++ stsgdb-6.8/gdb/breakpoint.h	2008-09-11 10:35:35.000000000 +0100
@@ -1,6 +1,7 @@
 /* Data structures associated with breakpoints in GDB.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
    2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -854,4 +855,11 @@
    target.  */
 int watchpoints_triggered (struct target_waitstatus *);
 
+/* Return number of H/W breakpoints in use.  */
+extern int hw_breakpoint_used_count (void);
+
+/* Return number of H/W watchpoints in use of given type and number of other
+   types of H/W watchpoint in use.  */
+extern int hw_watchpoint_used_count (enum bptype, int *);
+
 #endif /* !defined (BREAKPOINT_H) */
diff -Naur gdb-6.8/gdb/buildsym.c stsgdb-6.8/gdb/buildsym.c
--- gdb-6.8/gdb/buildsym.c	2008-01-01 22:53:09.000000000 +0000
+++ stsgdb-6.8/gdb/buildsym.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -584,6 +585,11 @@
 {
   struct subfile *subfile;
 
+  /* Convert cygwin path into std windows path, 
+     allocating new strings for name and dirname.  */
+  CYGPATH(name);
+  CYGPATH(dirname);
+
   /* See if this subfile is already known as a subfile of the current
      main source file.  */
 
@@ -604,6 +610,9 @@
       if (FILENAME_CMP (subfile_name, name) == 0)
 	{
 	  current_subfile = subfile;
+	  /* Free previously allocated strings.  */
+	  CYGPATH_FREE(name);
+	  CYGPATH_FREE(dirname);
 	  if (subfile_name != subfile->name)
 	    xfree (subfile_name);
 	  return;
@@ -627,6 +636,10 @@
   subfile->dirname =
     (dirname == NULL) ? NULL : savestring (dirname, strlen (dirname));
 
+  /* Free previously allocated strings */
+  CYGPATH_FREE(name);
+  CYGPATH_FREE(dirname);
+
   /* Initialize line-number recording for this subfile.  */
   subfile->line_vector = NULL;
 
diff -Naur gdb-6.8/gdb/c-exp.c stsgdb-6.8/gdb/c-exp.c
--- gdb-6.8/gdb/c-exp.c	2008-03-27 18:27:11.000000000 +0000
+++ stsgdb-6.8/gdb/c-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -97,6 +110,7 @@
      FILENAME = 299
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define FLOAT 259
 #define DECFLOAT 260
@@ -238,9 +252,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 125 "c-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     struct {
       LONGEST val;
@@ -266,9 +286,10 @@
 
     struct type **tvec;
     int *ivec;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 272 "c-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 292 "c-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -283,56 +304,170 @@
 static int parse_number (char *, int, int, YYSTYPE *);
 
 
-/* Line 214 of yacc.c.  */
-#line 288 "c-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 309 "c-exp.c.tmp"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -342,24 +477,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -377,39 +512,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  97
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   771
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  69
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  31
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  160
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  242
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   299
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -446,7 +575,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,     9,    11,    15,    18,    21,
       24,    27,    30,    33,    36,    39,    42,    45,    48,    52,
@@ -467,8 +596,8 @@
      500
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       70,     0,    -1,    72,    -1,    71,    -1,    90,    -1,    73,
       -1,    72,    30,    73,    -1,    50,    73,    -1,    38,    73,
@@ -524,7 +653,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   237,   237,   238,   241,   248,   249,   254,   258,   262,
      266,   270,   274,   278,   282,   286,   290,   294,   298,   304,
@@ -546,9 +675,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "FLOAT", "DECFLOAT", "STRING",
@@ -575,7 +704,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -588,7 +717,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    69,    70,    70,    71,    72,    72,    73,    73,    73,
       73,    73,    73,    73,    73,    73,    73,    73,    73,    73,
@@ -610,7 +739,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     1,     1,     3,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     3,     3,
@@ -634,7 +763,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
       79,    58,    60,    61,    65,   159,   100,    59,     0,     0,
        0,     0,    79,   134,     0,     0,   136,   102,   103,   101,
@@ -663,8 +792,8 @@
       98,   147
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,    38,    39,    93,    41,   182,    42,   128,   188,    43,
       44,    45,   132,    46,    47,    48,   137,   201,   202,   203,
@@ -675,7 +804,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -142
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      268,  -142,  -142,  -142,  -142,  -142,  -142,  -142,     7,     7,
        7,     7,   332,    33,     7,     7,    64,   116,   125,  -142,
@@ -705,7 +834,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
     -142,  -142,  -142,     3,    -8,  -142,  -142,    61,   107,  -142,
     -142,    -9,  -142,   103,  -142,   -15,    45,  -141,  -142,    47,
@@ -718,7 +847,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -142
-static const short yytable[] =
+static const yytype_int16 yytable[] =
 {
       50,    49,   224,    40,    65,    61,    62,    63,   186,    98,
       72,    73,   186,    85,    56,    57,    58,   239,    87,    88,
@@ -800,7 +929,7 @@
      125,   126
 };
 
-static const short yycheck[] =
+static const yytype_int16 yycheck[] =
 {
        0,     0,     3,     0,    12,     9,    10,    11,    30,    30,
       14,    15,    30,    24,     7,     8,     9,    30,    26,    27,
@@ -884,7 +1013,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
       12,    13,    14,    15,    16,    17,    19,    20,    21,    22,
@@ -913,22 +1042,6 @@
       65,    90
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -954,30 +1067,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -998,42 +1144,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -1042,45 +1242,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1095,13 +1302,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -1111,45 +1314,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -1159,70 +1364,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1230,13 +1557,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1245,10 +1572,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1261,14 +1588,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1279,13 +1610,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1296,18 +1633,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1316,9 +1653,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1342,8 +1679,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1356,18 +1692,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1378,21 +1714,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1423,19 +1759,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1450,7 +1784,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1470,22 +1804,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1523,7 +1856,7 @@
         case 4:
 #line 242 "c-exp.y"
     { write_exp_elt_opcode(OP_TYPE);
-			  write_exp_elt_type(yyvsp[0].tval);
+			  write_exp_elt_type((yyvsp[(1) - (1)].tval));
 			  write_exp_elt_opcode(OP_TYPE);}
     break;
 
@@ -1590,7 +1923,7 @@
   case 18:
 #line 299 "c-exp.y"
     { write_exp_elt_opcode (STRUCTOP_PTR);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (STRUCTOP_PTR); }
     break;
 
@@ -1611,7 +1944,7 @@
   case 21:
 #line 317 "c-exp.y"
     { write_exp_elt_opcode (STRUCTOP_STRUCT);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
     break;
 
@@ -1663,28 +1996,28 @@
 
   case 31:
 #line 364 "c-exp.y"
-    { yyval.lval = end_arglist () - 1; }
+    { (yyval.lval) = end_arglist () - 1; }
     break;
 
   case 32:
 #line 367 "c-exp.y"
     { write_exp_elt_opcode (OP_ARRAY);
 			  write_exp_elt_longcst ((LONGEST) 0);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(3) - (3)].lval));
 			  write_exp_elt_opcode (OP_ARRAY); }
     break;
 
   case 33:
 #line 374 "c-exp.y"
     { write_exp_elt_opcode (UNOP_MEMVAL);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_MEMVAL); }
     break;
 
   case 34:
 #line 380 "c-exp.y"
     { write_exp_elt_opcode (UNOP_CAST);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_CAST); }
     break;
 
@@ -1801,22 +2134,22 @@
   case 57:
 #line 476 "c-exp.y"
     { write_exp_elt_opcode (BINOP_ASSIGN_MODIFY);
-			  write_exp_elt_opcode (yyvsp[-1].opcode);
+			  write_exp_elt_opcode ((yyvsp[(2) - (3)].opcode));
 			  write_exp_elt_opcode (BINOP_ASSIGN_MODIFY); }
     break;
 
   case 58:
 #line 482 "c-exp.y"
     { write_exp_elt_opcode (OP_LONG);
-			  write_exp_elt_type (yyvsp[0].typed_val_int.type);
-			  write_exp_elt_longcst ((LONGEST)(yyvsp[0].typed_val_int.val));
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_int).type);
+			  write_exp_elt_longcst ((LONGEST)((yyvsp[(1) - (1)].typed_val_int).val));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 59:
 #line 489 "c-exp.y"
     { YYSTYPE val;
-			  parse_number (yyvsp[0].ssym.stoken.ptr, yyvsp[0].ssym.stoken.length, 0, &val);
+			  parse_number ((yyvsp[(1) - (1)].ssym).stoken.ptr, (yyvsp[(1) - (1)].ssym).stoken.length, 0, &val);
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (val.typed_val_int.type);
 			  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
@@ -1827,16 +2160,16 @@
   case 60:
 #line 500 "c-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
-			  write_exp_elt_type (yyvsp[0].typed_val_float.type);
-			  write_exp_elt_dblcst (yyvsp[0].typed_val_float.dval);
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_float).type);
+			  write_exp_elt_dblcst ((yyvsp[(1) - (1)].typed_val_float).dval);
 			  write_exp_elt_opcode (OP_DOUBLE); }
     break;
 
   case 61:
 #line 507 "c-exp.y"
     { write_exp_elt_opcode (OP_DECFLOAT);
-			  write_exp_elt_type (yyvsp[0].typed_val_decfloat.type);
-			  write_exp_elt_decfloatcst (yyvsp[0].typed_val_decfloat.val);
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_decfloat).type);
+			  write_exp_elt_decfloatcst ((yyvsp[(1) - (1)].typed_val_decfloat).val);
 			  write_exp_elt_opcode (OP_DECFLOAT); }
     break;
 
@@ -1844,8 +2177,8 @@
 #line 521 "c-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type (current_gdbarch)->builtin_int);
-			  CHECK_TYPEDEF (yyvsp[-1].tval);
-			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yyvsp[-1].tval));
+			  CHECK_TYPEDEF ((yyvsp[(3) - (4)].tval));
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ((yyvsp[(3) - (4)].tval)));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
@@ -1856,7 +2189,7 @@
 			     the array upper bound is the string length.
 			     There is no such thing in C as a completely empty
 			     string. */
-			  char *sp = yyvsp[0].sval.ptr; int count = yyvsp[0].sval.length;
+			  char *sp = (yyvsp[(1) - (1)].sval).ptr; int count = (yyvsp[(1) - (1)].sval).length;
 			  while (count-- > 0)
 			    {
 			      write_exp_elt_opcode (OP_LONG);
@@ -1870,7 +2203,7 @@
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_opcode (OP_ARRAY);
 			  write_exp_elt_longcst ((LONGEST) 0);
-			  write_exp_elt_longcst ((LONGEST) (yyvsp[0].sval.length));
+			  write_exp_elt_longcst ((LONGEST) ((yyvsp[(1) - (1)].sval).length));
 			  write_exp_elt_opcode (OP_ARRAY); }
     break;
 
@@ -1893,42 +2226,42 @@
   case 68:
 #line 570 "c-exp.y"
     {
-			  if (yyvsp[0].ssym.sym)
-			    yyval.bval = SYMBOL_BLOCK_VALUE (yyvsp[0].ssym.sym);
+			  if ((yyvsp[(1) - (1)].ssym).sym)
+			    (yyval.bval) = SYMBOL_BLOCK_VALUE ((yyvsp[(1) - (1)].ssym).sym);
 			  else
 			    error ("No file or function \"%s\".",
-				   copy_name (yyvsp[0].ssym.stoken));
+				   copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			}
     break;
 
   case 69:
 #line 578 "c-exp.y"
     {
-			  yyval.bval = yyvsp[0].bval;
+			  (yyval.bval) = (yyvsp[(1) - (1)].bval);
 			}
     break;
 
   case 70:
 #line 584 "c-exp.y"
     { struct symbol *tem
-			    = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			    = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					     VAR_DOMAIN, (int *) NULL,
 					     (struct symtab **) NULL);
 			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
 			    error ("No function \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
-			  yyval.bval = SYMBOL_BLOCK_VALUE (tem); }
+				   copy_name ((yyvsp[(3) - (3)].sval)));
+			  (yyval.bval) = SYMBOL_BLOCK_VALUE (tem); }
     break;
 
   case 71:
 #line 595 "c-exp.y"
     { struct symbol *sym;
-			  sym = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			  sym = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					       VAR_DOMAIN, (int *) NULL,
 					       (struct symtab **) NULL);
 			  if (sym == 0)
 			    error ("No symbol \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
+				   copy_name ((yyvsp[(3) - (3)].sval)));
 
 			  write_exp_elt_opcode (OP_VAR_VALUE);
 			  /* block_found is set by lookup_symbol.  */
@@ -1940,7 +2273,7 @@
   case 72:
 #line 611 "c-exp.y"
     {
-			  struct type *type = yyvsp[-2].tval;
+			  struct type *type = (yyvsp[(1) - (3)].tval);
 			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
 			      && TYPE_CODE (type) != TYPE_CODE_UNION
 			      && TYPE_CODE (type) != TYPE_CODE_NAMESPACE)
@@ -1949,7 +2282,7 @@
 
 			  write_exp_elt_opcode (OP_SCOPE);
 			  write_exp_elt_type (type);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (OP_SCOPE);
 			}
     break;
@@ -1957,7 +2290,7 @@
   case 73:
 #line 625 "c-exp.y"
     {
-			  struct type *type = yyvsp[-3].tval;
+			  struct type *type = (yyvsp[(1) - (4)].tval);
 			  struct stoken tmp_token;
 			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
 			      && TYPE_CODE (type) != TYPE_CODE_UNION
@@ -1965,10 +2298,10 @@
 			    error ("`%s' is not defined as an aggregate type.",
 				   TYPE_NAME (type));
 
-			  tmp_token.ptr = (char*) alloca (yyvsp[0].sval.length + 2);
-			  tmp_token.length = yyvsp[0].sval.length + 1;
+			  tmp_token.ptr = (char*) alloca ((yyvsp[(4) - (4)].sval).length + 2);
+			  tmp_token.length = (yyvsp[(4) - (4)].sval).length + 1;
 			  tmp_token.ptr[0] = '~';
-			  memcpy (tmp_token.ptr+1, yyvsp[0].sval.ptr, yyvsp[0].sval.length);
+			  memcpy (tmp_token.ptr+1, (yyvsp[(4) - (4)].sval).ptr, (yyvsp[(4) - (4)].sval).length);
 			  tmp_token.ptr[tmp_token.length] = 0;
 
 			  /* Check for valid destructor name.  */
@@ -1983,7 +2316,7 @@
   case 75:
 #line 651 "c-exp.y"
     {
-			  char *name = copy_name (yyvsp[0].sval);
+			  char *name = copy_name ((yyvsp[(2) - (2)].sval));
 			  struct symbol *sym;
 			  struct minimal_symbol *msymbol;
 
@@ -2017,7 +2350,7 @@
 
   case 76:
 #line 685 "c-exp.y"
-    { struct symbol *sym = yyvsp[0].ssym.sym;
+    { struct symbol *sym = (yyvsp[(1) - (1)].ssym).sym;
 
 			  if (sym)
 			    {
@@ -2037,7 +2370,7 @@
 			      write_exp_elt_sym (sym);
 			      write_exp_elt_opcode (OP_VAR_VALUE);
 			    }
-			  else if (yyvsp[0].ssym.is_a_field_of_this)
+			  else if ((yyvsp[(1) - (1)].ssym).is_a_field_of_this)
 			    {
 			      /* C++: it hangs off of `this'.  Must
 			         not inadvertently convert from a method call
@@ -2048,13 +2381,13 @@
 			      write_exp_elt_opcode (OP_THIS);
 			      write_exp_elt_opcode (OP_THIS);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
-			      write_exp_string (yyvsp[0].ssym.stoken);
+			      write_exp_string ((yyvsp[(1) - (1)].ssym).stoken);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
 			    }
 			  else
 			    {
 			      struct minimal_symbol *msymbol;
-			      char *arg = copy_name (yyvsp[0].ssym.stoken);
+			      char *arg = copy_name ((yyvsp[(1) - (1)].ssym).stoken);
 
 			      msymbol =
 				lookup_minimal_symbol (arg, NULL, NULL);
@@ -2068,47 +2401,47 @@
 				error ("No symbol table is loaded.  Use the \"file\" command.");
 			      else
 				error ("No symbol \"%s\" in current context.",
-				       copy_name (yyvsp[0].ssym.stoken));
+				       copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			    }
 			}
     break;
 
   case 77:
 #line 742 "c-exp.y"
-    { push_type_address_space (copy_name (yyvsp[0].ssym.stoken));
+    { push_type_address_space (copy_name ((yyvsp[(2) - (2)].ssym).stoken));
 		  push_type (tp_space_identifier);
 		}
     break;
 
   case 85:
 #line 764 "c-exp.y"
-    { push_type (tp_pointer); yyval.voidval = 0; }
+    { push_type (tp_pointer); (yyval.voidval) = 0; }
     break;
 
   case 86:
 #line 766 "c-exp.y"
-    { push_type (tp_pointer); yyval.voidval = yyvsp[0].voidval; }
+    { push_type (tp_pointer); (yyval.voidval) = (yyvsp[(2) - (2)].voidval); }
     break;
 
   case 87:
 #line 768 "c-exp.y"
-    { push_type (tp_reference); yyval.voidval = 0; }
+    { push_type (tp_reference); (yyval.voidval) = 0; }
     break;
 
   case 88:
 #line 770 "c-exp.y"
-    { push_type (tp_reference); yyval.voidval = yyvsp[0].voidval; }
+    { push_type (tp_reference); (yyval.voidval) = (yyvsp[(2) - (2)].voidval); }
     break;
 
   case 90:
 #line 775 "c-exp.y"
-    { yyval.voidval = yyvsp[-1].voidval; }
+    { (yyval.voidval) = (yyvsp[(2) - (3)].voidval); }
     break;
 
   case 91:
 #line 777 "c-exp.y"
     {
-			  push_type_int (yyvsp[0].lval);
+			  push_type_int ((yyvsp[(2) - (2)].lval));
 			  push_type (tp_array);
 			}
     break;
@@ -2116,9 +2449,9 @@
   case 92:
 #line 782 "c-exp.y"
     {
-			  push_type_int (yyvsp[0].lval);
+			  push_type_int ((yyvsp[(1) - (1)].lval));
 			  push_type (tp_array);
-			  yyval.voidval = 0;
+			  (yyval.voidval) = 0;
 			}
     break;
 
@@ -2134,239 +2467,239 @@
 
   case 95:
 #line 795 "c-exp.y"
-    { yyval.lval = -1; }
+    { (yyval.lval) = -1; }
     break;
 
   case 96:
 #line 797 "c-exp.y"
-    { yyval.lval = yyvsp[-1].typed_val_int.val; }
+    { (yyval.lval) = (yyvsp[(2) - (3)].typed_val_int).val; }
     break;
 
   case 97:
 #line 801 "c-exp.y"
-    { yyval.voidval = 0; }
+    { (yyval.voidval) = 0; }
     break;
 
   case 98:
 #line 803 "c-exp.y"
-    { free (yyvsp[-1].tvec); yyval.voidval = 0; }
+    { free ((yyvsp[(2) - (3)].tvec)); (yyval.voidval) = 0; }
     break;
 
   case 100:
 #line 819 "c-exp.y"
-    { yyval.tval = yyvsp[0].tsym.type; }
+    { (yyval.tval) = (yyvsp[(1) - (1)].tsym).type; }
     break;
 
   case 101:
 #line 821 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_int; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_int; }
     break;
 
   case 102:
 #line 823 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long; }
     break;
 
   case 103:
 #line 825 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_short; }
     break;
 
   case 104:
 #line 827 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long; }
     break;
 
   case 105:
 #line 829 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long; }
     break;
 
   case 106:
 #line 831 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long; }
     break;
 
   case 107:
 #line 833 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long; }
     break;
 
   case 108:
 #line 835 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long; }
     break;
 
   case 109:
 #line 837 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long; }
     break;
 
   case 110:
 #line 839 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long; }
     break;
 
   case 111:
 #line 841 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_long; }
     break;
 
   case 112:
 #line 843 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_long; }
     break;
 
   case 113:
 #line 845 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_long; }
     break;
 
   case 114:
 #line 847 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_long; }
     break;
 
   case 115:
 #line 849 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_long; }
     break;
 
   case 116:
 #line 851 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_long; }
     break;
 
   case 117:
 #line 853 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
     break;
 
   case 118:
 #line 855 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
     break;
 
   case 119:
 #line 857 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
     break;
 
   case 120:
 #line 859 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_long_long; }
     break;
 
   case 121:
 #line 861 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_short; }
     break;
 
   case 122:
 #line 863 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_short; }
     break;
 
   case 123:
 #line 865 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_short; }
     break;
 
   case 124:
 #line 867 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_short; }
     break;
 
   case 125:
 #line 869 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_short; }
     break;
 
   case 126:
 #line 871 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_short; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_short; }
     break;
 
   case 127:
 #line 873 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_double; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_double; }
     break;
 
   case 128:
 #line 875 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_long_double; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_long_double; }
     break;
 
   case 129:
 #line 877 "c-exp.y"
-    { yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_struct (copy_name ((yyvsp[(2) - (2)].sval)),
 					      expression_context_block); }
     break;
 
   case 130:
 #line 880 "c-exp.y"
-    { yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_struct (copy_name ((yyvsp[(2) - (2)].sval)),
 					      expression_context_block); }
     break;
 
   case 131:
 #line 883 "c-exp.y"
-    { yyval.tval = lookup_union (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_union (copy_name ((yyvsp[(2) - (2)].sval)),
 					     expression_context_block); }
     break;
 
   case 132:
 #line 886 "c-exp.y"
-    { yyval.tval = lookup_enum (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_enum (copy_name ((yyvsp[(2) - (2)].sval)),
 					    expression_context_block); }
     break;
 
   case 133:
 #line 889 "c-exp.y"
-    { yyval.tval = lookup_unsigned_typename (TYPE_NAME(yyvsp[0].tsym.type)); }
+    { (yyval.tval) = lookup_unsigned_typename (TYPE_NAME((yyvsp[(2) - (2)].tsym).type)); }
     break;
 
   case 134:
 #line 891 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_unsigned_int; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_unsigned_int; }
     break;
 
   case 135:
 #line 893 "c-exp.y"
-    { yyval.tval = lookup_signed_typename (TYPE_NAME(yyvsp[0].tsym.type)); }
+    { (yyval.tval) = lookup_signed_typename (TYPE_NAME((yyvsp[(2) - (2)].tsym).type)); }
     break;
 
   case 136:
 #line 895 "c-exp.y"
-    { yyval.tval = builtin_type (current_gdbarch)->builtin_int; }
+    { (yyval.tval) = builtin_type (current_gdbarch)->builtin_int; }
     break;
 
   case 137:
 #line 900 "c-exp.y"
-    { yyval.tval = lookup_template_type(copy_name(yyvsp[-3].sval), yyvsp[-1].tval,
+    { (yyval.tval) = lookup_template_type(copy_name((yyvsp[(2) - (5)].sval)), (yyvsp[(4) - (5)].tval),
 						    expression_context_block);
 			}
     break;
 
   case 138:
 #line 904 "c-exp.y"
-    { yyval.tval = follow_types (yyvsp[0].tval); }
+    { (yyval.tval) = follow_types ((yyvsp[(2) - (2)].tval)); }
     break;
 
   case 139:
 #line 906 "c-exp.y"
-    { yyval.tval = follow_types (yyvsp[-1].tval); }
+    { (yyval.tval) = follow_types ((yyvsp[(1) - (2)].tval)); }
     break;
 
   case 141:
 #line 956 "c-exp.y"
     {
-		  struct type *type = yyvsp[-2].tval;
+		  struct type *type = (yyvsp[(1) - (3)].tval);
 		  struct type *new_type;
-		  char *ncopy = alloca (yyvsp[0].sval.length + 1);
+		  char *ncopy = alloca ((yyvsp[(3) - (3)].sval).length + 1);
 
-		  memcpy (ncopy, yyvsp[0].sval.ptr, yyvsp[0].sval.length);
-		  ncopy[yyvsp[0].sval.length] = '\0';
+		  memcpy (ncopy, (yyvsp[(3) - (3)].sval).ptr, (yyvsp[(3) - (3)].sval).length);
+		  ncopy[(yyvsp[(3) - (3)].sval).length] = '\0';
 
 		  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
 		      && TYPE_CODE (type) != TYPE_CODE_UNION
@@ -2380,56 +2713,56 @@
 		    error ("No type \"%s\" within class or namespace \"%s\".",
 			   ncopy, TYPE_NAME (type));
 		  
-		  yyval.tval = new_type;
+		  (yyval.tval) = new_type;
 		}
     break;
 
   case 143:
 #line 982 "c-exp.y"
     {
-		  yyval.tsym.stoken.ptr = "int";
-		  yyval.tsym.stoken.length = 3;
-		  yyval.tsym.type = builtin_type (current_gdbarch)->builtin_int;
+		  (yyval.tsym).stoken.ptr = "int";
+		  (yyval.tsym).stoken.length = 3;
+		  (yyval.tsym).type = builtin_type (current_gdbarch)->builtin_int;
 		}
     break;
 
   case 144:
 #line 988 "c-exp.y"
     {
-		  yyval.tsym.stoken.ptr = "long";
-		  yyval.tsym.stoken.length = 4;
-		  yyval.tsym.type = builtin_type (current_gdbarch)->builtin_long;
+		  (yyval.tsym).stoken.ptr = "long";
+		  (yyval.tsym).stoken.length = 4;
+		  (yyval.tsym).type = builtin_type (current_gdbarch)->builtin_long;
 		}
     break;
 
   case 145:
 #line 994 "c-exp.y"
     {
-		  yyval.tsym.stoken.ptr = "short";
-		  yyval.tsym.stoken.length = 5;
-		  yyval.tsym.type = builtin_type (current_gdbarch)->builtin_short;
+		  (yyval.tsym).stoken.ptr = "short";
+		  (yyval.tsym).stoken.length = 5;
+		  (yyval.tsym).type = builtin_type (current_gdbarch)->builtin_short;
 		}
     break;
 
   case 146:
 #line 1003 "c-exp.y"
-    { yyval.tvec = (struct type **) xmalloc (sizeof (struct type *) * 2);
-		  yyval.ivec[0] = 1;	/* Number of types in vector */
-		  yyval.tvec[1] = yyvsp[0].tval;
+    { (yyval.tvec) = (struct type **) xmalloc (sizeof (struct type *) * 2);
+		  (yyval.ivec)[0] = 1;	/* Number of types in vector */
+		  (yyval.tvec)[1] = (yyvsp[(1) - (1)].tval);
 		}
     break;
 
   case 147:
 #line 1008 "c-exp.y"
-    { int len = sizeof (struct type *) * (++(yyvsp[-2].ivec[0]) + 1);
-		  yyval.tvec = (struct type **) xrealloc ((char *) yyvsp[-2].tvec, len);
-		  yyval.tvec[yyval.ivec[0]] = yyvsp[0].tval;
+    { int len = sizeof (struct type *) * (++((yyvsp[(1) - (3)].ivec)[0]) + 1);
+		  (yyval.tvec) = (struct type **) xrealloc ((char *) (yyvsp[(1) - (3)].tvec), len);
+		  (yyval.tvec)[(yyval.ivec)[0]] = (yyvsp[(3) - (3)].tval);
 		}
     break;
 
   case 149:
 #line 1016 "c-exp.y"
-    { yyval.tval = follow_types (yyvsp[-3].tval); }
+    { (yyval.tval) = follow_types ((yyvsp[(1) - (4)].tval)); }
     break;
 
   case 152:
@@ -2451,34 +2784,33 @@
 
   case 155:
 #line 1033 "c-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
   case 156:
 #line 1034 "c-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
   case 157:
 #line 1035 "c-exp.y"
-    { yyval.sval = yyvsp[0].tsym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].tsym).stoken; }
     break;
 
   case 158:
 #line 1036 "c-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2809 "c-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 2477 "c-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -2507,99 +2839,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2609,15 +2907,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2646,9 +2946,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2656,11 +2957,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2680,21 +2982,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -3478,4 +3798,3 @@
   error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
 }
 
-
diff -Naur gdb-6.8/gdb/ChangeLog.sts-gdb stsgdb-6.8/gdb/ChangeLog.sts-gdb
--- gdb-6.8/gdb/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/ChangeLog.sts-gdb	2008-09-11 10:35:35.000000000 +0100
@@ -0,0 +1,742 @@
+2008-09-03  Antony King  <antony.king@st.com>
+
+	Fix INSbl29231:
+	* breakpoint.c (hw_breakpoint_used_count): Remove static.
+	(hw_watchpoint_used_count): Likewise. Return number of other
+	watchpoint types.
+	(watch_command_1): Update error message.
+	* breakpoint.h (hw_breakpoint_used_count): Add extern declaration.
+	(hw_watchpoint_used_count): Likewise.
+	* shtdi.c (shtdi_can_use_hw_breakpoint): Use hw_breakpoint_used_count
+	and hw_watchpoint_used_count.
+
+2008-09-02  Antony King  <antony.king@st.com>
+
+	* shtdi.c (shtdi_insert_watchpoint): Use SHTDI_HW_WATCHPOINT_LIMIT.
+	(shtdi_can_use_hw_breakpoint): Add missing watchpoint types.
+
+2008-09-01  Antony King  <antony.king@st.com>
+
+	Fix PR/2500:
+	* breakpoint.c (bpstat_stop_status): Always stop if
+	WP_VALUE_CHANGED.
+
+2008-08-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl29209:
+	* shtdi.c (shtdi_watch_data_address): New global variable.
+	(shtdi_stopped_data_address): New function.
+	(shtdi_wait): Add support for version 1.5 of the SHDEBUG
+	API (GetState).
+	(init_shtdi_ops): Set to_stopped_data_address to
+	shtdi_stopped_data_address.
+
+2008-08-29  Denis Pilat  <denis.pilat@st.com>
+
+	* breakpoint.c: Add missing Copyright notice.
+	* remote.c: Likewise.
+	* cli/cli-cmds.c(fork_escape): Add cast to the last argument of execlp
+	to remove GCC 4.1.1 warning "missing sentinel in function call".
+	* version.in: Set version to 6.8-ST-2.0.
+
+2008-08-27  Antony King  <antony.king@st.com>
+
+	* target.c (set_targetdebug): New function.
+	(initialize_targets): Update.
+
+	Fix INSbl29191:
+	* infrun.c (prepare_to_proceed): Switch to last stopped thread
+	if target unable to lock scheduler.
+	* shtdi.c (shtdi_resume): Report error for unsupported modes.
+
+2008-08-15  Antony King  <antony.king@st.com>
+
+	* breakpoint.c (update_watchpoint): Do not remove watchpoint
+	if not inserted.
+	* dwarf2-frame.c (execute_cfa_program): Fix incorrect merge
+	for DW_CFA_restore_extended.
+	* shtdi.c (shtdi_stopped_by_watchpoint_p): New global variable.
+	(shtdi_stopped_by_watchpoint): New function.
+	(shtdi_wait): Recognize H/W code and data breakpoint stop codes.
+	(init_shtdi_ops): Set to_stopped_by_watchpoint to
+	shtdi_stopped_by_watchpoint.
+
+2008-08-14  Antony King  <antony.king@st.com>
+
+	Fix INSbl29142:
+	* shtdi.c (shtdi_addrfromsymb): Return success or failure.
+	(shtdi_symbfromaddr) Likewise.
+
+2008-08-12  Antony King  <antony.king@st.com>
+
+	Import STS-GDB 6.8:
+	* config/sh/tm-sh.h: Remove.
+	* configure.ac (sh*-superh-elf): Add definitions for GDBINIT_FILENAME,
+	SHTDI_GDB_REGISTER_MAP, TARGET_HAS_RELOCATABLE_LIB, SOLIB_BKPT_NAME
+	and SHTDI_JOINT_HW_BREAK_LIMIT.
+	* configure: Regenerate.
+	* config.in: Likewise.
+	* shtdi.c (shtdi_init_simulator_hook): Add definition.
+	(SHTDI_GDB_REGISTER_MAP) Likewise.
+	* sh-tdep.c (SVR4_SHARED_LIBS): Remove and replace with
+	TARGET_HAS_RELOCATABLE_LIB.
+	(sh_default_register_type): Use builtin_type_void_func_ptr for PC
+	PR and SPC registers.
+	(sh_sh2a_register_type): Likewise.
+	(sh_sh3e_register_type): Likewise.
+	(sh_sh4_register_type): Likewise.
+	* remote.c (extended_remote_attach_1): Fix GCC 3.4 compilation
+	warning (Solaris).
+
+2008-07-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl26448:
+	* shtdi.c (do_script): New function.
+	(do_script_cleanup): Likewise.
+	(shtdi_callplugin): Call do_script (or execute_command) on result.
+	(set_command): Deprecate.
+
+2008-07-18  Denis Pilat  <denis.pilat@st.com>
+
+	* shtdi.c: Add an include to "sh/tm-sh.h" following 6.8 porting.
+
+2008-07-07  Denis Pilat  <denis.pilat@st.com>
+
+	* Modify all required files while porting to 6.8 version,
+	adding ChangeLog.st40 for Andrew&Antony's patches.
+	* version.in: Set version to 6.8-ST-1.0.
+
+2008-06-30  Antony King  <antony.king@st.com>
+
+	Fix INSbl28906:
+	* sh-tdep.c (sh_sh4_register_sim_regno): Replace erroneous use of
+	FPSCR_PR with FPSCR_FR.
+	(sh4_gdb_to_shtdi_regno): Likewise.
+
+2008-05-15  Antony King  <antony.king@st.com>
+
+	* sh-tdep.c (sh3_show_regs): Display bank registers.
+	(sh3e_show_regs): Likewise.
+	(sh4_show_regs): Likewise.
+	(sh4_nofpu_show_regs): Likewise.
+
+2008-05-02  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* main.h (batch_silent): Declare.
+	* event-top.c: Include main.h.
+	(gdb_setup_readline): Remove extern batch_silent declaration.
+	* infrun.c (normal_stop): Don't print source location when running in
+	--batch-silent mode.
+	* Makefile.in (event-top.o): Add main.h dependency.
+
+2008-04-23  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* printcmd.c: Define USE_PRINTF_I64 and PRINTF_HAS_LONG_LONG on MinGW.
+	(printf_command): Convert %lld to %I64d when USE_PRINTF_I64 set.
+	Allow 'l' (ell) modifier for %f.
+
+2008-04-07  Antony King  <antony.king@st.com>
+
+	Fix INSbl28523:
+	* shtdi.c (shtdi_maintenance_cmdlist): New global variable.
+	(rtos_reset_command): New function.
+	(maintenance_shtdi_command): Likewise.
+	(_initialize_shtdi): Added new maintenance shtdi subcommand.
+
+2008-04-04  Antony King  <antony.king@st.com>
+
+	Fix INSbl27793:
+	* frame.c (frame_find_by_id): Only return null frame for null id
+	when target has no stack and apply patch from
+	http://www.sourceware.org/ml/gdb-patches/2006-05/msg00018.html.
+
+2008-04-03  Antony King  <antony.king@st.com>
+
+	Fix INSbl28523:
+	* sh-tdep.c (sh4_gdb_to_shtdi_regno): Add regcache parameter and use
+	instead of current frame.
+	(sh_gdb_to_shtdi_regno): Likewise.
+	(sh_sh4_register_sim_regno): Use current regcache instead of current
+	frame.
+	* config/sh/tm-sh.h (SHTDI_GDB_REGISTER_MAP): Add regcache parameter.
+	* shtdi.c (shtdi_register_offset): Likewise.
+
+2008-04-01  Antony King  <antony.king@st.com>
+
+	* shtdi.c (SHDEBUGAPI_VERSION): Remove and replace with
+	SHDEBUGAPI_VERSION_MIN and SHDEBUGAPI_VERSION_MAX.
+	(shtdi_load_shdebug): Add support for version 1.3 of the
+	SHDEBUG API (RtosGetEventMonitor).
+	(shtdi_unload_shdebug): Likewise.
+
+	Fix INSbl28523:
+	* shtdi.c (shtdi_read_all_registers): New global variable.
+	(shtdi_rtos_thread_information): Likewise.
+	(shtdi_fetch_all_registers_data): Likewise.
+	(show_shtdi_read_all_registers): New function.
+	(show_shtdi_rtos_thread_information): Likewise.
+	(_initialize_shtdi): Add new set/show shtdi subcommands.
+	(rtos_extra_thread_info) Add support for version 1.4 of the
+	SHDEBUG API (RtosGetThreadInfo).
+	(shtdi_fetch_register): Rename to shtdi_fetch_register_1. Use
+	shtdi_fetch_all_registers_data as temporary registers cache.
+	(shtdi_fetch_register): New function.
+	(shtdi_fetch_register_cleanup): Likewise.
+
+2008-03-10  Antony King  <antony.king@st.com>
+
+	Fix INSbl21056:
+	* shtdi.c (remote_debug): Remove erroneous usage.
+	(interrupt_requested): Rename to target_interrupted.
+	(interrupt_pending): Rename to interrupt_requested.
+	(terminate_pending): Rename to terminate_requested.
+	(shtdi_wait): Call interrupt_stop if quit_flag set or timeout. Move
+	restoration of interrupt handler to cleanup function.
+	(shtdi_wait_cleanup): New function.
+	(terminate_disable): Fix race condition.
+	(shtdi_stop): Rename to interrupt_stop.
+	(interrupt_once): Replace target_stop with interrupt_stop.
+	(shtdi_stop): New function.
+
+2008-03-06  Antony King  <antony.king@st.com>
+
+	* Makefile.in (tracepoint.o): Remove format checking (MinGW GCC 3.4
+	compilation warning).
+	* shtdi.c (iointerrupt): Fix GCC 3.4 compilation warning.
+
+2008-03-05  Antony King  <antony.king@st.com>
+
+	* infcall.c (find_function_addr): Fix GCC 3.2 compilation warning.
+
+2008-03-04  Denis PILAT for Antony King  <antony.king@st.com>
+
+	Fix INSbl25564:
+	* dwarf2-frame.c (execute_cfa_program): Ignore CFI entries with
+	negative register numbers.
+
+2008-02-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl28432:
+	* shtdi.c (shtdi_wait): Report unknown signal on shdbg_GetState
+	error; replace explict signal codes with TARGET_SIGNAL_<code>;
+	call shtdi_kill on detach request from deprecated_ui_loop_hook.
+
+2008-02-19  Antony King  <antony.king@st.com>
+
+	Fix INSbl28103:
+	* shtdi.c (set_rtos_initialize_string): New global variable.
+	(shtdi_set_cmdlist, shtdi_show_cmdlist): Likewise.
+	(show_shtdi_rtos_initialize): New function.
+	(set_shtdi_cmd): Likewise.
+	(show_shtdi_cmd): Likewise.
+	(_initialize_shtdi): Add new set/show command plus re-factor
+	existing set/show commands under shtdi subcommand.
+	(shtdi_open): Check set_rtos_initialize_string before
+	calling rtos_init.
+	(shtdi_load): Likewise.
+	(shtdi_resume): Likewise.
+
+2008-02-14  Antony King  <antony.king@st.com>
+
+	Fix INSbl28103:
+	* shtdi.c (rtos_disable): Remove target status check.
+	(rtos_enable): Likewise.
+	(shtdi_open): Call rtos_check_symbols and rtos_init before
+	start_remote.
+	(shtdi_resume) Remove call to rtos_init.
+
+	* shtdi.c (ioconsole_open): Rename to ioconsole_init.
+	(ioconsole_launch): Rename to ioconsole_open.
+	(ioconsole_console_enable): Remove target status check.
+	(ioconsole_close): Likewise.
+
+2008-02-13  Antony King  <antony.king@st.com>
+
+	Fix INSbl28376:
+	* shtdi.c (interrupt_query): Remove.
+	(interrupt_twice): Likewise.
+	(interrupt_once): Replace interrupt_twice with interrupt_once.
+	(shtdi_stop): Remove call to interrupt_query and always call
+	iointerrupt.
+	(interrupt_request): New global variable to indicate if
+	shdbg_Interrupt has been called.
+	(shtdi_close_cleanup): Likewise.
+	(interrupt_check): Likewise.
+	(shtdi_wait): Likewise.
+	(interrupt_pending): Add missing volatile.
+	(terminate_pending): Likewise.
+
+2008-02-07  Antony King  <antony.king@st.com>
+
+	Fix INSbl28274:
+	* shtdi.c (ioconsole_launch): Add asynchonous pipe handle
+	to parameters for separate Posix console.
+	(ioconsole_close): Clean up asynchonous pipe handle.
+	(iointerrupt): Use asynchonous pipe instead of write pipe.
+
+2008-02-04  Antony King  <antony.king@st.com>
+
+	Fix INSbl28274:
+	* shtdi.c (shtdi_stop): Call iointerrupt.
+	(interrupt_check): Remove call to iointerrupt.
+
+2008-02-04  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.7-ST-1.50 (intermediate version).
+
+2008-01-31  Antony King  <antony.king@st.com>
+
+	Fix INSbl28301:
+	* shtdi.c (shtdi_close_cleanup): Remove unnecessary
+	disabling of RTOS awareness.
+
+2008-01-14  Denis Pilat  <denis.pilat@st.com>
+
+	Evaluate environment variables from the command line, using
+	the ${} syntax.
+	* top.c (evaluate_environment_from_string): new function.
+	(ENV_DELIMITER_BEGIN,ENV_DELIMITER_END): new defines.
+
+2007-12-19  Denis Pilat  <denis.pilat@st.com>
+
+	* tui/tui-data.h (MAX_LOCATOR_ELEMENT_LEN): Defined to a bigger
+	value or to PATH_MAX when possible.
+
+2007-12-19  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.7-ST-1.0.
+
+2007-11-22  Antony King  <antony.king@st.com>
+
+	Fix INSbl28139:
+	* shtdi.c (shtdi_create_inferior): Remove unnecessary
+	explicit load of executable file.
+
+2007-11-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl28123:
+	* shtdi.c (show_shtdi_break_timeout): New function.
+	(shtdi_wait): Use set option for timeouts.
+	(_initialize_shtdi): Add new set/show command.
+	(_initialize_shtdi): Change set/show shtdi-wait-timeout to
+	to zinteger.
+
+2007-11-09  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.ac (GDBRESOPTS): New substitution.
+	* configure: Regenerate.
+	* Makefile.in (gdbres.o): Add @GDBRESOPTS@ to build command.
+
+2007-10-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl27972:
+	* shtdi.c (shtdi_close): Call target_mark_exited.
+	(shtdi_mourn_inferior): Remove call to target_mark_exited.
+
+2007-10-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl27972:
+	* shtdi.c (shtdi_mourn_inferior): Call target_mark_exited.
+
+2007-09-26  Antony King  <antony.king@st.com>
+
+	Fix INSbl27780:
+	* sh-tdep.c (sh_dbg_reg_to_regnum): New function.
+	(sh_gdbarch_init): Call set_gdbarch_dwarf_reg_to_regnum,
+	set_gdbarch_dwarf2_reg_to_regnum and set_gdbarch_stab_reg_to_regnum.
+	* sh-tdep.h: Change comment.
+
+2007-09-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl25905:
+	* sh-tdep.c (sh_type_align): New function.
+	(sh_treat_as_complex): Likewise.
+	(sh_use_struct_convention): Rewrite.
+	(sh_treat_as_flt_p): Likewise.
+	(sh_extract_return_value_nofpu): Remove limit on size of return
+	value type (for complex types).
+	(sh_use_struct_convention): Remove unused parameter.
+	(sh_return_value_nofpu): Likewise.
+	(sh_return_value_fpu): Likewise.
+
+2007-08-31  Antony King  <antony.king@st.com>
+
+	Fix INSbl26139:
+	* solib.c (solib_create_inferior_hook): Check if shared library
+	support is enabled.
+	(solib_add): Likewise.
+	(info_sharedlibrary_command): Likewise.
+	(disable_shared_libraries): New function.
+	(enable_shared_libraries): Likewise.
+	(_initialize_solib): Add enable and disable sharedlibrary commands.
+	* shtdi.c (ioconsole_console_disable): New function.
+	(ioconsole_console_enable): Likewise.
+	(info_ioconsole_console_command): Likewise.
+	(rtos_disable): Likewise.
+	(rtos_enable): Likewise.
+	(info_rtos_command): Likewise.
+	(ioconsole_console_command): Use ioconsole_console_disable(),
+	ioconsole_console_disable(), info_ioconsole_console_command().
+	(rtos_command): Use rtos_disable(), rtos_enable(),
+	info_rtos_command().
+	(_initialize_shtdi): Add enable, disable and info alternatives for
+	console and rtos commands.
+
+2007-08-24  Antony King  <antony.king@st.com>
+
+	Fix INSbl27529:
+	* configure.ac: Add check for -lthread.
+	* configure: Regenerate.
+
+2007-08-23  Antony King  <antony.king@st.com>
+
+	Fix INSbl25905:
+	* sh-tdep.c (sh_treat_as_flt_p): Add call to check_typedef()
+	when checking field types.
+	(sh_use_struct_convention): Likewise plus ABI change.
+
+2007-08-22  Antony King  <antony.king@st.com>
+
+	Fix INSbl26019:
+	* sh-tdep.c (sh_integer_to_address): New function.
+	(sh_gdbarch_init): Call set_gdbarch_integer_to_address.
+
+	Fix INSbl27304:
+	* shtdi.c (shtdi_crc32): Remove.
+	(shtdi_compare_sections): Add support for comparing VMA or LMA
+	addresses and for comparing with an offset. Replace CRC comparison
+	with memory compare and report first differing address and value.
+	(add_generic_cmds): Update compare-sections help.
+
+2007-08-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl27308:
+	* shtdi.c (shtdi_open): Remove superfluous call to
+	solib_create_inferior_hook(). Replace erroneous manipulation of
+	target state with target_mark_exited()/target_mark_running().
+	(init_shtdi_ops): Update target capabilities to normal defaults.
+	(shtdi_kill): Replace call to shdbg_RtosClearState() with call
+	to target_mourn_inferior().
+	(shtdi_mourn_inferior): Add call to shdbg_RtosClearState().
+	(shtdi_set_exec_file): New function.
+	(shtdi_load): Simplified to use shtdi_set_exec_file().
+	(shtdi_create_inferior): Replace non-standard executable file
+	handling with standard behaviour using the load command. Add
+	missing inferior process initialisations.
+
+2007-08-20  Antony King  <antony.king@st.com>
+
+	Fix INSbl27434:
+	* sh-tdep.c (sh_use_struct_convention): Add missing check
+	for enum before checking field type.
+
+	Fix INSbl27488:
+	* valops.c (value_fetch_lazy): Ensure object is initialised
+	before reading from memory.
+
+	Fix INSbl27444:
+	* shtdi.c (show_shtdi_wait_timeout): New function.
+	(shtdi_wait): Use set option for timeouts.
+	(_initialize_shtdi): Add new set/show command.
+	(show_download_write_size): Fix string formatting.
+	(_initialize_shtdi): Likewise.
+
+	Fix INSbl24984:
+	* shtdi.c (shtdi_mourn_inferior): New function.
+	(init_shtdi_ops): Set to_mourn_inferior to shtdi_mourn_inferior.
+
+	Fix INSbl26433:
+	* shtdi.c (terminate_once): New function.
+	(disable_terminate): Likewise.
+	(enable_terminate): Likewise.
+	(SHDEBUGSymbol): Add SIGTERM protection.
+	(voidreturnSHDEBUGSymbol): Likewise.
+	(voidSHDEBUGSymbol): Likewise.
+
+2007-08-17  Antony King  <antony.king@st.com>
+
+	* utils.c (defaulted_query): Prevent query when
+	sourcing a script file.
+
+2007-08-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl26938:
+	* sh-tdep.c (sh_show_regs_command): Remove sh_show_regs
+	hook (and replace with explicit architecture check).
+	(sh_gdbarch_init): Likewise.
+
+	Fix INSbl15403/INSbl27537:
+	* sh-tdep.h: Add missing registers.
+	(FP_LAST_REGNUM): Rename to FR_LAST_REGNUM.
+	* sh-tdep.c (FP0_REGNUM): Rename to FR0_REGNUM.
+	(FP_LAST_REGNUM): Rename to FR_LAST_REGNUM.
+	(sh_*_register_name): Return NULL for unknown registers.
+	(sh*_show_regs): Rename registers from FPn to FRn.
+	(sh_sh4_register_name): Add missing registers.
+	(sh_sh4_nofpu_register_name): Likewise.
+	(sh4_show_regs): Likewise.
+	(sh4_nofpu_show_regs): Likewise.
+	(sh_sh4_register_type): Likewise.
+	(sh_register_reggroup_p): Likewise.
+	(sh_register_convert_to_virtual): Likewise.
+	(sh_register_convert_to_raw): Likewise.
+	(dr_reg_base_num): Likewise.
+	(sh_pseudo_register_read): Likewise.
+	(sh_pseudo_register_write): Likewise.
+	(sh_dwarf2_frame_init_reg): Simplify.
+	(sh4_gdb_to_shtdi_regno): New function.
+	(sh_gdb_to_shtdi_regno): Likewise.
+	(sh_sh4_register_sim_regno): Likewise.
+	(sh_gdbarch_init): Increase pseudo registers for SH4 FPU targets
+	plus use sh_sh4_register_sim_regno for SH4 targets.
+	* config/sh/tm-sh.h (SHTDI_GDB_REGISTER_MAP): New macro.
+	* shtdi.c (shdbg_GetRegSize): Enable import of API.
+	(shtdi_register_offset): New function.
+	(shtdi_fetch_register): Use SHTDI_GDB_REGISTER_MAP if defined
+	and shdbg_GetRegSize to obtain register	size.
+	(shtdi_store_register): Likewise.
+
+2007-08-13  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Enable static build on Windows.
+
+	* Makefile.in (TCL_CFLAGS): Append @TCL_DEFS@.
+	(TK_CFLAGS): Append @TK_DEFS@.
+	(ITCL_CFLAGS): Append @ITCL_DEFS@.
+	(ITK_CFLAGS): Append @ITK_DEFS@.
+
+2007-08-01  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* symfile.c (struct load_section_data): Add use_vma field.
+	(load_progress_section_data): Likewise.
+	(load_progress): Output "vma" or "lma" as appropriate.
+	(load_section_callback): Use VMA, instead of LMA, if use_vma set.
+	Set use_vma in load_progress_section_data.
+	(generic_load): Handle the new lma or vma option.
+
+2007-02-06  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* shtdi.c (shtdi_create_inferior): Use execute command to run the
+	load command, instead of calling shtdi_load directly.
+
+2007-01-22  Denis Pilat  <denis.pilat@st.com>
+
+	In MI mode, after a step, this allows to print the stop reason a
+	string that represents the current frame identifier (optimization used
+	by STWorkbench):
+	* stack.c (print_frame_id): New global variable.
+	(show_print_frame_id): New function.
+	(print_frame): Print the frame-ID if print_frame_id set.
+	(initialize_stack): Add 'set print frame-id' command.
+
+2007-01-22  Denis Pilat  <denis.pilat@st.com>
+
+	This avoid printing frame information for "info threads" cli command:
+	* thread.c (info_threads_command): do not print stack frame information
+	if argument is nostackframe
+
+2007-01-19  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl26938:
+	* sh-tdep.c (sh_gdbarch_init): Integrate setting of sh_show_regs
+	with setting of everything else. Set sh_show_regs correctly for
+	all new architectures.
+
+2007-01-12  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl26678:
+	* shtdi.c (shtdi_create_inferior): Remove calls to continue_command.
+
+2006-12-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl26816:
+	* shtdi.c (shtdi_xfer_inferior_memory): Replace error message with
+	returning errno.
+
+2006-11-23  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* value.c (value_of_internalvar): Apply endian fix the float values.
+
+2006-11-09  Antony King  <antony.king@st.com>
+
+	Fix INSbl26654:
+	* shtdi.c: Added implementation of DllError() for reporting DLL
+	API errors.
+
+2006-11-08  Antony King  <antony.king@st.com>
+
+	* shtdi.c (shtdi_wait): Convert target signal from SIGTRAP
+	to SIGINT if user has interrupted the target.
+
+2006-10-27  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* shtdi.c (shtdi_close): Don't Deinitialize if not connected.
+
+2006-10-25  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* shtdi.c (shtdi_new_objfile): Don't inform the RTOS awareness when
+	relocatable libraries are loaded.
+
+2006-10-11  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.5-ST-1.0.50.
+
+2006-09-27  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-tdep.c (shtdi_init_simulator_hook): New function.
+	* shtdi.c: New file.
+	* symfile.c (download_write_size): Remove 'static'.
+	* symfile.h (download_write_size): New declaration.
+	* command.h (enum command_class): Add class_stm.
+	* cli/cli-cmds.c: Include windows.h, sys/time.h
+	(sleep_command): New function.
+	(init_cli_cmds): Add sleep command.
+	* config/sh/embed.mt (TDEPFILES): Add shtdi.o .
+	* config/sh/tm-sh.h (SHTDI_JOINT_HW_BREAK_LIMIT): New define.
+	(shtdi_init_simulator_hook): New prototype.
+
+2006-07-07  Denis Pilat  <denis.pilat@st.com>
+
+	* buildsym.c (start_subfile): convert cygwin path into standard windows
+	path for name and dirname parameters.
+
+2006-05-04  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl15583:
+	* thread.c (valid_thread_id): Call thread_alive() to confirm that
+	the thread table is up to date.
+
+2006-03-20  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* Makefile.in (WIN32RES_OBS): New make variable.
+	(gdb, gdbtui, insight): Add WIN32RES_OBS to dependencies and link.
+	* configure.ac: Add a check for MinGW.
+	(WIN32RES_OBS): New substitution.
+	* configure: Regenerate.
+
+2006-03-17  Denis Pilat  <denis.pilat@st.com>
+
+	* inflow.c (gdb_has_a_terminal): always returns 1 in case of minGW host.
+	This fixes the problem of dir command that do not query user.
+
+2006-03-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* main.c (captured_main): Replace cygdrive support using the cygpath
+	routine now in libiberty.
+	* source.c (directory_command): Likewise.
+	* cli/cli-cmds.c (cd_command, source_command): Likewise.
+
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-tdep.c (sh_gdbarch_init): Add missing architectures to the switch
+	table so that the registers and such are correct.
+
+2006-03-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* value.c (keep_variable_command): New function.
+	(_initialize_values): Add keep-variable command.
+
+2006-03-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-tdep.c (backtrace_abi_sniffer): New variable.
+	(sh_frame_this_id): Do nothing if backtrace_abi_sniffer zero.
+	(sh_gdbarch_init): Add set/show abi-sniffer command.
+	* frame.c (set_backtrace_cmdlist): Remove static.
+	(show_backtrace_cmdlist): Likewise.
+	* frame.h (set_backtrace_cmdlist): Add extern declaration.
+	(show_backtrace_cmdlist): Likewise.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cli/cli-cmds.c: Include errno.h, fcntl.h
+	(fork_escape): New function.
+	(init_cli_cmds): Add fork command.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* embed.mt (TDEPFILES): Add solib.o solib-svr4.o.
+	* config/sh/tm-sh.h: (SOLIB_BKPT_NAME): Define.
+	(TARGET_HAS_RELOCATABLE_LIB): Define.
+	* sh-tdep.c (sh_gdbarch_init): Call
+	set_solib_svr4_fetch_link_map_offsets.
+	* solib-svr4.c (enable_break): Add support for
+	TARGET_HAS_RELOCATABLE_LIB.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* config/sh/tm-sh.h (GDBINIT_FILENAME): Create to use .shgdbinit.
+
+2006-02-28  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.4-ST-1.0.50.
+
+2006-02-28  Denis Pilat  <denis.pilat@st.com>
+
+	* configure.ac: add the "win" to the configdir variable in case of
+	mingw host. Fix the bug that prevented insight.exe from beeing built.
+	* configure: Regenerate.
+
+2006-02-23  Denis Pilat  <denis.pilat@st.com>
+
+	* configure.ac: add pdcurses/pdcurses.a library to be linked when sts-gdb
+	is built for mingw hosts. Include file "curses.h" must be found in pdcurses
+	directory during configure step.
+	* configure: Regenerate.
+	* Makefile.in (CLIBS, CDEPS): add $(LIB_PDCURSES) pdcurses library
+	(INTERNAL_WARN_CFLAGS): add $(PDCURSES_CFLAGS) to compile pdcurses library
+
+2006-02-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cli/cli-cmds.c (cd_command, source_command): Add /cygdrive/ support
+	for use under MinGW.
+	* main.c (captured_main): Likewise.
+	* source.c (os_open): New function.
+	(openp, find_and_open_source): Use os_open() instead of open().
+	(directory_command): Add /cygdrive/ support for use under MinGW.
+
+2006-02-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* defs.h: Use MSDOS settings for MinGW.
+
+2006-01-25  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: set version to 6.4-ST-1.0.
+	* Makefile.in: generated version.c contains build date.
+
+2006-01-09  Denis Pilat  <denis.pilat@st.com>
+
+	* configure, configure.ac: remove win32-termcap that redefines
+	standard termcap function since we use pdcurses library
+	that redefine it for mingw32 host.
+
+2006-01-09  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* tui/tui-io.c (TUI_USE_PIPE_FOR_READLINE): Undefine.
+
+2006-01-09  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.ac (curses test): Look for curses before ncurses when the
+	host is MinGW (prefer PDcurses over cygwin ncurses).
+	* configure: Regenerate.
+
+2006-01-06  Denis Pilat  <denis.pilat@st.com>
+
+	Apply the insight minGW patch
+	http://sourceforge.net/forum/forum.php?forum_id=511897 for the following:
+	* configure.ac: add kernel32 and psapi library in WIN32LIBS,
+	add configdir="win" for mingw32 host
+	* configure: Regenerate.
+	* configure.host: add mingw32 host support
+	* configure.tgt: add mingw32 host support for arm
+	* remote-rdp.c: for MINGW32 compilation only:
+	 - define WIN32_LEAN_AND_MEAN before includion of windows.h to
+	 - excludes useless headers from the build and reduces compile time.
+	 - add a 3 sec timer when error accessing the board thru RDP interface.
+	* win32-nat.c: windows porting, allow compilation on MSYS environment
+	* config/arm/mingw_embed.mt: add mingw32 host support for arm
+	* config/i386/mingw32.mh: added for mingw32 native compilation,
+	definitions for hosting on WIN32, building with MinGW.
+	* config/i386/mingw32.mt: Likewise.
+	* config/i386/nm-mingw32.h: Likewise.
+	* config/i386/tm-mingw32.h: Likewise.
+	* config/i386/xm-mingw32.h: Likewise.
diff -Naur gdb-6.8/gdb/cli/cli-cmds.c stsgdb-6.8/gdb/cli/cli-cmds.c
--- gdb-6.8/gdb/cli/cli-cmds.c	2008-01-01 22:53:14.000000000 +0000
+++ stsgdb-6.8/gdb/cli/cli-cmds.c	2008-09-11 10:35:28.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
    This file is part of GDB.
 
@@ -18,6 +19,11 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
+#ifdef __MINGW32__
+#include <windows.h>
+#include <errno.h>
+#endif
+#include <math.h>
 #include "defs.h"
 #include "readline/readline.h"
 #include "readline/tilde.h"
@@ -44,6 +50,7 @@
 #include "cli/cli-script.h"
 #include "cli/cli-setshow.h"
 #include "cli/cli-cmds.h"
+#include "cli/cli-dump.h"
 
 #ifdef TUI
 #include "tui/tui.h"		/* For tui_active et.al.   */
@@ -83,6 +90,10 @@
 
 void apropos_command (char *, int);
 
+static void sleep_command(char *, int);
+
+static void fork_escape (char *, int);
+
 /* Prototypes for local utility functions */
 
 static void ambiguous_line_spec (struct symtabs_and_lines *);
@@ -345,6 +356,7 @@
     error_no_arg (_("new working directory"));
 
   dir = tilde_expand (dir);
+  CYGPATH_REPLACE (&dir);
   make_cleanup (xfree, dir);
 
   if (chdir (dir) < 0)
@@ -444,6 +456,7 @@
     }
 
   file = tilde_expand (file);
+  CYGPATH_REPLACE (&file);
   old_cleanups = make_cleanup (xfree, file);
 
   /* Search for and open 'file' on the search path used for source
@@ -981,6 +994,139 @@
 }
 
 static void
+sleep_command (char *arg, int from_tty)
+{
+  unsigned long sec = 0, usec = 0;
+
+  if (!arg)
+    goto error;
+
+  /* Read the first parameter: seconds.  */
+  sec = parse_and_eval_long (scan_expression_with_cleanup (&arg, NULL));
+
+  /* Read the second parameter: microseconds.
+     This parameter is optional so it is not an error if it is missing.  */
+  if (arg && *arg)
+    usec = parse_and_eval_long (arg);
+
+#ifdef __MINGW32__
+  /* Windows Sleep works in milleseconds, not microseconds.
+     Round up to the the next millisecond to ensure that
+     there is some pause when asking for small numbers.  */
+  Sleep ((sec*1000) + (unsigned long) ceil (usec/1000.0));
+#else
+  /* Ensure usec is not greater than 1 second.  */
+  sec += (usec/1000000);
+  usec %= 1000000;
+
+  if (sec) sleep (sec);
+  if (usec) usleep (usec);
+#endif
+
+  return;
+
+ error:
+  error ("Error: bad parameters to sleep command\n\
+Syntax: sleep seconds [useconds]");
+}
+
+/* ARGSUSED */
+static void
+fork_escape (char *arg, int from_tty)
+{
+  int status, pid;
+  int fd[2];
+  FILE *childstdout;
+  char *execname;
+  char *execargs;
+
+#ifndef __MINGW32__
+  if (pipe(fd) < 0)
+#else
+  if (_pipe(fd, 0, O_BINARY))
+#endif
+    {
+       fprintf_unfiltered (gdb_stderr, "Parent Cannot create pipe %s\n", 
+                           safe_strerror (errno)); 
+       gdb_flush (gdb_stderr);
+    }
+
+  execname = strtok(arg, " ");
+  execargs = arg + strlen(execname) + 1;
+#ifdef __MINGW32__
+  {
+    /* On Windows the arg list to _spawn does not work as it should.
+       Instead of keeping the arguments as given to it flattens them
+       into a string and then splits the string at the spaces and quotes.
+       The whole argument list to the gdb fork command is supposed to be
+       passed as one argument to the child. Therefore, on windows, use
+       quotes to get the right effect. This also requires that any existing
+       quotes are escaped or everything will fall apart. */
+    int count=0,i=0;
+    char *args = execargs;
+
+    /* count the number of double quotes in the arg list */
+    while ( args[i] != '\0' )
+      if ( args[i++] == '"' )
+	count++;
+
+    /* allocate space for the string, the new quotes
+       and the escapes for the old quotes */
+    execargs = alloca(sizeof(char) * (strlen(execargs)+2+count+1));
+
+    /* build the new argument */
+    i=0;
+    execargs[i++] = '"';              /* open quotes */
+    while ( *args != '\0' )
+      {
+	if ( *args == '"' )
+	  execargs[i++] = '\\';       /* escape existing quotes */
+	execargs[i++] = *args++;      /* copy character */
+      }
+    execargs[i++] = '"';              /* close quotes */
+    execargs[i] = '\0';               /* terminate string */
+  }
+#endif
+
+#ifndef __MINGW32__
+  if ((pid = fork ()) == 0)
+#endif
+    {
+       char pipefd[16],pipefd2[16];
+       sprintf (pipefd, "%d", fd[1]);
+       sprintf (pipefd2, "%d", fd[0]);
+
+#ifndef __MINGW32__
+       (void) setsid(); /* Set child to be leader of own process group */ 
+       execlp (execname, execname, pipefd, pipefd2, execargs, (char *)NULL);
+       fprintf_unfiltered (gdb_stderr, "Cannot execute %s: %s\n", execname,
+                           safe_strerror (errno));
+       gdb_flush (gdb_stderr);
+       _exit (0177);
+#else
+       /* note that _spawnlp seems to flatten the argument list
+	  which causes it to get broken at the spaces not the real breaks */
+       if ((pid =_spawnlp (_P_NOWAIT, execname, execname, pipefd, pipefd2, execargs, NULL)) == -1)
+         {
+	   fprintf_unfiltered (gdb_stderr, "Cannot execute %s: %s\n", execname,
+                           safe_strerror (errno));
+	   gdb_flush (gdb_stderr);
+	 }
+#endif
+    }
+
+  close(fd[1]);
+  childstdout = fdopen(fd[0], "r");
+
+  if (pid != -1)
+      read_command_file(childstdout);
+  else
+    error ("Fork failed");
+
+  fclose(childstdout);
+}
+
+static void
 make_command (char *arg, int from_tty)
 {
   char *p;
@@ -1346,6 +1492,16 @@
 With no arguments, run an inferior shell."));
   set_cmd_completer (c, filename_completer);
 
+  c = add_com ("fork", class_support, fork_escape,
+	       "Spawn a plugin process.\n\
+The first argument is the program name.\n\
+The rest are the parameters to pass to the program.\n\
+The program actually starts with:\n\
+  program fdout fdin args ...\n\
+where fdout is a pipe into which GDB commands may be passed\n\
+and fdin is the read end of the same pipe.");
+  set_cmd_completer (c, filename_completer);
+
   c = add_com ("edit", class_files, edit_command, _("\
 Edit specified file or function.\n\
 With no argument, edits file containing most recent line listed.\n\
@@ -1423,4 +1579,8 @@
 			   NULL,
 			   NULL,
 			   &setlist, &showlist);
+
+  add_com ("sleep", class_support, sleep_command, "\
+Sleep for a given time. Takes one or two arguments.\n\
+The first argument is in sec and the second argument is in usec.");
 }
diff -Naur gdb-6.8/gdb/command.h stsgdb-6.8/gdb/command.h
--- gdb-6.8/gdb/command.h	2008-01-01 22:53:09.000000000 +0000
+++ stsgdb-6.8/gdb/command.h	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 1986, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1999, 2000,
    2002, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -33,7 +34,7 @@
   no_class = -1, class_run = 0, class_vars, class_stack,
   class_files, class_support, class_info, class_breakpoint, class_trace,
   class_alias, class_obscure, class_user, class_maintenance,
-  class_pseudo, class_tui, class_xdb
+  class_pseudo, class_tui, class_xdb, class_stm
 };
 
 /* FIXME: cagney/2002-03-17: Once cmd_type() has been removed, ``enum
diff -Naur gdb-6.8/gdb/config.in stsgdb-6.8/gdb/config.in
--- gdb-6.8/gdb/config.in	2008-01-08 19:38:33.000000000 +0000
+++ stsgdb-6.8/gdb/config.in	2008-09-11 10:35:35.000000000 +0100
@@ -27,6 +27,9 @@
    language is requested. */
 #undef ENABLE_NLS
 
+/* Name of the GDB initialization file. */
+#undef GDBINIT_FILENAME
+
 /* Define to be a string naming the default host character set. */
 #undef GDB_DEFAULT_HOST_CHARSET
 
@@ -155,6 +158,9 @@
 /* Define to 1 if you have the `m' library (-lm). */
 #undef HAVE_LIBM
 
+/* Define to 1 if you have the `thread' library (-lthread). */
+#undef HAVE_LIBTHREAD
+
 /* Define if libunwind library is being used. */
 #undef HAVE_LIBUNWIND
 
@@ -534,24 +540,33 @@
 /* Define to 1 if the `setpgrp' function takes no argument. */
 #undef SETPGRP_VOID
 
-/* The size of a `char', as computed by sizeof. */
+/* SHTDI to GDB register number mapping function. */
+#undef SHTDI_GDB_REGISTER_MAP
+
+/* Number of shared H/W code and data breakpoints. */
+#undef SHTDI_JOINT_HW_BREAK_LIMIT
+
+/* The size of `char', as computed by sizeof. */
 #undef SIZEOF_CHAR
 
-/* The size of a `int', as computed by sizeof. */
+/* The size of `int', as computed by sizeof. */
 #undef SIZEOF_INT
 
-/* The size of a `long', as computed by sizeof. */
+/* The size of `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
-/* The size of a `short', as computed by sizeof. */
+/* The size of `short', as computed by sizeof. */
 #undef SIZEOF_SHORT
 
-/* The size of a `void *', as computed by sizeof. */
+/* The size of `void *', as computed by sizeof. */
 #undef SIZEOF_VOID_P
 
+/* Shared library breakpoint hook. */
+#undef SOLIB_BKPT_NAME
+
 /* If using the C implementation of alloca, define if you know the
    direction of stack growth for your system; otherwise it will be
-   automatically deduced at run-time.
+   automatically deduced at runtime.
 	STACK_DIRECTION > 0 => grows toward higher addresses
 	STACK_DIRECTION < 0 => grows toward lower addresses
 	STACK_DIRECTION = 0 => direction of growth unknown */
@@ -563,6 +578,9 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* Define if the target supports relocatable libraries. */
+#undef TARGET_HAS_RELOCATABLE_LIB
+
 /* Define if <thread_db.h> has the TD_NOTALLOC error code. */
 #undef THREAD_DB_HAS_TD_NOTALLOC
 
diff -Naur gdb-6.8/gdb/configure stsgdb-6.8/gdb/configure
--- gdb-6.8/gdb/configure	2008-01-13 12:23:04.000000000 +0000
+++ stsgdb-6.8/gdb/configure	2008-09-11 10:35:35.000000000 +0100
@@ -313,7 +313,7 @@
 ac_subdirs_all="$ac_subdirs_all gdbtk"
 ac_subdirs_all="$ac_subdirs_all multi-ice"
 ac_subdirs_all="$ac_subdirs_all gdbserver"
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT localedir PACKAGE subdirs TARGET_OBS AWK INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN_S RANLIB ac_ct_RANLIB YACC AR ac_ct_AR DLLTOOL ac_ct_DLLTOOL WINDRES ac_ct_WINDRES MIG ac_ct_MIG READLINE READLINE_DEPS READLINE_CFLAGS HAVE_LIBEXPAT LIBEXPAT LTLIBEXPAT ALLOCA CONFIG_LDFLAGS TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE WARN_CFLAGS WERROR_CFLAGS SER_HARDWIRE WIN32LIBS LIBGUI GUI_CFLAGS_X WIN32LDAPP TCL_VERSION TCL_MAJOR_VERSION TCL_MINOR_VERSION TCL_CC TCL_DEFS TCL_SHLIB_CFLAGS TCL_SHLIB_LD TCL_SHLIB_LD_LIBS TCL_SHLIB_SUFFIX TCL_DL_LIBS TCL_LD_FLAGS TCL_LD_SEARCH_FLAGS TCL_CC_SEARCH_FLAGS TCL_COMPAT_OBJS TCL_RANLIB TCL_BUILD_LIB_SPEC TCL_LIB_SPEC TCL_LIB_VERSIONS_OK TK_VERSION TK_DEFS TK_BUILD_INCLUDES TK_XINCLUDES TK_XLIBSW TK_BUILD_LIB_SPEC TK_LIB_SPEC TCLHDIR TKHDIR ITCLHDIR ITKHDIR ITCL_VERSION ITCL_DEFS ITCL_BUILD_INCLUDES ITCL_BUILD_LIB_SPEC ITCL_LIB_SPEC ITK_VERSION ITK_DEFS ITK_BUILD_INCLUDES ITK_BUILD_LIB_SPEC ITK_LIB_SPEC X_CFLAGS X_LDFLAGS X_LIBS TCL_DEPS TK_DEPS ITCLLIB ITCL_DEPS ITKLIB ITK_DEPS GDBTKLIBS GDBTK_CFLAGS GDBTK_SRC_DIR SIM SIM_OBS ENABLE_CFLAGS PROFILE_CFLAGS CONFIG_OBS CONFIG_DEPS CONFIG_SRCS CONFIG_ALL CONFIG_CLEAN CONFIG_INSTALL CONFIG_UNINSTALL target_subdir frags nm_h LIBICONV LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS DATADIRNAME INSTOBJEXT GENCAT CATOBJEXT localedir PACKAGE subdirs TARGET_OBS AWK INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA LN_S RANLIB ac_ct_RANLIB YACC AR ac_ct_AR DLLTOOL ac_ct_DLLTOOL WINDRES ac_ct_WINDRES MIG ac_ct_MIG LIB_PDCURSES PDCURSES_CFLAGS READLINE READLINE_DEPS READLINE_CFLAGS HAVE_LIBEXPAT LIBEXPAT LTLIBEXPAT ALLOCA CONFIG_LDFLAGS TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE WARN_CFLAGS WERROR_CFLAGS SER_HARDWIRE WIN32LIBS LIBGUI GUI_CFLAGS_X WIN32LDAPP TCL_VERSION TCL_MAJOR_VERSION TCL_MINOR_VERSION TCL_CC TCL_DEFS TCL_SHLIB_CFLAGS TCL_SHLIB_LD TCL_SHLIB_LD_LIBS TCL_SHLIB_SUFFIX TCL_DL_LIBS TCL_LD_FLAGS TCL_LD_SEARCH_FLAGS TCL_CC_SEARCH_FLAGS TCL_COMPAT_OBJS TCL_RANLIB TCL_BUILD_LIB_SPEC TCL_LIB_SPEC TCL_LIB_VERSIONS_OK TK_VERSION TK_DEFS TK_BUILD_INCLUDES TK_XINCLUDES TK_XLIBSW TK_BUILD_LIB_SPEC TK_LIB_SPEC TCLHDIR TKHDIR ITCLHDIR ITKHDIR ITCL_VERSION ITCL_DEFS ITCL_BUILD_INCLUDES ITCL_BUILD_LIB_SPEC ITCL_LIB_SPEC ITK_VERSION ITK_DEFS ITK_BUILD_INCLUDES ITK_BUILD_LIB_SPEC ITK_LIB_SPEC X_CFLAGS X_LDFLAGS X_LIBS TCL_DEPS TK_DEPS ITCLLIB ITCL_DEPS ITKLIB ITK_DEPS GDBTKLIBS GDBTK_CFLAGS GDBTK_SRC_DIR WIN32RES_OBS SIM SIM_OBS ENABLE_CFLAGS PROFILE_CFLAGS CONFIG_OBS CONFIG_DEPS CONFIG_SRCS CONFIG_ALL CONFIG_CLEAN CONFIG_INSTALL CONFIG_UNINSTALL target_subdir frags nm_h LIBICONV GDBRESOPTS LIBOBJS LTLIBOBJS'
 ac_subst_files='host_makefile_frag'
 
 # Initialize some variables set by options.
@@ -5573,6 +5573,76 @@
 fi
 
 
+# We might need to link with -lthread.
+
+echo "$as_me:$LINENO: checking for main in -lthread" >&5
+echo $ECHO_N "checking for main in -lthread... $ECHO_C" >&6
+if test "${ac_cv_lib_thread_main+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lthread  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+
+int
+main ()
+{
+main ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_thread_main=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_thread_main=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_thread_main" >&5
+echo "${ECHO_T}$ac_cv_lib_thread_main" >&6
+if test $ac_cv_lib_thread_main = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBTHREAD 1
+_ACEOF
+
+  LIBS="-lthread $LIBS"
+
+fi
+
+
 # We need to link with -lw to get `wctype' on Solaris before Solaris
 # 2.6.  Solaris 2.6 and beyond have this function in libc, and have a
 # libw that some versions of the GNU linker cannot hanle (GNU ld 2.9.1
@@ -6012,7 +6082,18 @@
 # search /usr/local/include, if ncurses is installed in /usr/local.  A
 # default installation of ncurses on alpha*-dec-osf* will lead to such
 # a situation.
-echo "$as_me:$LINENO: checking for library containing waddstr" >&5
+# However, with MinGW we use pdcurses library integrated into the
+# gdb repository: pdcurses/pdcurses.a, include file "curses.h" must
+# be found in pdcurses directory as well
+case $host_os in
+  mingw*)
+    LIB_PDCURSES="../pdcurses/pdcurses.a"
+    PDCURSES_CFLAGS="-I${srcdir}/../pdcurses"
+
+
+    ;;
+  *)
+    echo "$as_me:$LINENO: checking for library containing waddstr" >&5
 echo $ECHO_N "checking for library containing waddstr... $ECHO_C" >&6
 if test "${ac_cv_search_waddstr+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -6137,7 +6218,8 @@
   test "$ac_cv_search_waddstr" = "none required" || LIBS="$ac_cv_search_waddstr $LIBS"
 
 fi
-
+ ;;
+esac
 
 # On HP/UX we may need libxpdl for dlgetmodinfo (used by solib-pa64.c).
 echo "$as_me:$LINENO: checking for library containing dlgetmodinfo" >&5
@@ -6270,20 +6352,15 @@
 # Since GDB uses Readline, we need termcap functionality.  In many
 # cases this will be provided by the curses library, but some systems
 # have a seperate termcap library, or no curses library at all.
-
 case $host_os in
   cygwin*)
     if test -d $srcdir/libtermcap; then
       LIBS="../libtermcap/libtermcap.a $LIBS"
       ac_cv_search_tgetent="../libtermcap/libtermcap.a"
     fi ;;
-  go32* | *djgpp*)
+  go32* | *djgpp* | mingw*)
     ac_cv_search_tgetent="none required"
     ;;
-  *mingw32*)
-    ac_cv_search_tgetent="none required"
-    CONFIG_OBS="$CONFIG_OBS win32-termcap.o"
-    ;;
 esac
 
 # These are the libraries checked by Readline.
@@ -11607,9 +11684,321 @@
 esac
 
 
+# With MinGW we use pdcurses library integrated into the gdb repository
+# "curses.h" must be found in src/pdcurses directory
+case $host_os in
+  mingw*)
+    SAVE_CPPFLAGS="${CPPFLAGS}"
+    CPPFLAGS=$CPPFLAGS\ $PDCURSES_CFLAGS
+
+for ac_header in curses.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+    CPPFLAGS="${SAVE_CPPFLAGS}"
+    ;;
+  *)
+
+for ac_header in curses.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
 
+done
 
-for ac_header in curses.h cursesX.h ncurses.h ncurses/ncurses.h
+    ;;
+esac
+
+
+
+for ac_header in cursesX.h ncurses.h ncurses/ncurses.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
@@ -22958,6 +23347,35 @@
 echo "$as_me:$LINENO: result: $gdb_cv_os_cygwin" >&5
 echo "${ECHO_T}$gdb_cv_os_cygwin" >&6
 
+# Check for MinGW
+echo "$as_me:$LINENO: checking for mingw" >&5
+echo $ECHO_N "checking for mingw... $ECHO_C" >&6
+if test "${gdb_cv_os_mingw+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#if defined (__MINGW__) || defined (__MINGW32__)
+lose
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "lose" >/dev/null 2>&1; then
+  gdb_cv_os_mingw=yes
+else
+  gdb_cv_os_mingw=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $gdb_cv_os_mingw" >&5
+echo "${ECHO_T}$gdb_cv_os_mingw" >&6
+
 
 SER_HARDWIRE="ser-base.o ser-unix.o ser-pipe.o ser-tcp.o"
 case ${host} in
@@ -22985,7 +23403,7 @@
 #define USE_WIN32API 1
 _ACEOF
 
-    WIN32LIBS="$WIN32LIBS -lws2_32"
+    WIN32LIBS="$WIN32LIBS -lws2_32 -lkernel32 -lpsapi"
     ;;
 esac
 
@@ -23080,7 +23498,7 @@
 
 
 case "${host}" in
-*-*-cygwin*)
+*-*-cygwin* | *mingw32*)
     configdir="win"
     ;;
 *)
@@ -23089,6 +23507,7 @@
 esac
 
 GDBTKLIBS=
+WIN32RES_OBS=
 if test "${enable_gdbtk}" = "yes"; then
 
     # Gdbtk must have an absolute path to srcdir in order to run
@@ -24113,10 +24532,11 @@
 	   CONFIG_INSTALL="${CONFIG_INSTALL} install-gdbtk"
 	   CONFIG_UNINSTALL="${CONFIG_UNINSTALL} uninstall-gdbtk"
 
-	   if test x$gdb_cv_os_cygwin = xyes; then
+	   if test x$gdb_cv_os_cygwin = xyes \
+		|| test x$gdb_cv_os_mingw = xyes; then
 	      WIN32LIBS="${WIN32LIBS} -lshell32 -lgdi32 -lcomdlg32 -ladvapi32"
 	      WIN32LDAPP="-Wl,--subsystem,console"
-	      CONFIG_OBS="${CONFIG_OBS} gdbres.o"
+	      WIN32RES_OBS="${WIN32RES_OBS} gdbres.o"
 	   fi
 	fi
     fi
@@ -24140,6 +24560,7 @@
 
 
 
+
 echo "$as_me:$LINENO: checking for X" >&5
 echo $ECHO_N "checking for X... $ECHO_C" >&6
 
@@ -24802,6 +25223,44 @@
 
 
 
+if test "x$enable_shared" = xno; then
+  gdbresopts='-DSTATIC_TK_LIBRARY -I$(srcdir)/../tk/win/rc'
+else
+  gdbresopts=
+fi
+GDBRESOPTS=$gdbresopts
+
+
+case "$target" in
+sh*-superh-elf*)
+
+cat >>confdefs.h <<_ACEOF
+#define GDBINIT_FILENAME ".shgdbinit"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define SHTDI_GDB_REGISTER_MAP sh_gdb_to_shtdi_regno
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define TARGET_HAS_RELOCATABLE_LIB 1
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define SOLIB_BKPT_NAME "_r_debug_state"
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define SHTDI_JOINT_HW_BREAK_LIMIT 3
+_ACEOF
+
+;;
+esac
+
                     ac_config_files="$ac_config_files Makefile .gdbinit:gdbinit.in"
           ac_config_commands="$ac_config_commands default"
 cat >confcache <<\_ACEOF
@@ -25518,6 +25977,8 @@
 s,@ac_ct_WINDRES@,$ac_ct_WINDRES,;t t
 s,@MIG@,$MIG,;t t
 s,@ac_ct_MIG@,$ac_ct_MIG,;t t
+s,@LIB_PDCURSES@,$LIB_PDCURSES,;t t
+s,@PDCURSES_CFLAGS@,$PDCURSES_CFLAGS,;t t
 s,@READLINE@,$READLINE,;t t
 s,@READLINE_DEPS@,$READLINE_DEPS,;t t
 s,@READLINE_CFLAGS@,$READLINE_CFLAGS,;t t
@@ -25586,6 +26047,7 @@
 s,@GDBTKLIBS@,$GDBTKLIBS,;t t
 s,@GDBTK_CFLAGS@,$GDBTK_CFLAGS,;t t
 s,@GDBTK_SRC_DIR@,$GDBTK_SRC_DIR,;t t
+s,@WIN32RES_OBS@,$WIN32RES_OBS,;t t
 s,@SIM@,$SIM,;t t
 s,@SIM_OBS@,$SIM_OBS,;t t
 s,@ENABLE_CFLAGS@,$ENABLE_CFLAGS,;t t
@@ -25601,6 +26063,7 @@
 s,@frags@,$frags,;t t
 s,@nm_h@,$nm_h,;t t
 s,@LIBICONV@,$LIBICONV,;t t
+s,@GDBRESOPTS@,$GDBRESOPTS,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
 s,@LTLIBOBJS@,$LTLIBOBJS,;t t
 /@host_makefile_frag@/r $host_makefile_frag
diff -Naur gdb-6.8/gdb/configure.ac stsgdb-6.8/gdb/configure.ac
--- gdb-6.8/gdb/configure.ac	2008-01-13 12:23:05.000000000 +0000
+++ stsgdb-6.8/gdb/configure.ac	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
 dnl Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 dnl 2005, 2006
 dnl Free Software Foundation, Inc.
+dnl Copyright (C) 2007 STMicroelectronics
 dnl
 dnl This file is part of GDB.
 dnl 
@@ -381,6 +382,9 @@
 # We might need to link with -lm; most simulators need it.
 AC_CHECK_LIB(m, main)
 
+# We might need to link with -lthread.
+AC_CHECK_LIB(thread, main)
+
 # We need to link with -lw to get `wctype' on Solaris before Solaris
 # 2.6.  Solaris 2.6 and beyond have this function in libc, and have a
 # libw that some versions of the GNU linker cannot hanle (GNU ld 2.9.1
@@ -403,7 +407,19 @@
 # search /usr/local/include, if ncurses is installed in /usr/local.  A
 # default installation of ncurses on alpha*-dec-osf* will lead to such
 # a situation.
-AC_SEARCH_LIBS(waddstr, [ncurses cursesX curses])
+# However, with MinGW we use pdcurses library integrated into the 
+# gdb repository: pdcurses/pdcurses.a, include file "curses.h" must 
+# be found in pdcurses directory as well
+case $host_os in
+  mingw*) 
+    LIB_PDCURSES="../pdcurses/pdcurses.a"
+    PDCURSES_CFLAGS="-I${srcdir}/../pdcurses"
+    AC_SUBST(LIB_PDCURSES)
+    AC_SUBST(PDCURSES_CFLAGS)
+    ;;
+  *)
+    AC_SEARCH_LIBS(waddstr, [ncurses cursesX curses]) ;;
+esac
 
 # On HP/UX we may need libxpdl for dlgetmodinfo (used by solib-pa64.c).
 AC_SEARCH_LIBS(dlgetmodinfo, [dl xpdl])
@@ -411,20 +427,15 @@
 # Since GDB uses Readline, we need termcap functionality.  In many
 # cases this will be provided by the curses library, but some systems
 # have a seperate termcap library, or no curses library at all.
-
 case $host_os in
   cygwin*)
     if test -d $srcdir/libtermcap; then
       LIBS="../libtermcap/libtermcap.a $LIBS"
       ac_cv_search_tgetent="../libtermcap/libtermcap.a"
     fi ;;
-  go32* | *djgpp*)
+  go32* | *djgpp* | mingw*)
     ac_cv_search_tgetent="none required"
     ;;
-  *mingw32*)	 
-    ac_cv_search_tgetent="none required"
-    CONFIG_OBS="$CONFIG_OBS win32-termcap.o"
-    ;;
 esac
 
 # These are the libraries checked by Readline.
@@ -538,7 +549,22 @@
    Solaris 2.[789] when using GCC. ])
     fi ;;
 esac
-AC_CHECK_HEADERS(curses.h cursesX.h ncurses.h ncurses/ncurses.h)
+
+
+# With MinGW we use pdcurses library integrated into the gdb repository
+# "curses.h" must be found in src/pdcurses directory 
+case $host_os in
+  mingw*) 
+    SAVE_CPPFLAGS="${CPPFLAGS}"
+    CPPFLAGS=$CPPFLAGS\ $PDCURSES_CFLAGS
+    AC_CHECK_HEADERS(curses.h)
+    CPPFLAGS="${SAVE_CPPFLAGS}"
+    ;;
+  *)
+    AC_CHECK_HEADERS(curses.h)
+    ;;
+esac
+AC_CHECK_HEADERS(cursesX.h ncurses.h ncurses/ncurses.h)
 AC_CHECK_HEADERS(ncurses/term.h)
 AC_CHECK_HEADERS(term.h, [], [],
 [#if HAVE_CURSES_H
@@ -1374,6 +1400,13 @@
 lose
 #endif],[gdb_cv_os_cygwin=yes],[gdb_cv_os_cygwin=no])])
 
+# Check for MinGW
+AC_CACHE_CHECK([for mingw], gdb_cv_os_mingw,
+[AC_EGREP_CPP(lose, [
+#if defined (__MINGW__) || defined (__MINGW32__)
+lose
+#endif],[gdb_cv_os_mingw=yes],[gdb_cv_os_mingw=no])])
+
 
 dnl Figure out which of the many generic ser-*.c files the _host_ supports.
 SER_HARDWIRE="ser-base.o ser-unix.o ser-pipe.o ser-tcp.o"
@@ -1402,7 +1435,7 @@
 	       POSIX API.  On Windows, we use the Windows API when 
 	       building for MinGW, but the POSIX API when building 
 	       for Cygwin.])
-    WIN32LIBS="$WIN32LIBS -lws2_32"
+    WIN32LIBS="$WIN32LIBS -lws2_32 -lkernel32 -lpsapi"
     ;;
 esac	    
 AC_SUBST(WIN32LIBS)
@@ -1445,7 +1478,7 @@
 AC_SUBST(WIN32LDAPP)
 
 case "${host}" in
-*-*-cygwin*)
+*-*-cygwin* | *mingw32*)
     configdir="win"
     ;;
 *)
@@ -1454,6 +1487,7 @@
 esac
 
 GDBTKLIBS=
+WIN32RES_OBS=
 if test "${enable_gdbtk}" = "yes"; then
 
     # Gdbtk must have an absolute path to srcdir in order to run
@@ -1529,10 +1563,11 @@
 	   CONFIG_INSTALL="${CONFIG_INSTALL} install-gdbtk"
 	   CONFIG_UNINSTALL="${CONFIG_UNINSTALL} uninstall-gdbtk"
 
-	   if test x$gdb_cv_os_cygwin = xyes; then
+	   if test x$gdb_cv_os_cygwin = xyes \
+		|| test x$gdb_cv_os_mingw = xyes; then
 	      WIN32LIBS="${WIN32LIBS} -lshell32 -lgdi32 -lcomdlg32 -ladvapi32"
 	      WIN32LDAPP="-Wl,--subsystem,console"
-	      CONFIG_OBS="${CONFIG_OBS} gdbres.o"
+	      WIN32RES_OBS="${WIN32RES_OBS} gdbres.o"
 	   fi
 	fi
     fi
@@ -1552,6 +1587,7 @@
 AC_SUBST(GDBTKLIBS)
 AC_SUBST(GDBTK_CFLAGS)
 AC_SUBST(GDBTK_SRC_DIR)
+AC_SUBST(WIN32RES_OBS)
 
 AC_PATH_X
 
@@ -1721,6 +1757,27 @@
 
 AM_ICONV
 
+dnl  Detect whether or not gdbres.o (Windows resource file) needs
+dnl  special treatment.  This is the case for --disable-shared.
+dnl  Note that it is safe to assume the tk sources are in the
+dnl  source tree because insight is not supported any other way.
+if test "x$enable_shared" = xno; then
+  gdbresopts='-DSTATIC_TK_LIBRARY -I$(srcdir)/../tk/win/rc'
+else
+  gdbresopts=
+fi
+AC_SUBST(GDBRESOPTS,$gdbresopts)
+
+case "$target" in
+sh*-superh-elf*)
+  AC_DEFINE_UNQUOTED(GDBINIT_FILENAME, ".shgdbinit", [Name of the GDB initialization file. ])
+  AC_DEFINE_UNQUOTED(SHTDI_GDB_REGISTER_MAP, sh_gdb_to_shtdi_regno, [SHTDI to GDB register number mapping function. ])
+  AC_DEFINE(TARGET_HAS_RELOCATABLE_LIB, 1, [Define if the target supports relocatable libraries. ])
+  AC_DEFINE_UNQUOTED(SOLIB_BKPT_NAME, "_r_debug_state", [Shared library breakpoint hook. ])
+  AC_DEFINE(SHTDI_JOINT_HW_BREAK_LIMIT, 3, [Number of shared H/W code and data breakpoints. ])
+;;
+esac
+
 AC_OUTPUT(Makefile .gdbinit:gdbinit.in,
 [
 dnl Autoconf doesn't provide a mechanism for modifying definitions 
diff -Naur gdb-6.8/gdb/configure.host stsgdb-6.8/gdb/configure.host
--- gdb-6.8/gdb/configure.host	2008-01-19 15:03:50.000000000 +0000
+++ stsgdb-6.8/gdb/configure.host	2008-09-11 10:35:35.000000000 +0100
@@ -101,6 +101,7 @@
 i[34567]86-*-solaris2.1[0-9]*)	gdb_host=sol2-64 ;;
 i[34567]86-*-solaris*)	gdb_host=i386sol2 ;;
 i[34567]86-*-cygwin*)	gdb_host=cygwin ;;
+i[34567]86-*-mingw32*)	gdb_host=mingw32 ;;
 
 ia64-*-linux*)		gdb_host=linux ;;
 
diff -Naur gdb-6.8/gdb/configure.tgt stsgdb-6.8/gdb/configure.tgt
--- gdb-6.8/gdb/configure.tgt	2008-02-11 21:58:41.000000000 +0000
+++ stsgdb-6.8/gdb/configure.tgt	2008-09-11 10:35:35.000000000 +0100
@@ -385,6 +385,12 @@
 	gdb_target_obs="sh-tdep.o sh64-tdep.o shnbsd-tdep.o \
 			corelow.o solib.o solib-svr4.o"
 	;;
+sh*-superh-elf*)
+	# Target: STMicroelectronics embedded Super-H
+	gdb_target_obs="sh-tdep.o sh64-tdep.o monitor.o dsrec.o \
+			shtdi.o solib.o solib-svr4.o"
+	gdb_sim=../sim/sh/libsim.a
+	;;
 sh64-*-elf*)
 	# Target: Renesas/Super-H 64 bit with simulator
 	gdb_target_obs="sh-tdep.o sh64-tdep.o"
diff -Naur gdb-6.8/gdb/cp-name-parser.c stsgdb-6.8/gdb/cp-name-parser.c
--- gdb-6.8/gdb/cp-name-parser.c	2008-03-27 18:27:12.000000000 +0000
+++ stsgdb-6.8/gdb/cp-name-parser.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -106,6 +119,7 @@
      ARROW = 308
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define FLOAT 259
 #define NAME 260
@@ -383,9 +397,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 240 "cp-name-parser.y"
-typedef union YYSTYPE {
+{
     struct demangle_component *comp;
     struct nested {
       struct demangle_component *comp;
@@ -406,9 +426,10 @@
       struct demangle_component *type;
     } typed_val_int;
     const char *opname;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 412 "cp-name-parser.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 432 "cp-name-parser.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -425,56 +446,170 @@
 };
 
 
-/* Line 214 of yacc.c.  */
-#line 430 "cp-name-parser.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 451 "cp-name-parser.c.tmp"
+
+#ifdef short
+# undef short
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -484,24 +619,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -519,39 +654,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  85
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   1054
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  76
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  40
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  195
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  325
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   308
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -589,7 +718,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,     9,    11,    12,    15,    18,
       22,    26,    29,    32,    35,    40,    42,    45,    48,    53,
@@ -613,8 +742,8 @@
      603,   609,   611,   613,   618,   620
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       77,     0,    -1,    78,    -1,   109,    -1,    81,    -1,    80,
       -1,    -1,    12,    78,    -1,   105,   112,    -1,   105,    96,
@@ -682,7 +811,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   366,   366,   370,   372,   374,   379,   380,   387,   396,
      399,   403,   406,   425,   429,   431,   437,   439,   441,   443,
@@ -707,9 +836,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "FLOAT", "NAME", "STRUCT",
@@ -739,7 +868,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -753,7 +882,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    76,    77,    78,    78,    78,    79,    79,    80,    80,
       80,    80,    80,    81,    81,    81,    82,    82,    82,    82,
@@ -778,7 +907,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     1,     1,     0,     2,     2,     3,
        3,     2,     2,     2,     4,     1,     2,     2,     4,     4,
@@ -805,7 +934,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
        0,    60,    98,     0,     0,    97,   100,   101,    96,    93,
       92,   106,   108,    91,   110,   105,    99,   109,     0,     0,
@@ -842,8 +971,8 @@
        0,     0,   168,   170,   169
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,    22,   156,    93,    24,    25,    26,    27,    28,    29,
      119,    30,   253,    31,    32,    79,    34,   143,   144,   167,
@@ -854,7 +983,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -263
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      702,    22,  -263,    41,   499,  -263,   -14,  -263,  -263,  -263,
     -263,  -263,  -263,  -263,  -263,  -263,  -263,  -263,   702,   702,
@@ -892,7 +1021,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
     -263,  -263,    25,   -86,  -263,  -263,  -263,     9,  -263,   -27,
     -263,    -1,   -32,   -13,     1,     0,   150,   170,    50,  -263,
@@ -905,7 +1034,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -1
-static const unsigned short yytable[] =
+static const yytype_uint16 yytable[] =
 {
       33,   179,    45,    47,    46,   103,   106,   243,   121,    99,
      175,   160,    44,    81,   124,   248,    91,   180,    33,    33,
@@ -1015,7 +1144,7 @@
        0,     0,   233,     0,   234
 };
 
-static const short yycheck[] =
+static const yytype_int16 yycheck[] =
 {
        0,    99,     3,     3,     3,    31,    33,   164,    40,    28,
       96,     3,     3,    27,    40,   172,    69,   103,    18,    19,
@@ -1127,7 +1256,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     5,    11,    12,    17,    21,    22,    23,    24,    25,
       26,    27,    28,    30,    31,    32,    33,    34,    38,    39,
@@ -1164,22 +1293,6 @@
      115,   115,    42,    42,    42
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -1205,30 +1318,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -1249,42 +1395,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -1293,45 +1493,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1346,13 +1553,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -1362,45 +1565,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -1410,70 +1615,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+  if (! yyres)
+    return yystrlen (yystr);
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1481,13 +1808,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1496,10 +1823,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1512,14 +1839,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1530,13 +1861,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1547,18 +1884,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1567,9 +1904,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1593,8 +1930,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1607,18 +1943,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1629,21 +1965,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1674,19 +2010,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1701,7 +2035,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1721,22 +2055,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1773,1053 +2106,1053 @@
     {
         case 2:
 #line 367 "cp-name-parser.y"
-    { global_result = yyvsp[0].comp; }
+    { global_result = (yyvsp[(1) - (1)].comp); }
     break;
 
   case 6:
 #line 379 "cp-name-parser.y"
-    { yyval.comp = NULL; }
+    { (yyval.comp) = NULL; }
     break;
 
   case 7:
 #line 381 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 8:
 #line 388 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].nested.comp;
-			  *yyvsp[0].nested.last = yyvsp[-1].comp;
+    { (yyval.comp) = (yyvsp[(2) - (2)].nested).comp;
+			  *(yyvsp[(2) - (2)].nested).last = (yyvsp[(1) - (2)].comp);
 			}
     break;
 
   case 9:
 #line 397 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, yyvsp[-2].comp, yyvsp[-1].nested.comp);
-			  if (yyvsp[0].comp) yyval.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, yyval.comp, yyvsp[0].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, (yyvsp[(1) - (3)].comp), (yyvsp[(2) - (3)].nested).comp);
+			  if ((yyvsp[(3) - (3)].comp)) (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, (yyval.comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 10:
 #line 400 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, yyvsp[-2].comp, yyvsp[-1].nested.comp);
-			  if (yyvsp[0].comp) yyval.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, yyval.comp, yyvsp[0].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, (yyvsp[(1) - (3)].comp), (yyvsp[(2) - (3)].nested).comp);
+			  if ((yyvsp[(3) - (3)].comp)) (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, (yyval.comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 11:
 #line 404 "cp-name-parser.y"
-    { yyval.comp = yyvsp[-1].nested.comp;
-			  if (yyvsp[0].comp) yyval.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, yyval.comp, yyvsp[0].comp); }
+    { (yyval.comp) = (yyvsp[(1) - (2)].nested).comp;
+			  if ((yyvsp[(2) - (2)].comp)) (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, (yyval.comp), (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 12:
 #line 407 "cp-name-parser.y"
-    { if (yyvsp[0].abstract.last)
+    { if ((yyvsp[(2) - (2)].abstract).last)
 			    {
 			       /* First complete the abstract_declarator's type using
 				  the typespec from the conversion_op_name.  */
-			      *yyvsp[0].abstract.last = *yyvsp[-1].nested.last;
+			      *(yyvsp[(2) - (2)].abstract).last = *(yyvsp[(1) - (2)].nested).last;
 			      /* Then complete the conversion_op_name with the type.  */
-			      *yyvsp[-1].nested.last = yyvsp[0].abstract.comp;
+			      *(yyvsp[(1) - (2)].nested).last = (yyvsp[(2) - (2)].abstract).comp;
 			    }
 			  /* If we have an arglist, build a function type.  */
-			  if (yyvsp[0].abstract.fn.comp)
-			    yyval.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, yyvsp[-1].nested.comp, yyvsp[0].abstract.fn.comp);
+			  if ((yyvsp[(2) - (2)].abstract).fn.comp)
+			    (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, (yyvsp[(1) - (2)].nested).comp, (yyvsp[(2) - (2)].abstract).fn.comp);
 			  else
-			    yyval.comp = yyvsp[-1].nested.comp;
-			  if (yyvsp[0].abstract.start) yyval.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, yyval.comp, yyvsp[0].abstract.start);
+			    (yyval.comp) = (yyvsp[(1) - (2)].nested).comp;
+			  if ((yyvsp[(2) - (2)].abstract).start) (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, (yyval.comp), (yyvsp[(2) - (2)].abstract).start);
 			}
     break;
 
   case 13:
 #line 426 "cp-name-parser.y"
-    { yyval.comp = make_empty (yyvsp[-1].lval);
-			  d_left (yyval.comp) = yyvsp[0].comp;
-			  d_right (yyval.comp) = NULL; }
+    { (yyval.comp) = make_empty ((yyvsp[(1) - (2)].lval));
+			  d_left ((yyval.comp)) = (yyvsp[(2) - (2)].comp);
+			  d_right ((yyval.comp)) = NULL; }
     break;
 
   case 14:
 #line 430 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE, yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE, (yyvsp[(2) - (4)].comp), (yyvsp[(4) - (4)].comp)); }
     break;
 
   case 15:
 #line 432 "cp-name-parser.y"
-    { yyval.comp = make_empty (yyvsp[0].typed_val_int.val);
-			  d_left (yyval.comp) = yyvsp[0].typed_val_int.type;
-			  d_right (yyval.comp) = NULL; }
+    { (yyval.comp) = make_empty ((yyvsp[(1) - (1)].typed_val_int).val);
+			  d_left ((yyval.comp)) = (yyvsp[(1) - (1)].typed_val_int).type;
+			  d_right ((yyval.comp)) = NULL; }
     break;
 
   case 16:
 #line 438 "cp-name-parser.y"
-    { yyval.comp = make_operator ("new", 1); }
+    { (yyval.comp) = make_operator ("new", 1); }
     break;
 
   case 17:
 #line 440 "cp-name-parser.y"
-    { yyval.comp = make_operator ("delete", 1); }
+    { (yyval.comp) = make_operator ("delete", 1); }
     break;
 
   case 18:
 #line 442 "cp-name-parser.y"
-    { yyval.comp = make_operator ("new[]", 1); }
+    { (yyval.comp) = make_operator ("new[]", 1); }
     break;
 
   case 19:
 #line 444 "cp-name-parser.y"
-    { yyval.comp = make_operator ("delete[]", 1); }
+    { (yyval.comp) = make_operator ("delete[]", 1); }
     break;
 
   case 20:
 #line 446 "cp-name-parser.y"
-    { yyval.comp = make_operator ("+", 2); }
+    { (yyval.comp) = make_operator ("+", 2); }
     break;
 
   case 21:
 #line 448 "cp-name-parser.y"
-    { yyval.comp = make_operator ("-", 2); }
+    { (yyval.comp) = make_operator ("-", 2); }
     break;
 
   case 22:
 #line 450 "cp-name-parser.y"
-    { yyval.comp = make_operator ("*", 2); }
+    { (yyval.comp) = make_operator ("*", 2); }
     break;
 
   case 23:
 #line 452 "cp-name-parser.y"
-    { yyval.comp = make_operator ("/", 2); }
+    { (yyval.comp) = make_operator ("/", 2); }
     break;
 
   case 24:
 #line 454 "cp-name-parser.y"
-    { yyval.comp = make_operator ("%", 2); }
+    { (yyval.comp) = make_operator ("%", 2); }
     break;
 
   case 25:
 #line 456 "cp-name-parser.y"
-    { yyval.comp = make_operator ("^", 2); }
+    { (yyval.comp) = make_operator ("^", 2); }
     break;
 
   case 26:
 #line 458 "cp-name-parser.y"
-    { yyval.comp = make_operator ("&", 2); }
+    { (yyval.comp) = make_operator ("&", 2); }
     break;
 
   case 27:
 #line 460 "cp-name-parser.y"
-    { yyval.comp = make_operator ("|", 2); }
+    { (yyval.comp) = make_operator ("|", 2); }
     break;
 
   case 28:
 #line 462 "cp-name-parser.y"
-    { yyval.comp = make_operator ("~", 1); }
+    { (yyval.comp) = make_operator ("~", 1); }
     break;
 
   case 29:
 #line 464 "cp-name-parser.y"
-    { yyval.comp = make_operator ("!", 1); }
+    { (yyval.comp) = make_operator ("!", 1); }
     break;
 
   case 30:
 #line 466 "cp-name-parser.y"
-    { yyval.comp = make_operator ("=", 2); }
+    { (yyval.comp) = make_operator ("=", 2); }
     break;
 
   case 31:
 #line 468 "cp-name-parser.y"
-    { yyval.comp = make_operator ("<", 2); }
+    { (yyval.comp) = make_operator ("<", 2); }
     break;
 
   case 32:
 #line 470 "cp-name-parser.y"
-    { yyval.comp = make_operator (">", 2); }
+    { (yyval.comp) = make_operator (">", 2); }
     break;
 
   case 33:
 #line 472 "cp-name-parser.y"
-    { yyval.comp = make_operator (yyvsp[0].opname, 2); }
+    { (yyval.comp) = make_operator ((yyvsp[(2) - (2)].opname), 2); }
     break;
 
   case 34:
 #line 474 "cp-name-parser.y"
-    { yyval.comp = make_operator ("<<", 2); }
+    { (yyval.comp) = make_operator ("<<", 2); }
     break;
 
   case 35:
 #line 476 "cp-name-parser.y"
-    { yyval.comp = make_operator (">>", 2); }
+    { (yyval.comp) = make_operator (">>", 2); }
     break;
 
   case 36:
 #line 478 "cp-name-parser.y"
-    { yyval.comp = make_operator ("==", 2); }
+    { (yyval.comp) = make_operator ("==", 2); }
     break;
 
   case 37:
 #line 480 "cp-name-parser.y"
-    { yyval.comp = make_operator ("!=", 2); }
+    { (yyval.comp) = make_operator ("!=", 2); }
     break;
 
   case 38:
 #line 482 "cp-name-parser.y"
-    { yyval.comp = make_operator ("<=", 2); }
+    { (yyval.comp) = make_operator ("<=", 2); }
     break;
 
   case 39:
 #line 484 "cp-name-parser.y"
-    { yyval.comp = make_operator (">=", 2); }
+    { (yyval.comp) = make_operator (">=", 2); }
     break;
 
   case 40:
 #line 486 "cp-name-parser.y"
-    { yyval.comp = make_operator ("&&", 2); }
+    { (yyval.comp) = make_operator ("&&", 2); }
     break;
 
   case 41:
 #line 488 "cp-name-parser.y"
-    { yyval.comp = make_operator ("||", 2); }
+    { (yyval.comp) = make_operator ("||", 2); }
     break;
 
   case 42:
 #line 490 "cp-name-parser.y"
-    { yyval.comp = make_operator ("++", 1); }
+    { (yyval.comp) = make_operator ("++", 1); }
     break;
 
   case 43:
 #line 492 "cp-name-parser.y"
-    { yyval.comp = make_operator ("--", 1); }
+    { (yyval.comp) = make_operator ("--", 1); }
     break;
 
   case 44:
 #line 494 "cp-name-parser.y"
-    { yyval.comp = make_operator (",", 2); }
+    { (yyval.comp) = make_operator (",", 2); }
     break;
 
   case 45:
 #line 496 "cp-name-parser.y"
-    { yyval.comp = make_operator ("->*", 2); }
+    { (yyval.comp) = make_operator ("->*", 2); }
     break;
 
   case 46:
 #line 498 "cp-name-parser.y"
-    { yyval.comp = make_operator ("->", 2); }
+    { (yyval.comp) = make_operator ("->", 2); }
     break;
 
   case 47:
 #line 500 "cp-name-parser.y"
-    { yyval.comp = make_operator ("()", 0); }
+    { (yyval.comp) = make_operator ("()", 0); }
     break;
 
   case 48:
 #line 502 "cp-name-parser.y"
-    { yyval.comp = make_operator ("[]", 2); }
+    { (yyval.comp) = make_operator ("[]", 2); }
     break;
 
   case 49:
 #line 510 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_CAST, yyvsp[0].comp, NULL); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_CAST, (yyvsp[(2) - (2)].comp), NULL); }
     break;
 
   case 50:
 #line 515 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested1.comp;
-			  d_right (yyvsp[-1].nested1.last) = yyvsp[0].comp;
-			  yyval.nested.last = &d_left (yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(1) - (2)].nested1).comp;
+			  d_right ((yyvsp[(1) - (2)].nested1).last) = (yyvsp[(2) - (2)].comp);
+			  (yyval.nested).last = &d_left ((yyvsp[(2) - (2)].comp));
 			}
     break;
 
   case 51:
 #line 520 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[0].comp;
-			  yyval.nested.last = &d_left (yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(1) - (1)].comp);
+			  (yyval.nested).last = &d_left ((yyvsp[(1) - (1)].comp));
 			}
     break;
 
   case 52:
 #line 524 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested1.comp;
-			  d_right (yyvsp[-1].nested1.last) = yyvsp[0].comp;
-			  yyval.nested.last = &d_left (yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(2) - (3)].nested1).comp;
+			  d_right ((yyvsp[(2) - (3)].nested1).last) = (yyvsp[(3) - (3)].comp);
+			  (yyval.nested).last = &d_left ((yyvsp[(3) - (3)].comp));
 			}
     break;
 
   case 53:
 #line 529 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[0].comp;
-			  yyval.nested.last = &d_left (yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(2) - (2)].comp);
+			  (yyval.nested).last = &d_left ((yyvsp[(2) - (2)].comp));
 			}
     break;
 
   case 55:
 #line 538 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_TEMPLATE, yyvsp[-3].comp, yyvsp[-1].nested.comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_TEMPLATE, (yyvsp[(1) - (4)].comp), (yyvsp[(3) - (4)].nested).comp); }
     break;
 
   case 56:
 #line 540 "cp-name-parser.y"
-    { yyval.comp = make_dtor (gnu_v3_complete_object_dtor, yyvsp[0].comp); }
+    { (yyval.comp) = make_dtor (gnu_v3_complete_object_dtor, (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 58:
 #line 553 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 59:
 #line 559 "cp-name-parser.y"
-    { yyval.comp = yyvsp[-1].nested1.comp; d_right (yyvsp[-1].nested1.last) = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(1) - (2)].nested1).comp; d_right ((yyvsp[(1) - (2)].nested1).last) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 61:
 #line 562 "cp-name-parser.y"
-    { yyval.comp = yyvsp[-1].nested1.comp; d_right (yyvsp[-1].nested1.last) = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(1) - (2)].nested1).comp; d_right ((yyvsp[(1) - (2)].nested1).last) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 66:
 #line 572 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 67:
 #line 576 "cp-name-parser.y"
-    { yyval.comp = yyvsp[-1].nested1.comp; d_right (yyvsp[-1].nested1.last) = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(1) - (2)].nested1).comp; d_right ((yyvsp[(1) - (2)].nested1).last) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 69:
 #line 581 "cp-name-parser.y"
-    { yyval.nested1.comp = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
-			  d_left (yyval.nested1.comp) = yyvsp[-1].comp;
-			  d_right (yyval.nested1.comp) = NULL;
-			  yyval.nested1.last = yyval.nested1.comp;
+    { (yyval.nested1).comp = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
+			  d_left ((yyval.nested1).comp) = (yyvsp[(1) - (2)].comp);
+			  d_right ((yyval.nested1).comp) = NULL;
+			  (yyval.nested1).last = (yyval.nested1).comp;
 			}
     break;
 
   case 70:
 #line 587 "cp-name-parser.y"
-    { yyval.nested1.comp = yyvsp[-2].nested1.comp;
-			  d_right (yyvsp[-2].nested1.last) = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
-			  yyval.nested1.last = d_right (yyvsp[-2].nested1.last);
-			  d_left (yyval.nested1.last) = yyvsp[-1].comp;
-			  d_right (yyval.nested1.last) = NULL;
+    { (yyval.nested1).comp = (yyvsp[(1) - (3)].nested1).comp;
+			  d_right ((yyvsp[(1) - (3)].nested1).last) = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
+			  (yyval.nested1).last = d_right ((yyvsp[(1) - (3)].nested1).last);
+			  d_left ((yyval.nested1).last) = (yyvsp[(2) - (3)].comp);
+			  d_right ((yyval.nested1).last) = NULL;
 			}
     break;
 
   case 71:
 #line 594 "cp-name-parser.y"
-    { yyval.nested1.comp = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
-			  d_left (yyval.nested1.comp) = yyvsp[-1].comp;
-			  d_right (yyval.nested1.comp) = NULL;
-			  yyval.nested1.last = yyval.nested1.comp;
+    { (yyval.nested1).comp = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
+			  d_left ((yyval.nested1).comp) = (yyvsp[(1) - (2)].comp);
+			  d_right ((yyval.nested1).comp) = NULL;
+			  (yyval.nested1).last = (yyval.nested1).comp;
 			}
     break;
 
   case 72:
 #line 600 "cp-name-parser.y"
-    { yyval.nested1.comp = yyvsp[-2].nested1.comp;
-			  d_right (yyvsp[-2].nested1.last) = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
-			  yyval.nested1.last = d_right (yyvsp[-2].nested1.last);
-			  d_left (yyval.nested1.last) = yyvsp[-1].comp;
-			  d_right (yyval.nested1.last) = NULL;
+    { (yyval.nested1).comp = (yyvsp[(1) - (3)].nested1).comp;
+			  d_right ((yyvsp[(1) - (3)].nested1).last) = make_empty (DEMANGLE_COMPONENT_QUAL_NAME);
+			  (yyval.nested1).last = d_right ((yyvsp[(1) - (3)].nested1).last);
+			  d_left ((yyval.nested1).last) = (yyvsp[(2) - (3)].comp);
+			  d_right ((yyval.nested1).last) = NULL;
 			}
     break;
 
   case 73:
 #line 611 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_TEMPLATE, yyvsp[-3].comp, yyvsp[-1].nested.comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_TEMPLATE, (yyvsp[(1) - (4)].comp), (yyvsp[(3) - (4)].nested).comp); }
     break;
 
   case 74:
 #line 615 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, yyvsp[0].comp, NULL);
-			yyval.nested.last = &d_right (yyval.nested.comp); }
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, (yyvsp[(1) - (1)].comp), NULL);
+			(yyval.nested).last = &d_right ((yyval.nested).comp); }
     break;
 
   case 75:
 #line 618 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-2].nested.comp;
-			  *yyvsp[-2].nested.last = fill_comp (DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, yyvsp[0].comp, NULL);
-			  yyval.nested.last = &d_right (*yyvsp[-2].nested.last);
+    { (yyval.nested).comp = (yyvsp[(1) - (3)].nested).comp;
+			  *(yyvsp[(1) - (3)].nested).last = fill_comp (DEMANGLE_COMPONENT_TEMPLATE_ARGLIST, (yyvsp[(3) - (3)].comp), NULL);
+			  (yyval.nested).last = &d_right (*(yyvsp[(1) - (3)].nested).last);
 			}
     break;
 
   case 77:
 #line 630 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].abstract.comp;
-			  *yyvsp[0].abstract.last = yyvsp[-1].comp;
+    { (yyval.comp) = (yyvsp[(2) - (2)].abstract).comp;
+			  *(yyvsp[(2) - (2)].abstract).last = (yyvsp[(1) - (2)].comp);
 			}
     break;
 
   case 78:
 #line 634 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), yyvsp[0].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 79:
 #line 636 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), yyvsp[-1].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), (yyvsp[(3) - (4)].comp)); }
     break;
 
   case 81:
 #line 641 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_ARGLIST, yyvsp[0].comp, NULL);
-			  yyval.nested.last = &d_right (yyval.nested.comp);
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_ARGLIST, (yyvsp[(1) - (1)].comp), NULL);
+			  (yyval.nested).last = &d_right ((yyval.nested).comp);
 			}
     break;
 
   case 82:
 #line 645 "cp-name-parser.y"
-    { *yyvsp[0].abstract.last = yyvsp[-1].comp;
-			  yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_ARGLIST, yyvsp[0].abstract.comp, NULL);
-			  yyval.nested.last = &d_right (yyval.nested.comp);
+    { *(yyvsp[(2) - (2)].abstract).last = (yyvsp[(1) - (2)].comp);
+			  (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_ARGLIST, (yyvsp[(2) - (2)].abstract).comp, NULL);
+			  (yyval.nested).last = &d_right ((yyval.nested).comp);
 			}
     break;
 
   case 83:
 #line 650 "cp-name-parser.y"
-    { *yyvsp[-2].nested.last = fill_comp (DEMANGLE_COMPONENT_ARGLIST, yyvsp[0].comp, NULL);
-			  yyval.nested.comp = yyvsp[-2].nested.comp;
-			  yyval.nested.last = &d_right (*yyvsp[-2].nested.last);
+    { *(yyvsp[(1) - (3)].nested).last = fill_comp (DEMANGLE_COMPONENT_ARGLIST, (yyvsp[(3) - (3)].comp), NULL);
+			  (yyval.nested).comp = (yyvsp[(1) - (3)].nested).comp;
+			  (yyval.nested).last = &d_right (*(yyvsp[(1) - (3)].nested).last);
 			}
     break;
 
   case 84:
 #line 655 "cp-name-parser.y"
-    { *yyvsp[0].abstract.last = yyvsp[-1].comp;
-			  *yyvsp[-3].nested.last = fill_comp (DEMANGLE_COMPONENT_ARGLIST, yyvsp[0].abstract.comp, NULL);
-			  yyval.nested.comp = yyvsp[-3].nested.comp;
-			  yyval.nested.last = &d_right (*yyvsp[-3].nested.last);
+    { *(yyvsp[(4) - (4)].abstract).last = (yyvsp[(3) - (4)].comp);
+			  *(yyvsp[(1) - (4)].nested).last = fill_comp (DEMANGLE_COMPONENT_ARGLIST, (yyvsp[(4) - (4)].abstract).comp, NULL);
+			  (yyval.nested).comp = (yyvsp[(1) - (4)].nested).comp;
+			  (yyval.nested).last = &d_right (*(yyvsp[(1) - (4)].nested).last);
 			}
     break;
 
   case 85:
 #line 661 "cp-name-parser.y"
-    { *yyvsp[-2].nested.last
+    { *(yyvsp[(1) - (3)].nested).last
 			    = fill_comp (DEMANGLE_COMPONENT_ARGLIST,
 					   make_builtin_type ("..."),
 					   NULL);
-			  yyval.nested.comp = yyvsp[-2].nested.comp;
-			  yyval.nested.last = &d_right (*yyvsp[-2].nested.last);
+			  (yyval.nested).comp = (yyvsp[(1) - (3)].nested).comp;
+			  (yyval.nested).last = &d_right (*(yyvsp[(1) - (3)].nested).last);
 			}
     break;
 
   case 86:
 #line 671 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, yyvsp[-2].nested.comp);
-			  yyval.nested.last = &d_left (yyval.nested.comp);
-			  yyval.nested.comp = d_qualify (yyval.nested.comp, yyvsp[0].lval, 1); }
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, (yyvsp[(2) - (4)].nested).comp);
+			  (yyval.nested).last = &d_left ((yyval.nested).comp);
+			  (yyval.nested).comp = d_qualify ((yyval.nested).comp, (yyvsp[(4) - (4)].lval), 1); }
     break;
 
   case 87:
 #line 675 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, NULL);
-			  yyval.nested.last = &d_left (yyval.nested.comp);
-			  yyval.nested.comp = d_qualify (yyval.nested.comp, yyvsp[0].lval, 1); }
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, NULL);
+			  (yyval.nested).last = &d_left ((yyval.nested).comp);
+			  (yyval.nested).comp = d_qualify ((yyval.nested).comp, (yyvsp[(4) - (4)].lval), 1); }
     break;
 
   case 88:
 #line 679 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, NULL);
-			  yyval.nested.last = &d_left (yyval.nested.comp);
-			  yyval.nested.comp = d_qualify (yyval.nested.comp, yyvsp[0].lval, 1); }
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_FUNCTION_TYPE, NULL, NULL);
+			  (yyval.nested).last = &d_left ((yyval.nested).comp);
+			  (yyval.nested).comp = d_qualify ((yyval.nested).comp, (yyvsp[(3) - (3)].lval), 1); }
     break;
 
   case 89:
 #line 686 "cp-name-parser.y"
-    { yyval.lval = 0; }
+    { (yyval.lval) = 0; }
     break;
 
   case 91:
 #line 691 "cp-name-parser.y"
-    { yyval.lval = QUAL_RESTRICT; }
+    { (yyval.lval) = QUAL_RESTRICT; }
     break;
 
   case 92:
 #line 693 "cp-name-parser.y"
-    { yyval.lval = QUAL_VOLATILE; }
+    { (yyval.lval) = QUAL_VOLATILE; }
     break;
 
   case 93:
 #line 695 "cp-name-parser.y"
-    { yyval.lval = QUAL_CONST; }
+    { (yyval.lval) = QUAL_CONST; }
     break;
 
   case 95:
 #line 700 "cp-name-parser.y"
-    { yyval.lval = yyvsp[-1].lval | yyvsp[0].lval; }
+    { (yyval.lval) = (yyvsp[(1) - (2)].lval) | (yyvsp[(2) - (2)].lval); }
     break;
 
   case 96:
 #line 707 "cp-name-parser.y"
-    { yyval.lval = 0; }
+    { (yyval.lval) = 0; }
     break;
 
   case 97:
 #line 709 "cp-name-parser.y"
-    { yyval.lval = INT_SIGNED; }
+    { (yyval.lval) = INT_SIGNED; }
     break;
 
   case 98:
 #line 711 "cp-name-parser.y"
-    { yyval.lval = INT_UNSIGNED; }
+    { (yyval.lval) = INT_UNSIGNED; }
     break;
 
   case 99:
 #line 713 "cp-name-parser.y"
-    { yyval.lval = INT_CHAR; }
+    { (yyval.lval) = INT_CHAR; }
     break;
 
   case 100:
 #line 715 "cp-name-parser.y"
-    { yyval.lval = INT_LONG; }
+    { (yyval.lval) = INT_LONG; }
     break;
 
   case 101:
 #line 717 "cp-name-parser.y"
-    { yyval.lval = INT_SHORT; }
+    { (yyval.lval) = INT_SHORT; }
     break;
 
   case 103:
 #line 722 "cp-name-parser.y"
-    { yyval.lval = yyvsp[-1].lval | yyvsp[0].lval; if (yyvsp[-1].lval & yyvsp[0].lval & INT_LONG) yyval.lval = yyvsp[-1].lval | INT_LLONG; }
+    { (yyval.lval) = (yyvsp[(1) - (2)].lval) | (yyvsp[(2) - (2)].lval); if ((yyvsp[(1) - (2)].lval) & (yyvsp[(2) - (2)].lval) & INT_LONG) (yyval.lval) = (yyvsp[(1) - (2)].lval) | INT_LLONG; }
     break;
 
   case 104:
 #line 726 "cp-name-parser.y"
-    { yyval.comp = d_int_type (yyvsp[0].lval); }
+    { (yyval.comp) = d_int_type ((yyvsp[(1) - (1)].lval)); }
     break;
 
   case 105:
 #line 728 "cp-name-parser.y"
-    { yyval.comp = make_builtin_type ("float"); }
+    { (yyval.comp) = make_builtin_type ("float"); }
     break;
 
   case 106:
 #line 730 "cp-name-parser.y"
-    { yyval.comp = make_builtin_type ("double"); }
+    { (yyval.comp) = make_builtin_type ("double"); }
     break;
 
   case 107:
 #line 732 "cp-name-parser.y"
-    { yyval.comp = make_builtin_type ("long double"); }
+    { (yyval.comp) = make_builtin_type ("long double"); }
     break;
 
   case 108:
 #line 734 "cp-name-parser.y"
-    { yyval.comp = make_builtin_type ("bool"); }
+    { (yyval.comp) = make_builtin_type ("bool"); }
     break;
 
   case 109:
 #line 736 "cp-name-parser.y"
-    { yyval.comp = make_builtin_type ("wchar_t"); }
+    { (yyval.comp) = make_builtin_type ("wchar_t"); }
     break;
 
   case 110:
 #line 738 "cp-name-parser.y"
-    { yyval.comp = make_builtin_type ("void"); }
+    { (yyval.comp) = make_builtin_type ("void"); }
     break;
 
   case 111:
 #line 742 "cp-name-parser.y"
-    { yyval.nested.comp = make_empty (DEMANGLE_COMPONENT_POINTER);
-			  yyval.nested.comp->u.s_binary.left = yyval.nested.comp->u.s_binary.right = NULL;
-			  yyval.nested.last = &d_left (yyval.nested.comp);
-			  yyval.nested.comp = d_qualify (yyval.nested.comp, yyvsp[0].lval, 0); }
+    { (yyval.nested).comp = make_empty (DEMANGLE_COMPONENT_POINTER);
+			  (yyval.nested).comp->u.s_binary.left = (yyval.nested).comp->u.s_binary.right = NULL;
+			  (yyval.nested).last = &d_left ((yyval.nested).comp);
+			  (yyval.nested).comp = d_qualify ((yyval.nested).comp, (yyvsp[(2) - (2)].lval), 0); }
     break;
 
   case 112:
 #line 748 "cp-name-parser.y"
-    { yyval.nested.comp = make_empty (DEMANGLE_COMPONENT_REFERENCE);
-			  yyval.nested.comp->u.s_binary.left = yyval.nested.comp->u.s_binary.right = NULL;
-			  yyval.nested.last = &d_left (yyval.nested.comp); }
+    { (yyval.nested).comp = make_empty (DEMANGLE_COMPONENT_REFERENCE);
+			  (yyval.nested).comp->u.s_binary.left = (yyval.nested).comp->u.s_binary.right = NULL;
+			  (yyval.nested).last = &d_left ((yyval.nested).comp); }
     break;
 
   case 113:
 #line 752 "cp-name-parser.y"
-    { yyval.nested.comp = make_empty (DEMANGLE_COMPONENT_PTRMEM_TYPE);
-			  yyval.nested.comp->u.s_binary.left = yyvsp[-2].nested1.comp;
+    { (yyval.nested).comp = make_empty (DEMANGLE_COMPONENT_PTRMEM_TYPE);
+			  (yyval.nested).comp->u.s_binary.left = (yyvsp[(1) - (3)].nested1).comp;
 			  /* Convert the innermost DEMANGLE_COMPONENT_QUAL_NAME to a DEMANGLE_COMPONENT_NAME.  */
-			  *yyvsp[-2].nested1.last = *d_left (yyvsp[-2].nested1.last);
-			  yyval.nested.comp->u.s_binary.right = NULL;
-			  yyval.nested.last = &d_right (yyval.nested.comp);
-			  yyval.nested.comp = d_qualify (yyval.nested.comp, yyvsp[0].lval, 0); }
+			  *(yyvsp[(1) - (3)].nested1).last = *d_left ((yyvsp[(1) - (3)].nested1).last);
+			  (yyval.nested).comp->u.s_binary.right = NULL;
+			  (yyval.nested).last = &d_right ((yyval.nested).comp);
+			  (yyval.nested).comp = d_qualify ((yyval.nested).comp, (yyvsp[(3) - (3)].lval), 0); }
     break;
 
   case 114:
 #line 760 "cp-name-parser.y"
-    { yyval.nested.comp = make_empty (DEMANGLE_COMPONENT_PTRMEM_TYPE);
-			  yyval.nested.comp->u.s_binary.left = yyvsp[-2].nested1.comp;
+    { (yyval.nested).comp = make_empty (DEMANGLE_COMPONENT_PTRMEM_TYPE);
+			  (yyval.nested).comp->u.s_binary.left = (yyvsp[(2) - (4)].nested1).comp;
 			  /* Convert the innermost DEMANGLE_COMPONENT_QUAL_NAME to a DEMANGLE_COMPONENT_NAME.  */
-			  *yyvsp[-2].nested1.last = *d_left (yyvsp[-2].nested1.last);
-			  yyval.nested.comp->u.s_binary.right = NULL;
-			  yyval.nested.last = &d_right (yyval.nested.comp);
-			  yyval.nested.comp = d_qualify (yyval.nested.comp, yyvsp[0].lval, 0); }
+			  *(yyvsp[(2) - (4)].nested1).last = *d_left ((yyvsp[(2) - (4)].nested1).last);
+			  (yyval.nested).comp->u.s_binary.right = NULL;
+			  (yyval.nested).last = &d_right ((yyval.nested).comp);
+			  (yyval.nested).comp = d_qualify ((yyval.nested).comp, (yyvsp[(4) - (4)].lval), 0); }
     break;
 
   case 115:
 #line 770 "cp-name-parser.y"
-    { yyval.comp = make_empty (DEMANGLE_COMPONENT_ARRAY_TYPE);
-			  d_left (yyval.comp) = NULL;
+    { (yyval.comp) = make_empty (DEMANGLE_COMPONENT_ARRAY_TYPE);
+			  d_left ((yyval.comp)) = NULL;
 			}
     break;
 
   case 116:
 #line 774 "cp-name-parser.y"
-    { yyval.comp = make_empty (DEMANGLE_COMPONENT_ARRAY_TYPE);
-			  d_left (yyval.comp) = yyvsp[-1].comp;
+    { (yyval.comp) = make_empty (DEMANGLE_COMPONENT_ARRAY_TYPE);
+			  d_left ((yyval.comp)) = (yyvsp[(2) - (3)].comp);
 			}
     break;
 
   case 117:
 #line 790 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[-1].comp, yyvsp[0].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(1) - (2)].comp), (yyvsp[(2) - (2)].lval), 0); }
     break;
 
   case 119:
 #line 793 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[-1].comp, yyvsp[-2].lval | yyvsp[0].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(2) - (3)].comp), (yyvsp[(1) - (3)].lval) | (yyvsp[(3) - (3)].lval), 0); }
     break;
 
   case 120:
 #line 795 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[0].comp, yyvsp[-1].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(2) - (2)].comp), (yyvsp[(1) - (2)].lval), 0); }
     break;
 
   case 121:
 #line 798 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[-1].comp, yyvsp[0].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(1) - (2)].comp), (yyvsp[(2) - (2)].lval), 0); }
     break;
 
   case 123:
 #line 801 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[-1].comp, yyvsp[-2].lval | yyvsp[0].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(2) - (3)].comp), (yyvsp[(1) - (3)].lval) | (yyvsp[(3) - (3)].lval), 0); }
     break;
 
   case 124:
 #line 803 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[0].comp, yyvsp[-1].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(2) - (2)].comp), (yyvsp[(1) - (2)].lval), 0); }
     break;
 
   case 125:
 #line 806 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[-1].comp, yyvsp[0].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(2) - (3)].comp), (yyvsp[(3) - (3)].lval), 0); }
     break;
 
   case 126:
 #line 808 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].comp; }
+    { (yyval.comp) = (yyvsp[(2) - (2)].comp); }
     break;
 
   case 127:
 #line 810 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[-1].comp, yyvsp[-3].lval | yyvsp[0].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(3) - (4)].comp), (yyvsp[(1) - (4)].lval) | (yyvsp[(4) - (4)].lval), 0); }
     break;
 
   case 128:
 #line 812 "cp-name-parser.y"
-    { yyval.comp = d_qualify (yyvsp[0].comp, yyvsp[-2].lval, 0); }
+    { (yyval.comp) = d_qualify ((yyvsp[(3) - (3)].comp), (yyvsp[(1) - (3)].lval), 0); }
     break;
 
   case 129:
 #line 817 "cp-name-parser.y"
-    { yyval.abstract.comp = yyvsp[0].nested.comp; yyval.abstract.last = yyvsp[0].nested.last;
-			  yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL; }
+    { (yyval.abstract).comp = (yyvsp[(1) - (1)].nested).comp; (yyval.abstract).last = (yyvsp[(1) - (1)].nested).last;
+			  (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL; }
     break;
 
   case 130:
 #line 820 "cp-name-parser.y"
-    { yyval.abstract = yyvsp[0].abstract; yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL;
-			  if (yyvsp[0].abstract.fn.comp) { yyval.abstract.last = yyvsp[0].abstract.fn.last; *yyvsp[0].abstract.last = yyvsp[0].abstract.fn.comp; }
-			  *yyval.abstract.last = yyvsp[-1].nested.comp;
-			  yyval.abstract.last = yyvsp[-1].nested.last; }
+    { (yyval.abstract) = (yyvsp[(2) - (2)].abstract); (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL;
+			  if ((yyvsp[(2) - (2)].abstract).fn.comp) { (yyval.abstract).last = (yyvsp[(2) - (2)].abstract).fn.last; *(yyvsp[(2) - (2)].abstract).last = (yyvsp[(2) - (2)].abstract).fn.comp; }
+			  *(yyval.abstract).last = (yyvsp[(1) - (2)].nested).comp;
+			  (yyval.abstract).last = (yyvsp[(1) - (2)].nested).last; }
     break;
 
   case 131:
 #line 825 "cp-name-parser.y"
-    { yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL;
-			  if (yyvsp[0].abstract.fn.comp) { yyval.abstract.last = yyvsp[0].abstract.fn.last; *yyvsp[0].abstract.last = yyvsp[0].abstract.fn.comp; }
+    { (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL;
+			  if ((yyvsp[(1) - (1)].abstract).fn.comp) { (yyval.abstract).last = (yyvsp[(1) - (1)].abstract).fn.last; *(yyvsp[(1) - (1)].abstract).last = (yyvsp[(1) - (1)].abstract).fn.comp; }
 			}
     break;
 
   case 132:
 #line 832 "cp-name-parser.y"
-    { yyval.abstract = yyvsp[-1].abstract; yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL; yyval.abstract.fold_flag = 1;
-			  if (yyvsp[-1].abstract.fn.comp) { yyval.abstract.last = yyvsp[-1].abstract.fn.last; *yyvsp[-1].abstract.last = yyvsp[-1].abstract.fn.comp; }
+    { (yyval.abstract) = (yyvsp[(2) - (3)].abstract); (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL; (yyval.abstract).fold_flag = 1;
+			  if ((yyvsp[(2) - (3)].abstract).fn.comp) { (yyval.abstract).last = (yyvsp[(2) - (3)].abstract).fn.last; *(yyvsp[(2) - (3)].abstract).last = (yyvsp[(2) - (3)].abstract).fn.comp; }
 			}
     break;
 
   case 133:
 #line 836 "cp-name-parser.y"
-    { yyval.abstract.fold_flag = 0;
-			  if (yyvsp[-1].abstract.fn.comp) { yyval.abstract.last = yyvsp[-1].abstract.fn.last; *yyvsp[-1].abstract.last = yyvsp[-1].abstract.fn.comp; }
-			  if (yyvsp[-1].abstract.fold_flag)
+    { (yyval.abstract).fold_flag = 0;
+			  if ((yyvsp[(1) - (2)].abstract).fn.comp) { (yyval.abstract).last = (yyvsp[(1) - (2)].abstract).fn.last; *(yyvsp[(1) - (2)].abstract).last = (yyvsp[(1) - (2)].abstract).fn.comp; }
+			  if ((yyvsp[(1) - (2)].abstract).fold_flag)
 			    {
-			      *yyval.abstract.last = yyvsp[0].nested.comp;
-			      yyval.abstract.last = yyvsp[0].nested.last;
+			      *(yyval.abstract).last = (yyvsp[(2) - (2)].nested).comp;
+			      (yyval.abstract).last = (yyvsp[(2) - (2)].nested).last;
 			    }
 			  else
-			    yyval.abstract.fn = yyvsp[0].nested;
+			    (yyval.abstract).fn = (yyvsp[(2) - (2)].nested);
 			}
     break;
 
   case 134:
 #line 847 "cp-name-parser.y"
-    { yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL; yyval.abstract.fold_flag = 0;
-			  if (yyvsp[-1].abstract.fn.comp) { yyval.abstract.last = yyvsp[-1].abstract.fn.last; *yyvsp[-1].abstract.last = yyvsp[-1].abstract.fn.comp; }
-			  *yyvsp[-1].abstract.last = yyvsp[0].comp;
-			  yyval.abstract.last = &d_right (yyvsp[0].comp);
+    { (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL; (yyval.abstract).fold_flag = 0;
+			  if ((yyvsp[(1) - (2)].abstract).fn.comp) { (yyval.abstract).last = (yyvsp[(1) - (2)].abstract).fn.last; *(yyvsp[(1) - (2)].abstract).last = (yyvsp[(1) - (2)].abstract).fn.comp; }
+			  *(yyvsp[(1) - (2)].abstract).last = (yyvsp[(2) - (2)].comp);
+			  (yyval.abstract).last = &d_right ((yyvsp[(2) - (2)].comp));
 			}
     break;
 
   case 135:
 #line 853 "cp-name-parser.y"
-    { yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL; yyval.abstract.fold_flag = 0;
-			  yyval.abstract.comp = yyvsp[0].comp;
-			  yyval.abstract.last = &d_right (yyvsp[0].comp);
+    { (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL; (yyval.abstract).fold_flag = 0;
+			  (yyval.abstract).comp = (yyvsp[(1) - (1)].comp);
+			  (yyval.abstract).last = &d_right ((yyvsp[(1) - (1)].comp));
 			}
     break;
 
   case 136:
 #line 871 "cp-name-parser.y"
-    { yyval.abstract.comp = yyvsp[0].nested.comp; yyval.abstract.last = yyvsp[0].nested.last;
-			  yyval.abstract.fn.comp = NULL; yyval.abstract.fn.last = NULL; yyval.abstract.start = NULL; }
+    { (yyval.abstract).comp = (yyvsp[(1) - (1)].nested).comp; (yyval.abstract).last = (yyvsp[(1) - (1)].nested).last;
+			  (yyval.abstract).fn.comp = NULL; (yyval.abstract).fn.last = NULL; (yyval.abstract).start = NULL; }
     break;
 
   case 137:
 #line 874 "cp-name-parser.y"
-    { yyval.abstract = yyvsp[0].abstract;
-			  if (yyvsp[0].abstract.last)
-			    *yyval.abstract.last = yyvsp[-1].nested.comp;
+    { (yyval.abstract) = (yyvsp[(2) - (2)].abstract);
+			  if ((yyvsp[(2) - (2)].abstract).last)
+			    *(yyval.abstract).last = (yyvsp[(1) - (2)].nested).comp;
 			  else
-			    yyval.abstract.comp = yyvsp[-1].nested.comp;
-			  yyval.abstract.last = yyvsp[-1].nested.last;
+			    (yyval.abstract).comp = (yyvsp[(1) - (2)].nested).comp;
+			  (yyval.abstract).last = (yyvsp[(1) - (2)].nested).last;
 			}
     break;
 
   case 138:
 #line 882 "cp-name-parser.y"
-    { yyval.abstract.comp = yyvsp[0].abstract.comp; yyval.abstract.last = yyvsp[0].abstract.last; yyval.abstract.fn = yyvsp[0].abstract.fn; yyval.abstract.start = NULL; }
+    { (yyval.abstract).comp = (yyvsp[(1) - (1)].abstract).comp; (yyval.abstract).last = (yyvsp[(1) - (1)].abstract).last; (yyval.abstract).fn = (yyvsp[(1) - (1)].abstract).fn; (yyval.abstract).start = NULL; }
     break;
 
   case 139:
 #line 884 "cp-name-parser.y"
-    { yyval.abstract.start = yyvsp[0].comp;
-			  if (yyvsp[-3].abstract.fn.comp) { yyval.abstract.last = yyvsp[-3].abstract.fn.last; *yyvsp[-3].abstract.last = yyvsp[-3].abstract.fn.comp; }
-			  if (yyvsp[-3].abstract.fold_flag)
+    { (yyval.abstract).start = (yyvsp[(4) - (4)].comp);
+			  if ((yyvsp[(1) - (4)].abstract).fn.comp) { (yyval.abstract).last = (yyvsp[(1) - (4)].abstract).fn.last; *(yyvsp[(1) - (4)].abstract).last = (yyvsp[(1) - (4)].abstract).fn.comp; }
+			  if ((yyvsp[(1) - (4)].abstract).fold_flag)
 			    {
-			      *yyval.abstract.last = yyvsp[-2].nested.comp;
-			      yyval.abstract.last = yyvsp[-2].nested.last;
+			      *(yyval.abstract).last = (yyvsp[(2) - (4)].nested).comp;
+			      (yyval.abstract).last = (yyvsp[(2) - (4)].nested).last;
 			    }
 			  else
-			    yyval.abstract.fn = yyvsp[-2].nested;
+			    (yyval.abstract).fn = (yyvsp[(2) - (4)].nested);
 			}
     break;
 
   case 140:
 #line 895 "cp-name-parser.y"
-    { yyval.abstract.fn = yyvsp[-1].nested;
-			  yyval.abstract.start = yyvsp[0].comp;
-			  yyval.abstract.comp = NULL; yyval.abstract.last = NULL;
+    { (yyval.abstract).fn = (yyvsp[(1) - (2)].nested);
+			  (yyval.abstract).start = (yyvsp[(2) - (2)].comp);
+			  (yyval.abstract).comp = NULL; (yyval.abstract).last = NULL;
 			}
     break;
 
   case 142:
 #line 903 "cp-name-parser.y"
-    { yyval.comp = yyvsp[0].abstract.comp;
-			  *yyvsp[0].abstract.last = yyvsp[-1].comp;
+    { (yyval.comp) = (yyvsp[(2) - (2)].abstract).comp;
+			  *(yyvsp[(2) - (2)].abstract).last = (yyvsp[(1) - (2)].comp);
 			}
     break;
 
   case 143:
 #line 909 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[0].nested.comp;
-			  yyval.nested.last = yyvsp[-1].nested.last;
-			  *yyvsp[0].nested.last = yyvsp[-1].nested.comp; }
+    { (yyval.nested).comp = (yyvsp[(2) - (2)].nested).comp;
+			  (yyval.nested).last = (yyvsp[(1) - (2)].nested).last;
+			  *(yyvsp[(2) - (2)].nested).last = (yyvsp[(1) - (2)].nested).comp; }
     break;
 
   case 145:
 #line 917 "cp-name-parser.y"
-    { yyval.nested = yyvsp[-1].nested; }
+    { (yyval.nested) = (yyvsp[(2) - (3)].nested); }
     break;
 
   case 146:
 #line 919 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested.comp;
-			  *yyvsp[-1].nested.last = yyvsp[0].nested.comp;
-			  yyval.nested.last = yyvsp[0].nested.last;
+    { (yyval.nested).comp = (yyvsp[(1) - (2)].nested).comp;
+			  *(yyvsp[(1) - (2)].nested).last = (yyvsp[(2) - (2)].nested).comp;
+			  (yyval.nested).last = (yyvsp[(2) - (2)].nested).last;
 			}
     break;
 
   case 147:
 #line 924 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested.comp;
-			  *yyvsp[-1].nested.last = yyvsp[0].comp;
-			  yyval.nested.last = &d_right (yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(1) - (2)].nested).comp;
+			  *(yyvsp[(1) - (2)].nested).last = (yyvsp[(2) - (2)].comp);
+			  (yyval.nested).last = &d_right ((yyvsp[(2) - (2)].comp));
 			}
     break;
 
   case 148:
 #line 929 "cp-name-parser.y"
-    { yyval.nested.comp = make_empty (DEMANGLE_COMPONENT_TYPED_NAME);
-			  d_left (yyval.nested.comp) = yyvsp[0].comp;
-			  yyval.nested.last = &d_right (yyval.nested.comp);
+    { (yyval.nested).comp = make_empty (DEMANGLE_COMPONENT_TYPED_NAME);
+			  d_left ((yyval.nested).comp) = (yyvsp[(1) - (1)].comp);
+			  (yyval.nested).last = &d_right ((yyval.nested).comp);
 			}
     break;
 
   case 149:
 #line 942 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[0].nested.comp;
-			  yyval.nested.last = yyvsp[-1].nested.last;
-			  *yyvsp[0].nested.last = yyvsp[-1].nested.comp; }
+    { (yyval.nested).comp = (yyvsp[(2) - (2)].nested).comp;
+			  (yyval.nested).last = (yyvsp[(1) - (2)].nested).last;
+			  *(yyvsp[(2) - (2)].nested).last = (yyvsp[(1) - (2)].nested).comp; }
     break;
 
   case 150:
 #line 946 "cp-name-parser.y"
-    { yyval.nested.comp = make_empty (DEMANGLE_COMPONENT_TYPED_NAME);
-			  d_left (yyval.nested.comp) = yyvsp[0].comp;
-			  yyval.nested.last = &d_right (yyval.nested.comp);
+    { (yyval.nested).comp = make_empty (DEMANGLE_COMPONENT_TYPED_NAME);
+			  d_left ((yyval.nested).comp) = (yyvsp[(1) - (1)].comp);
+			  (yyval.nested).last = &d_right ((yyval.nested).comp);
 			}
     break;
 
   case 152:
 #line 959 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, yyvsp[-3].comp, yyvsp[-2].nested.comp);
-			  yyval.nested.last = yyvsp[-2].nested.last;
-			  yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, yyval.nested.comp, yyvsp[0].comp);
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, (yyvsp[(1) - (4)].comp), (yyvsp[(2) - (4)].nested).comp);
+			  (yyval.nested).last = (yyvsp[(2) - (4)].nested).last;
+			  (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, (yyval.nested).comp, (yyvsp[(4) - (4)].comp));
 			}
     break;
 
   case 153:
 #line 964 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-3].nested.comp;
-			  *yyvsp[-3].nested.last = yyvsp[-2].nested.comp;
-			  yyval.nested.last = yyvsp[-2].nested.last;
-			  yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, yyval.nested.comp, yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(1) - (4)].nested).comp;
+			  *(yyvsp[(1) - (4)].nested).last = (yyvsp[(2) - (4)].nested).comp;
+			  (yyval.nested).last = (yyvsp[(2) - (4)].nested).last;
+			  (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_LOCAL_NAME, (yyval.nested).comp, (yyvsp[(4) - (4)].comp));
 			}
     break;
 
   case 154:
 #line 973 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested.comp;
-			  yyval.nested.last = yyvsp[-2].nested.last;
-			  *yyvsp[-1].nested.last = yyvsp[-2].nested.comp; }
+    { (yyval.nested).comp = (yyvsp[(3) - (4)].nested).comp;
+			  (yyval.nested).last = (yyvsp[(2) - (4)].nested).last;
+			  *(yyvsp[(3) - (4)].nested).last = (yyvsp[(2) - (4)].nested).comp; }
     break;
 
   case 155:
 #line 977 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested.comp;
-			  *yyvsp[-1].nested.last = yyvsp[0].nested.comp;
-			  yyval.nested.last = yyvsp[0].nested.last;
+    { (yyval.nested).comp = (yyvsp[(1) - (2)].nested).comp;
+			  *(yyvsp[(1) - (2)].nested).last = (yyvsp[(2) - (2)].nested).comp;
+			  (yyval.nested).last = (yyvsp[(2) - (2)].nested).last;
 			}
     break;
 
   case 156:
 #line 982 "cp-name-parser.y"
-    { yyval.nested.comp = yyvsp[-1].nested.comp;
-			  *yyvsp[-1].nested.last = yyvsp[0].comp;
-			  yyval.nested.last = &d_right (yyvsp[0].comp);
+    { (yyval.nested).comp = (yyvsp[(1) - (2)].nested).comp;
+			  *(yyvsp[(1) - (2)].nested).last = (yyvsp[(2) - (2)].comp);
+			  (yyval.nested).last = &d_right ((yyvsp[(2) - (2)].comp));
 			}
     break;
 
   case 157:
 #line 987 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, yyvsp[-1].comp, yyvsp[0].nested.comp);
-			  yyval.nested.last = yyvsp[0].nested.last;
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, (yyvsp[(1) - (2)].comp), (yyvsp[(2) - (2)].nested).comp);
+			  (yyval.nested).last = (yyvsp[(2) - (2)].nested).last;
 			}
     break;
 
   case 158:
 #line 991 "cp-name-parser.y"
-    { yyval.nested.comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, yyvsp[-1].comp, yyvsp[0].comp);
-			  yyval.nested.last = &d_right (yyvsp[0].comp);
+    { (yyval.nested).comp = fill_comp (DEMANGLE_COMPONENT_TYPED_NAME, (yyvsp[(1) - (2)].comp), (yyvsp[(2) - (2)].comp));
+			  (yyval.nested).last = &d_right ((yyvsp[(2) - (2)].comp));
 			}
     break;
 
   case 159:
 #line 997 "cp-name-parser.y"
-    { yyval.comp = yyvsp[-1].comp; }
+    { (yyval.comp) = (yyvsp[(2) - (3)].comp); }
     break;
 
   case 161:
 #line 1006 "cp-name-parser.y"
-    { yyval.comp = d_binary (">", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary (">", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 162:
 #line 1013 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), yyvsp[0].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 163:
 #line 1015 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), yyvsp[-1].comp); }
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY, make_operator ("&", 1), (yyvsp[(3) - (4)].comp)); }
     break;
 
   case 164:
 #line 1020 "cp-name-parser.y"
-    { yyval.comp = d_unary ("-", yyvsp[0].comp); }
+    { (yyval.comp) = d_unary ("-", (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 165:
 #line 1024 "cp-name-parser.y"
-    { yyval.comp = d_unary ("!", yyvsp[0].comp); }
+    { (yyval.comp) = d_unary ("!", (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 166:
 #line 1028 "cp-name-parser.y"
-    { yyval.comp = d_unary ("~", yyvsp[0].comp); }
+    { (yyval.comp) = d_unary ("~", (yyvsp[(2) - (2)].comp)); }
     break;
 
   case 167:
 #line 1035 "cp-name-parser.y"
-    { if (yyvsp[0].comp->type == DEMANGLE_COMPONENT_LITERAL
-		      || yyvsp[0].comp->type == DEMANGLE_COMPONENT_LITERAL_NEG)
+    { if ((yyvsp[(4) - (4)].comp)->type == DEMANGLE_COMPONENT_LITERAL
+		      || (yyvsp[(4) - (4)].comp)->type == DEMANGLE_COMPONENT_LITERAL_NEG)
 		    {
-		      yyval.comp = yyvsp[0].comp;
-		      d_left (yyvsp[0].comp) = yyvsp[-2].comp;
+		      (yyval.comp) = (yyvsp[(4) - (4)].comp);
+		      d_left ((yyvsp[(4) - (4)].comp)) = (yyvsp[(2) - (4)].comp);
 		    }
 		  else
-		    yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY,
-				      fill_comp (DEMANGLE_COMPONENT_CAST, yyvsp[-2].comp, NULL),
-				      yyvsp[0].comp);
+		    (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY,
+				      fill_comp (DEMANGLE_COMPONENT_CAST, (yyvsp[(2) - (4)].comp), NULL),
+				      (yyvsp[(4) - (4)].comp));
 		}
     break;
 
   case 168:
 #line 1051 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY,
-				    fill_comp (DEMANGLE_COMPONENT_CAST, yyvsp[-4].comp, NULL),
-				    yyvsp[-1].comp);
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY,
+				    fill_comp (DEMANGLE_COMPONENT_CAST, (yyvsp[(3) - (7)].comp), NULL),
+				    (yyvsp[(6) - (7)].comp));
 		}
     break;
 
   case 169:
 #line 1058 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY,
-				    fill_comp (DEMANGLE_COMPONENT_CAST, yyvsp[-4].comp, NULL),
-				    yyvsp[-1].comp);
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY,
+				    fill_comp (DEMANGLE_COMPONENT_CAST, (yyvsp[(3) - (7)].comp), NULL),
+				    (yyvsp[(6) - (7)].comp));
 		}
     break;
 
   case 170:
 #line 1065 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_UNARY,
-				    fill_comp (DEMANGLE_COMPONENT_CAST, yyvsp[-4].comp, NULL),
-				    yyvsp[-1].comp);
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_UNARY,
+				    fill_comp (DEMANGLE_COMPONENT_CAST, (yyvsp[(3) - (7)].comp), NULL),
+				    (yyvsp[(6) - (7)].comp));
 		}
     break;
 
   case 171:
 #line 1084 "cp-name-parser.y"
-    { yyval.comp = d_binary ("*", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("*", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 172:
 #line 1088 "cp-name-parser.y"
-    { yyval.comp = d_binary ("/", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("/", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 173:
 #line 1092 "cp-name-parser.y"
-    { yyval.comp = d_binary ("%", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("%", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 174:
 #line 1096 "cp-name-parser.y"
-    { yyval.comp = d_binary ("+", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("+", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 175:
 #line 1100 "cp-name-parser.y"
-    { yyval.comp = d_binary ("-", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("-", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 176:
 #line 1104 "cp-name-parser.y"
-    { yyval.comp = d_binary ("<<", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("<<", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 177:
 #line 1108 "cp-name-parser.y"
-    { yyval.comp = d_binary (">>", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary (">>", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 178:
 #line 1112 "cp-name-parser.y"
-    { yyval.comp = d_binary ("==", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("==", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 179:
 #line 1116 "cp-name-parser.y"
-    { yyval.comp = d_binary ("!=", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("!=", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 180:
 #line 1120 "cp-name-parser.y"
-    { yyval.comp = d_binary ("<=", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("<=", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 181:
 #line 1124 "cp-name-parser.y"
-    { yyval.comp = d_binary (">=", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary (">=", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 182:
 #line 1128 "cp-name-parser.y"
-    { yyval.comp = d_binary ("<", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("<", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 183:
 #line 1132 "cp-name-parser.y"
-    { yyval.comp = d_binary ("&", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("&", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 184:
 #line 1136 "cp-name-parser.y"
-    { yyval.comp = d_binary ("^", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("^", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 185:
 #line 1140 "cp-name-parser.y"
-    { yyval.comp = d_binary ("|", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("|", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 186:
 #line 1144 "cp-name-parser.y"
-    { yyval.comp = d_binary ("&&", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("&&", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 187:
 #line 1148 "cp-name-parser.y"
-    { yyval.comp = d_binary ("||", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("||", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 188:
 #line 1153 "cp-name-parser.y"
-    { yyval.comp = d_binary ("->", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary ("->", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 189:
 #line 1157 "cp-name-parser.y"
-    { yyval.comp = d_binary (".", yyvsp[-2].comp, yyvsp[0].comp); }
+    { (yyval.comp) = d_binary (".", (yyvsp[(1) - (3)].comp), (yyvsp[(3) - (3)].comp)); }
     break;
 
   case 190:
 #line 1161 "cp-name-parser.y"
-    { yyval.comp = fill_comp (DEMANGLE_COMPONENT_TRINARY, make_operator ("?", 3),
-				    fill_comp (DEMANGLE_COMPONENT_TRINARY_ARG1, yyvsp[-4].comp,
-						 fill_comp (DEMANGLE_COMPONENT_TRINARY_ARG2, yyvsp[-2].comp, yyvsp[0].comp)));
+    { (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_TRINARY, make_operator ("?", 3),
+				    fill_comp (DEMANGLE_COMPONENT_TRINARY_ARG1, (yyvsp[(1) - (5)].comp),
+						 fill_comp (DEMANGLE_COMPONENT_TRINARY_ARG2, (yyvsp[(3) - (5)].comp), (yyvsp[(5) - (5)].comp))));
 		}
     break;
 
   case 193:
 #line 1175 "cp-name-parser.y"
-    { yyval.comp = d_unary ("sizeof", yyvsp[-1].comp); }
+    { (yyval.comp) = d_unary ("sizeof", (yyvsp[(3) - (4)].comp)); }
     break;
 
   case 194:
 #line 1180 "cp-name-parser.y"
     { struct demangle_component *i;
 		  i = make_name ("1", 1);
-		  yyval.comp = fill_comp (DEMANGLE_COMPONENT_LITERAL,
+		  (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_LITERAL,
 				    make_builtin_type ("bool"),
 				    i);
 		}
@@ -2829,22 +3162,21 @@
 #line 1189 "cp-name-parser.y"
     { struct demangle_component *i;
 		  i = make_name ("0", 1);
-		  yyval.comp = fill_comp (DEMANGLE_COMPONENT_LITERAL,
+		  (yyval.comp) = fill_comp (DEMANGLE_COMPONENT_LITERAL,
 				    make_builtin_type ("bool"),
 				    i);
 		}
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 3175 "cp-name-parser.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 2843 "cp-name-parser.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -2873,99 +3205,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2975,15 +3273,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -3012,9 +3312,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -3022,11 +3323,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -3046,21 +3348,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -4019,4 +4339,3 @@
 
 #endif
 
-
diff -Naur gdb-6.8/gdb/defs.h stsgdb-6.8/gdb/defs.h
--- gdb-6.8/gdb/defs.h	2008-01-18 17:07:39.000000000 +0000
+++ stsgdb-6.8/gdb/defs.h	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
    This file is part of GDB.
 
@@ -1104,7 +1105,7 @@
 /* FIXME, this doesn't work very well if host and executable
    filesystems conventions are different.  */
 
-#ifdef __MSDOS__
+#if defined(__MSDOS__) || defined(__MINGW32__)
 # define CANT_FORK
 # define GLOBAL_CURDIR
 # define DIRNAME_SEPARATOR ';'
diff -Naur gdb-6.8/gdb/doc/annotate.info stsgdb-6.8/gdb/doc/annotate.info
--- gdb-6.8/gdb/doc/annotate.info	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/annotate.info	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is annotate.info, produced by makeinfo version 4.8 from
+This is annotate.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/annotate.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -1089,20 +1089,20 @@
 
 
 Tag Table:
-Node: Top763
-Node: Annotations Overview1862
-Node: Limitations3661
-Node: Migrating to GDB/MI6246
-Node: Server Prefix6629
-Node: Value Annotations7275
-Node: Frame Annotations10445
-Node: Displays14344
-Node: Prompting15375
-Node: Errors16878
-Node: Breakpoint Info17768
-Node: Invalidation18993
-Node: Annotations for Running19472
-Node: Source Annotations20985
-Node: GNU Free Documentation License21942
+Node: Top764
+Node: Annotations Overview1863
+Node: Limitations3662
+Node: Migrating to GDB/MI6247
+Node: Server Prefix6630
+Node: Value Annotations7276
+Node: Frame Annotations10446
+Node: Displays14345
+Node: Prompting15376
+Node: Errors16879
+Node: Breakpoint Info17769
+Node: Invalidation18994
+Node: Annotations for Running19473
+Node: Source Annotations20986
+Node: GNU Free Documentation License21943
 
 End Tag Table
diff -Naur gdb-6.8/gdb/doc/gdb.info stsgdb-6.8/gdb/doc/gdb.info
--- gdb-6.8/gdb/doc/gdb.info	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdb.info	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdb.info, produced by makeinfo version 4.8 from
+This is gdb.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdb.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -29,412 +29,412 @@
 
 
 Indirect:
-gdb.info-1: 1109
-gdb.info-2: 299141
-gdb.info-3: 599007
-gdb.info-4: 891206
+gdb.info-1: 1110
+gdb.info-2: 299142
+gdb.info-3: 599008
+gdb.info-4: 891199
 
 Tag Table:
 (Indirect)
-Node: Top1109
-Node: Summary3815
-Node: Free Software5451
-Node: Contributors11019
-Node: Sample Session19003
-Node: Invocation25839
-Node: Invoking GDB26383
-Node: File Options28696
-Node: Mode Options31353
-Node: Startup37765
-Ref: Startup-Footnote-139670
-Node: Quitting GDB39779
-Node: Shell Commands40676
-Node: Logging Output41518
-Node: Commands42364
-Node: Command Syntax43002
-Node: Completion45168
-Node: Help49503
-Node: Running54742
-Node: Compilation55924
-Node: Starting58563
-Node: Arguments63452
-Node: Environment64722
-Node: Working Directory67990
-Node: Input/Output69098
-Node: Attach71069
-Node: Kill Process73536
-Node: Threads74502
-Node: Processes81338
-Node: Checkpoint/Restart86557
-Ref: Checkpoint/Restart-Footnote-191090
-Node: Stopping91125
-Node: Breakpoints92272
-Node: Set Breaks95691
-Node: Set Watchpoints109829
-Node: Set Catchpoints117636
-Node: Delete Breaks121675
-Node: Disabling123611
-Node: Conditions126476
-Node: Break Commands131424
-Node: Breakpoint Menus134309
-Node: Error in Breakpoints136035
-Node: Breakpoint-related Warnings137613
-Node: Continuing and Stepping139940
-Node: Signals149252
-Node: Thread Stops153524
-Node: Stack158161
-Node: Frames159637
-Node: Backtrace162389
-Ref: Backtrace-Footnote-1167280
-Node: Selection167468
-Node: Frame Info170332
-Node: Source172663
-Node: List173729
-Node: Specify Location176342
-Node: Edit179592
-Ref: Edit-Footnote-1181067
-Node: Search181302
-Node: Source Path182110
-Ref: set substitute-path187865
-Node: Machine Code190086
-Node: Data193460
-Node: Expressions195841
-Node: Variables197809
-Node: Arrays202300
-Node: Output Formats204829
-Ref: Output Formats-Footnote-1207702
-Node: Memory207859
-Node: Auto Display213106
-Node: Print Settings216819
-Node: Value History230290
-Node: Convenience Vars232706
-Node: Registers236230
-Ref: Registers-Footnote-1240905
-Node: Floating Point Hardware241300
-Node: Vector Unit241830
-Node: OS Information242215
-Node: Memory Region Attributes244213
-Node: Dump/Restore Files248871
-Node: Core File Generation251174
-Node: Character Sets252406
-Node: Caching Remote Data259231
-Node: Macros260379
-Node: Tracepoints267330
-Node: Set Tracepoints269172
-Node: Create and Delete Tracepoints270372
-Node: Enable and Disable Tracepoints272016
-Node: Tracepoint Passcounts272715
-Node: Tracepoint Actions274139
-Node: Listing Tracepoints277139
-Node: Starting and Stopping Trace Experiments278261
-Node: Analyze Collected Data279442
-Node: tfind280747
-Node: tdump285140
-Node: save-tracepoints286799
-Node: Tracepoint Variables287218
-Node: Overlays288233
-Node: How Overlays Work288953
-Ref: A code overlay291513
-Node: Overlay Commands294951
-Node: Automatic Overlay Debugging299141
-Node: Overlay Sample Program301282
-Node: Languages303042
-Node: Setting304205
-Node: Filenames305907
-Node: Manually306693
-Node: Automatically307902
-Node: Show308963
-Node: Checks310285
-Node: Type Checking311675
-Node: Range Checking314408
-Node: Supported Languages316809
-Node: C317982
-Node: C Operators319283
-Node: C Constants323602
-Node: C Plus Plus Expressions326006
-Node: C Defaults329549
-Node: C Checks330232
-Node: Debugging C330955
-Node: Debugging C Plus Plus331439
-Node: Decimal Floating Point334556
-Node: Objective-C335814
-Node: Method Names in Commands336275
-Node: The Print Command with Objective-C337970
-Node: Fortran338621
-Node: Fortran Operators339346
-Node: Fortran Defaults339936
-Node: Special Fortran Commands340321
-Node: Pascal340827
-Node: Modula-2341342
-Node: M2 Operators342317
-Node: Built-In Func/Proc345315
-Node: M2 Constants348176
-Node: M2 Types349777
-Node: M2 Defaults352996
-Node: Deviations353596
-Node: M2 Checks354697
-Node: M2 Scope355515
-Node: GDB/M2356539
-Node: Ada357451
-Node: Ada Mode Intro358250
-Node: Omissions from Ada360122
-Node: Additions to Ada364083
-Node: Stopping Before Main Program367981
-Node: Ada Glitches368513
-Node: Unsupported Languages370491
-Node: Symbols371181
-Node: Altering384680
-Node: Assignment385649
-Node: Jumping388754
-Node: Signaling390889
-Node: Returning392020
-Node: Calling393222
-Node: Patching395115
-Node: GDB Files396192
-Node: Files396733
-Ref: Shared Libraries409568
-Node: Separate Debug Files414964
-Node: Symbol Errors425587
-Node: Targets429190
-Node: Active Targets430670
-Node: Target Commands432249
-Node: Byte Order437489
-Node: Remote Debugging438466
-Node: Connecting439728
-Node: File Transfer444603
-Node: Server445543
-Ref: Monitor Commands for gdbserver452174
-Ref: Server-Footnote-1453033
-Node: Remote Configuration453153
-Ref: set remotebreak454177
-Ref: set remote hardware-watchpoint-limit455641
-Ref: set remote hardware-breakpoint-limit455641
-Ref: set remote exec-file455923
-Node: Remote Stub459201
-Node: Stub Contents462098
-Node: Bootstrapping464209
-Node: Debug Session468018
-Node: Configurations469578
-Node: Native470347
-Node: HP-UX470941
-Node: BSD libkvm Interface471230
-Node: SVR4 Process Information472301
-Node: DJGPP Native475731
-Node: Cygwin Native482311
-Node: Non-debug DLL Symbols485692
-Node: Hurd Native490238
-Node: Neutrino495501
-Node: Embedded OS495876
-Node: VxWorks496352
-Node: VxWorks Connection498569
-Node: VxWorks Download499503
-Node: VxWorks Attach501238
-Node: Embedded Processors501636
-Node: ARM502780
-Node: M32R/D505734
-Node: M68K507436
-Node: MIPS Embedded507732
-Node: OpenRISC 1000512677
-Node: PowerPC Embedded515532
-Node: PA516998
-Node: Sparclet517287
-Node: Sparclet File518771
-Node: Sparclet Connection519651
-Node: Sparclet Download520129
-Node: Sparclet Execution521178
-Node: Sparclite521769
-Node: Z8000522142
-Node: AVR523526
-Node: CRIS523889
-Node: Super-H524867
-Node: Architectures525109
-Node: i386525531
-Node: A29K526213
-Node: Alpha527052
-Node: MIPS527185
-Node: HPPA529809
-Node: SPU530328
-Node: PowerPC531572
-Node: Controlling GDB532150
-Node: Prompt532911
-Node: Editing533690
-Node: Command History534633
-Node: Screen Size538037
-Node: Numbers539742
-Node: ABI541719
-Node: Messages/Warnings544648
-Node: Debugging Output547141
-Node: Sequences551508
-Node: Define552119
-Node: Hooks555470
-Node: Command Files557661
-Node: Output561514
-Node: Interpreters566281
-Node: TUI568376
-Node: TUI Overview569343
-Node: TUI Keys571776
-Node: TUI Single Key Mode574080
-Node: TUI Commands574955
-Node: TUI Configuration577043
-Node: Emacs578339
-Node: GDB/MI583816
-Node: GDB/MI Command Syntax585638
-Node: GDB/MI Input Syntax585851
-Node: GDB/MI Output Syntax587405
-Node: GDB/MI Compatibility with CLI590823
-Node: GDB/MI Development and Front Ends591560
-Node: GDB/MI Output Records593481
-Node: GDB/MI Result Records593763
-Node: GDB/MI Stream Records594490
-Node: GDB/MI Out-of-band Records595761
-Node: GDB/MI Simple Examples597198
-Node: GDB/MI Command Description Format599007
-Node: GDB/MI Breakpoint Commands599887
-Node: GDB/MI Program Context616392
-Node: GDB/MI Thread Commands620874
-Node: GDB/MI Program Execution622950
-Node: GDB/MI Stack Manipulation631559
-Node: GDB/MI Variable Objects641190
-Ref: -var-list-children648202
-Ref: -var-update653161
-Ref: -var-set-frozen653975
-Node: GDB/MI Data Manipulation654698
-Node: GDB/MI Tracepoint Commands669060
-Node: GDB/MI Symbol Query669304
-Node: GDB/MI File Commands672592
-Node: GDB/MI Target Manipulation676845
-Node: GDB/MI File Transfer Commands684024
-Node: GDB/MI Miscellaneous Commands685346
-Ref: -interpreter-exec688490
-Node: Annotations690791
-Node: Annotations Overview691705
-Node: Server Prefix694168
-Node: Prompting694808
-Node: Errors696325
-Node: Invalidation697221
-Node: Annotations for Running697698
-Node: Source Annotations699218
-Node: GDB Bugs700143
-Node: Bug Criteria700870
-Node: Bug Reporting701747
-Node: Command Line Editing709370
-Node: Introduction and Notation710022
-Node: Readline Interaction711642
-Node: Readline Bare Essentials712831
-Node: Readline Movement Commands714618
-Node: Readline Killing Commands715581
-Node: Readline Arguments717499
-Node: Searching718541
-Node: Readline Init File720690
-Node: Readline Init File Syntax721753
-Node: Conditional Init Constructs733685
-Node: Sample Init File736216
-Node: Bindable Readline Commands739331
-Node: Commands For Moving740386
-Node: Commands For History741245
-Node: Commands For Text744367
-Node: Commands For Killing747091
-Node: Numeric Arguments749231
-Node: Commands For Completion750368
-Node: Keyboard Macros751910
-Node: Miscellaneous Commands752479
-Node: Readline vi Mode755838
-Node: Using History Interactively756755
-Node: History Interaction757270
-Node: Event Designators758692
-Node: Word Designators759625
-Node: Modifiers761262
-Node: Formatting Documentation762487
-Ref: Formatting Documentation-Footnote-1765816
-Node: Installing GDB765880
-Node: Requirements766389
-Ref: Expat766958
-Node: Running Configure767669
-Node: Separate Objdir771208
-Node: Config Names774092
-Node: Configure Options775537
-Node: Maintenance Commands777873
-Ref: maint info breakpoints778532
-Node: Remote Protocol788832
-Node: Overview789284
-Ref: Binary Data791471
-Node: Packets793730
-Ref: extended mode794812
-Ref: read registers packet797336
-Ref: cycle step packet798502
-Ref: write register packet800378
-Ref: step with signal packet801285
-Ref: X packet805991
-Ref: insert breakpoint or watchpoint packet806281
-Node: Stop Reply Packets808727
-Node: General Query Packets812286
-Ref: QPassSignals819329
-Ref: qSupported821404
-Ref: qXfer read829996
-Ref: qXfer auxiliary vector read830490
-Ref: qXfer target description read830839
-Ref: qXfer library list read831283
-Ref: qXfer memory map read831929
-Ref: qXfer spu read832318
-Ref: qXfer spu write834448
-Ref: General Query Packets-Footnote-1835738
-Node: Register Packet Format836065
-Node: Tracepoint Packets836983
-Node: Host I/O Packets843078
-Node: Interrupts847220
-Node: Examples848681
-Node: File-I/O Remote Protocol Extension849294
-Node: File-I/O Overview849756
-Node: Protocol Basics851905
-Node: The F Request Packet854137
-Node: The F Reply Packet855038
-Node: The Ctrl-C Message855956
-Node: Console I/O857585
-Node: List of Supported Calls858802
-Node: open859164
-Node: close861658
-Node: read862040
-Node: write862647
-Node: lseek863414
-Node: rename864292
-Node: unlink865688
-Node: stat/fstat866627
-Node: gettimeofday867514
-Node: isatty867949
-Node: system868545
-Node: Protocol-specific Representation of Datatypes870087
-Node: Integral Datatypes870464
-Node: Pointer Values871271
-Node: Memory Transfer871979
-Node: struct stat872599
-Node: struct timeval874801
-Node: Constants875318
-Node: Open Flags875767
-Node: mode_t Values876108
-Node: Errno Values876600
-Node: Lseek Flags877411
-Node: Limits877596
-Node: File-I/O Examples877956
-Node: Library List Format879072
-Node: Memory Map Format880940
-Node: Agent Expressions883473
-Node: General Bytecode Design886406
-Node: Bytecode Descriptions891206
-Node: Using Agent Expressions901892
-Node: Varying Target Capabilities903425
-Node: Tracing on Symmetrix904598
-Node: Rationale910420
-Node: Target Descriptions917799
-Node: Retrieving Descriptions919838
-Node: Target Description Format920923
-Node: Predefined Target Types927470
-Node: Standard Target Features928669
-Node: ARM Features930422
-Node: MIPS Features931041
-Node: M68K Features931985
-Node: PowerPC Features932648
-Node: Copying933588
-Node: GNU Free Documentation License952806
-Node: Index975241
+Node: Top1110
+Node: Summary3816
+Node: Free Software5452
+Node: Contributors11020
+Node: Sample Session19004
+Node: Invocation25840
+Node: Invoking GDB26384
+Node: File Options28697
+Node: Mode Options31354
+Node: Startup37766
+Ref: Startup-Footnote-139671
+Node: Quitting GDB39780
+Node: Shell Commands40677
+Node: Logging Output41519
+Node: Commands42365
+Node: Command Syntax43003
+Node: Completion45169
+Node: Help49504
+Node: Running54743
+Node: Compilation55925
+Node: Starting58564
+Node: Arguments63453
+Node: Environment64723
+Node: Working Directory67991
+Node: Input/Output69099
+Node: Attach71070
+Node: Kill Process73537
+Node: Threads74503
+Node: Processes81339
+Node: Checkpoint/Restart86558
+Ref: Checkpoint/Restart-Footnote-191091
+Node: Stopping91126
+Node: Breakpoints92273
+Node: Set Breaks95692
+Node: Set Watchpoints109830
+Node: Set Catchpoints117637
+Node: Delete Breaks121676
+Node: Disabling123612
+Node: Conditions126477
+Node: Break Commands131425
+Node: Breakpoint Menus134310
+Node: Error in Breakpoints136036
+Node: Breakpoint-related Warnings137614
+Node: Continuing and Stepping139941
+Node: Signals149253
+Node: Thread Stops153525
+Node: Stack158162
+Node: Frames159638
+Node: Backtrace162390
+Ref: Backtrace-Footnote-1167281
+Node: Selection167469
+Node: Frame Info170333
+Node: Source172664
+Node: List173730
+Node: Specify Location176343
+Node: Edit179593
+Ref: Edit-Footnote-1181068
+Node: Search181303
+Node: Source Path182111
+Ref: set substitute-path187866
+Node: Machine Code190087
+Node: Data193461
+Node: Expressions195842
+Node: Variables197810
+Node: Arrays202301
+Node: Output Formats204830
+Ref: Output Formats-Footnote-1207703
+Node: Memory207860
+Node: Auto Display213107
+Node: Print Settings216820
+Node: Value History230291
+Node: Convenience Vars232707
+Node: Registers236231
+Ref: Registers-Footnote-1240906
+Node: Floating Point Hardware241301
+Node: Vector Unit241831
+Node: OS Information242216
+Node: Memory Region Attributes244214
+Node: Dump/Restore Files248872
+Node: Core File Generation251175
+Node: Character Sets252407
+Node: Caching Remote Data259232
+Node: Macros260380
+Node: Tracepoints267331
+Node: Set Tracepoints269173
+Node: Create and Delete Tracepoints270373
+Node: Enable and Disable Tracepoints272017
+Node: Tracepoint Passcounts272716
+Node: Tracepoint Actions274140
+Node: Listing Tracepoints277140
+Node: Starting and Stopping Trace Experiments278262
+Node: Analyze Collected Data279443
+Node: tfind280748
+Node: tdump285141
+Node: save-tracepoints286800
+Node: Tracepoint Variables287219
+Node: Overlays288234
+Node: How Overlays Work288954
+Ref: A code overlay291514
+Node: Overlay Commands294952
+Node: Automatic Overlay Debugging299142
+Node: Overlay Sample Program301283
+Node: Languages303043
+Node: Setting304206
+Node: Filenames305908
+Node: Manually306694
+Node: Automatically307903
+Node: Show308964
+Node: Checks310286
+Node: Type Checking311676
+Node: Range Checking314409
+Node: Supported Languages316810
+Node: C317983
+Node: C Operators319284
+Node: C Constants323603
+Node: C Plus Plus Expressions326007
+Node: C Defaults329550
+Node: C Checks330233
+Node: Debugging C330956
+Node: Debugging C Plus Plus331440
+Node: Decimal Floating Point334557
+Node: Objective-C335815
+Node: Method Names in Commands336276
+Node: The Print Command with Objective-C337971
+Node: Fortran338622
+Node: Fortran Operators339347
+Node: Fortran Defaults339937
+Node: Special Fortran Commands340322
+Node: Pascal340828
+Node: Modula-2341343
+Node: M2 Operators342318
+Node: Built-In Func/Proc345316
+Node: M2 Constants348177
+Node: M2 Types349778
+Node: M2 Defaults352997
+Node: Deviations353597
+Node: M2 Checks354698
+Node: M2 Scope355516
+Node: GDB/M2356540
+Node: Ada357452
+Node: Ada Mode Intro358251
+Node: Omissions from Ada360123
+Node: Additions to Ada364084
+Node: Stopping Before Main Program367982
+Node: Ada Glitches368514
+Node: Unsupported Languages370492
+Node: Symbols371182
+Node: Altering384681
+Node: Assignment385650
+Node: Jumping388755
+Node: Signaling390890
+Node: Returning392021
+Node: Calling393223
+Node: Patching395116
+Node: GDB Files396193
+Node: Files396734
+Ref: Shared Libraries409569
+Node: Separate Debug Files414965
+Node: Symbol Errors425588
+Node: Targets429191
+Node: Active Targets430671
+Node: Target Commands432250
+Node: Byte Order437490
+Node: Remote Debugging438467
+Node: Connecting439729
+Node: File Transfer444604
+Node: Server445544
+Ref: Monitor Commands for gdbserver452175
+Ref: Server-Footnote-1453034
+Node: Remote Configuration453154
+Ref: set remotebreak454178
+Ref: set remote hardware-watchpoint-limit455642
+Ref: set remote hardware-breakpoint-limit455642
+Ref: set remote exec-file455924
+Node: Remote Stub459202
+Node: Stub Contents462099
+Node: Bootstrapping464210
+Node: Debug Session468019
+Node: Configurations469579
+Node: Native470348
+Node: HP-UX470942
+Node: BSD libkvm Interface471231
+Node: SVR4 Process Information472302
+Node: DJGPP Native475732
+Node: Cygwin Native482312
+Node: Non-debug DLL Symbols485693
+Node: Hurd Native490239
+Node: Neutrino495502
+Node: Embedded OS495877
+Node: VxWorks496353
+Node: VxWorks Connection498570
+Node: VxWorks Download499504
+Node: VxWorks Attach501239
+Node: Embedded Processors501637
+Node: ARM502781
+Node: M32R/D505735
+Node: M68K507437
+Node: MIPS Embedded507733
+Node: OpenRISC 1000512678
+Node: PowerPC Embedded515533
+Node: PA516999
+Node: Sparclet517288
+Node: Sparclet File518772
+Node: Sparclet Connection519652
+Node: Sparclet Download520130
+Node: Sparclet Execution521179
+Node: Sparclite521770
+Node: Z8000522143
+Node: AVR523527
+Node: CRIS523890
+Node: Super-H524868
+Node: Architectures525110
+Node: i386525532
+Node: A29K526214
+Node: Alpha527053
+Node: MIPS527186
+Node: HPPA529810
+Node: SPU530329
+Node: PowerPC531573
+Node: Controlling GDB532151
+Node: Prompt532912
+Node: Editing533691
+Node: Command History534634
+Node: Screen Size538038
+Node: Numbers539743
+Node: ABI541720
+Node: Messages/Warnings544649
+Node: Debugging Output547142
+Node: Sequences551509
+Node: Define552120
+Node: Hooks555471
+Node: Command Files557662
+Node: Output561515
+Node: Interpreters566282
+Node: TUI568377
+Node: TUI Overview569344
+Node: TUI Keys571777
+Node: TUI Single Key Mode574081
+Node: TUI Commands574956
+Node: TUI Configuration577044
+Node: Emacs578340
+Node: GDB/MI583817
+Node: GDB/MI Command Syntax585639
+Node: GDB/MI Input Syntax585852
+Node: GDB/MI Output Syntax587406
+Node: GDB/MI Compatibility with CLI590824
+Node: GDB/MI Development and Front Ends591561
+Node: GDB/MI Output Records593482
+Node: GDB/MI Result Records593764
+Node: GDB/MI Stream Records594491
+Node: GDB/MI Out-of-band Records595762
+Node: GDB/MI Simple Examples597199
+Node: GDB/MI Command Description Format599008
+Node: GDB/MI Breakpoint Commands599888
+Node: GDB/MI Program Context616393
+Node: GDB/MI Thread Commands620875
+Node: GDB/MI Program Execution622951
+Node: GDB/MI Stack Manipulation631560
+Node: GDB/MI Variable Objects641191
+Ref: -var-list-children648203
+Ref: -var-update653158
+Ref: -var-set-frozen653972
+Node: GDB/MI Data Manipulation654695
+Node: GDB/MI Tracepoint Commands669057
+Node: GDB/MI Symbol Query669301
+Node: GDB/MI File Commands672589
+Node: GDB/MI Target Manipulation676842
+Node: GDB/MI File Transfer Commands684021
+Node: GDB/MI Miscellaneous Commands685343
+Ref: -interpreter-exec688487
+Node: Annotations690784
+Node: Annotations Overview691698
+Node: Server Prefix694161
+Node: Prompting694801
+Node: Errors696318
+Node: Invalidation697214
+Node: Annotations for Running697691
+Node: Source Annotations699211
+Node: GDB Bugs700136
+Node: Bug Criteria700863
+Node: Bug Reporting701740
+Node: Command Line Editing709363
+Node: Introduction and Notation710015
+Node: Readline Interaction711635
+Node: Readline Bare Essentials712824
+Node: Readline Movement Commands714611
+Node: Readline Killing Commands715574
+Node: Readline Arguments717492
+Node: Searching718534
+Node: Readline Init File720683
+Node: Readline Init File Syntax721746
+Node: Conditional Init Constructs733678
+Node: Sample Init File736209
+Node: Bindable Readline Commands739324
+Node: Commands For Moving740379
+Node: Commands For History741238
+Node: Commands For Text744360
+Node: Commands For Killing747084
+Node: Numeric Arguments749224
+Node: Commands For Completion750361
+Node: Keyboard Macros751903
+Node: Miscellaneous Commands752472
+Node: Readline vi Mode755831
+Node: Using History Interactively756748
+Node: History Interaction757263
+Node: Event Designators758685
+Node: Word Designators759618
+Node: Modifiers761255
+Node: Formatting Documentation762480
+Ref: Formatting Documentation-Footnote-1765809
+Node: Installing GDB765873
+Node: Requirements766382
+Ref: Expat766951
+Node: Running Configure767662
+Node: Separate Objdir771201
+Node: Config Names774085
+Node: Configure Options775530
+Node: Maintenance Commands777866
+Ref: maint info breakpoints778525
+Node: Remote Protocol788825
+Node: Overview789277
+Ref: Binary Data791464
+Node: Packets793723
+Ref: extended mode794805
+Ref: read registers packet797329
+Ref: cycle step packet798495
+Ref: write register packet800371
+Ref: step with signal packet801278
+Ref: X packet805984
+Ref: insert breakpoint or watchpoint packet806274
+Node: Stop Reply Packets808720
+Node: General Query Packets812279
+Ref: QPassSignals819322
+Ref: qSupported821397
+Ref: qXfer read829989
+Ref: qXfer auxiliary vector read830483
+Ref: qXfer target description read830832
+Ref: qXfer library list read831276
+Ref: qXfer memory map read831922
+Ref: qXfer spu read832311
+Ref: qXfer spu write834441
+Ref: General Query Packets-Footnote-1835731
+Node: Register Packet Format836058
+Node: Tracepoint Packets836976
+Node: Host I/O Packets843071
+Node: Interrupts847213
+Node: Examples848674
+Node: File-I/O Remote Protocol Extension849287
+Node: File-I/O Overview849749
+Node: Protocol Basics851898
+Node: The F Request Packet854130
+Node: The F Reply Packet855031
+Node: The Ctrl-C Message855949
+Node: Console I/O857578
+Node: List of Supported Calls858795
+Node: open859157
+Node: close861651
+Node: read862033
+Node: write862640
+Node: lseek863407
+Node: rename864285
+Node: unlink865681
+Node: stat/fstat866620
+Node: gettimeofday867507
+Node: isatty867942
+Node: system868538
+Node: Protocol-specific Representation of Datatypes870080
+Node: Integral Datatypes870457
+Node: Pointer Values871264
+Node: Memory Transfer871972
+Node: struct stat872592
+Node: struct timeval874794
+Node: Constants875311
+Node: Open Flags875760
+Node: mode_t Values876101
+Node: Errno Values876593
+Node: Lseek Flags877404
+Node: Limits877589
+Node: File-I/O Examples877949
+Node: Library List Format879065
+Node: Memory Map Format880933
+Node: Agent Expressions883466
+Node: General Bytecode Design886399
+Node: Bytecode Descriptions891199
+Node: Using Agent Expressions901885
+Node: Varying Target Capabilities903418
+Node: Tracing on Symmetrix904591
+Node: Rationale910413
+Node: Target Descriptions917792
+Node: Retrieving Descriptions919831
+Node: Target Description Format920916
+Node: Predefined Target Types927463
+Node: Standard Target Features928662
+Node: ARM Features930415
+Node: MIPS Features931034
+Node: M68K Features931978
+Node: PowerPC Features932641
+Node: Copying933581
+Node: GNU Free Documentation License952799
+Node: Index975234
 
 End Tag Table
diff -Naur gdb-6.8/gdb/doc/gdb.info-1 stsgdb-6.8/gdb/doc/gdb.info-1
--- gdb-6.8/gdb/doc/gdb.info-1	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdb.info-1	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdb.info, produced by makeinfo version 4.8 from
+This is gdb.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdb.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -115,11 +115,11 @@
      correcting the effects of one bug and go on to learn about another.
 
    You can use GDB to debug programs written in C and C++.  For more
-information, see *Note Supported Languages: Supported Languages.  For
-more information, see *Note C and C++: C.
+information, see *note Supported Languages: Supported Languages.  For
+more information, see *note C and C++: C.
 
    Support for Modula-2 is partial.  For information on Modula-2, see
-*Note Modula-2: Modula-2.
+*note Modula-2: Modula-2.
 
    Debugging Pascal programs which use sets, subranges, file variables,
 or nested functions does not currently work.  GDB does not support
@@ -1124,7 +1124,7 @@
 previous command.  Certain commands (for example, `run') will not
 repeat this way; these are commands whose unintentional repetition
 might cause trouble and which you are unlikely to want to repeat.
-User-defined commands can disable this feature; see *Note dont-repeat:
+User-defined commands can disable this feature; see *note dont-repeat:
 Define.
 
    The `list' and `x' commands, when you repeat them with <RET>,
@@ -1237,9 +1237,9 @@
 have not yet started typing the argument list when you ask for
 completion on an overloaded symbol.
 
-   For more information about overloaded functions, see *Note C++
+   For more information about overloaded functions, see *note C++
 Expressions: C Plus Plus Expressions.  You can use the command `set
-overload-resolution off' to disable overload resolution; see *Note GDB
+overload-resolution off' to disable overload resolution; see *note GDB
 Features for C++: Debugging C Plus Plus.
 
 
@@ -1569,11 +1569,11 @@
      `start' or `run'.
 
      It is sometimes necessary to debug the program during elaboration.
-     In these cases, using the `start' command would stop the
-     execution of your program too late, as the program would have
-     already completed the elaboration phase.  Under these
-     circumstances, insert breakpoints in your elaboration code before
-     running your program.
+     In these cases, using the `start' command would stop the execution
+     of your program too late, as the program would have already
+     completed the elaboration phase.  Under these circumstances,
+     insert breakpoints in your elaboration code before running your
+     program.
 
 
 File: gdb.info,  Node: Arguments,  Next: Environment,  Prev: Starting,  Up: Running
@@ -2316,7 +2316,7 @@
 different command to set a catchpoint (*note Setting Catchpoints: Set
 Catchpoints.), but aside from that, you can manage a catchpoint like any
 other breakpoint.  (To stop when your program receives a signal, use the
-`handle' command; see *Note Signals: Signals.)
+`handle' command; see *note Signals: Signals.)
 
    GDB assigns a number to each breakpoint, watchpoint, or catchpoint
 when you create it; these numbers are successive integers starting with
@@ -2352,7 +2352,7 @@
 
 Breakpoints are set with the `break' command (abbreviated `b').  The
 debugger convenience variable `$bpnum' records the number of the
-breakpoint you've set most recently; see *Note Convenience Variables:
+breakpoint you've set most recently; see *note Convenience Variables:
 Convenience Vars, for a discussion of what you can do with convenience
 variables.
 
@@ -2418,7 +2418,7 @@
      unused hardware breakpoints before setting new ones (*note
      Disabling Breakpoints: Disabling.).  *Note Break Conditions:
      Conditions.  For remote targets, you can restrict the number of
-     hardware breakpoints GDB will use, see *Note set remote
+     hardware breakpoints GDB will use, see *note set remote
      hardware-breakpoint-limit::.
 
 `thbreak ARGS'
@@ -2429,7 +2429,7 @@
      program stops there.  Also, like the `hbreak' command, the
      breakpoint requires hardware support and some target hardware may
      not have this support.  *Note Disabling Breakpoints: Disabling.
-     See also *Note Break Conditions: Conditions.
+     See also *note Break Conditions: Conditions.
 
 `rbreak REGEX'
      Set breakpoints on all functions matching the regular expression
@@ -2479,10 +2479,10 @@
 
     _Address_
           Where the breakpoint is in your program, as a memory address.
-          For a pending breakpoint whose address is not yet known,
-          this field will contain `<PENDING>'.  Such breakpoint won't
-          fire until a shared library that has the symbol or line
-          referred by breakpoint is loaded.  See below for details.  A
+          For a pending breakpoint whose address is not yet known, this
+          field will contain `<PENDING>'.  Such breakpoint won't fire
+          until a shared library that has the symbol or line referred
+          by breakpoint is loaded.  See below for details.  A
           breakpoint with several locations will have `<MULTIPLE>' in
           this field--see below for details.
 
@@ -2720,7 +2720,7 @@
      Show the current mode of using hardware watchpoints.
 
    For remote targets, you can restrict the number of hardware
-watchpoints GDB will use, see *Note set remote
+watchpoints GDB will use, see *note set remote
 hardware-breakpoint-limit::.
 
    When you issue the `watch' command, GDB reports
@@ -3022,7 +3022,7 @@
 enabled; subsequently, they become disabled or enabled only when you
 use one of the commands above.  (The command `until' can set and delete
 a breakpoint of its own, but it does not change the state of your other
-breakpoints; see *Note Continuing and Stepping: Continuing and
+breakpoints; see *note Continuing and Stepping: Continuing and
 Stepping.)
 
 
@@ -3495,7 +3495,7 @@
 `u LOCATION'
      Continue running your program until either the specified location
      is reached, or the current stack frame returns.  LOCATION is any of
-     the forms described in *Note Specify Location::.  This form of the
+     the forms described in *note Specify Location::.  This form of the
      command uses temporary breakpoints, and hence is quicker than
      `until' without an argument.  The specified location is actually
      reached only if it is in the current frame.  This implies that
@@ -3516,7 +3516,7 @@
 `advance LOCATION'
      Continue running the program up to the given LOCATION.  An
      argument is required, which should be of one of the forms
-     described in *Note Specify Location::.  Execution will also stop
+     described in *note Specify Location::.  Execution will also stop
      upon exit from the current stack frame.  This command is similar
      to `until', but `advance' will not skip over recursive function
      calls, and the target location doesn't have to be in the same
@@ -4133,7 +4133,7 @@
 source files by explicit command.
 
    If you use GDB through its GNU Emacs interface, you may prefer to
-use Emacs facilities to view source; see *Note Using GDB under GNU
+use Emacs facilities to view source; see *note Using GDB under GNU
 Emacs: Emacs.
 
 * Menu:
@@ -4153,7 +4153,7 @@
 
 To print lines from a source file, use the `list' command (abbreviated
 `l').  By default, ten lines are printed.  There are several ways to
-specify what part of the file you want to print; see *Note Specify
+specify what part of the file you want to print; see *note Specify
 Location::, for the full list.
 
    Here are the forms of the `list' command most commonly used:
@@ -4422,7 +4422,7 @@
 debug information in case the sources were moved to a different
 directory between compilation and debugging.  A rule is made of two
 strings, the first specifying what needs to be rewritten in the path,
-and the second specifying how it should be rewritten.  In *Note set
+and the second specifying how it should be rewritten.  In *note set
 substitute-path::, we name these two parts FROM and TO respectively.
 GDB does a simple string replacement of FROM with TO at the start of
 the directory part of the source file name, and uses that result
@@ -4556,7 +4556,7 @@
 `info line LINESPEC'
      Print the starting and ending addresses of the compiled code for
      source line LINESPEC.  You can specify source lines in any of the
-     ways documented in *Note Specify Location::.
+     ways documented in *note Specify Location::.
 
    For example, we can use `info line' to discover the location of the
 object code for the first line of function `m4_changequote':
@@ -4635,7 +4635,7 @@
      EXPR is an expression (in the source language).  By default the
      value of EXPR is printed in a format appropriate to its data type;
      you can choose a different format by specifying `/F', where F is a
-     letter specifying the format; see *Note Output Formats: Output
+     letter specifying the format; see *note Output Formats: Output
      Formats.
 
 `print'
@@ -4686,7 +4686,7 @@
 programming language you are using is valid in an expression in GDB.
 This includes conditional expressions, function calls, casts, and
 string constants.  It also includes preprocessor macros, if you
-compiled your program to include this information; see *Note
+compiled your program to include this information; see *note
 Compilation::.
 
    GDB supports array constants in expressions input by the user.  The
@@ -4982,7 +4982,7 @@
    ---------- Footnotes ----------
 
    (1) `b' cannot be used because these format letters are also used
-with the `x' command, where `b' stands for "byte"; see *Note Examining
+with the `x' command, where `b' stands for "byte"; see *note Examining
 Memory: Memory.
 
 
@@ -5065,7 +5065,7 @@
 `i' format also prints branch delay slot instructions, if any, beyond
 the count specified, which immediately follow the last instruction that
 is within the count.  The command `disassemble' gives an alternative
-way of inspecting machine instructions; see *Note Source and Machine
+way of inspecting machine instructions; see *note Source and Machine
 Code: Machine Code.
 
    All the defaults for the arguments to `x' are designed to make it
@@ -5823,7 +5823,7 @@
 assumes that the innermost stack frame is selected; setting `$sp' is
 not allowed when other stack frames are selected.  To pop entire frames
 off the stack, regardless of machine architecture, use `return'; see
-*Note Returning from a Function: Returning.
+*note Returning from a Function: Returning.
 
 
 File: gdb.info,  Node: Floating Point Hardware,  Next: Vector Unit,  Prev: Registers,  Up: Data
@@ -5883,7 +5883,7 @@
 system-specific.  Depending on the configuration and operating system
 facilities, GDB may be able to show you this information.  For remote
 targets, this functionality may further depend on the remote stub's
-support of the `qXfer:auxv:read' packet, see *Note qXfer auxiliary
+support of the `qXfer:auxv:read' packet, see *note qXfer auxiliary
 vector read::.
 
 `info auxv'
@@ -6164,8 +6164,8 @@
      `set host-charset' command.
 
      GDB can only use certain character sets as its host character set.
-     We list the character set names GDB recognizes below, and
-     indicate which can be host character sets, but if you type `set
+     We list the character set names GDB recognizes below, and indicate
+     which can be host character sets, but if you type `set
      target-charset' followed by <TAB><TAB>, GDB will list the host
      character sets it supports.
 
@@ -6372,7 +6372,7 @@
 definitions, or have no definition at all.  If there is a current stack
 frame, GDB uses the macros in scope at that frame's source code line.
 Otherwise, GDB uses the macros in scope at the current listing location;
-see *Note List::.
+see *note List::.
 
    At the moment, GDB does not support the `##' token-splicing
 operator, the `#' stringification operator, or variable-arity macros.
@@ -6576,7 +6576,7 @@
 how to collect trace data.  This functionality is implemented in the
 remote stub; however, none of the stubs distributed with GDB support
 tracepoints as of this writing.  The format of the remote packets used
-to implement tracepoints are described in *Note Tracepoint Packets::.
+to implement tracepoints are described in *note Tracepoint Packets::.
 
    This chapter describes the tracepoint commands and features.
 
@@ -7213,7 +7213,7 @@
      be relocated and its symbols defined as if the overlay were at its
      mapped address.  You can use GNU linker scripts to specify
      different load and relocation addresses for pieces of your
-     program; see *Note Overlay Description: (ld.info)Overlay
+     program; see *note Overlay Description: (ld.info)Overlay
      Description.
 
    * The procedure for loading executable files onto your system must
@@ -7290,7 +7290,7 @@
 `overlay auto'
      Enable "automatic" overlay debugging.  In this mode, GDB consults
      a data structure the overlay manager maintains in the inferior to
-     see which overlays are mapped.  For details, see *Note Automatic
+     see which overlays are mapped.  For details, see *note Automatic
      Overlay Debugging::.
 
 `overlay load-target'
diff -Naur gdb-6.8/gdb/doc/gdb.info-2 stsgdb-6.8/gdb/doc/gdb.info-2
--- gdb-6.8/gdb/doc/gdb.info-2	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdb.info-2	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdb.info, produced by makeinfo version 4.8 from
+This is gdb.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdb.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -784,7 +784,7 @@
      explicit function signature to call an overloaded function, as in
           p 'foo(char,int)'('x', 13)
 
-     The GDB command-completion facility can simplify this; see *Note
+     The GDB command-completion facility can simplify this; see *note
      Command Completion: Completion.
 
   4. GDB understands variables declared as C++ references; you can use
@@ -913,7 +913,7 @@
      Enable overload resolution for C++ expression evaluation.  The
      default is on.  For overloaded functions, GDB evaluates the
      arguments and searches for a function whose signature matches the
-     argument types, using the standard C++ conversion rules (see *Note
+     argument types, using the standard C++ conversion rules (see *note
      C++ Expressions: C Plus Plus Expressions, for details).  If it
      cannot find a match, it emits a message.
 
@@ -964,7 +964,7 @@
 
    In the PowerPC architecture, GDB provides a set of pseudo-registers
 to inspect `_Decimal128' values stored in floating point registers. See
-*Note PowerPC: PowerPC. for more details.
+*note PowerPC: PowerPC. for more details.
 
 
 File: gdb.info,  Node: Objective-C,  Next: Fortran,  Prev: C,  Up: Supported Languages
@@ -973,8 +973,8 @@
 ------------------
 
 This section provides information about some commands and command
-options that are useful for debugging Objective-C code.  See also *Note
-info classes: Symbols, and *Note info selectors: Symbols, for a few
+options that are useful for debugging Objective-C code.  See also *note
+info classes: Symbols, and *note info selectors: Symbols, for a few
 more commands specific to Objective-C support.
 
 * Menu:
@@ -1101,7 +1101,7 @@
 
 Fortran symbols are usually case-insensitive, so GDB by default uses
 case-insensitive matches for Fortran symbols.  You can change that with
-the `set case-insensitive' command, see *Note Symbols::, for the
+the `set case-insensitive' command, see *note Symbols::, for the
 details.
 
 
@@ -2135,7 +2135,7 @@
           Symbol repeat is a local variable at frame offset -8, length 4.
 
      This command is especially useful for determining what data to
-     collect during a "trace experiment", see *Note collect: Tracepoint
+     collect during a "trace experiment", see *note collect: Tracepoint
      Actions.
 
 `info source'
@@ -2426,8 +2426,8 @@
 `jump LOCATION'
      Resume execution at line LINESPEC or at address given by LOCATION.
      Execution stops again immediately if there is a breakpoint there.
-     *Note Specify Location::, for a description of the different
-     forms of LINESPEC and LOCATION.  It is common practice to use the
+     *Note Specify Location::, for a description of the different forms
+     of LINESPEC and LOCATION.  It is common practice to use the
      `tbreak' command in conjunction with `jump'.  *Note Setting
      Breakpoints: Set Breaks.
 
@@ -3036,7 +3036,7 @@
      supported only on some operating systems, notably those which use
      the ELF format for binary files and the GNU Binutils.)  For more
      details about this feature, see the description of the `--build-id'
-     command-line option in *Note Command Line Options:
+     command-line option in *note Command Line Options:
      (ld.info)Options.  The debug info file's name is not specified
      explicitly by the build ID, but can be computed from the build ID,
      see below.
@@ -3455,7 +3455,7 @@
      device drivers, or even basic I/O is available, although some
      simulators do provide these.  For info about any
      processor-specific simulator details, see the appropriate section
-     in *Note Embedded Processors: Embedded Processors.
+     in *note Embedded Processors: Embedded Processors.
 
 
    Some configurations may include these targets as well:
@@ -3809,8 +3809,8 @@
 running.  The `run' and `attach' commands instruct `gdbserver' to run
 or attach to a new program.  The `run' command uses `set remote
 exec-file' (*note set remote exec-file::) to select the program to run.
-Command line arguments are supported, except for wildcard expansion
-and I/O redirection (*note Arguments::).
+Command line arguments are supported, except for wildcard expansion and
+I/O redirection (*note Arguments::).
 
    To start `gdbserver' without supplying an initial command to run or
 process ID to attach, use the `--multi' command line option.  Then you
@@ -3894,7 +3894,7 @@
 
 This section documents the configuration options available when
 debugging remote programs.  For the options related to the File I/O
-extensions of the remote protocol, see *Note system-call-allowed:
+extensions of the remote protocol, see *note system-call-allowed:
 system.
 
 `set remoteaddresssize BITS'
@@ -3976,7 +3976,7 @@
 can be set to `on' (the remote target supports this packet), `off' (the
 remote target does not support this packet), or `auto' (detect remote
 target support for this packet).  They all default to `auto'.  For more
-information about each packet, see *Note Remote Protocol::.
+information about each packet, see *note Remote Protocol::.
 
    During normal use, you should not have to use any of these commands.
 If you do, that may be a bug in your remote debugging stub, or a bug in
@@ -4595,7 +4595,7 @@
 GDB supports native debugging of MS Windows programs, including DLLs
 with and without symbolic debugging information.  There are various
 additional Cygwin-specific commands, described in this section.
-Working with DLLs that have no debugging symbols is described in *Note
+Working with DLLs that have no debugging symbols is described in *note
 Non-debug DLL Symbols::.
 
 `info w32'
@@ -4694,8 +4694,8 @@
 start the program -- either by setting a breakpoint or letting the
 program run once to completion.  It is also possible to force GDB to
 load a particular DLL before starting the executable -- see the shared
-library information in *Note Files::, or the `dll-symbols' command in
-*Note Cygwin Native::.  Currently, explicitly loading symbols from a
+library information in *note Files::, or the `dll-symbols' command in
+*note Cygwin Native::.  Currently, explicitly loading symbols from a
 DLL with no debugging information will cause the symbol names to be
 duplicated in GDB's lookup table, which may adversely affect symbol
 lookup performance.
@@ -6071,7 +6071,7 @@
 ******************
 
 You can alter the way GDB interacts with you by using the `set'
-command.  For commands controlling how GDB displays data, see *Note
+command.  For commands controlling how GDB displays data, see *note
 Print Settings: Print Settings.  Other settings are described here.
 
 * Menu:
@@ -6403,7 +6403,7 @@
 
    Currently, the messages controlled by `set verbose' are those which
 announce that the symbol table for a source file is being read; see
-`symbol-file' in *Note Commands to Specify Files: Files.
+`symbol-file' in *note Commands to Specify Files: Files.
 
 `set verbose on'
      Enables GDB output of certain informational messages.
@@ -6696,7 +6696,7 @@
      infinite recursion and aborts the command.
 
    In addition to the above commands, user-defined commands frequently
-use control flow commands, described in *Note Command Files::.
+use control flow commands, described in *note Command Files::.
 
    When user-defined commands are executed, the commands of the
 definition are not printed.  An error in any command stops execution of
@@ -7009,7 +7009,7 @@
 `mi'
      The newest GDB/MI interface (currently `mi2').  Used primarily by
      programs wishing to use GDB as a backend for a debugger GUI or an
-     IDE.  For more information, see *Note The GDB/MI Interface: GDB/MI.
+     IDE.  For more information, see *note The GDB/MI Interface: GDB/MI.
 
 `mi2'
      The current GDB/MI interface.
diff -Naur gdb-6.8/gdb/doc/gdb.info-3 stsgdb-6.8/gdb/doc/gdb.info-3
--- gdb-6.8/gdb/doc/gdb.info-3	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdb.info-3	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdb.info, produced by makeinfo version 4.8 from
+This is gdb.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdb.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -1115,8 +1115,8 @@
 
    Starts execution of the inferior from the beginning.  The inferior
 executes until either a breakpoint is encountered or the program exits.
-In the latter case the output will include an exit code, if the
-program has exited exceptionally.
+In the latter case the output will include an exit code, if the program
+has exited exceptionally.
 
 GDB Command
 ...........
@@ -1777,8 +1777,7 @@
 ........
 
       -var-list-children [PRINT-VALUES] NAME
-
-   Return a list of the children of the specified variable object and
+Return a list of the children of the specified variable object and
 create variable objects for them, if they do not already exist.  With a
 single argument or if PRINT-VALUES has a value for of 0 or
 `--no-values', print only the names of the variables; if PRINT-VALUES
@@ -2149,7 +2148,7 @@
 .......
 
 In the following example, the numbers that precede the commands are the
-"tokens" described in *Note GDB/MI Command Syntax: GDB/MI Command
+"tokens" described in *note GDB/MI Command Syntax: GDB/MI Command
 Syntax.  Notice how GDB/MI returns the same tokens in its output.
 
      211-data-evaluate-expression A
@@ -3436,8 +3435,7 @@
 --------
 
      -interpreter-exec INTERPRETER COMMAND
-
-   Execute the specified COMMAND in the given INTERPRETER.
+Execute the specified COMMAND in the given INTERPRETER.
 
 GDB Command
 -----------
@@ -5851,7 +5849,7 @@
 In addition to commands intended for GDB users, GDB includes a number
 of commands intended for GDB developers, that are not documented
 elsewhere in this manual.  These commands are provided here for
-reference.  (For commands that turn on debugging messages, see *Note
+reference.  (For commands that turn on debugging messages, see *note
 Debugging Output::.)
 
 `maint agent EXPRESSION'
@@ -6245,10 +6243,10 @@
 syntax, followed by an explanation of the packet's meaning.  We include
 spaces in some of the templates for clarity; these are not part of the
 packet's syntax.  No GDB packet uses spaces to separate its components.
-For example, a template like `foo BAR BAZ' describes a packet
-beginning with the three ASCII bytes `foo', followed by a BAR, followed
-directly by a BAZ.  GDB does not transmit a space character between the
-`foo' and the BAR, or between the BAR and the BAZ.
+For example, a template like `foo BAR BAZ' describes a packet beginning
+with the three ASCII bytes `foo', followed by a BAR, followed directly
+by a BAZ.  GDB does not transmit a space character between the `foo'
+and the BAR, or between the BAR and the BAZ.
 
    Note that all packet forms beginning with an upper- or lower-case
 letter, other than those described here, are reserved for future use.
@@ -6457,7 +6455,7 @@
 `q NAME PARAMS...'
 `Q NAME PARAMS...'
      General query (`q') and set (`Q').  These packets are described
-     fully in *Note General Query Packets::.
+     fully in *note General Query Packets::.
 
 `r'
      Reset the entire system.
@@ -6557,7 +6555,7 @@
 
 `vFile:OPERATION:PARAMETER...'
      Perform a file operation on the target system.  For details, see
-     *Note Host I/O Packets::.
+     *note Host I/O Packets::.
 
 `vFlashErase:ADDR,LENGTH'
      Direct the stub to erase LENGTH bytes of flash starting at ADDR.
@@ -7485,7 +7483,7 @@
 
     `X LEN,EXPR'
           Evaluate EXPR, whose length is LEN, and collect memory as it
-          directs.  EXPR is an agent expression, as described in *Note
+          directs.  EXPR is an agent expression, as described in *note
           Agent Expressions::.  Each byte of the expression is encoded
           as a two-digit hex number in the packet; LEN is the number of
           bytes in the expression (and thus one-half the number of hex
@@ -7496,10 +7494,10 @@
      packet, as long as the packet does not exceed the maximum packet
      length (400 bytes, for many stubs).  There may be only one `R'
      action per tracepoint, and it must precede any `M' or `X' actions.
-     Any registers referred to by `M' and `X' actions must be
-     collected by a preceding `R' action.  (The "while-stepping"
-     actions are treated as if they were attached to a separate
-     tracepoint, as far as these restrictions are concerned.)
+     Any registers referred to by `M' and `X' actions must be collected
+     by a preceding `R' action.  (The "while-stepping" actions are
+     treated as if they were attached to a separate tracepoint, as far
+     as these restrictions are concerned.)
 
      Replies:
     `OK'
@@ -7657,11 +7655,11 @@
 
 `vFile:pwrite: FD, OFFSET, DATA'
      Write DATA (a binary buffer) to the open file corresponding to FD.
-     Start the write at OFFSET from the start of the file.  Unlike
-     many `write' system calls, there is no separate COUNT argument;
-     the length of DATA in the packet is used.  `vFile:write' returns
-     the number of bytes written, which may be shorter than the length
-     of DATA, or -1 if an error occurred.
+     Start the write at OFFSET from the start of the file.  Unlike many
+     `write' system calls, there is no separate COUNT argument; the
+     length of DATA in the packet is used.  `vFile:write' returns the
+     number of bytes written, which may be shorter than the length of
+     DATA, or -1 if an error occurred.
 
 `vFile:unlink: PATHNAME'
      Delete the file at PATHNAME on the target.  Return 0, or -1 if an
@@ -8571,7 +8569,7 @@
      };
 
    The integral datatypes conform to the definitions given in the
-appropriate section (see *Note Integral Datatypes::, for details) so
+appropriate section (see *note Integral Datatypes::, for details) so
 this structure is of size 64 bytes.
 
    The values of several fields have a restricted meaning and/or range
@@ -8584,7 +8582,7 @@
      No valid meaning for the target.  Transmitted unchanged.
 
 `st_mode'
-     Valid mode bits are described in *Note Constants::.  Any other
+     Valid mode bits are described in *note Constants::.  Any other
      bits have currently no meaning for the target.
 
 `st_uid'
@@ -8622,7 +8620,7 @@
      };
 
    The integral datatypes conform to the definitions given in the
-appropriate section (see *Note Integral Datatypes::, for details) so
+appropriate section (see *note Integral Datatypes::, for details) so
 this structure is of size 8 bytes.
 
 
diff -Naur gdb-6.8/gdb/doc/gdb.info-4 stsgdb-6.8/gdb/doc/gdb.info-4
--- gdb-6.8/gdb/doc/gdb.info-4	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdb.info-4	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdb.info, produced by makeinfo version 4.8 from
+This is gdb.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdb.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -304,7 +304,7 @@
 
    * The agent arranges to be notified when a trace point is hit.  Note
      that, on some systems, the target operating system is completely
-     responsible for collecting the data; see *Note Tracing on
+     responsible for collecting the data; see *note Tracing on
      Symmetrix::.
 
    * When execution on the target reaches a trace point, the agent
@@ -689,7 +689,7 @@
 description from the target.  GDB retrieves it via the remote protocol
 using `qXfer' requests (*note qXfer: General Query Packets.).  The
 ANNEX in the `qXfer' packet will be `target.xml'.  The contents of the
-`target.xml' annex are an XML document, of the form described in *Note
+`target.xml' annex are an XML document, of the form described in *note
 Target Description Format::.
 
    Alternatively, you can specify a file to read for the target
@@ -1939,7 +1939,7 @@
                                                               (line 343)
 * -e:                                    File Options.        (line  35)
 * -enable-timings:                       GDB/MI Miscellaneous Commands.
-                                                              (line 235)
+                                                              (line 234)
 * -environment-cd:                       GDB/MI Program Context.
                                                               (line  50)
 * -environment-directory:                GDB/MI Program Context.
@@ -2001,9 +2001,9 @@
 * -gdb-version:                          GDB/MI Miscellaneous Commands.
                                                               (line  97)
 * -inferior-tty-set:                     GDB/MI Miscellaneous Commands.
-                                                              (line 186)
+                                                              (line 185)
 * -inferior-tty-show:                    GDB/MI Miscellaneous Commands.
-                                                              (line 209)
+                                                              (line 208)
 * -interpreter-exec:                     GDB/MI Miscellaneous Commands.
                                                               (line 160)
 * -l:                                    Mode Options.        (line 124)
@@ -2074,33 +2074,33 @@
 * -thread-select:                        GDB/MI Thread Commands.
                                                               (line  79)
 * -var-assign:                           GDB/MI Variable Objects.
-                                                              (line 304)
+                                                              (line 303)
 * -var-create:                           GDB/MI Variable Objects.
                                                               (line  85)
 * -var-delete:                           GDB/MI Variable Objects.
                                                               (line 126)
 * -var-evaluate-expression:              GDB/MI Variable Objects.
-                                                              (line 287)
+                                                              (line 286)
 * -var-info-expression:                  GDB/MI Variable Objects.
-                                                              (line 228)
+                                                              (line 227)
 * -var-info-num-children:                GDB/MI Variable Objects.
                                                               (line 175)
 * -var-info-path-expression:             GDB/MI Variable Objects.
-                                                              (line 252)
+                                                              (line 251)
 * -var-info-type:                        GDB/MI Variable Objects.
-                                                              (line 215)
+                                                              (line 214)
 * -var-list-children:                    GDB/MI Variable Objects.
                                                               (line 187)
 * -var-set-format:                       GDB/MI Variable Objects.
                                                               (line 139)
 * -var-set-frozen:                       GDB/MI Variable Objects.
-                                                              (line 381)
+                                                              (line 380)
 * -var-show-attributes:                  GDB/MI Variable Objects.
-                                                              (line 273)
+                                                              (line 272)
 * -var-show-format:                      GDB/MI Variable Objects.
                                                               (line 162)
 * -var-update:                           GDB/MI Variable Objects.
-                                                              (line 328)
+                                                              (line 327)
 * -w:                                    Mode Options.        (line  76)
 * -x:                                    File Options.        (line  51)
 * ., Modula-2 scope operator:            M2 Scope.            (line   6)
diff -Naur gdb-6.8/gdb/doc/gdbint.info stsgdb-6.8/gdb/doc/gdbint.info
--- gdb-6.8/gdb/doc/gdbint.info	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdbint.info	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdbint.info, produced by makeinfo version 4.8 from
+This is gdbint.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdbint.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -21,70 +21,70 @@
 
 
 Indirect:
-gdbint.info-1: 904
-gdbint.info-2: 288529
+gdbint.info-1: 905
+gdbint.info-2: 288530
 
 Tag Table:
 (Indirect)
-Node: Top904
-Node: Requirements1767
-Node: Overall Structure3255
-Node: Algorithms8191
-Node: User Interface40683
-Ref: User Interface-Footnote-164475
-Ref: User Interface-Footnote-264524
-Node: libgdb64759
-Node: Symbol Handling68719
-Node: Language Support83499
-Node: Host Definition88900
-Node: Target Architecture Definition95983
-Node: OS ABI Variant Handling96800
-Node: Initialize New Architecture101642
-Node: Registers and Memory103211
-Node: Pointers and Addresses104001
-Ref: Pointers and Addresses-Footnote-1110026
-Node: Address Classes110269
-Node: Raw and Virtual Registers113533
-Node: Register and Memory Data118417
-Node: Frame Interpretation121845
-Node: Inferior Call Setup122044
-Node: Compiler Characteristics122241
-Node: Target Conditionals122449
-Ref: gdbarch_breakpoint_from_pc127174
-Ref: frame_align133920
-Ref: DEPRECATED_FRAME_SAVED_PC136286
-Ref: gdbarch_unwind_pc136469
-Ref: gdbarch_unwind_sp137039
-Ref: gdbarch_stabs_argument_has_addr147068
-Ref: gdbarch_push_dummy_call147573
-Ref: gdbarch_push_dummy_code148189
-Ref: SAVE_DUMMY_FRAME_TOS149071
-Ref: gdbarch_return_value149733
-Ref: gdbarch_write_pc154655
-Ref: TARGET_READ_SP154689
-Ref: gdbarch_unwind_dummy_id156433
-Node: Adding a New Target157896
-Node: Target Descriptions160151
-Node: Target Descriptions Implementation161090
-Node: Adding Target Described Register Support162464
-Node: Target Vector Definition165410
-Node: Managing Execution State165942
-Node: Existing Targets167755
-Node: Native Debugging170076
-Node: Support Libraries178701
-Node: Coding190215
-Node: Porting GDB215191
-Node: Versions and Branches217100
-Ref: Tags223060
-Ref: experimental branch tags223391
-Node: Start of New Year Procedure224123
-Node: Releasing GDB225472
-Node: Testsuite243812
-Node: Hints251091
-Node: Getting Started251413
-Node: Debugging GDB255556
-Node: GDB Observers261483
-Node: GNU Free Documentation License266085
-Node: Index288529
+Node: Top905
+Node: Requirements1768
+Node: Overall Structure3256
+Node: Algorithms8192
+Node: User Interface40684
+Ref: User Interface-Footnote-164476
+Ref: User Interface-Footnote-264525
+Node: libgdb64760
+Node: Symbol Handling68720
+Node: Language Support83500
+Node: Host Definition88901
+Node: Target Architecture Definition95984
+Node: OS ABI Variant Handling96801
+Node: Initialize New Architecture101643
+Node: Registers and Memory103212
+Node: Pointers and Addresses104002
+Ref: Pointers and Addresses-Footnote-1110027
+Node: Address Classes110270
+Node: Raw and Virtual Registers113534
+Node: Register and Memory Data118418
+Node: Frame Interpretation121846
+Node: Inferior Call Setup122045
+Node: Compiler Characteristics122242
+Node: Target Conditionals122450
+Ref: gdbarch_breakpoint_from_pc127175
+Ref: frame_align133921
+Ref: DEPRECATED_FRAME_SAVED_PC136287
+Ref: gdbarch_unwind_pc136470
+Ref: gdbarch_unwind_sp137040
+Ref: gdbarch_stabs_argument_has_addr147069
+Ref: gdbarch_push_dummy_call147574
+Ref: gdbarch_push_dummy_code148190
+Ref: SAVE_DUMMY_FRAME_TOS149072
+Ref: gdbarch_return_value149734
+Ref: gdbarch_write_pc154656
+Ref: TARGET_READ_SP154690
+Ref: gdbarch_unwind_dummy_id156434
+Node: Adding a New Target157897
+Node: Target Descriptions160152
+Node: Target Descriptions Implementation161091
+Node: Adding Target Described Register Support162465
+Node: Target Vector Definition165411
+Node: Managing Execution State165943
+Node: Existing Targets167756
+Node: Native Debugging170077
+Node: Support Libraries178702
+Node: Coding190216
+Node: Porting GDB215192
+Node: Versions and Branches217101
+Ref: Tags223061
+Ref: experimental branch tags223392
+Node: Start of New Year Procedure224124
+Node: Releasing GDB225473
+Node: Testsuite243813
+Node: Hints251092
+Node: Getting Started251414
+Node: Debugging GDB255557
+Node: GDB Observers261484
+Node: GNU Free Documentation License266086
+Node: Index288530
 
 End Tag Table
diff -Naur gdb-6.8/gdb/doc/gdbint.info-1 stsgdb-6.8/gdb/doc/gdbint.info-1
--- gdb-6.8/gdb/doc/gdbint.info-1	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdbint.info-1	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdbint.info, produced by makeinfo version 4.8 from
+This is gdbint.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdbint.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -891,7 +891,7 @@
 easy to extend, and versatile enough to be used as the standard
 interface when adding new notifications.
 
-   See *Note GDB Observers:: for a brief description of the observers
+   See *note GDB Observers:: for a brief description of the observers
 currently implemented in GDB. The rationale for the current
 implementation is also briefly discussed.
 
@@ -1861,7 +1861,7 @@
 The COFF sections, symbols, and line numbers are used, but debugging
 symbols are `dbx'-style stabs whose strings are located in the `.debug'
 section (rather than the string table).  For more information, see
-*Note Top: (stabs)Top.
+*note Top: (stabs)Top.
 
    The shared library scheme has a clean interface for figuring out what
 shared libraries are in use, but the catch is that everything which
@@ -2735,7 +2735,7 @@
 
 _Maintainer note: This section is pretty much obsolete.  The
 functionality described here has largely been replaced by
-pseudo-registers and the mechanisms described in *Note Using Different
+pseudo-registers and the mechanisms described in *note Using Different
 Register and Memory Data Representations: Target Architecture
 Definition.  See also Bug Tracking Database
 (http://www.gnu.org/software/gdb/bugs/) and ARI Index
@@ -3306,7 +3306,7 @@
 
 `I386_USE_GENERIC_WATCHPOINTS'
      An x86-based target can define this to use the generic x86
-     watchpoint support; see *Note I386_USE_GENERIC_WATCHPOINTS:
+     watchpoint support; see *note I386_USE_GENERIC_WATCHPOINTS:
      Algorithms.
 
 `int gdbarch_inner_than (GDBARCH, LHS, RHS)'
@@ -3780,7 +3780,7 @@
 supports, or for the target to tell GDB directly.
 
    For details on writing, automatically supplying, and manually
-selecting target descriptions, see *Note Target Descriptions:
+selecting target descriptions, see *note Target Descriptions:
 (gdb)Target Descriptions.  This section will cover some related topics
 about the GDB internals.
 
@@ -3813,7 +3813,7 @@
 new architecture.  Then the initialization routine is called, and has a
 chance to adjust the constructed architecture based on the contents of
 the target description.  For instance, it can recognize any properties
-set by a `to_read_description' routine.  Also see *Note Adding Target
+set by a `to_read_description' routine.  Also see *note Adding Target
 Described Register Support::.
 
 
@@ -4168,7 +4168,7 @@
 
 `I386_USE_GENERIC_WATCHPOINTS'
      An x86-based machine can define this to use the generic x86
-     watchpoint support; see *Note I386_USE_GENERIC_WATCHPOINTS:
+     watchpoint support; see *note I386_USE_GENERIC_WATCHPOINTS:
      Algorithms.
 
 `ONE_PROCESS_WRITETEXT'
diff -Naur gdb-6.8/gdb/doc/gdbint.info-2 stsgdb-6.8/gdb/doc/gdbint.info-2
--- gdb-6.8/gdb/doc/gdbint.info-2	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/gdbint.info-2	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is gdbint.info, produced by makeinfo version 4.8 from
+This is gdbint.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/gdbint.texinfo.
 
 INFO-DIR-SECTION Software development
diff -Naur gdb-6.8/gdb/doc/stabs.info stsgdb-6.8/gdb/doc/stabs.info
--- gdb-6.8/gdb/doc/stabs.info	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/doc/stabs.info	2008-09-11 10:34:24.000000000 +0100
@@ -1,4 +1,4 @@
-This is stabs.info, produced by makeinfo version 4.8 from
+This is stabs.info, produced by makeinfo version 4.11 from
 ../.././gdb/doc/stabs.texinfo.
 
 INFO-DIR-SECTION Software development
@@ -133,7 +133,7 @@
      .stabx "STRING",VALUE,TYPE,SDB-TYPE
 
    For `.stabn' and `.stabd', there is no STRING (the `n_strx' field is
-zero; see *Note Symbol Tables::).  For `.stabd', the VALUE field is
+zero; see *note Symbol Tables::).  For `.stabd', the VALUE field is
 implicit and has the value of the current file location.  For `.stabx',
 the SDB-TYPE field is unused for stabs and can always be set to zero.
 The OTHER field is almost always unused and can be set to zero.
@@ -174,7 +174,7 @@
 that tells more specifically what kind of symbol the stab represents.
 If the SYMBOL-DESCRIPTOR is omitted, but type information follows, then
 the stab represents a local variable.  For a list of symbol
-descriptors, see *Note Symbol Descriptors::.  The `c' symbol descriptor
+descriptors, see *note Symbol Descriptors::.  The `c' symbol descriptor
 is an exception in that it is not followed by type information.  *Note
 Constants::.
 
@@ -195,7 +195,7 @@
 TYPE-DESCRIPTOR vary, depending on the TYPE-DESCRIPTOR.  *Note Type
 Descriptors::, for a list of TYPE-DESCRIPTOR values.  If a number
 follows the `=' then the number is a TYPE-REFERENCE.  For a full
-description of types, *Note Types::.
+description of types, *note Types::.
 
    A TYPE-NUMBER is often a single number.  The GNU and Sun tools
 additionally permit a TYPE-NUMBER to be a pair
@@ -205,7 +205,7 @@
 on.  The FILETYPE-NUMBER is a number starting with 1 which is
 incremented for each new type defined in the file.  (Separating the
 file number and the type number permits the `N_BINCL' optimization to
-succeed more often; see *Note Include Files::).
+succeed more often; see *note Include Files::).
 
    There is an AIX extension for type attributes.  Following the `='
 are any number of type attributes.  Each one starts with `@' and ends
@@ -562,7 +562,7 @@
 sure how to find which symbol of that name is the right one, and this
 doesn't provide any way to deal with nested functions, it would
 probably be better to make the value of the stab an address relative to
-the start of the file, or just absolute.  See *Note ELF Linker
+the start of the file, or just absolute.  See *note ELF Linker
 Relocation:: for more information on linker relocation of stabs in ELF
 files.  For XCOFF, the stab uses the `C_FUN' storage class and the
 value of the stab is meaningless; the address of the function can be
@@ -835,7 +835,7 @@
    The value of the stab is the offset of the variable within the local
 variables.  On most machines this is an offset from the frame pointer
 and is negative.  The location of the stab specifies which block it is
-defined in; see *Note Block Structure::.
+defined in; see *note Block Structure::.
 
    For example, the following C code:
 
@@ -852,8 +852,8 @@
      .stabn 192,0,0,LBB2             # 192 is N_LBRAC
      .stabn 224,0,0,LBE2             # 224 is N_RBRAC
 
-   See *Note Procedures:: for more information on the `N_FUN' stab, and
-*Note Block Structure:: for more information on the `N_LBRAC' and
+   See *note Procedures:: for more information on the `N_FUN' stab, and
+*note Block Structure:: for more information on the `N_LBRAC' and
 `N_RBRAC' stabs.
 
 
@@ -1667,7 +1667,7 @@
      represented by `M-2;3', where `-2' is a reference to a character
      type (*note Negative Type Numbers::).  I'm not sure how this
      differs from an array.  This appears to be a Fortran feature.
-     LENGTH is a bound, like those in range types; see *Note
+     LENGTH is a bound, like those in range types; see *note
      Subranges::.
 
 `S TYPE-INFORMATION'
@@ -1695,7 +1695,7 @@
 `s' for a structure tag, `u' for a union tag, or `e' for a enumerator
 tag, followed by the name of the tag, followed by `:'.  If the name
 contains `::' between a `<' and `>' pair (for C++ templates), such a
-`::' does not end the name--only a single `:' ends the name; see *Note
+`::' does not end the name--only a single `:' ends the name; see *note
 Nested Symbols::.
 
    For example, the following C declarations:
@@ -1757,7 +1757,7 @@
 `J'
      There is no bound.
 
-   Subranges are also used for builtin types; see *Note Traditional
+   Subranges are also used for builtin types; see *note Traditional
 Builtin Types::.
 
 
@@ -1903,7 +1903,7 @@
    There is no standard way to specify the size of an enumeration type;
 it is determined by the architecture (normally all enumerations types
 are 32 bits).  Type attributes can be used to specify an enumeration
-type of another size for debuggers which support them; see *Note String
+type of another size for debuggers which support them; see *note String
 Field::.
 
    Enumeration types are unusual in that they define symbols for the
@@ -1977,7 +1977,7 @@
 refers to.
 
    If the structure has methods (a C++ feature), they follow the
-non-method fields; see *Note Cplusplus::.
+non-method fields; see *note Cplusplus::.
 
 
 File: stabs.info,  Node: Typedefs,  Next: Unions,  Prev: Structures,  Up: Types
@@ -2488,8 +2488,8 @@
 rather than one.  This is followed by a new type definition for the
 method.  This is a number followed by an equal sign and the type of the
 method.  Normally this will be a type declared using the `#' type
-descriptor; see *Note Method Type Descriptor::; static member functions
-are declared using the `f' type descriptor instead; see *Note Function
+descriptor; see *note Method Type Descriptor::; static member functions
+are declared using the `f' type descriptor instead; see *note Function
 Types::.
 
    The format of an overloaded operator method name differs from that of
@@ -3105,149 +3105,149 @@
 languages other than C.
 
 `0x20     N_GSYM'
-     Global symbol; see *Note Global Variables::.
+     Global symbol; see *note Global Variables::.
 
 `0x22     N_FNAME'
-     Function name (for BSD Fortran); see *Note Procedures::.
+     Function name (for BSD Fortran); see *note Procedures::.
 
 `0x24     N_FUN'
      Function name (*note Procedures::) or text segment variable (*note
      Statics::).
 
 `0x26 N_STSYM'
-     Data segment file-scope variable; see *Note Statics::.
+     Data segment file-scope variable; see *note Statics::.
 
 `0x28 N_LCSYM'
-     BSS segment file-scope variable; see *Note Statics::.
+     BSS segment file-scope variable; see *note Statics::.
 
 `0x2a N_MAIN'
-     Name of main routine; see *Note Main Program::.
+     Name of main routine; see *note Main Program::.
 
 `0x2c N_ROSYM'
-     Variable in `.rodata' section; see *Note Statics::.
+     Variable in `.rodata' section; see *note Statics::.
 
 `0x30     N_PC'
-     Global symbol (for Pascal); see *Note N_PC::.
+     Global symbol (for Pascal); see *note N_PC::.
 
 `0x32     N_NSYMS'
-     Number of symbols (according to Ultrix V4.0); see *Note N_NSYMS::.
+     Number of symbols (according to Ultrix V4.0); see *note N_NSYMS::.
 
 `0x34     N_NOMAP'
-     No DST map; see *Note N_NOMAP::.
+     No DST map; see *note N_NOMAP::.
 
 `0x36     N_MAC_DEFINE'
-     Name and body of a `#define'd macro; see *Note Macro define and
+     Name and body of a `#define'd macro; see *note Macro define and
      undefine::.
 
 `0x38 N_OBJ'
      Object file (Solaris2).
 
 `0x3a     N_MAC_UNDEF'
-     Name of an `#undef'ed macro; see *Note Macro define and undefine::.
+     Name of an `#undef'ed macro; see *note Macro define and undefine::.
 
 `0x3c N_OPT'
      Debugger options (Solaris2).
 
 `0x40     N_RSYM'
-     Register variable; see *Note Register Variables::.
+     Register variable; see *note Register Variables::.
 
 `0x42     N_M2C'
-     Modula-2 compilation unit; see *Note N_M2C::.
+     Modula-2 compilation unit; see *note N_M2C::.
 
 `0x44     N_SLINE'
-     Line number in text segment; see *Note Line Numbers::.
+     Line number in text segment; see *note Line Numbers::.
 
 `0x46     N_DSLINE'
-     Line number in data segment; see *Note Line Numbers::.
+     Line number in data segment; see *note Line Numbers::.
 
 `0x48     N_BSLINE'
-     Line number in bss segment; see *Note Line Numbers::.
+     Line number in bss segment; see *note Line Numbers::.
 
 `0x48     N_BROWS'
-     Sun source code browser, path to `.cb' file; see *Note N_BROWS::.
+     Sun source code browser, path to `.cb' file; see *note N_BROWS::.
 
 `0x4a     N_DEFD'
-     GNU Modula2 definition module dependency; see *Note N_DEFD::.
+     GNU Modula2 definition module dependency; see *note N_DEFD::.
 
 `0x4c N_FLINE'
      Function start/body/end line numbers (Solaris2).
 
 `0x50     N_EHDECL'
-     GNU C++ exception variable; see *Note N_EHDECL::.
+     GNU C++ exception variable; see *note N_EHDECL::.
 
 `0x50     N_MOD2'
-     Modula2 info "for imc" (according to Ultrix V4.0); see *Note
+     Modula2 info "for imc" (according to Ultrix V4.0); see *note
      N_MOD2::.
 
 `0x54     N_CATCH'
-     GNU C++ `catch' clause; see *Note N_CATCH::.
+     GNU C++ `catch' clause; see *note N_CATCH::.
 
 `0x60     N_SSYM'
-     Structure of union element; see *Note N_SSYM::.
+     Structure of union element; see *note N_SSYM::.
 
 `0x62 N_ENDM'
      Last stab for module (Solaris2).
 
 `0x64     N_SO'
-     Path and name of source file; see *Note Source Files::.
+     Path and name of source file; see *note Source Files::.
 
 `0x80 N_LSYM'
      Stack variable (*note Stack Variables::) or type (*note
      Typedefs::).
 
 `0x82     N_BINCL'
-     Beginning of an include file (Sun only); see *Note Include Files::.
+     Beginning of an include file (Sun only); see *note Include Files::.
 
 `0x84     N_SOL'
-     Name of include file; see *Note Include Files::.
+     Name of include file; see *note Include Files::.
 
 `0xa0     N_PSYM'
-     Parameter variable; see *Note Parameters::.
+     Parameter variable; see *note Parameters::.
 
 `0xa2     N_EINCL'
-     End of an include file; see *Note Include Files::.
+     End of an include file; see *note Include Files::.
 
 `0xa4     N_ENTRY'
-     Alternate entry point; see *Note Alternate Entry Points::.
+     Alternate entry point; see *note Alternate Entry Points::.
 
 `0xc0     N_LBRAC'
-     Beginning of a lexical block; see *Note Block Structure::.
+     Beginning of a lexical block; see *note Block Structure::.
 
 `0xc2     N_EXCL'
-     Place holder for a deleted include file; see *Note Include Files::.
+     Place holder for a deleted include file; see *note Include Files::.
 
 `0xc4     N_SCOPE'
-     Modula2 scope information (Sun linker); see *Note N_SCOPE::.
+     Modula2 scope information (Sun linker); see *note N_SCOPE::.
 
 `0xe0     N_RBRAC'
-     End of a lexical block; see *Note Block Structure::.
+     End of a lexical block; see *note Block Structure::.
 
 `0xe2     N_BCOMM'
-     Begin named common block; see *Note Common Blocks::.
+     Begin named common block; see *note Common Blocks::.
 
 `0xe4     N_ECOMM'
-     End named common block; see *Note Common Blocks::.
+     End named common block; see *note Common Blocks::.
 
 `0xe8     N_ECOML'
-     Member of a common block; see *Note Common Blocks::.
+     Member of a common block; see *note Common Blocks::.
 
 `0xea N_WITH'
      Pascal `with' statement: type,,0,0,offset (Solaris2).
 
 `0xf0     N_NBTEXT'
-     Gould non-base registers; see *Note Gould::.
+     Gould non-base registers; see *note Gould::.
 
 `0xf2     N_NBDATA'
-     Gould non-base registers; see *Note Gould::.
+     Gould non-base registers; see *note Gould::.
 
 `0xf4     N_NBBSS'
-     Gould non-base registers; see *Note Gould::.
+     Gould non-base registers; see *note Gould::.
 
 `0xf6     N_NBSTS'
-     Gould non-base registers; see *Note Gould::.
+     Gould non-base registers; see *note Gould::.
 
 `0xf8     N_NBLCS'
-     Gould non-base registers; see *Note Gould::.
+     Gould non-base registers; see *note Gould::.
 
 
 File: stabs.info,  Node: Symbol Descriptors,  Next: Type Descriptors,  Prev: Stab Types,  Up: Top
@@ -3262,108 +3262,108 @@
 `DIGIT'
 `('
 `-'
-     Variable on the stack; see *Note Stack Variables::.
+     Variable on the stack; see *note Stack Variables::.
 
 `:'
      C++ nested symbol; see *Note Nested Symbols::.
 
 `a'
-     Parameter passed by reference in register; see *Note Reference
+     Parameter passed by reference in register; see *note Reference
      Parameters::.
 
 `b'
-     Based variable; see *Note Based Variables::.
+     Based variable; see *note Based Variables::.
 
 `c'
-     Constant; see *Note Constants::.
+     Constant; see *note Constants::.
 
 `C'
-     Conformant array bound (Pascal, maybe other languages); *Note
+     Conformant array bound (Pascal, maybe other languages); *note
      Conformant Arrays::.  Name of a caught exception (GNU C++).  These
      can be distinguished because the latter uses `N_CATCH' and the
      former uses another symbol type.
 
 `d'
-     Floating point register variable; see *Note Register Variables::.
+     Floating point register variable; see *note Register Variables::.
 
 `D'
-     Parameter in floating point register; see *Note Register
+     Parameter in floating point register; see *note Register
      Parameters::.
 
 `f'
-     File scope function; see *Note Procedures::.
+     File scope function; see *note Procedures::.
 
 `F'
-     Global function; see *Note Procedures::.
+     Global function; see *note Procedures::.
 
 `G'
-     Global variable; see *Note Global Variables::.
+     Global variable; see *note Global Variables::.
 
 `i'
      *Note Register Parameters::.
 
 `I'
-     Internal (nested) procedure; see *Note Nested Procedures::.
+     Internal (nested) procedure; see *note Nested Procedures::.
 
 `J'
-     Internal (nested) function; see *Note Nested Procedures::.
+     Internal (nested) function; see *note Nested Procedures::.
 
 `L'
      Label name (documented by AIX, no further information known).
 
 `m'
-     Module; see *Note Procedures::.
+     Module; see *note Procedures::.
 
 `p'
-     Argument list parameter; see *Note Parameters::.
+     Argument list parameter; see *note Parameters::.
 
 `pP'
      *Note Parameters::.
 
 `pF'
-     Fortran Function parameter; see *Note Parameters::.
+     Fortran Function parameter; see *note Parameters::.
 
 `P'
      Unfortunately, three separate meanings have been independently
      invented for this symbol descriptor.  At least the GNU and Sun
      uses can be distinguished by the symbol type.  Global Procedure
-     (AIX) (symbol type used unknown); see *Note Procedures::.
-     Register parameter (GNU) (symbol type `N_PSYM'); see *Note
+     (AIX) (symbol type used unknown); see *note Procedures::.
+     Register parameter (GNU) (symbol type `N_PSYM'); see *note
      Parameters::.  Prototype of function referenced by this file (Sun
      `acc') (symbol type `N_FUN').
 
 `Q'
-     Static Procedure; see *Note Procedures::.
+     Static Procedure; see *note Procedures::.
 
 `R'
-     Register parameter; see *Note Register Parameters::.
+     Register parameter; see *note Register Parameters::.
 
 `r'
-     Register variable; see *Note Register Variables::.
+     Register variable; see *note Register Variables::.
 
 `S'
-     File scope variable; see *Note Statics::.
+     File scope variable; see *note Statics::.
 
 `s'
      Local variable (OS9000).
 
 `t'
-     Type name; see *Note Typedefs::.
+     Type name; see *note Typedefs::.
 
 `T'
-     Enumeration, structure, or union tag; see *Note Typedefs::.
+     Enumeration, structure, or union tag; see *note Typedefs::.
 
 `v'
-     Parameter passed by reference; see *Note Reference Parameters::.
+     Parameter passed by reference; see *note Reference Parameters::.
 
 `V'
-     Procedure scope static variable; see *Note Statics::.
+     Procedure scope static variable; see *note Statics::.
 
 `x'
-     Conformant array; see *Note Conformant Arrays::.
+     Conformant array; see *note Conformant Arrays::.
 
 `X'
-     Function return variable; see *Note Parameters::.
+     Function return variable; see *note Parameters::.
 
 
 File: stabs.info,  Node: Type Descriptors,  Next: Expanded Reference,  Prev: Symbol Descriptors,  Up: Top
@@ -3377,115 +3377,115 @@
 
 `DIGIT'
 `('
-     Type reference; see *Note String Field::.
+     Type reference; see *note String Field::.
 
 `-'
-     Reference to builtin type; see *Note Negative Type Numbers::.
+     Reference to builtin type; see *note Negative Type Numbers::.
 
 `#'
-     Method (C++); see *Note Method Type Descriptor::.
+     Method (C++); see *note Method Type Descriptor::.
 
 `*'
-     Pointer; see *Note Miscellaneous Types::.
+     Pointer; see *note Miscellaneous Types::.
 
 `&'
      Reference (C++).
 
 `@'
-     Type Attributes (AIX); see *Note String Field::.  Member (class
-     and variable) type (GNU C++); see *Note Member Type Descriptor::.
+     Type Attributes (AIX); see *note String Field::.  Member (class
+     and variable) type (GNU C++); see *note Member Type Descriptor::.
 
 `a'
-     Array; see *Note Arrays::.
+     Array; see *note Arrays::.
 
 `A'
-     Open array; see *Note Arrays::.
+     Open array; see *note Arrays::.
 
 `b'
-     Pascal space type (AIX); see *Note Miscellaneous Types::.  Builtin
-     integer type (Sun); see *Note Builtin Type Descriptors::.  Const
+     Pascal space type (AIX); see *note Miscellaneous Types::.  Builtin
+     integer type (Sun); see *note Builtin Type Descriptors::.  Const
      and volatile qualified type (OS9000).
 
 `B'
-     Volatile-qualified type; see *Note Miscellaneous Types::.
+     Volatile-qualified type; see *note Miscellaneous Types::.
 
 `c'
-     Complex builtin type (AIX); see *Note Builtin Type Descriptors::.
+     Complex builtin type (AIX); see *note Builtin Type Descriptors::.
      Const-qualified type (OS9000).
 
 `C'
      COBOL Picture type.  See AIX documentation for details.
 
 `d'
-     File type; see *Note Miscellaneous Types::.
+     File type; see *note Miscellaneous Types::.
 
 `D'
-     N-dimensional dynamic array; see *Note Arrays::.
+     N-dimensional dynamic array; see *note Arrays::.
 
 `e'
-     Enumeration type; see *Note Enumerations::.
+     Enumeration type; see *note Enumerations::.
 
 `E'
-     N-dimensional subarray; see *Note Arrays::.
+     N-dimensional subarray; see *note Arrays::.
 
 `f'
-     Function type; see *Note Function Types::.
+     Function type; see *note Function Types::.
 
 `F'
-     Pascal function parameter; see *Note Function Types::
+     Pascal function parameter; see *note Function Types::
 
 `g'
-     Builtin floating point type; see *Note Builtin Type Descriptors::.
+     Builtin floating point type; see *note Builtin Type Descriptors::.
 
 `G'
      COBOL Group.  See AIX documentation for details.
 
 `i'
-     Imported type (AIX); see *Note Cross-References::.
+     Imported type (AIX); see *note Cross-References::.
      Volatile-qualified type (OS9000).
 
 `k'
-     Const-qualified type; see *Note Miscellaneous Types::.
+     Const-qualified type; see *note Miscellaneous Types::.
 
 `K'
      COBOL File Descriptor.  See AIX documentation for details.
 
 `M'
-     Multiple instance type; see *Note Miscellaneous Types::.
+     Multiple instance type; see *note Miscellaneous Types::.
 
 `n'
-     String type; see *Note Strings::.
+     String type; see *note Strings::.
 
 `N'
-     Stringptr; see *Note Strings::.
+     Stringptr; see *note Strings::.
 
 `o'
-     Opaque type; see *Note Typedefs::.
+     Opaque type; see *note Typedefs::.
 
 `p'
-     Procedure; see *Note Function Types::.
+     Procedure; see *note Function Types::.
 
 `P'
-     Packed array; see *Note Arrays::.
+     Packed array; see *note Arrays::.
 
 `r'
-     Range type; see *Note Subranges::.
+     Range type; see *note Subranges::.
 
 `R'
-     Builtin floating type; see *Note Builtin Type Descriptors:: (Sun).
-     Pascal subroutine parameter; see *Note Function Types:: (AIX).
+     Builtin floating type; see *note Builtin Type Descriptors:: (Sun).
+     Pascal subroutine parameter; see *note Function Types:: (AIX).
      Detecting this conflict is possible with careful parsing (hint: a
      Pascal subroutine parameter type will always contain a comma, and
      a builtin type descriptor never will).
 
 `s'
-     Structure type; see *Note Structures::.
+     Structure type; see *note Structures::.
 
 `S'
-     Set type; see *Note Miscellaneous Types::.
+     Set type; see *note Miscellaneous Types::.
 
 `u'
-     Union; see *Note Unions::.
+     Union; see *note Unions::.
 
 `v'
      Variant record.  This is a Pascal and Modula-2 feature which is
@@ -3493,16 +3493,16 @@
      details.
 
 `w'
-     Wide character; see *Note Builtin Type Descriptors::.
+     Wide character; see *note Builtin Type Descriptors::.
 
 `x'
-     Cross-reference; see *Note Cross-References::.
+     Cross-reference; see *note Cross-References::.
 
 `Y'
      Used by IBM's xlC C++ compiler (for structures, I think).
 
 `z'
-     gstring; see *Note Strings::.
+     gstring; see *note Strings::.
 
 
 File: stabs.info,  Node: Expanded Reference,  Next: Questions,  Prev: Type Descriptors,  Up: Top
@@ -3511,7 +3511,7 @@
 ******************************************
 
 For a full list of stab types, and cross-references to where they are
-described, see *Note Stab Types::.  This appendix just covers certain
+described, see *note Stab Types::.  This appendix just covers certain
 stabs which are not yet described in the main body of this document;
 eventually the information will all be in one place.
 
@@ -4426,98 +4426,98 @@
 
 
 Tag Table:
-Node: Top877
-Node: Overview1924
-Node: Flow3339
-Node: Stabs Format4865
-Node: String Field6427
-Node: C Example11858
-Node: Assembly Code12403
-Node: Program Structure14374
-Node: Main Program15100
-Node: Source Files15661
-Node: Include Files18113
-Node: Line Numbers20778
-Node: Procedures22312
-Node: Nested Procedures28202
-Node: Block Structure29378
-Node: Alternate Entry Points30784
-Node: Constants31517
-Node: Variables34629
-Node: Stack Variables35317
-Node: Global Variables37018
-Node: Register Variables38174
-Node: Common Blocks38996
-Node: Statics40250
-Node: Based Variables42829
-Node: Parameters44214
-Node: Register Parameters45826
-Node: Local Variable Parameters48087
-Node: Reference Parameters51002
-Node: Conformant Arrays51622
-Node: Types52339
-Node: Builtin Types53286
-Node: Traditional Builtin Types54432
-Node: Traditional Integer Types54833
-Node: Traditional Other Types57141
-Node: Builtin Type Descriptors58055
-Node: Negative Type Numbers61555
-Node: Miscellaneous Types67910
-Node: Cross-References69796
-Node: Subranges71471
-Node: Arrays72710
-Node: Strings75935
-Node: Enumerations76997
-Node: Structures79382
-Node: Typedefs82089
-Node: Unions83413
-Node: Function Types84994
-Node: Macro define and undefine86576
-Node: Symbol Tables88153
-Node: Symbol Table Format88605
-Node: Transformations On Symbol Tables90053
-Node: Transformations On Static Variables91407
-Node: Transformations On Global Variables92143
-Node: Stab Section Transformations93386
-Node: Cplusplus94769
-Node: Class Names95352
-Node: Nested Symbols96097
-Node: Basic Cplusplus Types96943
-Node: Simple Classes98503
-Node: Class Instance102797
-Node: Methods103514
-Node: Method Type Descriptor105733
-Node: Member Type Descriptor106933
-Node: Protections107725
-Node: Method Modifiers110815
-Node: Virtual Methods112443
-Node: Inheritance116244
-Node: Virtual Base Classes119940
-Node: Static Members122184
-Node: Stab Types122654
-Node: Non-Stab Symbol Types123278
-Node: Stab Symbol Types124709
-Node: Symbol Descriptors128640
-Node: Type Descriptors131419
-Node: Expanded Reference134631
-Node: N_PC136049
-Node: N_NSYMS136417
-Node: N_NOMAP136658
-Node: N_M2C136964
-Node: N_BROWS137398
-Node: N_DEFD137681
-Node: N_EHDECL138138
-Node: N_MOD2138389
-Node: N_CATCH138627
-Node: N_SSYM139121
-Node: N_SCOPE139406
-Node: Gould139596
-Node: N_LENG140588
-Node: Questions140816
-Node: Stab Sections142460
-Node: Stab Section Basics143058
-Node: ELF Linker Relocation146399
-Node: GNU Free Documentation License149809
-Node: Symbol Types Index172243
+Node: Top878
+Node: Overview1925
+Node: Flow3340
+Node: Stabs Format4866
+Node: String Field6428
+Node: C Example11859
+Node: Assembly Code12404
+Node: Program Structure14375
+Node: Main Program15101
+Node: Source Files15662
+Node: Include Files18114
+Node: Line Numbers20779
+Node: Procedures22313
+Node: Nested Procedures28203
+Node: Block Structure29379
+Node: Alternate Entry Points30785
+Node: Constants31518
+Node: Variables34630
+Node: Stack Variables35318
+Node: Global Variables37019
+Node: Register Variables38175
+Node: Common Blocks38997
+Node: Statics40251
+Node: Based Variables42830
+Node: Parameters44215
+Node: Register Parameters45827
+Node: Local Variable Parameters48088
+Node: Reference Parameters51003
+Node: Conformant Arrays51623
+Node: Types52340
+Node: Builtin Types53287
+Node: Traditional Builtin Types54433
+Node: Traditional Integer Types54834
+Node: Traditional Other Types57142
+Node: Builtin Type Descriptors58056
+Node: Negative Type Numbers61556
+Node: Miscellaneous Types67911
+Node: Cross-References69797
+Node: Subranges71472
+Node: Arrays72711
+Node: Strings75936
+Node: Enumerations76998
+Node: Structures79383
+Node: Typedefs82090
+Node: Unions83414
+Node: Function Types84995
+Node: Macro define and undefine86577
+Node: Symbol Tables88154
+Node: Symbol Table Format88606
+Node: Transformations On Symbol Tables90054
+Node: Transformations On Static Variables91408
+Node: Transformations On Global Variables92144
+Node: Stab Section Transformations93387
+Node: Cplusplus94770
+Node: Class Names95353
+Node: Nested Symbols96098
+Node: Basic Cplusplus Types96944
+Node: Simple Classes98504
+Node: Class Instance102798
+Node: Methods103515
+Node: Method Type Descriptor105734
+Node: Member Type Descriptor106934
+Node: Protections107726
+Node: Method Modifiers110816
+Node: Virtual Methods112444
+Node: Inheritance116245
+Node: Virtual Base Classes119941
+Node: Static Members122185
+Node: Stab Types122655
+Node: Non-Stab Symbol Types123279
+Node: Stab Symbol Types124710
+Node: Symbol Descriptors128641
+Node: Type Descriptors131420
+Node: Expanded Reference134632
+Node: N_PC136050
+Node: N_NSYMS136418
+Node: N_NOMAP136659
+Node: N_M2C136965
+Node: N_BROWS137399
+Node: N_DEFD137682
+Node: N_EHDECL138139
+Node: N_MOD2138390
+Node: N_CATCH138628
+Node: N_SSYM139122
+Node: N_SCOPE139407
+Node: Gould139597
+Node: N_LENG140589
+Node: Questions140817
+Node: Stab Sections142461
+Node: Stab Section Basics143059
+Node: ELF Linker Relocation146400
+Node: GNU Free Documentation License149810
+Node: Symbol Types Index172244
 
 End Tag Table
diff -Naur gdb-6.8/gdb/dwarf2-frame.c stsgdb-6.8/gdb/dwarf2-frame.c
--- gdb-6.8/gdb/dwarf2-frame.c	2008-01-01 22:53:09.000000000 +0000
+++ stsgdb-6.8/gdb/dwarf2-frame.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,6 +1,7 @@
 /* Frame unwinder for frames with DWARF Call Frame Information.
 
    Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    Contributed by Mark Kettenis.
 
@@ -337,7 +338,8 @@
   while (insn_ptr < insn_end && fs->pc <= pc)
     {
       gdb_byte insn = *insn_ptr++;
-      ULONGEST utmp, reg;
+      int reg = 0;
+      ULONGEST ureg, utmp;
       LONGEST offset;
 
       if ((insn & 0xc0) == DW_CFA_advance_loc)
@@ -383,42 +385,87 @@
 	      break;
 
 	    case DW_CFA_offset_extended:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
 	      offset = utmp * fs->data_align;
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_offset_extended register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_restore_extended:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_restore_rule (gdbarch, reg, fs, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_restore_extended register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_restore_rule (gdbarch, reg, fs, eh_frame_p);
+		}
 	      break;
 
 	    case DW_CFA_undefined:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNDEFINED;
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_undefined register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNDEFINED;
+		}
 	      break;
 
 	    case DW_CFA_same_value:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAME_VALUE;
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_same_value register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAME_VALUE;
+		}
 	      break;
 
 	    case DW_CFA_register:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
-	      utmp = dwarf2_frame_adjust_regnum (gdbarch, utmp, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
-	      fs->regs.reg[reg].loc.reg = utmp;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_register register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  utmp = dwarf2_frame_adjust_regnum (gdbarch, utmp, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
+		  fs->regs.reg[reg].loc.reg = utmp;
+		}
 	      break;
 
 	    case DW_CFA_remember_state:
@@ -489,51 +536,96 @@
 	      break;
 
 	    case DW_CFA_expression:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
-	      fs->regs.reg[reg].loc.exp = insn_ptr;
-	      fs->regs.reg[reg].exp_len = utmp;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_EXP;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_expression register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].loc.exp = insn_ptr;
+		  fs->regs.reg[reg].exp_len = utmp;
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_EXP;
+		}
 	      insn_ptr += utmp;
 	      break;
 
 	    case DW_CFA_offset_extended_sf:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
 	      offset *= fs->data_align;
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_extended_sf register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_val_offset:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
 	      offset = utmp * fs->data_align;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_val_offset register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_val_offset_sf:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
 	      offset *= fs->data_align;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_val_offset_sf register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_val_expression:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
-	      fs->regs.reg[reg].loc.exp = insn_ptr;
-	      fs->regs.reg[reg].exp_len = utmp;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_EXP;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_val_expression register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].loc.exp = insn_ptr;
+		  fs->regs.reg[reg].exp_len = utmp;
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_EXP;
+		}
 	      insn_ptr += utmp;
 	      break;
 
@@ -583,13 +675,22 @@
 	      break;
 
 	    case DW_CFA_GNU_negative_offset_extended:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &offset);
 	      offset *= fs->data_align;
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
-	      fs->regs.reg[reg].loc.offset = -offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_GNU_negative_offset_extended register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
+		  fs->regs.reg[reg].loc.offset = -offset;
+		}
 	      break;
 
 	    default:
diff -Naur gdb-6.8/gdb/event-top.c stsgdb-6.8/gdb/event-top.c
--- gdb-6.8/gdb/event-top.c	2008-01-01 22:53:09.000000000 +0000
+++ stsgdb-6.8/gdb/event-top.c	2008-09-11 10:35:35.000000000 +0100
@@ -31,6 +31,7 @@
 #include <signal.h>
 #include "exceptions.h"
 #include "cli/cli-script.h"     /* for reset_command_nest_depth */
+#include "main.h"
 
 /* For dont_repeat() */
 #include "gdbcmd.h"
@@ -1148,8 +1149,6 @@
      that the sync setup is ALL done in gdb_init, and we would only
      mess it up here.  The sync stuff should really go away over
      time.  */
-  extern int batch_silent;
-
   if (!batch_silent)
     gdb_stdout = stdio_fileopen (stdout);
   gdb_stderr = stdio_fileopen (stderr);
diff -Naur gdb-6.8/gdb/f-exp.c stsgdb-6.8/gdb/f-exp.c
--- gdb-6.8/gdb/f-exp.c	2008-03-27 18:27:13.000000000 +0000
+++ stsgdb-6.8/gdb/f-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -92,6 +105,7 @@
      UNARY = 294
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define FLOAT 259
 #define STRING_LITERAL 260
@@ -229,9 +243,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 131 "f-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     struct {
       LONGEST val;
@@ -250,9 +270,10 @@
 
     struct type **tvec;
     int *ivec;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 256 "f-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 276 "f-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -267,56 +288,170 @@
 static int parse_number (char *, int, int, YYSTYPE *);
 
 
-/* Line 214 of yacc.c.  */
-#line 272 "f-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 293 "f-exp.c.tmp"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -326,24 +461,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -361,39 +496,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  46
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   531
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  56
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  18
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  85
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  130
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   294
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -430,7 +559,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned char yyprhs[] =
+static const yytype_uint8 yyprhs[] =
 {
        0,     0,     3,     5,     7,     9,    13,    16,    19,    22,
       25,    28,    31,    32,    38,    39,    41,    43,    47,    51,
@@ -443,8 +572,8 @@
      238,   240,   242,   244,   248,   250
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       57,     0,    -1,    59,    -1,    58,    -1,    65,    -1,    52,
       59,    53,    -1,    47,    59,    -1,    35,    59,    -1,    46,
@@ -475,7 +604,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   230,   230,   231,   234,   240,   245,   249,   253,   257,
      261,   265,   275,   274,   282,   285,   289,   293,   299,   305,
@@ -489,9 +618,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "FLOAT", "STRING_LITERAL",
@@ -514,7 +643,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -526,7 +655,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    56,    57,    57,    58,    59,    59,    59,    59,    59,
       59,    59,    60,    59,    61,    61,    61,    61,    62,    62,
@@ -540,7 +669,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     1,     3,     2,     2,     2,     2,
        2,     2,     0,     5,     0,     1,     1,     3,     3,     2,
@@ -556,7 +685,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
        0,    47,    49,    54,    53,    85,    69,    48,     0,    70,
       71,    75,    74,    73,    76,    77,    78,    79,    80,    81,
@@ -573,8 +702,8 @@
       64,     0,    68,    20,    19,     0,    13,    83,    18,    17
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
 {
       -1,    28,    29,    42,   104,   118,   119,    43,    31,   108,
       33,    73,    74,    75,    34,   110,   103,    35
@@ -583,7 +712,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -49
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      123,   -49,   -49,   -49,   -49,   -49,   -49,   -49,   156,   -49,
      -49,   -49,   -49,   -49,   -49,   -49,   -49,   -49,   -49,   -49,
@@ -601,7 +730,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
+static const yytype_int8 yypgoto[] =
 {
      -49,   -49,   -49,     0,   -49,   -49,   -49,   -49,   -49,     2,
      -49,   -30,   -49,   -29,   -49,   -49,   -49,   -49
@@ -612,7 +741,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -1
-static const unsigned char yytable[] =
+static const yytype_uint8 yytable[] =
 {
       30,    70,    32,    46,    69,   121,   125,    79,    37,    65,
       66,    67,    68,    71,    69,   102,    67,    68,    72,    69,
@@ -670,7 +799,7 @@
        0,    69
 };
 
-static const yysigned_char yycheck[] =
+static const yytype_int8 yycheck[] =
 {
        0,    35,     0,     0,    52,    29,    29,    53,     8,    47,
       48,    49,    50,    47,    52,     7,    49,    50,    52,    52,
@@ -730,7 +859,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     3,     4,     5,     6,     7,     8,     9,    10,    12,
       13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
@@ -747,22 +876,6 @@
       53,    29,    53,    59,    55,    29,    53,    65,    59,    59
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -788,30 +901,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -832,42 +978,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -876,45 +1076,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -929,13 +1136,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -945,45 +1148,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -993,70 +1198,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1064,13 +1391,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1079,10 +1406,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1095,14 +1422,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1113,13 +1444,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1130,18 +1467,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1150,9 +1487,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1176,8 +1513,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1190,18 +1526,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1212,21 +1548,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1257,19 +1593,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1284,7 +1618,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1304,22 +1638,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1357,7 +1690,7 @@
         case 4:
 #line 235 "f-exp.y"
     { write_exp_elt_opcode(OP_TYPE);
-			  write_exp_elt_type(yyvsp[0].tval);
+			  write_exp_elt_type((yyvsp[(1) - (1)].tval));
 			  write_exp_elt_opcode(OP_TYPE); }
     break;
 
@@ -1464,14 +1797,14 @@
   case 24:
 #line 332 "f-exp.y"
     { write_exp_elt_opcode (UNOP_CAST);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_CAST); }
     break;
 
   case 25:
 #line 338 "f-exp.y"
     { write_exp_elt_opcode (STRUCTOP_STRUCT);
-                          write_exp_string (yyvsp[0].sval);
+                          write_exp_string ((yyvsp[(3) - (3)].sval));
                           write_exp_elt_opcode (STRUCTOP_STRUCT); }
     break;
 
@@ -1578,22 +1911,22 @@
   case 46:
 #line 427 "f-exp.y"
     { write_exp_elt_opcode (BINOP_ASSIGN_MODIFY);
-			  write_exp_elt_opcode (yyvsp[-1].opcode);
+			  write_exp_elt_opcode ((yyvsp[(2) - (3)].opcode));
 			  write_exp_elt_opcode (BINOP_ASSIGN_MODIFY); }
     break;
 
   case 47:
 #line 433 "f-exp.y"
     { write_exp_elt_opcode (OP_LONG);
-			  write_exp_elt_type (yyvsp[0].typed_val.type);
-			  write_exp_elt_longcst ((LONGEST)(yyvsp[0].typed_val.val));
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val).type);
+			  write_exp_elt_longcst ((LONGEST)((yyvsp[(1) - (1)].typed_val).val));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 48:
 #line 440 "f-exp.y"
     { YYSTYPE val;
-			  parse_number (yyvsp[0].ssym.stoken.ptr, yyvsp[0].ssym.stoken.length, 0, &val);
+			  parse_number ((yyvsp[(1) - (1)].ssym).stoken.ptr, (yyvsp[(1) - (1)].ssym).stoken.length, 0, &val);
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (val.typed_val.type);
 			  write_exp_elt_longcst ((LONGEST)val.typed_val.val);
@@ -1604,7 +1937,7 @@
 #line 449 "f-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
 			  write_exp_elt_type (builtin_type_f_real_s8);
-			  write_exp_elt_dblcst (yyvsp[0].dval);
+			  write_exp_elt_dblcst ((yyvsp[(1) - (1)].dval));
 			  write_exp_elt_opcode (OP_DOUBLE); }
     break;
 
@@ -1612,15 +1945,15 @@
 #line 462 "f-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_f_integer);
-			  CHECK_TYPEDEF (yyvsp[-1].tval);
-			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yyvsp[-1].tval));
+			  CHECK_TYPEDEF ((yyvsp[(3) - (4)].tval));
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ((yyvsp[(3) - (4)].tval)));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 53:
 #line 470 "f-exp.y"
     { write_exp_elt_opcode (OP_BOOL);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].lval));
 			  write_exp_elt_opcode (OP_BOOL);
 			}
     break;
@@ -1629,14 +1962,14 @@
 #line 477 "f-exp.y"
     {
 			  write_exp_elt_opcode (OP_STRING);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(1) - (1)].sval));
 			  write_exp_elt_opcode (OP_STRING);
 			}
     break;
 
   case 55:
 #line 485 "f-exp.y"
-    { struct symbol *sym = yyvsp[0].ssym.sym;
+    { struct symbol *sym = (yyvsp[(1) - (1)].ssym).sym;
 
 			  if (sym)
 			    {
@@ -1659,7 +1992,7 @@
 			  else
 			    {
 			      struct minimal_symbol *msymbol;
-			      char *arg = copy_name (yyvsp[0].ssym.stoken);
+			      char *arg = copy_name ((yyvsp[(1) - (1)].ssym).stoken);
 
 			      msymbol =
 				lookup_minimal_symbol (arg, NULL, NULL);
@@ -1673,7 +2006,7 @@
 				error ("No symbol table is loaded.  Use the \"file\" command.");
 			      else
 				error ("No symbol \"%s\" in current context.",
-				       copy_name (yyvsp[0].ssym.stoken));
+				       copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			    }
 			}
     break;
@@ -1684,7 +2017,7 @@
 		  /* This is where the interesting stuff happens.  */
 		  int done = 0;
 		  int array_size;
-		  struct type *follow_type = yyvsp[-1].tval;
+		  struct type *follow_type = (yyvsp[(1) - (2)].tval);
 		  struct type *range_type;
 		  
 		  while (!done)
@@ -1718,33 +2051,33 @@
 			follow_type = lookup_function_type (follow_type);
 			break;
 		      }
-		  yyval.tval = follow_type;
+		  (yyval.tval) = follow_type;
 		}
     break;
 
   case 59:
 #line 576 "f-exp.y"
-    { push_type (tp_pointer); yyval.voidval = 0; }
+    { push_type (tp_pointer); (yyval.voidval) = 0; }
     break;
 
   case 60:
 #line 578 "f-exp.y"
-    { push_type (tp_pointer); yyval.voidval = yyvsp[0].voidval; }
+    { push_type (tp_pointer); (yyval.voidval) = (yyvsp[(2) - (2)].voidval); }
     break;
 
   case 61:
 #line 580 "f-exp.y"
-    { push_type (tp_reference); yyval.voidval = 0; }
+    { push_type (tp_reference); (yyval.voidval) = 0; }
     break;
 
   case 62:
 #line 582 "f-exp.y"
-    { push_type (tp_reference); yyval.voidval = yyvsp[0].voidval; }
+    { push_type (tp_reference); (yyval.voidval) = (yyvsp[(2) - (2)].voidval); }
     break;
 
   case 64:
 #line 587 "f-exp.y"
-    { yyval.voidval = yyvsp[-1].voidval; }
+    { (yyval.voidval) = (yyvsp[(2) - (3)].voidval); }
     break;
 
   case 65:
@@ -1759,110 +2092,109 @@
 
   case 67:
 #line 595 "f-exp.y"
-    { yyval.voidval = 0; }
+    { (yyval.voidval) = 0; }
     break;
 
   case 68:
 #line 597 "f-exp.y"
-    { free (yyvsp[-1].tvec); yyval.voidval = 0; }
+    { free ((yyvsp[(2) - (3)].tvec)); (yyval.voidval) = 0; }
     break;
 
   case 69:
 #line 602 "f-exp.y"
-    { yyval.tval = yyvsp[0].tsym.type; }
+    { (yyval.tval) = (yyvsp[(1) - (1)].tsym).type; }
     break;
 
   case 70:
 #line 604 "f-exp.y"
-    { yyval.tval = builtin_type_f_integer; }
+    { (yyval.tval) = builtin_type_f_integer; }
     break;
 
   case 71:
 #line 606 "f-exp.y"
-    { yyval.tval = builtin_type_f_integer_s2; }
+    { (yyval.tval) = builtin_type_f_integer_s2; }
     break;
 
   case 72:
 #line 608 "f-exp.y"
-    { yyval.tval = builtin_type_f_character; }
+    { (yyval.tval) = builtin_type_f_character; }
     break;
 
   case 73:
 #line 610 "f-exp.y"
-    { yyval.tval = builtin_type_f_logical;}
+    { (yyval.tval) = builtin_type_f_logical;}
     break;
 
   case 74:
 #line 612 "f-exp.y"
-    { yyval.tval = builtin_type_f_logical_s2;}
+    { (yyval.tval) = builtin_type_f_logical_s2;}
     break;
 
   case 75:
 #line 614 "f-exp.y"
-    { yyval.tval = builtin_type_f_logical_s1;}
+    { (yyval.tval) = builtin_type_f_logical_s1;}
     break;
 
   case 76:
 #line 616 "f-exp.y"
-    { yyval.tval = builtin_type_f_real;}
+    { (yyval.tval) = builtin_type_f_real;}
     break;
 
   case 77:
 #line 618 "f-exp.y"
-    { yyval.tval = builtin_type_f_real_s8;}
+    { (yyval.tval) = builtin_type_f_real_s8;}
     break;
 
   case 78:
 #line 620 "f-exp.y"
-    { yyval.tval = builtin_type_f_real_s16;}
+    { (yyval.tval) = builtin_type_f_real_s16;}
     break;
 
   case 79:
 #line 622 "f-exp.y"
-    { yyval.tval = builtin_type_f_complex_s8;}
+    { (yyval.tval) = builtin_type_f_complex_s8;}
     break;
 
   case 80:
 #line 624 "f-exp.y"
-    { yyval.tval = builtin_type_f_complex_s16;}
+    { (yyval.tval) = builtin_type_f_complex_s16;}
     break;
 
   case 81:
 #line 626 "f-exp.y"
-    { yyval.tval = builtin_type_f_complex_s32;}
+    { (yyval.tval) = builtin_type_f_complex_s32;}
     break;
 
   case 82:
 #line 631 "f-exp.y"
-    { yyval.tvec = (struct type **) xmalloc (sizeof (struct type *) * 2);
-		  yyval.ivec[0] = 1;	/* Number of types in vector */
-		  yyval.tvec[1] = yyvsp[0].tval;
+    { (yyval.tvec) = (struct type **) xmalloc (sizeof (struct type *) * 2);
+		  (yyval.ivec)[0] = 1;	/* Number of types in vector */
+		  (yyval.tvec)[1] = (yyvsp[(1) - (1)].tval);
 		}
     break;
 
   case 83:
 #line 636 "f-exp.y"
-    { int len = sizeof (struct type *) * (++(yyvsp[-2].ivec[0]) + 1);
-		  yyval.tvec = (struct type **) xrealloc ((char *) yyvsp[-2].tvec, len);
-		  yyval.tvec[yyval.ivec[0]] = yyvsp[0].tval;
+    { int len = sizeof (struct type *) * (++((yyvsp[(1) - (3)].ivec)[0]) + 1);
+		  (yyval.tvec) = (struct type **) xrealloc ((char *) (yyvsp[(1) - (3)].tvec), len);
+		  (yyval.tvec)[(yyval.ivec)[0]] = (yyvsp[(3) - (3)].tval);
 		}
     break;
 
   case 84:
 #line 643 "f-exp.y"
-    {  yyval.sval = yyvsp[0].ssym.stoken; }
+    {  (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2193 "f-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 1861 "f-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -1891,99 +2223,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -1993,15 +2291,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2030,9 +2330,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2040,11 +2341,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2064,21 +2366,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -2652,4 +2972,3 @@
   error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
 }
 
-
diff -Naur gdb-6.8/gdb/frame.c stsgdb-6.8/gdb/frame.c
--- gdb-6.8/gdb/frame.c	2008-03-04 20:05:27.000000000 +0000
+++ stsgdb-6.8/gdb/frame.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001,
    2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -397,9 +398,10 @@
 {
   struct frame_info *frame;
 
-  /* ZERO denotes the null frame, let the caller decide what to do
-     about it.  Should it instead return get_current_frame()?  */
-  if (!frame_id_p (id))
+  /* When target has no stack, null frame id most
+     likely means no frame at all.  Return NULL,
+     and let the caller decide what to do.  */
+  if (!target_has_stack && !frame_id_p (id))
     return NULL;
 
   for (frame = get_current_frame ();
@@ -407,6 +409,14 @@
        frame = get_prev_frame (frame))
     {
       struct frame_id this = get_frame_id (frame);
+#if 1
+      /* We use an invalid frame id to mean "could not unwind from
+	 here"!  This hack fixes the "value being assigned to is
+	 no longer active" problem.  This strongly suggests that
+	 we need to change the representation.  */
+      if (!frame_id_p (id) && !frame_id_p (this))
+	return frame;
+#endif
       if (frame_id_eq (id, this))
 	/* An exact match.  */
 	return frame;
@@ -1771,8 +1781,8 @@
 
 extern initialize_file_ftype _initialize_frame; /* -Wmissing-prototypes */
 
-static struct cmd_list_element *set_backtrace_cmdlist;
-static struct cmd_list_element *show_backtrace_cmdlist;
+struct cmd_list_element *set_backtrace_cmdlist;
+struct cmd_list_element *show_backtrace_cmdlist;
 
 static void
 set_backtrace_cmd (char *args, int from_tty)
diff -Naur gdb-6.8/gdb/frame.h stsgdb-6.8/gdb/frame.h
--- gdb-6.8/gdb/frame.h	2008-01-01 22:53:09.000000000 +0000
+++ stsgdb-6.8/gdb/frame.h	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997,
    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -721,4 +722,9 @@
 extern void deprecated_update_frame_base_hack (struct frame_info *frame,
 					       CORE_ADDR base);
 
+/* Export 'set backtrace' so that new subcommands may be added elsewhere. */
+
+extern struct cmd_list_element *set_backtrace_cmdlist;
+extern struct cmd_list_element *show_backtrace_cmdlist;
+
 #endif /* !defined (FRAME_H)  */
diff -Naur gdb-6.8/gdb/infcall.c stsgdb-6.8/gdb/infcall.c
--- gdb-6.8/gdb/infcall.c	2008-01-08 19:28:08.000000000 +0000
+++ stsgdb-6.8/gdb/infcall.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -194,7 +195,7 @@
   struct type *ftype = check_typedef (value_type (function));
   enum type_code code = TYPE_CODE (ftype);
   struct type *value_type;
-  CORE_ADDR funaddr;
+  CORE_ADDR funaddr = 0;
 
   /* If it's a member function, just look at the function
      part of it.  */
diff -Naur gdb-6.8/gdb/inflow.c stsgdb-6.8/gdb/inflow.c
--- gdb-6.8/gdb/inflow.c	2008-01-01 22:53:11.000000000 +0000
+++ stsgdb-6.8/gdb/inflow.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -108,6 +109,10 @@
 int
 gdb_has_a_terminal (void)
 {
+#ifdef __MINGW32__
+  return 1;
+#endif
+
   switch (gdb_has_a_terminal_flag)
     {
     case yes:
diff -Naur gdb-6.8/gdb/infrun.c stsgdb-6.8/gdb/infrun.c
--- gdb-6.8/gdb/infrun.c	2008-01-29 22:47:19.000000000 +0000
+++ stsgdb-6.8/gdb/infrun.c	2008-09-11 10:35:35.000000000 +0100
@@ -4,6 +4,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -699,6 +700,16 @@
       return 0;
     }
 
+  /* Switch to WAIT_PID if target unable to control threads.  */
+  if (!ptid_equal (wait_ptid, minus_one_ptid)
+      && !ptid_equal (inferior_ptid, wait_ptid)
+      && !target_can_lock_scheduler)
+    {
+      printf_filtered (_("[Switching to %s]\n"),
+		       target_pid_to_str (wait_ptid));
+      switch_to_thread (wait_ptid);
+    }
+
   /* Switched over from WAIT_PID.  */
   if (!ptid_equal (wait_ptid, minus_one_ptid)
       && !ptid_equal (inferior_ptid, wait_ptid)
@@ -3202,7 +3213,10 @@
          bpstat_print() contains the logic deciding in detail
          what to print, based on the event(s) that just occurred. */
 
-      if (stop_print_frame)
+      /* If --batch-silent is enabled then there's no need to print the current
+	 source location, and to try risks causing an error message about
+	 missing source files.  */
+      if (stop_print_frame && !batch_silent)
 	{
 	  int bpstat_ret;
 	  int source_flag;
diff -Naur gdb-6.8/gdb/jv-exp.c stsgdb-6.8/gdb/jv-exp.c
--- gdb-6.8/gdb/jv-exp.c	2008-03-27 18:27:13.000000000 +0000
+++ stsgdb-6.8/gdb/jv-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -85,6 +98,7 @@
      INCREMENT = 287
    };
 #endif
+/* Tokens.  */
 #define INTEGER_LITERAL 258
 #define FLOATING_POINT_LITERAL 259
 #define IDENTIFIER 260
@@ -218,9 +232,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 128 "jv-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     struct {
       LONGEST val;
@@ -239,9 +259,10 @@
     enum exp_opcode opcode;
     struct internalvar *ivar;
     int *ivec;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 245 "jv-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 265 "jv-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -256,56 +277,170 @@
 static int parse_number (char *, int, int, YYSTYPE *);
 
 
-/* Line 214 of yacc.c.  */
-#line 261 "jv-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 282 "jv-exp.c.tmp"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -315,24 +450,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -350,39 +485,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  98
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   373
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  56
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  58
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  132
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  209
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   287
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -418,7 +547,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,     9,    11,    13,    15,    17,
       19,    21,    23,    25,    27,    29,    31,    33,    35,    37,
@@ -436,8 +565,8 @@
      375,   377,   379
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       57,     0,    -1,    73,    -1,    58,    -1,    59,    -1,    62,
       -1,    68,    -1,     6,    -1,     3,    -1,     9,    -1,     4,
@@ -481,7 +610,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   205,   205,   206,   209,   218,   219,   223,   232,   237,
      245,   250,   255,   266,   267,   272,   273,   277,   279,   281,
@@ -500,9 +629,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INTEGER_LITERAL",
@@ -536,7 +665,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -548,7 +677,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    56,    57,    57,    58,    59,    59,    60,    61,    61,
       61,    61,    61,    62,    62,    63,    63,    64,    64,    64,
@@ -567,7 +696,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
@@ -588,7 +717,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
        0,     8,    10,    28,     7,    11,     9,    20,    18,    17,
       19,    21,    14,    23,    22,    74,     0,     0,     0,     0,
@@ -613,8 +742,8 @@
        0,    57,    48,    91,    93,     0,   123,    68,    67
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,    27,    28,    29,    30,    31,    32,    33,    34,    35,
       79,    80,    36,    85,    38,    39,    82,    41,    42,    43,
@@ -627,7 +756,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -145
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      215,  -145,  -145,    -5,  -145,  -145,     1,  -145,  -145,  -145,
     -145,  -145,  -145,  -145,  -145,    -7,   -19,   279,    50,    50,
@@ -653,7 +782,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
     -145,  -145,  -145,  -145,  -145,  -145,    -3,  -145,  -145,  -145,
     -145,  -145,  -145,    11,  -145,   -64,     0,  -145,  -145,  -145,
@@ -668,7 +797,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -132
-static const short yytable[] =
+static const yytype_int16 yytable[] =
 {
       40,   180,   181,   100,   192,   156,    47,    73,   104,   189,
      136,    37,   138,  -129,    78,   -32,   150,  -129,   191,   -32,
@@ -710,7 +839,7 @@
        0,     0,    25,    26
 };
 
-static const short yycheck[] =
+static const yytype_int16 yycheck[] =
 {
        0,   132,   133,    32,   148,    23,     0,     0,    37,   143,
       74,     0,    76,    20,    17,    20,    47,    24,    49,    24,
@@ -754,7 +883,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     3,     4,     5,     6,     7,     9,    11,    12,    13,
       14,    15,    16,    17,    18,    19,    21,    22,    39,    40,
@@ -779,22 +908,6 @@
       80,    52,    49,    94,    97,    80,   109,    49,    49
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -820,30 +933,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -864,42 +1010,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -908,45 +1108,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -961,13 +1168,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -977,45 +1180,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -1025,70 +1230,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1096,13 +1423,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1111,10 +1438,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1127,14 +1454,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1145,13 +1476,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1162,18 +1499,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1182,9 +1519,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1208,8 +1545,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1222,18 +1558,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1244,21 +1580,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1289,19 +1625,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1316,7 +1650,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1336,22 +1670,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1390,7 +1723,7 @@
 #line 210 "jv-exp.y"
     {
 		  write_exp_elt_opcode(OP_TYPE);
-		  write_exp_elt_type(yyvsp[0].tval);
+		  write_exp_elt_type((yyvsp[(1) - (1)].tval));
 		  write_exp_elt_opcode(OP_TYPE);
 		}
     break;
@@ -1399,7 +1732,7 @@
 #line 224 "jv-exp.y"
     {
 		  write_exp_elt_opcode (OP_STRING);
-		  write_exp_string (yyvsp[0].sval);
+		  write_exp_string ((yyvsp[(1) - (1)].sval));
 		  write_exp_elt_opcode (OP_STRING);
 		}
     break;
@@ -1407,15 +1740,15 @@
   case 8:
 #line 233 "jv-exp.y"
     { write_exp_elt_opcode (OP_LONG);
-		  write_exp_elt_type (yyvsp[0].typed_val_int.type);
-		  write_exp_elt_longcst ((LONGEST)(yyvsp[0].typed_val_int.val));
+		  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_int).type);
+		  write_exp_elt_longcst ((LONGEST)((yyvsp[(1) - (1)].typed_val_int).val));
 		  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 9:
 #line 238 "jv-exp.y"
     { YYSTYPE val;
-		  parse_number (yyvsp[0].sval.ptr, yyvsp[0].sval.length, 0, &val);
+		  parse_number ((yyvsp[(1) - (1)].sval).ptr, (yyvsp[(1) - (1)].sval).length, 0, &val);
 		  write_exp_elt_opcode (OP_LONG);
 		  write_exp_elt_type (val.typed_val_int.type);
 		  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
@@ -1426,8 +1759,8 @@
   case 10:
 #line 246 "jv-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
-		  write_exp_elt_type (yyvsp[0].typed_val_float.type);
-		  write_exp_elt_dblcst (yyvsp[0].typed_val_float.dval);
+		  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_float).type);
+		  write_exp_elt_dblcst ((yyvsp[(1) - (1)].typed_val_float).dval);
 		  write_exp_elt_opcode (OP_DOUBLE); }
     break;
 
@@ -1435,77 +1768,77 @@
 #line 251 "jv-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 		  write_exp_elt_type (java_boolean_type);
-		  write_exp_elt_longcst ((LONGEST)yyvsp[0].lval);
+		  write_exp_elt_longcst ((LONGEST)(yyvsp[(1) - (1)].lval));
 		  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 14:
 #line 268 "jv-exp.y"
-    { yyval.tval = java_boolean_type; }
+    { (yyval.tval) = java_boolean_type; }
     break;
 
   case 17:
 #line 278 "jv-exp.y"
-    { yyval.tval = java_byte_type; }
+    { (yyval.tval) = java_byte_type; }
     break;
 
   case 18:
 #line 280 "jv-exp.y"
-    { yyval.tval = java_short_type; }
+    { (yyval.tval) = java_short_type; }
     break;
 
   case 19:
 #line 282 "jv-exp.y"
-    { yyval.tval = java_int_type; }
+    { (yyval.tval) = java_int_type; }
     break;
 
   case 20:
 #line 284 "jv-exp.y"
-    { yyval.tval = java_long_type; }
+    { (yyval.tval) = java_long_type; }
     break;
 
   case 21:
 #line 286 "jv-exp.y"
-    { yyval.tval = java_char_type; }
+    { (yyval.tval) = java_char_type; }
     break;
 
   case 22:
 #line 291 "jv-exp.y"
-    { yyval.tval = java_float_type; }
+    { (yyval.tval) = java_float_type; }
     break;
 
   case 23:
 #line 293 "jv-exp.y"
-    { yyval.tval = java_double_type; }
+    { (yyval.tval) = java_double_type; }
     break;
 
   case 24:
 #line 305 "jv-exp.y"
-    { yyval.tval = java_type_from_name (yyvsp[0].sval); }
+    { (yyval.tval) = java_type_from_name ((yyvsp[(1) - (1)].sval)); }
     break;
 
   case 26:
 #line 314 "jv-exp.y"
-    { yyval.tval = java_array_type (yyvsp[-1].tval, yyvsp[0].lval); }
+    { (yyval.tval) = java_array_type ((yyvsp[(1) - (2)].tval), (yyvsp[(2) - (2)].lval)); }
     break;
 
   case 27:
 #line 316 "jv-exp.y"
-    { yyval.tval = java_array_type (java_type_from_name (yyvsp[-1].sval), yyvsp[0].lval); }
+    { (yyval.tval) = java_array_type (java_type_from_name ((yyvsp[(1) - (2)].sval)), (yyvsp[(2) - (2)].lval)); }
     break;
 
   case 34:
 #line 336 "jv-exp.y"
-    { yyval.sval.length = yyvsp[-2].sval.length + yyvsp[0].sval.length + 1;
-		  if (yyvsp[-2].sval.ptr + yyvsp[-2].sval.length + 1 == yyvsp[0].sval.ptr
-		      && yyvsp[-2].sval.ptr[yyvsp[-2].sval.length] == '.')
-		    yyval.sval.ptr = yyvsp[-2].sval.ptr;  /* Optimization. */
+    { (yyval.sval).length = (yyvsp[(1) - (3)].sval).length + (yyvsp[(3) - (3)].sval).length + 1;
+		  if ((yyvsp[(1) - (3)].sval).ptr + (yyvsp[(1) - (3)].sval).length + 1 == (yyvsp[(3) - (3)].sval).ptr
+		      && (yyvsp[(1) - (3)].sval).ptr[(yyvsp[(1) - (3)].sval).length] == '.')
+		    (yyval.sval).ptr = (yyvsp[(1) - (3)].sval).ptr;  /* Optimization. */
 		  else
 		    {
-		      yyval.sval.ptr = (char *) xmalloc (yyval.sval.length + 1);
-		      make_cleanup (free, yyval.sval.ptr);
-		      sprintf (yyval.sval.ptr, "%.*s.%.*s",
-			       yyvsp[-2].sval.length, yyvsp[-2].sval.ptr, yyvsp[0].sval.length, yyvsp[0].sval.ptr);
+		      (yyval.sval).ptr = (char *) xmalloc ((yyval.sval).length + 1);
+		      make_cleanup (free, (yyval.sval).ptr);
+		      sprintf ((yyval.sval).ptr, "%.*s.%.*s",
+			       (yyvsp[(1) - (3)].sval).length, (yyvsp[(1) - (3)].sval).ptr, (yyvsp[(3) - (3)].sval).length, (yyvsp[(3) - (3)].sval).ptr);
 		} }
     break;
 
@@ -1518,7 +1851,7 @@
 #line 376 "jv-exp.y"
     { write_exp_elt_opcode (OP_ARRAY);
 		  write_exp_elt_longcst ((LONGEST) 0);
-		  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+		  write_exp_elt_longcst ((LONGEST) (yyvsp[(3) - (3)].lval));
 		  write_exp_elt_opcode (OP_ARRAY); }
     break;
 
@@ -1529,7 +1862,7 @@
 
   case 47:
 #line 389 "jv-exp.y"
-    { yyval.lval = end_arglist () - 1; }
+    { (yyval.lval) = end_arglist () - 1; }
     break;
 
   case 48:
@@ -1567,32 +1900,32 @@
 
   case 58:
 #line 431 "jv-exp.y"
-    { yyval.lval = 1; }
+    { (yyval.lval) = 1; }
     break;
 
   case 59:
 #line 433 "jv-exp.y"
-    { yyval.lval = yyvsp[-2].lval + 1; }
+    { (yyval.lval) = (yyvsp[(1) - (3)].lval) + 1; }
     break;
 
   case 61:
 #line 439 "jv-exp.y"
-    { yyval.lval = 0; }
+    { (yyval.lval) = 0; }
     break;
 
   case 62:
 #line 444 "jv-exp.y"
-    { push_fieldnames (yyvsp[0].sval); }
+    { push_fieldnames ((yyvsp[(3) - (3)].sval)); }
     break;
 
   case 63:
 #line 446 "jv-exp.y"
-    { push_fieldnames (yyvsp[0].sval); }
+    { push_fieldnames ((yyvsp[(3) - (3)].sval)); }
     break;
 
   case 64:
 #line 452 "jv-exp.y"
-    { push_expression_name (yyvsp[-1].sval); }
+    { push_expression_name ((yyvsp[(1) - (2)].sval)); }
     break;
 
   case 65:
@@ -1627,7 +1960,7 @@
 		     for our parsing kludges.  */
 		  struct expression *name_expr;
 
-		  push_expression_name (yyvsp[-3].sval);
+		  push_expression_name ((yyvsp[(1) - (4)].sval));
 		  name_expr = copy_exp (expout, expout_ptr);
 		  expout_ptr -= name_expr->nelts;
 		  insert_exp (expout_ptr-length_of_subexp (expout, expout_ptr),
@@ -1649,7 +1982,7 @@
 
   case 73:
 #line 495 "jv-exp.y"
-    { push_expression_name (yyvsp[0].sval); }
+    { push_expression_name ((yyvsp[(1) - (1)].sval)); }
     break;
 
   case 77:
@@ -1695,7 +2028,7 @@
   case 91:
 #line 544 "jv-exp.y"
     { write_exp_elt_opcode (UNOP_CAST);
-		  write_exp_elt_type (java_array_type (yyvsp[-3].tval, yyvsp[-2].lval));
+		  write_exp_elt_type (java_array_type ((yyvsp[(2) - (5)].tval), (yyvsp[(3) - (5)].lval)));
 		  write_exp_elt_opcode (UNOP_CAST); }
     break;
 
@@ -1726,7 +2059,7 @@
   case 93:
 #line 569 "jv-exp.y"
     { write_exp_elt_opcode (UNOP_CAST);
-		  write_exp_elt_type (java_array_type (java_type_from_name (yyvsp[-3].sval), yyvsp[-2].lval));
+		  write_exp_elt_type (java_array_type (java_type_from_name ((yyvsp[(2) - (5)].sval)), (yyvsp[(3) - (5)].lval)));
 		  write_exp_elt_opcode (UNOP_CAST); }
     break;
 
@@ -1833,25 +2166,24 @@
   case 127:
 #line 667 "jv-exp.y"
     { write_exp_elt_opcode (BINOP_ASSIGN_MODIFY);
-		  write_exp_elt_opcode (yyvsp[-1].opcode);
+		  write_exp_elt_opcode ((yyvsp[(2) - (3)].opcode));
 		  write_exp_elt_opcode (BINOP_ASSIGN_MODIFY); }
     break;
 
   case 128:
 #line 674 "jv-exp.y"
-    { push_expression_name (yyvsp[0].sval); }
+    { push_expression_name ((yyvsp[(1) - (1)].sval)); }
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2182 "jv-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 1850 "jv-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -1880,99 +2212,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -1982,15 +2280,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2019,9 +2319,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2029,11 +2330,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2053,21 +2355,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -2852,4 +3172,3 @@
   expout_ptr += newlen;
 }
 
-
diff -Naur gdb-6.8/gdb/m2-exp.c stsgdb-6.8/gdb/m2-exp.c
--- gdb-6.8/gdb/m2-exp.c	2008-03-27 18:27:13.000000000 +0000
+++ stsgdb-6.8/gdb/m2-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -102,6 +115,7 @@
      QID = 304
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define HEX 259
 #define ERROR 260
@@ -259,9 +273,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 137 "m2-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     ULONGEST ulval;
     DOUBLEST dval;
@@ -275,9 +295,10 @@
 
     struct type **tvec;
     int *ivec;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 281 "m2-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 301 "m2-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -288,56 +309,170 @@
 /* Copy the second part of user declarations.  */
 
 
-/* Line 214 of yacc.c.  */
-#line 293 "m2-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 314 "m2-exp.c.tmp"
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifdef short
+# undef short
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -347,24 +482,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -382,39 +517,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
-
-#endif
+    while (YYID (0))
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
 #endif
 
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  69
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   923
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  69
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  15
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  82
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  187
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   304
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -452,7 +581,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,     9,    12,    13,    17,    20,
       23,    25,    27,    32,    37,    42,    47,    52,    57,    62,
@@ -465,8 +594,8 @@
      296,   300,   302
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       70,     0,    -1,    72,    -1,    71,    -1,    83,    -1,    72,
       58,    -1,    -1,    52,    73,    72,    -1,    51,    72,    -1,
@@ -502,7 +631,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   206,   206,   207,   210,   219,   224,   223,   230,   234,
      238,   239,   242,   246,   250,   254,   258,   264,   270,   274,
@@ -516,9 +645,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "HEX", "ERROR", "UINT", "M2_TRUE",
@@ -538,7 +667,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -551,7 +680,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    69,    70,    70,    71,    72,    73,    72,    72,    72,
       74,    74,    72,    72,    72,    72,    72,    72,    72,    72,
@@ -565,7 +694,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     1,     2,     0,     3,     2,     2,
        1,     1,     4,     4,     4,     4,     4,     4,     4,     6,
@@ -581,7 +710,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
        0,    68,    69,    66,    67,    70,    71,    74,    81,    76,
       82,     0,     0,     0,     0,     0,     0,     0,     0,     0,
@@ -604,8 +733,8 @@
       40,    19,    26,    28,    32,    33,    45
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,    35,    36,    66,    64,    38,    39,   139,   140,    67,
      169,    40,    41,    42,    46
@@ -614,7 +743,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -89
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      163,   -89,   -89,   -89,   -89,   -89,   -89,   -89,   -89,   -89,
      -89,   224,   -54,   -35,   -30,   -20,   -19,   -14,     3,     9,
@@ -638,7 +767,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
+static const yytype_int8 yypgoto[] =
 {
      -89,   -89,   -89,     0,   -89,   -89,    34,   -89,   -89,   -88,
      -89,   -89,   -89,   -89,    54
@@ -649,7 +778,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -76
-static const short yytable[] =
+static const yytype_int16 yytable[] =
 {
       37,    10,   178,   115,   115,   115,    47,   145,   142,   143,
       79,    45,    80,    81,    82,    83,    84,    85,    86,    87,
@@ -746,7 +875,7 @@
       88,    89,    90,    91
 };
 
-static const short yycheck[] =
+static const yytype_int16 yycheck[] =
 {
        0,    16,    36,    36,    36,    36,    60,    95,    12,    13,
       47,    11,    49,    50,    51,    52,    53,    54,    55,    56,
@@ -845,7 +974,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     3,     6,     7,     8,     9,    10,    11,    12,    13,
       16,    17,    18,    19,    20,    21,    22,    23,    24,    25,
@@ -868,22 +997,6 @@
       65,    65,    65,    65,    65,    65,    72
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -909,30 +1022,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -953,42 +1099,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -997,45 +1197,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1050,13 +1257,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -1066,45 +1269,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -1114,70 +1319,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1185,13 +1512,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1200,10 +1527,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1216,14 +1543,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1234,13 +1565,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1251,18 +1588,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1271,9 +1608,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1297,8 +1634,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1311,18 +1647,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1333,21 +1669,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1378,19 +1714,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1405,7 +1739,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1425,22 +1759,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1478,7 +1811,7 @@
         case 4:
 #line 211 "m2-exp.y"
     { write_exp_elt_opcode(OP_TYPE);
-		  write_exp_elt_type(yyvsp[0].tval);
+		  write_exp_elt_type((yyvsp[(1) - (1)].tval));
 		  write_exp_elt_opcode(OP_TYPE);
 		}
     break;
@@ -1532,14 +1865,14 @@
   case 16:
 #line 259 "m2-exp.y"
     { write_exp_elt_opcode (UNOP_MIN);
-			  write_exp_elt_type (yyvsp[-1].tval);
+			  write_exp_elt_type ((yyvsp[(3) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_MIN); }
     break;
 
   case 17:
 #line 265 "m2-exp.y"
     { write_exp_elt_opcode (UNOP_MAX);
-			  write_exp_elt_type (yyvsp[-1].tval);
+			  write_exp_elt_type ((yyvsp[(3) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_MIN); }
     break;
 
@@ -1551,7 +1884,7 @@
   case 19:
 #line 275 "m2-exp.y"
     { write_exp_elt_opcode (BINOP_VAL);
-			  write_exp_elt_type (yyvsp[-3].tval);
+			  write_exp_elt_type ((yyvsp[(3) - (6)].tval));
 			  write_exp_elt_opcode (BINOP_VAL); }
     break;
 
@@ -1607,7 +1940,7 @@
   case 29:
 #line 322 "m2-exp.y"
     { write_exp_elt_opcode (STRUCTOP_STRUCT);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
     break;
 
@@ -1688,14 +2021,14 @@
   case 46:
 #line 398 "m2-exp.y"
     { write_exp_elt_opcode (UNOP_MEMVAL);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_MEMVAL); }
     break;
 
   case 47:
 #line 404 "m2-exp.y"
     { write_exp_elt_opcode (UNOP_CAST);
-			  write_exp_elt_type (yyvsp[-3].tval);
+			  write_exp_elt_type ((yyvsp[(1) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_CAST); }
     break;
 
@@ -1792,14 +2125,14 @@
   case 66:
 #line 487 "m2-exp.y"
     { write_exp_elt_opcode (OP_BOOL);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].ulval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].ulval));
 			  write_exp_elt_opcode (OP_BOOL); }
     break;
 
   case 67:
 #line 493 "m2-exp.y"
     { write_exp_elt_opcode (OP_BOOL);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].ulval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].ulval));
 			  write_exp_elt_opcode (OP_BOOL); }
     break;
 
@@ -1807,7 +2140,7 @@
 #line 499 "m2-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_m2_int);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].lval));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
@@ -1816,7 +2149,7 @@
     {
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_m2_card);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].ulval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].ulval));
 			  write_exp_elt_opcode (OP_LONG);
 			}
     break;
@@ -1825,7 +2158,7 @@
 #line 515 "m2-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_m2_char);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].ulval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].ulval));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
@@ -1833,7 +2166,7 @@
 #line 523 "m2-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
 			  write_exp_elt_type (builtin_type_m2_real);
-			  write_exp_elt_dblcst (yyvsp[0].dval);
+			  write_exp_elt_dblcst ((yyvsp[(1) - (1)].dval));
 			  write_exp_elt_opcode (OP_DOUBLE); }
     break;
 
@@ -1841,39 +2174,39 @@
 #line 533 "m2-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_int);
-			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yyvsp[-1].tval));
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ((yyvsp[(3) - (4)].tval)));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 74:
 #line 540 "m2-exp.y"
     { write_exp_elt_opcode (OP_M2_STRING);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(1) - (1)].sval));
 			  write_exp_elt_opcode (OP_M2_STRING); }
     break;
 
   case 75:
 #line 547 "m2-exp.y"
-    { yyval.bval = SYMBOL_BLOCK_VALUE(yyvsp[0].sym); }
+    { (yyval.bval) = SYMBOL_BLOCK_VALUE((yyvsp[(1) - (1)].sym)); }
     break;
 
   case 76:
 #line 551 "m2-exp.y"
     { struct symbol *sym
-			    = lookup_symbol (copy_name (yyvsp[0].sval), expression_context_block,
+			    = lookup_symbol (copy_name ((yyvsp[(1) - (1)].sval)), expression_context_block,
 					     VAR_DOMAIN, 0, NULL);
-			  yyval.sym = sym;}
+			  (yyval.sym) = sym;}
     break;
 
   case 77:
 #line 560 "m2-exp.y"
     { struct symbol *tem
-			    = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			    = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					     VAR_DOMAIN, 0, NULL);
 			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
 			    error ("No function \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
-			  yyval.sym = tem;
+				   copy_name ((yyvsp[(3) - (3)].sval)));
+			  (yyval.sym) = tem;
 			}
     break;
 
@@ -1881,18 +2214,18 @@
 #line 572 "m2-exp.y"
     { write_exp_elt_opcode(OP_VAR_VALUE);
 			  write_exp_elt_block (NULL);
-			  write_exp_elt_sym (yyvsp[0].sym);
+			  write_exp_elt_sym ((yyvsp[(1) - (1)].sym));
 			  write_exp_elt_opcode (OP_VAR_VALUE); }
     break;
 
   case 80:
 #line 584 "m2-exp.y"
     { struct symbol *sym;
-			  sym = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			  sym = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					       VAR_DOMAIN, 0, NULL);
 			  if (sym == 0)
 			    error ("No symbol \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
+				   copy_name ((yyvsp[(3) - (3)].sval)));
 
 			  write_exp_elt_opcode (OP_VAR_VALUE);
 			  /* block_found is set by lookup_symbol.  */
@@ -1906,7 +2239,7 @@
     { struct symbol *sym;
 			  int is_a_field_of_this;
 
- 			  sym = lookup_symbol (copy_name (yyvsp[0].sval),
+ 			  sym = lookup_symbol (copy_name ((yyvsp[(1) - (1)].sval)),
 					       expression_context_block,
 					       VAR_DOMAIN,
 					       &is_a_field_of_this,
@@ -1932,7 +2265,7 @@
 			  else
 			    {
 			      struct minimal_symbol *msymbol;
-			      char *arg = copy_name (yyvsp[0].sval);
+			      char *arg = copy_name ((yyvsp[(1) - (1)].sval));
 
 			      msymbol =
 				lookup_minimal_symbol (arg, NULL, NULL);
@@ -1947,27 +2280,26 @@
 				error ("No symbol table is loaded.  Use the \"symbol-file\" command.");
 			      else
 				error ("No symbol \"%s\" in current context.",
-				       copy_name (yyvsp[0].sval));
+				       copy_name ((yyvsp[(1) - (1)].sval)));
 			    }
 			}
     break;
 
   case 82:
 #line 651 "m2-exp.y"
-    { yyval.tval = lookup_typename (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_typename (copy_name ((yyvsp[(1) - (1)].sval)),
 						expression_context_block, 0); }
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2298 "m2-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 1966 "m2-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -1996,99 +2328,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2098,15 +2396,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2135,9 +2435,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2145,11 +2446,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2169,21 +2471,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -2653,4 +2973,3 @@
   error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
 }
 
-
diff -Naur gdb-6.8/gdb/main.c stsgdb-6.8/gdb/main.c
--- gdb-6.8/gdb/main.c	2008-01-05 16:49:53.000000000 +0000
+++ stsgdb-6.8/gdb/main.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
    This file is part of GDB.
 
@@ -119,6 +120,7 @@
   struct captured_main_args *context = data;
   int argc = context->argc;
   char **argv = context->argv;
+  int count;
   static int quiet = 0;
   static int batch = 0;
   static int set_args = 0;
@@ -366,6 +368,8 @@
 	if (c == 0 && long_options[option_index].flag == 0)
 	  c = long_options[option_index].val;
 
+	CYGPATH (optarg);
+
 	switch (c)
 	  {
 	  case 0:
@@ -547,6 +551,9 @@
 	use_windows = 0;
       }
 
+    for (count = optind; count < argc; count++)
+      CYGPATH (argv[count]);
+
     if (set_args)
       {
 	/* The remaining options are the command-line options for the
diff -Naur gdb-6.8/gdb/main.h stsgdb-6.8/gdb/main.h
--- gdb-6.8/gdb/main.h	2008-01-01 22:53:12.000000000 +0000
+++ stsgdb-6.8/gdb/main.h	2008-09-11 10:35:35.000000000 +0100
@@ -1,6 +1,7 @@
 /* Main interface for GDB, the GNU debugger.
 
    Copyright (C) 2002, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -33,5 +34,6 @@
 /* From main.c.  */
 extern int return_child_result;
 extern int return_child_result_value;
+extern int batch_silent;
 
 #endif
diff -Naur gdb-6.8/gdb/Makefile.in stsgdb-6.8/gdb/Makefile.in
--- gdb-6.8/gdb/Makefile.in	2008-03-17 12:15:08.000000000 +0000
+++ stsgdb-6.8/gdb/Makefile.in	2008-09-11 10:35:35.000000000 +0100
@@ -1,6 +1,7 @@
 # Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
 # 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 # Free Software Foundation, Inc.
+# Copyright (c) 2007 STMicroelectronics
 
 # This file is part of GDB.
 
@@ -147,6 +148,7 @@
 GDB_WERROR_CFLAGS = $(WERROR_CFLAGS)
 
 GDB_WARN_CFLAGS_NO_FORMAT = `echo " $(GDB_WARN_CFLAGS) " | sed "s/ -Wformat-nonliteral / /g"`
+GDB_WARN_CFLAGS_DISABLE_FORMAT = `echo " $(GDB_WARN_CFLAGS) " | sed "s/\(.* -Wall .*\)/\1-Wno-format /g"`
 
 # Where is the INTL library?  Typically in ../intl.
 INTL = @LIBINTL@
@@ -265,27 +267,28 @@
 SIM = @SIM@
 
 WIN32LIBS = @WIN32LIBS@
+WIN32RES_OBS= @WIN32RES_OBS@
 
 # Where is the TCL library?  Typically in ../tcl.
 LIB_INSTALL_DIR = $(libdir)
 # This variable is needed when doing dynamic linking.
 LIB_RUNTIME_DIR = $(libdir)
 TCL = @TCL_CC_SEARCH_FLAGS@ @TCL_BUILD_LIB_SPEC@
-TCL_CFLAGS = @TCLHDIR@
+TCL_CFLAGS = @TCLHDIR@ @TCL_DEFS@
 GDBTKLIBS = @GDBTKLIBS@
 # Extra flags that the GDBTK files need:
 GDBTK_CFLAGS = @GDBTK_CFLAGS@
 
 # Where is the TK library?  Typically in ../tk.
 TK = @TK_BUILD_LIB_SPEC@
-TK_CFLAGS = @TKHDIR@ @TK_BUILD_INCLUDES@
+TK_CFLAGS = @TKHDIR@ @TK_BUILD_INCLUDES@ @TK_DEFS@
 
 # Where is Itcl?  Typically in ../itcl/itcl.
-ITCL_CFLAGS = @ITCLHDIR@
+ITCL_CFLAGS = @ITCLHDIR@ @ITCL_DEFS@
 ITCL = @ITCLLIB@
 
 # Where is Itk?  Typically in ../itcl/itk.
-ITK_CFLAGS = @ITKHDIR@
+ITK_CFLAGS = @ITKHDIR@ @ITK_DEFS@
 ITK = @ITKLIB@
 
 X11_CFLAGS = @TK_XINCLUDES@
@@ -298,6 +301,10 @@
 GUI_CFLAGS_X = @GUI_CFLAGS_X@
 IDE_CFLAGS=$(GUI_CFLAGS_X) $(IDE_CFLAGS_X)
 
+# PDCURSES library is used for mingw host
+LIB_PDCURSES = @LIB_PDCURSES@
+PDCURSES_CFLAGS = @PDCURSES_CFLAGS@
+
 # The version of gdbtk we're building. This should be kept
 # in sync with GDBTK_VERSION and friends in gdbtk.h.
 GDBTK_VERSION = 1.0
@@ -364,7 +371,8 @@
 	$(CFLAGS) $(GLOBAL_CFLAGS) $(PROFILE_CFLAGS) \
 	$(GDB_CFLAGS) $(OPCODES_CFLAGS) $(READLINE_CFLAGS) \
 	$(BFD_CFLAGS) $(INCLUDE_CFLAGS) $(LIBDECNUMBER_CFLAGS) \
-	$(INTL_CFLAGS) $(ENABLE_CFLAGS) $(INTERNAL_CPPFLAGS)
+	$(INTL_CFLAGS) $(ENABLE_CFLAGS) $(INTERNAL_CPPFLAGS) \
+	$(PDCURSES_CFLAGS)
 INTERNAL_WARN_CFLAGS = $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS)
 INTERNAL_CFLAGS = $(INTERNAL_WARN_CFLAGS) $(GDB_WERROR_CFLAGS)
 
@@ -392,9 +400,9 @@
 CLIBS = $(SIM) $(READLINE) $(OPCODES) $(BFD) $(INTL) $(LIBIBERTY) $(LIBDECNUMBER) \
 	$(XM_CLIBS) $(TM_CLIBS) $(NAT_CLIBS) $(GDBTKLIBS) @LIBS@ \
 	$(LIBICONV) $(LIBEXPAT) \
-	$(LIBIBERTY) $(WIN32LIBS)
+	$(LIBIBERTY) $(WIN32LIBS) $(LIB_PDCURSES)
 CDEPS = $(XM_CDEPS) $(TM_CDEPS) $(NAT_CDEPS) $(SIM) $(BFD) $(READLINE_DEPS) \
-	$(OPCODES) $(INTL_DEPS) $(LIBIBERTY) $(CONFIG_DEPS)
+	$(OPCODES) $(INTL_DEPS) $(LIBIBERTY) $(CONFIG_DEPS) $(LIB_PDCURSES)
 
 ADD_FILES = $(XM_ADD_FILES) $(TM_ADD_FILES) $(NAT_ADD_FILES)
 ADD_DEPS = $(XM_ADD_FILES) $(TM_ADD_FILES) $(NAT_ADD_FILES)
@@ -1317,16 +1325,17 @@
 init.o: init.c $(defs_h) $(call_cmds_h)
 
 # Removing the old gdb first works better if it is running, at least on SunOS.
-gdb$(EXEEXT): gdb.o libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
+gdb$(EXEEXT): gdb.o $(WIN32RES_OBS) libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
 	rm -f gdb$(EXEEXT)
 	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
-		-o gdb$(EXEEXT) gdb.o libgdb.a \
+		-o gdb$(EXEEXT) gdb.o $(WIN32RES_OBS) libgdb.a \
 		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
 
-$(TUI)$(EXEEXT): tui-main.o libgdb.a $(ADD_DEPS) $(CDEPS) $(TDEPLIBS)
+$(TUI)$(EXEEXT): tui-main.o $(WIN32RES_OBS) libgdb.a $(ADD_DEPS) $(CDEPS) \
+		$(TDEPLIBS)
 	rm -f $(TUI)$(EXEEXT)
 	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
-		-o $(TUI)$(EXEEXT) tui-main.o libgdb.a \
+		-o $(TUI)$(EXEEXT) tui-main.o $(WIN32RES_OBS) libgdb.a \
 		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
 
 # Create a library of the gdb object files and build GDB by linking
@@ -1485,7 +1494,7 @@
 version.c: Makefile version.in
 	rm -f version.c-tmp version.c
 	echo '#include "version.h"' >> version.c-tmp
-	echo 'const char version[] = "'"`sed q ${srcdir}/version.in`"'";' >> version.c-tmp
+	echo 'const char version[] = "'"`sed q ${srcdir}/version.in`" [build '"__DATE__"]";' >> version.c-tmp
 	echo 'const char host_name[] = "$(host_alias)";' >> version.c-tmp
 	echo 'const char target_name[] = "$(target_alias)";' >> version.c-tmp
 	mv version.c-tmp version.c
@@ -1637,6 +1646,10 @@
 	$(CC) -c $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS_NO_FORMAT) \
 	   $(GDB_WERROR_CFLAGS) $(srcdir)/printcmd.c
 
+tracepoint.o: $(srcdir)/tracepoint.c
+	$(CC) -c $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS_DISABLE_FORMAT) \
+	   $(GDB_WERROR_CFLAGS) $(srcdir)/tracepoint.c
+
 # FIXME: Procfs.o gets -Wformat errors because things like pid_t don't
 # match output format strings.
 procfs.o: $(srcdir)/procfs.c
@@ -2084,7 +2097,7 @@
 event-top.o: event-top.c $(defs_h) $(top_h) $(inferior_h) $(target_h) \
 	$(terminal_h) $(event_loop_h) $(event_top_h) $(interps_h) \
 	$(exceptions_h) $(cli_script_h) $(gdbcmd_h) $(readline_h) \
-	$(readline_history_h)
+	$(readline_history_h) $(main_h)
 exceptions.o: exceptions.c $(defs_h) $(exceptions_h) $(breakpoint_h) \
 	$(target_h) $(inferior_h) $(annotate_h) $(ui_out_h) $(gdb_assert_h) \
 	$(gdb_string_h) $(serial_h)
@@ -2709,7 +2722,10 @@
 	$(value_h) $(dis_asm_h) $(inferior_h) $(gdb_string_h) \
 	$(gdb_assert_h) $(arch_utils_h) $(floatformat_h) $(regcache_h) \
 	$(doublest_h) $(osabi_h) $(sh_tdep_h) $(elf_bfd_h) $(solib_svr4_h) \
-	$(elf_sh_h) $(gdb_sim_sh_h) $(reggroups_h)
+	$(elf_sh_h) $(gdb_sim_sh_h) $(reggroups_h) $(sim_regno_h)
+shtdi.o: shtdi.c $(defs_h) $(gdbcore_h) $(regcache_h) $(gdbcmd_h) \
+	$(gdbthread_h) $(inferior_h) $(objfiles_h) $(observer_h) \
+	$(exceptions_h) $(cli_cmds_h) $(solib_h)
 sol2-tdep.o: sol2-tdep.c $(defs_h) $(frame_h) $(symtab_h) $(sol2_tdep_h)
 solib.o: solib.c $(defs_h) $(gdb_string_h) $(symtab_h) $(bfd_h) $(symfile_h) \
 	$(objfiles_h) $(exceptions_h) $(gdbcore_h) $(command_h) $(target_h) \
@@ -3085,15 +3101,15 @@
 	rm -f insight$(EXEEXT)
 
 # Removing the old gdb first works better if it is running, at least on SunOS.
-insight$(EXEEXT): gdbtk-main.o libgdb.a $(ADD_DEPS) \
+insight$(EXEEXT): gdbtk-main.o $(WIN32RES_OBS) libgdb.a $(ADD_DEPS) \
 		$(CDEPS) $(TDEPLIBS)
 	rm -f insight$(EXEEXT)
 	$(CC_LD) $(INTERNAL_LDFLAGS) $(WIN32LDAPP) \
-		-o insight$(EXEEXT) gdbtk-main.o libgdb.a \
+		-o insight$(EXEEXT) gdbtk-main.o $(WIN32RES_OBS) libgdb.a \
 		$(TDEPLIBS) $(TUI_LIBRARY) $(CLIBS) $(LOADLIBES)
 
 gdbres.o: $(srcdir)/gdbtk/gdb.rc $(srcdir)/gdbtk/gdbtool.ico
-	$(WINDRES) --include $(srcdir)/gdbtk $(srcdir)/gdbtk/gdb.rc gdbres.o
+	$(WINDRES) @GDBRESOPTS@ --include $(srcdir)/gdbtk $(srcdir)/gdbtk/gdb.rc gdbres.o
 
 gdbtk.o: $(srcdir)/gdbtk/generic/gdbtk.c \
 	$(srcdir)/gdbtk/generic/gdbtk.h $(defs_h) \
diff -Naur gdb-6.8/gdb/objc-exp.c stsgdb-6.8/gdb/objc-exp.c
--- gdb-6.8/gdb/objc-exp.c	2008-03-27 18:27:12.000000000 +0000
+++ stsgdb-6.8/gdb/objc-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -96,6 +109,7 @@
      BLOCKNAME = 298
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define FLOAT 259
 #define STRING 260
@@ -240,9 +254,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 126 "objc-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     struct {
       LONGEST val;
@@ -265,9 +285,10 @@
 
     struct type **tvec;
     int *ivec;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 271 "objc-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 291 "objc-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -283,56 +304,170 @@
 parse_number (char *, int, int, YYSTYPE *);
 
 
-/* Line 214 of yacc.c.  */
-#line 288 "objc-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 309 "objc-exp.c.tmp"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -342,24 +477,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -377,39 +512,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  89
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   793
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  68
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  29
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  146
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  236
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   298
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -446,7 +575,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,     9,    11,    15,    18,    21,
       24,    27,    30,    33,    36,    39,    42,    45,    49,    53,
@@ -465,8 +594,8 @@
      443,   445,   447,   449,   451,   453,   455
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       69,     0,    -1,    71,    -1,    70,    -1,    91,    -1,    72,
       -1,    71,    30,    72,    -1,    50,    72,    -1,    38,    72,
@@ -517,7 +646,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   231,   231,   232,   235,   242,   243,   248,   252,   256,
      260,   264,   268,   272,   276,   280,   284,   288,   294,   301,
@@ -537,9 +666,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "FLOAT", "STRING", "NSSTRING",
@@ -562,7 +691,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -575,7 +704,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    68,    69,    69,    70,    71,    71,    72,    72,    72,
       72,    72,    72,    72,    72,    72,    72,    72,    72,    72,
@@ -595,7 +724,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     1,     1,     3,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     3,     3,     4,
@@ -617,7 +746,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
        0,    70,    72,    77,    78,    75,   145,   108,   109,    71,
        0,     0,     0,     0,     0,   128,     0,     0,   130,   111,
@@ -645,8 +774,8 @@
       27,    29,    67,    38,   139,    34
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,    37,    38,    85,    40,   140,   141,   142,   204,   205,
      206,   174,    41,   120,   180,    42,    43,    44,    45,   130,
@@ -656,7 +785,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -86
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      220,   -86,   -86,   -86,   -86,   -86,   -86,   -86,   -86,   -86,
       19,    19,    19,    19,   284,    28,    19,    19,   118,    16,
@@ -685,7 +814,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
      -86,   -86,   -86,     3,   -10,   -86,   -86,   -86,   -85,   -86,
      -51,   -86,   -86,   -11,    37,   -86,   -86,   -79,   -86,     6,
@@ -697,7 +826,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -110
-static const short yytable[] =
+static const yytype_int16 yytable[] =
 {
       47,    46,   189,    39,    59,    54,    55,    56,    57,   178,
       90,    66,    67,   221,   178,    74,    77,    78,    79,    80,
@@ -781,7 +910,7 @@
      115,   116,   117,   118
 };
 
-static const short yycheck[] =
+static const yytype_int16 yycheck[] =
 {
        0,     0,     3,     0,    14,    10,    11,    12,    13,    30,
       30,    16,    17,    30,    30,    24,    26,    27,    28,    29,
@@ -867,7 +996,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     3,     4,     5,     6,     7,     8,     9,    10,    11,
       12,    13,    14,    15,    16,    17,    18,    19,    21,    22,
@@ -895,22 +1024,6 @@
       63,    63,    72,    65,    91,    72
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -936,30 +1049,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -980,42 +1126,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -1024,45 +1224,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1077,13 +1284,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -1093,45 +1296,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -1141,70 +1346,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1212,13 +1539,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1227,10 +1554,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1243,14 +1570,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1261,13 +1592,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1278,18 +1615,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1298,9 +1635,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1324,8 +1661,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1338,18 +1674,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1360,21 +1696,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1405,19 +1741,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1432,7 +1766,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1452,22 +1786,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1505,7 +1838,7 @@
         case 4:
 #line 236 "objc-exp.y"
     { write_exp_elt_opcode(OP_TYPE);
-			  write_exp_elt_type(yyvsp[0].tval);
+			  write_exp_elt_type((yyvsp[(1) - (1)].tval));
 			  write_exp_elt_opcode(OP_TYPE);}
     break;
 
@@ -1567,7 +1900,7 @@
   case 17:
 #line 289 "objc-exp.y"
     { write_exp_elt_opcode (STRUCTOP_PTR);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (STRUCTOP_PTR); }
     break;
 
@@ -1588,7 +1921,7 @@
   case 20:
 #line 306 "objc-exp.y"
     { write_exp_elt_opcode (STRUCTOP_STRUCT);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (STRUCTOP_STRUCT); }
     break;
 
@@ -1616,10 +1949,10 @@
     {
 			  CORE_ADDR class;
 
-			  class = lookup_objc_class (copy_name (yyvsp[0].tsym.stoken));
+			  class = lookup_objc_class (copy_name ((yyvsp[(2) - (2)].tsym).stoken));
 			  if (class == 0)
 			    error ("%s is not an ObjC Class", 
-				   copy_name (yyvsp[0].tsym.stoken));
+				   copy_name ((yyvsp[(2) - (2)].tsym).stoken));
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_int);
 			  write_exp_elt_longcst ((LONGEST) class);
@@ -1641,7 +1974,7 @@
     {
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_int);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].class.class);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(2) - (2)].class).class);
 			  write_exp_elt_opcode (OP_LONG);
 			  start_msglist();
 			}
@@ -1670,12 +2003,12 @@
 
   case 30:
 #line 378 "objc-exp.y"
-    { add_msglist(&yyvsp[0].sval, 0); }
+    { add_msglist(&(yyvsp[(1) - (1)].sval), 0); }
     break;
 
   case 34:
 #line 387 "objc-exp.y"
-    { add_msglist(&yyvsp[-2].sval, 1); }
+    { add_msglist(&(yyvsp[(1) - (3)].sval), 1); }
     break;
 
   case 35:
@@ -1717,28 +2050,28 @@
 
   case 43:
 #line 420 "objc-exp.y"
-    { yyval.lval = end_arglist () - 1; }
+    { (yyval.lval) = end_arglist () - 1; }
     break;
 
   case 44:
 #line 423 "objc-exp.y"
     { write_exp_elt_opcode (OP_ARRAY);
 			  write_exp_elt_longcst ((LONGEST) 0);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(3) - (3)].lval));
 			  write_exp_elt_opcode (OP_ARRAY); }
     break;
 
   case 45:
 #line 430 "objc-exp.y"
     { write_exp_elt_opcode (UNOP_MEMVAL);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_MEMVAL); }
     break;
 
   case 46:
 #line 436 "objc-exp.y"
     { write_exp_elt_opcode (UNOP_CAST);
-			  write_exp_elt_type (yyvsp[-2].tval);
+			  write_exp_elt_type ((yyvsp[(2) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_CAST); }
     break;
 
@@ -1855,22 +2188,22 @@
   case 69:
 #line 532 "objc-exp.y"
     { write_exp_elt_opcode (BINOP_ASSIGN_MODIFY);
-			  write_exp_elt_opcode (yyvsp[-1].opcode);
+			  write_exp_elt_opcode ((yyvsp[(2) - (3)].opcode));
 			  write_exp_elt_opcode (BINOP_ASSIGN_MODIFY); }
     break;
 
   case 70:
 #line 538 "objc-exp.y"
     { write_exp_elt_opcode (OP_LONG);
-			  write_exp_elt_type (yyvsp[0].typed_val_int.type);
-			  write_exp_elt_longcst ((LONGEST)(yyvsp[0].typed_val_int.val));
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_int).type);
+			  write_exp_elt_longcst ((LONGEST)((yyvsp[(1) - (1)].typed_val_int).val));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 71:
 #line 545 "objc-exp.y"
     { YYSTYPE val;
-			  parse_number (yyvsp[0].ssym.stoken.ptr, yyvsp[0].ssym.stoken.length, 0, &val);
+			  parse_number ((yyvsp[(1) - (1)].ssym).stoken.ptr, (yyvsp[(1) - (1)].ssym).stoken.length, 0, &val);
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (val.typed_val_int.type);
 			  write_exp_elt_longcst ((LONGEST)val.typed_val_int.val);
@@ -1881,8 +2214,8 @@
   case 72:
 #line 556 "objc-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
-			  write_exp_elt_type (yyvsp[0].typed_val_float.type);
-			  write_exp_elt_dblcst (yyvsp[0].typed_val_float.dval);
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_float).type);
+			  write_exp_elt_dblcst ((yyvsp[(1) - (1)].typed_val_float).dval);
 			  write_exp_elt_opcode (OP_DOUBLE); }
     break;
 
@@ -1890,7 +2223,7 @@
 #line 570 "objc-exp.y"
     {
 			  write_exp_elt_opcode (OP_OBJC_SELECTOR);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(1) - (1)].sval));
 			  write_exp_elt_opcode (OP_OBJC_SELECTOR); }
     break;
 
@@ -1898,8 +2231,8 @@
 #line 577 "objc-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_int);
-			  CHECK_TYPEDEF (yyvsp[-1].tval);
-			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yyvsp[-1].tval));
+			  CHECK_TYPEDEF ((yyvsp[(3) - (4)].tval));
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ((yyvsp[(3) - (4)].tval)));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
@@ -1911,7 +2244,7 @@
 			     bound is the string length.  There is no
 			     such thing in C as a completely empty
 			     string.  */
-			  char *sp = yyvsp[0].sval.ptr; int count = yyvsp[0].sval.length;
+			  char *sp = (yyvsp[(1) - (1)].sval).ptr; int count = (yyvsp[(1) - (1)].sval).length;
 			  while (count-- > 0)
 			    {
 			      write_exp_elt_opcode (OP_LONG);
@@ -1925,31 +2258,31 @@
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_opcode (OP_ARRAY);
 			  write_exp_elt_longcst ((LONGEST) 0);
-			  write_exp_elt_longcst ((LONGEST) (yyvsp[0].sval.length));
+			  write_exp_elt_longcst ((LONGEST) ((yyvsp[(1) - (1)].sval).length));
 			  write_exp_elt_opcode (OP_ARRAY); }
     break;
 
   case 78:
 #line 612 "objc-exp.y"
     { write_exp_elt_opcode (OP_OBJC_NSSTRING);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(1) - (1)].sval));
 			  write_exp_elt_opcode (OP_OBJC_NSSTRING); }
     break;
 
   case 79:
 #line 618 "objc-exp.y"
     {
-			  if (yyvsp[0].ssym.sym != 0)
-			      yyval.bval = SYMBOL_BLOCK_VALUE (yyvsp[0].ssym.sym);
+			  if ((yyvsp[(1) - (1)].ssym).sym != 0)
+			      (yyval.bval) = SYMBOL_BLOCK_VALUE ((yyvsp[(1) - (1)].ssym).sym);
 			  else
 			    {
 			      struct symtab *tem =
-				  lookup_symtab (copy_name (yyvsp[0].ssym.stoken));
+				  lookup_symtab (copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			      if (tem)
-				yyval.bval = BLOCKVECTOR_BLOCK (BLOCKVECTOR (tem), STATIC_BLOCK);
+				(yyval.bval) = BLOCKVECTOR_BLOCK (BLOCKVECTOR (tem), STATIC_BLOCK);
 			      else
 				error ("No file or function \"%s\".",
-				       copy_name (yyvsp[0].ssym.stoken));
+				       copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			    }
 			}
     break;
@@ -1957,24 +2290,24 @@
   case 80:
 #line 635 "objc-exp.y"
     { struct symbol *tem
-			    = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			    = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					     VAR_DOMAIN, (int *) NULL,
 					     (struct symtab **) NULL);
 			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
 			    error ("No function \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
-			  yyval.bval = SYMBOL_BLOCK_VALUE (tem); }
+				   copy_name ((yyvsp[(3) - (3)].sval)));
+			  (yyval.bval) = SYMBOL_BLOCK_VALUE (tem); }
     break;
 
   case 81:
 #line 646 "objc-exp.y"
     { struct symbol *sym;
-			  sym = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			  sym = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					       VAR_DOMAIN, (int *) NULL,
 					       (struct symtab **) NULL);
 			  if (sym == 0)
 			    error ("No symbol \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
+				   copy_name ((yyvsp[(3) - (3)].sval)));
 
 			  write_exp_elt_opcode (OP_VAR_VALUE);
 			  /* block_found is set by lookup_symbol.  */
@@ -1986,7 +2319,7 @@
   case 82:
 #line 662 "objc-exp.y"
     {
-			  struct type *type = yyvsp[-2].tval;
+			  struct type *type = (yyvsp[(1) - (3)].tval);
 			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
 			      && TYPE_CODE (type) != TYPE_CODE_UNION)
 			    error ("`%s' is not defined as an aggregate type.",
@@ -1994,7 +2327,7 @@
 
 			  write_exp_elt_opcode (OP_SCOPE);
 			  write_exp_elt_type (type);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (OP_SCOPE);
 			}
     break;
@@ -2002,21 +2335,21 @@
   case 83:
 #line 675 "objc-exp.y"
     {
-			  struct type *type = yyvsp[-3].tval;
+			  struct type *type = (yyvsp[(1) - (4)].tval);
 			  struct stoken tmp_token;
 			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
 			      && TYPE_CODE (type) != TYPE_CODE_UNION)
 			    error ("`%s' is not defined as an aggregate type.",
 				   TYPE_NAME (type));
 
-			  if (strcmp (type_name_no_tag (type), yyvsp[0].sval.ptr) != 0)
+			  if (strcmp (type_name_no_tag (type), (yyvsp[(4) - (4)].sval).ptr) != 0)
 			    error ("invalid destructor `%s::~%s'",
-				   type_name_no_tag (type), yyvsp[0].sval.ptr);
+				   type_name_no_tag (type), (yyvsp[(4) - (4)].sval).ptr);
 
-			  tmp_token.ptr = (char*) alloca (yyvsp[0].sval.length + 2);
-			  tmp_token.length = yyvsp[0].sval.length + 1;
+			  tmp_token.ptr = (char*) alloca ((yyvsp[(4) - (4)].sval).length + 2);
+			  tmp_token.length = (yyvsp[(4) - (4)].sval).length + 1;
 			  tmp_token.ptr[0] = '~';
-			  memcpy (tmp_token.ptr+1, yyvsp[0].sval.ptr, yyvsp[0].sval.length);
+			  memcpy (tmp_token.ptr+1, (yyvsp[(4) - (4)].sval).ptr, (yyvsp[(4) - (4)].sval).length);
 			  tmp_token.ptr[tmp_token.length] = 0;
 			  write_exp_elt_opcode (OP_SCOPE);
 			  write_exp_elt_type (type);
@@ -2028,7 +2361,7 @@
   case 85:
 #line 701 "objc-exp.y"
     {
-			  char *name = copy_name (yyvsp[0].sval);
+			  char *name = copy_name ((yyvsp[(2) - (2)].sval));
 			  struct symbol *sym;
 			  struct minimal_symbol *msymbol;
 
@@ -2062,7 +2395,7 @@
 
   case 86:
 #line 735 "objc-exp.y"
-    { struct symbol *sym = yyvsp[0].ssym.sym;
+    { struct symbol *sym = (yyvsp[(1) - (1)].ssym).sym;
 
 			  if (sym)
 			    {
@@ -2082,7 +2415,7 @@
 			      write_exp_elt_sym (sym);
 			      write_exp_elt_opcode (OP_VAR_VALUE);
 			    }
-			  else if (yyvsp[0].ssym.is_a_field_of_this)
+			  else if ((yyvsp[(1) - (1)].ssym).is_a_field_of_this)
 			    {
 			      /* C++/ObjC: it hangs off of `this'/'self'.  
 				 Must not inadvertently convert from a 
@@ -2093,13 +2426,13 @@
 			      write_exp_elt_opcode (OP_OBJC_SELF);
 			      write_exp_elt_opcode (OP_OBJC_SELF);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
-			      write_exp_string (yyvsp[0].ssym.stoken);
+			      write_exp_string ((yyvsp[(1) - (1)].ssym).stoken);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
 			    }
 			  else
 			    {
 			      struct minimal_symbol *msymbol;
-			      char *arg = copy_name (yyvsp[0].ssym.stoken);
+			      char *arg = copy_name ((yyvsp[(1) - (1)].ssym).stoken);
 
 			      msymbol =
 				lookup_minimal_symbol (arg, NULL, NULL);
@@ -2114,55 +2447,55 @@
 				error ("No symbol table is loaded.  Use the \"file\" command.");
 			      else
 				error ("No symbol \"%s\" in current context.",
-				       copy_name (yyvsp[0].ssym.stoken));
+				       copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			    }
 			}
     break;
 
   case 90:
 #line 802 "objc-exp.y"
-    { yyval.tval = follow_types (yyvsp[-1].tval); }
+    { (yyval.tval) = follow_types ((yyvsp[(1) - (2)].tval)); }
     break;
 
   case 91:
 #line 804 "objc-exp.y"
-    { yyval.tval = follow_types (yyvsp[-2].tval); }
+    { (yyval.tval) = follow_types ((yyvsp[(1) - (3)].tval)); }
     break;
 
   case 92:
 #line 806 "objc-exp.y"
-    { yyval.tval = follow_types (yyvsp[-2].tval); }
+    { (yyval.tval) = follow_types ((yyvsp[(1) - (3)].tval)); }
     break;
 
   case 93:
 #line 810 "objc-exp.y"
-    { push_type (tp_pointer); yyval.voidval = 0; }
+    { push_type (tp_pointer); (yyval.voidval) = 0; }
     break;
 
   case 94:
 #line 812 "objc-exp.y"
-    { push_type (tp_pointer); yyval.voidval = yyvsp[0].voidval; }
+    { push_type (tp_pointer); (yyval.voidval) = (yyvsp[(2) - (2)].voidval); }
     break;
 
   case 95:
 #line 814 "objc-exp.y"
-    { push_type (tp_reference); yyval.voidval = 0; }
+    { push_type (tp_reference); (yyval.voidval) = 0; }
     break;
 
   case 96:
 #line 816 "objc-exp.y"
-    { push_type (tp_reference); yyval.voidval = yyvsp[0].voidval; }
+    { push_type (tp_reference); (yyval.voidval) = (yyvsp[(2) - (2)].voidval); }
     break;
 
   case 98:
 #line 821 "objc-exp.y"
-    { yyval.voidval = yyvsp[-1].voidval; }
+    { (yyval.voidval) = (yyvsp[(2) - (3)].voidval); }
     break;
 
   case 99:
 #line 823 "objc-exp.y"
     {
-			  push_type_int (yyvsp[0].lval);
+			  push_type_int ((yyvsp[(2) - (2)].lval));
 			  push_type (tp_array);
 			}
     break;
@@ -2170,9 +2503,9 @@
   case 100:
 #line 828 "objc-exp.y"
     {
-			  push_type_int (yyvsp[0].lval);
+			  push_type_int ((yyvsp[(1) - (1)].lval));
 			  push_type (tp_array);
-			  yyval.voidval = 0;
+			  (yyval.voidval) = 0;
 			}
     break;
 
@@ -2188,244 +2521,243 @@
 
   case 103:
 #line 841 "objc-exp.y"
-    { yyval.lval = -1; }
+    { (yyval.lval) = -1; }
     break;
 
   case 104:
 #line 843 "objc-exp.y"
-    { yyval.lval = yyvsp[-1].typed_val_int.val; }
+    { (yyval.lval) = (yyvsp[(2) - (3)].typed_val_int).val; }
     break;
 
   case 105:
 #line 847 "objc-exp.y"
-    { yyval.voidval = 0; }
+    { (yyval.voidval) = 0; }
     break;
 
   case 106:
 #line 849 "objc-exp.y"
-    { free (yyvsp[-1].tvec); yyval.voidval = 0; }
+    { free ((yyvsp[(2) - (3)].tvec)); (yyval.voidval) = 0; }
     break;
 
   case 108:
 #line 865 "objc-exp.y"
-    { yyval.tval = yyvsp[0].tsym.type; }
+    { (yyval.tval) = (yyvsp[(1) - (1)].tsym).type; }
     break;
 
   case 109:
 #line 867 "objc-exp.y"
     {
-			  if (yyvsp[0].class.type == NULL)
+			  if ((yyvsp[(1) - (1)].class).type == NULL)
 			    error ("No symbol \"%s\" in current context.", 
-				   copy_name(yyvsp[0].class.stoken));
+				   copy_name((yyvsp[(1) - (1)].class).stoken));
 			  else
-			    yyval.tval = yyvsp[0].class.type;
+			    (yyval.tval) = (yyvsp[(1) - (1)].class).type;
 			}
     break;
 
   case 110:
 #line 875 "objc-exp.y"
-    { yyval.tval = builtin_type_int; }
+    { (yyval.tval) = builtin_type_int; }
     break;
 
   case 111:
 #line 877 "objc-exp.y"
-    { yyval.tval = builtin_type_long; }
+    { (yyval.tval) = builtin_type_long; }
     break;
 
   case 112:
 #line 879 "objc-exp.y"
-    { yyval.tval = builtin_type_short; }
+    { (yyval.tval) = builtin_type_short; }
     break;
 
   case 113:
 #line 881 "objc-exp.y"
-    { yyval.tval = builtin_type_long; }
+    { (yyval.tval) = builtin_type_long; }
     break;
 
   case 114:
 #line 883 "objc-exp.y"
-    { yyval.tval = builtin_type_unsigned_long; }
+    { (yyval.tval) = builtin_type_unsigned_long; }
     break;
 
   case 115:
 #line 885 "objc-exp.y"
-    { yyval.tval = builtin_type_long_long; }
+    { (yyval.tval) = builtin_type_long_long; }
     break;
 
   case 116:
 #line 887 "objc-exp.y"
-    { yyval.tval = builtin_type_long_long; }
+    { (yyval.tval) = builtin_type_long_long; }
     break;
 
   case 117:
 #line 889 "objc-exp.y"
-    { yyval.tval = builtin_type_unsigned_long_long; }
+    { (yyval.tval) = builtin_type_unsigned_long_long; }
     break;
 
   case 118:
 #line 891 "objc-exp.y"
-    { yyval.tval = builtin_type_unsigned_long_long; }
+    { (yyval.tval) = builtin_type_unsigned_long_long; }
     break;
 
   case 119:
 #line 893 "objc-exp.y"
-    { yyval.tval = builtin_type_short; }
+    { (yyval.tval) = builtin_type_short; }
     break;
 
   case 120:
 #line 895 "objc-exp.y"
-    { yyval.tval = builtin_type_unsigned_short; }
+    { (yyval.tval) = builtin_type_unsigned_short; }
     break;
 
   case 121:
 #line 897 "objc-exp.y"
-    { yyval.tval = builtin_type_double; }
+    { (yyval.tval) = builtin_type_double; }
     break;
 
   case 122:
 #line 899 "objc-exp.y"
-    { yyval.tval = builtin_type_long_double; }
+    { (yyval.tval) = builtin_type_long_double; }
     break;
 
   case 123:
 #line 901 "objc-exp.y"
-    { yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_struct (copy_name ((yyvsp[(2) - (2)].sval)),
 					      expression_context_block); }
     break;
 
   case 124:
 #line 904 "objc-exp.y"
-    { yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_struct (copy_name ((yyvsp[(2) - (2)].sval)),
 					      expression_context_block); }
     break;
 
   case 125:
 #line 907 "objc-exp.y"
-    { yyval.tval = lookup_union (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_union (copy_name ((yyvsp[(2) - (2)].sval)),
 					     expression_context_block); }
     break;
 
   case 126:
 #line 910 "objc-exp.y"
-    { yyval.tval = lookup_enum (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_enum (copy_name ((yyvsp[(2) - (2)].sval)),
 					    expression_context_block); }
     break;
 
   case 127:
 #line 913 "objc-exp.y"
-    { yyval.tval = lookup_unsigned_typename (TYPE_NAME(yyvsp[0].tsym.type)); }
+    { (yyval.tval) = lookup_unsigned_typename (TYPE_NAME((yyvsp[(2) - (2)].tsym).type)); }
     break;
 
   case 128:
 #line 915 "objc-exp.y"
-    { yyval.tval = builtin_type_unsigned_int; }
+    { (yyval.tval) = builtin_type_unsigned_int; }
     break;
 
   case 129:
 #line 917 "objc-exp.y"
-    { yyval.tval = lookup_signed_typename (TYPE_NAME(yyvsp[0].tsym.type)); }
+    { (yyval.tval) = lookup_signed_typename (TYPE_NAME((yyvsp[(2) - (2)].tsym).type)); }
     break;
 
   case 130:
 #line 919 "objc-exp.y"
-    { yyval.tval = builtin_type_int; }
+    { (yyval.tval) = builtin_type_int; }
     break;
 
   case 131:
 #line 921 "objc-exp.y"
-    { yyval.tval = lookup_template_type(copy_name(yyvsp[-3].sval), yyvsp[-1].tval,
+    { (yyval.tval) = lookup_template_type(copy_name((yyvsp[(2) - (5)].sval)), (yyvsp[(4) - (5)].tval),
 						    expression_context_block);
 			}
     break;
 
   case 132:
 #line 927 "objc-exp.y"
-    { yyval.tval = yyvsp[0].tval; }
+    { (yyval.tval) = (yyvsp[(2) - (2)].tval); }
     break;
 
   case 133:
 #line 928 "objc-exp.y"
-    { yyval.tval = yyvsp[0].tval; }
+    { (yyval.tval) = (yyvsp[(2) - (2)].tval); }
     break;
 
   case 135:
 #line 933 "objc-exp.y"
     {
-		  yyval.tsym.stoken.ptr = "int";
-		  yyval.tsym.stoken.length = 3;
-		  yyval.tsym.type = builtin_type_int;
+		  (yyval.tsym).stoken.ptr = "int";
+		  (yyval.tsym).stoken.length = 3;
+		  (yyval.tsym).type = builtin_type_int;
 		}
     break;
 
   case 136:
 #line 939 "objc-exp.y"
     {
-		  yyval.tsym.stoken.ptr = "long";
-		  yyval.tsym.stoken.length = 4;
-		  yyval.tsym.type = builtin_type_long;
+		  (yyval.tsym).stoken.ptr = "long";
+		  (yyval.tsym).stoken.length = 4;
+		  (yyval.tsym).type = builtin_type_long;
 		}
     break;
 
   case 137:
 #line 945 "objc-exp.y"
     {
-		  yyval.tsym.stoken.ptr = "short";
-		  yyval.tsym.stoken.length = 5;
-		  yyval.tsym.type = builtin_type_short;
+		  (yyval.tsym).stoken.ptr = "short";
+		  (yyval.tsym).stoken.length = 5;
+		  (yyval.tsym).type = builtin_type_short;
 		}
     break;
 
   case 138:
 #line 954 "objc-exp.y"
-    { yyval.tvec = (struct type **) xmalloc (sizeof (struct type *) * 2);
-		  yyval.ivec[0] = 1;	/* Number of types in vector.  */
-		  yyval.tvec[1] = yyvsp[0].tval;
+    { (yyval.tvec) = (struct type **) xmalloc (sizeof (struct type *) * 2);
+		  (yyval.ivec)[0] = 1;	/* Number of types in vector.  */
+		  (yyval.tvec)[1] = (yyvsp[(1) - (1)].tval);
 		}
     break;
 
   case 139:
 #line 959 "objc-exp.y"
-    { int len = sizeof (struct type *) * (++(yyvsp[-2].ivec[0]) + 1);
-		  yyval.tvec = (struct type **) xrealloc ((char *) yyvsp[-2].tvec, len);
-		  yyval.tvec[yyval.ivec[0]] = yyvsp[0].tval;
+    { int len = sizeof (struct type *) * (++((yyvsp[(1) - (3)].ivec)[0]) + 1);
+		  (yyval.tvec) = (struct type **) xrealloc ((char *) (yyvsp[(1) - (3)].tvec), len);
+		  (yyval.tvec)[(yyval.ivec)[0]] = (yyvsp[(3) - (3)].tval);
 		}
     break;
 
   case 140:
 #line 965 "objc-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
   case 141:
 #line 966 "objc-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
   case 142:
 #line 967 "objc-exp.y"
-    { yyval.sval = yyvsp[0].tsym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].tsym).stoken; }
     break;
 
   case 143:
 #line 968 "objc-exp.y"
-    { yyval.sval = yyvsp[0].class.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].class).stoken; }
     break;
 
   case 144:
 #line 969 "objc-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2756 "objc-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 2424 "objc-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -2454,99 +2786,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2556,15 +2854,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2593,9 +2893,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2603,11 +2904,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2627,21 +2929,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -3471,4 +3791,3 @@
 	   lexptr);
 }
 
-
diff -Naur gdb-6.8/gdb/p-exp.c stsgdb-6.8/gdb/p-exp.c
--- gdb-6.8/gdb/p-exp.c	2008-03-27 18:27:13.000000000 +0000
+++ stsgdb-6.8/gdb/p-exp.c	2008-09-11 10:35:35.000000000 +0100
@@ -1,7 +1,9 @@
-/* A Bison parser, made by GNU Bison 1.875c.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -15,16 +17,24 @@
 
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
-   Foundation, Inc., 59 Temple Place - Suite 330,
-   Boston, MA 02111-1307, USA.  */
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -36,6 +46,9 @@
 /* Identify Bison output.  */
 #define YYBISON 1
 
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
@@ -89,6 +102,7 @@
      BLOCKNAME = 291
    };
 #endif
+/* Tokens.  */
 #define INT 258
 #define FLOAT 259
 #define STRING 260
@@ -221,9 +235,15 @@
 # define YYERROR_VERBOSE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 130 "p-exp.y"
-typedef union YYSTYPE {
+{
     LONGEST lval;
     struct {
       LONGEST val;
@@ -245,9 +265,10 @@
 
     struct type **tvec;
     int *ivec;
-  } YYSTYPE;
-/* Line 191 of yacc.c.  */
-#line 251 "p-exp.c.tmp"
+  }
+/* Line 187 of yacc.c.  */
+#line 271 "p-exp.c.tmp"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -269,56 +290,170 @@
 static int search_field;
 
 
-/* Line 214 of yacc.c.  */
-#line 274 "p-exp.c.tmp"
+/* Line 216 of yacc.c.  */
+#line 295 "p-exp.c.tmp"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
 
-# ifndef YYFREE
-#  define YYFREE free
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
 # endif
-# ifndef YYMALLOC
-#  define YYMALLOC xmalloc
+# ifndef YY_
+#  define YY_(msgid) msgid
 # endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
 
 /* The parser invokes alloca or xmalloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
-#   define YYSTACK_ALLOC alloca
-#  endif
-# else
-#  if defined (alloca) || defined (_ALLOCA_H)
-#   define YYSTACK_ALLOC alloca
-#  else
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
-# else
-#  if defined (__STDC__) || defined (__cplusplus)
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   define YYSIZE_T size_t
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
+# else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined xmalloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC xmalloc
+#   if ! defined xmalloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *xmalloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
   };
 
@@ -328,24 +463,24 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
       + YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
 #   define YYCOPY(To, From, Count)		\
       do					\
 	{					\
-	  register YYSIZE_T yyi;		\
+	  YYSIZE_T yyi;				\
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -363,39 +498,33 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  3
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   358
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  52
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  20
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  73
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  122
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   291
 
-#define YYTRANSLATE(YYX) 						\
+#define YYTRANSLATE(YYX)						\
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -432,7 +561,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned char yyprhs[] =
+static const yytype_uint8 yyprhs[] =
 {
        0,     0,     3,     4,     7,     9,    11,    13,    15,    19,
       22,    25,    28,    31,    36,    41,    42,    47,    48,    54,
@@ -444,8 +573,8 @@
      214,   216,   218,   220
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       53,     0,    -1,    -1,    54,    55,    -1,    57,    -1,    56,
       -1,    68,    -1,    58,    -1,    57,    19,    58,    -1,    58,
@@ -473,7 +602,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   234,   234,   234,   242,   243,   246,   253,   254,   259,
      265,   271,   275,   279,   283,   287,   287,   302,   300,   330,
@@ -486,9 +615,9 @@
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE
-/* YYTNME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "INT", "FLOAT", "STRING", "FIELDNAME",
@@ -507,7 +636,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,    44,
@@ -519,7 +648,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    52,    54,    53,    55,    55,    56,    57,    57,    58,
       58,    58,    58,    58,    58,    59,    58,    60,    58,    61,
@@ -532,7 +661,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     0,     2,     1,     1,     1,     1,     3,     2,
        2,     2,     2,     4,     4,     0,     4,     0,     5,     0,
@@ -547,7 +676,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
        2,     0,     0,     1,    47,    49,    53,    72,    65,    48,
        0,     0,     0,     0,    51,    54,    45,    46,     0,     0,
@@ -564,8 +693,8 @@
       20,    23
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const yysigned_char yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
 {
       -1,     1,     2,    26,    27,    28,    29,   103,   104,   105,
      116,   102,    30,    31,    32,    33,    46,    35,    41,    36
@@ -574,7 +703,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -40
-static const short yypact[] =
+static const yytype_int16 yypact[] =
 {
      -40,     6,    87,   -40,   -40,   -40,   -40,   -40,   -40,   -40,
        4,     4,   -39,     4,   -40,   -40,   -40,   -40,    87,    87,
@@ -592,7 +721,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const yysigned_char yypgoto[] =
+static const yytype_int8 yypgoto[] =
 {
      -40,   -40,   -40,   -40,   -40,   -19,   -18,   -40,   -40,   -40,
      -40,   -40,   -40,   -40,   -40,   -40,    12,   -16,    -8,   -40
@@ -603,7 +732,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -57
-static const yysigned_char yytable[] =
+static const yytype_int8 yytable[] =
 {
       45,    47,    48,    42,    51,    44,     3,    43,    52,    49,
       50,    37,    38,    39,    34,   -55,     8,    53,    10,    11,
@@ -643,7 +772,7 @@
       71,     0,     0,     0,    72,    73,    74,     0,    75
 };
 
-static const yysigned_char yycheck[] =
+static const yytype_int8 yycheck[] =
 {
       18,    19,    20,    11,    23,    13,     0,    46,    24,    46,
       46,     7,     8,     9,     2,    13,     8,    19,    10,    11,
@@ -685,7 +814,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,    53,    54,     0,     3,     4,     5,     7,     8,     9,
       10,    11,    12,    13,    15,    16,    17,    18,    22,    36,
@@ -702,22 +831,6 @@
       50,    58
 };
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
-#endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
-#endif
-#if ! defined (YYSIZE_T)
-# if defined (__STDC__) || defined (__cplusplus)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# endif
-#endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
-#endif
-
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
 #define YYEMPTY		(-2)
@@ -743,30 +856,63 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { 								\
-      yyerror ("syntax error: cannot back up");\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-/* YYLLOC_DEFAULT -- Compute the default location (before the actions
-   are run).  */
 
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
 #ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)		\
-   ((Current).first_line   = (Rhs)[1].first_line,	\
-    (Current).first_column = (Rhs)[1].first_column,	\
-    (Current).last_line    = (Rhs)[N].last_line,	\
-    (Current).last_column  = (Rhs)[N].last_column)
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
 /* YYLEX -- calling `yylex' with the right arguments.  */
 
 #ifdef YYLEX_PARAM
@@ -787,42 +933,96 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YYDSYMPRINT(Args)			\
-do {						\
-  if (yydebug)					\
-    yysymprint Args;				\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
-# define YYDSYMPRINTF(Title, Token, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr, 					\
-                  Token, Value);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short *bottom, short *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short *bottom;
-    short *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -831,45 +1031,52 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
     int yyrule;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %u), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname [yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname [yyr1[yyrule]]);
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
 # define YYDPRINTF(Args)
-# define YYDSYMPRINT(Args)
-# define YYDSYMPRINTF(Title, Token, Value, Location)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -884,13 +1091,9 @@
    if the built-in stack extension method is used).
 
    Do not make this value too large; the results are undefined if
-   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
    evaluated with infinite-precision integer arithmetic.  */
 
-#if defined (YYMAXDEPTH) && YYMAXDEPTH == 0
-# undef YYMAXDEPTH
-#endif
-
 #ifndef YYMAXDEPTH
 # define YYMAXDEPTH 10000
 #endif
@@ -900,45 +1103,47 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  register const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *yyd = yydest;
-  register const char *yys = yysrc;
+  char *yyd = yydest;
+  const char *yys = yysrc;
 
   while ((*yyd++ = *yys++) != '\0')
     continue;
@@ -948,70 +1153,192 @@
 #  endif
 # endif
 
-#endif /* !YYERROR_VERBOSE */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  int yyn = yypact[yystate];
 
-  if (yytype < YYNTOKENS)
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
     {
-      YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-# ifdef YYPRINT
-      YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
 # endif
-    }
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  switch (yytype)
-    {
-      default:
-        break;
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (int yytype, YYSTYPE *yyvaluep)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
 #else
 static void
-yydestruct (yytype, yyvaluep)
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
   switch (yytype)
     {
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1019,13 +1346,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void);
 #else
 int yyparse ();
@@ -1034,10 +1361,10 @@
 
 
 
-/* The lookahead symbol.  */
+/* The look-ahead symbol.  */
 int yychar;
 
-/* The semantic value of the lookahead symbol.  */
+/* The semantic value of the look-ahead symbol.  */
 YYSTYPE yylval;
 
 /* Number of syntax errors so far.  */
@@ -1050,14 +1377,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (void)
 #else
@@ -1068,13 +1399,19 @@
 #endif
 {
   
-  register int yystate;
-  register int yyn;
+  int yystate;
+  int yyn;
   int yyresult;
   /* Number of tokens to shift before error messages enabled.  */
   int yyerrstatus;
-  /* Lookahead token as an internal (translated) token number.  */
+  /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1085,18 +1422,18 @@
      to xreallocate them elsewhere.  */
 
   /* The state stack.  */
-  short	yyssa[YYINITDEPTH];
-  short *yyss = yyssa;
-  register short *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
   YYSTYPE *yyvs = yyvsa;
-  register YYSTYPE *yyvsp;
+  YYSTYPE *yyvsp;
 
 
 
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1105,9 +1442,9 @@
   YYSTYPE yyval;
 
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1131,8 +1468,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1145,18 +1481,18 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to xreallocate the stack. Use copies of
+	/* Give user a chance to xreallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 
 
 	/* Each stack pointer address is followed by the size of the
 	   data in use in that stack, in bytes.  This used to be a
 	   conditional around just the two extra args, but that might
 	   be undefined if yyoverflow is a macro.  */
-	yyoverflow ("parser stack overflow",
+	yyoverflow (YY_("memory exhausted"),
 		    &yyss1, yysize * sizeof (*yyssp),
 		    &yyvs1, yysize * sizeof (*yyvsp),
 
@@ -1167,21 +1503,21 @@
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
-      goto yyoverflowlab;
+      goto yyexhaustedlab;
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyoverflowlab;
+	goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
 
       {
-	short *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
-	  goto yyoverflowlab;
+	  goto yyexhaustedlab;
 	YYSTACK_RELOCATE (yyss);
 	YYSTACK_RELOCATE (yyvs);
 
@@ -1212,19 +1548,17 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
-
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
@@ -1239,7 +1573,7 @@
   else
     {
       yytoken = YYTRANSLATE (yychar);
-      YYDSYMPRINTF ("Next token is", yytoken, &yylval, &yylloc);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
   /* If the proper action on seeing token YYTOKEN is to reduce or to
@@ -1259,22 +1593,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
-  YYDPRINTF ((stderr, "Shifting token %s, ", yytname[yytoken]));
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
-  *++yyvsp = yylval;
-
-
   /* Count tokens shifted since error; after three, turn off error
      status.  */
   if (yyerrstatus)
     yyerrstatus--;
 
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
   yystate = yyn;
+  *++yyvsp = yylval;
+
   goto yynewstate;
 
 
@@ -1325,9 +1658,9 @@
   case 6:
 #line 247 "p-exp.y"
     { write_exp_elt_opcode(OP_TYPE);
-			  write_exp_elt_type(yyvsp[0].tval);
+			  write_exp_elt_type((yyvsp[(1) - (1)].tval));
 			  write_exp_elt_opcode(OP_TYPE);
-			  current_type = yyvsp[0].tval; }
+			  current_type = (yyvsp[(1) - (1)].tval); }
     break;
 
   case 8:
@@ -1377,14 +1710,14 @@
   case 16:
 #line 290 "p-exp.y"
     { write_exp_elt_opcode (STRUCTOP_STRUCT);
-			  write_exp_string (yyvsp[0].sval); 
+			  write_exp_string ((yyvsp[(4) - (4)].sval)); 
 			  write_exp_elt_opcode (STRUCTOP_STRUCT);
 			  search_field = 0; 
 			  if (current_type)
 			    { while (TYPE_CODE (current_type) == TYPE_CODE_PTR)
 				current_type = TYPE_TARGET_TYPE (current_type);
 			      current_type = lookup_struct_elt_type (
-				current_type, yyvsp[0].sval.ptr, 0); };
+				current_type, (yyvsp[(4) - (4)].sval).ptr, 0); };
 			 }
     break;
 
@@ -1452,13 +1785,13 @@
 			      /* Allow automatic dereference of classes.  */
 			      if ((TYPE_CODE (current_type) == TYPE_CODE_PTR)
 				  && (TYPE_CODE (TYPE_TARGET_TYPE (current_type)) == TYPE_CODE_CLASS)
-				  && (TYPE_CODE (yyvsp[-3].tval) == TYPE_CODE_CLASS))
+				  && (TYPE_CODE ((yyvsp[(1) - (4)].tval)) == TYPE_CODE_CLASS))
 				write_exp_elt_opcode (UNOP_IND);
 			    }
 			  write_exp_elt_opcode (UNOP_CAST);
-			  write_exp_elt_type (yyvsp[-3].tval);
+			  write_exp_elt_type ((yyvsp[(1) - (4)].tval));
 			  write_exp_elt_opcode (UNOP_CAST); 
-			  current_type = yyvsp[-3].tval; }
+			  current_type = (yyvsp[(1) - (4)].tval); }
     break;
 
   case 25:
@@ -1591,7 +1924,7 @@
   case 45:
 #line 471 "p-exp.y"
     { write_exp_elt_opcode (OP_BOOL);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].lval));
 			  current_type = builtin_type_bool;
 			  write_exp_elt_opcode (OP_BOOL); }
     break;
@@ -1599,7 +1932,7 @@
   case 46:
 #line 478 "p-exp.y"
     { write_exp_elt_opcode (OP_BOOL);
-			  write_exp_elt_longcst ((LONGEST) yyvsp[0].lval);
+			  write_exp_elt_longcst ((LONGEST) (yyvsp[(1) - (1)].lval));
 			  current_type = builtin_type_bool;
 			  write_exp_elt_opcode (OP_BOOL); }
     break;
@@ -1607,16 +1940,16 @@
   case 47:
 #line 485 "p-exp.y"
     { write_exp_elt_opcode (OP_LONG);
-			  write_exp_elt_type (yyvsp[0].typed_val_int.type);
-			  current_type = yyvsp[0].typed_val_int.type;
-			  write_exp_elt_longcst ((LONGEST)(yyvsp[0].typed_val_int.val));
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_int).type);
+			  current_type = (yyvsp[(1) - (1)].typed_val_int).type;
+			  write_exp_elt_longcst ((LONGEST)((yyvsp[(1) - (1)].typed_val_int).val));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
   case 48:
 #line 493 "p-exp.y"
     { YYSTYPE val;
-			  parse_number (yyvsp[0].ssym.stoken.ptr, yyvsp[0].ssym.stoken.length, 0, &val);
+			  parse_number ((yyvsp[(1) - (1)].ssym).stoken.ptr, (yyvsp[(1) - (1)].ssym).stoken.length, 0, &val);
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (val.typed_val_int.type);
 			  current_type = val.typed_val_int.type;
@@ -1628,9 +1961,9 @@
   case 49:
 #line 505 "p-exp.y"
     { write_exp_elt_opcode (OP_DOUBLE);
-			  write_exp_elt_type (yyvsp[0].typed_val_float.type);
-			  current_type = yyvsp[0].typed_val_float.type;
-			  write_exp_elt_dblcst (yyvsp[0].typed_val_float.dval);
+			  write_exp_elt_type ((yyvsp[(1) - (1)].typed_val_float).type);
+			  current_type = (yyvsp[(1) - (1)].typed_val_float).type;
+			  write_exp_elt_dblcst ((yyvsp[(1) - (1)].typed_val_float).dval);
 			  write_exp_elt_opcode (OP_DOUBLE); }
     break;
 
@@ -1638,8 +1971,8 @@
 #line 520 "p-exp.y"
     { write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_type (builtin_type_int);
-			  CHECK_TYPEDEF (yyvsp[-1].tval);
-			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH (yyvsp[-1].tval));
+			  CHECK_TYPEDEF ((yyvsp[(3) - (4)].tval));
+			  write_exp_elt_longcst ((LONGEST) TYPE_LENGTH ((yyvsp[(3) - (4)].tval)));
 			  write_exp_elt_opcode (OP_LONG); }
     break;
 
@@ -1650,7 +1983,7 @@
 			     the array upper bound is the string length.
 			     There is no such thing in C as a completely empty
 			     string. */
-			  char *sp = yyvsp[0].sval.ptr; int count = yyvsp[0].sval.length;
+			  char *sp = (yyvsp[(1) - (1)].sval).ptr; int count = (yyvsp[(1) - (1)].sval).length;
 			  while (count-- > 0)
 			    {
 			      write_exp_elt_opcode (OP_LONG);
@@ -1664,7 +1997,7 @@
 			  write_exp_elt_opcode (OP_LONG);
 			  write_exp_elt_opcode (OP_ARRAY);
 			  write_exp_elt_longcst ((LONGEST) 0);
-			  write_exp_elt_longcst ((LONGEST) (yyvsp[0].sval.length));
+			  write_exp_elt_longcst ((LONGEST) ((yyvsp[(1) - (1)].sval).length));
 			  write_exp_elt_opcode (OP_ARRAY); }
     break;
 
@@ -1697,17 +2030,17 @@
   case 55:
 #line 580 "p-exp.y"
     {
-			  if (yyvsp[0].ssym.sym != 0)
-			      yyval.bval = SYMBOL_BLOCK_VALUE (yyvsp[0].ssym.sym);
+			  if ((yyvsp[(1) - (1)].ssym).sym != 0)
+			      (yyval.bval) = SYMBOL_BLOCK_VALUE ((yyvsp[(1) - (1)].ssym).sym);
 			  else
 			    {
 			      struct symtab *tem =
-				  lookup_symtab (copy_name (yyvsp[0].ssym.stoken));
+				  lookup_symtab (copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			      if (tem)
-				yyval.bval = BLOCKVECTOR_BLOCK (BLOCKVECTOR (tem), STATIC_BLOCK);
+				(yyval.bval) = BLOCKVECTOR_BLOCK (BLOCKVECTOR (tem), STATIC_BLOCK);
 			      else
 				error ("No file or function \"%s\".",
-				       copy_name (yyvsp[0].ssym.stoken));
+				       copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			    }
 			}
     break;
@@ -1715,24 +2048,24 @@
   case 56:
 #line 597 "p-exp.y"
     { struct symbol *tem
-			    = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			    = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					     VAR_DOMAIN, (int *) NULL,
 					     (struct symtab **) NULL);
 			  if (!tem || SYMBOL_CLASS (tem) != LOC_BLOCK)
 			    error ("No function \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
-			  yyval.bval = SYMBOL_BLOCK_VALUE (tem); }
+				   copy_name ((yyvsp[(3) - (3)].sval)));
+			  (yyval.bval) = SYMBOL_BLOCK_VALUE (tem); }
     break;
 
   case 57:
 #line 608 "p-exp.y"
     { struct symbol *sym;
-			  sym = lookup_symbol (copy_name (yyvsp[0].sval), yyvsp[-2].bval,
+			  sym = lookup_symbol (copy_name ((yyvsp[(3) - (3)].sval)), (yyvsp[(1) - (3)].bval),
 					       VAR_DOMAIN, (int *) NULL,
 					       (struct symtab **) NULL);
 			  if (sym == 0)
 			    error ("No symbol \"%s\" in specified context.",
-				   copy_name (yyvsp[0].sval));
+				   copy_name ((yyvsp[(3) - (3)].sval)));
 
 			  write_exp_elt_opcode (OP_VAR_VALUE);
 			  /* block_found is set by lookup_symbol.  */
@@ -1744,7 +2077,7 @@
   case 58:
 #line 624 "p-exp.y"
     {
-			  struct type *type = yyvsp[-2].tval;
+			  struct type *type = (yyvsp[(1) - (3)].tval);
 			  if (TYPE_CODE (type) != TYPE_CODE_STRUCT
 			      && TYPE_CODE (type) != TYPE_CODE_UNION)
 			    error ("`%s' is not defined as an aggregate type.",
@@ -1752,7 +2085,7 @@
 
 			  write_exp_elt_opcode (OP_SCOPE);
 			  write_exp_elt_type (type);
-			  write_exp_string (yyvsp[0].sval);
+			  write_exp_string ((yyvsp[(3) - (3)].sval));
 			  write_exp_elt_opcode (OP_SCOPE);
 			}
     break;
@@ -1760,7 +2093,7 @@
   case 60:
 #line 640 "p-exp.y"
     {
-			  char *name = copy_name (yyvsp[0].sval);
+			  char *name = copy_name ((yyvsp[(2) - (2)].sval));
 			  struct symbol *sym;
 			  struct minimal_symbol *msymbol;
 
@@ -1794,7 +2127,7 @@
 
   case 61:
 #line 674 "p-exp.y"
-    { struct symbol *sym = yyvsp[0].ssym.sym;
+    { struct symbol *sym = (yyvsp[(1) - (1)].ssym).sym;
 
 			  if (sym)
 			    {
@@ -1814,7 +2147,7 @@
 			      write_exp_elt_sym (sym);
 			      write_exp_elt_opcode (OP_VAR_VALUE);
 			      current_type = sym->type; }
-			  else if (yyvsp[0].ssym.is_a_field_of_this)
+			  else if ((yyvsp[(1) - (1)].ssym).is_a_field_of_this)
 			    {
 			      struct value * this_val;
 			      struct type * this_type;
@@ -1828,7 +2161,7 @@
 			      write_exp_elt_opcode (OP_THIS);
 			      write_exp_elt_opcode (OP_THIS);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
-			      write_exp_string (yyvsp[0].ssym.stoken);
+			      write_exp_string ((yyvsp[(1) - (1)].ssym).stoken);
 			      write_exp_elt_opcode (STRUCTOP_PTR);
 			      /* we need type of this */
 			      this_val = value_of_this (0); 
@@ -1839,14 +2172,14 @@
 			      if (this_type)
 				current_type = lookup_struct_elt_type (
 				  this_type,
-				  copy_name (yyvsp[0].ssym.stoken), 0);
+				  copy_name ((yyvsp[(1) - (1)].ssym).stoken), 0);
 			      else
 				current_type = NULL; 
 			    }
 			  else
 			    {
 			      struct minimal_symbol *msymbol;
-			      char *arg = copy_name (yyvsp[0].ssym.stoken);
+			      char *arg = copy_name ((yyvsp[(1) - (1)].ssym).stoken);
 
 			      msymbol =
 				lookup_minimal_symbol (arg, NULL, NULL);
@@ -1860,63 +2193,62 @@
 				error ("No symbol table is loaded.  Use the \"file\" command.");
 			      else
 				error ("No symbol \"%s\" in current context.",
-				       copy_name (yyvsp[0].ssym.stoken));
+				       copy_name ((yyvsp[(1) - (1)].ssym).stoken));
 			    }
 			}
     break;
 
   case 64:
 #line 762 "p-exp.y"
-    { yyval.tval = lookup_pointer_type (yyvsp[0].tval); }
+    { (yyval.tval) = lookup_pointer_type ((yyvsp[(2) - (2)].tval)); }
     break;
 
   case 65:
 #line 764 "p-exp.y"
-    { yyval.tval = yyvsp[0].tsym.type; }
+    { (yyval.tval) = (yyvsp[(1) - (1)].tsym).type; }
     break;
 
   case 66:
 #line 766 "p-exp.y"
-    { yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_struct (copy_name ((yyvsp[(2) - (2)].sval)),
 					      expression_context_block); }
     break;
 
   case 67:
 #line 769 "p-exp.y"
-    { yyval.tval = lookup_struct (copy_name (yyvsp[0].sval),
+    { (yyval.tval) = lookup_struct (copy_name ((yyvsp[(2) - (2)].sval)),
 					      expression_context_block); }
     break;
 
   case 68:
 #line 776 "p-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
   case 69:
 #line 777 "p-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
   case 70:
 #line 778 "p-exp.y"
-    { yyval.sval = yyvsp[0].tsym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].tsym).stoken; }
     break;
 
   case 71:
 #line 779 "p-exp.y"
-    { yyval.sval = yyvsp[0].ssym.stoken; }
+    { (yyval.sval) = (yyvsp[(1) - (1)].ssym).stoken; }
     break;
 
 
+/* Line 1267 of yacc.c.  */
+#line 2247 "p-exp.c.tmp"
+      default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1000 of yacc.c.  */
-#line 1915 "p-exp.c.tmp"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -1945,99 +2277,65 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  YYSIZE_T yysize = 0;
-	  int yytype = YYTRANSLATE (yychar);
-	  const char* yyprefix;
-	  char *yymsg;
-	  int yyx;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 0;
-
-	  yyprefix = ", expecting ";
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		yysize += yystrlen (yyprefix) + yystrlen (yytname [yyx]);
-		yycount += 1;
-		if (yycount == 5)
-		  {
-		    yysize = 0;
-		    break;
-		  }
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
-	  yysize += (sizeof ("syntax error, unexpected ")
-		     + yystrlen (yytname[yytype]));
-	  yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg != 0)
-	    {
-	      char *yyp = yystpcpy (yymsg, "syntax error, unexpected ");
-	      yyp = yystpcpy (yyp, yytname[yytype]);
+	  }
 
-	      if (yycount < 5)
-		{
-		  yyprefix = ", expecting ";
-		  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-		    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
-		      {
-			yyp = yystpcpy (yyp, yyprefix);
-			yyp = yystpcpy (yyp, yytname[yyx]);
-			yyprefix = " or ";
-		      }
-		}
-	      yyerror (yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    yyerror ("syntax error; also virtual memory exhausted");
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror ("syntax error");
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
     }
 
 
 
   if (yyerrstatus == 3)
     {
-      /* If just tried and failed to reuse lookahead token after an
+      /* If just tried and failed to reuse look-ahead token after an
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
-          /* If at end of input, pop the error token,
-	     then the rest of the stack, then return failure.  */
+	{
+	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
-	     for (;;)
-	       {
-		 YYPOPSTACK;
-		 if (yyssp == yyss)
-		   YYABORT;
-		 YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-		 yydestruct (yystos[*yyssp], yyvsp);
-	       }
-        }
+	    YYABORT;
+	}
       else
 	{
-	  YYDSYMPRINTF ("Error: discarding", yytoken, &yylval, &yylloc);
-	  yydestruct (yytoken, &yylval);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
 	  yychar = YYEMPTY;
-
 	}
     }
 
-  /* Else will try to reuse lookahead token after shifting the error
+  /* Else will try to reuse look-ahead token after shifting the error
      token.  */
   goto yyerrlab1;
 
@@ -2047,15 +2345,17 @@
 `---------------------------------------------------*/
 yyerrorlab:
 
-#ifdef __GNUC__
-  /* Pacify GCC when the user code never invokes YYERROR and the label
-     yyerrorlab therefore never appears in user code.  */
-  if (0)
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
-#endif
 
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2084,9 +2384,10 @@
       if (yyssp == yyss)
 	YYABORT;
 
-      YYDSYMPRINTF ("Error: popping", yystos[*yyssp], yyvsp, yylsp);
-      yydestruct (yystos[yystate], yyvsp);
-      YYPOPSTACK;
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2094,11 +2395,12 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  YYDPRINTF ((stderr, "Shifting error token, "));
-
   *++yyvsp = yylval;
 
 
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
   yystate = yyn;
   goto yynewstate;
 
@@ -2118,21 +2420,39 @@
   goto yyreturn;
 
 #ifndef yyoverflow
-/*----------------------------------------------.
-| yyoverflowlab -- parser overflow comes here.  |
-`----------------------------------------------*/
-yyoverflowlab:
-  yyerror ("parser stack overflow");
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
 
 yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-  return yyresult;
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
@@ -3047,4 +3367,3 @@
   error ("A %s in expression, near `%s'.", (msg ? msg : "error"), lexptr);
 }
 
-
diff -Naur gdb-6.8/gdb/po/gdb.pot stsgdb-6.8/gdb/po/gdb.pot
--- gdb-6.8/gdb/po/gdb.pot	2008-03-27 18:27:15.000000000 +0000
+++ stsgdb-6.8/gdb/po/gdb.pot	2008-09-11 10:35:23.000000000 +0100
@@ -8,7 +8,7 @@
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-03-27 18:27+0000\n"
+"POT-Creation-Date: 2008-03-29 17:17-0700\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -668,26 +668,26 @@
 msgid "Invalid character '%s' in expression."
 msgstr ""
 
-#: ada-lex.l:321
+#: ada-lex.l:322
 #, possible-c-format
 msgid "Invalid base: %d."
 msgstr ""
 
-#: ada-lex.l:332 ada-lex.l:339
+#: ada-lex.l:333 ada-lex.l:340
 msgid "Integer literal out of range"
 msgstr ""
 
-#: ada-lex.l:334
+#: ada-lex.l:335
 #, possible-c-format
 msgid "Invalid digit `%c' in based literal"
 msgstr ""
 
-#: ada-lex.l:579
+#: ada-lex.l:580
 #, possible-c-format
 msgid "ambiguous attribute name: `%s'"
 msgstr ""
 
-#: ada-lex.l:582
+#: ada-lex.l:583
 #, possible-c-format
 msgid "unrecognized attribute: `%s'"
 msgstr ""
@@ -2961,6 +2961,54 @@
 "charset'<TAB>"
 msgstr ""
 
+#: cli/cli-setshow.c:58
+msgid "\"on\", \"off\" or \"auto\" expected."
+msgstr ""
+
+#: cli/cli-setshow.c:87
+msgid "\"on\" or \"off\" expected."
+msgstr ""
+
+#: cli/cli-setshow.c:191
+msgid "filename to set it to."
+msgstr ""
+
+#: cli/cli-setshow.c:211 cli/cli-setshow.c:220 cli/cli-setshow.c:232
+msgid "integer to set it to."
+msgstr ""
+
+#: cli/cli-setshow.c:225
+#, possible-c-format
+msgid "integer %u out of range"
+msgstr ""
+
+#: cli/cli-setshow.c:261
+#, possible-c-format
+msgid "Requires an argument. Valid arguments are %s."
+msgstr ""
+
+#: cli/cli-setshow.c:289
+#, possible-c-format
+msgid "Undefined item: \"%s\"."
+msgstr ""
+
+#: cli/cli-setshow.c:292
+#, possible-c-format
+msgid "Ambiguous item \"%s\"."
+msgstr ""
+
+#: cli/cli-setshow.c:298 cli/cli-setshow.c:367
+msgid "gdb internal error: bad var_type in do_setshow_command"
+msgstr ""
+
+#: cli/cli-setshow.c:343
+msgid "do_setshow_command: invalid var_auto_boolean"
+msgstr ""
+
+#: cli/cli-setshow.c:391
+msgid "gdb internal error: bad cmd_type in do_setshow_command"
+msgstr ""
+
 #: cli/cli-cmds.c:190
 #, possible-c-format
 msgid "Argument required (%s)."
@@ -3426,23 +3474,109 @@
 msgid "When 'on', each command is displayed as it is executed."
 msgstr ""
 
-#: cli/cli-decode.c:1200
+#: cli/cli-script.c:85
+msgid "if/while commands require arguments."
+msgstr ""
+
+#: cli/cli-script.c:119
+msgid "Error reading in canned sequence of commands."
+msgstr ""
+
+#: cli/cli-script.c:294
+msgid "Max user call depth exceeded -- command aborted."
+msgstr ""
+
+#: cli/cli-script.c:313
+msgid "Error executing canned sequence of commands."
+msgstr ""
+
+#: cli/cli-script.c:532
+msgid "Invalid control type in canned commands structure."
+msgstr ""
+
+#: cli/cli-script.c:586
+msgid "arg_cleanup called with no user args.\n"
+msgstr ""
+
+#: cli/cli-script.c:625
 #, possible-c-format
-msgid "Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."
+msgid "user defined function may only have %d arguments."
 msgstr ""
 
-#: cli/cli-decode.c:1233
+#: cli/cli-script.c:722
 #, possible-c-format
-msgid "Lack of needed %scommand"
+msgid "Missing argument %d in user function."
 msgstr ""
 
-#: cli/cli-decode.c:1297
+#: cli/cli-script.c:821
+msgid "Control nesting too deep!"
+msgstr ""
+
+#: cli/cli-script.c:944
+msgid "Recursed on a simple control type."
+msgstr ""
+
+#: cli/cli-script.c:947
+msgid "Allocated body is smaller than this command type needs."
+msgstr ""
+
+#: cli/cli-script.c:1204
+msgid "name of command to define"
+msgstr ""
+
+#: cli/cli-script.c:1210
 #, possible-c-format
-msgid "Ambiguous %scommand \"%s\": %s."
+msgid "Junk in argument list: \"%s\""
 msgstr ""
 
-#: cli/cli-decode.c:1665
-msgid "Invalid command"
+#: cli/cli-script.c:1255
+#, possible-c-format
+msgid "Redefine command \"%s\"? "
+msgstr ""
+
+#: cli/cli-script.c:1257
+#, possible-c-format
+msgid "Really redefine built-in command \"%s\"? "
+msgstr ""
+
+#: cli/cli-script.c:1259
+#, possible-c-format
+msgid "Command \"%s\" not redefined."
+msgstr ""
+
+#: cli/cli-script.c:1286
+#, possible-c-format
+msgid "Your new `%s' command does not hook any existing command."
+msgstr ""
+
+#. Should never come here as hookc would be 0.
+#: cli/cli-script.c:1328 complaints.c:299 exceptions.c:151 exceptions.c:168
+#: exceptions.c:194 exceptions.c:254 hppa-tdep.c:3131 hppa-tdep.c:3144
+#: infcall.c:560 infcmd.c:1192 infrun.c:1324 language.c:883 language.c:909
+#: mi/mi-out.c:321 mi/mi-out.c:339 mips-tdep.c:277 mips-tdep.c:336
+#: mips-tdep.c:1261 mips-tdep.c:3782 mips-tdep.c:4750 mn10300-tdep.c:88
+#: reggroups.c:214 remote.c:4600 utils.c:747 utils.c:766
+msgid "bad switch"
+msgstr ""
+
+#: cli/cli-script.c:1346
+#, possible-c-format
+msgid "Command \"%s\" is built-in."
+msgstr ""
+
+#: cli/cli-script.c:1418
+msgid "called with NULL file pointer!"
+msgstr ""
+
+#: cli/cli-script.c:1445
+#, possible-c-format
+msgid ""
+"%s:%d: Error in sourced command file:\n"
+"%s"
+msgstr ""
+
+#: cli/cli-script.c:1448
+msgid "bad reason"
 msgstr ""
 
 #: cli/cli-dump.c:95
@@ -3644,6 +3778,25 @@
 "(file relative) will be restored to target memory."
 msgstr ""
 
+#: cli/cli-decode.c:1200
+#, possible-c-format
+msgid "Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."
+msgstr ""
+
+#: cli/cli-decode.c:1233
+#, possible-c-format
+msgid "Lack of needed %scommand"
+msgstr ""
+
+#: cli/cli-decode.c:1297
+#, possible-c-format
+msgid "Ambiguous %scommand \"%s\": %s."
+msgstr ""
+
+#: cli/cli-decode.c:1665
+msgid "Invalid command"
+msgstr ""
+
 #: cli/cli-logging.c:43
 #, possible-c-format
 msgid "The current logfile is \"%s\".\n"
@@ -3757,159 +3910,6 @@
 msgid "Disable logging."
 msgstr ""
 
-#: cli/cli-script.c:85
-msgid "if/while commands require arguments."
-msgstr ""
-
-#: cli/cli-script.c:119
-msgid "Error reading in canned sequence of commands."
-msgstr ""
-
-#: cli/cli-script.c:294
-msgid "Max user call depth exceeded -- command aborted."
-msgstr ""
-
-#: cli/cli-script.c:313
-msgid "Error executing canned sequence of commands."
-msgstr ""
-
-#: cli/cli-script.c:532
-msgid "Invalid control type in canned commands structure."
-msgstr ""
-
-#: cli/cli-script.c:586
-msgid "arg_cleanup called with no user args.\n"
-msgstr ""
-
-#: cli/cli-script.c:625
-#, possible-c-format
-msgid "user defined function may only have %d arguments."
-msgstr ""
-
-#: cli/cli-script.c:722
-#, possible-c-format
-msgid "Missing argument %d in user function."
-msgstr ""
-
-#: cli/cli-script.c:821
-msgid "Control nesting too deep!"
-msgstr ""
-
-#: cli/cli-script.c:944
-msgid "Recursed on a simple control type."
-msgstr ""
-
-#: cli/cli-script.c:947
-msgid "Allocated body is smaller than this command type needs."
-msgstr ""
-
-#: cli/cli-script.c:1204
-msgid "name of command to define"
-msgstr ""
-
-#: cli/cli-script.c:1210
-#, possible-c-format
-msgid "Junk in argument list: \"%s\""
-msgstr ""
-
-#: cli/cli-script.c:1255
-#, possible-c-format
-msgid "Redefine command \"%s\"? "
-msgstr ""
-
-#: cli/cli-script.c:1257
-#, possible-c-format
-msgid "Really redefine built-in command \"%s\"? "
-msgstr ""
-
-#: cli/cli-script.c:1259
-#, possible-c-format
-msgid "Command \"%s\" not redefined."
-msgstr ""
-
-#: cli/cli-script.c:1286
-#, possible-c-format
-msgid "Your new `%s' command does not hook any existing command."
-msgstr ""
-
-#. Should never come here as hookc would be 0.
-#: cli/cli-script.c:1328 complaints.c:299 exceptions.c:151 exceptions.c:168
-#: exceptions.c:194 exceptions.c:254 hppa-tdep.c:3131 hppa-tdep.c:3144
-#: infcall.c:560 infcmd.c:1192 infrun.c:1324 language.c:883 language.c:909
-#: mi/mi-out.c:321 mi/mi-out.c:339 mips-tdep.c:277 mips-tdep.c:336
-#: mips-tdep.c:1261 mips-tdep.c:3782 mips-tdep.c:4750 mn10300-tdep.c:88
-#: reggroups.c:214 remote.c:4600 utils.c:747 utils.c:766
-msgid "bad switch"
-msgstr ""
-
-#: cli/cli-script.c:1346
-#, possible-c-format
-msgid "Command \"%s\" is built-in."
-msgstr ""
-
-#: cli/cli-script.c:1418
-msgid "called with NULL file pointer!"
-msgstr ""
-
-#: cli/cli-script.c:1445
-#, possible-c-format
-msgid ""
-"%s:%d: Error in sourced command file:\n"
-"%s"
-msgstr ""
-
-#: cli/cli-script.c:1448
-msgid "bad reason"
-msgstr ""
-
-#: cli/cli-setshow.c:58
-msgid "\"on\", \"off\" or \"auto\" expected."
-msgstr ""
-
-#: cli/cli-setshow.c:87
-msgid "\"on\" or \"off\" expected."
-msgstr ""
-
-#: cli/cli-setshow.c:191
-msgid "filename to set it to."
-msgstr ""
-
-#: cli/cli-setshow.c:211 cli/cli-setshow.c:220 cli/cli-setshow.c:232
-msgid "integer to set it to."
-msgstr ""
-
-#: cli/cli-setshow.c:225
-#, possible-c-format
-msgid "integer %u out of range"
-msgstr ""
-
-#: cli/cli-setshow.c:261
-#, possible-c-format
-msgid "Requires an argument. Valid arguments are %s."
-msgstr ""
-
-#: cli/cli-setshow.c:289
-#, possible-c-format
-msgid "Undefined item: \"%s\"."
-msgstr ""
-
-#: cli/cli-setshow.c:292
-#, possible-c-format
-msgid "Ambiguous item \"%s\"."
-msgstr ""
-
-#: cli/cli-setshow.c:298 cli/cli-setshow.c:367
-msgid "gdb internal error: bad var_type in do_setshow_command"
-msgstr ""
-
-#: cli/cli-setshow.c:343
-msgid "do_setshow_command: invalid var_auto_boolean"
-msgstr ""
-
-#: cli/cli-setshow.c:391
-msgid "gdb internal error: bad cmd_type in do_setshow_command"
-msgstr ""
-
 #: coffread.c:579
 #, possible-c-format
 msgid "\"%s\": error reading line numbers."
@@ -9948,34 +9948,6 @@
 msgid "target memory map"
 msgstr ""
 
-#: mi/mi-cmd-break.c:129
-msgid "mi_cmd_break_insert: Missing <location>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:131
-msgid "mi_cmd_break_insert: Garbage following <location>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:156
-msgid "mi_cmd_break_insert: Unsupported tempoary regexp breakpoint"
-msgstr ""
-
-#: mi/mi-cmd-break.c:164
-msgid "mi_cmd_break_insert: Bad switch."
-msgstr ""
-
-#: mi/mi-cmd-break.c:222
-msgid "mi_cmd_break_watch: Missing <expression>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:224
-msgid "mi_cmd_break_watch: Garbage following <expression>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:240
-msgid "mi_cmd_break_watch: Unknown watchpoint type."
-msgstr ""
-
 #: mi/mi-cmd-disas.c:138
 msgid "mi_cmd_disassemble: Mixed_mode argument must be 0 or 1."
 msgstr ""
@@ -9992,28 +9964,13 @@
 msgid "mi_cmd_disassemble: No function contains specified address"
 msgstr ""
 
-#: mi/mi-cmd-env.c:71
-msgid "mi_cmd_env_pwd: No arguments required"
-msgstr ""
-
-#: mi/mi-cmd-env.c:92
-msgid "mi_cmd_env_cd: Usage DIRECTORY"
-msgstr ""
-
-#: mi/mi-cmd-env.c:261
-msgid "mi_cmd_inferior_tty_show: Usage: No args"
-msgstr ""
-
-#: mi/mi-cmd-file.c:39
-msgid "mi_cmd_file_list_exec_source_file: Usage: No args"
-msgstr ""
-
-#: mi/mi-cmd-file.c:49
-msgid "mi_cmd_file_list_exec_source_file: No symtab"
+#: mi/mi-common.c:50
+msgid "async_reason_string_lookup is inconsistent"
 msgstr ""
 
-#: mi/mi-cmd-file.c:75
-msgid "mi_cmd_file_list_exec_source_files: Usage: No args"
+#: mi/mi-cmds.c:243
+#, possible-c-format
+msgid "command `%s' appears to be duplicated"
 msgstr ""
 
 #: mi/mi-cmd-stack.c:50
@@ -10055,16 +10012,70 @@
 msgid "mi_cmd_stack_info_frame: No arguments required"
 msgstr ""
 
-#: mi/mi-cmd-target.c:40
-msgid "mi_cmd_target_file_get: Usage: REMOTE_FILE LOCAL_FILE"
+#: mi/mi-cmd-file.c:39
+msgid "mi_cmd_file_list_exec_source_file: Usage: No args"
 msgstr ""
 
-#: mi/mi-cmd-target.c:66
-msgid "mi_cmd_target_file_put: Usage: LOCAL_FILE REMOTE_FILE"
+#: mi/mi-cmd-file.c:49
+msgid "mi_cmd_file_list_exec_source_file: No symtab"
 msgstr ""
 
-#: mi/mi-cmd-target.c:92
-msgid "mi_cmd_target_file_delete: Usage: REMOTE_FILE"
+#: mi/mi-cmd-file.c:75
+msgid "mi_cmd_file_list_exec_source_files: Usage: No args"
+msgstr ""
+
+#: mi/mi-cmd-env.c:71
+msgid "mi_cmd_env_pwd: No arguments required"
+msgstr ""
+
+#: mi/mi-cmd-env.c:92
+msgid "mi_cmd_env_cd: Usage DIRECTORY"
+msgstr ""
+
+#: mi/mi-cmd-env.c:261
+msgid "mi_cmd_inferior_tty_show: Usage: No args"
+msgstr ""
+
+#: mi/mi-cmd-break.c:129
+msgid "mi_cmd_break_insert: Missing <location>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:131
+msgid "mi_cmd_break_insert: Garbage following <location>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:156
+msgid "mi_cmd_break_insert: Unsupported tempoary regexp breakpoint"
+msgstr ""
+
+#: mi/mi-cmd-break.c:164
+msgid "mi_cmd_break_insert: Bad switch."
+msgstr ""
+
+#: mi/mi-cmd-break.c:222
+msgid "mi_cmd_break_watch: Missing <expression>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:224
+msgid "mi_cmd_break_watch: Garbage following <expression>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:240
+msgid "mi_cmd_break_watch: Unknown watchpoint type."
+msgstr ""
+
+#: mi/mi-getopt.c:35
+msgid "mi_getopt_long: optind out of bounds"
+msgstr ""
+
+#: mi/mi-getopt.c:61
+#, possible-c-format
+msgid "%s: Option %s requires an argument"
+msgstr ""
+
+#: mi/mi-getopt.c:73
+#, possible-c-format
+msgid "%s: Unknown option ``%s''"
 msgstr ""
 
 #. mi_error_message = xstrprintf ("mi_cmd_var_create: Usage:
@@ -10221,47 +10232,36 @@
 msgid "mi_cmd_var_update: Variable object not found"
 msgstr ""
 
-#: mi/mi-cmds.c:243
-#, possible-c-format
-msgid "command `%s' appears to be duplicated"
-msgstr ""
-
-#: mi/mi-common.c:50
-msgid "async_reason_string_lookup is inconsistent"
-msgstr ""
-
-#: mi/mi-console.c:66
-msgid "mi_console_file_delete: bad magic number"
+#: mi/mi-symbol-cmds.c:39
+msgid "mi_cmd_symbol_list_lines: Usage: SOURCE_FILENAME"
 msgstr ""
 
-#: mi/mi-console.c:94
-msgid "mi_console_file_transform: bad magic number"
+#: mi/mi-symbol-cmds.c:45
+msgid "mi_cmd_symbol_list_lines: Unknown source file name."
 msgstr ""
 
-#: mi/mi-console.c:120
-msgid "mi_console_file_flush: bad magic number"
+#: mi/mi-cmd-target.c:40
+msgid "mi_cmd_target_file_get: Usage: REMOTE_FILE LOCAL_FILE"
 msgstr ""
 
-#: mi/mi-getopt.c:35
-msgid "mi_getopt_long: optind out of bounds"
+#: mi/mi-cmd-target.c:66
+msgid "mi_cmd_target_file_put: Usage: LOCAL_FILE REMOTE_FILE"
 msgstr ""
 
-#: mi/mi-getopt.c:61
-#, possible-c-format
-msgid "%s: Option %s requires an argument"
+#: mi/mi-cmd-target.c:92
+msgid "mi_cmd_target_file_delete: Usage: REMOTE_FILE"
 msgstr ""
 
-#: mi/mi-getopt.c:73
-#, possible-c-format
-msgid "%s: Unknown option ``%s''"
+#: mi/mi-console.c:66
+msgid "mi_console_file_delete: bad magic number"
 msgstr ""
 
-#: mi/mi-symbol-cmds.c:39
-msgid "mi_cmd_symbol_list_lines: Usage: SOURCE_FILENAME"
+#: mi/mi-console.c:94
+msgid "mi_console_file_transform: bad magic number"
 msgstr ""
 
-#: mi/mi-symbol-cmds.c:45
-msgid "mi_cmd_symbol_list_lines: Unknown source file name."
+#: mi/mi-console.c:120
+msgid "mi_console_file_flush: bad magic number"
 msgstr ""
 
 #: mips-linux-nat.c:66 mips-linux-nat.c:101
@@ -14460,13 +14460,6 @@
 "directory as the binary, then in the `"
 msgstr ""
 
-#: symfile.c:4180
-msgid ""
-"' subdirectory,\n"
-"and lastly at the path of the directory of the binary with\n"
-"the global debug-file directory prepended."
-msgstr ""
-
 #: symfile-mem.c:76
 msgid "add-symbol-file-from-memory not supported for this target"
 msgstr ""
@@ -15552,34 +15545,6 @@
 msgid "Register %s not available"
 msgstr ""
 
-#: tui/tui-file.c:78
-msgid "tui_file_delete: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:125
-msgid "tui_file_isatty: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:138
-msgid "tui_file_rewind: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:150
-msgid "tui_file_put: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:186
-msgid "tui_file_get_strbuf: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:200
-msgid "tui_file_adjust_strbuf: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:227
-msgid "tui_file_flush: bad magic number"
-msgstr ""
-
 #: tui/tui-hooks.c:82
 msgid "(y or n) "
 msgstr ""
@@ -15588,97 +15553,6 @@
 msgid "Please answer y or n.\n"
 msgstr ""
 
-#: tui/tui-interp.c:113
-msgid "tui_exec called"
-msgstr ""
-
-#: tui/tui-layout.c:381
-msgid ""
-"Change the layout of windows.\n"
-"Usage: layout prev | next | <layout_name> \n"
-"Layout names are:\n"
-"   src   : Displays source and command windows.\n"
-"   asm   : Displays disassembly and command windows.\n"
-"   split : Displays source, disassembly and command windows.\n"
-"   regs  : Displays register window. If existing layout\n"
-"           is source/command or assembly/command, the \n"
-"           register window is displayed. If the\n"
-"           source/assembly/command (split) is displayed, \n"
-"           the register window is displayed with \n"
-"           the window that has current logical focus.\n"
-msgstr ""
-
-#: tui/tui-layout.c:396
-msgid "Toggle between Source/Command and Disassembly/Command layouts.\n"
-msgstr ""
-
-#: tui/tui-layout.c:398
-msgid ""
-"Toggle between Source/Command or Disassembly/Command and \n"
-"Source/Disassembly/Command layouts.\n"
-msgstr ""
-
-#: tui/tui-layout.c:433
-msgid "Ambiguous command input."
-msgstr ""
-
-#: tui/tui-layout.c:600
-#, possible-c-format
-msgid ""
-"Invalid layout specified.\n"
-"%s"
-msgstr ""
-
-#: tui/tui-regs.c:601
-msgid "\"tui reg\" must be followed by the name of a tui reg command.\n"
-msgstr ""
-
-#: tui/tui-regs.c:614
-msgid "TUI commands to control the register window."
-msgstr ""
-
-#: tui/tui-regs.c:619
-msgid "Display only floating point registers."
-msgstr ""
-
-#: tui/tui-regs.c:622
-msgid "Display only general registers."
-msgstr ""
-
-#: tui/tui-regs.c:625
-msgid "Display only system registers."
-msgstr ""
-
-#: tui/tui-regs.c:628
-msgid "Display next register group."
-msgstr ""
-
-#: tui/tui-regs.c:634
-msgid "Display only floating point registers\n"
-msgstr ""
-
-#: tui/tui-regs.c:636
-msgid "Display only general registers\n"
-msgstr ""
-
-#: tui/tui-regs.c:638
-msgid "Display only special registers\n"
-msgstr ""
-
-#: tui/tui-regs.c:640
-msgid "Scroll the registers window forward\n"
-msgstr ""
-
-#: tui/tui-regs.c:642
-msgid "Scroll the register window backward\n"
-msgstr ""
-
-#: tui/tui-stack.c:417
-msgid ""
-"Update the source window and locator to display the current execution "
-"point.\n"
-msgstr ""
-
 #: tui/tui-win.c:211
 #, possible-c-format
 msgid "The attribute mode to use for the active TUI window border is \"%s\".\n"
@@ -15858,6 +15732,125 @@
 "%s"
 msgstr ""
 
+#: tui/tui-stack.c:417
+msgid ""
+"Update the source window and locator to display the current execution "
+"point.\n"
+msgstr ""
+
+#: tui/tui-layout.c:381
+msgid ""
+"Change the layout of windows.\n"
+"Usage: layout prev | next | <layout_name> \n"
+"Layout names are:\n"
+"   src   : Displays source and command windows.\n"
+"   asm   : Displays disassembly and command windows.\n"
+"   split : Displays source, disassembly and command windows.\n"
+"   regs  : Displays register window. If existing layout\n"
+"           is source/command or assembly/command, the \n"
+"           register window is displayed. If the\n"
+"           source/assembly/command (split) is displayed, \n"
+"           the register window is displayed with \n"
+"           the window that has current logical focus.\n"
+msgstr ""
+
+#: tui/tui-layout.c:396
+msgid "Toggle between Source/Command and Disassembly/Command layouts.\n"
+msgstr ""
+
+#: tui/tui-layout.c:398
+msgid ""
+"Toggle between Source/Command or Disassembly/Command and \n"
+"Source/Disassembly/Command layouts.\n"
+msgstr ""
+
+#: tui/tui-layout.c:433
+msgid "Ambiguous command input."
+msgstr ""
+
+#: tui/tui-layout.c:600
+#, possible-c-format
+msgid ""
+"Invalid layout specified.\n"
+"%s"
+msgstr ""
+
+#: tui/tui-interp.c:113
+msgid "tui_exec called"
+msgstr ""
+
+#: tui/tui-file.c:78
+msgid "tui_file_delete: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:125
+msgid "tui_file_isatty: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:138
+msgid "tui_file_rewind: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:150
+msgid "tui_file_put: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:186
+msgid "tui_file_get_strbuf: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:200
+msgid "tui_file_adjust_strbuf: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:227
+msgid "tui_file_flush: bad magic number"
+msgstr ""
+
+#: tui/tui-regs.c:601
+msgid "\"tui reg\" must be followed by the name of a tui reg command.\n"
+msgstr ""
+
+#: tui/tui-regs.c:614
+msgid "TUI commands to control the register window."
+msgstr ""
+
+#: tui/tui-regs.c:619
+msgid "Display only floating point registers."
+msgstr ""
+
+#: tui/tui-regs.c:622
+msgid "Display only general registers."
+msgstr ""
+
+#: tui/tui-regs.c:625
+msgid "Display only system registers."
+msgstr ""
+
+#: tui/tui-regs.c:628
+msgid "Display next register group."
+msgstr ""
+
+#: tui/tui-regs.c:634
+msgid "Display only floating point registers\n"
+msgstr ""
+
+#: tui/tui-regs.c:636
+msgid "Display only general registers\n"
+msgstr ""
+
+#: tui/tui-regs.c:638
+msgid "Display only special registers\n"
+msgstr ""
+
+#: tui/tui-regs.c:640
+msgid "Scroll the registers window forward\n"
+msgstr ""
+
+#: tui/tui-regs.c:642
+msgid "Scroll the register window backward\n"
+msgstr ""
+
 #: typeprint.c:262
 msgid "internal error: unhandled type in print_type_scalar"
 msgstr ""
diff -Naur gdb-6.8/gdb/printcmd.c stsgdb-6.8/gdb/printcmd.c
--- gdb-6.8/gdb/printcmd.c	2008-01-30 19:19:51.000000000 +0000
+++ stsgdb-6.8/gdb/printcmd.c	2008-09-11 10:35:35.000000000 +0100
@@ -47,6 +47,13 @@
 #include "tui/tui.h"		/* For tui_active et.al.   */
 #endif
 
+#if defined(__MINGW32__)
+# define USE_PRINTF_I64 1
+# define PRINTF_HAS_LONG_LONG
+#else
+# define USE_PRINTF_I64 0
+#endif
+
 extern int asm_demangle;	/* Whether to demangle syms in asm printouts */
 extern int addressprint;	/* Whether to print hex addresses in HLL " */
 
@@ -2009,8 +2016,23 @@
 		   *f);
 
 	  f++;
-	  strncpy (current_substring, last_arg, f - last_arg);
-	  current_substring += f - last_arg;
+
+	  if (lcount > 1 && USE_PRINTF_I64)
+	    {
+	      /* Windows' printf does support long long, but not the usual way.
+		 Convert %lld to %I64d.  */
+	      int length_before_ll = f - last_arg - 1 - lcount;
+	      strncpy (current_substring, last_arg, length_before_ll);
+	      strcpy (current_substring + length_before_ll, "I64");
+	      current_substring[length_before_ll + 3] =
+		last_arg[length_before_ll + lcount];
+	      current_substring += length_before_ll + 4;
+	    }
+	  else
+	    {
+	      strncpy (current_substring, last_arg, f - last_arg);
+	      current_substring += f - last_arg;
+	    }
 	  *current_substring++ = '\0';
 	  last_arg = f;
 	  argclass[nargs_wanted++] = this_argclass;
diff -Naur gdb-6.8/gdb/remote.c stsgdb-6.8/gdb/remote.c
--- gdb-6.8/gdb/remote.c	2008-02-25 09:59:06.000000000 +0000
+++ stsgdb-6.8/gdb/remote.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -2856,7 +2857,7 @@
   if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
     error (_("This target does not support attaching to a process"));
 
-  sprintf (rs->buf, "vAttach;%x", pid);
+  sprintf (rs->buf, "vAttach;%x", (unsigned int) pid);
   putpkt (rs->buf);
   getpkt (&rs->buf, &rs->buf_size, 0);
 
diff -Naur gdb-6.8/gdb/sh-tdep.c stsgdb-6.8/gdb/sh-tdep.c
--- gdb-6.8/gdb/sh-tdep.c	2008-01-11 13:20:02.000000000 +0000
+++ stsgdb-6.8/gdb/sh-tdep.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
    2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2007 STMicroelectronics
 
    This file is part of GDB.
 
@@ -43,6 +44,7 @@
 #include "doublest.h"
 #include "osabi.h"
 #include "reggroups.h"
+#include "sim-regno.h"
 
 #include "sh-tdep.h"
 
@@ -54,9 +56,7 @@
 /* registers numbers shared with the simulator */
 #include "gdb/sim-sh.h"
 
-static void (*sh_show_regs) (struct frame_info *);
-
-#define SH_NUM_REGS 67
+#define SH_NUM_REGS 109
 
 struct sh_frame_cache
 {
@@ -80,13 +80,6 @@
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -102,13 +95,12 @@
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     "ssr", "spc",
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
-    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1"
-    "", "", "", "", "", "", "", "",
+    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
   };
   if (reg_nr < 0)
     return NULL;
@@ -130,7 +122,6 @@
     "ssr", "spc",
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
     "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -149,10 +140,6 @@
     "fpul", "fpscr",
     "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
     "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -176,7 +163,7 @@
     "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
     "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
     /* 41, 42 */
-    "", "",
+    NULL, NULL,
     /* 43 - 62.  Banked registers.  The bank number used is determined by
        the bank register (63). */
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
@@ -185,13 +172,20 @@
     /* 63: register bank number, not a real register but used to
        communicate the register bank currently get/set.  This register
        is hidden to the user, who manipulates it using the pseudo
-       register called "bank" (67).  See below.  */
-    "",
+       register called "bank" (109).  See below.  */
+    NULL,
     /* 64 - 66 */
     "ibcr", "ibnr", "tbr",
-    /* 67: register bank number, the user visible pseudo register.  */
+    /* 67 - 108 */
+    NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    /* 109: register bank number, the user visible pseudo register.  */
     "bank",
-    /* double precision (pseudo) 68 - 75 */
+    /* double precision (pseudo) 110 - 117 */
     "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
   };
   if (reg_nr < 0)
@@ -211,12 +205,12 @@
     /* 16 - 22 */
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
     /* 23, 24 */
-    "", "",
+    NULL, NULL,
     /* floating point registers 25 - 40 */
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     /* 41, 42 */
-    "", "",
+    NULL, NULL,
     /* 43 - 62.  Banked registers.  The bank number used is determined by
        the bank register (63). */
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
@@ -225,14 +219,19 @@
     /* 63: register bank number, not a real register but used to
        communicate the register bank currently get/set.  This register
        is hidden to the user, who manipulates it using the pseudo
-       register called "bank" (67).  See below.  */
-    "",
+       register called "bank" (109).  See below.  */
+    NULL,
     /* 64 - 66 */
     "ibcr", "ibnr", "tbr",
-    /* 67: register bank number, the user visible pseudo register.  */
+    /* 67 - 108 */
+    NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    /* 109: register bank number, the user visible pseudo register.  */
     "bank",
-    /* double precision (pseudo) 68 - 75 */
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -248,13 +247,11 @@
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "dsr",
+    NULL, "dsr",
     "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
-    "y0", "y1", "", "", "", "", "", "mod",
-    "", "",
-    "rs", "re", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    "y0", "y1", NULL, NULL, NULL, NULL, NULL, "mod",
+    NULL, NULL,
+    "rs", "re",
   };
   if (reg_nr < 0)
     return NULL;
@@ -270,14 +267,12 @@
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "dsr",
+    NULL, "dsr",
     "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
-    "y0", "y1", "", "", "", "", "", "mod",
+    "y0", "y1", NULL, NULL, NULL, NULL, NULL, "mod",
     "ssr", "spc",
-    "rs", "re", "", "", "", "", "", "",
+    "rs", "re", NULL, NULL, NULL, NULL, NULL, NULL,
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -297,7 +292,7 @@
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
     /* 23, 24 */
     "fpul", "fpscr",
-    /* floating point registers 25 - 40 */
+    /* floating point 25 - 40 */
     "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
     "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
     /* 41, 42 */
@@ -306,15 +301,25 @@
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
     /* bank 1 51 - 58 */
     "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
-    "", "", "", "", "", "", "", "",
-    /* pseudo bank register. */
-    "",
-    /* double precision (pseudo) 59 - 66 */
+    /* 59, 60 */
+    "dbr", "sgr",
+    /* extended floating point 61 - 76 */
+    "xf0", "xf1", "xf2", "xf3", "xf4", "xf5", "xf6", "xf7",
+    "xf8", "xf9", "xf10", "xf11", "xf12", "xf13", "xf14", "xf15",
+    /* floating point bank 0 77 - 92 */
+    "fr0b0", "fr1b0", "fr2b0", "fr3b0", "fr4b0", "fr5b0", "fr6b0", "fr7b0",
+    "fr8b0", "fr9b0", "fr10b0", "fr11b0", "fr12b0", "fr13b0", "fr14b0", "fr15b0",
+    /* floating point bank 1 93 - 108 */
+    "fr0b1", "fr1b1", "fr2b1", "fr3b1", "fr4b1", "fr5b1", "fr6b1", "fr7b1",
+    "fr8b1", "fr9b1", "fr10b1", "fr11b1", "fr12b1", "fr13b1", "fr14b1", "fr15b1",
+    /* 109 */
+    NULL,
+    /* double precision (pseudo) 110 - 117 */
     "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
-    /* vectors (pseudo) 67 - 70 */
+    /* extended double precision (pseudo) 118 - 125 */
+    "xd0", "xd2", "xd4", "xd6", "xd8", "xd10", "xd12", "xd14",
+    /* vectors (pseudo) 126 - 129 */
     "fv0", "fv4", "fv8", "fv12",
-    /* FIXME: missing XF 71 - 86 */
-    /* FIXME: missing XD 87 - 94 */
   };
   if (reg_nr < 0)
     return NULL;
@@ -333,23 +338,18 @@
     /* 16 - 22 */
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
     /* 23, 24 */
-    "", "",
+    NULL, NULL,
     /* floating point registers 25 - 40 -- not for nofpu target */
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     /* 41, 42 */
     "ssr", "spc",
     /* bank 0 43 - 50 */
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
     /* bank 1 51 - 58 */
     "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
-    "", "", "", "", "", "", "", "",
-    /* pseudo bank register. */
-    "",
-    /* double precision (pseudo) 59 - 66 -- not for nofpu target */
-    "", "", "", "", "", "", "", "",
-    /* vectors (pseudo) 67 - 70 -- not for nofpu target */
-    "", "", "", "",
+    /* 59, 60 */
+    "dbr", "sgr",
   };
   if (reg_nr < 0)
     return NULL;
@@ -365,14 +365,12 @@
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "dsr",
+    NULL, "dsr",
     "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
-    "y0", "y1", "", "", "", "", "", "mod",
+    "y0", "y1", NULL, NULL, NULL, NULL, NULL, "mod",
     "ssr", "spc",
-    "rs", "re", "", "", "", "", "", "",
+    "rs", "re", NULL, NULL, NULL, NULL, NULL, NULL,
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -419,33 +417,33 @@
    Actually it can be more complicated than this but that's it, basically.
  */
 
-#define GET_SOURCE_REG(x)  	(((x) >> 4) & 0xf)
-#define GET_TARGET_REG(x)  	(((x) >> 8) & 0xf)
+#define GET_SOURCE_REG(x)	(((x) >> 4) & 0xf)
+#define GET_TARGET_REG(x)	(((x) >> 8) & 0xf)
 
 /* JSR @Rm         0100mmmm00001011 */
 #define IS_JSR(x)		(((x) & 0xf0ff) == 0x400b)
 
 /* STS.L PR,@-r15  0100111100100010
    r15-4-->r15, PR-->(r15) */
-#define IS_STS(x)  		((x) == 0x4f22)
+#define IS_STS(x)		((x) == 0x4f22)
 
 /* STS.L MACL,@-r15  0100111100010010
    r15-4-->r15, MACL-->(r15) */
-#define IS_MACL_STS(x)  	((x) == 0x4f12)
+#define IS_MACL_STS(x)		((x) == 0x4f12)
 
 /* MOV.L Rm,@-r15  00101111mmmm0110
    r15-4-->r15, Rm-->(R15) */
-#define IS_PUSH(x) 		(((x) & 0xff0f) == 0x2f06)
+#define IS_PUSH(x)		(((x) & 0xff0f) == 0x2f06)
 
 /* MOV r15,r14     0110111011110011
    r15-->r14  */
-#define IS_MOV_SP_FP(x)  	((x) == 0x6ef3)
+#define IS_MOV_SP_FP(x)		((x) == 0x6ef3)
 
 /* ADD #imm,r15    01111111iiiiiiii
    r15+imm-->r15 */
-#define IS_ADD_IMM_SP(x) 	(((x) & 0xff00) == 0x7f00)
+#define IS_ADD_IMM_SP(x)	(((x) & 0xff00) == 0x7f00)
 
-#define IS_MOV_R3(x) 		(((x) & 0xff00) == 0x1a00)
+#define IS_MOV_R3(x)		(((x) & 0xff00) == 0x1a00)
 #define IS_SHLL_R3(x)		((x) == 0x4300)
 
 /* ADD r3,r15      0011111100111100
@@ -485,16 +483,19 @@
 /* SUB Rn,R15                 00111111nnnn1000 */
 #define IS_SUB_REG_FROM_SP(x)	(((x) & 0xff0f) == 0x3f08)
 
+#define SR_RB			(1 << 29)
+#define FPSCR_PR		(1 << 19)
 #define FPSCR_SZ		(1 << 20)
+#define FPSCR_FR		(1 << 21)
 
 /* The following instructions are used for epilogue testing. */
 #define IS_RESTORE_FP(x)	((x) == 0x6ef6)
 #define IS_RTS(x)		((x) == 0x000b)
-#define IS_LDS(x)  		((x) == 0x4f26)
-#define IS_MACL_LDS(x)  	((x) == 0x4f16)
-#define IS_MOV_FP_SP(x)  	((x) == 0x6fe3)
+#define IS_LDS(x)		((x) == 0x4f26)
+#define IS_MACL_LDS(x)		((x) == 0x4f16)
+#define IS_MOV_FP_SP(x)		((x) == 0x6fe3)
 #define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
-#define IS_ADD_IMM_FP(x) 	(((x) & 0xff00) == 0x7e00)
+#define IS_ADD_IMM_FP(x)	(((x) & 0xff00) == 0x7e00)
 
 /* Disassemble an instruction.  */
 static int
@@ -584,12 +585,12 @@
 	    }
 	}
       else if (IS_MOVI20 (inst))
-        {
+	{
 	  if (sav_reg < 0)
 	    {
 	      reg = GET_TARGET_REG (inst);
 	      if (reg < 14)
-	        {
+		{
 		  sav_reg = reg;
 		  sav_offset = GET_SOURCE_REG (inst) << 16;
 		  /* MOVI20 is a 32 bit instruction! */
@@ -770,7 +771,7 @@
    the return value from foo() will be in memory, not
    in R0, because there is no 3-byte integer type.
 
-   Similarly, in 
+   Similarly, in
 
    struct s { char c[2]; } wibble;
    struct s foo(void) {  return wibble; }
@@ -783,31 +784,80 @@
 */
 
 static int
-sh_use_struct_convention (int gcc_p, struct type *type)
+sh_type_align (struct type *type)
 {
   int len = TYPE_LENGTH (type);
-  int nelem = TYPE_NFIELDS (type);
 
-  /* Non-power of 2 length types and types bigger than 8 bytes (which don't
-     fit in two registers anyway) use struct convention.  */
-  if (len != 1 && len != 2 && len != 4 && len != 8)
-    return 1;
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_STRUCT:
+    case TYPE_CODE_UNION:
+      {
+	int i, align = 1;
+	for (i = 0; i < TYPE_NFIELDS (type); i++)
+	  {
+	    int falign = sh_type_align (TYPE_FIELD_TYPE (type, i));
+	    if (falign > align)
+	      align = falign;
+	  }
+	return align;
+      }
+    case TYPE_CODE_ARRAY:
+    case TYPE_CODE_COMPLEX:
+      return sh_type_align (TYPE_TARGET_TYPE (type));
+    case TYPE_CODE_TYPEDEF:
+      return sh_type_align (check_typedef (type));
+    }
 
-  /* Scalar types and aggregate types with exactly one field are aligned
-     by definition.  They are returned in registers.  */
-  if (nelem <= 1)
-    return 0;
+  /* Assume scalar type with maximum alignment of 4 bytes.  */
+  return (len > 4) ? 4 : len;
+}
 
-  /* If the first field in the aggregate has the same length as the entire
-     aggregate type, the type is returned in registers.  */
-  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == len)
-    return 0;
+static int
+sh_treat_as_complex (struct type *type)
+{
+  switch (TYPE_CODE (type))
+    {
+    /* Complex int types are represented as simple int types.  */
+    case TYPE_CODE_INT:
+    case TYPE_CODE_COMPLEX:
+      return 1;
+    case TYPE_CODE_STRUCT:
+      /* Structs with one member maybe treated as complex.  */
+      if (TYPE_NFIELDS (type) == 1)
+	return sh_treat_as_complex (TYPE_FIELD_TYPE (type, 0));
+      break;
+    case TYPE_CODE_ARRAY:
+      /* Arrays with one element maybe treated as complex.  */
+      if (TYPE_LENGTH (type) == TYPE_LENGTH (TYPE_TARGET_TYPE (type)))
+	return sh_treat_as_complex (TYPE_TARGET_TYPE (type));
+      break;
+    case TYPE_CODE_TYPEDEF:
+      return sh_treat_as_complex (check_typedef (type));
+    }
 
-  /* If the size of the aggregate is 8 bytes and the first field is
-     of size 4 bytes its alignment is equal to long long's alignment,
-     so it's returned in registers.  */
-  if (len == 8 && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)
-    return 0;
+  /* Otherwise it's not treated as complex.  */
+  return 0;
+}
+
+static int
+sh_use_struct_convention (struct type *type)
+{
+  int len = TYPE_LENGTH (type);
+  int align = sh_type_align (type);
+
+  /* Check for register convention.  */
+  switch (len)
+    {
+    case 1:
+    case 2:
+    case 4:
+      return (align != len);
+    case 8:
+      return (align != 4);
+    case 16:
+      return (align != 4) || !sh_treat_as_complex (type);
+    }
 
   /* Otherwise use struct convention.  */
   return 1;
@@ -832,16 +882,16 @@
    manner, but using FP registers instead of GP registers.
 
    Arguments that are smaller than 4 bytes will still take up a whole
-   register or a whole 32-bit word on the stack, and will be 
+   register or a whole 32-bit word on the stack, and will be
    right-justified in the register or the stack word.  This includes
    chars, shorts, and small aggregate types.
 
-   Arguments that are larger than 4 bytes may be split between two or 
+   Arguments that are larger than 4 bytes may be split between two or
    more registers.  If there are not enough registers free, an argument
    may be passed partly in a register (or registers), and partly on the
-   stack.  This includes doubles, long longs, and larger aggregates. 
-   As far as I know, there is no upper limit to the size of aggregates 
-   that will be passed in this way; in other words, the convention of 
+   stack.  This includes doubles, long longs, and larger aggregates.
+   As far as I know, there is no upper limit to the size of aggregates
+   that will be passed in this way; in other words, the convention of
    passing a pointer to a large aggregate instead of a copy is not used.
 
    MVS: The above appears to be true for the SH variants that do not
@@ -850,24 +900,24 @@
    if it is larger than 16 bytes (four GP registers).
 
    An exceptional case exists for struct arguments (and possibly other
-   aggregates such as arrays) if the size is larger than 4 bytes but 
-   not a multiple of 4 bytes.  In this case the argument is never split 
+   aggregates such as arrays) if the size is larger than 4 bytes but
+   not a multiple of 4 bytes.  In this case the argument is never split
    between the registers and the stack, but instead is copied in its
-   entirety onto the stack, AND also copied into as many registers as 
-   there is room for.  In other words, space in registers permitting, 
+   entirety onto the stack, AND also copied into as many registers as
+   there is room for.  In other words, space in registers permitting,
    two copies of the same argument are passed in.  As far as I can tell,
-   only the one on the stack is used, although that may be a function 
+   only the one on the stack is used, although that may be a function
    of the level of compiler optimization.  I suspect this is a compiler
-   bug.  Arguments of these odd sizes are left-justified within the 
-   word (as opposed to arguments smaller than 4 bytes, which are 
+   bug.  Arguments of these odd sizes are left-justified within the
+   word (as opposed to arguments smaller than 4 bytes, which are
    right-justified).
 
-   If the function is to return an aggregate type such as a struct, it 
-   is either returned in the normal return value register R0 (if its 
+   If the function is to return an aggregate type such as a struct, it
+   is either returned in the normal return value register R0 (if its
    size is no greater than one byte), or else the caller must allocate
    space into which the callee will copy the return value (if the size
-   is greater than one byte).  In this case, a pointer to the return 
-   value location is passed into the callee in register R2, which does 
+   is greater than one byte).  In this case, a pointer to the return
+   value location is passed into the callee in register R2, which does
    not displace any of the other arguments passed in via registers R4
    to R7.   */
 
@@ -916,7 +966,7 @@
 
 /* This function returns the next register to use for float arg passing.
    It returns either a valid value between FLOAT_ARG0_REGNUM and
-   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns 
+   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns
    FLOAT_ARGLAST_REGNUM + 1 to indicate that no register is available.
 
    Note that register number 0 in flt_argreg_array corresponds with the
@@ -984,6 +1034,8 @@
 
      double d;
 
+   The same is also true for arrays of float type with exactly one element.
+
    As a result, arguments of these struct types are pushed into floating point
    registers exactly as floats or doubles, using the same decision algorithm.
 
@@ -994,21 +1046,28 @@
 static int
 sh_treat_as_flt_p (struct type *type)
 {
-  int len = TYPE_LENGTH (type);
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_FLT:
+      /* Ordinary float types are obviously treated as float.  */
+      return 1;
+    case TYPE_CODE_STRUCT:
+      /* Structs with one member maybe treated as float.  */
+      if (TYPE_NFIELDS (type) == 1)
+	return sh_treat_as_flt_p (TYPE_FIELD_TYPE (type, 0));
+      break;
+    case TYPE_CODE_ARRAY:
+      /* Arrays with one element maybe treated as float.  */
+      if (TYPE_LENGTH (type) == TYPE_LENGTH (TYPE_TARGET_TYPE (type)))
+	return sh_treat_as_flt_p (TYPE_TARGET_TYPE (type));
+      break;
+    case TYPE_CODE_COMPLEX:
+      /* Complex types maybe treated as float.  */
+      return sh_treat_as_flt_p (TYPE_TARGET_TYPE (type));
+    case TYPE_CODE_TYPEDEF:
+      return sh_treat_as_flt_p (check_typedef (type));
+    }
 
-  /* Ordinary float types are obviously treated as float.  */
-  if (TYPE_CODE (type) == TYPE_CODE_FLT)
-    return 1;
-  /* Otherwise non-struct types are not treated as float.  */
-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)
-    return 0;
-  /* Otherwise structs with more than one memeber are not treated as float.  */
-  if (TYPE_NFIELDS (type) != 1)
-    return 0;
-  /* Otherwise if the type of that member is float, the whole type is
-     treated as float.  */
-  if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT)
-    return 1;
   /* Otherwise it's not treated as float.  */
   return 0;
 }
@@ -1056,7 +1115,7 @@
       val = sh_justify_value_in_reg (gdbarch, args[argnum], len);
 
       /* Some decisions have to be made how various types are handled.
-         This also differs in different ABIs. */
+	 This also differs in different ABIs. */
       pass_on_stack = 0;
 
       /* Find out the next register to use for a floating point value. */
@@ -1073,7 +1132,7 @@
 	{
 	  if ((treat_as_flt && flt_argreg > FLOAT_ARGLAST_REGNUM)
 	      || (!treat_as_flt && (argreg > ARGLAST_REGNUM
-	                            || pass_on_stack)))
+				    || pass_on_stack)))
 	    {
 	      /* The data goes entirely on the stack, 4-byte aligned. */
 	      reg_size = (len + 3) & ~3;
@@ -1086,15 +1145,15 @@
 	      reg_size = register_size (gdbarch, flt_argreg);
 	      regval = extract_unsigned_integer (val, reg_size);
 	      /* In little endian mode, float types taking two registers
-	         (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
+		 (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
 		 be stored swapped in the argument registers.  The below
 		 code first writes the first 32 bits in the next but one
 		 register, increments the val and len values accordingly
 		 and then proceeds as normal by writing the second 32 bits
 		 into the next register. */
 	      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE
-	          && TYPE_LENGTH (type) == 2 * reg_size)
-	        {
+		  && TYPE_LENGTH (type) == 2 * reg_size)
+		{
 		  regcache_cooked_write_unsigned (regcache, flt_argreg + 1,
 						  regval);
 		  val += reg_size;
@@ -1167,7 +1226,7 @@
 	  if (argreg > ARGLAST_REGNUM)
 	    {
 	      /* The remainder of the data goes entirely on the stack,
-	         4-byte aligned. */
+		 4-byte aligned. */
 	      reg_size = (len + 3) & ~3;
 	      write_memory (sp + stack_offset, val, reg_size);
 	      stack_offset += reg_size;
@@ -1206,24 +1265,20 @@
 			       void *valbuf)
 {
   int len = TYPE_LENGTH (type);
-  int return_register = R0_REGNUM;
-  int offset;
 
   if (len <= 4)
     {
-      ULONGEST c;
+      ULONGEST val;
 
-      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &c);
-      store_unsigned_integer (valbuf, len, c);
+      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &val);
+      store_unsigned_integer (valbuf, len, val);
     }
-  else if (len == 8)
+  else
     {
       int i, regnum = R0_REGNUM;
       for (i = 0; i < len; i += 4)
 	regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
     }
-  else
-    error (_("bad size for return value"));
 }
 
 static void
@@ -1234,7 +1289,7 @@
   if (sh_treat_as_flt_p (type))
     {
       int len = TYPE_LENGTH (type);
-      int i, regnum = gdbarch_fp0_regnum (gdbarch);
+      int i, regnum = FR0_REGNUM;
       for (i = 0; i < len; i += 4)
 	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
 	  regcache_raw_read (regcache, regnum++, (char *) valbuf + len - 4 - i);
@@ -1248,18 +1303,19 @@
 /* Write into appropriate registers a function return value
    of type TYPE, given in virtual format.
    If the architecture is sh4 or sh3e, store a function's return value
-   in the R0 general register or in the FP0 floating point register,
+   in the R0 general register or in the FR0 floating point register,
    depending on the type of the return value. In all the other cases
    the result is stored in r0, left-justified. */
 static void
 sh_store_return_value_nofpu (struct type *type, struct regcache *regcache,
 			     const void *valbuf)
 {
-  ULONGEST val;
   int len = TYPE_LENGTH (type);
 
   if (len <= 4)
     {
+      ULONGEST val;
+
       val = extract_unsigned_integer (valbuf, len);
       regcache_cooked_write_unsigned (regcache, R0_REGNUM, val);
     }
@@ -1279,7 +1335,7 @@
   if (sh_treat_as_flt_p (type))
     {
       int len = TYPE_LENGTH (type);
-      int i, regnum = gdbarch_fp0_regnum (gdbarch);
+      int i, regnum = FR0_REGNUM;
       for (i = 0; i < len; i += 4)
 	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
 	  regcache_raw_write (regcache, regnum++,
@@ -1296,7 +1352,7 @@
 		       struct regcache *regcache,
 		       gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  if (sh_use_struct_convention (0, type))
+  if (sh_use_struct_convention (type))
     return RETURN_VALUE_STRUCT_CONVENTION;
   if (writebuf)
     sh_store_return_value_nofpu (type, regcache, writebuf);
@@ -1310,7 +1366,7 @@
 		     struct regcache *regcache,
 		     gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  if (sh_use_struct_convention (0, type))
+  if (sh_use_struct_convention (type))
     return RETURN_VALUE_STRUCT_CONVENTION;
   if (writebuf)
     sh_store_return_value_fpu (type, regcache, writebuf);
@@ -1364,6 +1420,9 @@
 static void
 sh3_show_regs (struct frame_info *frame)
 {
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
@@ -1403,16 +1462,26 @@
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
+  printf_filtered
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
 }
 
 static void
 sh2e_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
@@ -1451,53 +1520,37 @@
      (long) get_frame_register_unsigned (frame, 15));
 
   printf_filtered
-    ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
-  printf_filtered
-    ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+    ("FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
+  printf_filtered
+    ("FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
 }
 
 static void
 sh2a_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
-  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;
+  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & FPSCR_PR;
 
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
@@ -1538,42 +1591,26 @@
 
   printf_filtered
     (pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
+	: "FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
   printf_filtered
     (pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+	: "FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
   printf_filtered
     ("BANK=%-3d\n", (int) get_frame_register_unsigned (frame, BANK_REGNUM));
   printf_filtered
@@ -1607,8 +1644,6 @@
 static void
 sh2a_nofpu_show_regs (struct frame_info *frame)
 {
-  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;
-
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
@@ -1685,11 +1720,14 @@
 static void
 sh3e_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
@@ -1726,43 +1764,37 @@
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
-
   printf_filtered
-    ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
-  printf_filtered
-    ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
+
+  printf_filtered
+    ("FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
+  printf_filtered
+    ("FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
 }
 
 static void
@@ -1832,26 +1864,32 @@
 static void
 sh4_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
-  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & FPSCR_PR;
 
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
 
   printf_filtered
-    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
+    ("     GBR %08lx      VBR %08lx      DBR %08lx     MACL %08lx\n",
      (long) get_frame_register_unsigned (frame, GBR_REGNUM),
      (long) get_frame_register_unsigned (frame, VBR_REGNUM),
+     (long) get_frame_register_unsigned (frame, DBR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACL_REGNUM));
   printf_filtered
-    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
+    ("     SSR %08lx      SPC %08lx      SGR %08lx\n",
      (long) get_frame_register_unsigned (frame, SSR_REGNUM),
      (long) get_frame_register_unsigned (frame, SPC_REGNUM),
+     (long) get_frame_register_unsigned (frame, SGR_REGNUM));
+  printf_filtered
+    ("    FPUL %08lx    FPSCR %08lx\n",
      (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
      (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));
 
@@ -1875,50 +1913,70 @@
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
+  printf_filtered
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
 
   printf_filtered
     (pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
+	: "FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
   printf_filtered
     (pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+	: "FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
+
+  printf_filtered
+    (pr ? "XD0-XD6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
+        : "XF0-XF7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 7));
+  printf_filtered
+    (pr ? "XD8-XD14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
+        : "XF8-XF15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 15));
 }
 
 static void
 sh4_nofpu_show_regs (struct frame_info *frame)
 {
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
@@ -1929,16 +1987,16 @@
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
 
   printf_filtered
-    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
+    ("     GBR %08lx      VBR %08lx      DBR %08lx     MACL %08lx\n",
      (long) get_frame_register_unsigned (frame, GBR_REGNUM),
      (long) get_frame_register_unsigned (frame, VBR_REGNUM),
+     (long) get_frame_register_unsigned (frame, DBR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACL_REGNUM));
   printf_filtered
-    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
+    ("     SSR %08lx      SPC %08lx      SGR %08lx\n",
      (long) get_frame_register_unsigned (frame, SSR_REGNUM),
      (long) get_frame_register_unsigned (frame, SPC_REGNUM),
-     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
-     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));
+     (long) get_frame_register_unsigned (frame, SGR_REGNUM));
 
   printf_filtered
     ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
@@ -1960,6 +2018,16 @@
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
+  printf_filtered
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
 }
 
 static void
@@ -2023,18 +2091,81 @@
 static void
 sh_show_regs_command (char *args, int from_tty)
 {
-  if (sh_show_regs)
-    (*sh_show_regs) (get_current_frame ());
+  struct frame_info *frame = get_current_frame ();
+
+  switch (gdbarch_bfd_arch_info (get_frame_arch (frame))->mach)
+    {
+    case bfd_mach_sh2e:
+      sh2e_show_regs (frame);
+      break;
+
+    case bfd_mach_sh2a:
+      sh2a_show_regs (frame);
+      break;
+
+    case bfd_mach_sh2a_nofpu:
+      sh2a_nofpu_show_regs (frame);
+      break;
+
+    case bfd_mach_sh_dsp:
+      sh_dsp_show_regs (frame);
+      break;
+
+    case bfd_mach_sh3:
+    case bfd_mach_sh3_nommu:
+    case bfd_mach_sh2a_nofpu_or_sh3_nommu:
+      sh3_show_regs (frame);
+      break;
+
+    case bfd_mach_sh3e:
+    case bfd_mach_sh2a_or_sh3e:
+      sh3e_show_regs (frame);
+      break;
+
+    case bfd_mach_sh3_dsp:
+    case bfd_mach_sh4al_dsp:
+      sh3_dsp_show_regs (frame);
+      break;
+
+    case bfd_mach_sh4:
+    case bfd_mach_sh4a:
+    case bfd_mach_st40_300:
+    case bfd_mach_st40_300_or_sh4a:
+      sh4_show_regs (frame);
+      break;
+
+    case bfd_mach_sh4_nofpu:
+    case bfd_mach_sh4a_nofpu:
+    case bfd_mach_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_or_sh4:
+    case bfd_mach_st40_300_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh2a_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh4a_nofpu:
+      sh4_nofpu_show_regs (frame);
+      break;
+
+    case bfd_mach_sh5:
+      sh64_show_regs (frame);
+      break;
+
+    default:
+      sh_generic_show_regs (frame);
+      break;
+    }
 }
 
 static struct type *
 sh_sh2a_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
-       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
+  if ((reg_nr >= FR0_REGNUM && reg_nr <= FR_LAST_REGNUM)
+      || (reg_nr == FPUL_REGNUM))
     return builtin_type_float;
   else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
     return builtin_type_double;
+  else if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
   else
     return builtin_type_int;
 }
@@ -2044,9 +2175,12 @@
 static struct type *
 sh_sh3e_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
-       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
+  if ((reg_nr >= FR0_REGNUM && reg_nr <= FR_LAST_REGNUM)
+      || (reg_nr == FPUL_REGNUM))
     return builtin_type_float;
+  else if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
   else
     return builtin_type_int;
 }
@@ -2063,13 +2197,20 @@
 static struct type *
 sh_sh4_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
-       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
+  if ((reg_nr >= FR0_REGNUM && reg_nr <= FR_LAST_REGNUM)
+      || (reg_nr >= XF0_REGNUM && reg_nr <= XF_LAST_REGNUM)
+      || (reg_nr >= FR0_BANK0_REGNUM && reg_nr <= FR_BANK0_LAST_REGNUM)
+      || (reg_nr >= FR0_BANK1_REGNUM && reg_nr <= FR_BANK1_LAST_REGNUM)
+      || (reg_nr == FPUL_REGNUM))
     return builtin_type_float;
-  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+  else if ((reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+	   || (reg_nr >= XD0_REGNUM && reg_nr <= XD_LAST_REGNUM))
     return builtin_type_double;
   else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
-    return sh_sh4_build_float_register_type (3);
+    return sh_sh4_build_float_register_type (FV_LAST_REGNUM - FV0_REGNUM);
+  else if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
   else
     return builtin_type_int;
 }
@@ -2077,7 +2218,11 @@
 static struct type *
 sh_default_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  return builtin_type_int;
+  if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
+  else
+    return builtin_type_int;
 }
 
 /* Is a register in a reggroup?
@@ -2092,9 +2237,7 @@
       || *gdbarch_register_name (gdbarch, regnum) == '\0')
     return 0;
 
-  if (reggroup == float_reggroup
-      && (regnum == FPUL_REGNUM
-	  || regnum == FPSCR_REGNUM))
+  if (reggroup == float_reggroup && regnum == FPSCR_REGNUM)
     return 1;
 
   if (regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM)
@@ -2106,8 +2249,10 @@
     }
 
   if (regnum == VBR_REGNUM
+      || regnum == DBR_REGNUM
       || regnum == SR_REGNUM
       || regnum == FPSCR_REGNUM
+      || regnum == SGR_REGNUM
       || regnum == SSR_REGNUM
       || regnum == SPC_REGNUM)
     {
@@ -2124,9 +2269,9 @@
 /* On the sh4, the DRi pseudo registers are problematic if the target
    is little endian. When the user writes one of those registers, for
    instance with 'ser var $dr0=1', we want the double to be stored
-   like this: 
-   fr0 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f 
-   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
+   like this:
+   fr0 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f
+   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
 
    This corresponds to little endian byte order & big endian word
    order.  However if we let gdb write the register w/o conversion, it
@@ -2134,7 +2279,7 @@
    fr0 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
    fr1 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f
    because it will consider fr0 and fr1 as a single LE stretch of memory.
-   
+
    To achieve what we want we must force gdb to store things in
    floatformat_ieee_double_littlebyte_bigword (which is defined in
    include/floatformat.h and libiberty/floatformat.c.
@@ -2142,7 +2287,7 @@
    In case the target is big endian, there is no problem, the
    raw bytes will look like:
    fr0 = 0x3f 0xf0 0x00 0x00 0x00 0x00 0x00
-   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
+   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
 
    The other pseudo registers (the FVs) also don't pose a problem
    because they are stored as 4 individual FP elements. */
@@ -2151,7 +2296,8 @@
 sh_register_convert_to_virtual (int regnum, struct type *type,
 				char *from, char *to)
 {
-  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+  if ((regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+      || (regnum >= XD0_REGNUM && regnum <= XD_LAST_REGNUM))
     {
       DOUBLEST val;
       floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
@@ -2167,7 +2313,8 @@
 sh_register_convert_to_raw (struct type *type, int regnum,
 			    const void *from, void *to)
 {
-  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+  if ((regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+      || (regnum >= XD0_REGNUM && regnum <= XD_LAST_REGNUM))
     {
       DOUBLEST val = extract_typed_floating (from, type);
       floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword,
@@ -2181,22 +2328,24 @@
 static int
 fv_reg_base_num (struct gdbarch *gdbarch, int fv_regnum)
 {
-  int fp_regnum;
+  int fr_regnum;
 
-  fp_regnum = gdbarch_fp0_regnum (gdbarch)
-	      + (fv_regnum - FV0_REGNUM) * 4;
-  return fp_regnum;
+  fr_regnum = FR0_REGNUM + (fv_regnum - FV0_REGNUM) * 4;
+  return fr_regnum;
 }
 
 /* For double precision floating point registers, i.e 2 fp regs.*/
 static int
 dr_reg_base_num (struct gdbarch *gdbarch, int dr_regnum)
 {
-  int fp_regnum;
+  int fr_regnum;
+
+  if (dr_regnum >= DR0_REGNUM && dr_regnum <= DR_LAST_REGNUM)
+    fr_regnum = FR0_REGNUM + (dr_regnum - DR0_REGNUM) * 2;
+  else
+    fr_regnum = XF0_REGNUM + (dr_regnum - XD0_REGNUM) * 2;
 
-  fp_regnum = gdbarch_fp0_regnum (gdbarch)
-	      + (dr_regnum - DR0_REGNUM) * 2;
-  return fp_regnum;
+  return fr_regnum;
 }
 
 static void
@@ -2208,8 +2357,8 @@
 
   if (reg_nr == PSEUDO_BANK_REGNUM)
     regcache_raw_read (regcache, BANK_REGNUM, buffer);
-  else
-  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+  else if ((reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+	   || (reg_nr >= XD0_REGNUM && reg_nr <= XD_LAST_REGNUM))
     {
       base_regnum = dr_reg_base_num (gdbarch, reg_nr);
 
@@ -2248,16 +2397,17 @@
   if (reg_nr == PSEUDO_BANK_REGNUM)
     {
       /* When the bank register is written to, the whole register bank
-         is switched and all values in the bank registers must be read
+	 is switched and all values in the bank registers must be read
 	 from the target/sim again. We're just invalidating the regcache
 	 so that a re-read happens next time it's necessary.  */
       int bregnum;
 
       regcache_raw_write (regcache, BANK_REGNUM, buffer);
       for (bregnum = R0_BANK0_REGNUM; bregnum < MACLB_REGNUM; ++bregnum)
-        regcache_invalidate (regcache, bregnum);
+	regcache_invalidate (regcache, bregnum);
     }
-  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+  else if ((reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+	   || (reg_nr >= XD0_REGNUM && reg_nr <= XD_LAST_REGNUM))
     {
       base_regnum = dr_reg_base_num (gdbarch, reg_nr);
 
@@ -2309,29 +2459,76 @@
   switch (nr)
     {
       case TBR_REGNUM:
-        return SIM_SH_TBR_REGNUM;
+	return SIM_SH_TBR_REGNUM;
       case IBNR_REGNUM:
-        return SIM_SH_IBNR_REGNUM;
+	return SIM_SH_IBNR_REGNUM;
       case IBCR_REGNUM:
-        return SIM_SH_IBCR_REGNUM;
+	return SIM_SH_IBCR_REGNUM;
       case BANK_REGNUM:
-        return SIM_SH_BANK_REGNUM;
+	return SIM_SH_BANK_REGNUM;
       case MACLB_REGNUM:
-        return SIM_SH_BANK_MACL_REGNUM;
+	return SIM_SH_BANK_MACL_REGNUM;
       case GBRB_REGNUM:
-        return SIM_SH_BANK_GBR_REGNUM;
+	return SIM_SH_BANK_GBR_REGNUM;
       case PRB_REGNUM:
-        return SIM_SH_BANK_PR_REGNUM;
+	return SIM_SH_BANK_PR_REGNUM;
       case IVNB_REGNUM:
-        return SIM_SH_BANK_IVN_REGNUM;
+	return SIM_SH_BANK_IVN_REGNUM;
       case MACHB_REGNUM:
-        return SIM_SH_BANK_MACH_REGNUM;
+	return SIM_SH_BANK_MACH_REGNUM;
       default:
-        break;
+	break;
     }
   return legacy_register_sim_regno (gdbarch, nr);
 }
 
+static int
+sh_sh4_register_sim_regno (struct gdbarch *gdbarch, int nr)
+{
+  if (legacy_register_sim_regno (gdbarch, nr) < 0)
+    return legacy_register_sim_regno (gdbarch, nr);
+  if (nr >= XF0_REGNUM && nr <= XF_LAST_REGNUM)
+    return nr - XF0_REGNUM + SIM_SH_XF0_REGNUM;
+  if (nr == DBR_REGNUM)
+    return SIM_SH_DBR_REGNUM;
+  if (nr == SGR_REGNUM)
+    return SIM_SH_SGR_REGNUM;
+  if (nr >= FR0_BANK0_REGNUM && nr <= FR_BANK0_LAST_REGNUM)
+    {
+      ULONGEST val;
+      struct regcache *regcache = get_current_regcache ();
+
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return nr - FR0_BANK0_REGNUM + SIM_SH_XF0_REGNUM;
+      else
+	return nr - FR0_BANK0_REGNUM + SIM_SH_FR0_REGNUM;
+    }
+  if (nr >= FR0_BANK1_REGNUM && nr <= FR_BANK1_LAST_REGNUM)
+    {
+      ULONGEST val;
+      struct regcache *regcache = get_current_regcache ();
+
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return nr - FR0_BANK1_REGNUM + SIM_SH_FR0_REGNUM;
+      else
+	return nr - FR0_BANK1_REGNUM + SIM_SH_XF0_REGNUM;
+    }
+  if (nr >= SIM_SH4_NUM_REGS)
+    return LEGACY_SIM_REGNO_IGNORE;
+  return nr;
+}
+
+static int
+sh_dbg_reg_to_regnum (struct gdbarch *gdbarch, int nr)
+{
+  /* Fixup pseudo XD register numbers in debug information.  */
+  if ((nr >= 87) && (nr <= 94))
+    return (nr - 87) + XD0_REGNUM;
+  return nr;
+}
+
 /* Set up the register unwinding such that call-clobbered registers are
    not displayed in frames >0 because the true value is not certain.
    The 'undefined' registers will show up as 'not available' unless the
@@ -2341,7 +2538,7 @@
 
 static void
 sh_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
-                          struct dwarf2_frame_state_reg *reg,
+			  struct dwarf2_frame_state_reg *reg,
 			  struct frame_info *next_frame)
 {
   /* Mark the PC as the destination for the return address.  */
@@ -2355,32 +2552,16 @@
   /* The above was taken from the default init_reg in dwarf2-frame.c
      while the below is SH specific.  */
 
-  /* Caller save registers.  */
-  else if ((regnum >= R0_REGNUM && regnum <= R0_REGNUM+7)
-	   || (regnum >= FR0_REGNUM && regnum <= FR0_REGNUM+11)
-	   || (regnum >= DR0_REGNUM && regnum <= DR0_REGNUM+5)
-	   || (regnum >= FV0_REGNUM && regnum <= FV0_REGNUM+2)
-	   || (regnum == MACH_REGNUM)
-	   || (regnum == MACL_REGNUM)
-	   || (regnum == FPUL_REGNUM)
-	   || (regnum == SR_REGNUM))
-    reg->how = DWARF2_FRAME_REG_UNDEFINED;
-
   /* Callee save registers.  */
   else if ((regnum >= R0_REGNUM+8 && regnum <= R0_REGNUM+15)
 	   || (regnum >= FR0_REGNUM+12 && regnum <= FR0_REGNUM+15)
-	   || (regnum >= DR0_REGNUM+6 && regnum <= DR0_REGNUM+8)
-	   || (regnum == FV0_REGNUM+3))
+	   || (regnum >= DR0_REGNUM+6 && regnum <= DR0_REGNUM+7)
+	   || (regnum == FV0_REGNUM+3)
+	   || (regnum == PR_REGNUM))
     reg->how = DWARF2_FRAME_REG_SAME_VALUE;
 
-  /* Other registers.  These are not in the ABI and may or may not
-     mean anything in frames >0 so don't show them.  */
-  else if ((regnum >= R0_BANK0_REGNUM && regnum <= R0_BANK0_REGNUM+15)
-	   || (regnum == GBR_REGNUM)
-	   || (regnum == VBR_REGNUM)
-	   || (regnum == FPSCR_REGNUM)
-	   || (regnum == SSR_REGNUM)
-	   || (regnum == SPC_REGNUM))
+  /* Other, so assume undefined and don't show them.  */
+  else
     reg->how = DWARF2_FRAME_REG_UNDEFINED;
 }
 
@@ -2445,12 +2626,12 @@
   if (!cache->uses_fp)
     {
       /* We didn't find a valid frame, which means that CACHE->base
-         currently holds the frame pointer for our calling frame.  If
-         we're at the start of a function, or somewhere half-way its
-         prologue, the function's frame probably hasn't been fully
-         setup yet.  Try to reconstruct the base address for the stack
-         frame by looking at the stack pointer.  For truly "frameless"
-         functions this might work too.  */
+	 currently holds the frame pointer for our calling frame.  If
+	 we're at the start of a function, or somewhere half-way its
+	 prologue, the function's frame probably hasn't been fully
+	 setup yet.  Try to reconstruct the base address for the stack
+	 frame by looking at the stack pointer.  For truly "frameless"
+	 functions this might work too.  */
       cache->base = frame_unwind_register_unsigned
 		    (next_frame,
 		     gdbarch_sp_regnum (get_frame_arch (next_frame)));
@@ -2523,12 +2704,18 @@
     frame_unwind_register (next_frame, (*realnump), valuep);
 }
 
+static int backtrace_abi_sniffer = 1;
+
 static void
 sh_frame_this_id (struct frame_info *next_frame, void **this_cache,
 		  struct frame_id *this_id)
 {
   struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);
 
+  /* Is this sniffer enabled? */
+  if (!backtrace_abi_sniffer)
+    return;
+
   /* This marks the outermost frame.  */
   if (cache->base == 0)
     return;
@@ -2596,9 +2783,9 @@
     {
       ULONGEST inst;
       /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
-         for a nop and some fixed data (e.g. big offsets) which are
-         unfortunately also treated as part of the function (which
-         means, they are below func_end. */
+	 for a nop and some fixed data (e.g. big offsets) which are
+	 unfortunately also treated as part of the function (which
+	 means, they are below func_end. */
       CORE_ADDR addr = func_end - 28;
       if (addr < func_addr + 4)
 	addr = func_addr + 4;
@@ -2613,8 +2800,8 @@
 	return 0;
 
       /* At this point we should find a mov.l @r15+,r14 instruction,
-         either before or after the rts.  If not, then the function has
-         probably no "normal" epilogue and we bail out here. */
+	 either before or after the rts.  If not, then the function has
+	 probably no "normal" epilogue and we bail out here. */
       inst = read_memory_unsigned_integer (addr - 2, 2);
       if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2)))
 	addr -= 2;
@@ -2645,7 +2832,7 @@
 	}
 
       /* Now check for FP adjustments, using add #imm,r14 or add rX, r14
-         instructions. */
+	 instructions. */
       while (addr > func_addr + 4
 	     && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
 	{
@@ -2654,10 +2841,10 @@
 	}
 
       /* On SH2a check if the previous instruction was perhaps a MOVI20.
-         That's allowed for the epilogue.  */
+	 That's allowed for the epilogue.  */
       if ((gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a
-           || gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu)
-          && addr > func_addr + 6
+	   || gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu)
+	  && addr > func_addr + 6
 	  && IS_MOVI20 (read_memory_unsigned_integer (addr - 4, 2)))
 	addr -= 4;
 
@@ -2666,57 +2853,136 @@
     }
   return 0;
 }
-
 
-static struct gdbarch *
-sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+/* Convert an integer into an address.  Extracting the value unsigned
+   prevents the 32 bit address getting sign-extended in 64 bit CORE_ADDR.  */
+static CORE_ADDR
+sh_integer_to_address (struct gdbarch *gdbarch,
+		       struct type *type, const gdb_byte *buf)
 {
-  struct gdbarch *gdbarch;
+  return (CORE_ADDR) extract_unsigned_integer (buf, TYPE_LENGTH (type));
+}
 
-  sh_show_regs = sh_generic_show_regs;
-  switch (info.bfd_arch_info->mach)
+void
+shtdi_init_simulator_hook ()
+{
+  const char *envname = "SUPERH_SIM_PROFILE";
+  char *superh_sim_profile = getenv (envname);
+  if (!superh_sim_profile)
+    {
+      xasprintf (&superh_sim_profile, "%s=%s", envname,
+		 get_exec_file (0));
+      putenv (superh_sim_profile);
+    }
+}
+
+/*
+ * SHTDI register layout:
+ *
+ *   R0B0, ..., R7B0
+ *   R0B1, ..., R7B1
+ *   R8, ..., R15
+ *   SR, PC, PR, DBR, GBR, VBR, MACH, MACL, SGR, SSR, SPC
+ *   FR0B0, ..., FR15B0
+ *   FR0B1, ..., FR15B1
+ *   FPSCR, FPUL
+ *
+ * GDB register layout:
+ *
+ *   R0, ..., R15
+ *   PC, PR, GBR, VBR, MACH, MACL, SR, FPUL, FPSCR
+ *   FR0, ..., FR15
+ *   SSR, SPC
+ *   R0B0, ..., R7B0
+ *   R0B1, ..., R7B1
+ *   DBR, SGR
+ *   XF0, ..., XF15
+ *   FR0B0, ..., FR15B0
+ *   FR0B1, ..., FR15B1
+ */
+static int
+sh4_gdb_to_shtdi_regno (struct regcache *regcache, int regno)
+{
+  static const int register_map[SH_NUM_REGS] = {
+    -1, -1, -1, -1, -1, -1, -1, -1, 16, 17, 18, 19, 20, 21, 22, 23,
+    25, 26, 28, 29, 30, 31, 24, 68, 67,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    33, 34,
+     0,  1,  2,  3,  4,  5,  6,  7,
+     8,  9, 10, 11, 12, 13, 14, 15,
+    27, 32,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
+    51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66
+  };
+
+  if ((regno >= R0_REGNUM) && (regno < (R0_REGNUM + 8)))
     {
-    case bfd_mach_sh2e:
-      sh_show_regs = sh2e_show_regs;
-      break;
-    case bfd_mach_sh2a:
-      sh_show_regs = sh2a_show_regs;
-      break;
-    case bfd_mach_sh2a_nofpu:
-      sh_show_regs = sh2a_nofpu_show_regs;
-      break;
-    case bfd_mach_sh_dsp:
-      sh_show_regs = sh_dsp_show_regs;
-      break;
+      ULONGEST val;
 
-    case bfd_mach_sh3:
-      sh_show_regs = sh3_show_regs;
-      break;
+      regcache_cooked_read_unsigned (regcache, SR_REGNUM, &val);
+      if (val & SR_RB)
+	return (regno - R0_REGNUM) + 8; /* bank 1 */
+      else
+	return (regno - R0_REGNUM) + 0; /* bank 0 */
+    }
+  else if ((regno >= FR0_REGNUM) && (regno < (FR0_REGNUM + 16)))
+    {
+      ULONGEST val;
 
-    case bfd_mach_sh3e:
-      sh_show_regs = sh3e_show_regs;
-      break;
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return (regno - FR0_REGNUM) + 51; /* bank 1 */
+      else
+	return (regno - FR0_REGNUM) + 35; /* bank 0 */
+    }
+  else if ((regno >= XF0_REGNUM) && (regno < (XF0_REGNUM + 16)))
+    {
+      ULONGEST val;
 
-    case bfd_mach_sh3_dsp:
-    case bfd_mach_sh4al_dsp:
-      sh_show_regs = sh3_dsp_show_regs;
-      break;
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return (regno - XF0_REGNUM) + 35; /* bank 0 */
+      else
+	return (regno - XF0_REGNUM) + 51; /* bank 1 */
+    }
+  else if ((regno >= 0) && (regno < SH_NUM_REGS))
+    return register_map[regno];
+  else
+    return -1; /* invalid */
+}
 
+int
+sh_gdb_to_shtdi_regno (struct regcache *regcache, int regno)
+{
+  switch (gdbarch_bfd_arch_info (get_regcache_arch (regcache))->mach)
+    {
     case bfd_mach_sh4:
     case bfd_mach_sh4a:
-      sh_show_regs = sh4_show_regs;
-      break;
-
+    case bfd_mach_st40_300:
+    case bfd_mach_st40_300_or_sh4a:
     case bfd_mach_sh4_nofpu:
     case bfd_mach_sh4a_nofpu:
-      sh_show_regs = sh4_nofpu_show_regs;
+    case bfd_mach_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_or_sh4:
+    case bfd_mach_st40_300_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh2a_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh4a_nofpu:
+      return sh4_gdb_to_shtdi_regno (regcache, regno);
       break;
-
-    case bfd_mach_sh5:
-      sh_show_regs = sh64_show_regs;
-      /* SH5 is handled entirely in sh64-tdep.c */
-      return sh64_gdbarch_init (info, arches);
     }
+  return regno;
+}
+
+static struct gdbarch *
+sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+
+  if (info.bfd_arch_info->mach == bfd_mach_sh5)
+    /* SH5 is handled entirely in sh64-tdep.c */
+    return sh64_gdbarch_init (info, arches);
 
   /* If there is already a candidate, use it.  */
   arches = gdbarch_list_lookup_by_info (arches, &info);
@@ -2736,6 +3002,8 @@
   set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
   set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
 
+  set_gdbarch_integer_to_address (gdbarch, sh_integer_to_address);
+
   set_gdbarch_num_regs (gdbarch, SH_NUM_REGS);
   set_gdbarch_sp_regnum (gdbarch, 15);
   set_gdbarch_pc_regnum (gdbarch, 16);
@@ -2750,6 +3018,10 @@
   set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh);
   set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);
 
+  set_gdbarch_dwarf_reg_to_regnum (gdbarch, sh_dbg_reg_to_regnum);
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, sh_dbg_reg_to_regnum);
+  set_gdbarch_stab_reg_to_regnum (gdbarch, sh_dbg_reg_to_regnum);
+
   set_gdbarch_return_value (gdbarch, sh_return_value_nofpu);
 
   set_gdbarch_skip_prologue (gdbarch, sh_skip_prologue);
@@ -2785,7 +3057,7 @@
 
       set_gdbarch_register_name (gdbarch, sh_sh2e_register_name);
       set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
-      set_gdbarch_fp0_regnum (gdbarch, 25);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
       set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
       set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
       break;
@@ -2795,7 +3067,7 @@
       set_gdbarch_register_type (gdbarch, sh_sh2a_register_type);
       set_gdbarch_register_sim_regno (gdbarch, sh_sh2a_register_sim_regno);
 
-      set_gdbarch_fp0_regnum (gdbarch, 25);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
       set_gdbarch_num_pseudo_regs (gdbarch, 9);
       set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
       set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
@@ -2830,7 +3102,7 @@
 
       set_gdbarch_register_name (gdbarch, sh_sh3e_register_name);
       set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
-      set_gdbarch_fp0_regnum (gdbarch, 25);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
       set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
       set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
       break;
@@ -2842,10 +3114,13 @@
 
     case bfd_mach_sh4:
     case bfd_mach_sh4a:
+    case bfd_mach_st40_300:
+    case bfd_mach_st40_300_or_sh4a:
       set_gdbarch_register_name (gdbarch, sh_sh4_register_name);
       set_gdbarch_register_type (gdbarch, sh_sh4_register_type);
-      set_gdbarch_fp0_regnum (gdbarch, 25);
-      set_gdbarch_num_pseudo_regs (gdbarch, 13);
+      set_gdbarch_register_sim_regno (gdbarch, sh_sh4_register_sim_regno);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
+      set_gdbarch_num_pseudo_regs (gdbarch, 21);
       set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
       set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
       set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
@@ -2857,7 +3132,11 @@
     case bfd_mach_sh4_nommu_nofpu:
     case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
     case bfd_mach_sh2a_or_sh4:
+    case bfd_mach_st40_300_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh2a_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh4a_nofpu:
       set_gdbarch_register_name (gdbarch, sh_sh4_nofpu_register_name);
+      set_gdbarch_register_sim_regno (gdbarch, sh_sh4_register_sim_regno);
       break;
 
     case bfd_mach_sh4al_dsp:
@@ -2876,6 +3155,22 @@
   frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
   frame_unwind_append_sniffer (gdbarch, sh_frame_sniffer);
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+  set_solib_svr4_fetch_link_map_offsets (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+#endif
+
+  add_setshow_boolean_cmd ("abi-sniffer", class_obscure,
+			   &backtrace_abi_sniffer, "\
+Set whether backtraces should use the ABI where there is no debug info.", "\
+Show whether backtraces should use the ABI where there is no debug info.", "\
+Normally there is debug information from which to construct a backtrace\n\
+but sometimes is is not available (e.g. in assembly code). In this case the\n\
+ABI sniffer can attempt to construct a backtrace. It is disabled by default\n\
+because it can cause inconvenient errors. Note that it does not disable the\n\
+Dwarf debug information sniffer.",
+			   NULL, NULL, &set_backtrace_cmdlist,
+			   &show_backtrace_cmdlist);
+
   return gdbarch;
 }
 
diff -Naur gdb-6.8/gdb/sh-tdep.h stsgdb-6.8/gdb/sh-tdep.h
--- gdb-6.8/gdb/sh-tdep.h	2008-01-01 22:53:13.000000000 +0000
+++ stsgdb-6.8/gdb/sh-tdep.h	2008-09-11 10:35:35.000000000 +0100
@@ -22,7 +22,21 @@
 
 /* Contributed by Steve Chamberlain sac@cygnus.com */
 
-/* Registers for all SH variants.  Used also by sh3-rom.c. */
+/* Registers for all SH variants.
+
+   For reference, GCC register allocation (as of GCC 4.2.1):
+     0 to 15  = R0 to R15
+     16       = PC (linux only)
+     17       = PR
+     18       = GBR (previously 19)
+     20       = MACH
+     21       = MACL
+     22       = SR (linux only)
+     22       = SR.T (previously 18)
+     23       = FPUL
+     24       = FPSCR
+     25 to 40 = FR0 to FR15
+     87 to 94 = XD0 to XD7  */
 enum
   {
     R0_REGNUM = 0,
@@ -36,16 +50,29 @@
     MACH_REGNUM = 20,
     MACL_REGNUM = 21,
     SR_REGNUM = 22,
-    FPUL_REGNUM = 23,
     /* Floating point registers */
+    FPUL_REGNUM = 23,
     FPSCR_REGNUM = 24,
     FR0_REGNUM = 25,
     FLOAT_ARG0_REGNUM = 29,
     FLOAT_ARGLAST_REGNUM = 36,
-    FP_LAST_REGNUM = 40,
+    FR_LAST_REGNUM = 40,
     /* sh3,sh4 registers */
     SSR_REGNUM = 41,
     SPC_REGNUM = 42,
+    /*
+    R0_BANK0_REGNUM = 43,
+    R0_BANK1_REGNUM = 51,
+    */
+    /* sh4 registers */
+    DBR_REGNUM = 59,
+    SGR_REGNUM = 60,
+    XF0_REGNUM = 61,
+    XF_LAST_REGNUM = 76,
+    FR0_BANK0_REGNUM = 77,
+    FR_BANK0_LAST_REGNUM = 92,
+    FR0_BANK1_REGNUM = 93,
+    FR_BANK1_LAST_REGNUM = 108,
     /* DSP registers */
     DSR_REGNUM = 24,
     A0G_REGNUM = 25,
@@ -74,12 +101,14 @@
     IBCR_REGNUM = 64,
     IBNR_REGNUM = 65,
     TBR_REGNUM = 66,
-    PSEUDO_BANK_REGNUM = 67,
+    PSEUDO_BANK_REGNUM = 109,
     /* Floating point pseudo registers */
-    DR0_REGNUM = 68,
-    DR_LAST_REGNUM = 75,
-    FV0_REGNUM = 76,
-    FV_LAST_REGNUM = 79
+    DR0_REGNUM = 110,
+    DR_LAST_REGNUM = 117,
+    XD0_REGNUM = 118,
+    XD_LAST_REGNUM = 125,
+    FV0_REGNUM = 126,
+    FV_LAST_REGNUM = 129
   };
 
 extern gdbarch_init_ftype sh64_gdbarch_init;
diff -Naur gdb-6.8/gdb/shtdi.c stsgdb-6.8/gdb/shtdi.c
--- gdb-6.8/gdb/shtdi.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/shtdi.c	2008-09-11 10:35:35.000000000 +0100
@@ -0,0 +1,3052 @@
+/* STMicroelectronics Host-Target Debug Interface.
+
+   Copyright (C) 2006, 2007, 2008 STMicroelectronics  */
+
+#if defined(__MINGW32__) || defined(__CYGWIN__)
+#include <windows.h>
+#endif
+#include <signal.h>
+#ifndef __MINGW32__
+#include <dlfcn.h>
+#endif
+#include <time.h>
+
+#include "defs.h"
+#include "breakpoint.h"
+#include "gdbcore.h"
+#include "regcache.h"
+#include "gdbcmd.h"
+#include "gdbthread.h"
+#include "inferior.h"
+#include "objfiles.h"
+#include "observer.h"
+#include "exceptions.h"
+#include "cli/cli-cmds.h"
+#include "solib.h"
+
+void shtdi_init_simulator_hook (void);
+#ifdef SHTDI_GDB_REGISTER_MAP
+int SHTDI_GDB_REGISTER_MAP (struct regcache *, int);
+#endif
+
+/**************************************************************************/
+/* Are we connected to a target?  */
+static int shtdi_targetconnected = 0;
+
+/* The name of the silicon target currently connected.  */
+static char *shtdi_targetName = NULL;
+
+/* read or write size used when accessing inferior memory.  */
+static int download_write_size = 512;
+
+/* The millisecond timeout to use when waiting for a target event.  */
+static int shtdi_wait_timeout = 100; /* 10th second */
+
+/* The timeout (in seconds) to wait for a target event before breaking
+   into the target.  */
+static int shtdi_break_timeout = 0; /* no timeout */
+
+/* Display RTOS specific thread information?  */
+static int shtdi_rtos_thread_information = 1;
+
+/* Read all target registers?  */
+static int shtdi_read_all_registers = 1;
+
+/**************************************************************************/
+/* SHDEBUG DLL loading routines */
+
+static void enable_terminate (void);
+static void disable_terminate (void);
+
+/* DLL utility macros */
+#if defined(__MINGW32__)
+static const char *
+getLastLibraryErrorString (void)
+{
+  static char error[1024];
+
+  if (FormatMessage
+      (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
+       FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, GetLastError (), 0, error,
+       sizeof (error), NULL) == 0)
+    sprintf (error, "0x%08lx", GetLastError ());
+
+  return error;
+}
+
+#define DllOpen(name)		((void *) LoadLibrary(name))
+#define DllSymbol(handle, name) GetProcAddress((HANDLE)handle, name)
+#define DllClose(handle)	FreeLibrary((HANDLE)handle)
+#define DllError()		getLastLibraryErrorString()
+#else
+#define DllOpen(name)		dlopen(name, RTLD_NOW)
+#define DllSymbol(handle, name) dlsym(handle, name)
+#define DllClose(handle)	(dlclose(handle) == 0)
+#define DllError()		dlerror()
+#endif
+
+/* SHDEBUG interface version */
+#define SHDEBUGAPI_MAJOR_VER 1
+#define SHDEBUGAPI_MINOR_VER 5
+
+#define SHDEBUGAPI_VERSION(M, m) \
+  (((M) == SHDEBUGAPI_MAJOR_VER) && ((m) == SHDEBUGAPI_MINOR_VER))
+#define SHDEBUGAPI_VERSION_MIN(M, m) \
+  (((M) < SHDEBUGAPI_MAJOR_VER) || \
+   (((M) == SHDEBUGAPI_MAJOR_VER) && ((m) <= SHDEBUGAPI_MINOR_VER)))
+#define SHDEBUGAPI_VERSION_MAX(M, m) \
+  (((M) > SHDEBUGAPI_MAJOR_VER) || \
+   (((M) == SHDEBUGAPI_MAJOR_VER) && ((m) >= SHDEBUGAPI_MINOR_VER)))
+
+static void *shdbgDllHandle = NULL;
+
+/* SHDEBUG DLL error message function pointer definitions */
+typedef int (*printMessageFn_t) (const char *format, va_list args);
+typedef int (*errorMessageFn_t) (int msgsrc, int msgtype, const char *format,
+				 va_list args);
+
+/* SHDEBUG DLL symbol handler function pointer definitions */
+typedef int (*symToAddrFn_t) (const char *, unsigned int *);
+typedef int (*addrToSymFn_t) (unsigned int, char **, char **, int *);
+
+/* SHDEBUG DLL symbol definitions with user interface callback */
+#define SHDEBUGSymbol(s, r, p, a) \
+typedef r (*shdbg_##s##Fn_t) p; \
+static shdbg_##s##Fn_t _shdbg_##s; \
+static r shdbg_##s p \
+{ \
+  r v; \
+\
+  if (!_shdbg_##s) { \
+    error (_("Internal error: shdbg_"#s" not loaded")); \
+  } \
+\
+  /* Allow user interface to refresh */ \
+  if (deprecated_ui_loop_hook) { \
+    deprecated_ui_loop_hook(0); \
+  } \
+\
+  disable_terminate(); \
+  v =_shdbg_##s a; \
+  enable_terminate(); \
+\
+  return v; \
+}
+
+#define voidreturnSHDEBUGSymbol(s, r, p, a, v) \
+typedef void (*shdbg_##s##Fn_t) p; \
+static shdbg_##s##Fn_t _shdbg_##s; \
+static r shdbg_##s p \
+{ \
+  if (!_shdbg_##s) { \
+    error (_("Internal error: shdbg_"#s" not loaded")); \
+  } \
+\
+  /* Allow user interface to refresh */ \
+  if (deprecated_ui_loop_hook) { \
+    deprecated_ui_loop_hook(0); \
+  } \
+\
+  disable_terminate(); \
+  _shdbg_##s a; \
+  enable_terminate(); \
+\
+  return (v); \
+}
+
+#define voidSHDEBUGSymbol(s, p, a) \
+typedef void (*shdbg_##s##Fn_t) p; \
+static shdbg_##s##Fn_t _shdbg_##s; \
+static void shdbg_##s p \
+{ \
+  if (!_shdbg_##s) { \
+    error (_("Internal error: shdbg_"#s" not loaded")); \
+  } \
+\
+  /* Allow user interface to refresh */ \
+  if (deprecated_ui_loop_hook) { \
+    deprecated_ui_loop_hook(0); \
+  } \
+\
+  disable_terminate(); \
+  _shdbg_##s a; \
+  enable_terminate(); \
+}
+
+/* SHDEBUG DLL API function declarations */
+SHDEBUGSymbol (GetApiVersion, int, (int *major, int *minor), (major, minor))
+
+/* SHDEBUG DLL target function declarations */
+#if SHDEBUGAPI_VERSION_MAX(1, 0)
+SHDEBUGSymbol (Initialise, int,
+	       (int argc, char **argv, errorMessageFn_t msgFunc), (argc, argv,
+								   msgFunc))
+#else
+SHDEBUGSymbol (Initialise, int,
+	       (int argc, char **argv, printMessageFn_t prtFunc,
+		errorMessageFn_t msgFunc), (argc, argv, prtFunc, msgFunc))
+#endif
+SHDEBUGSymbol (DeInitialise, int, (void), ())
+SHDEBUGSymbol (CommandString, int, (char *string), (string))
+#if SHDEBUGAPI_VERSION_MAX(1, 0)
+SHDEBUGSymbol (Attach, int, (void), ())
+#else
+SHDEBUGSymbol (Attach, int, (int attachType), (attachType))
+#endif
+#if SHDEBUGAPI_VERSION_MAX(1, 1)
+SHDEBUGSymbol (Detach, int, (void), ())
+#else
+SHDEBUGSymbol (Detach, int, (int detachType), (detachType))
+#endif
+SHDEBUGSymbol (Continue, int, (unsigned int address), (address))
+SHDEBUGSymbol (StepTarget, int, (void), ())
+SHDEBUGSymbol (Interrupt, int, (void), ())
+SHDEBUGSymbol (ReadReg, int, (int regnum, unsigned char *regs),
+	       (regnum, regs))
+SHDEBUGSymbol (WriteReg, int, (int regnum, unsigned char *regs),
+	       (regnum, regs))
+SHDEBUGSymbol (ReadMem, int,
+	       (unsigned int address, int size, unsigned char *buffer),
+	       (address, size, buffer))
+SHDEBUGSymbol (WriteMem, int,
+	       (unsigned int address, int size, unsigned char *buffer),
+	       (address, size, buffer))
+#if SHDEBUGAPI_VERSION_MAX(1, 4)
+SHDEBUGSymbol (GetState, int, (int *exitCode, int timeout),
+	       (exitCode, timeout))
+#else
+struct targetstate
+{
+  int stopType;
+  unsigned int stopAddress;
+  int exitCode;
+};
+SHDEBUGSymbol (GetState, int, (struct targetstate *state, int timeout),
+	       (state, timeout))
+#endif
+SHDEBUGSymbol (SetBreakpoint, int,
+	       (unsigned int address, int type, int length), (address, type,
+							      length))
+SHDEBUGSymbol (RemoveBreakpoint, int,
+	       (unsigned int address, int type, int length), (address, type,
+							      length))
+SHDEBUGSymbol (GetRegSize, int, (int regnum), (regnum))
+#if 0
+SHDEBUGSymbol (GetNumRegs, int, (void), ())
+SHDEBUGSymbol (GetAllRegBytes, int, (void), ())
+#endif
+
+/* SHDEBUG DLL plugin function declarations */
+SHDEBUGSymbol (InstallPlugin, int,
+	       (const char *name, const char *dllname, char *args,
+		symToAddrFn_t symToAddrFunc, addrToSymFn_t addrToSymFunc),
+	       (name, dllname, args, symToAddrFunc, addrToSymFunc))
+SHDEBUGSymbol (CallPlugin, char *, (const char *name, char *args),
+	       (name, args))
+SHDEBUGSymbol (RemovePlugins, int, (void), ())
+
+/* SHDEBUG DLL rtos function declarations */
+#if 0
+SHDEBUGSymbol (RtosVersionString, const char *, (void), ())
+#endif
+voidSHDEBUGSymbol (RtosClearState, (void), ())
+voidSHDEBUGSymbol (RtosClearTasks, (void), ())
+SHDEBUGSymbol (RtosSetContinueThreadId, int, (int id), (id))
+SHDEBUGSymbol (RtosSetGeneralThreadId, int, (int id), (id))
+SHDEBUGSymbol (RtosGetCurrentThreadId, int, (void), ())
+SHDEBUGSymbol (RtosIterateThreadId, int, (int begin), (begin))
+#if SHDEBUGAPI_VERSION_MAX(1, 3)
+SHDEBUGSymbol (RtosGetThreadInfo, const char *, (int id), (id))
+#else
+SHDEBUGSymbol (RtosGetThreadInfo, const char *,
+	       (int id, int verbose), (id, verbose))
+#endif
+#if SHDEBUGAPI_VERSION_MIN(1, 3)
+SHDEBUGSymbol (RtosGetEventMonitor, int,
+	       (int type, unsigned int *address),
+	       (type, address))
+#endif
+SHDEBUGSymbol (RtosIsThreadAlive, int, (int id), (id))
+voidSHDEBUGSymbol (RtosQuerySymbols,
+		   (int (*query)
+		    (const char *symbol, unsigned int *address, void *handle),
+		    void *handle), (query, handle))
+#if SHDEBUGAPI_VERSION_MIN(1, 1)
+voidSHDEBUGSymbol (RtosEnable, (void), ())
+voidSHDEBUGSymbol (RtosDisable, (void), ())
+#else
+static void
+shdbg_RtosEnable (void)
+{
+}
+static void
+shdbg_RtosDisable (void)
+{
+}
+#endif
+
+/* SHDEBUG DLL i/o function declarations */
+#if SHDEBUGAPI_VERSION_MAX(1, 1)
+voidreturnSHDEBUGSymbol (RedirectIo, int, (int request, int response),
+			 (request, response), 1)
+voidreturnSHDEBUGSymbol (SetIoArgs, int, (const char *execname, char *args),
+			 (execname, args), 1)
+#else
+SHDEBUGSymbol (RedirectIo, int, (int request, int response),
+	       (request, response))
+SHDEBUGSymbol (SetIoArgs, int, (const char *execname, char *args),
+	       (execname, args))
+#endif
+
+/* Load SHDEBUG DLL functions */
+static void
+shtdi_load_shdebug (const char *shdbgdllname)
+{
+  int shdbgMajorVer = 0;
+  int shdbgMinorVer = 0;
+
+  shdbgDllHandle = DllOpen (shdbgdllname);
+  if (!shdbgDllHandle)
+    error (_("Internal error: unable to open SHDEBUG shared library %s (%s)"),
+	   shdbgdllname, DllError ());
+
+#define LoadSHDEBUGSymbol(s) \
+  do { \
+    _shdbg_##s = (shdbg_##s##Fn_t)DllSymbol(shdbgDllHandle, "sh_"#s); \
+    if (!_shdbg_##s) { \
+      error (_("Internal error: unable to find symbol sh_"#s" in %s (%s)"), \
+	    shdbgdllname, DllError ()); \
+    } \
+  } while (0)
+
+  /* Initialise SHDEBUG interface API version function pointer */
+  LoadSHDEBUGSymbol (GetApiVersion);
+
+  /* Check SHDEBUG API version */
+  if (shdbg_GetApiVersion (&shdbgMajorVer, &shdbgMinorVer))
+    {
+      if ((shdbgMajorVer != SHDEBUGAPI_MAJOR_VER)
+	  || (shdbgMinorVer != SHDEBUGAPI_MINOR_VER))
+	error (_("Internal error: API version mismatch"
+		 " (GDB using %d.%d, %s using %d.%d)"),
+	       SHDEBUGAPI_MAJOR_VER, SHDEBUGAPI_MINOR_VER, shdbgdllname,
+	       shdbgMajorVer, shdbgMinorVer);
+    }
+  else
+    error (_("Internal error: unable to check API versions (GDB using %d.%d)"),
+	   SHDEBUGAPI_MAJOR_VER, SHDEBUGAPI_MINOR_VER);
+
+  /* Initialise SHDEBUG target interface function pointers */
+  LoadSHDEBUGSymbol (Initialise);
+  LoadSHDEBUGSymbol (DeInitialise);
+  LoadSHDEBUGSymbol (CommandString);
+  LoadSHDEBUGSymbol (Attach);
+  LoadSHDEBUGSymbol (Detach);
+  LoadSHDEBUGSymbol (Continue);
+  LoadSHDEBUGSymbol (StepTarget);
+  LoadSHDEBUGSymbol (Interrupt);
+  LoadSHDEBUGSymbol (ReadReg);
+  LoadSHDEBUGSymbol (WriteReg);
+  LoadSHDEBUGSymbol (ReadMem);
+  LoadSHDEBUGSymbol (WriteMem);
+  LoadSHDEBUGSymbol (GetState);
+  LoadSHDEBUGSymbol (SetBreakpoint);
+  LoadSHDEBUGSymbol (RemoveBreakpoint);
+  LoadSHDEBUGSymbol (GetRegSize);
+#if 0
+  LoadSHDEBUGSymbol (GetNumRegs);
+  LoadSHDEBUGSymbol (GetAllRegBytes);
+#endif
+
+  /* Intialise SHDEBUG plugin interface function pointers */
+  LoadSHDEBUGSymbol (InstallPlugin);
+  LoadSHDEBUGSymbol (CallPlugin);
+  LoadSHDEBUGSymbol (RemovePlugins);
+
+  /* Initialise SHDEBUG rtos interface function pointers */
+#if 0
+  LoadSHDEBUGSymbol (RtosVersionString);
+#endif
+#if SHDEBUGAPI_VERSION_MIN(1, 1)
+  LoadSHDEBUGSymbol (RtosEnable);
+  LoadSHDEBUGSymbol (RtosDisable);
+#endif
+  LoadSHDEBUGSymbol (RtosClearState);
+  LoadSHDEBUGSymbol (RtosClearTasks);
+  LoadSHDEBUGSymbol (RtosSetContinueThreadId);
+  LoadSHDEBUGSymbol (RtosSetGeneralThreadId);
+  LoadSHDEBUGSymbol (RtosGetCurrentThreadId);
+  LoadSHDEBUGSymbol (RtosIterateThreadId);
+  LoadSHDEBUGSymbol (RtosGetThreadInfo);
+#if SHDEBUGAPI_VERSION_MIN(1, 3)
+  LoadSHDEBUGSymbol (RtosGetEventMonitor);
+#endif
+  LoadSHDEBUGSymbol (RtosIsThreadAlive);
+  LoadSHDEBUGSymbol (RtosQuerySymbols);
+
+  /* Initialise SHDEBUG io interface function pointers */
+  LoadSHDEBUGSymbol (RedirectIo);
+  LoadSHDEBUGSymbol (SetIoArgs);
+}
+
+/* Unload SHDEBUG DLL functions */
+static void
+shtdi_unload_shdebug (void)
+{
+#define UnloadSHDEBUGSymbol(s) \
+  do { \
+    _shdbg_##s = NULL; \
+  } while (0)
+
+  /* De-initialise SHDEBUG interface API version function pointer */
+  UnloadSHDEBUGSymbol (GetApiVersion);
+
+  /* De-initialise SHDEBUG target interface function pointers */
+  UnloadSHDEBUGSymbol (Initialise);
+  UnloadSHDEBUGSymbol (DeInitialise);
+  UnloadSHDEBUGSymbol (CommandString);
+  UnloadSHDEBUGSymbol (Attach);
+  UnloadSHDEBUGSymbol (Detach);
+  UnloadSHDEBUGSymbol (Continue);
+  UnloadSHDEBUGSymbol (StepTarget);
+  UnloadSHDEBUGSymbol (Interrupt);
+  UnloadSHDEBUGSymbol (ReadReg);
+  UnloadSHDEBUGSymbol (WriteReg);
+  UnloadSHDEBUGSymbol (ReadMem);
+  UnloadSHDEBUGSymbol (WriteMem);
+  UnloadSHDEBUGSymbol (GetState);
+  UnloadSHDEBUGSymbol (SetBreakpoint);
+  UnloadSHDEBUGSymbol (RemoveBreakpoint);
+  UnloadSHDEBUGSymbol (GetRegSize);
+#if 0
+  UnloadSHDEBUGSymbol (GetNumRegs);
+  UnloadSHDEBUGSymbol (GetAllRegBytes);
+#endif
+
+  /* De-intialise SHDEBUG plugin interface function pointers */
+  UnloadSHDEBUGSymbol (InstallPlugin);
+  UnloadSHDEBUGSymbol (CallPlugin);
+  UnloadSHDEBUGSymbol (RemovePlugins);
+
+  /* De-initialise SHDEBUG rtos interface function pointers */
+#if 0
+  UnloadSHDEBUGSymbol (RtosVersionString);
+#endif
+#if SHDEBUGAPI_VERSION_MIN(1, 1)
+  UnloadSHDEBUGSymbol (RtosEnable);
+  UnloadSHDEBUGSymbol (RtosDisable);
+#endif
+  UnloadSHDEBUGSymbol (RtosClearState);
+  UnloadSHDEBUGSymbol (RtosClearTasks);
+  UnloadSHDEBUGSymbol (RtosSetContinueThreadId);
+  UnloadSHDEBUGSymbol (RtosSetGeneralThreadId);
+  UnloadSHDEBUGSymbol (RtosGetCurrentThreadId);
+  UnloadSHDEBUGSymbol (RtosIterateThreadId);
+  UnloadSHDEBUGSymbol (RtosGetThreadInfo);
+#if SHDEBUGAPI_VERSION_MIN(1, 3)
+  UnloadSHDEBUGSymbol (RtosGetEventMonitor);
+#endif
+  UnloadSHDEBUGSymbol (RtosIsThreadAlive);
+  UnloadSHDEBUGSymbol (RtosQuerySymbols);
+
+  /* De-initialise SHDEBUG io interface function pointers */
+  UnloadSHDEBUGSymbol (RedirectIo);
+  UnloadSHDEBUGSymbol (SetIoArgs);
+
+  if (shdbgDllHandle && !DllClose (shdbgDllHandle))
+    error (_("Internal error: unable to close SHDEBUG shared library (%s)"),
+	   DllError ());
+
+  shdbgDllHandle = NULL;
+}
+
+
+/**************************************************************************/
+/* DLL support routines.  */
+
+/* Debug message system types */
+enum
+{
+  shdbg_Error = 0,
+  shdbg_Warning = 1,
+  shdbg_Info = 2,
+  shdbg_Debug = 3
+};
+
+enum
+{
+  shdbg_SHDEBUG = 0,
+  shdbg_SDI = 1,
+  shdbg_RTOS = 2,
+  shdbg_IO = 3,
+  shdbg_PLUGIN = 4
+};
+
+static struct
+{
+  struct
+  {
+    unsigned int warning:1;
+    unsigned int info:1;
+    unsigned int debug:1;
+  } lvl;
+
+  struct
+  {
+    unsigned int shdebug:1;
+    unsigned int sdi:1;
+    unsigned int rtos:1;
+    unsigned int io:1;
+    unsigned int plugin:1;
+  } src;
+} shdbg_msg;
+
+/* Print message routine */
+static int
+shdbg_print_message_callback (const char *format, va_list args)
+{
+  vprintf_filtered (format, args);
+  return 0;
+}
+
+/* Error message routine */
+static int
+shdbg_error_message_callback (int msgsrc, int msgtype, const char *format,
+			      va_list args)
+{
+  char *message = NULL, *srctag = NULL, *typetag = NULL;
+
+  switch (msgsrc)
+    {
+    case shdbg_SHDEBUG:
+      if (!shdbg_msg.src.shdebug && (msgtype != shdbg_Error))
+	return 0;
+      srctag = "SHDEBUG";
+      break;
+    case shdbg_SDI:
+      if (!shdbg_msg.src.sdi && (msgtype != shdbg_Error))
+	return 0;
+      srctag = "SDI";
+      break;
+    case shdbg_RTOS:
+      if (!shdbg_msg.src.rtos && (msgtype != shdbg_Error))
+	return 0;
+      srctag = "RTOS";
+      break;
+    case shdbg_IO:
+      if (!shdbg_msg.src.io && (msgtype != shdbg_Error))
+	return 0;
+      srctag = "IO";
+      break;
+    case shdbg_PLUGIN:
+      if (!shdbg_msg.src.plugin && (msgtype != shdbg_Error))
+	return 0;
+      srctag = "PLUGIN";
+      break;
+    default:
+      srctag = "*UNKNOWN*";
+      break;
+    }
+
+  switch (msgtype)
+    {
+    case shdbg_Error:
+      typetag = "ERROR";
+      break;
+    case shdbg_Warning:
+      if (!shdbg_msg.lvl.warning)
+	return 0;
+      typetag = "WARNING";
+      break;
+    case shdbg_Info:
+      if (!shdbg_msg.lvl.info)
+	return 0;
+      typetag = "INFO";
+      break;
+    case shdbg_Debug:
+      if (!shdbg_msg.lvl.debug)
+	return 0;
+      typetag = "DEBUG";
+      break;
+    default:
+      typetag = "UNKNOWN";
+      break;
+    }
+
+  xvasprintf (&message, format, args);
+
+  switch (msgtype)
+    {
+    case shdbg_Error:
+      fprintf_unfiltered (gdb_stdlog, "%s [%s] :: %s\n", srctag, typetag,
+			  message);
+      break;
+    default:
+      fprintf_filtered (gdb_stdlog, "%s [%s] :: %s\n", srctag, typetag,
+			message);
+      break;
+    }
+
+  xfree (message);
+
+  return 0;
+}
+
+static void
+shdbg_msglevel_init (void)
+{
+  /* Initialise all messages to disabled */
+  shdbg_msg.lvl.warning = 0;
+  shdbg_msg.lvl.info = 0;
+  shdbg_msg.lvl.debug = 0;
+  shdbg_msg.src.shdebug = 0;
+  shdbg_msg.src.sdi = 0;
+  shdbg_msg.src.rtos = 0;
+  shdbg_msg.src.io = 0;
+  shdbg_msg.src.plugin = 0;
+}
+
+static void
+shdbg_msglevel_command (char *args, int from_tty)
+{
+  char *arg = NULL;
+
+  if (!args)
+    {
+      if (shdbg_msg.lvl.warning || shdbg_msg.lvl.info || shdbg_msg.lvl.debug)
+	printf_filtered (_("Message levels:%s%s%s.\n"),
+			 shdbg_msg.lvl.warning ? " warning" : "",
+			 shdbg_msg.lvl.info ? " info" : "",
+			 shdbg_msg.lvl.debug ? " debug" : "");
+      else
+	printf_filtered (_("No message levels set.\n"));
+      if (shdbg_msg.src.shdebug || shdbg_msg.src.sdi || shdbg_msg.src.rtos
+	  || shdbg_msg.src.io || shdbg_msg.src.plugin)
+	printf_filtered (_("Message sources:%s%s%s%s%s.\n"),
+			 shdbg_msg.src.shdebug ? " shdebug" : "",
+			 shdbg_msg.src.sdi ? " sdi" : "",
+			 shdbg_msg.src.rtos ? " rtos" : "",
+			 shdbg_msg.src.io ? " io" : "",
+			 shdbg_msg.src.plugin ? " plugin" : "");
+      else
+	printf_filtered (_("No message sources set.\n"));
+    }
+  else
+    {
+      for (arg = strtok (args, " "); arg; arg = strtok (NULL, " "))
+	{
+	  if (strcmp (arg, "warning") == 0)
+	    shdbg_msg.lvl.warning = 1;
+	  else if (strcmp (arg, "info") == 0)
+	    shdbg_msg.lvl.info = 1;
+	  else if (strcmp (arg, "debug") == 0)
+	    shdbg_msg.lvl.debug = 1;
+	  else if (strcmp (arg, "shdebug") == 0)
+	    shdbg_msg.src.shdebug = 1;
+	  else if (strcmp (arg, "sdi") == 0)
+	    shdbg_msg.src.sdi = 1;
+	  else if (strcmp (arg, "rtos") == 0)
+	    shdbg_msg.src.rtos = 1;
+	  else if (strcmp (arg, "io") == 0)
+	    shdbg_msg.src.io = 1;
+	  else if (strcmp (arg, "plugin") == 0)
+	    shdbg_msg.src.plugin = 1;
+	  else if (strcmp (arg, "alllvl") == 0)
+	    {
+	      shdbg_msg.lvl.warning = 1;
+	      shdbg_msg.lvl.info = 1;
+	      shdbg_msg.lvl.debug = 1;
+	    }
+	  else if (strcmp (arg, "nolvl") == 0)
+	    {
+	      shdbg_msg.lvl.warning = 0;
+	      shdbg_msg.lvl.info = 0;
+	      shdbg_msg.lvl.debug = 0;
+	    }
+	  else if (strcmp (arg, "allsrc") == 0)
+	    {
+	      shdbg_msg.src.shdebug = 1;
+	      shdbg_msg.src.sdi = 1;
+	      shdbg_msg.src.rtos = 1;
+	      shdbg_msg.src.io = 1;
+	      shdbg_msg.src.plugin = 1;
+	    }
+	  else if (strcmp (arg, "nosrc") == 0)
+	    {
+	      shdbg_msg.src.shdebug = 0;
+	      shdbg_msg.src.sdi = 0;
+	      shdbg_msg.src.rtos = 0;
+	      shdbg_msg.src.io = 0;
+	      shdbg_msg.src.plugin = 0;
+	    }
+	  else if (strcmp (arg, "all") == 0)
+	    {
+	      shdbg_msg.lvl.warning = 1;
+	      shdbg_msg.lvl.info = 1;
+	      shdbg_msg.lvl.debug = 1;
+	      shdbg_msg.src.shdebug = 1;
+	      shdbg_msg.src.sdi = 1;
+	      shdbg_msg.src.rtos = 1;
+	      shdbg_msg.src.io = 1;
+	      shdbg_msg.src.plugin = 1;
+	    }
+	  else if (strcmp (arg, "none") == 0)
+	    {
+	      shdbg_msg.lvl.warning = 0;
+	      shdbg_msg.lvl.info = 0;
+	      shdbg_msg.lvl.debug = 0;
+	      shdbg_msg.src.shdebug = 0;
+	      shdbg_msg.src.sdi = 0;
+	      shdbg_msg.src.rtos = 0;
+	      shdbg_msg.src.io = 0;
+	      shdbg_msg.src.plugin = 0;
+	    }
+	  else
+	    error (_("Unrecognised argument `%s'."), arg);
+	}
+    }
+}
+
+static int
+shtdi_addrfromsymb (const char *arg, unsigned int *address)
+{
+  int result = 0;
+
+  *address = 0;
+
+  if (!symfile_objfile)
+    *address = -1;
+  else if (!strstr (arg, ":"))
+    {
+      struct minimal_symbol *minsym =
+	lookup_minimal_symbol (arg, NULL, symfile_objfile);
+
+      if (minsym)
+	{
+	  *address = SYMBOL_VALUE_ADDRESS (minsym);
+	  result = 1;
+	}
+    }
+  else
+    {
+      struct symtabs_and_lines sals;
+      CORE_ADDR start_pc, end_pc;
+
+      sals = decode_line_spec_1 ((char *) arg, 0);
+      dont_repeat ();
+
+      if (find_line_pc_range (sals.sals[0], &start_pc, &end_pc))
+	{
+	  *address = start_pc;
+	  result = 1;
+	}
+
+      xfree (sals.sals);
+    }
+
+  return result;
+}
+
+static int
+shtdi_symbfromaddr (unsigned int address, char **symbol, char **filename,
+		    int *linenum)
+{
+  struct minimal_symbol *msymbol;
+  struct symtab_and_line sal;
+
+  *symbol = NULL;
+  *filename = NULL;
+  *linenum = -1;
+
+  if (!symfile_objfile)
+    return 0;
+
+  if ((msymbol = lookup_minimal_symbol_by_pc (address)))
+    {
+      *symbol = xstrdup (SYMBOL_PRINT_NAME (msymbol));
+      sal = find_pc_line (address, 0);
+      if (sal.symtab)
+	{
+	  *filename = xstrdup (sal.symtab->filename);
+	  *linenum = sal.line;
+	}
+      return 1;
+    }
+  return 0;
+}
+
+/* This implements the installplugin command.  */
+
+static void
+shtdi_instplugin (char *args, int from_tty)
+{
+  char *pluginname = NULL;
+  char *plugindll = NULL;
+  char *pluginargs = NULL;
+  int argslen = 0;
+
+  if (!args)
+    error (_("No arguments passed to installplugin command"));
+
+  argslen = strlen (args);
+  pluginname = strtok (args, " ");
+  if (!pluginname)
+    error (_("No plugin name supplied to installplugin command"));
+  argslen -= strlen (pluginname) + 1;
+
+  plugindll = strtok (NULL, " ");
+  if (!plugindll)
+    error (_("No plugin library supplied to installplugin command"));
+  argslen -= strlen (plugindll) + 1;
+
+  if (argslen > 0)
+    pluginargs = plugindll + strlen (plugindll) + 1;
+
+  if (!shdbg_InstallPlugin
+      (pluginname, plugindll, pluginargs, shtdi_addrfromsymb,
+       shtdi_symbfromaddr))
+    error (_("Unable to install plugin `%s'"), pluginname);
+}
+
+static void
+set_command (char *exp, int from_tty)
+{
+  struct expression *expr = parse_expression (exp);
+  struct cleanup *old_chain = make_cleanup (free_current_contents, &expr);
+  evaluate_expression (expr);
+  do_cleanups (old_chain);
+}
+
+static void
+do_script_cleanup (void *args)
+{
+  remove ((char *) args);
+  xfree (args);
+}
+
+static void
+do_script (char *script, int from_tty)
+{
+  char *scriptname = make_temp_file (NULL);
+  struct cleanup *old_chain = make_cleanup (do_script_cleanup, scriptname);
+  FILE *scriptfile = NULL;
+  char *scriptcommand = NULL;
+
+  if ((scriptfile = fopen (scriptname, "w")) == NULL)
+    error (_("Unable to create temporary script file `%s'"), scriptname);
+  fwrite (script, strlen (script), 1, scriptfile);
+  fclose (scriptfile);
+
+  xasprintf (&scriptcommand, "source %s", scriptname);
+  make_cleanup (xfree, scriptcommand);
+  execute_command (scriptcommand, from_tty);
+
+  do_cleanups (old_chain);
+}
+
+/* This implements the callplugin command.  */
+
+static void
+shtdi_callplugin (char *args, int from_tty)
+{
+  char *pluginname = NULL;
+  char *pluginargs = NULL;
+  char *pluginresult = NULL;
+  int argslen = 0;
+
+  if (!args)
+    error (_("No arguments passed to callplugin command"));
+
+  argslen = strlen (args);
+  pluginname = strtok (args, " ");
+  if (!pluginname)
+    error (_("No plugin name supplied to callplugin command"));
+  argslen -= strlen (pluginname) + 1;
+
+  if (argslen > 0)
+    pluginargs = pluginname + strlen (pluginname) + 1;
+
+  pluginresult = shdbg_CallPlugin (pluginname, pluginargs);
+  if (pluginresult != NULL)
+    {
+#if 0
+      char *setexpr = NULL;
+      for (setexpr = strtok (pluginresult, "\n"); setexpr;
+	   setexpr = strtok (NULL, "\n"))
+	set_command (setexpr, from_tty);
+#else
+      if (strchr (pluginresult, '\n'))
+	do_script (pluginresult, from_tty);
+      else
+	execute_command (pluginresult, from_tty);
+#endif
+    }
+}
+
+
+/**************************************************************************/
+/* IO Console Routines.  */
+
+/* Should we use the IO console?  */
+static int ioconsole_enabled = 1;
+
+/* Is the external IO Console running?
+   (Or else, would it be if it were enabled?) */
+static int ioconsole_launched = 0;
+
+/* The process ID of the IO console, if running.  */
+static int ioconsole_pid = 0;
+
+/* The pipe handles connected to the IO console.  */
+static int ioconsole_readhandle = 0;
+static int ioconsole_writehandle = 0;
+static int ioconsole_asynchandle = 0;
+
+static void
+ioconsole_open (void)
+{
+#if defined(__MINGW32__) || defined(__CYGWIN__)
+  char *consoleName = "posix-console.exe";
+  HANDLE input[2];
+  HANDLE inputRead;
+  HANDLE output[2];
+  HANDLE outputWrite;
+  HANDLE async[2];
+  HANDLE asyncWrite;
+  char *commandline = NULL;
+  STARTUPINFO si;
+  PROCESS_INFORMATION pi;
+  SECURITY_ATTRIBUTES sa;
+
+  sa.nLength = sizeof (SECURITY_ATTRIBUTES);
+  sa.bInheritHandle = TRUE;
+  sa.lpSecurityDescriptor = NULL;
+
+  ZeroMemory (&si, sizeof (STARTUPINFO));
+  si.cb = sizeof (STARTUPINFO);
+
+  if (!CreatePipe (&inputRead, &input[1], &sa, 0))
+    error (_("Internal error: ioconsole_open:"
+	     " CreatePipe() has failed (%d)"), (int) GetLastError ());
+  if (!CreatePipe (&output[0], &outputWrite, &sa, 0))
+    error (_("Internal error: ioconsole_open:"
+	     " CreatePipe() has failed (%d)"), (int) GetLastError ());
+  if (!CreatePipe (&async[0], &asyncWrite, &sa, 0))
+    error (_("Internal error: ioconsole_open:"
+	     " CreatePipe() has failed (%d)"), (int) GetLastError ());
+
+  if (!DuplicateHandle
+      (GetCurrentProcess (), inputRead, GetCurrentProcess (), &input[0], 0,
+       FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+    error (_("Internal error: ioconsole_open:"
+	     " DuplicateHandle() has failed (%d)"), (int) GetLastError ());
+  if (!DuplicateHandle
+      (GetCurrentProcess (), outputWrite, GetCurrentProcess (), &output[1], 0,
+       FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+    error (_("Internal error: ioconsole_open:"
+	     " DuplicateHandle() has failed (%d)"), (int) GetLastError ());
+  if (!DuplicateHandle
+      (GetCurrentProcess (), asyncWrite, GetCurrentProcess (), &async[1], 0,
+       FALSE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+    error (_("Internal error: ioconsole_open:"
+	     " DuplicateHandle() has failed (%d)"), (int) GetLastError ());
+
+  xasprintf (&commandline, "%s -async %u -read %u -write %u -target %s",
+	     consoleName, (unsigned int) async[0], (unsigned int) output[0],
+	     (unsigned int) input[1], shtdi_targetName);
+
+  GetStartupInfo (&si);
+  si.dwFlags &= ~STARTF_USESTDHANDLES;
+
+  if (!CreateProcess
+      (NULL, commandline, &sa, &sa, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &si,
+       &pi))
+    error (_("Internal error: ioconsole_open: CreateProcess()"
+	     " has failed for %s (%d)"), commandline, (int) GetLastError ());
+
+  xfree (commandline);
+#else
+  char *consoleName = "posix-console";
+  char *consoleTerm = getenv ("SUPERH_CONSOLE_TERM");
+  int input[2] = { 0, 0 };
+  int inputWrite = 0;
+  int output[2] = { 0, 0 };
+  int outputRead = 0;
+  int async[2] = { 0, 0 };
+  int asyncRead = 0;
+  int childPid = 0;
+  int argc = 0;
+  char **argv = NULL;
+
+  if (pipe (input) == -1)
+    error (_("Internal error: ioconsole_open: pipe() has failed (%s)"),
+	   safe_strerror (errno));
+  if (pipe (output) == -1)
+    error (_("Internal error: ioconsole_open: pipe() has failed (%s)"),
+	   safe_strerror (errno));
+  if (pipe (async) == -1)
+    error (_("Internal error: ioconsole_open: pipe() has failed (%s)"),
+	   safe_strerror (errno));
+
+  /* GDB keep input read and output write */
+
+  if ((inputWrite = dup (input[1])) == -1)
+    error (_("Internal error: ioconsole_open: dup() has failed (%s)"),
+	   safe_strerror (errno));
+  if ((outputRead = dup (output[0])) == -1)
+    error (_("Internal error: ioconsole_open: dup() has failed (%s)"),
+	   safe_strerror (errno));
+  if ((asyncRead = dup (async[0])) == -1)
+    error (_("Internal error: ioconsole_open: dup() has failed (%s)"),
+	   safe_strerror (errno));
+
+  close (input[1]);
+  close (output[0]);
+  close (async[0]);
+
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  argv[argc++] = NULL;		/* Skip, set below in child */
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%s", "-title");
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "Target I/O console for %s", shtdi_targetName);
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%s", "-e");
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%s", consoleName);
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%s", "-async");
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%d", asyncRead);
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%s", "-read");
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%d", outputRead);
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%s", "-write");
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  xasprintf (&argv[argc++], "%d", inputWrite);
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  argv[argc] = NULL;
+
+  childPid = fork ();
+
+  if (childPid == 0)
+    {
+      close (input[0]);
+      close (output[1]);
+      close (async[1]);
+      setsid ();
+
+      /*
+       * Following implementation assumes exec only returns on error
+       */
+
+      /* Try user X terminal first ... */
+      if (consoleTerm)
+	{
+	  argv[0] = consoleTerm;
+	  execvp (argv[0], argv);
+	}
+
+      /* Failed, try xterm on PATH ... */
+      argv[0] = "xterm";
+      execvp (argv[0], argv);
+
+      /* Failed, try natural Solaris location ... */
+      argv[0] = "/usr/X/bin/xterm";
+      execv (argv[0], argv);
+
+      /* Failed, try natural Linux location ... */
+      argv[0] = "/usr/X11R6/bin/xterm";
+      execv (argv[0], argv);
+
+      /* Failed, so exit */
+      _exit (1);
+    }
+  else if (childPid == -1)
+    error (_("Internal error: ioconsole_open: fork() has failed (%s)"),
+	   safe_strerror (errno));
+  else
+    {
+      ioconsole_pid = childPid;
+      while (argc-- > 0)
+	xfree (argv[argc]);
+      xfree (argv);
+    }
+#endif
+
+  if (!shdbg_RedirectIo ((int) output[1], (int) input[0]))
+    error (_("Internal error: unable to redirect target I/O"
+	     " to a separate console"));
+  else
+    {
+      ioconsole_readhandle = (int) input[0];
+      ioconsole_writehandle = (int) output[1];
+      ioconsole_asynchandle = (int) async[1];
+    }
+}
+
+/* Launch the IO console if it is enabled
+   and the program has DTF enabled.  */
+
+static void
+ioconsole_init (void)
+{
+  int addr = 0;
+
+  if (ioconsole_launched)
+    return;
+
+  /* Check for _SH_DEBUGGER_CONNECTED flag to determine
+     initial console mode */
+  shtdi_addrfromsymb ("_SH_DEBUGGER_CONNECTED", &addr);
+  if (!addr)
+    ioconsole_enabled = 0;
+
+  if (ioconsole_enabled)
+    ioconsole_open ();
+
+  /* Launched or not, it would be if enabled.  */
+  ioconsole_launched = 1;
+}
+
+static void
+ioconsole_close (void)
+{
+  if (ioconsole_readhandle)
+    {
+#if defined(__MINGW32__) || defined(__CYGWIN__)
+      CloseHandle ((HANDLE) ioconsole_readhandle);
+#else
+      close (ioconsole_readhandle);
+#endif
+    }
+
+  if (ioconsole_writehandle)
+    {
+#if defined(__MINGW32__) || defined(__CYGWIN__)
+      CloseHandle ((HANDLE) ioconsole_writehandle);
+#else
+      close (ioconsole_writehandle);
+#endif
+    }
+
+  if (ioconsole_asynchandle)
+    {
+#if defined(__MINGW32__) || defined(__CYGWIN__)
+      CloseHandle ((HANDLE) ioconsole_asynchandle);
+#else
+      close (ioconsole_asynchandle);
+#endif
+    }
+
+  if (ioconsole_enabled && ioconsole_launched && !shdbg_RedirectIo (0, 0))
+    error (_("Internal error: unable to redirect target I/O to"
+	     " GDB console"));
+
+  /* Note console enabled state is not reset but left as is */
+  ioconsole_readhandle = 0;
+  ioconsole_writehandle = 0;
+  ioconsole_asynchandle = 0;
+  ioconsole_pid = 0;		/* Assume I/O console process terminated */
+}
+
+/* These functions implement the 'console' commands.  */
+
+static void
+ioconsole_console_disable (char *args, int from_tty)
+{
+  ioconsole_close ();
+  ioconsole_enabled = 0;
+}
+
+static void
+ioconsole_console_enable (char *args, int from_tty)
+{
+  if (!ioconsole_enabled && ioconsole_launched)
+    ioconsole_open ();
+  ioconsole_enabled = 1;
+}
+
+static void
+info_ioconsole_console_command (char *args, int from_tty)
+{
+  printf_filtered (_("Target I/O console is %s.\n"),
+		   ioconsole_enabled ? "enabled" : "disabled");
+}
+
+static void
+ioconsole_console_command (char *args, int from_tty)
+{
+  char *consoleMode = NULL;
+
+  if (!args)
+    {
+      info_ioconsole_console_command (NULL, from_tty);
+      return;
+    }
+
+  consoleMode = strtok (args, " ");
+  if (strcmp (consoleMode, "on") == 0)
+    {
+      ioconsole_console_enable (NULL, from_tty);
+    }
+  else if (strcmp (consoleMode, "off") == 0)
+    {
+      ioconsole_console_disable (NULL, from_tty);
+    }
+  else
+    error (_("Unrecognised argument `%s'."), consoleMode);
+}
+
+
+/**************************************************************************/
+/* RTOS awareness routines.  */
+
+/* IMPORTANT: A target thread must never have this id
+   (unlikely but not impossible) */
+#define MAGIC_TARGET_PID 42000000
+
+/* RTOS awareness initialization hook.  */
+static const char rtos_initialize_attach[] = "attach";
+static const char rtos_initialize_load[] = "load";
+static const char rtos_initialize_resume[] = "resume";
+static const char *rtos_initialize_enum[] =
+{
+  rtos_initialize_attach,
+  rtos_initialize_load,
+  rtos_initialize_resume,
+  NULL,
+};
+static const char *set_rtos_initialize_string = rtos_initialize_resume;
+
+/* Should we be using RTOS awareness?  */
+static int rtos_enabled = 1;
+
+/* Is the RTOS awareness initialized?
+   (Or would it be if it were enabled?)  */
+static int shtdi_rtos_launched = 0;
+
+static void
+rtos_init (void)
+{
+  if (shtdi_rtos_launched)
+    return;
+
+  if (rtos_enabled)
+    shdbg_RtosEnable ();
+  else
+    shdbg_RtosDisable ();
+
+  /* Launched or not, it would be if enabled.  */
+  shtdi_rtos_launched = 1;
+}
+
+static void
+rtos_disable (char *args, int from_tty)
+{
+  if (rtos_enabled && shtdi_rtos_launched)
+    shdbg_RtosDisable ();
+  rtos_enabled = 0;
+}
+
+static void
+rtos_enable (char *args, int from_tty)
+{
+  if (!rtos_enabled && shtdi_rtos_launched)
+    shdbg_RtosEnable ();
+  rtos_enabled = 1;
+}
+
+static void
+info_rtos_command (char *args, int from_tty)
+{
+  printf_filtered (_("RTOS awareness is %s.\n"),
+		   rtos_enabled ? "enabled" : "disabled");
+}
+
+static void
+rtos_command (char *args, int from_tty)
+{
+  char *rtosMode = NULL;
+
+  if (!args)
+    {
+      info_rtos_command (NULL, from_tty);
+      return;
+    }
+
+  rtosMode = strtok (args, " ");
+  if (strcmp (rtosMode, "on") == 0)
+    {
+      rtos_enable (NULL, from_tty);
+    }
+  else if (strcmp (rtosMode, "off") == 0)
+    {
+      rtos_disable (NULL, from_tty);
+    }
+  else
+    error (_("Unrecognised argument `%s'."), rtosMode);
+}
+
+static int
+rtos_thread_alive (ptid_t ptid)
+{
+  return shdbg_RtosIsThreadAlive (PIDGET (ptid));
+}
+
+static void
+rtos_find_new_threads (void)
+{
+  int tid = 0;
+  int begin = 1;
+
+  while ((tid = shdbg_RtosIterateThreadId (begin ? (begin = 0, 1) : 0)))
+    {
+      if (!in_thread_list (pid_to_ptid (tid)))
+	add_thread (pid_to_ptid (tid));
+    }
+}
+
+static char *
+rtos_pid_to_str (ptid_t ptid)
+{
+  static char buf[64];
+  sprintf (buf, "Thread %d", PIDGET (ptid));
+  return buf;
+}
+
+static char *
+rtos_extra_thread_info (struct thread_info *thread_info)
+{
+#if SHDEBUGAPI_VERSION_MAX(1, 3)
+  return (char *) shdbg_RtosGetThreadInfo (PIDGET (thread_info->ptid));
+#else
+  return (char *) shdbg_RtosGetThreadInfo (PIDGET (thread_info->ptid),
+					   shtdi_rtos_thread_information);
+#endif
+}
+
+/* Inform the RTOS plugin of the location of any symbols it may need.
+   Call this whenever the symbols may have moved.  */
+
+static void
+rtos_check_symbols (struct objfile *objfile)
+{
+  /* Nested function.  */
+  int callback (const char *symbol, unsigned int *address, void *objfile)
+  {
+    struct minimal_symbol *minsym =
+      lookup_minimal_symbol (symbol, NULL, (struct objfile *) objfile);
+
+    if (!minsym)
+      return 0;
+
+    *address = SYMBOL_VALUE_ADDRESS (minsym);
+
+    return 1;
+  }
+
+  shdbg_RtosQuerySymbols (callback, objfile);
+}
+
+
+static void
+rtos_reset_command (char *args, int from_tty)
+{
+  char *rtosReset = NULL;
+
+  if (!args)
+    {
+      error (_("Argument required (reset level)."));
+    }
+
+  rtosReset = strtok (args, " ");
+  if (strcmp (rtosReset, "all") == 0)
+    {
+      if (shtdi_targetconnected)
+	{
+	  shdbg_RtosClearState ();
+	  if  (symfile_objfile != NULL)
+	    rtos_check_symbols (symfile_objfile);
+	  if (rtos_enabled && shtdi_rtos_launched)
+	    shdbg_RtosEnable ();
+	}
+    }
+  else if (strcmp (rtosReset, "thread") == 0)
+    {
+      if (shtdi_targetconnected)
+	shdbg_RtosClearTasks ();
+    }
+  else
+    error (_("Unrecognised argument `%s'."), rtosReset);
+}
+
+/**************************************************************************/
+/* Signal Handling.  */
+
+/* A target interrupt has been requested.  */
+static volatile int interrupt_requested = 0;
+static int target_interrupted = 0;
+
+/* A SIGTERM has been requested.  */
+static volatile int terminate_requested = 0;
+
+/* Remember the regular SIG handlers while ours are installed.  */
+static void (*old_interrupt_handler) (int);
+static void (*old_terminate_handler) (int);
+
+/* Send an interrupt to the target console.  */
+static void
+iointerrupt (void)
+{
+  char int_req = 0x03;
+  int result = 0;
+
+#if defined(__MINGW32__) || defined(__CYGWIN__)
+  DWORD bytesWritten = 0;
+
+  result =
+    WriteFile ((HANDLE) ioconsole_asynchandle, &int_req, 1,
+	       &bytesWritten, NULL);
+#else
+  result = write (ioconsole_asynchandle, &int_req, 1);
+#endif
+}
+
+/* This is called when the user wants to interrupt the target.
+   All we do is set interrupt_requested. The actual work is handled
+   by interrupt_check().  */
+static void
+interrupt_stop (void)
+{
+  interrupt_requested = 1;
+
+  if (ioconsole_enabled)
+    iointerrupt ();
+}
+
+/* The user typed ^C once.
+   Send the interrupt on to the target and hope it responds.  */
+static void
+interrupt_once (int signo)
+{
+  /* Re-install interrupt handler.  */
+  signal (signo, interrupt_once);
+
+  interrupt_stop ();
+}
+
+/* Test if there is a queued interrupt waiting to be serviced.  */
+static void
+interrupt_check (void)
+{
+  if (interrupt_requested && !target_interrupted)
+    {
+      if (!shdbg_Interrupt ())
+	error (_("Unable to stop target"));
+
+      target_interrupted = 1;
+    }
+}
+
+/* Functions to protect SHDEBUG APIs from SIGTERM interferance.
+
+   SIGTERM sent to shutdown GDB but while performing SHDEBUG RPC calls
+   want to delay the signal until RPC has completed. Therefore SHDEBUG
+   APIs install this handler and if called re-raise the signal when it
+   is safe to do so.  */
+
+static void
+terminate_once (int signo)
+{
+  signal (signo, SIG_IGN); /* Ignore further signals */
+  terminate_requested = 1;
+}
+
+static void
+disable_terminate (void)
+{
+  terminate_requested = 0; /* Reset */
+  old_terminate_handler = signal (SIGTERM, terminate_once);
+}
+
+static void
+enable_terminate (void)
+{
+  signal (SIGTERM, old_terminate_handler);
+  if (terminate_requested)
+    raise (SIGTERM);
+}
+
+
+/**************************************************************************/
+
+/* SHTDI Global variables not needed above.  */
+
+/* Target operations structure */
+static struct target_ops shtdi_ops;
+
+/* shtdi global variables */
+static int shtdi_targetissimulator = 0;
+static char *shtdi_execName = NULL;
+static int shtdi_args_passed = 0;
+static int shtdi_hw_break_count = 0;
+static int shtdi_hw_watch_count = 0;
+
+static int shtdi_stopped_by_watchpoint_p = 0;
+static CORE_ADDR shtdi_watch_data_address;
+
+/* GDB target routines.  */
+
+static void
+shtdi_compare_sections (char *args, int from_tty)
+{
+  struct cleanup *old_chain = make_cleanup (null_cleanup, 0);
+  asection *s;
+  char *comparename = NULL;
+  unsigned long int compareoffset = 0;
+  int use_vma = 0;
+  int matched = 0;
+  int mismatched = 0;
+
+  if (!exec_bfd)
+    error (_("compare-sections command cannot be used without an exec file"));
+
+  if (args)
+    {
+      int argi = 1;
+      char **argv = buildargv (args);
+
+      if (argv == NULL)
+	nomem(0);
+
+      make_cleanup_freeargv (argv);
+
+      /* Check if first argument "lma", "vma" or a section name */
+      if (strcasecmp (argv[0], "vma") == 0)
+	use_vma = 1;
+      else if (strcasecmp (argv[0], "lma") == 0)
+	use_vma = 0;
+      else
+	{
+	  char *endp = NULL;
+
+	  (void) strtoul (argv[0], &endp, 0);
+	  if (*endp)
+	    comparename = argv[0];
+	  else
+	    argi = 0; /* Reset for later offset check */
+	}
+
+      /* If first argument is a section name check if next is "lma" or "vma" */
+      if (comparename && argv[argi])
+	{
+	  if (strcasecmp (argv[argi], "vma") == 0)
+	    {
+	      argi++;
+	      use_vma = 1;
+	    }
+	  else if (strcasecmp (argv[argi], "lma") == 0)
+	    {
+	      argi++;
+	      use_vma = 0;
+	    }
+	}
+
+      /* Check that next argument is an offset */
+      if (argv[argi])
+	{
+	  char *endp = NULL;
+
+	  compareoffset = strtoul (argv[argi], &endp, 0);
+	  if (*endp)
+	    error (_("Invalid download offset: %s."), argv[argi]);
+	  argi++;
+	}
+
+      if (argv[argi])
+	error (_("Too many parameters."));
+    }
+
+  for (s = exec_bfd->sections; s; s = s->next)
+    {
+      struct cleanup *old_chain = make_cleanup (null_cleanup, 0);
+      const char *sectname;
+      unsigned char *sectdata;
+      unsigned char *targdata;
+      bfd_size_type size, offset;
+      bfd_vma address;
+
+      if (!(s->flags & SEC_LOAD))
+	continue;		/* skip non-loadable section */
+
+      size = bfd_get_section_size (s);
+      if (size == 0)
+	continue;		/* skip zero-length section */
+
+      sectname = bfd_get_section_name (exec_bfd, s);
+      if (comparename && strcmp (comparename, sectname) != 0)
+	continue;		/* not the section selected by user */
+
+      matched = 1;		/* do this section */
+      address = use_vma ? bfd_section_vma (exec_bfd, s)
+			: bfd_section_lma (exec_bfd, s);
+      address += compareoffset;
+      /* FIXME: assumes address can fit into long */
+
+      sectdata = xmalloc (size);
+      make_cleanup (xfree, sectdata);
+      bfd_get_section_contents (exec_bfd, s, sectdata, 0, size);
+
+      targdata = xmalloc (size);
+      make_cleanup (xfree, targdata);
+      target_read_memory (address, targdata, size);
+
+      for (offset = 0; offset < size; offset++)
+	{
+	  if (sectdata[offset] != targdata[offset])
+	    break;
+	}
+
+      printf_filtered ("Section %s, range 0x%s -- 0x%s: ",
+		       sectname, paddr (address), paddr (address + size));
+      if (offset == size)
+	printf_filtered ("matched.\n");
+      else
+	{
+	  printf_filtered ("MIS-MATCHED at 0x%s (0x%02x != 0x%02x).\n",
+			   paddr (address + offset),
+			   targdata[offset], sectdata[offset]);
+	  mismatched++;
+	}
+
+      do_cleanups (old_chain);
+    }
+
+  if (mismatched > 0)
+    warning (_("One or more sections of the executable does not"
+	       " match the loaded file"));
+  if (comparename && !matched)
+    printf_filtered (_("No loaded section named '%s'.\n"), comparename);
+
+  do_cleanups (old_chain);
+}
+
+static void
+add_generic_cmds (void)
+{
+  add_com ("installplugin", class_stm, shtdi_instplugin,
+	   _("Install a plugin to drive the"
+	     " target interface layer directly."));
+
+  add_com ("callplugin", class_stm, shtdi_callplugin,
+	   _("Call an installed target interface plugin."));
+
+  add_cmd ("compare-sections", class_stm, shtdi_compare_sections,
+	   _("Compare section data on target to the exec file.\n"
+	     "Arguments are a single section name, VMA or LMA and an OFFSET.\n"
+	     "Default is to compare all loaded sections."), &cmdlist);
+}
+
+static void
+add_sim_cmds (void)
+{
+}
+
+static void
+add_si_cmds (void)
+{
+}
+
+static void
+delete_generic_cmds (void)
+{
+  delete_cmd ("installplugin", &cmdlist);
+  delete_cmd ("callplugin", &cmdlist);
+  delete_cmd ("compare-sections", &cmdlist);
+}
+
+static void
+delete_sim_cmds (void)
+{
+}
+
+static void
+delete_si_cmds (void)
+{
+}
+
+/*
+ * shtdi_open - called from GDB via target command
+ * Opens SHDEBUG DLL and sets up function pointers
+ */
+static void
+shtdi_open_cleanup (void *nocleanup)
+{
+  int docleanup = !*((int *) nocleanup);
+
+  xfree (nocleanup);
+  if (docleanup)
+    unpush_target (&shtdi_ops);
+}
+
+static void
+shtdi_open (char *args, int from_tty)
+{
+  int *nocleanupflag = NULL;
+  struct cleanup *old_chain = NULL;
+
+  int argi = 0, argc = 0;
+  char **initialargv = NULL, **argv = NULL;
+
+  char *inicommand = NULL;
+  char *shdbgdllname = NULL;
+
+  /* Check if already connected using shtdi interface */
+  if (shtdi_targetconnected)
+    error (_("shtdi target interface already in use,"
+	     " please disconnect first"));
+
+  if (!args)
+    error (_("No arguments supplied to shtdi target interface"));
+
+  /* First pass tokenisation of arguments into argv array */
+  initialargv = buildargv (args);
+  if (!initialargv)
+    nomem (0);
+
+  /* Second pass tokenisation converting space separated argv arguments
+     into separate arguments except for -target option. */
+  for (argi = 0; initialargv[argi]; argi++)
+    {
+      if ((strcmp (initialargv[argi], "-target") == 0)
+	  && initialargv[argi + 1])
+	{
+	  argv = xrealloc (argv, sizeof (char *) * (argc + 2));
+	  argv[argc++] = xstrdup (initialargv[argi++]);
+	  argv[argc++] = xstrdup (initialargv[argi]);
+	}
+      else if (*initialargv[argi])
+	{			/* ignore empty arguments */
+	  char **argiargv = buildargv (initialargv[argi]), **arg;
+	  if (!argiargv)
+	    nomem (0);
+	  for (arg = argiargv; *arg; arg++)
+	    {
+	      if (**arg)
+		{		/* ignore empty arguments */
+		  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+		  argv[argc++] = xstrdup (*arg);
+		}
+	    }
+	  freeargv (argiargv);
+	}
+    }
+  freeargv (initialargv);
+
+  /* Add NULL terminator to argv array a la buildargv() */
+  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+  argv[argc] = NULL;
+
+  /* Reset argv arrays */
+  initialargv = argv;
+  argv = NULL;
+  argc = 0;
+
+  /* Reset target type information */
+  shtdi_targetissimulator = 0;
+  xfree (shtdi_targetName);
+  shtdi_targetName = NULL;
+
+  /* Analyse arguments for recognised options. Strip out -sim and -inicommand
+     options from arguments passed to shdbg_Initialise. */
+  shdbgdllname = initialargv[0];
+  for (argi = 1; initialargv[argi]; argi++)
+    {
+      if (strcmp (initialargv[argi], "-sim") == 0)
+	shtdi_targetissimulator = 1;
+      else if (strcmp (initialargv[argi], "-target") == 0)
+	{
+	  if (initialargv[argi + 1])
+	    {
+	      if (shtdi_targetName)
+		error (_("Cannot specify -target configuration"
+			 " option multiple times"));
+	      else
+		{
+		  argv = xrealloc (argv, sizeof (char *) * (argc + 2));
+		  argv[argc++] = initialargv[argi++];
+		  argv[argc++] = initialargv[argi];
+
+		  xfree (shtdi_targetName);
+		  shtdi_targetName = xstrdup (initialargv[argi]);
+		}
+	    }
+	  else
+	    error (_("Missing target name for -target configuration option"));
+	}
+      else if (strcmp (initialargv[argi], "-inicommand") == 0)
+	{
+	  if (initialargv[argi + 1])
+	    {
+	      if (inicommand)
+		error (_("Cannot specify -inicommand configuration"
+			 " option multiple times"));
+	      else
+		{
+		  argi++;	/* Skip -inicommand */
+		  inicommand = initialargv[argi];
+		}
+	    }
+	  else
+	    error (_("Missing command for -inicommand configuration option"));
+	}
+      else
+	{
+	  argv = xrealloc (argv, sizeof (char *) * (argc + 1));
+	  argv[argc++] = initialargv[argi];
+	}
+    }
+  xfree (initialargv);		/* Only dispose of array at this point */
+
+  /* Replace any commas with spaces for arguments to -inicommand */
+  if (inicommand)
+    {
+      char *s = inicommand;
+      while ((s = strchr (s, ',')))
+	*s = ' ';
+    }
+
+  /* Check target type information supplied */
+  if (shtdi_targetissimulator)
+    {
+      if (shtdi_targetName)
+	error (_("Cannot specify -sim and -target configuration"
+		 " options together"));
+      else
+	{
+	  xfree (shtdi_targetName);
+	  shtdi_targetName = xstrdup ("simulator");
+	}
+    }
+  else
+    {
+      if (!shtdi_targetName)
+	error (_("Neither -sim nor -target configuration option specified"));
+    }
+
+  /* Set the environment to use simulator profiling if not already set */
+  if (shtdi_targetissimulator && get_exec_file (0))
+    shtdi_init_simulator_hook ();
+
+  /* Ensure that we undo everything from this point on error */
+  nocleanupflag = xcalloc (1, sizeof (int));
+  old_chain = make_cleanup (shtdi_open_cleanup, nocleanupflag);
+
+  /* Attempt to load SHDEBUG DLL */
+  shtdi_load_shdebug (shdbgdllname);
+
+#if SHDEBUGAPI_VERSION_MAX(1, 0)
+  if (!shdbg_Initialise (argc, argv, shdbg_error_message_callback))
+    {
+#else
+  if (!shdbg_Initialise (argc, argv, shdbg_print_message_callback,
+			 shdbg_error_message_callback))
+    {
+#endif
+      if (shtdi_targetissimulator)
+	error (_("Unable to connect to simulator target"));
+      else
+	error (_("Unable to connect to remote target %s"), shtdi_targetName);
+    }
+  else
+    shtdi_targetconnected = 1;
+  xfree (argv);
+
+  push_target (&shtdi_ops);
+
+  add_generic_cmds ();
+  if (shtdi_targetissimulator)
+    add_sim_cmds ();
+  else
+    add_si_cmds ();
+
+  /* Disable access to target state */
+  target_mark_exited (&shtdi_ops);
+
+  if (inicommand)
+    {
+      execute_command (inicommand, from_tty);
+
+      /* Maybe disconnected from target, if so return immediately */
+      if (!shtdi_targetconnected)
+	return;
+    }
+
+#if SHDEBUGAPI_VERSION_MAX(1, 0)
+  if (!shdbg_Attach ())
+    {
+#else
+  /* Attach to target using default attach type */
+  if (!shdbg_Attach (-1))
+    {
+#endif
+      if (shtdi_targetissimulator)
+	error (_("Unable to attach to simulator target"));
+      else
+	error (_("Unable to attach to remote target %s"), shtdi_targetName);
+    }
+
+  /* Enable access to target state */
+  target_mark_running (&shtdi_ops);
+
+  if (symfile_objfile != NULL)
+    rtos_check_symbols (symfile_objfile);
+
+  /* Enable RTOS awareness ? */
+  if (set_rtos_initialize_string == rtos_initialize_attach)
+    rtos_init ();
+
+  inferior_ptid = pid_to_ptid (MAGIC_TARGET_PID);
+  start_remote (from_tty);
+
+  *nocleanupflag = 1;		/* Discard cleanups */
+  do_cleanups (old_chain);
+}
+
+static void
+shtdi_close_cleanup (void *d)
+{
+  /* Reset state to initial values on target close */
+  xfree (shtdi_targetName);
+  shtdi_targetName = NULL;
+
+  xfree (shtdi_execName);
+  shtdi_execName = NULL;
+
+  shtdi_targetconnected = 0;
+  shtdi_targetissimulator = 0;
+  shtdi_args_passed = 0;
+  ioconsole_launched = 0;
+  shtdi_rtos_launched = 0;
+  shtdi_hw_break_count = 0;
+  shtdi_hw_watch_count = 0;
+
+  shtdi_stopped_by_watchpoint_p = 0;
+
+  interrupt_requested = 0;
+  target_interrupted = 0;
+  terminate_requested = 0;
+
+  shtdi_unload_shdebug ();
+}
+
+static void
+shtdi_close (int quitting)
+{
+  struct cleanup *old_chain = make_cleanup (shtdi_close_cleanup, NULL);
+
+  ioconsole_close ();
+
+  if (shtdi_targetconnected)
+    {
+      delete_generic_cmds ();
+      if (shtdi_targetissimulator)
+	delete_sim_cmds ();
+      else
+	delete_si_cmds ();
+
+      if (!shdbg_RemovePlugins ())
+	error (_("Unable to uninstall plugins"));
+
+      target_mark_exited (&shtdi_ops);
+
+#if SHDEBUGAPI_VERSION_MAX(1, 1)
+      if (!shdbg_Detach ())
+	{
+#else
+      /* Detach target using default detach type */
+      if (!shdbg_Detach (-1))
+	{
+#endif
+	  if (shtdi_targetissimulator)
+	    error (_("Unable to detach from simulator target"));
+	  else
+	    error (_("Unable to detach from remote target %s"),
+		   shtdi_targetName);
+	}
+
+      if (!shdbg_DeInitialise ())
+	{
+	  if (shtdi_targetissimulator)
+	    error (_("Unable to disconnect from simulator target"));
+	  else
+	    error (_("Unable to disconnect from remote target %s"),
+		   shtdi_targetName);
+	}
+    }
+
+  do_cleanups (old_chain);
+}
+
+static unsigned char *
+shtdi_register_offset (struct regcache *regcache, unsigned char *data, int regno)
+{
+#ifdef SHTDI_GDB_REGISTER_MAP
+  int shtdi_regno = SHTDI_GDB_REGISTER_MAP(regcache, regno);
+#else
+  int shtdi_regno = regno;
+#endif
+
+  if (shtdi_regno != -1)
+    {
+      int i;
+      for (i = 0; i <= shtdi_regno; i++)
+	{
+	  int regsize = shdbg_GetRegSize (i);
+	  if (regsize)
+	    {
+	      if (i < shtdi_regno)
+		data += regsize;
+	      else
+		gdb_assert (regsize == register_size (current_gdbarch, regno));
+	    }
+	  else
+	    error (_("Unable to get size of target register %d"), i);
+	}
+    }
+  else
+    internal_error (__FILE__, __LINE__, _("Invalid register number %d"), regno);
+
+  return data;
+}
+
+static unsigned char *shtdi_fetch_all_registers_data = NULL;
+
+static void
+shtdi_fetch_register_1 (struct regcache *regcache, int regno)
+{
+  if (!shdbg_RtosSetGeneralThreadId (PIDGET (inferior_ptid)))
+    {
+      /* Not really an error if thread does not exist */
+    }
+  if (regno == -1)
+    {
+      int num_regs = gdbarch_num_regs (current_gdbarch);
+      if (!shtdi_fetch_all_registers_data)
+	{
+	  int regsize = shdbg_GetRegSize (-1);
+	  if (regsize)
+	    {
+	      shtdi_fetch_all_registers_data = xcalloc (regsize, sizeof (char));
+	      if (!shdbg_ReadReg (-1, shtdi_fetch_all_registers_data))
+		error (_("Unable to read target registers"));
+	    }
+	  else
+	    error (_("Unable to get size of target registers"));
+	}
+      for (regno = 0; regno < num_regs; regno++)
+	regcache_raw_supply (regcache, regno,
+	  shtdi_register_offset (regcache,
+	    shtdi_fetch_all_registers_data, regno));
+    }
+  else if (shtdi_fetch_all_registers_data)
+    {
+      regcache_raw_supply (regcache, regno,
+	shtdi_register_offset (regcache,
+	  shtdi_fetch_all_registers_data, regno));
+    }
+  else
+    {
+#ifdef SHTDI_GDB_REGISTER_MAP
+      int shtdi_regno = SHTDI_GDB_REGISTER_MAP(regcache, regno);
+#else
+      int shtdi_regno = regno;
+#endif
+      if (shtdi_regno != -1)
+	{
+	  int regsize = shdbg_GetRegSize (shtdi_regno);
+	  if (regsize)
+	    {
+	      unsigned char *regData = alloca (regsize);
+	      gdb_assert (regsize == register_size (current_gdbarch, regno));
+	      if (!shdbg_ReadReg (shtdi_regno, regData))
+		error (_("Unable to read target register %d"), shtdi_regno);
+	      regcache_raw_supply (regcache, regno, regData);
+	    }
+	  else
+	    error (_("Unable to get size of target register %d"), shtdi_regno);
+	}
+      else
+	internal_error (__FILE__, __LINE__, _("Invalid register number %d"), regno);
+    }
+}
+
+static void
+shtdi_fetch_register_cleanup (void *d)
+{
+  xfree (shtdi_fetch_all_registers_data);
+  shtdi_fetch_all_registers_data = NULL;
+}
+
+static void
+shtdi_fetch_register (struct regcache *regcache, int regno)
+{
+  if ((shtdi_read_all_registers || (regno == -1))
+      && !shtdi_fetch_all_registers_data)
+    {
+      struct cleanup *old_chain =
+	make_cleanup (shtdi_fetch_register_cleanup, NULL);
+
+      shtdi_fetch_register_1 (regcache, -1); /* Fetch all registers */
+
+      do_cleanups (old_chain);
+    }
+  else
+    shtdi_fetch_register_1 (regcache, regno);
+}
+
+static void
+shtdi_store_register (struct regcache *regcache, int regno)
+{
+  if (!shdbg_RtosSetGeneralThreadId (PIDGET (inferior_ptid)))
+    {
+      /* Not really an error if thread does not exist */
+    }
+  if (regno == -1)
+    {
+      int regsize = shdbg_GetRegSize (-1);
+      if (regsize)
+	{
+	  unsigned char *regData = alloca (regsize);
+	  int num_regs = gdbarch_num_regs (current_gdbarch);
+	  for (regno = 0; regno < num_regs; regno++)
+	    regcache_raw_read (regcache, regno,
+	      shtdi_register_offset (regcache, regData, regno));
+	  if (!shdbg_WriteReg (-1, regData))
+	    error (_("Unable to write target registers"));
+	}
+      else
+	error (_("Unable to get size of target registers"));
+    }
+  else
+    {
+#ifdef SHTDI_GDB_REGISTER_MAP
+      int shtdi_regno = SHTDI_GDB_REGISTER_MAP(regcache, regno);
+#else
+      int shtdi_regno = regno;
+#endif
+      if (shtdi_regno != -1)
+	{
+	  int regsize = shdbg_GetRegSize (shtdi_regno);
+	  if (regsize)
+	    {
+	      unsigned char *regData = alloca (regsize);
+	      gdb_assert (regsize == register_size (current_gdbarch, regno));
+	      regcache_raw_read (regcache, regno, regData);
+	      if (!shdbg_WriteReg (shtdi_regno, regData))
+		error (_("Unable to write target register %d"), shtdi_regno);
+	    }
+	  else
+	    error (_("Unable to get size of target register %d"), shtdi_regno);
+	}
+      else
+	internal_error (__FILE__, __LINE__, _("Invalid register number %d"), regno);
+    }
+  /* Cope with read only registers */
+  shtdi_fetch_register (regcache, regno);
+}
+
+static void
+shtdi_kill (void)
+{
+  target_mourn_inferior ();
+}
+
+static void
+shtdi_set_exec_file (char *prog)
+{
+#ifndef __MINGW32__
+  static const char *sep = "/";
+#else
+  static const char *sep = ":/\\";
+#endif
+  char *s = prog;
+
+  while ((s = strpbrk (s, sep)) != NULL)
+    prog = ++s;
+
+  xfree (shtdi_execName);
+  shtdi_execName = xstrdup (prog);
+}
+
+static void
+shtdi_load (char *args, int from_tty)
+{
+  char **argv = buildargv (args);
+
+  if (!argv)
+    nomem (0);
+
+  shtdi_set_exec_file (argv[0]);
+  shtdi_args_passed = 0;
+
+  freeargv (argv);
+
+  generic_load (args, from_tty);
+
+  /* Enable RTOS awareness ? */
+  if (set_rtos_initialize_string == rtos_initialize_load)
+    rtos_init ();
+}
+
+static void
+shtdi_create_inferior (char *exec_file, char *args, char **env, int from_tty)
+{
+  char *load_cmd = NULL;
+  struct cleanup *old_chain;
+
+  if (symfile_objfile != NULL)
+    rtos_check_symbols (symfile_objfile);
+
+  xasprintf (&load_cmd, "load");
+
+  old_chain = make_cleanup (xfree, load_cmd);
+  execute_command (load_cmd, from_tty);
+  do_cleanups (old_chain);
+
+  /* Tell wait_for_inferior that we've started a new process.  */
+  init_wait_for_inferior ();
+
+  inferior_ptid = pid_to_ptid (MAGIC_TARGET_PID);
+}
+
+static void
+shtdi_attach (char *args, int from_tty)
+{
+  error (_("'attach' not implemented for target shtdi"));
+}
+
+static void
+shtdi_detach (char *args, int from_tty)
+{
+  error (_("'detach' not implemented for target shtdi. Use disconnect."));
+}
+
+/*
+ * Target resume modes:
+ *
+ * (1) ptid == -1, step = 0
+ *     Resume all threads, no H/W single step
+ * (2) ptid != -1, step = 0
+ *     Resume only specified thread, no H/W single step
+ * (3) ptid == -1, step = 1
+ *     Resume all threads, H/W single step inferior_ptid thread
+ * (4) ptid != -1, step = 1
+ *     Resume only specified thread, H/W single step specified thread
+ *
+ * SHTDI interface only fully supports mode 1 but is able to support
+ * modes 3 and 4 if thread to be stepped is last stopped thread.
+ */
+
+static void
+shtdi_resume (ptid_t ptid, int step, enum target_signal signal)
+{
+  ptid_t last_ptid;
+  struct target_waitstatus last_status;
+
+  get_last_target_status (&last_ptid, &last_status);
+
+  /* Error if not resumuing all threads or not stepping stopped thread */
+  if (!ptid_equal (ptid, minus_one_ptid))
+    {
+      if (step && !ptid_equal (ptid, last_ptid))
+	error (_("Cannot step 'Thread %d', please select 'Thread %d'"),
+	       PIDGET (ptid), PIDGET (last_ptid));
+      else if (!step)
+	error (_("Cannot resume 'Thread %d'"), PIDGET (ptid));
+    }
+  else if (!ptid_equal (last_ptid, minus_one_ptid))
+    {
+      if (step && !ptid_equal (inferior_ptid, last_ptid))
+	error (_("Cannot step 'Thread %d', please select 'Thread %d'"),
+	       PIDGET (inferior_ptid), PIDGET (last_ptid));
+    }
+
+  /* Pass args to I/O subsytem */
+  if (!shtdi_args_passed)
+    {
+      char *args = xstrdup (get_inferior_args ());
+
+      if (!shdbg_SetIoArgs (shtdi_execName, args))
+	error (_("Internal error: unable to set arguments for target"));
+      shtdi_args_passed = 1;
+
+      xfree (args);
+    }
+
+  /* Launch console if not already created */
+  ioconsole_init ();
+
+  /* Enable RTOS awareness ? */
+  if (set_rtos_initialize_string == rtos_initialize_resume)
+    rtos_init ();
+
+  shdbg_RtosClearTasks ();
+  if (step)
+    {
+      if (!shdbg_StepTarget ())
+	error (_("Unable to single step target"));
+    }
+  else
+    {
+      if (!shdbg_Continue (-1))
+	error (_("Unable to restart target"));
+    }
+}
+
+static void
+shtdi_wait_cleanup (void *d)
+{
+  /* Restore the standard GDB signal handler.  */
+  signal (SIGINT, old_interrupt_handler);
+}
+
+static ptid_t
+shtdi_wait (ptid_t ptid, struct target_waitstatus *status)
+{
+  int thread_num = -1;
+  int result = 0;
+#if SHDEBUGAPI_VERSION_MAX(1, 4)
+  int exitCode = 0;
+#else
+  struct targetstate targetState;
+#endif
+  time_t timeStart = time (NULL);
+  struct cleanup *old_chain = NULL;
+
+  /* Reset target interrupt state.  */
+  interrupt_requested = 0;
+  target_interrupted = 0;
+
+  /* Reset target watchpoint state.  */
+  shtdi_stopped_by_watchpoint_p = 0;
+
+  /* Install target interrupt signal handler.  */
+  old_interrupt_handler = signal (SIGINT, interrupt_once);
+
+  old_chain = make_cleanup (shtdi_wait_cleanup, NULL);
+
+  do
+    {
+      /* Stop target if quit flag set.  */
+      if (quit_flag)
+	{
+	  quit_flag = 0;
+	  interrupt_stop ();
+	}
+
+      /* Stop target if timeout expired.  */
+      if ((shtdi_break_timeout > 0)
+	  && ((time (NULL) - timeStart) >= shtdi_break_timeout))
+	interrupt_stop ();
+
+      /* Has the signal handler been triggered?  */
+      interrupt_check ();
+
+      /* Poll the target.  */
+#if SHDEBUGAPI_VERSION_MAX(1, 1)
+      if ((shtdi_break_timeout > 0)
+	  && (shtdi_wait_timeout > ((LONGEST)shtdi_break_timeout * 1000)))
+	result = shdbg_GetState (&exitCode, shtdi_break_timeout);
+      else
+	/* Round up milliseconds to nearest second.  */
+	result = shdbg_GetState (&exitCode, (shtdi_wait_timeout + 999) / 1000);
+#elif SHDEBUGAPI_VERSION_MAX(1, 4)
+      if ((shtdi_break_timeout > 0)
+	  && (shtdi_wait_timeout > ((LONGEST)shtdi_break_timeout * 1000)))
+	result = shdbg_GetState (&exitCode, shtdi_break_timeout * 1000);
+      else
+	result = shdbg_GetState (&exitCode, shtdi_wait_timeout);
+#else
+      if ((shtdi_break_timeout > 0)
+	  && (shtdi_wait_timeout > ((LONGEST)shtdi_break_timeout * 1000)))
+	result = shdbg_GetState (&targetState, shtdi_break_timeout * 1000);
+      else
+	result = shdbg_GetState (&targetState, shtdi_wait_timeout);
+#endif
+
+      /* Keep the Insight GUI alive.  */
+      if (deprecated_ui_loop_hook)
+	if (deprecated_ui_loop_hook (0))
+	  shtdi_kill ();
+    }
+#if SHDEBUGAPI_VERSION_MAX(1, 4)
+  while (result == -1); /* Timeout */
+#else
+  while (result == 0); /* Timeout */
+#endif
+
+  do_cleanups (old_chain);
+
+  /* The target has stopped, but how?  */
+  if (result < 0)		/* Error.  */
+    {
+      warning (_("Target unexpectedly unavailable"));
+      status->value.sig = TARGET_SIGNAL_UNKNOWN;
+      status->kind = TARGET_WAITKIND_SIGNALLED;
+      return minus_one_ptid;
+    }
+  else
+    {
+#if SHDEBUGAPI_VERSION_MAX(1, 4)
+      switch (result)
+#else
+      switch (targetState.stopType)
+#endif
+	{
+	case 0:			/* Target CRT Exit.  */
+	  status->kind = TARGET_WAITKIND_EXITED;
+#if SHDEBUGAPI_VERSION_MAX(1, 4)
+	  status->value.integer = exitCode;
+#else
+	  status->value.integer = targetState.exitCode;
+#endif
+	  break;
+	case 5:			/* Target H/W Watch.  */
+	  shtdi_stopped_by_watchpoint_p = 1;
+#if SHDEBUGAPI_VERSION_MIN(1, 5)
+	  shtdi_watch_data_address = (CORE_ADDR) targetState.stopAddress;
+#endif
+	case 4:			/* Target H/W Break.  */
+	case 2:			/* Target Break.  */
+	case 1:			/* Target Boot.  */
+	  if (interrupt_requested)
+	    status->value.sig = TARGET_SIGNAL_INT;
+	  else
+	    status->value.sig = TARGET_SIGNAL_TRAP;
+	  status->kind = TARGET_WAITKIND_STOPPED;
+	  break;
+	case 3:			/* Target Interrupt.  */
+	  status->value.sig = TARGET_SIGNAL_INT;
+	  status->kind = TARGET_WAITKIND_STOPPED;
+	  break;
+	default:		/* Unknown reason.  */
+	  if (interrupt_requested)
+	    status->value.sig = TARGET_SIGNAL_INT;
+	  else
+	    status->value.sig = TARGET_SIGNAL_TRAP;
+	  status->kind = TARGET_WAITKIND_STOPPED;
+	  warning (_("Target stopped for unknown reason (%d)"), result);
+	  break;
+	}
+    }
+
+  if (!(thread_num = shdbg_RtosGetCurrentThreadId ()))
+    {
+      /* Not really an error if no thread exists.  */
+    }
+  if (!shdbg_RtosSetGeneralThreadId (thread_num))
+    {
+      /* Not really an error if thread does not exist.  */
+    }
+  if (!shdbg_RtosSetContinueThreadId (thread_num))
+    {
+      /* Not really an error if thread does not exist.  */
+    }
+
+  if (thread_num && (thread_num != -1))
+    {
+      if (!in_thread_list (pid_to_ptid (thread_num)))
+	add_thread (pid_to_ptid (thread_num));
+      return pid_to_ptid (thread_num);
+    }
+  return inferior_ptid;
+}
+
+static void
+shtdi_stop (void)
+{
+  /* Invoke Ctrl-C handler.  */
+  raise (SIGINT);
+}
+
+static void
+shtdi_prepare_to_store (struct regcache * r)
+{
+}
+
+static int
+shtdi_xfer_inferior_memory (CORE_ADDR memaddr, gdb_byte * myaddr,
+			    int len, int write, struct mem_attrib *attrib,
+			    struct target_ops *target)
+{
+  int sent = 0;
+  while (len > 0)
+    {
+      bfd_size_type size =
+	(len > download_write_size) ? download_write_size : len;
+      if (write)
+	{
+	  if (!shdbg_WriteMem ((unsigned long) memaddr, size, myaddr))
+	    {
+	      errno = EIO;
+	      return 0;
+	    }
+	}
+      else
+	{
+	  if (!shdbg_ReadMem ((unsigned long) memaddr, size, myaddr))
+	    {
+	      errno = EIO;
+	      return 0;
+	    }
+	}
+      len -= size;
+      myaddr += size;
+      memaddr += size;
+      sent += size;
+    }
+
+  return sent;
+}
+
+static void
+shtdi_files_info (struct target_ops *target)
+{
+}
+
+static int
+shtdi_insert_breakpoint (struct bp_target_info *bp)
+{
+  int bp_type = 0;		/* Standard software break,
+				   not patched from GDB */
+
+  gdbarch_breakpoint_from_pc (current_gdbarch, &bp->placed_address, &bp->placed_size);
+
+  if (!shdbg_SetBreakpoint
+      ((unsigned long) bp->placed_address, bp_type, bp->placed_size))
+    error (_("Unable to set breakpoint at address 0x%08lx"),
+	   (unsigned long) bp->placed_address);
+
+  return 0;
+}
+
+static int
+shtdi_remove_breakpoint (struct bp_target_info *bp)
+{
+  int bp_type = 0;		/* Standard software break,
+				   not patched from GDB */
+
+  gdbarch_breakpoint_from_pc (current_gdbarch, &bp->placed_address, &bp->placed_size);
+
+  if (!shdbg_RemoveBreakpoint
+      ((unsigned long) bp->placed_address, bp_type, bp->placed_size))
+    error (_("Unable to remove breakpoint at address 0x%08lx"),
+	   (unsigned long) bp->placed_address);
+
+  return 0;
+}
+
+static int
+shtdi_insert_hw_breakpoint (struct bp_target_info *bp)
+{
+  int bp_type = 1;		/* Hardware break, not patched from GDB */
+
+#ifdef SHTDI_JOINT_HW_BREAK_LIMIT
+  if (shtdi_hw_break_count + shtdi_hw_watch_count + 1
+      > SHTDI_JOINT_HW_BREAK_LIMIT)
+#else
+  if (shtdi_hw_break_count + 1 > SHTDI_HW_BREAKPOINT_LIMIT)
+#endif
+    return -1;
+
+  gdbarch_breakpoint_from_pc (current_gdbarch, &bp->placed_address, &bp->placed_size);
+
+  if (!shdbg_SetBreakpoint
+      ((unsigned long) bp->placed_address, bp_type, bp->placed_size))
+    error (_("Unable to set hardware breakpoint at address 0x%08lx"),
+	   (unsigned long) bp->placed_address);
+
+  shtdi_hw_break_count++;
+
+  return 0;
+}
+
+static int
+shtdi_remove_hw_breakpoint (struct bp_target_info *bp)
+{
+  int bp_type = 1;		/* Hardware break, not patched from GDB */
+
+  gdbarch_breakpoint_from_pc (current_gdbarch, &bp->placed_address, &bp->placed_size);
+
+  if (!shdbg_RemoveBreakpoint
+      ((unsigned long) bp->placed_address, bp_type, bp->placed_size))
+    error (_("Unable to remove hardware breakpoint at address 0x%08lx"),
+	   (unsigned long) bp->placed_address);
+
+  shtdi_hw_break_count--;
+
+  return 0;
+}
+
+static int
+shtdi_insert_watchpoint (CORE_ADDR addr, int len, int type)
+{
+#ifdef SHTDI_JOINT_HW_BREAK_LIMIT
+  if (shtdi_hw_break_count + shtdi_hw_watch_count + 1
+      > SHTDI_JOINT_HW_BREAK_LIMIT)
+#else
+  if (shtdi_hw_watch_count + 1 > SHTDI_HW_WATCHPOINT_LIMIT)
+#endif
+    return -1;
+
+  switch (type)
+    {
+    case hw_write:
+      if (!shdbg_SetBreakpoint ((unsigned long) addr, 2, len))
+	error (_("Unable to set watchpoint at address 0x%08lx"),
+	       (unsigned long) addr);
+      break;
+    case hw_read:
+      if (!shdbg_SetBreakpoint ((unsigned long) addr, 3, len))
+	error (_("Unable to set watchpoint at address 0x%08lx"),
+	       (unsigned long) addr);
+      break;
+    case hw_access:
+      if (!shdbg_SetBreakpoint ((unsigned long) addr, 4, len))
+	error (_("Unable to set watchpoint at address 0x%08lx"),
+	       (unsigned long) addr);
+      break;
+    default:
+      error (_("Internal error: illegal watchpoint type (%d)"), type);
+    }
+
+  shtdi_hw_watch_count++;
+  return 0;
+}
+
+static int
+shtdi_remove_watchpoint (CORE_ADDR addr, int len, int type)
+{
+  switch (type)
+    {
+    case hw_write:
+      if (!shdbg_RemoveBreakpoint ((unsigned long) addr, 2, len))
+	error (_("Unable to remove watchpoint at address 0x%08lx"),
+	       (unsigned long) addr);
+      break;
+    case hw_read:
+      if (!shdbg_RemoveBreakpoint ((unsigned long) addr, 3, len))
+	error (_("Unable to remove watchpoint at address 0x%08lx"),
+	       (unsigned long) addr);
+      break;
+    case hw_access:
+      if (!shdbg_RemoveBreakpoint ((unsigned long) addr, 4, len))
+	error (_("Unable to remove watchpoint at address 0x%08lx"),
+	       (unsigned long) addr);
+      break;
+    default:
+      error (_("Internal error: illegal watchpoint type (%d)"), type);
+    }
+
+  shtdi_hw_watch_count--;
+  return 0;
+}
+
+static int
+shtdi_can_use_hw_breakpoint (int type, int cnt, int otcnt)
+{
+  if (shtdi_targetissimulator)
+    return 0;
+
+#ifdef SHTDI_JOINT_HW_BREAK_LIMIT
+  if (SHTDI_JOINT_HW_BREAK_LIMIT == 0)
+    return 0;
+
+  switch (type)
+    {
+    case bp_hardware_breakpoint:
+      {
+	int wpcnt, wpotcnt;
+	wpcnt = hw_watchpoint_used_count (bp_hardware_watchpoint, &wpotcnt);
+	if ((cnt + wpcnt + wpotcnt) <= SHTDI_JOINT_HW_BREAK_LIMIT)
+	  return 1;
+      }
+      break;
+    case bp_read_watchpoint:
+    case bp_access_watchpoint:
+    case bp_hardware_watchpoint:
+      {
+	int bpcnt;
+	bpcnt = hw_breakpoint_used_count ();
+	if ((cnt + otcnt + bpcnt) <= SHTDI_JOINT_HW_BREAK_LIMIT)
+	  return 1;
+      }
+      break;
+    }
+#else
+  switch (type)
+    {
+    case bp_hardware_breakpoint:
+      if (SHTDI_HW_BREAKPOINT_LIMIT == 0)
+	return 0;
+      else if (cnt <= SHTDI_HW_BREAKPOINT_LIMIT)
+	return 1;
+      break;
+    case bp_read_watchpoint:
+    case bp_access_watchpoint:
+    case bp_hardware_watchpoint:
+      if (SHTDI_HW_WATCHPOINT_LIMIT == 0)
+	return 0;
+      else if ((cnt + otcnt) <= SHTDI_HW_WATCHPOINT_LIMIT)
+	return 1;
+      break;
+    }
+#endif
+
+  /* The count is too high or the type was unknown.  */
+  return -1;
+}
+
+static int
+shtdi_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
+{
+  /* Hardware can watch any region */
+  return 1;
+}
+
+static int
+shtdi_stopped_by_watchpoint (void)
+{
+  return shtdi_stopped_by_watchpoint_p;
+}
+
+static int
+shtdi_stopped_data_address (struct target_ops *target, CORE_ADDR *addr)
+{
+#if SHDEBUGAPI_VERSION_MAX(1, 4)
+  return 0;
+#else
+  if (shtdi_stopped_by_watchpoint_p)
+    *addr = shtdi_watch_data_address;
+
+  return shtdi_stopped_by_watchpoint_p;
+#endif
+}
+
+static void
+shtdi_monitorcmd (char *command, struct ui_file *outbuf)
+{
+  if (!command)
+    error (_("No arguments passed to monitor command"));
+
+  if (!shdbg_CommandString (command))
+    error (_("monitor command `%s' failed"), command);
+}
+
+static void
+shtdi_mourn_inferior (void)
+{
+  shdbg_RtosClearState ();
+  remove_breakpoints ();
+  generic_mourn_inferior ();
+}
+
+static void
+shtdi_disconnect (struct target_ops *ops, char *args, int from_tty)
+{
+  target_mourn_inferior ();
+  unpush_target (ops);
+}
+
+static void
+init_shtdi_ops (void)
+{
+  shtdi_ops.to_shortname = "shtdi";
+  shtdi_ops.to_longname =
+    _("Remote STMicroelectronics host-target debug interface");
+  shtdi_ops.to_doc =
+    _("Connect to an STMicroelectronics silicon or simulator target\n"
+      "via the STMicroelectronics Host-Target Debug Interface.\n"
+      "Specify the debug interface library (e.g. libshdebug.so)\n"
+      "and appropriate target configuration options (library specific).");
+  shtdi_ops.to_open = shtdi_open;
+  shtdi_ops.to_close = shtdi_close;
+  shtdi_ops.to_xclose = NULL;
+  shtdi_ops.to_attach = shtdi_attach;
+  shtdi_ops.to_post_attach = NULL;
+  shtdi_ops.to_detach = shtdi_detach;
+  shtdi_ops.to_disconnect = shtdi_disconnect;
+  shtdi_ops.to_resume = shtdi_resume;
+  shtdi_ops.to_wait = shtdi_wait;
+  shtdi_ops.to_fetch_registers = shtdi_fetch_register;
+  shtdi_ops.to_store_registers = shtdi_store_register;
+  shtdi_ops.to_prepare_to_store = shtdi_prepare_to_store;
+  /*shtdi_ops.to_prepare_to_fetch = shtdi_prepare_to_fetch; */
+  shtdi_ops.deprecated_xfer_memory = shtdi_xfer_inferior_memory;
+  shtdi_ops.to_xfer_partial = NULL;
+  shtdi_ops.to_files_info = shtdi_files_info;
+
+  shtdi_ops.to_insert_breakpoint = shtdi_insert_breakpoint;
+  shtdi_ops.to_remove_breakpoint = shtdi_remove_breakpoint;
+  shtdi_ops.to_can_use_hw_breakpoint = shtdi_can_use_hw_breakpoint;
+  shtdi_ops.to_insert_hw_breakpoint = shtdi_insert_hw_breakpoint;
+  shtdi_ops.to_remove_hw_breakpoint = shtdi_remove_hw_breakpoint;
+  shtdi_ops.to_insert_watchpoint = shtdi_insert_watchpoint;
+  shtdi_ops.to_remove_watchpoint = shtdi_remove_watchpoint;
+
+  shtdi_ops.to_stopped_by_watchpoint = shtdi_stopped_by_watchpoint;
+  shtdi_ops.to_stopped_data_address = shtdi_stopped_data_address;
+  shtdi_ops.to_region_ok_for_hw_watchpoint = shtdi_region_ok_for_hw_watchpoint;
+
+  shtdi_ops.to_terminal_init = NULL;
+  shtdi_ops.to_terminal_inferior = NULL;
+  shtdi_ops.to_terminal_ours_for_output = NULL;
+  shtdi_ops.to_terminal_ours = NULL;
+  shtdi_ops.to_terminal_info = NULL;
+  shtdi_ops.to_kill = shtdi_kill;
+  shtdi_ops.to_load = shtdi_load;
+  shtdi_ops.to_lookup_symbol = NULL;
+  shtdi_ops.to_create_inferior = shtdi_create_inferior;
+  shtdi_ops.to_post_startup_inferior = NULL;
+  shtdi_ops.to_acknowledge_created_inferior = NULL;
+  shtdi_ops.to_insert_fork_catchpoint = NULL;
+  shtdi_ops.to_remove_fork_catchpoint = NULL;
+  shtdi_ops.to_insert_vfork_catchpoint = NULL;
+  shtdi_ops.to_remove_vfork_catchpoint = NULL;
+  shtdi_ops.to_insert_exec_catchpoint = NULL;
+  shtdi_ops.to_remove_exec_catchpoint = NULL;
+  shtdi_ops.to_reported_exec_events_per_exec_call = NULL;
+  shtdi_ops.to_has_exited = NULL;
+  shtdi_ops.to_mourn_inferior = shtdi_mourn_inferior;
+  shtdi_ops.to_can_run = 0;
+  shtdi_ops.to_notice_signals = 0;
+
+  /* RTOS Specific */
+  shtdi_ops.to_thread_alive = rtos_thread_alive;
+  shtdi_ops.to_find_new_threads = rtos_find_new_threads;
+  shtdi_ops.to_pid_to_str = rtos_pid_to_str;
+  shtdi_ops.to_extra_thread_info = rtos_extra_thread_info;
+
+  shtdi_ops.to_stop = shtdi_stop;
+  shtdi_ops.to_rcmd = shtdi_monitorcmd;
+  shtdi_ops.to_pid_to_exec_file = NULL;
+  shtdi_ops.to_stratum = process_stratum;
+  shtdi_ops.to_has_all_memory = 1;
+  shtdi_ops.to_has_memory = 1;
+  shtdi_ops.to_has_stack = 1;
+  shtdi_ops.to_has_registers = 1;
+  shtdi_ops.to_has_execution = 1;
+  shtdi_ops.to_sections = NULL;
+  shtdi_ops.to_sections_end = NULL;
+  shtdi_ops.to_magic = OPS_MAGIC;
+
+  shdbg_msglevel_init ();
+}
+
+static void
+shtdi_new_objfile (struct objfile *objfile)
+{
+  if (shtdi_targetconnected
+      && objfile == symfile_objfile)  /* Only check top objfile.  */
+    rtos_check_symbols (objfile);
+}
+
+static void
+show_download_write_size (struct ui_file *file, int from_tty,
+			  struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+    _("The write size used when downloading a program is %s.\n"), value);
+}
+
+static void
+show_shtdi_rtos_initialize (struct ui_file *file, int from_tty,
+			    struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+    _("The RTOS awareness initialization hook is \"%s\".\n"), value);
+}
+
+static void
+show_shtdi_wait_timeout (struct ui_file *file, int from_tty,
+			 struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+    _("The timeout when waiting for a target event is %s milliseconds.\n"), value);
+}
+
+static void
+show_shtdi_break_timeout (struct ui_file *file, int from_tty,
+			  struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+    _("The timeout to wait before breaking into the target is %s seconds.\n"), value);
+}
+
+static void
+show_shtdi_rtos_thread_information (struct ui_file *file, int from_tty,
+				    struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+    _("RTOS thread information is %s.\n"), value);
+}
+
+static void
+show_shtdi_read_all_registers (struct ui_file *file, int from_tty,
+			       struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file,
+    _("Read all target registers is %s.\n"), value);
+}
+
+/* For "set shtdi" and "show shtdi".  */
+static struct cmd_list_element *shtdi_set_cmdlist;
+static struct cmd_list_element *shtdi_show_cmdlist;
+
+static void
+set_shtdi_cmd (char *args, int from_tty)
+{
+  printf_unfiltered (
+     _("\"set shtdi\" must be followed by the name of an shtdi subcommand.\n"));
+  help_list (shtdi_set_cmdlist, "set shtdi ", all_commands, gdb_stdout);
+}
+
+static void
+show_shtdi_cmd (char *args, int from_tty)
+{
+  cmd_show_list (shtdi_show_cmdlist, from_tty, "");
+}
+
+/* For "maintenance shtdi".  */
+static struct cmd_list_element *shtdi_maintenance_cmdlist;
+
+static void
+maintenance_shtdi_command (char *args, int from_tty)
+{
+  printf_unfiltered (
+    _("\"maintenance shtdi\" must be followed by the name of an shtdi subcommand.\n"));
+  help_list (shtdi_maintenance_cmdlist,
+    "maintenance shtdi ", all_commands, gdb_stdout);
+}
+
+void
+_initialize_shtdi (void)
+{
+  init_shtdi_ops ();
+  add_target (&shtdi_ops);
+
+  /* Hook into new objfile notification.  */
+  observer_attach_new_objfile (shtdi_new_objfile);
+
+  add_cmd ("STM", class_stm, NULL,
+	   _("STMicroelectronics specific target commands."), &cmdlist);
+
+  add_com ("msglevel", class_stm, shdbg_msglevel_command,
+	   _("Set the target debug interface message level.\n"
+	     "Syntax: msglevel {Level|Source} ...\n"
+	     "Any number of message sources and levels may be enabled.\n"
+	     "Levels: warning info debug alllvl nolvl\n"
+	     "Sources: shdebug sdi rtos io plugin allsrc nosrc\n"
+	     "Enable all messages with: all\n"
+	     "Disable all messages with: none"));
+
+  add_com ("console", class_stm, ioconsole_console_command,
+	   _("Enable or disable the target I/O console.\n"
+	     "Syntax: console on|off"));
+  add_info ("console", info_ioconsole_console_command,
+	    _("Status of the target I/O console."));
+  add_cmd ("console", class_stm, ioconsole_console_disable,
+	   _("Disable the target I/O console."),
+	   &disablelist);
+  add_cmd ("console", class_stm, ioconsole_console_enable,
+	   _("Enable the target I/O console."),
+	   &enablelist);
+
+  add_com ("rtos", class_stm, rtos_command,
+	   _("Enable or disable RTOS awareness.\nSyntax: rtos on|off"));
+  add_info ("rtos", info_rtos_command,
+	    _("Status of RTOS awareness."));
+  add_cmd ("rtos", class_stm, rtos_disable,
+	   _("Disable RTOS awareness."),
+	   &disablelist);
+  add_cmd ("rtos", class_stm, rtos_enable,
+	   _("Enable RTOS awareness."),
+	   &enablelist);
+
+  add_prefix_cmd ("shtdi", class_stm, set_shtdi_cmd,
+    _("SHTDI configuration variables"),
+    &shtdi_set_cmdlist, "set shtdi ", 0, &setlist);
+  add_prefix_cmd ("shtdi", class_stm, show_shtdi_cmd,
+    _("SHTDI configuration variables"),
+    &shtdi_show_cmdlist, "show shtdi ", 0, &showlist);
+
+  add_setshow_enum_cmd ("rtos-initialize-hook", class_stm,
+    rtos_initialize_enum, &set_rtos_initialize_string,
+   _("Set RTOS awareness initialization hook."),
+   _("Show RTOS awareness initialization hook."),
+   _("Valid values are \"attach\", \"load\" and \"resume\"."),
+   NULL,
+   show_shtdi_rtos_initialize,
+   &shtdi_set_cmdlist, &shtdi_show_cmdlist);
+
+  add_setshow_zinteger_cmd ("wait-timeout", class_stm,
+    &shtdi_wait_timeout,
+     _("Set the timeout when waiting for an event from the target."),
+     _("Show the timeout when waiting for an event from the target."),
+     _("Timeout is specified in milliseconds."),
+    NULL,
+    show_shtdi_wait_timeout,
+    &shtdi_set_cmdlist, &shtdi_show_cmdlist);
+
+  add_setshow_zinteger_cmd ("break-timeout", class_stm,
+    &shtdi_break_timeout,
+     _("Set the timeout to wait before breaking into the target."),
+     _("Show the timeout to wait before breaking into the target."),
+     _("Timeout is specified in seconds. Set to 0 to disable."),
+    NULL,
+    show_shtdi_break_timeout,
+    &shtdi_set_cmdlist, &shtdi_show_cmdlist);
+
+  add_setshow_boolean_cmd ("rtos-thread-information", class_stm,
+    &shtdi_rtos_thread_information,
+    _("Set RTOS thread information."),
+    _("Show RTOS thread information."),
+    NULL,
+    NULL,
+    show_shtdi_rtos_thread_information,
+    &shtdi_set_cmdlist, &shtdi_show_cmdlist);
+
+  add_setshow_boolean_cmd ("read-all-registers", class_stm,
+    &shtdi_read_all_registers,
+    _("Set read all target registers."),
+    _("Show read all target registers."),
+    NULL,
+    NULL,
+    show_shtdi_read_all_registers,
+    &shtdi_set_cmdlist, &shtdi_show_cmdlist);
+
+  add_prefix_cmd ("shtdi", class_maintenance, maintenance_shtdi_command,
+    _("Maintenance command for SHTDI internal state."),
+    &shtdi_maintenance_cmdlist, "maintenance shtdi ", 0,  &maintenancelist);
+
+  add_cmd ("rtos-reset", class_maintenance, rtos_reset_command,
+    _("Reset cached RTOS state. Reset levels are \"all\" and \"thread\"."),
+    &shtdi_maintenance_cmdlist);
+
+  add_setshow_integer_cmd ("download-write-size", class_obscure,
+    &download_write_size,
+    _("Set the write size used when downloading a program."),
+    _("Show the write size used when downloading a program."),
+    _("Only used when downloading a program onto a remote\n"
+      "target. Specify zero, or a negative value, to disable\n"
+      "blocked writes. The actual size of each transfer is also\n"
+      "limited by the size of the target packet and the memory\n"
+      "cache."),
+    NULL,
+    show_download_write_size,
+    &setlist, &showlist);
+}
diff -Naur gdb-6.8/gdb/solib.c stsgdb-6.8/gdb/solib.c
--- gdb-6.8/gdb/solib.c	2008-01-07 15:19:58.000000000 +0000
+++ stsgdb-6.8/gdb/solib.c	2008-09-11 10:35:35.000000000 +0100
@@ -87,6 +87,8 @@
 
 static struct so_list *so_list_head;	/* List of known shared objects */
 
+static int solib_enabled = 1;		/* Shared libraries enabled ? */
+
 /* Local function prototypes */
 
 /* If non-empty, this is a search path for loading non-absolute shared library
@@ -674,7 +676,8 @@
 	error (_("Invalid regexp: %s"), re_err);
     }
 
-  update_solib_list (from_tty, target);
+  if (solib_enabled)
+    update_solib_list (from_tty, target);
 
   /* Walk the list of currently loaded shared libraries, and read
      symbols for any that match the pattern --- or any whose symbols
@@ -743,7 +746,8 @@
   /* "0x", a little whitespace, and two hex digits per byte of pointers.  */
   addr_width = 4 + (gdbarch_ptr_bit (current_gdbarch) / 4);
 
-  update_solib_list (from_tty, 0);
+  if (solib_enabled)
+    update_solib_list (from_tty, 0);
 
   for (so = so_list_head; so; so = so->next)
     {
@@ -775,7 +779,14 @@
     }
   if (so_list_head == NULL)
     {
-      printf_unfiltered (_("No shared libraries loaded at this time.\n"));
+      if (solib_enabled)
+	{
+	  printf_unfiltered (_("No shared libraries loaded at this time.\n"));
+	}
+      else
+	{
+	  printf_unfiltered (_("Shared library support is disabled.\n"));
+	}
     }
 }
 
@@ -881,7 +892,8 @@
 solib_create_inferior_hook (void)
 {
   struct target_so_ops *ops = solib_ops (current_gdbarch);
-  ops->solib_create_inferior_hook();
+  if (solib_enabled)
+    ops->solib_create_inferior_hook();
 }
 
 /* GLOBAL FUNCTION
@@ -963,6 +975,39 @@
 		    value);
 }
 
+/* LOCAL FUNCTION
+
+   disable_shared_libraries -- handle command to disable shared library
+   support.
+
+   DESCRIPTION
+
+   Implements the command "disable sharedlibrary".  */
+
+static void
+disable_shared_libraries (char *ignored, int from_tty)
+{
+  solib_enabled = 0;
+  remove_solib_event_breakpoints ();
+  no_shared_libraries (NULL, from_tty);
+}
+
+/* LOCAL FUNCTION
+
+   enable_shared_libraries -- handle command to enable shared library
+   support.
+
+   DESCRIPTION
+
+   Implements the command "enable sharedlibrary".  */
+
+static void
+enable_shared_libraries (char *ignored, int from_tty)
+{
+  solib_enabled = 1;
+  solib_create_inferior_hook ();
+  solib_add (NULL, from_tty, NULL, auto_solib_add);
+}
 
 /* Handler for library-specific lookup of global symbol NAME in OBJFILE.  Call
    the library-specific handler if it is installed for the current target.  */
@@ -1035,4 +1080,12 @@
 				     reload_shared_libraries,
 				     show_solib_search_path,
 				     &setlist, &showlist);
+
+  add_cmd ("sharedlibrary", class_support, disable_shared_libraries, _("\
+Disable shared library support."),
+	   &disablelist);
+
+  add_cmd ("sharedlibrary", class_support, enable_shared_libraries, _("\
+Enable shared library support."),
+	   &enablelist);
 }
diff -Naur gdb-6.8/gdb/solib-svr4.c stsgdb-6.8/gdb/solib-svr4.c
--- gdb-6.8/gdb/solib-svr4.c	2008-02-22 19:48:05.000000000 +0000
+++ stsgdb-6.8/gdb/solib-svr4.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
    2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -977,6 +978,10 @@
   asection *interp_sect;
   CORE_ADDR sym_addr;
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+  asection *dyn_sect;
+#endif
+
   /* First, remove all the solib event breakpoints.  Their addresses
      may have changed since the last time we ran the program.  */
   remove_solib_event_breakpoints ();
@@ -1061,6 +1066,13 @@
       bfd_get_section_contents (exec_bfd, interp_sect,
 				buf, 0, interp_sect_size);
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+      /* [CL] in the case of the relocatable library, the .interp
+         section is "RL_LIB", so that we know that we must revert to the
+         "bkpt_at_symbol mechanism, without emitting a warning */
+      if (strcmp (buf, "RL_LIB") == 0) goto rlib_check_dyn;
+#endif
+
       /* Now we need to figure out where the dynamic linker was
          loaded so that we can load its symbols and place a breakpoint
          in the dynamic linker itself.
@@ -1184,6 +1196,18 @@
                "and track explicitly loaded dynamic code."));
     }
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+ rlib_check_dyn:
+  /* Find the .dynamic section; if not found, it means this is
+     a static executable, so don't bother anymore.
+     Otherwise, we end up setting multiple breakpoints in _start
+     which makes execution stall */
+  dyn_sect = bfd_get_section_by_name (exec_bfd, ".dynamic");
+  if (!dyn_sect) { 
+    return 1;
+  }
+#endif
+
   /* Scan through the lists of symbols, trying to look up the symbol and
      set a breakpoint there.  Terminate loop when we/if we succeed.  */
 
diff -Naur gdb-6.8/gdb/source.c stsgdb-6.8/gdb/source.c
--- gdb-6.8/gdb/source.c	2008-02-08 22:20:48.000000000 +0000
+++ stsgdb-6.8/gdb/source.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2007 STMicroelectronics
 
    This file is part of GDB.
 
@@ -210,6 +211,23 @@
   current_source_line = 0;
 }
 
+/* Open a file, possibly using MinGW magic.  */
+
+static int
+os_open (const char *name, int mode, int prot)
+{
+#ifdef __MINGW32__
+  /* Someone has the habit of writing absolute paths starting with two
+     slashes to the EXE debug info. Windows treats this as a UNC (network
+     machine) name, causing a LONG delay when it tries unsuccessfully to
+     open it. Eliminate that. */
+  if (name[0] == '/' && name[1] == '/')
+    name++;
+#endif
+
+  return open (name, mode, prot);
+}
+
 /* Set the source file default for the "list" command to be S.
 
    If S is NULL, and we don't have a default, find one.  This
@@ -377,8 +395,10 @@
     }
   else
     {
+      CYGPATH (dirname);
       mod_path (dirname, &source_path);
       last_source_visited = NULL;
+      CYGPATH_FREE (dirname);
     }
   if (from_tty)
     show_directories ((char *) 0, from_tty);
@@ -708,7 +728,7 @@
 	{
 	  filename = alloca (strlen (string) + 1);
 	  strcpy (filename, string);
-	  fd = open (filename, mode, prot);
+	  fd = os_open (filename, mode, prot);
 	  if (fd >= 0)
 	    goto done;
 	}
@@ -775,7 +795,7 @@
 
       if (is_regular_file (filename))
 	{
-	  fd = open (filename, mode);
+	  fd = os_open (filename, mode, prot);
 	  if (fd >= 0)
 	    break;
 	}
@@ -960,7 +980,7 @@
           *fullname = rewritten_fullname;
         }
 
-      result = open (*fullname, OPEN_MODE);
+      result = os_open (*fullname, OPEN_MODE, S_IRWXU);
       if (result >= 0)
 	return result;
       /* Didn't work -- free old one, try again. */
diff -Naur gdb-6.8/gdb/stack.c stsgdb-6.8/gdb/stack.c
--- gdb-6.8/gdb/stack.c	2008-03-17 15:06:24.000000000 +0000
+++ stsgdb-6.8/gdb/stack.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -75,6 +76,13 @@
 int annotation_level = 0;
 
 
+int print_frame_id = 0;
+static void
+show_print_frame_id (struct ui_file *file, int from_tty,
+		    struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("Display of the frame id when stepping is %s.\n"), value);
+}
 struct print_stack_frame_args
 {
   struct frame_info *frame;
@@ -732,12 +740,35 @@
 	}
     }
 
-  /* do_cleanups will call ui_out_tuple_end() for us.  */
-  do_cleanups (list_chain);
-  ui_out_text (uiout, "\n");
-  do_cleanups (old_chain);
-}
-
+
+  /* Print a string that represents the frame_id. This could be used by the UI
+     for comparison with the previous frame_id.
+     This is printed only on MI output for step stop reason and when the 
+     "set print frame-id" command is on.  */
+  if (print_frame_id && ui_out_is_mi_like_p (uiout) && stop_step)
+    {
+      struct frame_id this_frame_id;
+      struct cleanup *frame_id_list_chain;
+
+      frame_id_list_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "id");
+      this_frame_id= get_frame_id (frame);
+
+      ui_out_field_string (uiout, "stack", this_frame_id.stack_addr_p ? 
+        paddr (this_frame_id.stack_addr) : "false");
+      ui_out_field_string (uiout, "code", this_frame_id.code_addr_p ? 
+        paddr (this_frame_id.code_addr) : "false");
+      ui_out_field_string (uiout, "special", this_frame_id.special_addr_p ? 
+        paddr (this_frame_id.special_addr) : "false");
+
+      do_cleanups (frame_id_list_chain);
+    }
+    /* do_cleanups will call ui_out_tuple_end() for us.  */
+    do_cleanups (list_chain);
+    ui_out_text (uiout, "\n");
+    do_cleanups (old_chain);
+} 
+
+
 /* Show the frame info.  If this is the tui, it will be shown in the
    source display otherwise, nothing is done.  */
 
@@ -2097,4 +2128,15 @@
   add_info ("backtrace-limit", backtrace_limit_info, _("\
 The maximum number of frames for \"backtrace\" to print by default."));
 #endif
+
+  add_setshow_boolean_cmd ("frame-id", class_stack, &print_frame_id, _("\
+Set the frame id MI printing mode."), _("\
+Show the frame id MI printing mode."), _("\
+Set the printing of the frame ID into the MI output.\n\
+The frame id is printed only if stop reason is end-stepping-range."),
+			   NULL,
+			   show_print_frame_id,
+			   &setprintlist, &showprintlist);
+
+
 }
diff -Naur gdb-6.8/gdb/symfile.c stsgdb-6.8/gdb/symfile.c
--- gdb-6.8/gdb/symfile.c	2008-01-29 22:47:20.000000000 +0000
+++ stsgdb-6.8/gdb/symfile.c	2008-09-11 10:35:35.000000000 +0100
@@ -1787,6 +1787,7 @@
 struct load_section_data {
   unsigned long load_offset;
   struct load_progress_data *progress_data;
+  int use_vma;
   VEC(memory_write_request_s) *requests;
 };
 
@@ -1807,6 +1808,7 @@
   ULONGEST section_sent;
   ULONGEST section_size;
   CORE_ADDR lma;
+  int use_vma;
   gdb_byte *buffer;
 };
 
@@ -1829,8 +1831,9 @@
     {
       /* The write is just starting.  Let the user know we've started
 	 this section.  */
-      ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
+      ui_out_message (uiout, 0, "Loading section %s, size 0x%s %s 0x%s\n",
 		      args->section_name, paddr_nz (args->section_size),
+		      args->use_vma ? "vma" : "lma",
 		      paddr_nz (args->lma));
       return;
     }
@@ -1896,7 +1899,8 @@
 			       args->requests, NULL);
   memset (new_request, 0, sizeof (struct memory_write_request));
   section_data = xcalloc (1, sizeof (struct load_progress_section_data));
-  new_request->begin = bfd_section_lma (abfd, asec) + args->load_offset;
+  new_request->begin = (args->use_vma ? bfd_section_vma (abfd, asec)
+			   : bfd_section_lma (abfd, asec)) + args->load_offset;
   new_request->end = new_request->begin + size; /* FIXME Should size be in instead?  */
   new_request->data = xmalloc (size);
   new_request->baton = section_data;
@@ -1907,6 +1911,7 @@
   section_data->section_name = sect_name;
   section_data->section_size = size;
   section_data->lma = new_request->begin;
+  section_data->use_vma = args->use_vma;
   section_data->buffer = buffer;
 
   bfd_get_section_contents (abfd, asec, buffer, 0, size);
@@ -1943,6 +1948,7 @@
 
   CORE_ADDR entry;
   char **argv;
+  int i = 1;
 
   memset (&cbdata, 0, sizeof (cbdata));
   memset (&total_progress, 0, sizeof (total_progress));
@@ -1960,18 +1966,32 @@
   filename = tilde_expand (argv[0]);
   make_cleanup (xfree, filename);
 
-  if (argv[1] != NULL)
+  if (argv[i] != NULL)
+    {
+      if (strcasecmp (argv[i], "vma") == 0)
+	{
+	  i++;
+	  cbdata.use_vma = 1;
+	}
+      else if (strcasecmp (argv[i], "lma") == 0)
+	{
+	  i++;
+	  cbdata.use_vma = 0;
+	}
+    }
+
+  if (argv[i] != NULL)
     {
       char *endptr;
 
-      cbdata.load_offset = strtoul (argv[1], &endptr, 0);
+      cbdata.load_offset = strtoul (argv[i], &endptr, 0);
 
       /* If the last word was not a valid number then
          treat it as a file name with spaces in.  */
-      if (argv[1] == endptr)
-        error (_("Invalid download offset:%s."), argv[1]);
+      if (argv[i] == endptr)
+        error (_("Invalid download offset:%s."), argv[i]);
 
-      if (argv[2] != NULL)
+      if (argv[i+1] != NULL)
 	error (_("Too many parameters."));
     }
 
diff -Naur gdb-6.8/gdb/target.c stsgdb-6.8/gdb/target.c
--- gdb-6.8/gdb/target.c	2008-01-25 00:09:49.000000000 +0000
+++ stsgdb-6.8/gdb/target.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    Contributed by Cygnus Support.
 
@@ -42,6 +43,8 @@
 
 static void target_info (char *, int);
 
+static void update_current_target (void);
+
 static void maybe_kill_then_attach (char *, int);
 
 static void kill_or_be_killed (int);
@@ -206,6 +209,13 @@
 /* Non-zero if we want to see trace of target level stuff.  */
 
 static int targetdebug = 0;
+
+static void
+set_targetdebug (char *args, int from_tty, struct cmd_list_element *c)
+{
+  update_current_target ();
+}
+
 static void
 show_targetdebug (struct ui_file *file, int from_tty,
 		  struct cmd_list_element *c, const char *value)
@@ -2783,7 +2793,7 @@
 When non-zero, target debugging is enabled.  Higher numbers are more\n\
 verbose.  Changes do not take effect until the next \"run\" or \"target\"\n\
 command."),
-			    NULL,
+			    set_targetdebug,
 			    show_targetdebug,
 			    &setdebuglist, &showdebuglist);
 
diff -Naur gdb-6.8/gdb/testsuite/ChangeLog.sts-gdb stsgdb-6.8/gdb/testsuite/ChangeLog.sts-gdb
--- gdb-6.8/gdb/testsuite/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/ChangeLog.sts-gdb	2008-09-11 10:35:03.000000000 +0100
@@ -0,0 +1,17 @@
+2008-08-29  Denis Pilat  <denis.pilat@st.com>
+
+	* insight-support.exp (gdbtk_start): test TCL_LIBRARY env. variable
+	exists before being unset.
+
+2008-08-28  Denis Pilat  <denis.pilat@st.com>
+
+	* gdb.gdbtk: New testsuite imported from cvs head of gdb.
+
+2008-05-29  Antony King  <antony.king@st.com>
+
+	* gdb.mi/mi-var-cmd.exp: Correct endvar tests.
+
+2006-07-31  Denis Pilat  <denis.pilat@st.com>
+
+	* gdb.base/maint.exp: Change regexp to pass "maint print"
+	tests due to wrong result catching of "shell ls" command.
diff -Naur gdb-6.8/gdb/testsuite/gdb.base/maint.exp stsgdb-6.8/gdb/testsuite/gdb.base/maint.exp
--- gdb-6.8/gdb/testsuite/gdb.base/maint.exp	2008-01-28 18:06:59.000000000 +0000
+++ stsgdb-6.8/gdb/testsuite/gdb.base/maint.exp	2008-09-11 10:35:00.000000000 +0100
@@ -1,5 +1,6 @@
 # Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2007, 2008
 # Free Software Foundation, Inc.
+# Copyright (C) 2006 STMicroelectronics
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -264,7 +265,7 @@
          {
           send_gdb "shell ls psymbols_output\n"
           gdb_expect {
-                -re "psymbols_output\r\n$gdb_prompt $"\
+                -re "psymbols_output\r\n.*$gdb_prompt $"\
                  {
 	          # We want this grep to be as specific as possible,
 	          # so it's less likely to match symbol file names in
@@ -306,7 +307,7 @@
          {
           send_gdb "shell ls msymbols_output\n"
           gdb_expect {
-                -re "msymbols_output\r\n$gdb_prompt $"\
+                -re "msymbols_output\r\n.*$gdb_prompt $"\
                  {
                   send_gdb "shell grep factorial msymbols_output\n"
                   gdb_expect {
@@ -332,7 +333,7 @@
 gdb_test_multiple "maint print msymbols msymbols_output2 ${subdir}/${testfile}" "maint print msymbols" {
     -re "^maint print msymbols msymbols_output2 \[^\n\]*\r\n$gdb_prompt $" {
     	gdb_test_multiple "shell ls msymbols_output2" "maint print msymbols" {
-	    -re "msymbols_output2\r\n$gdb_prompt $" {
+	    -re "msymbols_output2\r\n.*$gdb_prompt $" {
 	    	gdb_test_multiple "shell grep factorial msymbols_output2" "maint print msymbols" {
 		    -re "\\\[ *$decimal\\\] T\[ \t\]+$hex factorial.*$gdb_prompt $" {
 		    	pass "maint print msymbols"
@@ -381,7 +382,7 @@
          {
           send_gdb "shell ls symbols_output\n"
           gdb_expect {
-                -re "symbols_output\r\n$gdb_prompt $"\
+                -re "symbols_output\r\n.*$gdb_prompt $"\
                  {
 	          # See comments for `maint print psymbols'.
                   send_gdb "shell grep 'main(.*block' symbols_output\n"
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/browser.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/browser.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/browser.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/browser.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,41 @@
+# Copyright 1998, 1999, 2001, 2004 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+load_lib ../gdb.gdbtk/insight-support.exp
+
+if {[gdbtk_initialize_display]} {
+  if {$tracelevel} {
+    strace $tracelevel
+  }
+
+  #
+  # test browser window
+  #
+  set prms_id 0
+  set bug_id 0
+
+  set testfile "stack"
+  set binfile ${objdir}/${subdir}/${testfile}
+  set r [gdb_compile "${srcdir}/${subdir}/stack1.c ${srcdir}/${subdir}/stack2.c" "${binfile}" executable {debug}]
+  if  { $r != "" } {
+    gdb_suppress_entire_file \
+      "Testcase compile failed, so some tests in this file will automatically fail."
+  }
+
+  # Start with a fresh gdbtk
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir browser.test]]
+  set results [split $results \n]
+
+  # Analyze results
+  gdbtk_done $results
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/browser.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/browser.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/browser.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/browser.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,686 @@
+# Browser Window Tests
+# Copyright 1998, 2001 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Keith Seitz (keiths@cygnus.com)
+
+# Read in the standard defs file
+
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir test_ran
+set _files(stupid_initializer) -100
+
+#####                            #####
+#                                    #
+#  Helper functions for this module  #
+#                                    #
+#####                            #####
+
+# Set the search expression
+proc set_regexp {exp} {
+  global browser
+
+  $browser component filt_entry delete 0 end
+  $browser component filt_entry insert 0 $exp
+}
+
+# Do the search
+proc do_search {} {
+  global browser
+  $browser search
+  set m [$browser component func_box get 0 end]
+
+  return $m
+}
+
+# Set search to use regular expressions.
+proc set_search_mode {val} {
+  global browser
+  pref set gdb/search/filter_mode $val
+
+  # Use configure instead of entryset: need to have
+  # combobox's command fire
+  $browser component filt_type configure -value $val
+}
+
+# Highlight a file
+proc select {filename} {
+  global browser _files
+
+  if {[info exists _files($filename)]} {
+    $browser component file_box selection set $_files($filename)
+  } else {
+    set files [$browser component file_box get 0 end]
+    set i [lsearch $files $filename]
+    set _files($filename) $i
+    $browser component file_box selection set $i
+  }
+  $browser search
+}
+
+proc select_all {} {
+  global browser
+  
+  $browser component file_all invoke
+
+}
+
+# clear all files
+proc clear {} {
+  global browser
+
+  $browser component file_box selection clear 0 end
+  $browser search
+}
+
+#####         #####
+#                 #
+#  BROWSER TESTS  #
+#                 #
+#####         #####
+
+# Load the test executable
+set program [file join $objdir stack]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+# Open a browser
+set browser [ManagedWin::open BrowserWin]
+
+# Test:  browser-1.1
+# Desc:  Check file listbox contents
+gdbtk_test browser-1.1 {file listbox contents} {
+  set m [$browser component file_box get 0 end]
+  set f {}
+  if {[lsearch $m stack1.c] == -1} {
+    lappend f 0
+  } else {
+    lappend f 1
+  }
+  if {[lsearch $m stack2.c] == -1} {
+    lappend f 0
+  } else {
+    lappend f 1
+  }
+
+  join $f \ 
+} {1 1}
+
+# Tests 2.* test starts with search mode.
+# Test:  browser-2.1
+# Desc:  Check all files/all funcs
+gdbtk_test browser-2.1 {all files/all funcs} {
+  set_search_mode "starts with"
+  set_regexp ""
+  select_all
+  set m [do_search]
+  set r 0
+  foreach f {extern_func1_1 extern_func1_10 extern_func1_11 extern_func1_12 \
+	       extern_func1_13 extern_func1_14 extern_func1_15 extern_func1_2 \
+	       extern_func1_3 extern_func1_4 extern_func1_5 extern_func1_6 \
+	       extern_func1_7 extern_func1_8 extern_func1_9 func_1 \
+	       func_10 func_11 func_12 func_13 \
+	       func_14 func_15 func_2 func_3 \
+	       func_4 func_5 func_6 func_7 \
+	       func_8 func_9 main static_func_1 \
+	       static_func_10 static_func_11 static_func_12 static_func_13 \
+	       static_func_14 static_func_15 static_func_2 static_func_3 \
+	       static_func_4 static_func_5 static_func_6 static_func_7 \
+	       static_func_8 static_func_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {46}
+
+# Test:  browser-2.2
+# Desc:  Check all functions in stack1.c
+gdbtk_test browser-2.2 {all functions in stack1.c} {
+  set_regexp ""
+  clear
+  select stack1.c
+  set m [do_search]
+
+  set r 0
+  foreach f {func_1 func_10 func_11 func_12 \
+	       func_13 func_14 func_15 func_2 \
+	       func_3 func_4 func_5 func_6 \
+	       func_7 func_8 func_9 main \
+	       static_func_1 static_func_10 static_func_11 static_func_12 \
+	       static_func_13 static_func_14 static_func_15 static_func_2 \
+	       static_func_3 static_func_4 static_func_5 static_func_6 \
+	       static_func_7 static_func_8 static_func_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {31}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-2.3
+# Desc:  Check all functions in stack2.c
+gdbtk_test browser-2.3 {all functions in stack2.c} {
+  set_regexp ""
+  clear
+  select stack2.c
+  set m [do_search]
+
+  set r 0
+  foreach f {extern_func1_1 extern_func1_10 extern_func1_11 \
+	       extern_func1_12 extern_func1_13 extern_func1_14 extern_func1_15 \
+	       extern_func1_2 extern_func1_3 extern_func1_4 extern_func1_5 \
+	       extern_func1_6 extern_func1_7 extern_func1_8 extern_func1_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {15}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-2.4
+# Desc:  Check for all functions matching "func" - mode starts with
+gdbtk_test browser-2.4 {all functions matching "func" - "mode starts with"} {
+  set_search_mode "starts with"
+  select_all
+  set_regexp func
+  do_search
+} {func_1 func_10 func_11 func_12 func_13 func_14 func_15 func_2 func_3 func_4 func_5 func_6 func_7 func_8 func_9}
+
+# Test:  browser-2.5
+# Desc:  Check all functions matching "func" in stack1.c - mode starts with
+gdbtk_test browser-2.5 {all functions matching "func" in stack1.c - "mode starts with"} {
+  set_search_mode "starts with"
+  set_regexp func
+  clear
+  select stack1.c
+  do_search
+} {func_1 func_10 func_11 func_12 func_13 func_14 func_15 func_2 func_3 func_4 func_5 func_6 func_7 func_8 func_9}
+
+# Test:  browser-2.6
+# Desc:  Check all functions matching "funcs" in stack2.c - mode starts with
+gdbtk_test browser-2.6 {all functions matching "func" in stack2.c - mode "starts with"} {
+  set_search_mode "starts with"
+  set_regexp func
+  clear
+  select stack2.c
+  do_search
+} {}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-2.7
+# Desc:  Check all functions matching "foobar"
+gdbtk_test browser-2.7 {all functions matching "foobar"} {
+  set_search_mode "starts with"
+  select_all
+  set_regexp foobar
+  do_search
+} {}
+
+# Test:  browser-2.8
+# Desc:  Check all functions matching "foobar" in stack1.c
+gdbtk_test browser-2.8 {functions matching "foobar" in stack1.c} {
+  set_search_mode "starts with"
+  set_regexp foobar
+  clear
+  select stack1.c
+  do_search
+} {}
+
+# Tests 3.* test "contains" search mode.
+# Test:  browser-3.1
+# Desc:  Check all files/all funcs
+gdbtk_test browser-3.1 {all files/all funcs} {
+  set_search_mode "contains"
+  set_regexp ""
+  select_all
+  set m [do_search]
+  set r 0
+  foreach f {extern_func1_1 extern_func1_10 extern_func1_11 extern_func1_12 \
+	       extern_func1_13 extern_func1_14 extern_func1_15 extern_func1_2 \
+	       extern_func1_3 extern_func1_4 extern_func1_5 extern_func1_6 \
+	       extern_func1_7 extern_func1_8 extern_func1_9 func_1 \
+	       func_10 func_11 func_12 func_13 \
+	       func_14 func_15 func_2 func_3 \
+	       func_4 func_5 func_6 func_7 \
+	       func_8 func_9 main static_func_1 \
+	       static_func_10 static_func_11 static_func_12 static_func_13 \
+	       static_func_14 static_func_15 static_func_2 static_func_3 \
+	       static_func_4 static_func_5 static_func_6 static_func_7 \
+	       static_func_8 static_func_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {46}
+
+# Test:  browser-3.2
+# Desc:  Check all functions in stack1.c
+gdbtk_test browser-3.2 {all functions in stack1.c} {
+  set_regexp ""
+  set_search_mode "contains"
+  clear
+  select stack1.c
+  set m [do_search]
+
+  set r 0
+  foreach f {func_1 func_10 func_11 func_12 \
+	       func_13 func_14 func_15 func_2 \
+	       func_3 func_4 func_5 func_6 \
+	       func_7 func_8 func_9 main \
+	       static_func_1 static_func_10 static_func_11 static_func_12 \
+	       static_func_13 static_func_14 static_func_15 static_func_2 \
+	       static_func_3 static_func_4 static_func_5 static_func_6 \
+	       static_func_7 static_func_8 static_func_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {31}
+
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-3.3
+# Desc:  Check all functions in stack2.c
+gdbtk_test browser-3.3 {all functions in stack2.c} {
+  set_regexp ""
+  set_search_mode "contains"
+  clear
+  select stack2.c
+  set m [do_search]
+
+  set r 0
+  foreach f {extern_func1_1 extern_func1_10 extern_func1_11 \
+	       extern_func1_12 extern_func1_13 extern_func1_14 extern_func1_15 \
+	       extern_func1_2 extern_func1_3 extern_func1_4 extern_func1_5 \
+	       extern_func1_6 extern_func1_7 extern_func1_8 extern_func1_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {15}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-3.4
+# Desc:  Check for all functions matching "func" - mode contains
+gdbtk_test browser-3.4 {all functions matching "func_1" - "mode contains"} {
+  set_search_mode "contains"
+  set_regexp "func_1"
+  select_all
+  do_search
+} {func_1 func_10 func_11 func_12 func_13 func_14 func_15 static_func_1 static_func_10 static_func_11 static_func_12 static_func_13 static_func_14 static_func_15}
+
+# Test:  browser-3.5
+# Desc:  Check all functions matching "func_1" in stack1.c - mode contains
+gdbtk_test browser-3.5 {all functions matching "func_1" in stack1.c - "mode contains"} {
+  set_search_mode "contains"
+  set_regexp "func_1"
+  clear
+  select stack1.c
+  do_search
+} {func_1 func_10 func_11 func_12 func_13 func_14 func_15 static_func_1 static_func_10 static_func_11 static_func_12 static_func_13 static_func_14 static_func_15}
+
+# Test:  browser-3.6
+# Desc:  Check all functions matching "func_1" in stack2.c - mode contains
+gdbtk_test browser-3.6 {all functions matching "func" in stack2.c - mode "contains"} {
+  set_search_mode "contains"
+  set_regexp func_1
+  clear
+  select stack2.c
+  do_search
+} {}
+
+# Test:  browser-3.7
+# Desc:  Check all functions matching "foobar"
+gdbtk_test browser-3.7 {all functions matching "foobar"} {
+  set_search_mode "contains"
+  select_all
+  set_regexp foobar
+  do_search
+} {}
+
+# Test:  browser-3.8
+# Desc:  Check all functions matching "foobar" in stack1.c
+gdbtk_test browser-3.8 {functions matching "foobar" in stack1.c} {
+  set_search_mode "contains"
+  set_regexp foobar
+  clear
+  select stack1.c
+  do_search
+} {}
+
+# Tests 4.* test "ends with" search mode.
+# Test:  browser-4.1
+# Desc:  Check all files/all funcs
+gdbtk_test browser-4.1 {all files/all funcs} {
+  set_search_mode "ends with"
+  set_regexp ""
+  select_all
+  set m [do_search]
+  set r 0
+  foreach f {extern_func1_1 extern_func1_10 extern_func1_11 extern_func1_12 \
+	       extern_func1_13 extern_func1_14 extern_func1_15 extern_func1_2 \
+	       extern_func1_3 extern_func1_4 extern_func1_5 extern_func1_6 \
+	       extern_func1_7 extern_func1_8 extern_func1_9 func_1 \
+	       func_10 func_11 func_12 func_13 \
+	       func_14 func_15 func_2 func_3 \
+	       func_4 func_5 func_6 func_7 \
+	       func_8 func_9 main static_func_1 \
+	       static_func_10 static_func_11 static_func_12 static_func_13 \
+	       static_func_14 static_func_15 static_func_2 static_func_3 \
+	       static_func_4 static_func_5 static_func_6 static_func_7 \
+	       static_func_8 static_func_9} {
+    if {[lsearch $m $f] > -1} {
+      incr r
+    }
+  }
+
+  set r
+} {46}
+
+# Test:  browser-4.2
+# Desc:  Check all functions in stack1.c
+gdbtk_test browser-4.2 {all functions in stack1.c} {
+  set_regexp ""
+  set_search_mode "ends with"
+  clear
+  select stack1.c
+  set m [do_search]
+
+  set r 0
+  foreach f {func_1 func_10 func_11 func_12 \
+	       func_13 func_14 func_15 func_2 \
+	       func_3 func_4 func_5 func_6 \
+	       func_7 func_8 func_9 main \
+	       static_func_1 static_func_10 static_func_11 static_func_12 \
+	       static_func_13 static_func_14 static_func_15 static_func_2 \
+	       static_func_3 static_func_4 static_func_5 static_func_6 \
+	       static_func_7 static_func_8 static_func_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {31}
+
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-4.3
+# Desc:  Check all functions in stack2.c
+gdbtk_test browser-4.3 {all functions in stack2.c} {
+  set_regexp ""
+  set_search_mode "ends with"
+  clear
+  select stack2.c
+  set m [do_search]
+
+  set r 0
+  foreach f {extern_func1_1 extern_func1_10 extern_func1_11 \
+	       extern_func1_12 extern_func1_13 extern_func1_14 extern_func1_15 \
+	       extern_func1_2 extern_func1_3 extern_func1_4 extern_func1_5 \
+	       extern_func1_6 extern_func1_7 extern_func1_8 extern_func1_9} {
+    if {[lsearch $m $f] != -1} {
+      incr r
+    }
+  }
+
+  set r
+} {15}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-4.4
+# Desc:  Check for all functions matching "func_1" - mode ends with
+gdbtk_test browser-4.4 {all functions matching "func_1" - "mode ends with"} {
+  set_search_mode "ends with"
+  set_regexp "func_1"
+  select_all
+  do_search
+} {func_1 static_func_1}
+
+# Test:  browser-4.5
+# Desc:  Check all functions matching "func_1" in stack1.c - mode ends with
+gdbtk_test browser-4.5 {all functions matching "func_1" in stack1.c - "mode ends with"} {
+  set_search_mode "ends with"
+  set_regexp "func_1"
+  clear
+  select stack1.c
+  do_search
+} {func_1 static_func_1}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-4.6
+# Desc:  Check all functions matching "func_1" in stack2.c - mode ends with
+gdbtk_test browser-4.6 {all functions matching "func" in stack2.c - mode "ends with"} {
+  set_search_mode "ends with"
+  set_regexp func_1
+  clear
+  select stack2.c
+  do_search
+} {}
+
+# Test:  browser-4.7
+# Desc:  Check all functions matching "foobar"
+gdbtk_test browser-4.7 {all functions matching "foobar"} {
+  set_search_mode "ends with"
+  select_all
+  set_regexp foobar
+  do_search
+} {}
+
+# Test:  browser-4.8
+# Desc:  Check all functions matching "foobar" in stack1.c
+gdbtk_test browser-4.8 {functions matching "foobar" in stack1.c} {
+  set_search_mode "ends with"
+  set_regexp foobar
+  clear
+  select stack1.c
+  do_search
+} {}
+if {$test_ran} {
+  clear
+}
+
+# Test:  browser-5.10
+# Desc:  Check all functions matching regexp "func"
+gdbtk_test browser-5.10 {all functions matching regexp "func"} {
+  set_search_mode "matches regexp"
+  set_regexp func
+  select_all
+  do_search
+} {extern_func1_1 extern_func1_10 extern_func1_11 extern_func1_12 extern_func1_13 extern_func1_14 extern_func1_15 extern_func1_2 extern_func1_3 extern_func1_4 extern_func1_5 extern_func1_6 extern_func1_7 extern_func1_8 extern_func1_9 func_1 func_10 func_11 func_12 func_13 func_14 func_15 func_2 func_3 func_4 func_5 func_6 func_7 func_8 func_9 static_func_1 static_func_10 static_func_11 static_func_12 static_func_13 static_func_14 static_func_15 static_func_2 static_func_3 static_func_4 static_func_5 static_func_6 static_func_7 static_func_8 static_func_9}
+
+# Test:  browser-5.11
+# Desc:  Check all functions matching regexp "func" in stack1.c
+gdbtk_test browser-5.11 {all functions matching regexp "func" in stack1.c} {
+  set_search_mode "matches regexp"
+  set_regexp func
+  clear
+  select stack1.c
+  do_search
+} {func_1 func_10 func_11 func_12 func_13 func_14 func_15 func_2 func_3 func_4 func_5 func_6 func_7 func_8 func_9 static_func_1 static_func_10 static_func_11 static_func_12 static_func_13 static_func_14 static_func_15 static_func_2 static_func_3 static_func_4 static_func_5 static_func_6 static_func_7 static_func_8 static_func_9}
+
+# Test:  browser-5.12
+# Desc:  Check all functions matching regexp "func" in stack2.c
+gdbtk_test browser-5.12 {all functions matching regexp "func" in stack2.c} {
+  set_regexp func
+  clear
+  select stack2.c
+  do_search
+} {extern_func1_1 extern_func1_10 extern_func1_11 extern_func1_12 extern_func1_13 extern_func1_14 extern_func1_15 extern_func1_2 extern_func1_3 extern_func1_4 extern_func1_5 extern_func1_6 extern_func1_7 extern_func1_8 extern_func1_9}
+
+# Test:  browser-5.13
+# Desc:  Check all functions matching regexp "\_1$"
+gdbtk_test browser-5.13 {all functions matching regexp "\_1$"} {
+  set_search_mode "matches regexp"
+  set_regexp {\_1$}
+  select_all
+  do_search
+} {extern_func1_1 func_1 static_func_1}
+
+# Test:  browser-5.14
+# Desc:  Check all functions matching regexp "\_1$" in stack1.c
+gdbtk_test browser-5.14 {all functions matching regexp "\_1$" in stack1.c} {
+  set_search_mode "matches regexp"
+  set_regexp {\_1$}
+  clear
+  select stack1.c
+  do_search
+} {func_1 static_func_1}
+
+# Test:  browser-5.15
+# Desc:  Check all functions matching regexp "\_1$" in stack2.c
+gdbtk_test browser-5.15 {all functions matching regexp "\_1$" in stack2.c} {
+  set_search_mode "matches regexp"
+  set_regexp {\_1$}
+  clear
+  select stack2.c
+  do_search
+} {extern_func1_1}
+
+# Test:  browser-5.16
+# Desc:  Check all functions matching regexp "foobar"
+gdbtk_test browser-5.16 {all functions matching regexp "foobar"} {
+  set_search_mode "matches regexp"
+  set_regexp foobar
+  select_all
+  do_search
+} {}
+
+# Test:  browser-5.17
+# Desc:  Check all functions matching regexp "foobar" in stack1.c
+gdbtk_test browser-5.17 {all functions matching regexp "foobar" in stack1.c} {
+  set_search_mode "matches regexp"
+  set_regexp foobar
+  clear
+  select stack1.c
+  do_search
+} {}
+
+
+# Test:  browser-6.1
+# Desc:  Check select button function
+gdbtk_test browser-6.1 {select button - select all} {
+  clear
+  select_all
+  set m [$browser component file_box curselection]
+
+  expr {[llength $m] >= 2}
+} {1}
+
+# Test:  browser-6.2
+# Desc:  Check that search expressions are saved
+gdbtk_test browser-6.2 {save last search expression} {
+  set_regexp hello
+  select_all
+  do_search
+  pref get gdb/search/last_symbol
+} {hello}
+
+# Test:  browser-7.1
+# Desc:  Toggle all bps on
+gdbtk_test browser-7.1 {toggle_all_bp on} {
+  set_regexp {\_1$}
+  set_search_mode "matches regexp"
+  select_all
+  set funcs [do_search]
+
+  # select all to set bp on
+  $browser component func_box selection set 0 end
+  $browser component func_add_bp invoke
+
+  set bps {}
+  foreach f $funcs {
+    if {![catch {gdb_loc $f} ls]} {
+      if {[bp_exists $ls] != -1} {
+	lappend bps $f
+      }
+    }
+  }
+
+  catch {gdb_cmd "delete" 0}
+  join [lsort $bps]
+} {extern_func1_1 func_1 static_func_1}
+
+# Test:  browser-7.2
+# Desc:  Toggle some bps off
+gdbtk_test browser-7.2 {toggle_some_bp off} {
+  set_regexp {\_1$}
+  set_search_mode "matches regexp"
+  select_all
+  set funcs [do_search]
+
+  $browser component func_box selection set 0 end
+  $browser component func_add_bp invoke
+
+  # Turn off all the "static_func_*" bps
+  set_regexp {^static.*_1$}
+  do_search
+  $browser component func_box selection set 0 end
+  $browser component func_remove_bp invoke
+  set bps {}
+  foreach f $funcs {
+    if {![catch {gdb_loc $f} ls]} {
+      if {[bp_exists $ls] != -1} {
+	lappend bps $f
+      }
+    }
+  }
+
+  catch {gdb_cmd "delete" 0}
+
+  join [lsort $bps]
+} {extern_func1_1 func_1}
+
+#
+#  Exit
+#
+gdbtk_test_done
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/ChangeLog stsgdb-6.8/gdb/testsuite/gdb.gdbtk/ChangeLog
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/ChangeLog	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,353 @@
+2008-03-28  Maciej W. Rozycki  <macro@mips.com>
+
+        * README: Fix a few typos throughout.
+
+2008-02-20  Keith Seitz  <keiths@redhat.com>
+
+	* stack1.c: Include stdlib.h
+	* simple.c: Likewise.
+	Include string.h.
+
+2007-06-27  Maciej W. Rozycki  <macro@mips.com>
+
+	* c_variable.c: Include <stdlib.h> for a declaration of exit().
+
+2007-02-08  Andreas Schwab  <schwab@suse.de>
+
+	* insight-support.exp (gdbtk_start): Return error status instead
+	of aborting the whole testsuite run.
+
+2006-09-19  Keith Seitz  <keiths@redhat.com>
+
+	* Makefile.in: Change all instances of configure.in to refer to
+	configure.ac.
+
+2005-01-27  Keith Seitz  <keiths@redhat.com>
+
+	* configure.in: Rename to ...
+	* configure.ac: ... this.
+	* configure: Regnerate.
+
+2004-07-19  Martin Hunt  <hunt@redhat.com>
+
+	* All: Updated load_lib calls to find new location
+	of insight-support.exp.
+
+2004-07-16  Andrew Cagney  <cagney@redhat.com>
+
+	* insight-support.exp: Moved to here from ../lib.
+
+2003-02-28  Martin M. Hunt  <hunt@redhat.com>
+
+	* c_variable.test: Fix result for 6.22.
+
+2003-02-27  Martin M. Hunt  <hunt@redhat.com>
+
+	* cpp_variable.test: Major changes required because varobj_update
+	now returns "-1" if a variable is out of scope.
+
+	* c_variable.test: Major changes required because varobj_update
+	now returns "-1" if a variable is out of scope. This fixes a bunch 
+	of XFAILS. Change bug reporting address.
+	
+	* windows.test: Remove HtmlViewer from list of windows.
+
+	* srcwin.test: Use "list get" instead of "listget" to
+	get contents of comboboxes. 
+	(2.1): Be less sensitive. 
+
+	* srcwin2.test: Use "list get" instead of "listget" to
+	get contents of comboboxes
+	(2-1.3): Accept assembly == mixed
+	for no source tests.
+
+	* srcwin3.test:  Use "list get" instead of "listget" to
+	get contents of comboboxes
+
+2002-09-09  Fred Fish  <fnf@intrinsity.com>
+
+	* simple.c:  Pass addresses to strncpy, not chars.
+
+2002-04-26  Martin M. Hunt  <hunt@redhat.com>
+
+	* defs (gdbtk_test_done): Call gdbtk_force_quit. 
+
+2002-04-26  Martin M. Hunt  <hunt@redhat.com>
+
+	* srcwin.test (click): Take a button number as an arg.
+	Generate a ButtonPress event then a ButtonRelease event
+	for that button number.
+	(4.4): Fix args for click().
+	(5.1): Fix results again.
+
+2002-03-07  Martin M. Hunt  <hunt@redhat.com>
+
+	* srcwin.test (5.1): Adjust line numbers to
+	test now runs correctly.
+
+2002-01-18  Keith Seitz  <keiths@redhat.com>
+
+	* console.test: Don't rely on "event generate" to do
+	keystrokes. It just doesn't work. Use the console window's
+	"test" method instead.
+	Use Console::test instead of Console::get_text.
+
+2002-01-15  Keith Seitz  <keiths@redhat.com>
+
+	* c_variable.test (1.4,2.14): Remove test for local frame
+	variables. Varobj now forces evaluation in the current frame
+	by default.
+	(2.15): Ignore any changes and only check for out of scope
+	locals (which is still unsupported).
+	* cpp_variable.test (1.1): Support alternative names for
+	local scope.
+	(1.6a): Catch call to gdb_cmd to prevent an error from
+	throwing testsuite into la-la land. Add to test.
+	(1.7): Ignore results from children during step, since
+	they may or may not change value when the parent changes.
+	(2.2a): New test incorperating gdb_cmd (also wrapped in
+	catch).
+	(2.22a): Likewise.
+	(2.71a): Likewise.
+
+2001-12-20  Keith Seitz  <keiths@redhat.com>
+
+	* cpp_variable.test: Catch non-test calls in case we
+	could not run.
+
+2001-10-25  Keith Seitz  <keiths@redhat.com>
+
+	* defs (_report_error): Fix typo.
+	(show_warning): Redefine the standard warning handler
+	so that we don't end up stalling tests with a warning dialog.
+
+	* windows.exp: New file.
+	* windows.test: New file.
+
+2001-10-08  Keith Seitz  <keiths@redhat.com>
+
+	* c_variable.test (check_update): Forget about returning
+	the "unchanged" list. It unneccessarily complicates things.
+	Update all callers.
+	* cpp_variable.test: Likewise.
+
+2001-08-30  Keith Seitz  <keiths@redhat.com>
+
+	* README: Update documentation to reflect recent changes.
+	* browser.exp: Load the insight testsuite support library.
+	* c_variable.exp: Likewise.
+	* console.exp: Likewise.
+	* cpp_variable.exp: Likewise.
+	* srcwin.exp: Likewise.
+
+2001-08-16  Keith Seitz  <keiths@redhat.com>
+
+	* cpp_variable.test (2.29, 2.30, 2.43, 2.63, 2.72): Char
+	pointers can now be dereferenced. Update test to reflect
+	this change in varobj.
+	* c_variable.test (4.9, 4.10, 4.47, 4.48, 5.1, 5.2, 5.3,
+	5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 5.17, 5.18, 5.43, 5.44, 5.47,
+	5.48, 5.49, 5.50, 5.51, 5.53, 6.30): Likewise.
+
+2001-08-13  Jeff Holcomb  <jeffh@redhat.com>
+
+	* cpp_variable.test: Use gdbtk_test_run to start the test
+	program.
+
+2001-05-07  Keith Seitz  <keiths@cygnus.com>
+
+	* README: New file.
+
+        * configure.in: Check for executable filename extension.
+	* Makefile.in: Add filename extensions.
+        * configure: Regenerated.
+
+        * defs: Fix typo setting _test(verbose).
+        (gdbtk_test_file): New proc to load executables into gdbtk.
+        (gdbtk_test_run): New proc to run executables on gdbtk.
+        * browser.exp: Don't check if DISPLAY is set: let
+        gdbtk_initialize_display do it all for us.
+        Call gdbtk_done when finished with tests.
+        * c_variable.exp: Ditto.
+        * console.exp: Ditto.
+        * cpp_variable.exp: Ditto.
+        Only run tests if c++ is supported in the configuration.
+        * srcwin.exp: Ditto the DISPLAY stuff.
+        Accumulate all test results for the end and report them then.
+
+        * browser.test: Use gdbtk_test_file and gdbtk_test_run
+        to load and run an executable.
+        * c_variable.test: Use gdbtk_test_file and gdbtk_test_run
+        to load and run an executable.
+        * srcwin.test: Ditto.
+        * srcwin1.test: Ditto.
+        * srcwin2.test: Ditto.
+
+        * browser.test: (set_search_mode): Use "configure
+        -value" not "entryset" to set the combobox's value. We need
+        to have the command fired.
+        (browser-3.5): Remove trailing whitespace which causes test to
+        fail.
+        (browser-4.4): Expect something rational. Regexp "\_1$" cannot
+        match "func_10"!
+        (browser-4.5): Ditto.
+        (browser-5.12): Select all files for search to make test
+        match description.
+        (browser-6.2): Renamed from another test also calledd 6.1.
+        (browser-7.1): Delete all breakpoints at once without from_tty.
+        Select all entries in the comobox before invoking BP set/delete
+        button.
+        (browser-7.2): Ditto.
+
+        * list0.c, list1.c, list0.h: New files. Grabbed from gdb.base.
+        * srcwin.exp: Use these local files instead of those in gdb.base.
+
+1999-09-17  Fernando Nasser  <fnasser@totem.to.cygnus.com>
+
+	* cpp_variable.test: Add test (2.75) to verify
+	that a baseclass member value was effectively changed.
+
+1999-09-17  Fernando Nasser  <fnasser@totem.to.cygnus.com>
+
+	* cpp_variable.test: Update for new variable
+	code.
+
+1999-09-17  Fernando Nasser  <fnasser@totem.to.cygnus.com>
+
+	* c_variable.test: Update for new variable code.
+
+1999-09-17  Fernando Nasser  <fnasser@totem.to.cygnus.com>
+
+	* cpp_variable.h (class V): Add type to virtual function
+	declaration.
+
+1999-06-08  Fernando Nasser  <fnasser@totem.to.cygnus.com>
+
+	* browser.exp: Use untested and not warning when DISPLAY is
+	not found.
+	* c_variable.exp: Same.
+	* console.exp: Same.
+	* cpp_variable.exp: Same.
+	* srcwin.exp: Same.
+
+1999-04-12  Keith Seitz  <keiths@cygnus.com>
+
+	* cpp_variable.exp: Pass the "c++" flag to gdb_compile so
+	that it can grab the right compiler.
+
+1999-03-16  Martin Hunt  <hunt@cygnus.com>
+
+	* srcwin.test (srcwin-4.5): Change variable name
+	to $b so test will run again.
+
+1999-03-03  James Ingham  <jingham@cygnus.com>
+
+	* browser.test: Fixed up to match the new function browser.
+	This is not done yet...
+
+	* srcwin.test: Check for errors when the bbox is called for a text 
+	item that is not on screen (so bbox is "").  Return something more 
+	useful.
+
+1999-03-01  James Ingham  <jingham@cygnus.com>
+
+	Changelog entries merged over from gdb development branch.
+
+	1999-01-12  Martin Hunt  <hunt@cygnus.com>
+	* srcwin.test: Add a bunch of tests for the source
+	window filename and function comboboxes.  Add in stack tests.
+
+	1999-01-11  Martin Hunt  <hunt@cygnus.com>
+	* srcwin.test: New file. Source Window tests.
+	* srcwin.exp: New file. Source Window tests.
+
+	Wed Jan  6 09:22:52 1999  Keith Seitz  <keiths@cygnus.com>
+	* c_variable.test (c_variable-1.9): Add new
+	test to check for creation of a variable that is really a type.
+	(c_variable-7.81): Use "output" instead of "print" to get PC.
+	Include missing bits of test.
+
+	* cpp_variable.test (cpp_variable-1.6): Default format
+	is now "natural", not "hexadecimal"
+	(cpp_variable-2.22): Ditto.
+	(cpp_variable-2.24): Force format to hex before getting value.
+
+	* cpp_variable.exp: Supply missing arg to gdbtk_analyze_results.
+
+	Tue Jan  5 12:40:52 1999  Keith Seitz  <keiths@cygnus.com>
+	* gdb.gdbtk/c_variable.c, c_variable.test, c_variable.exp: New C
+	language tests for variable object interface.
+	
+	* gdb.gdbtk/cpp_variable.h, cpp_variable.cc, cpp_variable.test,
+	cpp_variable.exp: New C++ language tests for variable object
+	interface.
+	
+	* gdb.gdbtk/Makefile.in (EXECUTABLES): Add c_variable and cpp_variable.
+
+	Tue Jan  5 12:33:47 1999  Keith Seitz  <keiths@cygnus.com>
+	lib/gdb.exp (gdbtk_analyze_results): Generic function
+	for outputting results of test run.
+	
+	* gdb.gdbtk/defs (gdbtk_test): Handle xpass and xfail.
+	(gdbtk_test_error): New proc which handles error aborts.
+	
+	* gdb.gdbtk/console.exp: Use gdbtk_analyze_results.
+	Check if we have a valid DISPLAY before running.
+	* gdb.gdbtk/browser.exp: Ditto.
+
+	1998-12-07  Martin M. Hunt  <hunt@cygnus.com>
+	* lib/gdb.exp (gdbtk_start): Fix path for itcl library.
+	* gdb.gdbtk/browser.test: Change "manage open" to ManagedWin::open.
+	* gdb.gdbtk/console.test: Same.
+	* gdb.gdbtk/*: Update from devo.
+
+	Fri Jul 24 14:57:19 1998  Keith Seitz  <keiths@cygnus.com>
+	* gdb.gdbtk/Makefile.in: Add new example program "stack".
+	* gdb.gdbtk/browser.test,browser.exp: Add browser window
+	  tests.
+	* gdb.gdbtk/stack1.c,stack2.c: Test case for browser window.
+
+1999-02-22  Martin Hunt  <hunt@cygnus.com>
+
+	* srcwin.test (move_mouse_to): Fix typo.
+
+1999-02-03  Martin Hunt  <hunt@cygnus.com>
+
+	* console.test (clear_command_line): Add tests 1.5 - 1.8,
+	which test the new Shift-Up and Shift-Down bindings.
+
+1999-02-01  Martin Hunt  <hunt@cygnus.com>
+
+	* srcwin.test (srcwin-4.3): Fix bp test.
+
+1999-01-29  Martin Hunt  <hunt@cygnus.com>
+
+	* srcwin.test (click): New function that generates an event
+	at a location.
+	(srcwin-4.4): New test. Simulate a click on a line and
+	check for breakpoint set.
+	(srcwin-4.5): New test. Right-click on a line and select "Continue
+	to Here" from popup.
+
+	* srcwin.exp: Source srcwin3.test, which will test source window
+	assembly debugging on executables built without "-g".
+	
+1999-01-29  Martin Hunt  <hunt@cygnus.com>	
+
+	* srcwin.exp: Add srcwin2.test, which are basically the same
+	tests as srcwin.test, but run with a missing source file.
+
+	* srcwin2.test: New file.
+
+	* srcwin.test: Add tests for setting breakpoints in the source window,
+	testing BP balloons, variable balloons, and mixed-mode disassembly
+	of include files.
+
+Sun Jun 28 22:34:34 1998  Martin M. Hunt  <hunt@cygnus.com>
+
+	* gdb.gdbtk/simple.c (main): Make main return an
+	int so compiler will stop complaining.
+
+Fri Jun 26 14:27:13 1998  Keith Seitz  <keiths@cygnus.com>
+
+	* gdb.gdbtk/console.{exp, test}: New console window tests.
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/configure stsgdb-6.8/gdb/testsuite/gdb.gdbtk/configure
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/configure	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/configure	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,2248 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="defs"
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CC build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os LIBOBJS LTLIBOBJS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+  --target=TARGET   configure for building compilers for TARGET [HOST]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+CC=${CC-cc}
+
+ac_aux_dir=
+for ac_dir in `cd $srcdir;pwd`/../../.. $srcdir/`cd $srcdir;pwd`/../../..; do
+  if test -f $ac_dir/install-sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f $ac_dir/install.sh; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f $ac_dir/shtool; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \`cd $srcdir;pwd\`/../../.. $srcdir/\`cd $srcdir;pwd\`/../../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in \`cd $srcdir;pwd\`/../../.. $srcdir/\`cd $srcdir;pwd\`/../../.." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
+
+# Make sure we can run config.sub.
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
+   { (exit 1); exit 1; }; }
+
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
+if test "${ac_cv_build+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
+  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
+echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
+   { (exit 1); exit 1; }; }
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
+build=$ac_cv_build
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
+if test "${ac_cv_host+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
+host=$ac_cv_host
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
+if test "${ac_cv_target+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
+target=$ac_cv_target
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+
+# The aliases save the names the user supplied, while $host etc.
+# will get canonicalized.
+test -n "$target_alias" &&
+  test "$program_prefix$program_suffix$program_transform_name" = \
+    NONENONEs,x,x, &&
+  program_prefix=${target_alias}-
+
+
+
+          ac_config_files="$ac_config_files Makefile"
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then we branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+cat >confdef2opt.sed <<\_ACEOF
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+d
+: quote
+s,[	 `~#$^&*(){}\\|;'"<>?],\\&,g
+s,\[,\\&,g
+s,\],\\&,g
+s,\$,$$,g
+p
+_ACEOF
+# We use echo to avoid assuming a particular line-breaking character.
+# The extra dot is to prevent the shell from consuming trailing
+# line-breaks from the sub-command output.  A line-break within
+# single-quotes doesn't work because, if this script is created in a
+# platform that uses two characters for line-breaks (e.g., DOS), tr
+# would break.
+ac_LF_and_DOT=`echo; echo .`
+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr "$ac_LF_and_DOT" ' .'`
+rm -f confdef2opt.sed
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@CC@,$CC,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/configure.ac stsgdb-6.8/gdb/testsuite/gdb.gdbtk/configure.ac
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/configure.ac	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/configure.ac	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,18 @@
+dnl Process this file file with autoconf to produce a configure script.
+dnl This file is a shell script fragment that supplies the information
+dnl necessary to tailor a template configure script into the configure
+dnl script appropriate for this directory.  For more information, check
+dnl any existing configure script.
+
+AC_PREREQ(2.5)
+AC_INIT(defs)
+
+CC=${CC-cc}
+AC_SUBST(CC)
+AC_CONFIG_AUX_DIR(`cd $srcdir;pwd`/../../..)
+AC_CANONICAL_SYSTEM
+
+dnl Check for exe extension set on certain hosts (e.g. Win32)
+AC_EXEEXT
+
+AC_OUTPUT(Makefile)
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/console.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/console.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/console.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/console.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,42 @@
+# Copyright 1998, 1999, 2001, 2004 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+load_lib ../gdb.gdbtk/insight-support.exp
+
+if {[gdbtk_initialize_display]} {
+  if {$tracelevel} {
+    strace $tracelevel
+  }
+
+  #
+  # test console window
+  #
+  set prms_id 0
+  set bug_id 0
+
+  set testfile "simple"
+  set srcfile ${testfile}.c
+  set binfile ${objdir}/${subdir}/${testfile}
+  set r [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}]
+  if  { $r != "" } {
+    gdb_suppress_entire_file \
+      "Testcase compile failed, so some tests in this file will automatically fail."
+  }
+
+  # Start with a fresh gdbtk
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir console.test]]
+  set results [split $results \n]
+
+  # Analyze results
+  gdbtk_done $results
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/console.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/console.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/console.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/console.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,491 @@
+#   Copyright (C) 1998, 1999, 2002 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Keith Seitz (keiths@cygnus.com)
+
+# Read in the standard defs file
+
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir test_ran
+global console text
+set console [ManagedWin::open Console]
+set text [$console test set _twin]
+
+#####                            #####
+#                                    #
+#  Helper functions for this module  #
+#                                    #
+#####                            #####
+
+# console_command --
+#      Invoke STRING as a command in the console window and
+#      return the result
+proc console_command {string} { 
+  global console text
+
+  # Save current position
+  set line [lindex [split [$text index cmdmark] .] 0]
+  incr line 1
+
+  # Insert and invoke command
+  $text insert end $string
+  $console invoke
+  update
+
+  # Get the result
+  set end [lindex [split [$text index cmdmark] .] 0]
+  incr end -1
+  return [$text get $line.0 [list $end.0 lineend]]
+} 
+
+# get_cmd_line --
+#     Return the command line
+proc get_cmd_line {} {
+  global text
+
+  update
+  set index [$text index cmdmark]
+  return [$text get [list $index linestart] [list $index lineend]]
+}
+
+# clear_command_line --
+#     Clear the command line
+proc clear_command_line {} {
+  global text
+  $text delete {cmdmark + 1 char} insert
+}
+
+#####         #####
+#                 #
+#  CONSOLE TESTS  #
+#                 #
+#####         #####
+
+#
+# Miscellaneous tests
+#
+
+# Test:  console-misc-1
+# Desc:  Change console prompt
+gdbtk_test console-misc-1 {change console prompt} {
+  # Insert the "set prompt" command into the text widget
+  console_command {set prompt (test) }
+
+  $text get {cmdmark linestart} {cmdmark lineend}
+} {(test) }
+if {$test_ran} {
+  console_command {set prompt (gdb) }
+}
+
+#
+# Paste tests
+#
+
+# Test:  console-paste-1
+# Desc:  Paste the X selection into console window
+gdbtk_test console-paste-1 {paste X text} {
+  # This is cheesy, but it works... Create a text widget
+  # which holds the current selection...
+  text .test_text
+  .test_text insert end "this is some pasted text"
+  .test_text tag add sel 1.0 {1.0 lineend}
+  event generate .test_text <<Copy>>
+  event generate $text <<Paste>>
+  get_cmd_line
+} {(gdb) this is some pasted text}
+if {$test_ran} {
+  destroy .test_text
+  clear_command_line
+}
+
+#
+# Test for errors
+#
+
+# Test:  console-error-1
+# Desc:  Check if console window reports internal gdb errors
+gdbtk_test console-error-1 {invoke unknown command} {
+  console_command {this_command_doesn't_exist}
+} {Error: Undefined command: "this".  Try "help".
+}
+
+#
+# History tests
+#
+
+# Test:  console-history-1.1
+# Desc:  Exercise the up-history functionality
+gdbtk_test console-history-1.1 {up history once} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+  # this doesn't seem to work reliably: event generate $text <Up>
+  $console test _previous
+  get_cmd_line
+} {(gdb) help si}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-1.2
+# Desc:  Exercise the up-history functionality
+gdbtk_test console-history-1.2 {up history twice} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+  # this doesn't seem to work reliably: event generate $text <Up>
+  # this doesn't seem to work reliably: event generate $text <Up>
+  $console test _previous
+  $console test _previous
+  get_cmd_line
+} {(gdb) help quit}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-1.3
+# Desc:  Exercise the up-history functionality
+gdbtk_test console-history-1.3 {up history four times} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+
+  for {set i 0} {$i < 4} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Up>
+    $console test _previous
+  }
+  get_cmd_line
+} {(gdb) show remotedevice}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-1.4
+# Desc:  Exercise the up-history functionality
+gdbtk_test console-history-1.4 {up fourteen times} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+  for {set i 0} {$i < 14} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Up>
+    $console test _previous
+  }
+  get_cmd_line
+} {(gdb) show annotate}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-1.5
+# Desc:  Exercise the up-history search functionality
+gdbtk_test console-history-1.5 {up search} {
+ # Add some commands into the command buffer
+  console_command {show height}
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {print main}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+
+  $text insert end "sh"
+  # this doesn't seem to work reliably: event generate $text <Shift-Up>
+  # this doesn't seem to work reliably: event generate $text <Shift-Up>
+  # this doesn't seem to work reliably: event generate $text <Shift-Up>
+  $console test _search_history
+  $console test _search_history
+  $console test _search_history
+  get_cmd_line
+} {(gdb) show annotate}
+
+
+# Test:  console-history-1.6
+# Desc:  Exercise the down-history search functionality
+gdbtk_test console-history-1.6 {down search} {
+  # this doesn't seem to work reliably: event generate $text <Shift-Down>
+  # this doesn't seem to work reliably: event generate $text <Shift-Down>
+  $console test _rsearch_history
+  $console test _rsearch_history
+  get_cmd_line
+} {(gdb) show remotelogbase}
+
+# Test:  console-history-1.7
+# Desc:  Down-history search to bottom
+# We go back down until the original partialcommand is displayed
+gdbtk_test console-history-1.7 {down search to bottom} {
+  # this doesn't seem to work reliably: event generate $text <Shift-Down>
+  # this doesn't seem to work reliably: event generate $text <Shift-Down>
+  $console test _rsearch_history
+  $console test _rsearch_history
+  get_cmd_line
+} {(gdb) sh}
+
+# Test:  console-history-1.8
+# Desc:  Up-history search to top
+# We go up until there are no matches
+gdbtk_test console-history-1.8 {up search to top} {
+  for {set i 0} {$i < 100} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Shift-Up>
+    $console test _search_history
+  }
+  get_cmd_line
+} {(gdb) show annotate}
+
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-2.1
+# Desc:  Exercise the down-history functionality
+gdbtk_test console-history-2.1 {down once} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+
+  for {set i 0} {$i < 14} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Up>
+    $console test _previous
+  }
+  # this doesn't seem to work reliably: event generate $text <Down>
+  $console test _next
+  get_cmd_line
+} {(gdb) show complaints}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-2.2
+# Desc:  Exercise the down-history functionality
+gdbtk_test console-history-2.2 {down twice} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+
+  for {set i 0} {$i < 14} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Up>
+    $console test _previous
+  }
+
+  # this doesn't seem to work reliably: event generate $text <Down>
+  # this doesn't seem to work reliably: event generate $text <Down>
+  $console test _next
+  $console test _next
+  get_cmd_line
+} {(gdb) show confirm}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-2.3
+# Desc:  Exercise the down-history functionality
+gdbtk_test console-history-2.3 {down four times} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+
+  for {set i 0} {$i < 14} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Up>
+    $console test _previous
+  }
+
+  for {set i 0} {$i < 4} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Down>
+    $console test _next
+  }
+  get_cmd_line
+} {(gdb) show language}
+if {$test_ran} {
+  clear_command_line
+}
+
+# Test:  console-history-2.4
+# Desc:  Exercise the down-history functionality
+gdbtk_test console-history-2.4 {down infinitely} {
+  # Add some commands into the command buffer
+  console_command {show annotate}
+  console_command {show complaints}
+  console_command {show confirm}
+  console_command {show height}
+  console_command {show language}
+  console_command {show print demangle}
+  console_command {show remotebaud}
+  console_command {show remotebreak}
+  console_command {show remotecache}
+  console_command {show remotedebug}
+  console_command {show remotedevice}
+  console_command {show remotelogbase}
+  console_command {help quit}
+  console_command {help si}
+  for {set i 0} {$i < 14} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Up>
+    $console test _previous
+  }
+
+  for {set i 0} {$i < 20} {incr i} {
+    # this doesn't seem to work reliably: event generate $text <Down>
+    $console test _next
+  }
+  get_cmd_line
+} {(gdb) }
+if {$test_ran} {
+  clear_command_line
+}
+
+#
+# gdb - gdbtk Interface Tests
+#
+
+# Test:  console-interface-1.1
+# Desc:  Verify that a "file" command in the console window causes
+#        gdb to invoke the pre-/post-add-symbol hooks
+set file_loaded 0
+gdbtk_test console-interface-1.1 {file command goes through hooks} {
+  global TEST1_RESULT TEST2_RESULT
+
+  # This is really ugly, but its the only way to do this...
+  rename gdbtk_tcl_pre_add_symbol pre_add
+  rename gdbtk_tcl_post_add_symbol post_add
+
+  proc gdbtk_tcl_pre_add_symbol {file} {
+    global TEST1_RESULT
+
+    set TEST1_RESULT $file
+    pre_add $file
+  }
+  proc gdbtk_tcl_post_add_symbol {} {
+    global TEST2_RESULT
+
+    set TEST2_RESULT ok
+    post_add
+  }
+
+  # load a file and make sure we went through the pre/post_add_symbol hooks
+  set TEST1_RESULT {}
+  set TEST2_RESULT {}
+  set file [file join $objdir simple]
+  console_command "file $file"
+  if {$TEST1_RESULT != $file} {
+    set result "did not go through gdbtk_tcl_pre_add_symbol ($TEST1_RESULT)"
+  } elseif {$TEST2_RESULT != "ok"} {
+    set result "did not go through gdbtk_tcl_post_add_symbol"
+  } else {
+    set result {}
+    set file_loaded 1
+  }
+
+  set result
+} {}
+if {$test_ran} {
+  rename gdbtk_tcl_pre_add_symbol {}
+  rename gdbtk_tcl_post_add_symbol {}
+  rename pre_add gdbtk_tcl_pre_add_symbol
+  rename post_add gdbtk_tcl_post_add_symbol
+}
+
+#
+#  Exit
+#
+gdbtk_test_done
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.cc stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.cc
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.cc	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.cc	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,33 @@
+#include "cpp_variable.h"
+
+static void do_simple_class_tests (void);
+
+int
+VB::fvb_pub () {return 300 + vb_pub_int;}
+
+int
+VB::vvb_pub () {return 400 + vb_pub_int;}
+
+int
+V::f () {return 600 + v_pub_int;}
+
+int
+V::vv () {return 400 + v_pub_int;}
+
+int
+VC::fvc () {return 300 + vc_pub_int;}
+
+int
+VC::vfvc () {return 100 + vc_pub_int;}
+
+main ()
+{
+  do_simple_class_tests ();
+}
+
+static void
+do_simple_class_tests (void)
+{
+  V *v = new V;
+  V vv;
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,48 @@
+# Copyright 1999, 2001, 2004 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+load_lib ../gdb.gdbtk/insight-support.exp
+
+if {[gdbtk_initialize_display]} {
+  if {$tracelevel} {
+    strace $tracelevel
+  }
+
+  set results {}
+  if {[skip_cplus_tests]} {
+    # Target doesn't have c++ support
+    verbose "No C++ support -- skipping test"
+  } else {
+    #
+    # test variable API
+    #
+    set prms_id 0
+    set bug_id 0
+
+    set testfile "cpp_variable"
+    set srcfile ${testfile}.cc
+    set binfile ${objdir}/${subdir}/${testfile}
+    set r [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug c++}]
+    if  { $r != "" } {
+      gdb_suppress_entire_file \
+	"Testcase compile failed, so some tests in this file will automatically fail."
+    }
+
+    # Start with a fresh gdbtk
+    gdb_exit
+    set results [gdbtk_start [file join $srcdir $subdir ${testfile}.test]]
+    set results [split $results \n]
+  }
+
+  # Analyze results
+  gdbtk_done $results
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.h stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.h
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.h	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,54 @@
+struct _foo
+{
+  int a[10];
+  char *p;
+};
+
+class VA
+{
+ public:
+  int va_pub_int;
+  char *va_pub_charp;
+
+ private:
+  int va_priv_int;
+  char *va_priv_charp;
+
+ protected:
+  struct _foo bar;
+};
+
+class VB
+{
+ public:
+  int vb_pub_int;
+
+  int fvb_pub ();
+  virtual int vvb_pub ();
+
+ private:
+  int vb_priv_int;
+  char *vb_priv_charp;
+};
+
+class VC
+{
+ public:
+  int vc_pub_int;
+
+  int fvc ();
+  virtual int vfvc ();
+};
+
+class V : public VA, public VB, public VC
+{
+ public:
+  int f ();
+  virtual int vv ();
+  int v_pub_int;
+  char *v_pub_charp;
+
+ private:
+  int v_priv_int;
+  char *v_priv_charp;
+};
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/cpp_variable.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,594 @@
+# Varobj Tests (C++ language)
+# Copyright (C) 1998, 2003 Red Hat, Inc.
+#
+# This Program Is Free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# insight@sources.redhat.com
+
+# This file was written by Keith Seitz (keiths@cygnus.com)
+
+# Read in the standard defs file
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir test_ran
+
+# Load in a file
+set program [file join $objdir cpp_variable]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+# The variables that are created are stored in an array called "var".
+
+# proc to tell us which of the variables are changed/out of scope
+proc check_update {} {
+  global var
+
+  set out {}
+  set changed {}
+  foreach ind [array names var] {
+    set ret [$var($ind) update]
+    if {$ret == -1} {
+	lappend out $ind
+    } elseif {$ret != ""} {
+        lappend changed $ret
+    }
+  }
+  return [list $changed $out]
+}
+
+
+# proc to create a variable
+proc create_variable {expr} {
+  global var
+
+  set err [catch {gdb_variable create "$expr" -expr $expr} v]
+  if {!$err} {
+    set var($expr) $v
+  }
+
+  return $err
+}
+
+# proc to get the children
+# Children are stored in the global "var" as
+# PARENT.child. So for struct _foo {int a; int b} bar;,
+# the children returned are {a b} and var(bar.a) and var(bar.b)
+# map the actual objects to their names.
+proc get_children {parent} {
+  global var
+
+  set kiddies [$var($parent) children]
+  set children {}
+  foreach child $kiddies {
+    set name [lindex [split $child .] end]
+    lappend children $name
+    set var($parent.$name) $child
+  }
+
+  return $children
+}
+
+proc delete_variable {varname} {
+  global var
+
+  if {[info exists var($varname)]} {
+    # This has to be caught, since deleting a parent
+    # will erase all children.
+    $var($varname) delete
+    set vars [array names var $varname*]
+    foreach v $vars {
+      if {[info exists var($v)]} {
+	unset var($v)
+      }
+    }
+  }
+}
+
+# Compare the values of variable V in format FMT with value of OBJ
+# with gdb's value.
+proc cppvalue {obj v fmt} {
+  global var
+  global _test
+
+  puts $_test(logfile) "obj=$obj v=$v fmt=$fmt"
+  puts $_test(logfile) "var(\$obj)=$var($obj)"
+
+  set value [$var($obj) value]
+  set gdb [gdb_cmd "output/$fmt $v"]
+  puts $_test(logfile) "output/$fmt $v"
+  if {$value == $gdb} {
+    puts $_test(logfile) "gdbtk: $value == gdb: $gdb"
+    set result ok
+  } else {
+    set result $v
+    puts $_test(logfile) "gdbtk: $value <> gdb: $gdb"
+  }
+
+  return $result
+}
+
+proc delete_all_variables {} {
+  global var
+
+  foreach variable [array names var] {
+    delete_variable $variable
+  }
+}
+
+#####            #####
+#                    #
+# Simple Class Tests #
+#                    #
+#####            #####
+
+# run to "do_simple_class_tests"
+gdb_cmd "break do_simple_class_tests"
+gdbtk_test_run
+
+# Test:  cpp_variable-1.1
+# Desc:  stopped in do_simple_class_tests
+gdbtk_test cpp_variable-1.1 {stopped in do_simple_class_tests} {
+  # G++ can output "do_simple_class_tests(void)". Strip the "(void)" part.
+  set loc [lindex [gdb_loc] 1]
+  set index [string first \( $loc]
+  if {$index > 0} {
+    set loc [string range $loc 0 [expr {$index-1}]]
+  }
+  set loc
+} {do_simple_class_tests}
+
+# Test: cpp_variable-1.2
+# Desc: create variable v
+gdbtk_test cpp_variable-1.2 {create variable v} {
+  create_variable v
+} {0}
+
+# Test: cpp_variable-1.3
+# Desc: number of children of v
+gdbtk_test cpp_variable-1.3 {number of children of v} {
+  $var(v) numChildren
+} {5}
+
+# Test: cpp_variable-1.4a
+# Desc: children of v
+gdbtk_test cpp_variable-1.4a {children of v} {
+  get_children v
+} {VA VB VC public private}
+
+# Test: cpp_variable-1.4b
+# Desc: public children of v
+gdbtk_test cpp_variable-1.4b {public children of v} {
+  get_children v.public
+} {v_pub_int v_pub_charp}
+
+# Test: cpp_variable-1.4c
+# Desc: private children of v
+gdbtk_test cpp_variable-1.4c {private children of v} {
+  get_children v.private
+} {v_priv_int v_priv_charp}
+
+# Test: cpp_variable-1.5
+# Desc: type of v
+gdbtk_test cpp_variable-1.5 {type of v} {
+  $var(v) type
+} {V *}
+
+# Test: cpp_variable-1.6
+# Desc: format of v
+gdbtk_test cpp_variable-1.6 {format of v} {
+  $var(v) format
+} {natural}
+
+set value {}
+catch {$var(v) value} value
+
+# Test: cpp_variable-1.6a
+# Desc: Step over "V *v = new V;"
+gdbtk_test cpp_variable-1.6a {step over "V *v = new V;"} {
+  catch {gdb_cmd "next"}
+} {0}
+
+# Test: cpp_variable-1.7
+# Desc: check value of v changed
+gdbtk_test cpp_variable-1.7 {check value of v changed} {
+  set changes [check_update]
+  # It is undefined whether the children will change values
+  # or not, so ignore them.
+  expr {[lsearch [lindex [lindex $changes 0] 0] v] != -1}
+} {1}
+
+# Test: cpp_variable-1.8
+# Desc: check values of v
+gdbtk_test cpp_variable-1.8 {check values of v} {
+  set new [$var(v) value]
+  expr {$new != $value}
+} {1}
+
+# Test: cpp_variable-1.9
+# Desc: v editable
+gdbtk_test cpp_variable-1.9 {v editable} {
+  $var(v) editable
+} {1}
+
+#####             #####
+#                     #
+# Children of v tests #
+#                     #
+#####             #####
+
+# Test: cpp_variable-2.1
+# Desc: type of v.v_pub_int
+gdbtk_test cpp_variable-2.1 {type of v.v_pub_int} {
+  $var(v.public.v_pub_int) type
+} {int}
+
+# Test: cpp_variable-2.2
+# Desc: format of v.v_pub_int
+gdbtk_test cpp_variable-2.2 {format of v.v_pub_int} {
+  $var(v.public.v_pub_int) format
+} {natural}
+
+# Test: cpp_variable-2.2a
+# Desc: set variable v->v_pub_int=2112 
+gdbtk_test cpp_variable-2.2a {set variable v.v_pub_int=2112} {
+  set err [catch {gdb_cmd "set variable v.v_pub_int=2112"} txt]
+  if {$err} {
+    set txt
+  } else {
+    set err
+  }
+} {0}
+
+# Test: cpp_variable-2.3
+# Desc: value of v.v_pub_int changed
+gdbtk_test cpp_variable-2.3 {value of v.v_pub_int changed} {
+  check_update
+} {v.public.v_pub_int {v.private.v_priv_charp v.VB v.private.v_priv_int v.VC v.public.v_pub_charp v.public.v_pub_int v.private v.public v.VA}}
+
+# Test: cpp_variable-2.4
+# Desc: value of v.v_pub_int
+gdbtk_test cpp_variable-2.4 {value of v.v_pub_int} {
+  $var(v.public.v_pub_int) value
+} {2112}
+
+# Test: cpp_variable-2.5
+# Desc: changed format of v.v_pub_int
+gdbtk_test cpp_variable-2.5 {changed format of v.v_pub_int} {
+  $var(v.public.v_pub_int) format octal
+  $var(v.public.v_pub_int) format
+} {octal}
+
+# Test: cpp_variable-2.6
+# Desc: value of v.v_pub_int with new format
+gdbtk_test cpp_variable-2.6 {value of v.v_pub_int with new format} {
+  $var(v.public.v_pub_int) value
+} {04100}
+
+# Test: cpp_variable-2.7
+# Desc: change value of v.v_pub_int (decimal)
+gdbtk_test cpp_variable-2.7 {change value of v.v_pub_int (decimal)} {
+  $var(v.public.v_pub_int) value 3
+  cppvalue v.public.v_pub_int v.v_pub_int o
+} {ok}
+
+# Test: cpp_variable-2.8
+# Desc: change value of v.v_pub_int (hexadecimal)
+gdbtk_test cpp_variable-2.8 {change value of v.v_pub_int (hexadecimal)} {
+  $var(v.public.v_pub_int) value 0x21
+  cppvalue v.public.v_pub_int v.v_pub_int o
+} {ok}
+
+# Test: cpp_variable-2.9
+# Desc: number of children of v_pub_int
+gdbtk_test cpp_variable-2.9 {number of children of v_pub_int} {
+  $var(v.public.v_pub_int) numChildren
+} {0}
+
+# Test: cpp_variable-2.10
+# Desc: children of v.v_pub_int
+gdbtk_test cpp_variable-2.10 {children of v.v_pub_int} {
+  get_children v.public.v_pub_int
+} {}
+
+# Test: cpp_variable-2.11
+# Desc: v.v_pub_int editable
+gdbtk_test cpp_variable-2.11 {v.v_pub_int editable} {
+  $var(v.public.v_pub_int) editable
+} {1}
+
+# Test: cpp_variable-2.21
+# Desc: type of v.v_priv_charp
+gdbtk_test cpp_variable-2.21 {type of v.v_priv_charp} {
+  $var(v.private.v_priv_charp) type
+} {char *}
+
+# Test: cpp_variable-2.22
+# Desc: format of v.v_priv_charp
+gdbtk_test cpp_variable-2.22 {format of v.v_priv_charp} {
+  $var(v.private.v_priv_charp) format
+} {natural}
+
+# Test: cpp_variable-2.22a
+# Desc: set variable v->v_priv_charp=2112
+gdbtk_test cpp_variable-2.22a {set variable v->v_priv_charp=2112} {
+  set err [catch {gdb_cmd "set variable v->v_priv_charp=2112"} txt]
+  if {$err} {
+    set txt
+  } else {
+    set err
+  }
+} {0}
+
+# Test: cpp_variable-2.23
+# Desc: value of v.v_priv_charp changed
+gdbtk_test cpp_variable-2.23 {value of v.v_priv_charp changed} {
+  check_update
+} {{{v.public.v_pub_int v.private.v_priv_charp}} {v.private.v_priv_charp v.VB v.private.v_priv_int v.VC v.public.v_pub_charp v.public.v_pub_int v.private v.public v.VA}}
+
+# Test: cpp_variable-2.24
+# Desc: value of v.v_priv_charp
+gdbtk_test cpp_variable-2.24 {value of v.v_priv_charp} {
+  $var(v.private.v_priv_charp) format hexadecimal
+  $var(v.private.v_priv_charp) value
+} {0x840}
+
+# Test: cpp_variable-2.25
+# Desc: changed format of v.v_priv_charp
+gdbtk_test cpp_variable-2.25 {changed format of v.v_priv_charp} {
+  $var(v.private.v_priv_charp) format octal
+  $var(v.private.v_priv_charp) format
+} {octal}
+
+# Test: cpp_variable-2.26
+# Desc: value of v.v_priv_charp with new format
+gdbtk_test cpp_variable-2.26 {value of v.v_priv_charp with new format} {
+  $var(v.private.v_priv_charp) value
+} {04100}
+
+# Test: cpp_variable-2.27
+# Desc: change value of v.v_priv_charp (decimal)
+gdbtk_test cpp_variable-2.27 {change value of v.v_priv_charp (decimal)} {
+  $var(v.private.v_priv_charp) value 3
+  cppvalue v.private.v_priv_charp v.v_priv_charp o
+} {ok}
+
+# Test: cpp_variable-2.28
+# Desc: change value of v.v_priv_charp (hexadecimal)
+gdbtk_test cpp_variable-2.28 {change value of v.v_priv_charp (hexadecimal)} {
+  $var(v.private.v_priv_charp) value 0x21
+  cppvalue v.private.v_priv_charp v.v_priv_charp o
+} {ok}
+
+# Test: cpp_variable-2.29
+# Desc: number of children of v_priv_charp
+gdbtk_test cpp_variable-2.29 {number of children of v_priv_charp} {
+  $var(v.private.v_priv_charp) numChildren
+} {1}
+
+# Test: cpp_variable-2.30
+# Desc: children of v.v_priv_charp
+gdbtk_test cpp_variable-2.30 {children of v.v_priv_charp} {
+  get_children v.private.v_priv_charp
+} {*v_priv_charp}
+
+# Test: cpp_variable-2.31
+# Desc: v.v_priv_int editable
+gdbtk_test cpp_variable-2.31 {v.v_priv_int editable} {
+  $var(v.private.v_priv_int) editable
+} {1}
+
+# Test: cpp_variable-2.41
+# Desc: type of v.VA
+gdbtk_test cpp_variable-2.41 {type of v.VA} {
+  $var(v.VA) type
+} {VA}
+
+# Test: cpp_variable-2.42
+# Desc: format of v.VA
+gdbtk_test cpp_variable-2.42 {format of v.VA} {
+  $var(v.VA) format
+} {natural}
+
+# Test: cpp_variable-2.43
+# Desc: value of v.VA changed
+gdbtk_test cpp_variable-2.43 {value of v.VA changed} {
+  check_update
+} {v.private.v_priv_charp {v.private.v_priv_charp v.VB v.private.v_priv_int v.VC v.public.v_pub_charp v.private.v_priv_charp.*v_priv_charp v.public.v_pub_int v.private v.public v.VA}}
+
+# Test: cpp_variable-2.44
+# Desc: value of v.VA
+gdbtk_test cpp_variable-2.44 {value of v.VA} {
+  $var(v.VA) value
+} {{...}}
+
+# Test: cpp_variable-2.45
+# Desc: changed format of v.VA
+gdbtk_test cpp_variable-2.45 {changed format of v.VA} {
+  $var(v.VA) format octal
+  $var(v.VA) format
+} {octal}
+
+# Test: cpp_variable-2.46
+# Desc: value of v.VA with new format
+gdbtk_test cpp_variable-2.46 {value of v.VA with new format} {
+  $var(v.VA) value
+} {{...}}
+
+# Test: cpp_variable-2.47
+# Desc: number of children of VA
+gdbtk_test cpp_variable-2.47 {number of children of VA} {
+  $var(v.VA) numChildren
+} {3}
+
+# Test: cpp_variable-2.48a
+# Desc: children of v.VA
+gdbtk_test cpp_variable-2.48a {children of v.VA} {
+  get_children v.VA
+} {public private protected}
+
+# Test: cpp_variable-2.48b
+# Desc: public children of v.VA
+gdbtk_test cpp_variable-2.48b {children of v.VA} {
+  get_children v.VA.public
+} {va_pub_int va_pub_charp}
+
+# Test: cpp_variable-2.48c
+# Desc: private children of v.VA
+gdbtk_test cpp_variable-2.48c {children of v.VA} {
+  get_children v.VA.private
+} {va_priv_int va_priv_charp}
+
+# Test: cpp_variable-2.48d
+# Desc: protected children of v.VA
+gdbtk_test cpp_variable-2.48d {children of v.VA} {
+  get_children v.VA.protected
+} {bar}
+
+# Test: cpp_variable-2.49
+# Desc: v.VA editable
+gdbtk_test cpp_variable-2.49 {v.VA editable} {
+  $var(v.VA) editable
+} {0}
+
+# Test: cpp_variable-2.61
+# Desc: type of v.VB
+gdbtk_test cpp_variable-2.61 {type of v.VB} {
+  $var(v.VB) type
+} {VB}
+
+# Test: cpp_variable-2.62
+# Desc: format of v.VB
+gdbtk_test cpp_variable-2.62 {format of v.VB} {
+  $var(v.VB) format
+} {natural}
+
+# Test: cpp_variable-2.63
+# Desc: value of v.VB changed
+gdbtk_test cpp_variable-2.63 {value of v.VB changed} {
+  check_update
+} {{} {v.VA.protected v.private.v_priv_charp.*v_priv_charp v.VA.private v.VA.public.va_pub_int v.private.v_priv_int v.public.v_pub_int v.VA.public.va_pub_charp v.private.v_priv_charp v.VA.public v.public.v_pub_charp v.VA.private.va_priv_int v.VA v.public v.VB v.VC v.VA.protected.bar v.VA.private.va_priv_charp v.private}}
+
+# Test: cpp_variable-2.64
+ # Desc: value of v.VB
+gdbtk_test cpp_variable-2.64 {value of v.VB} {
+  $var(v.VB) value
+} {{...}}
+
+# Test: cpp_variable-2.65
+# Desc: changed format of v.VB
+gdbtk_test cpp_variable-2.65 {changed format of v.VB} {
+  $var(v.VB) format octal
+  $var(v.VB) format
+} {octal}
+
+# Test: cpp_variable-2.66
+# Desc: value of v.VB with new format
+gdbtk_test cpp_variable-2.66 {value of v.VB with new format} {
+  $var(v.VB) value
+} {{...}}
+
+# Note: The next two tests show whether or not the logic
+# concerning vptr tables is working.
+# Test: cpp_variable-2.67
+# Desc: number of children of VB
+gdbtk_test cpp_variable-2.67 {number of children of VB} {
+  $var(v.VB) numChildren
+} {2}
+
+# Test: cpp_variable-2.68a
+# Desc: children of v.VB
+gdbtk_test cpp_variable-2.68a {children of v.VB} {
+  get_children v.VB
+} {public private}
+
+# Test: cpp_variable-2.68b
+# Desc: public children of v.VB
+gdbtk_test cpp_variable-2.68b {children of v.VB} {
+  get_children v.VB.public
+} {vb_pub_int}
+
+# Test: cpp_variable-2.68c
+# Desc: private children of v.VB
+gdbtk_test cpp_variable-2.68c {children of v.VB} {
+  get_children v.VB.private
+} {vb_priv_int vb_priv_charp}
+
+# Test: cpp_variable-2.69
+# Desc: v.VB editable
+gdbtk_test cpp_variable-2.69 {v.VB editable} {
+  $var(v.VB) editable
+} {0}
+
+# Test: cpp_variable-2.70
+# Desc: v.VB.public editable
+gdbtk_test cpp_variable-2.70 {v.VB.public editable} {
+  $var(v.VB.public) editable
+} {0}
+
+# Test: cpp_variable-2.71
+# Desc: v.VB.vb_pub_int editable
+gdbtk_test cpp_variable-2.71 {v.VB.vb_pub_int editable} {
+  $var(v.VB.public.vb_pub_int) editable
+} {1}
+
+# Test: cpp_variable-2.71a
+# Desc: set variable v->vb_pub_int=2112
+gdbtk_test cpp_variable-2.71a {set variable v->v_pub_int=2112} {
+  set err [catch {gdb_cmd "set variable v->vb_pub_int=2112"} txt]
+  if {$err} {
+    set txt
+  } else {
+    set err
+  }
+} {0}
+
+# Test: cpp_variable-2.72
+# Desc: value of v.vb_pub_int changed
+gdbtk_test cpp_variable-2.72 {value of v.vb_pub_int changed} {
+  check_update
+} {v.VB.public.vb_pub_int {v.VB.public v.VA.protected v.private.v_priv_charp.*v_priv_charp v.VA.private v.VB.private.vb_priv_int v.VB.private v.VA.public.va_pub_int v.private.v_priv_int v.VB.public.vb_pub_int v.public.v_pub_int v.VB.private.vb_priv_charp v.VA.public.va_pub_charp v.private.v_priv_charp v.VA.public v.public.v_pub_charp v.VA.private.va_priv_int v.VA v.public v.VB v.VC v.VA.protected.bar v.VA.private.va_priv_charp v.private}}
+
+# Test: cpp_variable-2.73
+# Desc: value of v.VB.vb_pub_int
+gdbtk_test cpp_variable-2.73 {changed value of v.vb_pub_int} {
+  $var(v.VB.public.vb_pub_int) value
+} {2112}
+
+# Test: cpp_variable-2.74
+# Desc: change value of v.VB.vb_pub_int
+gdbtk_test cpp_variable-2.74 {change value of v.VB.public.vb_pub_int} {
+  $var(v.VB.public.vb_pub_int) value 3
+  cppvalue v.VB.public.vb_pub_int v.vb_pub_int d
+} {ok}
+
+# Test: cpp_variable-2.75
+# Desc: value of v.VB.vb_pub_int
+gdbtk_test cpp_variable-2.75 {changed value of v.VB.public.vb_pub_int} {
+  $var(v.VB.public.vb_pub_int) value
+} {3}
+
+
+#  Exit
+#
+gdbtk_test_done
+
+#Local Variables:
+#mode: tcl
+
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.c stsgdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.c
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.c	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,298 @@
+#include <stdlib.h>
+
+struct _simple_struct {
+  int integer;
+  unsigned int unsigned_integer;
+  char character;
+  signed char signed_character;
+  char *char_ptr;
+  int array_of_10[10];
+};
+
+typedef struct _simple_struct simpleton;
+
+simpleton global_simple;
+
+enum foo {
+  bar = 1,
+  baz
+};
+
+typedef enum foo efoo;
+
+union named_union
+{
+  int integer;
+  char *char_ptr;
+};
+
+typedef struct _struct_decl {
+  int   integer;
+  char  character;
+  char *char_ptr;
+  long  long_int;
+  int  **int_ptr_ptr;
+  long  long_array[10];
+
+  void (*func_ptr) (void);
+  struct _struct_decl (*func_ptr_struct) (int, char *, long);
+  struct _struct_decl *(*func_ptr_ptr) (int, char *, long);
+  union {
+    int   a;
+    char *b;
+    long  c;
+    enum foo d;
+  } u1;
+
+  struct {
+    union {
+      struct {
+        int d;
+        char e[10];
+        int *(*func) (void);
+        efoo foo;
+      } u1s1;
+
+      long f;
+      struct {
+        char array_ptr[2];
+        int (*func) (int, char *);
+      } u1s2;
+    } u2;
+
+    int g;
+    char h;
+    long i[10];
+  } s2;
+} weird_struct;
+
+struct _struct_n_pointer {
+  char ****char_ptr;
+  long ****long_ptr;
+  struct _struct_n_pointer *ptrs[3];
+  struct _struct_n_pointer *next;
+};
+
+void do_locals_tests (void);
+void do_block_tests (void);
+void subroutine1 (int, long *);
+void nothing (void);
+void do_children_tests (void);
+void do_special_tests (void);
+void incr_a (int);
+
+void incr_a (int a)
+{
+  int b;
+  b = a;
+}
+
+void
+do_locals_tests ()
+{
+  int linteger;
+  int *lpinteger;
+  char lcharacter;
+  char *lpcharacter;
+  long llong;
+  long *lplong;
+  float lfloat;
+  float *lpfloat;
+  double ldouble;
+  double *lpdouble;
+  struct _simple_struct lsimple;
+  struct _simple_struct *lpsimple;
+  void (*func) (void);
+
+  /* Simple assignments */
+  linteger = 1234;
+  lpinteger = &linteger;
+  lcharacter = 'a';
+  lpcharacter = &lcharacter;
+  llong = 2121L;
+  lplong = &llong;
+  lfloat = 2.1;
+  lpfloat = &lfloat;
+  ldouble = 2.718281828459045;
+  lpdouble = &ldouble;
+  lsimple.integer = 1234;
+  lsimple.unsigned_integer = 255;
+  lsimple.character = 'a';
+  lsimple.signed_character = 21;
+  lsimple.char_ptr = &lcharacter;
+  lpsimple = &lsimple;
+  func = nothing;
+
+  /* Check pointers */
+  linteger = 4321;
+  lcharacter = 'b';
+  llong = 1212L;
+  lfloat = 1.2;
+  ldouble = 5.498548281828172;
+  lsimple.integer = 255;
+  lsimple.unsigned_integer = 4321;
+  lsimple.character = 'b';
+  lsimple.signed_character = 0;
+
+  subroutine1 (linteger, &llong);
+}
+
+void
+nothing ()
+{
+}
+
+void
+subroutine1 (int i, long *l)
+{
+  global_simple.integer = i + 3;
+  i = 212;
+  *l = 12;
+}
+
+void
+do_block_tests ()
+{
+  int cb = 12;
+
+  {
+    int foo;
+    foo = 123;
+    {
+      int foo2;
+      foo2 = 123;
+      {
+        int foo;
+        foo = 321;
+      }
+      foo2 = 0;
+    }
+    foo = 0;
+  }
+
+  cb = 21;
+}
+
+void
+do_children_tests (void)
+{
+  weird_struct *weird;
+  struct _struct_n_pointer *psnp;
+  struct _struct_n_pointer snp0, snp1, snp2;
+  char a0, *a1, **a2, ***a3;
+  char b0, *b1, **b2, ***b3;
+  char c0, *c1, **c2, ***c3;
+  long z0, *z1, **z2, ***z3;
+  long y0, *y1, **y2, ***y3;
+  long x0, *x1, **x2, ***x3;
+  int *foo;
+  int bar;
+
+  struct _struct_decl struct_declarations;
+  weird = &struct_declarations;
+
+  struct_declarations.integer = 123;
+  weird->char_ptr = "hello";
+  bar = 2121;
+  foo = &bar;
+  struct_declarations.int_ptr_ptr = &foo;
+  weird->long_array[0] = 1234;
+  struct_declarations.long_array[1] = 2345;
+  weird->long_array[2] = 3456;
+  struct_declarations.long_array[3] = 4567;
+  weird->long_array[4] = 5678;
+  struct_declarations.long_array[5] = 6789;
+  weird->long_array[6] = 7890;
+  struct_declarations.long_array[7] = 8901;
+  weird->long_array[8] = 9012;
+  struct_declarations.long_array[9] = 1234;
+
+  weird->func_ptr = nothing;
+
+  /* Struct/pointer/array tests */
+  a0 = '0';
+  a1 = &a0;
+  a2 = &a1;
+  a3 = &a2;
+  b0 = '1';
+  b1 = &b0;
+  b2 = &b1;
+  b3 = &b2;
+  c0 = '2';
+  c1 = &c0;
+  c2 = &c1;
+  c3 = &c2;
+  z0 = 0xdead + 0;
+  z1 = &z0;
+  z2 = &z1;
+  z3 = &z2;
+  y0 = 0xdead + 1;
+  y1 = &y0;
+  y2 = &y1;
+  y3 = &y2;
+  x0 = 0xdead + 2;
+  x1 = &x0;
+  x2 = &x1;
+  x3 = &x2;
+  snp0.char_ptr = &a3;
+  snp0.long_ptr = &z3;
+  snp0.ptrs[0] = &snp0;
+  snp0.ptrs[1] = &snp1;
+  snp0.ptrs[2] = &snp2;
+  snp0.next = &snp1;
+  snp1.char_ptr = &b3;
+  snp1.long_ptr = &y3;
+  snp1.ptrs[0] = &snp0;
+  snp1.ptrs[1] = &snp1;
+  snp1.ptrs[2] = &snp2;
+  snp1.next = &snp2;
+  snp2.char_ptr = &c3;
+  snp2.long_ptr = &x3;
+  snp2.ptrs[0] = &snp0;
+  snp2.ptrs[1] = &snp1;
+  snp2.ptrs[2] = &snp2;
+  snp2.next = 0x0;
+  psnp = &snp0;
+  snp0.char_ptr = &b3;
+  snp1.char_ptr = &c3;
+  snp2.char_ptr = &a3;
+  snp0.long_ptr = &y3;
+  snp1.long_ptr = &x3;
+  snp2.long_ptr = &z3;
+}
+
+void
+do_special_tests (void)
+{
+  union named_union u;
+  union {
+    int a;
+    char b;
+    long c;
+  } anonu;
+  struct _simple_struct s;
+  struct {
+    int a;
+    char b;
+    long c;
+  } anons;
+  enum foo e;
+  enum { A, B, C } anone;
+  int array[21];
+  int a;
+
+  a = 1;   
+  incr_a(2);
+}
+
+int
+main (int argc, char *argv [])
+{
+  do_locals_tests ();
+  do_block_tests ();
+  do_children_tests ();
+  do_special_tests ();
+  exit (0);
+}
+
+  
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,42 @@
+# Copyright 1999, 2001, 2004 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+load_lib ../gdb.gdbtk/insight-support.exp
+
+if {[gdbtk_initialize_display]} {
+  if {$tracelevel} {
+    strace $tracelevel
+  }
+
+  #
+  # test variable API
+  #
+  set prms_id 0
+  set bug_id 0
+
+  set testfile "c_variable"
+  set srcfile ${testfile}.c
+  set binfile ${objdir}/${subdir}/${testfile}
+  set r [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}]
+  if  { $r != "" } {
+    gdb_suppress_entire_file \
+      "Testcase compile failed, so some tests in this file will automatically fail."
+  }
+
+  # Start with a fresh gdbtk
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir ${testfile}.test]]
+  set results [split $results \n]
+
+  # Analyze results
+  gdbtk_done $results
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/c_variable.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,2071 @@
+# Varobj Tests (C language)
+# Copyright 1998, 2001, 2003 Red Hat, Inc.
+#
+# This Program Is Free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# insight@sources.redhat.com
+
+# This file was written by Keith Seitz (keiths@cygnus.com)
+
+# Read in the standard defs file
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir test_ran
+
+# Load in a file
+set program [file join $objdir c_variable]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+# The variables that are created are stored in an array called "var".
+
+# proc to tell us which of the variables are changed/out of scope
+proc check_update {} {
+  global var
+
+  set out {}
+  set changed {}
+  foreach ind [array names var] {
+    set ret [$var($ind) update]
+    if {$ret == -1} {
+	lappend out $ind
+    } elseif {$ret != ""} {
+        lappend changed $ret
+    }
+  }
+  return [list $changed $out]
+}
+
+# proc to create a variable
+proc create_variable {expr} {
+  global var
+
+  set err [catch {gdb_variable create "$expr" -expr $expr} v]
+  if {!$err} {
+    set var($expr) $v
+  }
+
+  return $err
+}
+
+# proc to get the children
+# Children are stored in the global "var" as
+# PARENT.child. So for struct _foo {int a; int b} bar;,
+# the children returned are {a b} and var(bar.a) and var(bar.b)
+# map the actual objects to their names.
+proc get_children {parent} {
+  global var
+
+  set kiddies [$var($parent) children]
+  set children {}
+  foreach child $kiddies {
+    set name [lindex [split $child .] end]
+    lappend children $name
+    set var($parent.$name) $child
+  }
+
+  return $children
+}
+
+proc delete_variable {varname} {
+  global var
+
+  if {[info exists var($varname)]} {
+    # This has to be caught, since deleting a parent
+    # will erase all children.
+    $var($varname) delete
+    set vars [array names var $varname*]
+    foreach v $vars {
+      if {[info exists var($v)]} {
+	unset var($v)
+      }
+    }
+  }
+}
+
+# Compare the values of variable V in format FMT
+# with gdb's value.
+proc value {v fmt} {
+  global var
+  global _test
+
+  set value [$var($v) value]
+  set gdb [gdb_cmd "output/$fmt $v"]
+  if {$value == $gdb} {
+    set result ok
+  } else {
+    set result $v
+    puts $_test(logfile) "output/$fmt $v"
+    puts $_test(logfile) "gdbtk: $value <> gdb: $gdb"
+  }
+
+  return $result
+}
+
+proc delete_all_variables {} {
+  global var
+
+  foreach variable [array names var] {
+    delete_variable $variable
+  }
+}
+
+proc editable_variables {} {
+  global var
+
+  set yes {}
+  set no {}
+  foreach name [array names var] {
+    if {[$var($name) editable]} {
+      lappend yes $name
+    } else {
+      lappend no $name
+    }
+  }
+
+  return [list $yes $no]
+}
+
+
+#####                   #####
+#                           #
+#  Variable Creation tests  #
+#                           #
+#####                   #####
+
+# Test:  c_variable-1.1
+# Desc:  Create global variable
+gdbtk_test c_variable-1.1 {create global variable} {
+  create_variable global_simple
+} {0}
+
+# Test: c_variable-1.2
+# Desc: Create non-existent variable
+gdbtk_test c_variable-1.2 {create non-existent variable} {
+  create_variable bogus_unknown_variable
+} {1}
+
+# Test: c_variable-1.3
+# Desc: Create out of scope variable
+gdbtk_test c_variable-1.3 {create out of scope variable} {
+  create_variable argc
+} {1}
+
+# Break in main and run
+gdb_cmd "break do_locals_tests"
+gdbtk_test_run
+
+# Test: c_variable-1.4
+# Desc: create local variables
+gdbtk_test c_variable-1.4 {create local variables} {
+  set results {}
+  foreach v {linteger lpinteger lcharacter lpcharacter llong lplong lfloat lpfloat ldouble lpdouble lsimple lpsimple func} {
+    lappend results [create_variable $v]
+  }
+  set results
+} {0 0 0 0 0 0 0 0 0 0 0 0 0}
+
+# Test: c_variable-1.5
+# Desc: create lsimple.character
+gdbtk_test c_variable-1.5 {create lsimple.character} {
+  create_variable lsimple.character
+} {0}
+
+# Test: c_variable-1.6
+# Desc: create lpsimple->integer
+gdbtk_test c_variable-1.6 {create lpsimple->integer} {
+  create_variable lpsimple->integer
+} {0}
+
+# Test: c_variable-1.7
+# Desc: create lsimple.integer
+gdbtk_test c_variable-1.7 {create lsimple.integer} {
+  create_variable lsimple.integer
+} {0}
+
+# Test: c_variable-1.8
+# Desc: names of editable variables
+gdbtk_test c_variable-1.8 {names of editable variables} {
+  editable_variables
+} {{lsimple.character lsimple.integer lpsimple lcharacter lpcharacter linteger lpinteger lfloat lpfloat func llong lplong lpsimple->integer ldouble lpdouble} {lsimple global_simple}}
+
+# Test: c_variable-1.9
+# Desc: create type name
+#    Type names (like int, long, etc..) are all proper expressions to gdb.
+#    make sure variable code does not allow users to create variables, though.
+gdbtk_test c_variable-1.9 {create type name} {
+  create_variable int
+} {1}
+
+#####             #####
+#                     #
+# Value changed tests #
+#                     #
+#####             #####
+
+# Test: c_variable-2.1
+# Desc: check whether values changed at do_block_tests
+gdbtk_test c_variable-2.1 {check whether values changed at do_block_tests} {
+  check_update
+} {{} {}}
+
+# Step over "linteger = 1234;"
+gdb_cmd "step"
+
+# Test: c_variable-2.2
+# Desc: check whether only linteger changed values
+gdbtk_test c_variable-2.2 {check whether only linteger changed values} {
+  check_update
+} {linteger {}}
+
+# Step over "lpinteger = &linteger;"
+gdb_cmd "step"
+
+# Test: c_variable-2.3
+# Desc: check whether only lpinteger changed
+gdbtk_test c_variable-2.3 {check whether only lpinteger changed} {
+  check_update
+} {lpinteger {}}
+
+# Step over "lcharacter = 'a';"
+gdb_cmd "step"
+
+# Test: c_variable-2.4
+# Desc: check whether only lcharacter changed
+gdbtk_test c_variable-2.4 {check whether only lcharacter changed} {
+  check_update
+} {lcharacter {}}
+
+# Step over "lpcharacter = &lcharacter;"
+gdb_cmd "step"
+
+# Test: c_variable-2.5
+# Desc: check whether only lpcharacter changed
+gdbtk_test c_variable-2.5 {check whether only lpcharacter changed} {
+  check_update
+} {lpcharacter {}}
+
+# Step over:
+#  llong = 2121L;
+#  lplong = &llong;
+#  lfloat = 2.1;
+#  lpfloat = &lfloat;
+#  ldouble = 2.718281828459045;
+#  lpdouble = &ldouble;
+#  lsimple.integer = 1234;
+#  lsimple.unsigned_integer = 255;
+#  lsimple.character = 'a';
+for {set i 0} {$i < 9} {incr i} {
+  gdb_cmd "step"
+}
+
+# Test: c_variable-2.6
+# Desc: check whether llong, lplong, lfloat, lpfloat, ldouble, lpdouble, lsimple.integer,
+#       lsimple.unsigned_character lsimple.integer lsimple.character changed
+gdbtk_test c_variable-2.6 {check whether llong -- lsimple.character changed} {
+  check_update
+} {{lsimple.character lsimple.integer lfloat lpfloat llong lplong ldouble lpdouble} {}}
+
+# Step over:
+#  lsimple.signed_character = 21;
+#  lsimple.char_ptr = &lcharacter;
+#  lpsimple = &lsimple;
+#  func = nothing;
+for {set i 0} {$i < 4} {incr i} {
+  gdb_cmd "step"
+}
+
+# Test: c_variable-2.7
+# Desc: check whether lsimple.signed_character, lsimple.char_ptr, lpsimple, func changed
+gdbtk_test c_variable-2.7 {check whether lsimple.signed_character, lsimple.char_ptr, lpsimple, func changed} {
+  check_update
+} {{lpsimple func lpsimple->integer} {}}
+
+# Step over
+#  linteger = 4321;
+#  lcharacter = 'b';
+#  llong = 1212L;
+#  lfloat = 1.2;
+#  ldouble = 5.498548281828172;
+#  lsimple.integer = 255;
+#  lsimple.unsigned_integer = 4321;
+#  lsimple.character = 'b';
+for {set i 0} {$i < 8} {incr i} {
+  gdb_cmd "step"
+}
+
+# Test: c_variable-2.8
+# Desc: check whether linteger, lcharacter, llong, lfoat, ldouble, lsimple.integer,
+#       lpsimple.integer lsimple.character changed
+# Note: this test also checks that lpsimple->integer and lsimple.integer have
+#       changed (they are the same)
+gdbtk_test c_variable-2.8 {check whether linteger -- lsimple.integer changed} {
+  check_update
+} {{lsimple.character lsimple.integer lcharacter linteger lfloat llong lpsimple->integer ldouble} {}}
+
+gdb_cmd "break subroutine1"
+gdb_cmd "continue"
+
+# Test: c_variable-2.9
+# Desc: stop in subroutine1
+gdbtk_test c_variable-2.9 {stop in subroutine1} {
+  lindex [gdb_loc] 1
+} {subroutine1}
+
+# Test: c_variable-2.10
+# Desc: create variable for locals i,l in subroutine1
+gdbtk_test c_variable-2.10 {create variable for locals i,l in subroutine1} {
+  set r [create_variable i]
+  lappend r [create_variable l]  
+} {0 0}
+
+# Test: c_variable-2.11
+# Desc: create do_locals_tests local in subroutine1
+gdbtk_test c_variable-2.11 {create do_locals_tests local in subroutine1} {
+  create_variable linteger
+} {1}
+
+# Step over
+#  global_simple.integer = i + 3;
+gdb_cmd "step"
+
+# Test: c_variable-2.12
+# Desc: change global_simple.integer
+# Note: This also tests whether we are reporting changes in structs properly.
+#       gdb normally would say that global_simple has changed, but we
+#       special case that, since it is not what a human expects to see.
+gdbtk_test c_variable-2.12 {change global_simple.integer} {
+  check_update
+} {{} {lsimple.character lsimple.integer lpsimple lsimple lcharacter lpcharacter linteger lpinteger lfloat lpfloat func llong lplong lpsimple->integer ldouble lpdouble}}
+
+# Step over
+#  i = 212;
+gdb_cmd "step"
+
+# Test: c_variable-2.13
+# Desc: change subroutine1 local i
+gdbtk_test c_variable-2.13 {change subroutine1 local i} {
+  check_update
+} {i {lsimple.character lsimple.integer lpsimple lsimple lcharacter lpcharacter linteger lpinteger lfloat lpfloat func llong lplong lpsimple->integer ldouble lpdouble}}
+
+# Step over
+#  *l = 12
+gdb_cmd "step"
+
+# This test is no longer valid, since varobj now forces
+# re-evaluation in the current frame by default.
+# Test: c_variable-2.14
+# Desc: change do_locals_tests local llong
+#gdbtk_test c_variable-2.14 {change do_locals_tests local llong} {
+#  check_update
+#} {llong {}}
+
+# Leave subroutine1
+gdb_cmd "next"
+
+# Test: c_variable-2.15
+# Desc: check for out of scope subroutine1 locals
+gdbtk_test c_variable-2.15 {check for out of scope subroutine1 locals} {
+  lindex [check_update] 1
+} {i l}
+
+# Test: c_variable-2.16
+# Desc: names of all editable variables
+gdbtk_test c_variable-2.16 {names of all editable variables} {
+  editable_variables
+} {{lsimple.character lsimple.integer lpsimple i lcharacter lpcharacter linteger lpinteger lfloat lpfloat l func llong lplong lpsimple->integer ldouble lpdouble} {lsimple global_simple}}
+
+# Done with locals/globals tests. Erase all variables
+delete_all_variables
+
+#####     #####
+#             #
+# Block tests #
+#             #
+#####     #####
+gdb_cmd "break do_block_tests"
+gdb_cmd "continue"
+
+# Test: c_variable-3.1
+# Desc: stop in do_block_tests
+gdbtk_test c_variable-3.1 {stop in do_block_tests} {
+  lindex [gdb_loc] 1
+} {do_block_tests}
+
+# Test: c_variable-3.2
+# Desc: create cb and foo
+gdbtk_test c_variable-3.2 {create cb and foo} {
+  set r [create_variable cb]
+  lappend r [create_variable foo]
+} {0 1}
+
+# step to "foo = 123;"
+gdb_cmd "step"
+
+# Be paranoid and assume 3.2 created foo
+delete_variable foo
+
+# Test: c_variable-3.3
+# Desc: create foo
+gdbtk_test c_variable-3.3 {create foo} {
+  create_variable foo
+} {0}
+
+# step to "foo2 = 123;"
+gdb_cmd "step"
+
+# Test: c_variable-3.4
+# Desc: check foo, cb changed
+gdbtk_test c_variable-3.4 {check foo,cb changed} {
+  check_update
+} {{foo cb} {}}
+
+# step to "foo = 321;"
+gdb_cmd "step"
+
+# Test: c_variable-3.5
+# Desc: create inner block foo
+gdbtk_test c_variable-3.5 {create inner block foo} {
+  global var
+  set err [catch {gdb_variable create inner_foo -expr foo} v]
+  if {!$err} {
+    set var(inner_foo) $v
+  }
+  
+  set err
+} {0}
+
+# step to "foo2 = 0;"
+gdb_cmd "step"
+
+# Test: c_variable-3.6
+# Desc: create foo2
+gdbtk_test c_variable-3.6 {create foo2} { 
+  create_variable foo2
+} {0}
+
+# Test: c_variable-3.7
+# Desc: check that outer foo in scope and inner foo out of scope
+
+# Disabled for now because varobjs don't work this way.  If you create a varobj named "foo"
+# it will display the correct value for any variable named "foo" in scope. So inner_foo 
+# is not out of scope because there is another variable named "foo" in scope. It is
+# instead marked as changed.
+
+#gdbtk_test *c_variable-3.7 {check that outer foo in scope and inner foo out of scope} {
+#  check_update
+#} {{} inner_foo}
+
+delete_variable inner_foo
+
+# step to "foo = 0;"
+gdb_cmd "step"
+
+# Test: c_variable-3.8
+# Desc: check that foo2 out of scope
+gdbtk_test c_variable-3.8 {check that foo2 out of scope} {
+  check_update
+} {{} foo2}
+
+# step to "cb = 21;"
+gdb_cmd "step"
+
+# Test: c_variable-3.9
+# Desc: check that only cb is in scope
+gdbtk_test c_variable-3.9 {check that only cb is in scope} {
+  check_update
+} {{} {foo foo2}}
+
+# Test: c_variable-3.10
+# Desc: names of editable variables
+gdbtk_test c_variable-3.10 {names of editable variables} {
+  editable_variables
+} {{foo cb foo2} {}}
+
+# Done with block tests
+delete_all_variables
+
+#####        #####
+#                #
+# children tests #
+#                #
+#####        #####
+
+gdb_cmd "break do_children_tests"
+gdb_cmd "continue"
+
+# Test: c_variable-4.1
+# Desc: stopped in do_children_tests
+gdbtk_test c_variable-4.1 {stopped in do_children_tests} {
+  lindex [gdb_loc] 1
+} {do_children_tests}
+
+# Test: c_variable-4.2
+# Desc: create variable "struct_declarations"
+gdbtk_test c_variable-4.2 {create variable "struct_declarations"} {
+  create_variable struct_declarations
+} {0}
+
+# Test: c_variable-4.3
+# Desc: children of struct_declarations
+gdbtk_test c_variable-4.3 {children of struct_declarations} {
+  get_children  struct_declarations
+} {integer character char_ptr long_int int_ptr_ptr long_array func_ptr func_ptr_struct func_ptr_ptr u1 s2}
+
+# Test: c_variable-4.4
+# Desc: number of children of struct_declarations
+gdbtk_test c_variable-4.4 {number of children of struct_declarations} {
+  $var(struct_declarations) numChildren
+} {11}
+
+# Test: c_variable-4.5
+# Desc: children of struct_declarations.integer
+gdbtk_test c_variable-4.5 {children of struct_declarations.integer} {
+  get_children struct_declarations.integer
+} {}
+
+# Test: c_variable-4.6
+# Desc: number of children of struct_declarations.integer
+gdbtk_test c_variable-4.6 {number of children of struct_declarations.integer} {
+  $var(struct_declarations.integer) numChildren
+} {0}
+
+# Test: c_variable-4.7
+# Desc: children of struct_declarations.character
+gdbtk_test c_variable-4.7 {children of struct_declarations.character} {
+  get_children struct_declarations.character
+} {}
+
+# Test: c_variable-4.8
+# Desc: number of children of struct_declarations.character
+gdbtk_test c_variable-4.8 {number of children of struct_declarations.character} {
+  $var(struct_declarations.character) numChildren
+} {0}
+
+# Test: c_variable-4.9
+# Desc: children of struct_declarations.char_ptr
+gdbtk_test c_variable-4.9 {children of struct_declarations.char_ptr} {
+  get_children struct_declarations.char_ptr
+} {*char_ptr}
+
+# Test: c_variable-4.10
+# Desc: number of children of struct_declarations.char_ptr
+gdbtk_test c_variable-4.10 {number of children of struct_declarations.char_ptr} {
+  $var(struct_declarations.char_ptr) numChildren
+} {1}
+
+# Test: c_variable-4.11
+# Desc: children of struct_declarations.long_int
+gdbtk_test c_variable-4.11 {children of struct_declarations.long_int} {
+
+  get_children struct_declarations.long_int
+} {}
+
+# Test: c_variable-4.12
+# Desc: number of children of struct_declarations.long_int
+gdbtk_test c_variable-4.12 {number of children of struct_declarations.long_int} {
+  $var(struct_declarations.long_int) numChildren
+} {0}
+
+# Test: c_variable-4.13
+# Desc: children of int_ptr_ptr
+gdbtk_test c_variable-4.13 {children of int_ptr_ptr} {
+  get_children struct_declarations.int_ptr_ptr
+} {*int_ptr_ptr}
+
+# Test: c_variable-4.14
+# Desc: number of children of int_ptr_ptr
+gdbtk_test c_variable-4.14 {number of children of int_ptr_ptr} {
+  $var(struct_declarations.int_ptr_ptr) numChildren
+} {1}
+
+# Test: c_variable-4.15
+# Desc: children of struct_declarations.long_array
+gdbtk_test c_variable-4.15 {children of struct_declarations.long_array} {
+  get_children struct_declarations.long_array
+} {0 1 2 3 4 5 6 7 8 9}
+
+# Test: c_variable-4.16
+# Desc: number of children of struct_declarations.long_array
+gdbtk_test c_variable-4.16 {number of children of struct_declarations.long_array} {
+  $var(struct_declarations.long_array) numChildren
+} {10}
+
+# Test: c_variable-4.17
+# Desc: children of struct_declarations.func_ptr
+gdbtk_test c_variable-4.17 {children of struct_declarations.func_ptr} {
+  get_children struct_declarations.func_ptr
+} {}
+
+# Test: c_variable-4.18
+# Desc: number of children of struct_declarations.func_ptr
+gdbtk_test c_variable-4.18 {number of children of struct_declarations.func_ptr} {
+  $var(struct_declarations.func_ptr) numChildren
+} {0}
+
+# Test: c_variable-4.19
+# Desc: children of struct_declarations.func_ptr_struct
+gdbtk_test c_variable-4.19 {children of struct_declarations.func_ptr_struct} {
+  get_children struct_declarations.func_ptr_struct
+} {}
+
+# Test: c_variable-4.20
+# Desc: number of children of struct_declarations.func_ptr_struct
+gdbtk_test c_variable-4.20 {number of children of struct_declarations.func_ptr_struct} {
+  $var(struct_declarations.func_ptr_struct) numChildren
+} {0}
+
+# Test: c_variable-4.21
+# Desc: children of struct_declarations.func_ptr_ptr
+gdbtk_test c_variable-4.21 {children of struct_declarations.func_ptr_ptr} {
+  get_children struct_declarations.func_ptr_ptr
+} {}
+
+# Test: c_variable-4.22
+# Desc: number of children of struct_declarations.func_ptr_ptr
+gdbtk_test c_variable-4.22 {number of children of struct_declarations.func_ptr_ptr} {
+  $var(struct_declarations.func_ptr_ptr) numChildren
+} {0}
+
+# Test: c_variable-4.23
+# Desc: children of struct_declarations.u1
+gdbtk_test c_variable-4.23 {children of struct_declarations.u1} {
+  get_children struct_declarations.u1
+} {a b c d}
+
+# Test: c_variable-4.24
+# Desc: number of children of struct_declarations.u1
+gdbtk_test c_variable-4.24 {number of children of struct_declarations.u1} {
+  $var(struct_declarations.u1) numChildren
+} {4}
+
+# Test: c_variable-4.25
+# Desc: children of struct_declarations.s2
+gdbtk_test c_variable-4.25 {children of struct_declarations.s2} {
+  get_children struct_declarations.s2
+} {u2 g h i}
+
+# Test: c_variable-4.26
+# Desc: number of children of struct_declarations.s2
+gdbtk_test c_variable-4.26 {number of children of struct_declarations.s2} {
+  $var(struct_declarations.s2) numChildren
+} {4}
+
+# Test: c_variable-4.27
+# Desc: children of struct_declarations.long_array.1
+gdbtk_test c_variable-4.27 {children of struct_declarations.long_array.1} {
+  get_children struct_declarations.long_array.1
+} {}
+
+# Test: c_variable-4.28
+# Desc: number of children of struct_declarations.long_array.1
+gdbtk_test c_variable-4.28 {number of children of struct_declarations.long_array.1} {
+  $var(struct_declarations.long_array.1) numChildren
+} {0}
+
+# Test: c_variable-4.29
+# Desc: children of struct_declarations.long_array.2
+gdbtk_test c_variable-4.29 {children of struct_declarations.long_array.2} {
+  get_children struct_declarations.long_array.2
+} {}
+
+# Test: c_variable-4.30
+# Desc: number of children of struct_declarations.long_array.2
+gdbtk_test c_variable-4.30 {number of children of struct_declarations.long_array.2} {
+  $var(struct_declarations.long_array.2) numChildren
+} {0}
+
+# Test: c_variable-4.31
+# Desc: children of struct_declarations.long_array.3
+gdbtk_test c_variable-4.31 {children of struct_declarations.long_array.3} {
+  get_children struct_declarations.long_array.3
+} {}
+
+# Test: c_variable-4.32
+# Desc: number of children of struct_declarations.long_array.3
+gdbtk_test c_variable-4.32 {number of children of struct_declarations.long_array.3} {
+  $var(struct_declarations.long_array.3) numChildren
+} {0}
+
+# Test: c_variable-4.33 
+# Desc: children of struct_declarations.long_array.4
+gdbtk_test c_variable-4.33 {children of struct_declarations.long_array.4} {
+  get_children struct_declarations.long_array.4
+} {}
+
+# Test: c_variable-4.34
+# Desc: number of children of struct_declarations.long_array.4
+gdbtk_test c_variable-4.34 {number of children of struct_declarations.long_array.4} {
+  $var(struct_declarations.long_array.4) numChildren
+} {0}
+
+# Test: c_variable-4.35
+# Desc: children of struct_declarations.long_array.5
+gdbtk_test c_variable-4.35 {children of struct_declarations.long_array.5} {
+  get_children struct_declarations.long_array.5
+} {}
+
+# Test: c_variable-4.36
+# Desc: number of children of struct_declarations.long_array.5
+gdbtk_test c_variable-4.36 {number of children of struct_declarations.long_array.5} {
+  $var(struct_declarations.long_array.5) numChildren
+} {0}
+
+# Test: c_variable-4.37
+# Desc: children of struct_declarations.long_array.6
+gdbtk_test c_variable-4.37 {children of struct_declarations.long_array.6} {
+  get_children struct_declarations.long_array.6
+} {}
+
+# Test: c_variable-4.38
+# Desc: number of children of struct_declarations.long_array.6
+gdbtk_test c_variable-4.38 {number of children of struct_declarations.long_array.6} {
+  $var(struct_declarations.long_array.6) numChildren
+} {0}
+
+# Test: c_variable-4.39
+# Desc: children of struct_declarations.long_array.7
+gdbtk_test c_variable-4.39 {children of struct_declarations.long_array.7} {
+  get_children struct_declarations.long_array.7
+} {}
+
+# Test: c_variable-4.40
+# Desc: number of children of struct_declarations.long_array.7
+gdbtk_test c_variable-4.40 {number of children of struct_declarations.long_array.7} {
+  $var(struct_declarations.long_array.7) numChildren
+} {0}
+
+# Test: c_variable-4.41
+# Desc: children of struct_declarations.long_array.8
+gdbtk_test c_variable-4.41 {children of struct_declarations.long_array.8} {
+  get_children struct_declarations.long_array.8
+} {}
+
+# Test: c_variable-4.42
+# Desc: number of children of struct_declarations.long_array.8
+gdbtk_test c_variable-4.42 {number of children of struct_declarations.long_array.8} {
+  $var(struct_declarations.long_array.8) numChildren
+} {0}
+
+# Test: c_variable-4.43
+# Desc: children of struct_declarations.long_array.9
+gdbtk_test c_variable-4.43 {children of struct_declarations.long_array.9} {
+  get_children struct_declarations.long_array.9
+} {}
+
+# Test: c_variable-4.44
+# Desc: number of children of struct_declarations.long_array.9
+gdbtk_test c_variable-4.44 {number of children of struct_declarations.long_array.9} {
+  $var(struct_declarations.long_array.9) numChildren
+} {0}
+
+# Test: c_variable-4.45
+# Desc: children of struct_declarations.u1.a
+gdbtk_test c_variable-4.45 {children of struct_declarations.u1.a} {
+  get_children struct_declarations.u1.a
+} {}
+
+# Test: c_variable-4.46
+# Desc: number of children of struct_declarations.u1.a
+gdbtk_test c_variable-4.46 {number of children of struct_declarations.u1.a} {
+  $var(struct_declarations.u1.a) numChildren
+} {0}
+
+# Test: c_variable-4.47
+# Desc: children of struct_declarations.u1.b
+gdbtk_test c_variable-4.47 {children of struct_declarations.u1.b} {
+  get_children struct_declarations.u1.b
+} {*b}
+
+# Test: c_variable-4.48
+# Desc: number of children of struct_declarations.u1.b
+gdbtk_test c_variable-4.48 {number of children of struct_declarations.u1.b} {
+  $var(struct_declarations.u1.b) numChildren
+} {1}
+
+# Test: c_variable-4.49
+# Desc: children of struct_declarations.u1.c
+gdbtk_test c_variable-4.49 {children of struct_declarations.u1.c} {
+  get_children struct_declarations.u1.c
+} {}
+
+# Test: c_variable-4.50
+# Desc: number of children of struct_declarations.u1.c
+gdbtk_test c_variable-4.50 {number of children of struct_declarations.u1.c} {
+  $var(struct_declarations.u1.c) numChildren
+} {0}
+
+# Test: c_variable-4.51
+# Desc: children of struct_declarations.u1.d
+gdbtk_test c_variable-4.51 {children of struct_declarations.u1.d} {
+  get_children struct_declarations.u1.d
+} {}
+
+# Test: c_variable-4.52
+# Desc: number of children of struct_declarations.u1.d
+gdbtk_test c_variable-4.52 {number of children of struct_declarations.u1.d} {
+  $var(struct_declarations.u1.d) numChildren
+} {0}
+
+# Test: c_variable-4.53
+# Desc: children of struct_declarations.s2.u2
+gdbtk_test c_variable-4.53 {children of struct_declarations.s2.u2} {
+  get_children struct_declarations.s2.u2
+} {u1s1 f u1s2}
+
+# Test: c_variable-4.54
+# Desc: number of children of struct_declarations.s2.u2
+gdbtk_test c_variable-4.54 {number of children of struct_declarations.s2.u2} {
+  $var(struct_declarations.s2.u2) numChildren
+} {3}
+
+# Test: c_variable-4.55
+# Desc: children of struct_declarations.s2.g
+gdbtk_test c_variable-4.55 {children of struct_declarations.s2.g} {
+  get_children struct_declarations.s2.g
+} {}
+
+# Test: c_variable-4.56
+# Desc: number of children of struct_declarations.s2.g
+gdbtk_test c_variable-4.56 {number of children of struct_declarations.s2.g} {
+  $var(struct_declarations.s2.g) numChildren
+} {0}
+
+# Test: c_variable-4.57
+# Desc: children of struct_declarations.s2.h
+gdbtk_test c_variable-4.57 {children of struct_declarations.s2.h} {
+  get_children struct_declarations.s2.h
+} {}
+
+# Test: c_variable-4.58
+# Desc: number of children of struct_declarations.s2.h
+gdbtk_test c_variable-4.58 {number of children of struct_declarations.s2.h} {
+  $var(struct_declarations.s2.h) numChildren
+} {0}
+
+# Test: c_variable-4.59
+# Desc: children of struct_declarations.s2.i
+gdbtk_test c_variable-4.59 {children of struct_declarations.s2.i} {
+  get_children struct_declarations.s2.i
+} {0 1 2 3 4 5 6 7 8 9}
+
+# Test: c_variable-4.60
+# Desc: number of children of struct_declarations.s2.i
+gdbtk_test c_variable-4.60 {number of children of struct_declarations.s2.i} {
+  $var(struct_declarations.s2.i) numChildren
+} {10}
+
+# Test: c_variable-4.61
+# Desc: children of struct_declarations.s2.u2.u1s1
+gdbtk_test c_variable-4.61 {children of struct_declarations.s2.u2.u1s1} {
+  get_children struct_declarations.s2.u2.u1s1
+} {d e func foo}
+
+# Test: c_variable-4.62
+# Desc: number of children of struct_declarations.s2.u2.u1s1
+gdbtk_test c_variable-4.62 {number of children of struct_declarations.s2.u2.u1s1} {
+  $var(struct_declarations.s2.u2.u1s1) numChildren
+} {4}
+
+# Test: c_variable-4.63
+# Desc: children of struct_declarations.s2.u2.f
+gdbtk_test c_variable-4.63 {children of struct_declarations.s2.u2.f} {
+  get_children struct_declarations.s2.u2.f
+} {}
+
+# Test: c_variable-4.64
+# Desc: number of children of struct_declarations.s2.u2.f
+gdbtk_test c_variable-4.64 {number of children of struct_declarations.s2.u2.f} {
+  $var(struct_declarations.s2.u2.f) numChildren
+} {0}
+
+# Test: c_variable-4.65
+# Desc: children of struct_declarations.s2.u2.u1s2
+gdbtk_test c_variable-4.65 {children of struct_declarations.s2.u2.u1s2} {
+  get_children struct_declarations.s2.u2.u1s2
+} {array_ptr func}
+
+# Test: c_variable-4.66
+# Desc: number of children of struct_declarations.s2.u2.u1s2
+gdbtk_test c_variable-4.66 {number of children of struct_declarations.s2.u2.u1s2} {
+  $var(struct_declarations.s2.u2.u1s2) numChildren
+} {2}
+
+# Test: c_variable-4.67
+# Desc: children of struct_declarations.s2.u2.u1s1.d
+gdbtk_test c_variable-4.67 {children of struct_declarations.s2.u2.u1s1.d} {
+  get_children struct_declarations.s2.u2.u1s1.d
+} {}
+
+# Test: c_variable-4.68
+# Desc: number of children of struct_declarations.s2.u2.u1s1.d
+gdbtk_test c_variable-4.68 {number of children of struct_declarations.s2.u2.u1s1.d} {
+  $var(struct_declarations.s2.u2.u1s1.d) numChildren
+} {0}
+
+# Test: c_variable-4.69
+# Desc: children of struct_declarations.s2.u2.u1s1.e
+gdbtk_test c_variable-4.69 {children of struct_declarations.s2.u2.u1s1.e} {
+  get_children struct_declarations.s2.u2.u1s1.e
+} {0 1 2 3 4 5 6 7 8 9}
+
+# Test: c_variable-4.70
+# Desc: number of children of struct_declarations.s2.u2.u1s1.e
+gdbtk_test c_variable-4.70 {number of children of struct_declarations.s2.u2.u1s1.e} {
+  $var(struct_declarations.s2.u2.u1s1.e) numChildren
+} {10}
+
+# Test: c_variable-4.71
+# Desc: children of struct_declarations.s2.u2.u1s1.func
+gdbtk_test c_variable-4.71 {children of struct_declarations.s2.u2.u1s1.func} {
+  get_children struct_declarations.s2.u2.u1s1.func
+} {}
+
+# Test: c_variable-4.72
+# Desc: number of children of struct_declarations.s2.u2.u1s1.func
+gdbtk_test c_variable-4.72 {number of children of struct_declarations.s2.u2.u1s1.func} {
+  $var(struct_declarations.s2.u2.u1s1.func) numChildren
+} {0}
+
+# Test: c_variable-4.73
+# Desc: children of struct_declarations.s2.u2.u1s1.foo
+gdbtk_test c_variable-4.73 {children of struct_declarations.s2.u2.u1s1.foo} {
+  get_children struct_declarations.s2.u2.u1s1.foo
+} {}
+
+# Test: c_variable-4.74
+# Desc: number of children of struct_declarations.s2.u2.u1s1.foo
+gdbtk_test c_variable-4.74 {number of children of struct_declarations.s2.u2.u1s1.foo} {
+  $var(struct_declarations.s2.u2.u1s1.foo) numChildren
+} {0}
+
+# Test: c_variable-4.75
+# Desc: children of struct_declarations.s2.u2.u1s2.array_ptr
+gdbtk_test c_variable-4.75 {children of struct_declarations.s2.u2.u1s2.array_ptr} {
+  get_children struct_declarations.s2.u2.u1s2.array_ptr
+} {0 1}
+
+# Test: c_variable-4.76
+# Desc: number of children of struct_declarations.s2.u2.u1s2.array_ptr
+gdbtk_test c_variable-4.76 {number of children of struct_declarations.s2.u2.u1s2.array_ptr} {
+  $var(struct_declarations.s2.u2.u1s2.array_ptr) numChildren
+} {2}
+
+# Test: c_variable-4.77
+# Desc: children of struct_declarations.s2.u2.u1s2.func
+gdbtk_test c_variable-4.77 {children of struct_declarations.s2.u2.u1s2.func} {
+  get_children struct_declarations.s2.u2.u1s2.func
+} {}
+
+# Test: c_variable-4.78
+# Desc: number of children of struct_declarations.s2.u2.u1s2.func
+gdbtk_test c_variable-4.78 {number of children of struct_declarations.s2.u2.u1s2.func} {
+  $var(struct_declarations.s2.u2.u1s2.func) numChildren
+} {0}
+
+# Test: c_variable-4.79
+# Desc: children of struct_declarations.*int_ptr_ptr
+gdbtk_test c_variable-4.79 {children of struct_declarations.*int_ptr_ptr} {
+  get_children struct_declarations.int_ptr_ptr.*int_ptr_ptr
+} {**int_ptr_ptr}
+
+# Test: c_variable-4.80
+# Desc: Number of children of struct_declarations.*int_ptr_ptr
+gdbtk_test c_variable-4.80 {Number of children of struct_declarations.*int_ptr_ptr} {
+  $var(struct_declarations.int_ptr_ptr.*int_ptr_ptr) numChildren
+} {1}
+
+# Step to "struct_declarations.integer = 123;"
+gdb_cmd "step"
+
+# Test: c_variable-4.81
+# Desc: create local variable "weird"
+gdbtk_test c_variable-4.81 {create local variable "weird"} {
+  create_variable weird
+} {0}
+
+# Test: c_variable-4.82
+# Desc: children of weird
+gdbtk_test c_variable-4.82 {children of weird} {
+  get_children weird
+} {integer character char_ptr long_int int_ptr_ptr long_array func_ptr func_ptr_struct func_ptr_ptr u1 s2}
+
+# Test: c_variable-4.83
+# Desc: number of children of weird
+gdbtk_test c_variable-4.83 {number of children of weird} {
+  $var(weird) numChildren
+} {11}
+
+# Test: c_variable-4.84
+# Desc: children of weird->long_array
+gdbtk_test c_variable-4.84 {children of weird->long_array} {
+  get_children weird.long_array
+} {0 1 2 3 4 5 6 7 8 9}
+
+# Test: c_variable-4.85
+# Desc: number of children of weird->long_array
+gdbtk_test c_variable-4.85 {number of children of weird->long_array} {
+  $var(weird.long_array) numChildren
+} {10}
+
+# Test: c_variable-4.86
+# Desc: children of weird->int_ptr_ptr
+gdbtk_test c_variable-4.86 {children of weird->int_ptr_ptr} {
+  get_children weird.int_ptr_ptr
+} {*int_ptr_ptr}
+
+# Test: c_variable-4.87
+# Desc: number of children of weird->int_ptr_ptr
+gdbtk_test c_variable-4.87 {number of children of weird->int_ptr_ptr} {
+  $var(weird.int_ptr_ptr) numChildren
+} {1}
+
+# Test: c_variable-4.88
+# Desc: children of *weird->int_ptr_ptr
+gdbtk_test c_variable-4.88 {children of *weird->int_ptr_ptr} {
+  get_children weird.int_ptr_ptr.*int_ptr_ptr
+} {**int_ptr_ptr}
+
+# Test: c_variable-4.89
+# Desc: number of children *weird->int_ptr_ptr
+gdbtk_test c_variable-4.89 {number of children *weird->int_ptr_ptr} {
+  $var(weird.int_ptr_ptr.*int_ptr_ptr) numChildren
+} {1}
+
+# Test: c_variable-4.90
+# Desc: create weird->int_ptr_ptr
+gdbtk_test c_variable-4.90 {create weird->int_ptr_ptr} {
+  create_variable weird->int_ptr_ptr
+} {0}
+
+# Test: c_variable-4.91
+# Desc: children of weird->int_ptr_ptr
+gdbtk_test c_variable-4.91 {children of weird->int_ptr_ptr} {
+  get_children weird->int_ptr_ptr
+} {*weird->int_ptr_ptr}
+
+# Test: c_variable-4.92
+# Desc: number of children of (weird->int_ptr_ptr)
+gdbtk_test c_variable-4.92 {number of children of (weird->int_ptr_ptr)} {
+  $var(weird->int_ptr_ptr) numChildren
+} {1}
+
+# Test: c_variable-4.93
+# Desc: children of *(weird->int_ptr_ptr)
+gdbtk_test c_variable-4.93 {children of *(weird->int_ptr_ptr)} {
+  get_children weird->int_ptr_ptr.*weird->int_ptr_ptr
+} {**weird->int_ptr_ptr}
+
+# Test: c_variable-4.94
+# Desc: number of children of *(weird->int_ptr_ptr)
+gdbtk_test c_variable-4.94 {number of children of *(weird->int_ptr_ptr)} {
+  $var(weird->int_ptr_ptr.*weird->int_ptr_ptr) numChildren
+} {1}
+
+# Test: c_variable-4.95
+# Desc: children of *(*(weird->int_ptr_ptr))
+gdbtk_test c_variable-4.95 {children of *(*(weird->int_ptr_ptr))} {
+  get_children weird->int_ptr_ptr.*weird->int_ptr_ptr.**weird->int_ptr_ptr
+} {}
+
+# Test: c_variable-4.96
+# Desc: number of children of *(*(weird->int_ptr_ptr))
+gdbtk_test c_variable-4.96 {number of children of **weird->int_ptr_ptr} {
+  $var(weird->int_ptr_ptr.*weird->int_ptr_ptr.**weird->int_ptr_ptr) numChildren
+} {0}
+
+# Test: c_variable-4.97
+# Desc: is weird editable
+gdbtk_test c_variable-4.97 {is weird editable} {
+  $var(weird) editable
+} {1}
+
+# Test: c_variable-4.98
+# Desc: is weird->int_ptr_ptr editable
+gdbtk_test c_variable-4.98 {is weird->int_ptr_ptr editable} {
+  $var(weird.int_ptr_ptr) editable
+} {1}
+
+# Test: c_variable-4.99
+# Desc: is *(weird->int_ptr_ptr) editable
+gdbtk_test c_variable-4.99 {is *(weird->int_ptr_ptr) editable} {
+  $var(weird.int_ptr_ptr.*int_ptr_ptr) editable
+} {1}
+
+# Test: c_variable-4.100
+# Desc: is *(*(weird->int_ptr_ptr)) editable
+gdbtk_test c_variable-4.100 {is *(*(weird->int_ptr_ptr)) editable} {
+  $var(weird.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr) editable
+} {1}
+
+# Test: c_variable-4.101
+# Desc: is weird->u1 editable
+gdbtk_test c_variable-4.101 {is weird->u1 editable} {
+  $var(weird.u1) editable
+} {0}
+
+# Test: c_variable-4.102
+# Desc: is weird->s2 editable
+gdbtk_test c_variable-4.102 {is weird->s2 editable} {
+  $var(weird.s2) editable
+} {0}
+
+# Test: c_variable-4.103
+# Desc: is struct_declarations.u1.a editable
+gdbtk_test c_variable-4.103 {is struct_declarations.u1.a editable} {
+  $var(struct_declarations.u1.a) editable
+} {1}
+
+# Test: c_variable-4.104
+# Desc: is struct_declarations.u1.b editable
+gdbtk_test c_variable-4.104 {is struct_declarations.u1.b editable} {
+  $var(struct_declarations.u1.b) editable
+} {1}
+
+# Test: c_variable-4.105
+# Desc: is struct_declarations.u1.c editable
+gdbtk_test c_variable-4.105 {is struct_declarations.u1.c editable} {
+  $var(struct_declarations.u1.c) editable
+} {1}
+
+# Test: c_variable-4.106
+# Desc: is struct_declarations.long_array editable
+gdbtk_test c_variable-4.106 {is struct_declarations.long_array editable} {
+  $var(struct_declarations.long_array) editable
+} {0}
+
+# Test: c_variable-4.107
+# Desc: is struct_declarations.long_array[0] editable
+gdbtk_test c_variable-4.107 {is struct_declarations.long_array[0] editable} {
+  $var(struct_declarations.long_array.0) editable
+} {1}
+
+# Test: c_variable-4.108
+# Desc: is struct_declarations editable
+gdbtk_test c_variable-4.108 {is struct_declarations editable} {
+  $var(struct_declarations) editable
+} {0}
+
+delete_variable weird
+
+#####                         #####
+#                                 #
+# children and update tests #
+#                                 #
+#####                         #####
+
+# Test: c_variable-5.1
+# Desc: check that nothing changed
+gdbtk_test c_variable-5.1 {check that nothing changed} {
+  check_update
+} {{} {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over "struct_declarations.integer = 123;"
+gdb_cmd "step"
+
+# Test: c_variable-5.2
+# Desc: check that integer changed
+gdbtk_test c_variable-5.2 {check that integer changed} {
+  check_update
+} {struct_declarations.integer {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over:
+#    weird->char_ptr = "hello";
+#    bar = 2121;
+#    foo = &bar;
+for {set i 0} {$i < 3} {incr i} {
+  gdb_cmd "step"
+}
+
+# Test: c_variable-5.3
+# Desc: check that char_ptr changed
+gdbtk_test c_variable-5.3 {check that char_ptr changed} {
+  check_update
+} {{{struct_declarations.char_ptr struct_declarations.char_ptr.*char_ptr}} {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over "struct_declarations.int_ptr_ptr = &foo;"
+gdb_cmd "step"
+
+# Test: c_variable-5.4
+# Desc: check that int_ptr_ptr and children changed
+gdbtk_test c_variable-5.4 {check that int_ptr_ptr and children changed} {
+  check_update
+} {{{struct_declarations.int_ptr_ptr struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr}} {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over "weird->long_array[0] = 1234;"
+gdb_cmd "step"
+
+# Test: c_variable-5.5
+# Desc: check that long_array[0] changed
+gdbtk_test c_variable-5.5 {check that long_array[0] changed} {
+  check_update
+} {struct_declarations.long_array.0 {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over "struct_declarations.long_array[1] = 2345;"
+gdb_cmd "step"
+
+# Test: c_variable-5.6
+# Desc: check that long_array[1] changed
+gdbtk_test c_variable-5.6 {check that long_array[1] changed} {
+  check_update
+} {struct_declarations.long_array.1 {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over "weird->long_array[2] = 3456;"
+gdb_cmd "step"
+
+# Test: c_variable-5.7
+# Desc: check that long_array[2] changed
+gdbtk_test c_variable-5.7 {check that long_array[2] changed} {
+  check_update
+} {struct_declarations.long_array.2 {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over:
+#    struct_declarations.long_array[3] = 4567;
+#    weird->long_array[4] = 5678;
+#    struct_declarations.long_array[5] = 6789;
+#    weird->long_array[6] = 7890;
+#    struct_declarations.long_array[7] = 8901;
+#    weird->long_array[8] = 9012;
+#    struct_declarations.long_array[9] = 1234;
+for {set i 0} {$i < 7} {incr i} {
+  gdb_cmd "step"
+}
+
+# Test: c_variable-5.8
+# Desc: check that long_array[3-9] changed
+gdbtk_test c_variable-5.8 {check that long_array[3-9] changed} {
+  check_update
+} {{{struct_declarations.long_array.3 struct_declarations.long_array.4 struct_declarations.long_array.5 struct_declarations.long_array.6 struct_declarations.long_array.7 struct_declarations.long_array.8 struct_declarations.long_array.9}} {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Step over "weird->func_ptr = nothing;"
+gdb_cmd "step"
+
+# Test: c_variable-5.9
+# Desc: check that func_ptr changed
+gdbtk_test c_variable-5.9 {check that func_ptr changed} {
+  check_update
+} {struct_declarations.func_ptr {struct_declarations.s2.i.3 struct_declarations.func_ptr_ptr struct_declarations.s2.i.4 struct_declarations.s2.i.5 struct_declarations.s2.i.6 struct_declarations.func_ptr struct_declarations.s2.i.7 struct_declarations.s2.i.8 struct_declarations.s2.i.9 struct_declarations.s2.u2.u1s1.d struct_declarations.func_ptr_struct struct_declarations.s2.u2.u1s1.e struct_declarations.u1 struct_declarations.char_ptr.*char_ptr struct_declarations.long_int struct_declarations.s2.u2.u1s2.func struct_declarations.integer struct_declarations.s2.u2 struct_declarations.s2.u2.u1s1.e.0 struct_declarations.s2.u2.u1s1.e.1 struct_declarations.long_array.0 struct_declarations.s2.u2.u1s1.e.2 struct_declarations.long_array.1 struct_declarations.u1.a struct_declarations.s2.u2.u1s1.e.3 struct_declarations.long_array.2 struct_declarations.u1.b struct_declarations.s2.u2.u1s1.e.4 struct_declarations.long_array.3 struct_declarations.u1.c struct_declarations.s2.u2.u1s1.e.5 struct_declarations.long_array.4 struct_declarations.u1.d struct_declarations.u1.b.*b struct_declarations.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr struct_declarations.s2.u2.u1s1.e.6 struct_declarations.long_array.5 struct_declarations.s2.u2.u1s1.e.7 struct_declarations.long_array.6 struct_declarations.s2.u2.u1s1.e.8 struct_declarations.long_array.7 struct_declarations.s2.u2.u1s1.e.9 struct_declarations.long_array.8 struct_declarations.character struct_declarations.long_array.9 struct_declarations.int_ptr_ptr.*int_ptr_ptr struct_declarations.s2.u2.u1s1.func struct_declarations.s2.u2.u1s2.array_ptr struct_declarations.s2.u2.f struct_declarations.s2.u2.u1s1.foo struct_declarations.s2.u2.u1s1 struct_declarations.s2.u2.u1s2.array_ptr.0 struct_declarations.char_ptr struct_declarations.s2.u2.u1s2 struct_declarations.s2.u2.u1s2.array_ptr.1 struct_declarations.int_ptr_ptr struct_declarations.s2 struct_declarations.long_array struct_declarations.s2.g struct_declarations.s2.i.0 struct_declarations.s2.h struct_declarations.s2.i.1 struct_declarations.s2.i struct_declarations.s2.i.2}}
+
+# Delete all variables
+delete_all_variables
+
+# Step over all lines:
+# ...
+#   psnp = &snp0;
+for {set i 0} {$i < 43} {incr i} {
+  gdb_cmd "step"
+}
+
+# Test: c_variable-5.10
+# Desc: create psnp->char_ptr
+gdbtk_test c_variable-5.10 {create psnp->char_ptr} {
+  create_variable psnp->char_ptr
+} {0}
+
+# Test: c_variable-5.11
+# Desc: children of psnp->char_ptr
+gdbtk_test c_variable-5.11 {children of psnp->char_ptr} {
+  get_children psnp->char_ptr
+} {*psnp->char_ptr}
+
+# Test: c_variable-5.12
+# Desc: number of children of psnp->char_ptr
+gdbtk_test c_variable-5.12 {number of children of psnp->char_ptr} {
+  $var(psnp->char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.13
+# Desc: children of *(psnp->char_ptr)
+gdbtk_test c_variable-5.13 {children of *(psnp->char_ptr)} {
+  get_children psnp->char_ptr.*psnp->char_ptr
+} {**psnp->char_ptr}
+
+# Test: c_variable-5.14
+# Desc: number of children of *(psnp->char_ptr)
+gdbtk_test c_variable-5.14 {number of children of *(psnp->char_ptr)} {
+  $var(psnp->char_ptr.*psnp->char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.15
+# Desc: children of *(*(psnp->char_ptr))
+gdbtk_test c_variable-5.15 {children of *(*(psnp->char_ptr))} {
+  get_children psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr
+} {***psnp->char_ptr}
+
+# Test: c_variable-5.16
+# Desc: number of children of *(*(psnp->char_ptr))
+gdbtk_test c_variable-5.16 {number of children of *(*(psnp->char_ptr))} {
+  $var(psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.17
+# Desc: children of *(*(*(psnp->char_ptr)))
+gdbtk_test c_variable-5.17 {children of *(*(*(psnp->char_ptr)))} {
+  get_children psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr
+} {****psnp->char_ptr}
+
+# Test: c_variable-5.18
+# Desc: number of children of *(*(*(psnp->char_ptr)))
+gdbtk_test c_variable-5.18 {number of children of *(*(*(psnp->char_ptr)))} {
+  $var(psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.19
+# Desc: create psnp->long_ptr
+gdbtk_test c_variable-5.19 {create psnp->long_ptr} {
+  create_variable psnp->long_ptr
+} {0}
+
+# Test: c_variable-5.20
+# Desc: children of psnp->long_ptr
+gdbtk_test c_variable-5.20 {children of psnp->long_ptr} {
+  get_children psnp->long_ptr
+} {*psnp->long_ptr}
+
+# Test: c_variable-5.21
+# Desc: number of children of psnp->long_ptr
+gdbtk_test c_variable-5.21 {number of children of psnp->long_ptr} {
+  $var(psnp->long_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.22
+# Desc: children of *(psnp->long_ptr)
+gdbtk_test c_variable-5.22 {children of *(psnp->long_ptr)} {
+  get_children psnp->long_ptr.*psnp->long_ptr
+} {**psnp->long_ptr}
+
+# Test: c_variable-5.23
+# Desc: number of children of *(psnp->long_ptr)
+gdbtk_test c_variable-5.23 {number of children of *(psnp->long_ptr)} {
+  $var(psnp->long_ptr.*psnp->long_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.24
+# Desc: children of *(*(psnp->long_ptr))
+gdbtk_test c_variable-5.24 {children of *(*(psnp->long_ptr))} {
+  get_children psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr
+} {***psnp->long_ptr}
+
+# Test: c_variable-5.25
+# Desc: number of children of *(*(psnp->long_ptr))
+gdbtk_test c_variable-5.25 {number of children of *(*(psnp->long_ptr))} {
+  $var(psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.26
+# Desc: children of *(*(*(psnp->long_ptr)))
+gdbtk_test c_variable-5.26 {children of *(*(*(psnp->long_ptr)))} {
+  get_children psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr
+} {****psnp->long_ptr}
+
+# Test: c_variable-5.27
+# Desc: number of children of *(*(*(psnp->long_ptr)))
+gdbtk_test c_variable-5.27 {number of children of *(*(*(psnp->long_ptr)))} {
+  $var(psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.28
+# Desc: children of *(*(*(*(psnp->long_ptr))))
+gdbtk_test c_variable-5.29 {children of *(*(*(*(psnp->long_ptr))))} {
+  get_children psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr
+} {}
+
+# Test: c_variable-5.29
+# Desc: number of children of *(*(*(*(psnp->long_ptr))))
+gdbtk_test c_variable-5.29 {number of children of *(*(*(*(psnp->long_ptr))))} {
+  $var(psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr) numChildren
+} {0}
+
+# Test: c_variable-5.30
+# Desc: create psnp->ptrs
+gdbtk_test c_variable-5.30 {create psnp->ptrs} {
+  create_variable psnp->ptrs
+} {0}
+
+# Test: c_variable-5.31
+# Desc: children of psnp->ptrs
+gdbtk_test c_variable-5.31 {children of psnp->ptrs} {
+  get_children psnp->ptrs
+} {0 1 2}
+
+# Test: c_variable-5.32
+# Desc: number of children of psnp->ptrs
+gdbtk_test c_variable-5.32 {number of children of psnp->ptrs} {
+  $var(psnp->ptrs) numChildren
+} {3}
+
+# Test: c_variable-5.33
+# Desc: children of psnp->ptrs[0]
+gdbtk_test c_variable-5.33 {children of psnp->ptrs[0]} {
+  get_children psnp->ptrs.0
+} {char_ptr long_ptr ptrs next}
+
+# Test: c_variable-5.34
+# Desc: number of children of psnp->ptrs[0]
+gdbtk_test c_variable-5.34 {number of children of psnp->ptrs[0]} {
+  $var(psnp->ptrs.0) numChildren
+} {4}
+
+# Test: c_variable-5.35
+# Desc: children of psnp->ptrs[0]->next
+gdbtk_test c_variable-5.35 {children of psnp->ptrs.0.next} {
+  get_children psnp->ptrs.0.next
+} {char_ptr long_ptr ptrs next}
+
+# Test: c_variable-5.36
+# Desc: number of children of psnp->ptrs[0]->next
+gdbtk_test c_variable-5.36 {number of children of psnp->ptrs[0]->next} {
+  $var(psnp->ptrs.0.next) numChildren
+} {4}
+
+# Test: c_variable-5.37
+# Desc: children of psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.37 {children of psnp->ptrs[0]->next->char_ptr} {
+  get_children psnp->ptrs.0.next.char_ptr
+} {*char_ptr}
+
+# Test: c_variable-5.38
+# Desc: number of children of psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.38 {number of children of psnp->ptrs[0]->next->char_ptr} {
+  $var(psnp->ptrs.0.next.char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.39
+# Desc: children of *psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.39 {children of *psnp->ptrs[0]->next->char_ptr} {
+  get_children psnp->ptrs.0.next.char_ptr.*char_ptr
+} {**char_ptr}
+
+# Test: c_variable-5.40
+# Desc: number of children of *psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.40 {number of children of *psnp->ptrs[0]->next->char_ptr} {
+  $var(psnp->ptrs.0.next.char_ptr.*char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.41
+# Desc: children of **psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.41 {children of **psnp->ptrs[0]->next->char_ptr} {
+  get_children psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr
+} {***char_ptr}
+
+# Test: c_variable-5.42
+# Desc: number of children of **psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.42 {number of children of **psnp->ptrs[0]->next->char_ptr} {
+  $var(psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.43
+# Desc: children of ***psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.43 {children of ***psnp->ptrs[0]->next->char_ptr} {
+  get_children psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr
+} {****char_ptr}
+
+# Test: c_variable-5.44
+# Desc: number of children of ***psnp->ptrs[0]->next->char_ptr
+gdbtk_test c_variable-5.44 {number of children of ***psnp->ptrs[0]->next->char_ptr} {
+  $var(psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr) numChildren
+} {1}
+
+# Test: c_variable-5.45
+# Desc: children of psnp->ptrs[0]->next->next
+gdbtk_test c_variable-5.45 {children of psnp->ptrs[0]->next->next} {
+  get_children psnp->ptrs.0.next.next
+} {char_ptr long_ptr ptrs next}
+
+# Test: c_variable-5.46
+# Desc: children of psnp->ptrs[0]->next->next->ptrs
+gdbtk_test c_variable-5.46 {children of psnp->ptrs[0]->next->next->ptrs} {
+  get_children psnp->ptrs.0.next.next.ptrs
+} {0 1 2}
+
+#  Step over "snp0.char_ptr = &b3;"
+gdb_cmd "step"
+
+# Test: c_variable-5.47
+# Desc: check that psnp->char_ptr (and [0].char_ptr) changed
+gdbtk_test c_variable-5.47 {check that psnp->char_ptr (and [0].char_ptr) changed} {
+  check_update
+} {{psnp->ptrs.0.char_ptr {psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr}} {psnp->ptrs.0.next psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.next.ptrs psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->ptrs.0.ptrs psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr}}
+
+#  Step over "snp1.char_ptr = &c3;"
+gdb_cmd "step"
+
+# Test: c_variable-5.48
+# Desc: check that psnp->next->char_ptr (and [1].char_ptr) changed
+gdbtk_test c_variable-5.48 {check that psnp->next->char_ptr (and [1].char_ptr) changed} {
+  check_update
+} {{{psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr}} {psnp->ptrs.0.next psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.next.ptrs psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->ptrs.0.ptrs psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr}}
+
+#  Step over "snp2.char_ptr = &a3;"
+gdb_cmd "step"
+
+# Test: c_variable-5.49
+# Desc: check that psnp->next->next->char_ptr (and [2].char_ptr) changed
+gdbtk_test c_variable-5.49 {heck that psnp->next->next->char_ptr (and [2].char_ptr) changed} {
+  check_update
+} {psnp->ptrs.0.next.next.char_ptr {psnp->ptrs.0.next psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.next.ptrs psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->ptrs.0.ptrs psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr}}
+
+#  Step over "snp0.long_ptr = &y3;"
+gdb_cmd "step"
+
+# Test: c_variable-5.50
+# Desc: check that psnp->long_ptr (and [0].long_ptr) changed
+gdbtk_test c_variable-5.50 {check that psnp->long_ptr (and [0].long_ptr) changed} {
+  check_update
+} {{psnp->ptrs.0.long_ptr {psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr}} {psnp->ptrs.0.next psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.next.ptrs psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->ptrs.0.ptrs psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr}}
+
+#  Step over "snp1.long_ptr = &x3;"
+gdb_cmd "step"
+
+# Test: c_variable-5.51
+# Desc: check that psnp->next->long_ptr (and [1].long_ptr) changed
+gdbtk_test c_variable-5.51 {check that psnp->next->long_ptr (and [1].long_ptr) changed} {
+  check_update
+} {psnp->ptrs.0.next.long_ptr {psnp->ptrs.0.next psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.next.ptrs psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->ptrs.0.ptrs psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr}}
+
+#  Step over "snp2.long_ptr = &z3;"
+gdb_cmd "step"
+
+# Test: c_variable-5.52
+# Desc: check that psnp->next->next->long_ptr (and [2].long_ptr) changed
+gdbtk_test c_variable-5.52 {check that psnp->next->next->long_ptr (and [2].long_ptr) changed} {
+  check_update
+} {psnp->ptrs.0.next.next.long_ptr {psnp->ptrs.0.next psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.next.ptrs psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->ptrs.0.ptrs psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr}}
+
+# Test: c_variable-5.53
+# Desc: names of editable variables
+gdbtk_test c_variable-5.53 {names of editable variables} {
+  editable_variables
+} {{psnp->ptrs.0.next psnp->ptrs.0.next.next psnp->ptrs.0.next.next.char_ptr psnp->ptrs.0.next.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr.****psnp->char_ptr psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr psnp->ptrs.0.next.char_ptr psnp->ptrs.0.next.long_ptr psnp->ptrs.0.next.char_ptr.*char_ptr psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr.****psnp->long_ptr psnp->ptrs.0.next.next.next psnp->char_ptr.*psnp->char_ptr.**psnp->char_ptr.***psnp->char_ptr psnp->char_ptr.*psnp->char_ptr psnp->ptrs.0.next.next.ptrs.0 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr.***psnp->long_ptr psnp->long_ptr.*psnp->long_ptr psnp->ptrs.0.next.next.ptrs.1 psnp->ptrs.0.next.next.ptrs.2 psnp->ptrs.0.char_ptr psnp->ptrs.0.long_ptr psnp->char_ptr psnp->ptrs.0.next.char_ptr.*char_ptr.**char_ptr.***char_ptr.****char_ptr psnp->long_ptr psnp->ptrs.0 psnp->ptrs.1 psnp->ptrs.2 psnp->long_ptr.*psnp->long_ptr.**psnp->long_ptr} {psnp->ptrs.0.next.ptrs psnp->ptrs.0.next.next.ptrs psnp->ptrs psnp->ptrs.0.ptrs}}
+
+#####       #####
+#               #
+# Display tests #
+#               #
+#####       #####
+
+delete_all_variables
+
+# Test: c_variable-6.1
+# Desc: create variable bar
+gdbtk_test c_variable-6.1 {create variable bar} {
+  create_variable bar
+} {0}
+
+# Test: c_variable-6.2
+# Desc: type of variable bar
+gdbtk_test c_variable-6.2 {type of variable bar} {
+  $var(bar) type
+} {int}
+
+# Test: c_variable-6.3
+# Desc: format of variable bar
+gdbtk_test c_variable-6.3 {format of variable bar} {
+  $var(bar) format
+} {natural}
+
+# Test: c_variable-6.4
+# Desc: value of variable bar
+gdbtk_test c_variable-6.4 {value of variable bar} {
+  value bar d
+} {ok}
+
+# Test: c_variable-6.5
+# Desc: change format of bar to hex
+gdbtk_test c_variable-6.5 {change format of bar to hex} {
+  $var(bar) format hex
+  $var(bar) format
+} {hexadecimal}
+
+# Test: c_variable-6.6
+# Desc: value of bar with new format
+gdbtk_test c_variable-6.6 {value of bar with new format} {
+  value bar x
+} {ok}
+
+# Test: c_variable-6.7
+# Desc: change value of bar
+gdbtk_test c_variable-6.7 {change value of bar} {
+  $var(bar) value 3
+  value bar x
+} {ok}
+
+# Test: c_variable-6.8
+# Desc: check new value of bar
+gdbtk_test c_variable-6.8 {change value of bar} {
+  $var(bar) format decimal
+  $var(bar) value
+} {3}
+
+delete_variable bar
+
+# Test: c_variable-6.11
+# Desc: create variable foo
+gdbtk_test c_variable-6.11 {create variable foo} {
+  create_variable foo
+} {0}
+
+# Test: c_variable-6.12
+# Desc: type of variable foo
+gdbtk_test c_variable-6.12 {type of variable foo} {
+  $var(foo) type
+} {int *}
+
+# Test: c_variable-6.13
+# Desc: format of variable foo
+gdbtk_test c_variable-6.13 {format of variable foo} {
+  $var(foo) format
+} {natural}
+
+# Test: c_variable-6.14
+# Desc: value of variable foo
+gdbtk_test c_variable-6.14 {value of variable foo} {
+  value foo x
+} {ok}
+
+# Test: c_variable-6.15
+# Desc: change format of var to octal
+gdbtk_test c_variable-6.15 {change format of foo to octal} {
+  $var(foo) format octal
+  $var(foo) format
+} {octal}
+
+# Test: c_variable-6.16
+# Desc: value of foo with new format
+gdbtk_test c_variable-6.16 {value of foo with new format} {
+  value foo o
+} {ok}
+
+# Test: c_variable-6.17
+# Desc: change value of foo
+gdbtk_test c_variable-6.17 {change value of foo} {
+  $var(foo) value 3
+  value foo o
+} {ok}
+
+# Test: c_variable-6.18
+# Desc: check new value of foo
+gdbtk_test c_variable-6.18 {check new value of foo} {
+  $var(foo) format decimal
+  $var(foo) value
+} {3}
+
+delete_variable foo
+
+# Test: c_variable-6.21
+# Desc: create variable weird and children
+gdbtk_test c_variable-6.21 {create variable foo} {
+  if {![create_variable weird]} {
+    lsort [get_children weird]
+  }
+} {char_ptr character func_ptr func_ptr_ptr func_ptr_struct int_ptr_ptr integer long_array long_int s2 u1}
+
+# Test: c_variable-6.22
+# Desc: type of weird and children
+gdbtk_test c_variable-6.22 {type of weird and children} {
+  set types {}
+  foreach v [lsort [array names var]] {
+    lappend types [$var($v) type]
+  }
+
+  set types
+} {{weird_struct *} {char *} char {void (*)(void)} {struct _struct_decl *(*)(int, char *, long int)} {struct _struct_decl (*)(int, char *, long int)} {int **} int {long int [10]} {long int} struct union}
+
+# Test: c_variable-6.23
+# Desc: change format of weird.func_ptr and weird.func_ptr_ptr
+gdbtk_test c_variable-6.23 {change format of weird.func_ptr and weird.func_ptr_ptr} {
+  $var(weird.func_ptr) format hexadecimal
+  $var(weird.func_ptr_ptr) format hexadecimal
+  set result {}
+  lappend result [$var(weird.func_ptr) format]
+  lappend result [$var(weird.func_ptr_ptr) format]
+  set result
+} {hexadecimal hexadecimal}
+
+# Test: c_variable-6.24
+# Desc: format of weird and children
+gdbtk_test c_variable-6.24 {format of weird and children} {
+  set formats {}
+  foreach v [lsort [array names var]] {
+    lappend formats [$var($v) format]
+  }
+
+  set formats
+} {natural natural natural hexadecimal hexadecimal natural natural natural natural natural natural natural}
+
+# Test: c_variable-6.25
+# Desc: value of weird and children
+gdbtk_test c_variable-6.25 {value of weird and children} {
+  set values {}
+  foreach v [lsort [array names var]] f [list x "" "" x x x x d d d d d] {
+    lappend values [value $v $f]
+  }
+
+  set values
+} {ok ok ok ok ok ok ok ok weird.long_array ok weird.s2 weird.u1}
+
+# Test: c_variable-6.26
+# Desc: change format of weird and children to octal
+gdbtk_test c_variable-6.26 {change format of weird and children to octal} {
+  set formats {}
+  foreach v [lsort [array names var]] {
+    $var($v) format octal
+    lappend formats [$var($v) format]
+  }
+
+  set formats
+} {octal octal octal octal octal octal octal octal octal octal octal octal}
+
+# Test: c_variable-6.27
+# Desc: value of weird and children with new format
+gdbtk_test c_variable-6.27 {value of foo with new format} {
+  set values {}
+  foreach v [lsort [array names var]] {
+    lappend values [value $v o]
+  }
+
+  set values
+} {ok ok ok ok ok ok ok ok weird.long_array ok weird.s2 weird.u1}
+
+# Test: c_variable-6.30
+# Desc: create more children of weird
+gdbtk_test c_variable-6.30 {create more children of weird} {
+  foreach v [array names var] {
+    get_children $v
+  }
+
+  # Do it twice to get more children
+  foreach v [array names var] {
+    get_children $v
+  }
+
+  lsort [array names var]
+} {weird weird.char_ptr weird.char_ptr.*char_ptr weird.character weird.func_ptr weird.func_ptr_ptr weird.func_ptr_struct weird.int_ptr_ptr weird.int_ptr_ptr.*int_ptr_ptr weird.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr weird.integer weird.long_array weird.long_array.0 weird.long_array.1 weird.long_array.2 weird.long_array.3 weird.long_array.4 weird.long_array.5 weird.long_array.6 weird.long_array.7 weird.long_array.8 weird.long_array.9 weird.long_int weird.s2 weird.s2.g weird.s2.h weird.s2.i weird.s2.i.0 weird.s2.i.1 weird.s2.i.2 weird.s2.i.3 weird.s2.i.4 weird.s2.i.5 weird.s2.i.6 weird.s2.i.7 weird.s2.i.8 weird.s2.i.9 weird.s2.u2 weird.s2.u2.f weird.s2.u2.u1s1 weird.s2.u2.u1s2 weird.u1 weird.u1.a weird.u1.b weird.u1.b.*b weird.u1.c weird.u1.d}
+
+# Test: c_variable-6.31
+# Desc: check that all children of weird change
+#       Ok, obviously things like weird.s2 and weird.u1 will not change!
+gdbtk_test c_variable-6.31 {check that all children of weird change (ops, we are now reporting array names as changed in this case - seems harmless though)} {
+  $var(weird) value 0x2121
+  check_update
+} {{{weird weird.integer weird.character weird.char_ptr weird.char_ptr.*char_ptr weird.long_int weird.int_ptr_ptr weird.int_ptr_ptr.*int_ptr_ptr weird.long_array.0 weird.long_array.1 weird.long_array.2 weird.long_array.3 weird.long_array.4 weird.long_array.5 weird.long_array.6 weird.long_array.7 weird.long_array.8 weird.long_array.9 weird.func_ptr weird.func_ptr_struct weird.func_ptr_ptr weird.u1.a weird.u1.b weird.u1.c weird.u1.d weird.s2.u2.f weird.s2.g weird.s2.h weird.s2.i.0 weird.s2.i.1 weird.s2.i.2 weird.s2.i.3 weird.s2.i.4 weird.s2.i.5 weird.s2.i.6 weird.s2.i.7 weird.s2.i.8 weird.s2.i.9}} {weird.char_ptr weird.s2.u2.f weird.int_ptr_ptr.*int_ptr_ptr.**int_ptr_ptr weird.s2.g weird.s2.h weird.s2.i weird.func_ptr_ptr weird.func_ptr weird.s2.u2 weird.int_ptr_ptr weird.long_int weird.character weird.s2.u2.u1s1 weird.s2.u2.u1s2 weird.long_array.0 weird.u1.a weird.long_array.1 weird.s2 weird.func_ptr_struct weird.u1.b weird.long_array.2 weird.long_array weird.u1.c weird.long_array.3 weird.u1.d weird.long_array.4 weird.long_array.5 weird.s2.i.0 weird.long_array.6 weird.s2.i.1 weird.long_array.7 weird.s2.i.2 weird.long_array.8 weird.s2.i.3 weird.long_array.9 weird.s2.i.4 weird.integer weird.s2.i.5 weird.s2.i.6 weird.s2.i.7 weird.s2.i.8 weird.int_ptr_ptr.*int_ptr_ptr weird.s2.i.9 weird.char_ptr.*char_ptr weird.u1 weird.u1.b.*b}}
+
+delete_variable weird
+
+#####               #####
+#                       #
+# Special Display Tests #
+#                       #
+#####               #####
+
+# Stop in "do_special_tests"
+gdb_cmd "break do_special_tests"
+gdb_cmd "continue"
+
+# Test: c_variable-7.1
+# Desc: stop in do_special_tests
+gdbtk_test c_variable-7.1 {stop in do_special_tests} {
+  lindex [gdb_loc] 1
+} {do_special_tests}
+
+# Test: c_variable-7.10
+# Desc: create union u
+gdbtk_test c_variable-7.10 {create union u} {
+  create_variable u
+} {0}
+
+# Test: c_variable-7.11
+# Desc: value of u
+gdbtk_test c_variable-7.11 {value of u} {
+  $var(u) value
+} {{...}}
+
+# Test: c_variable-7.12
+# Desc: type of u
+gdbtk_test c_variable-7.12 {type of u} {
+  $var(u) type
+} {union named_union}
+
+# Test: c_variable-7.13
+# Desc: is u editable
+gdbtk_test c_variable-7.13 {is u editable} {
+  $var(u) editable
+} {0}
+
+# Test: c_variable-7.14
+# Desc: number of children of u
+gdbtk_test c_variable-7.14 {number of children of u} {
+  $var(u) numChildren
+} {2}
+
+# Test: c_variable-7.15
+# Desc: children of u
+gdbtk_test c_variable-7.15 {children of u} {
+  get_children u
+} {integer char_ptr}
+
+# Test: c_variable-7.20
+# Desc: create anonu
+gdbtk_test c_variable-7.20 {create anonu} {
+  create_variable anonu
+} {0}
+
+# Test: c_variable-7.21
+# Desc: value of anonu
+gdbtk_test c_variable-7.21 {value of anonu} {
+  $var(anonu) value
+} {{...}}
+
+# Test: c_variable-7.22
+# Desc: type of anonu
+gdbtk_test c_variable-7.22 {type of anonu} {
+  $var(anonu) type
+} {union}
+
+# Test: c_variable-7.23
+# Desc: is anonu editable
+gdbtk_test c_variable-7.23 {is anonu editable} {
+  $var(anonu) editable
+} {0}
+
+# Test: c_variable-7.24
+# Desc: number of children of anonu
+gdbtk_test c_variable-7.24 {number of children of anonu} {
+  $var(anonu) numChildren
+} {3}
+
+# Test: c_variable-7.25
+# Desc: children of anonu
+gdbtk_test c_variable-7.25 {children of anonu} {
+  get_children anonu
+} {a b c}
+
+# Test: c_variable-7.30
+# Desc: create struct s
+gdbtk_test c_variable-7.30 {create struct s} {
+  create_variable s
+} {0}
+
+# Test: c_variable-7.31
+# Desc: value of s
+gdbtk_test c_variable-7.31 {value of s} {
+  $var(s) value
+} {{...}}
+
+# Test: c_variable-7.32
+# Desc: type of s
+gdbtk_test c_variable-7.32 {type of s} {
+  $var(s) type
+} {struct _simple_struct}
+
+# Test: c_variable-7.33
+# Desc: is s editable
+gdbtk_test c_variable-7.33 {is s editable} {
+  $var(s) editable
+} {0}
+
+# Test: c_variable-7.34
+# Desc: number of children of s
+gdbtk_test c_variable-7.34 {number of children of s} {
+  $var(s) numChildren
+} {6}
+
+# Test: c_variable-7.35
+# Desc: children of s
+gdbtk_test c_variable-7.35 {children of s} {
+  get_children s
+} {integer unsigned_integer character signed_character char_ptr array_of_10}
+
+# Test: c_variable-7.40
+# Desc: create anons
+gdbtk_test c_variable-7.40 {create anons} {
+  create_variable anons
+} {0}
+
+# Test: c_variable-7.41
+# Desc: value of anons
+gdbtk_test c_variable-7.41 {value of anons} {
+  $var(anons) value
+} {{...}}
+
+# Test: c_variable-7.42
+# Desc: type of anons
+gdbtk_test c_variable-7.42 {type of anons} {
+  $var(anons) type
+} {struct}
+
+# Test: c_variable-7.43
+# Desc: is anons editable
+gdbtk_test c_variable-7.43 {is anons editable} {
+  $var(anons) editable
+} {0}
+
+# Test: c_variable-7.44
+# Desc: number of children of anons
+gdbtk_test c_variable-7.44 {number of children of anons} {
+  $var(anons) numChildren
+} {3}
+
+# Test: c_variable-7.45
+# Desc: children of anons
+gdbtk_test c_variable-7.45 {children of anons} {
+  get_children anons
+} {a b c}
+
+# Test: c_variable-7.50
+# Desc: create enum e
+gdbtk_test c_variable-7.50 {create enum e} {
+  create_variable e
+} {0}
+
+# Test: c_variable-7.51
+# Desc: value of e
+gdbtk_test c_variable-7.51 {value of e} {
+  $var(e) value bar
+  $var(e) value
+} {bar}
+
+# Test: c_variable-7.52
+# Desc: type of e
+gdbtk_test c_variable-7.52 {type of e} {
+  $var(e) type
+} {enum foo}
+
+# Test: c_variable-7.53
+# Desc: is e editable
+gdbtk_test c_variable-7.53 {is e editable} {
+  $var(e) editable
+} {1}
+
+# Test: c_variable-7.54
+# Desc: number of children of e
+gdbtk_test c_variable-7.54 {number of children of e} {
+  $var(e) numChildren
+} {0}
+
+# Test: c_variable-7.55
+# Desc: children of e
+gdbtk_test c_variable-7.55 {children of e} {
+  get_children e
+} {}
+
+# Test: c_variable-7.60
+# Desc: create anone
+gdbtk_test c_variable-7.60 {create anone} {
+  create_variable anone
+} {0}
+
+# Test: c_variable-7.61
+# Desc: value of anone
+gdbtk_test c_variable-7.61 {value of e} {
+  $var(e) value bar
+  $var(e) value
+} {bar}
+
+# Test: c_variable-7.62
+# Desc: type of e
+gdbtk_test c_variable-7.62 {type of e} {
+  $var(e) type
+} {enum foo}
+
+# Test: c_variable-7.63
+# Desc: is e editable
+gdbtk_test c_variable-7.63 {is e editable} {
+  $var(e) editable
+} {1}
+
+# Test: c_variable-7.64
+# Desc: number of children of e
+gdbtk_test c_variable-7.64 {number of children of e} {
+  $var(e) numChildren
+} {0}
+
+# Test: c_variable-7.65
+# Desc: children of e
+gdbtk_test c_variable-7.65 {children of e} {
+  get_children e
+} {}
+
+# Test: c_variable-7.70
+# Desc: create anone
+gdbtk_test c_variable-7.70 {try to create anone again (duplicate obj name} {
+  create_variable anone
+} {1}
+
+# Test: c_variable-7.71
+# Desc: value of anone
+gdbtk_test c_variable-7.71 {value of anone} {
+  $var(anone) value A
+  $var(anone) value
+} {A}
+
+# Test: c_variable-7.72
+# Desc: type of anone
+gdbtk_test c_variable-7.72 {type of anone} {
+  $var(anone) type
+} {enum}
+
+# Test: c_variable-7.73
+# Desc: is anone editable
+gdbtk_test c_variable-7.73 {is anone editable} {
+  $var(anone) editable
+} {1}
+
+# Test: c_variable-7.74
+# Desc: number of children of anone
+gdbtk_test c_variable-7.74 {number of children of anone} {
+  $var(anone) numChildren
+} {0}
+
+# Test: c_variable-7.75
+# Desc: children of anone
+gdbtk_test c_variable-7.75 {children of anone} {
+  get_children anone
+} {}
+
+# Record fp
+set fp [gdb_cmd "output/x \$fp"]
+gdb_cmd {break incr_a}
+gdb_cmd {continue}
+
+# Test: c_variable-7.80
+# Desc: stop in incr_a
+gdbtk_test c_variable-7.80 {stop in incr_a} {
+  lindex [gdb_loc] 1
+} {incr_a}
+
+# Test: c_variable-7.81
+# Desc: Create variables in different scopes
+gdbtk_test c_variable-7.81 {create variables in different scopes} {
+  set a1 [gdb_variable create -expr a]
+  set a2 [gdb_variable create -expr a -frame $fp]
+
+  set vals {}
+  lappend vals [$a1 value]
+  lappend vals [$a2 value]
+  set vals
+} {2 1}
+
+#  Exit
+#
+gdbtk_test_done
+
+#Local Variables:
+#mode: tcl
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/defs stsgdb-6.8/gdb/testsuite/gdb.gdbtk/defs
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/defs	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/defs	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,306 @@
+# This file contains support code for the gdbtk test suite.
+# Copyright 2001 Red Hat, Inc.
+#
+# Based on the Tcl testsuite support code, portions of this file
+# are Copyright (c) 1990-1994 The Regents of the University of California and
+# Copyright (c) 1994-1996 Sun Microsystems, Inc.
+#
+global _test env srcdir objdir
+
+if {![info exists srcdir]} {
+  if {[info exists env(SRCDIR)]} {
+    set srcdir $env(SRCDIR)
+  } else {
+    set srcdir .
+  }
+}
+
+if {![info exists objdir]} {
+  if {[info exists env(OBJDIR)]} {
+    set objdir $env(OBJDIR)
+  } elseif {$_test(interactive)} {
+    # If running interactively, assume that the objdir is
+    # relative to the executable's location
+    set objdir [file join [file dirname [info nameofexecutable]] testsuite gdb.gdbtk]
+  } else {
+    set objdir .
+  }
+}
+
+if {![info exists _test(verbose)]} {
+  if {[info exists env(GDBTK_VERBOSE)]} {
+    set _test(verbose) $env(GDBTK_VERBOSE)
+  } else {
+    set _test(verbose) 0
+  }
+}
+if {![info exists _test(tests)]} {
+
+  if {[info exists env(GDBTK_TESTS)]} {
+    set _test(tests) $env(GDBTK_TESTS)
+  } else {
+    set _test(tests) {}
+  }
+}
+
+if {[info exists env(GDBTK_LOGFILE)]} {
+  set _test(logfile) [open $env(GDBTK_LOGFILE) a+]
+  fconfigure $_test(logfile) -buffering none
+} else {
+  set _test(logfile) {}
+}
+
+# Informs gdbtk internals that testsuite is running. An example
+# where this is needed is the window manager, which must place
+# all windows at some place on the screen so that the system's
+# window manager does not interfere. This is reset in gdbtk_test_done.
+set env(GDBTK_TEST_RUNNING) 1
+
+# The gdb "file" command to use for gdbtk testing
+# NOTE: This proc appends ".exe" to all windows' programs
+proc gdbtk_test_file {filename} {
+  global tcl_platform
+
+  if {$tcl_platform(platform) == "windows"} {
+    append filename ".exe"
+  }
+
+  set err [catch {gdb_cmd "file $filename" 1} text]
+  if {$err} {
+    error $text
+  }
+
+  return $text
+}
+
+proc gdbtk_test_run {{prog_args {}}} {
+  global env
+
+  # Get the target_info array from the testsuite
+  array set target_info $env(TARGET_INFO)
+
+  # We get the target ready by:
+  # 1. Run all init commands
+  # 2. Issue target command
+  # 3. Issue load command
+  # 4. Issue run command
+  foreach cmd $target_info(init) {
+    set err [catch {gdb_cmd $cmd 0} txt]
+    if {$err} {
+      _report_error "Target initialization command \"$cmd\" failed: $txt"
+      return 0
+    }
+  }
+
+  if {$target_info(target) != ""} {
+    set err [catch {gdb_cmd $target_info(target) 0} txt]
+    if {$err} {
+      _report_error "Failed to connect to target: $txt"
+      return 0
+    }
+  }
+
+  if {$target_info(load) != ""} {
+    set err [catch {gdb_cmd $target_info(load) 0} txt]
+    if {$err} {
+      _report_error "Failed to load: $txt"
+      return 0
+    }
+  }
+
+  if {$target_info(run) != ""} {
+    set err [catch {gdb_cmd $target_info(run) 0} txt]
+    if {$err} {
+      _report_error "Could not run target with \"$target_info(run)\": $txt"
+      return 0
+    }
+  }
+
+  return 1
+}
+
+proc _report_error {msg} {
+  global _test
+
+  if {[info exists _test(interactive)] && $_test(interactive)} {
+    # Dialog
+    tk_messageBox -message $msg -icon error -type ok
+  } else {
+    # to stderr
+    puts stderr $msg
+  }
+}
+
+proc gdbtk_print_verbose {status name description script code answer} {
+  global _test
+
+  switch $code {
+    0 {
+      set code_words {}
+    }
+    1 {
+      set code_words "Test generated error: $answer"
+    }
+
+    2 {
+      set code_words "Test generated return exception;  result was: $answer"
+    }
+
+    3 {
+      set code_words "Test generated break exception"
+    }
+
+    4 {
+      set code_words "Test generated continue exception"
+    }
+
+    5 {
+      set code_words "Test generated exception $code;  message was:$answer"
+    }
+  }
+
+  if {$_test(verbose) > 1 \
+	|| ($_test(verbose) != 1 && ($status == "ERROR" || $status == "FAIL"))} {
+    # Printed when user verbose mode (verbose > 1) or an error/failure occurs
+    # not running the testsuite (dejagnu)
+    puts stdout "\n"
+    puts stdout "==== $name $description"
+    puts stdout "==== Contents of test case:"
+    puts stdout "$script"
+    if {$code_words != ""} {
+      puts stdout $code_words
+    }
+    puts stdout "==== Result was:"
+    puts stdout "$answer"
+  } elseif {$_test(verbose)} {
+    # Printed for the testsuite (verbose = 1)
+    puts stdout "[list $status $name $description $code_words]"
+
+    if {$_test(logfile) != ""} {
+      puts $_test(logfile) "\n"
+      puts $_test(logfile) "==== $name $description"
+      puts $_test(logfile) "==== Contents of test case:"
+      puts $_test(logfile) "$script"
+      if {$code_words != ""} {
+	puts $_test(logfile) $code_words
+      }
+      puts $_test(logfile) "==== Result was:"
+      puts $_test(logfile) "$answer"
+    }
+  }
+}
+
+# gdbtk_test
+#
+# This procedure runs a test and prints an error message if the
+# test fails.
+#
+# Arguments:
+# name -		Name of test, in the form foo-1.2.
+# description -		Short textual description of the test, to
+#			help humans understand what it does.
+# script -		Script to run to carry out the test.  It must
+#			return a result that can be checked for
+#			correctness.
+# answer -		Expected result from script.
+
+proc gdbtk_test {name description script answer} {
+  global _test test_ran
+
+  set test_ran 0
+  if {[string compare $_test(tests) ""] != 0} then {
+    set ok 0
+    foreach test $_test(tests) {
+      if [string match $test $name] then {
+	set ok 1
+	break
+      }
+    }
+    if !$ok then return
+  }
+
+  set code [catch {uplevel $script} result]
+  set test_ran 1
+  if {$code != 0} {
+    # Error
+    gdbtk_print_verbose ERROR $name $description $script \
+      $code $result
+  } elseif {[string compare $result $answer] == 0} { 
+    if {[string index $name 0] == "*"} {
+      # XPASS
+      set HOW XPASS
+    } else {
+      set HOW PASS
+    }
+
+    if {$_test(verbose)} {
+      gdbtk_print_verbose $HOW $name $description $script \
+	$code $result
+      if {$_test(verbose) != 1} {
+	puts stdout "++++ $name ${HOW}ED"
+      }
+    }
+    if {$_test(logfile) != ""} {
+      puts $_test(logfile) "++++ $name ${HOW}ED"
+    }
+  } else {
+    if {[string index $name 0] == "*"} {
+      # XFAIL
+      set HOW XFAIL
+    } else {
+      set HOW FAIL
+    }
+
+    gdbtk_print_verbose $HOW $name $description $script \
+      $code $result
+    if {$_test(verbose) != 1} {
+      puts stdout "---- Result should have been:"
+      puts stdout "$answer"
+      puts stdout "---- $name ${HOW}ED" 
+    }
+    if {$_test(logfile) != ""} {
+      puts $_test(logfile) "---- Result should have been:"
+      puts $_test(logfile) "$answer"
+      puts $_test(logfile) "---- $name ${HOW}ED" 
+    }
+  }
+}
+
+proc gdbtk_dotests {file args} {
+  global _test
+  set savedTests $_test(tests)
+  set _test(tests) $args
+  source $file
+  set _test(tests) $savedTests
+}
+
+proc gdbtk_test_done {} {
+  global _test env
+
+  if {$_test(logfile) != ""} {
+    close $_test(logfile)
+  }
+
+  set env(GDBTK_TEST_RUNNING) 0
+  if {![info exists _test(interactive)] || !$_test(interactive)} {
+    gdbtk_force_quit
+  }
+}
+
+proc gdbtk_test_error {desc} {
+  set desc [join [split $desc \n] |]
+  puts "ERROR \{$desc\} \{\} \{\}"
+  gdbtk_test_done
+}
+
+# Override the warning dialog. We don't want to see them.
+rename show_warning real_show_warning
+proc show_warning {msg} {
+  global _test
+
+  set str "INSIGHT TESTSUITE WARNING: $msg"
+  puts stdout $str
+  if {$_test(logfile) != ""} {
+    puts $_test(logfile) $str
+  }
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/insight-support.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/insight-support.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/insight-support.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/insight-support.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,321 @@
+# GDB Testsuite Support for Insight.
+#
+# Copyright 2001, 2004 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# Initializes the display for gdbtk testing.
+# Returns 1 if tests should run, 0 otherwise.
+proc gdbtk_initialize_display {} {
+  global _using_windows
+
+  # This is hacky, but, we don't have much choice. When running
+  # expect under Windows, tcl_platform(platform) is "unix".
+  if {![info exists _using_windows]} {
+    set _using_windows [expr {![catch {exec cygpath --help}]}]
+  }
+
+  if {![_gdbtk_xvfb_init]} {
+    if {$_using_windows} {
+      untested "No GDB_DISPLAY -- skipping tests"
+    } else {
+      untested "No GDB_DISPLAY or Xvfb -- skipping tests"
+    }
+
+    return 0
+  }
+
+  return 1
+}
+
+# From dejagnu:
+# srcdir = testsuite src dir (e.g., devo/gdb/testsuite)
+# objdir = testsuite obj dir (e.g., gdb/testsuite)
+# subdir = subdir of testsuite (e.g., gdb.gdbtk)
+#
+# To gdbtk:
+# env(DEFS)=the "defs" files (e.g., devo/gdb/testsuite/gdb.gdbtk/defs)
+# env(SRCDIR)=directory containing the test code (e.g., *.test)
+# env(OBJDIR)=directory which contains any executables
+#            (e.g., gdb/testsuite/gdb.gdbtk)
+proc gdbtk_start {test} {
+  global verbose
+  global GDB
+  global GDBFLAGS
+  global env srcdir subdir objdir
+
+  gdb_stop_suppressing_tests;
+
+  # Need to convert ::GDB to use (-)?insight...
+  if {[regsub {gdb$} $GDB insight newGDB]} {
+    set INSIGHT $newGDB
+  } else {
+    perror "Cannot find Insight executable"
+    return "ERROR gdbtk_start"
+  }
+
+  verbose "Starting $INSIGHT -nx -q --tclcommand=$test"
+
+  set real_test [which $test]
+  if {$real_test == 0} {
+    perror "$test is not found"
+    return "ERROR gdbtk_start"
+  }
+
+  if {![is_remote host]} {
+    if { [which $INSIGHT] == 0 } {
+      perror "$INSIGHT does not exist."
+      return "ERROR gdbtk_start"
+    }
+  }
+
+  set wd [pwd]
+
+  # Find absolute path to test
+  set test [to_tcl_path -abs $test]
+
+  # Set some environment variables
+  cd $srcdir
+  set abs_srcdir [pwd]
+  set env(DEFS) [to_tcl_path -abs [file join $abs_srcdir $subdir defs]]
+
+  cd $wd
+  cd [file join $objdir $subdir]
+  set env(OBJDIR) [pwd]
+  cd $wd
+
+  # Set info about target into env
+  _gdbtk_export_target_info
+
+  set env(SRCDIR) $abs_srcdir
+  set env(GDBTK_VERBOSE) 1
+  set env(GDBTK_LOGFILE) [to_tcl_path [file join $objdir gdb.log]]
+  if {[info exists env(TCL_LIBRARY)]} {
+    unset -nocomplain env(TCL_LIBRARY)
+  }
+
+  set err [catch {exec $INSIGHT -nx -q --tclcommand=$test} res]
+  if { $err } {
+    perror "Execing $INSIGHT failed: $res"
+    append res "\nERROR gdb-crash"
+  }
+  return $res
+}
+
+# Start xvfb when using it.
+# The precedence is:
+#   1. If GDB_DISPLAY is set (and not ""), use it
+#   2. If Xvfb exists, use it (not on cygwin)
+#   3. Skip tests
+proc _gdbtk_xvfb_init {} {
+  global env spawn_id _xvfb_spawn_id _using_windows
+
+  if {[info exists env(GDB_DISPLAY)]} {
+    if {$env(GDB_DISPLAY) != ""} {
+      set env(DISPLAY) $env(GDB_DISPLAY)
+    } else {
+      # Suppress tests
+      return 0
+    }
+  } elseif {!$_using_windows && [which Xvfb] != 0} {
+    set screen ":[getpid]"
+    set pid [spawn  Xvfb $screen -ac]
+    set _xvfb_spawn_id $spawn_id
+    set env(DISPLAY) localhost$screen
+  } else {
+    # No Xvfb found -- skip test
+    return 0
+  }
+
+  return 1
+}
+
+# Kill xvfb
+proc _gdbtk_xvfb_exit {} {
+  global objdir subdir env _xvfb_spawn_id
+
+  if {[info exists _xvfb_spawn_id]} {
+    exec kill [exp_pid -i $_xvfb_spawn_id]
+    wait -i $_xvfb_spawn_id
+  }
+}
+
+# help proc for setting tcl-style paths from unix-style paths
+# pass "-abs" to make it an absolute path
+proc to_tcl_path {unix_path {arg {}}} {
+  global _using_windows
+
+  if {[string compare $unix_path "-abs"] == 0} {
+    set unix_path $arg
+    set wd [pwd]
+    cd [file dirname $unix_path]
+    set dirname [pwd]
+    set unix_name [file join $dirname [file tail $unix_path]]
+    cd $wd
+  }
+
+  if {$_using_windows} {
+    set unix_path [exec cygpath -aw $unix_path]
+    set unix_path [join [split $unix_path \\] /]
+  }
+
+  return $unix_path
+}
+  
+# Set information about the target into the environment
+# variable TARGET_INFO. This array will contain a list
+# of commands that are necessary to run a target.
+#
+# This is mostly devined from how dejagnu works, what
+# procs are defined, and analyzing unix.exp, monitor.exp,
+# and sim.exp.
+#
+# Array elements exported:
+# Index   Meaning
+# -----   -------
+# init    list of target/board initialization commands
+# target  target command for target/board
+# load    load command for target/board
+# run     run command for target_board
+proc _gdbtk_export_target_info {} {
+  global env
+
+  # Figure out what "target class" the testsuite is using,
+  # i.e., sim, monitor, native
+  if {[string compare [info proc gdb_target_monitor] gdb_target_monitor] == 0} {
+    # Using a monitor/remote target
+    set target monitor
+  } elseif {[string compare [info proc gdb_target_sim] gdb_target_sim] == 0} {
+    # Using a simulator target
+    set target simulator
+  } elseif {[string compare [info proc gdb_target_sid] gdb_target_sid] == 0} {
+    # Using sid
+    set target sid
+  } else {
+    # Assume native
+    set target native
+  }
+
+  # Now setup the array to be exported.
+  set info(init) {}
+  set info(target) {}
+  set info(load) {}
+  set info(run) {}
+
+  switch $target {
+    simulator {
+      set opts "[target_info gdb,target_sim_options]"
+      set info(target) "target sim $opts"
+      set info(load) "load"
+      set info(run) "run"
+    }
+
+    monitor {
+      # Setup options for the connection
+      if {[target_info exists baud]} {
+	lappend info(init) "set remotebaud [target_info baud]"
+      }
+      if {[target_info exists binarydownload]} {
+	lappend info(init) "set remotebinarydownload [target_info binarydownload]"
+      }
+      if {[target_info exists disable_x_packet]} {
+	lappend info(init) "set remote X-packet disable"
+      }
+      if {[target_info exists disable_z_packet]} {
+	lappend info(init) "set remote Z-packet disable"
+      }
+
+      # Get target name and connection info
+      if {[target_info exists gdb_protocol]} {
+	set targetname "[target_info gdb_protocol]"
+      } else {
+	set targetname "not_specified"
+      }
+      if {[target_info exists gdb_serial]} {
+	set serialport "[target_info gdb_serial]"
+      } elseif {[target_info exists netport]} {
+	set serialport "[target_info netport]"
+      } else {
+	set serialport "[target_info serial]"
+      }
+
+      set info(target) "target $targetname $serialport"
+      set info(load) "load"
+      set info(run) "continue"
+    }
+
+    sid {
+      # We must start sid first, since Insight won't have a clue
+      # about how to do this.
+      sid_start
+      set info(target) "target [target_info gdb_protocol] [target_info netport]"
+      set info(load) "load"
+      set info(run) "continue"
+    }
+
+    native {
+      set info(run) "run"
+    }
+  }
+
+  # Export the array to the environment
+  set env(TARGET_INFO) [array get info]
+}
+
+# gdbtk tests call this function to print out the results of the
+# tests. The argument is a proper list of lists of the form:
+# {status name description msg}. All of these things typically
+# come from the testsuite harness.
+proc gdbtk_analyze_results {results} {
+  foreach test $results {
+    set status [lindex $test 0]
+    set name [lindex $test 1]
+    set description [lindex $test 2]
+    set msg [lindex $test 3]
+
+    switch $status {
+      PASS {
+	pass "$description ($name)"
+      }
+
+      FAIL {
+	fail "$description ($name)"
+      }
+
+      ERROR {
+	perror "$name"
+      }
+
+      XFAIL {
+	xfail "$description ($name)"
+      }
+
+      XPASS {
+	xpass "$description ($name)"
+      }
+    }
+  }
+}
+
+proc gdbtk_done {{results {}}} {
+  global _xvfb_spawn_id
+  gdbtk_analyze_results $results
+
+  # Kill off xvfb if using it
+  if {[info exists _xvfb_spawn_id]} {
+    _gdbtk_xvfb_exit
+  }
+
+  # Yich. If we're using sid, we must kill it
+  if {[string compare [info proc gdb_target_sid] gdb_target_sid] == 0} {
+    sid_exit
+  }
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/list0.c stsgdb-6.8/gdb/testsuite/gdb.gdbtk/list0.c
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/list0.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/list0.c	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,43 @@
+#include "list0.h"
+
+int main ()
+{
+    int x;
+#ifdef usestubs
+    set_debug_traps();
+    breakpoint();
+#endif
+    x = 0;
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    foo (x++);
+    return 0;
+}
+
+static void
+unused ()
+{
+    /* Not used for anything */
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/list0.h stsgdb-6.8/gdb/testsuite/gdb.gdbtk/list0.h
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/list0.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/list0.h	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,37 @@
+/* An include file that actually causes code to be generated in the including file.  This is known to cause problems on some systems. */
+#ifdef PROTOTYPES
+extern void bar(int);
+static void foo (int x)
+#else
+static void foo (x) int x;
+#endif
+{
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+    bar (x++);
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/list1.c stsgdb-6.8/gdb/testsuite/gdb.gdbtk/list1.c
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/list1.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/list1.c	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,39 @@
+#include <stdio.h>
+
+#ifdef PROTOTYPES
+void long_line (); int oof (int);
+void bar (int x)
+#else
+void bar (x) int x;
+#endif
+{
+    printf ("%d\n", x);
+
+    long_line ();
+}
+
+static void
+unused ()
+{
+    /* Not used for anything */
+}
+/* This routine has a very long line that will break searching in older versions of GDB.  */
+#ifdef PROTOTYPES
+void
+#endif
+long_line ()
+{
+  oof (67);
+
+  oof (6789);
+
+  oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*  5 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 10 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 15 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 20 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 25 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 30 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 35 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 40 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 45 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 50 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 55 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 60 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /* 65 */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (12); /*    */      oof (12);  oof (12);  oof (12);  oof (12);  oof (12);  oof (1234); /* 70 */
+}
+#ifdef PROTOTYPES
+int oof (int n)
+#else
+oof (n) int n;
+#endif
+{
+  return n + 1;
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/Makefile.in stsgdb-6.8/gdb/testsuite/gdb.gdbtk/Makefile.in
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/Makefile.in	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,36 @@
+VPATH = @srcdir@
+srcdir = @srcdir@
+
+EXEEXT = @EXEEXT@
+
+EXECUTABLES = simple$(EXEEXT) stack$(EXEEXT) c_variable$(EXEEXT) \
+		cpp_variable$(EXEEXT)
+
+# uuencoded format to avoid SCCS/RCS problems with binary files.
+CROSS_EXECUTABLES =
+
+all:
+	@echo "Nothing to be done for all..."
+
+info:
+install-info:
+dvi:
+install:
+uninstall: force
+installcheck:
+check:
+
+clean mostlyclean:
+	-rm -f *~ *.o a.out xgdb *.x $(CROSS_EXECUTABLES) *.ci *.tmp
+	-rm -f core core.coremaker coremaker.core corefile $(EXECUTABLES)
+	-rm -f twice-tmp.c
+
+distclean maintainer-clean realclean: clean
+	-rm -f *~ core
+	-rm -f Makefile config.status config.log
+	-rm -f arch.inc
+	-rm -f *-init.exp
+	-rm -fr *.log summary detail *.plog *.sum *.psum site.*
+
+Makefile : $(srcdir)/Makefile.in $(srcdir)/configure.ac
+	$(SHELL) ./config.status --recheck
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/README stsgdb-6.8/gdb/testsuite/gdb.gdbtk/README
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/README	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,421 @@
+			The Insight Testsuite
+			---------------------
+		   Keith Seitz (keiths@cygnus.com)
+			     May 1, 2001
+
+RUNNING THE TESTSUITE
+
+The Insight testsuite is run in much the same way that gdb's testsuites
+are run. The one big difference is the environment variable GDB_DISPLAY,
+which governs what display should be used for the tests.
+
+When GDB_DISPLAY is not set in the user's environment, the Insight testsuite
+will attempt to run Xvfb, an X server with a virtual frame buffer. Using
+Xvfb, the testsuite can run without interuppting the user.
+
+When Xvfb is not available, the testsuite will mark the Insight tests
+"untested" and print out some appropriate warning to the testsuite log
+file.
+
+If GDB_DISPLAY is set in the user's environment, the testsuite will attempt
+to use this display for the tests. If this display is a desktop display,
+it is very likely that any interaction between the user and his desktop
+will interfere with the tests. Some tests warp the cursor, i.e., they
+force the mouse to move on the screen. If you don't want this to happen to
+you, put Xvfb in your path.
+
+On Cygwin systems, Xvfb is not supported. Only two choices are available in
+this environment: run the testsuites using the desktop or do not run the
+testsuite. To run the testsuite on Cygwin, just define the environment
+variable GDB_DISPLAY to anything.
+
+The examples below summarize the usage of the environment variable GDB_DISPLAY
+on unix/X-Windows hosts and Cygwin hosts. In all examples, assume that DISPLAY
+set to the local workstation's main display (:0).
+
+To run the testsuite using Xvfb -- unix only (Xvfb must be in PATH):
+$ make check
+
+To run the testsuite using a given display (either the desktop or a peviously
+started Xvfb):
+$ GDB_DISPLAY=$DISPLAY make check
+
+To run the testsuite on Cygwin:
+$ GDB_DISPLAY=foo make check
+
+
+TESTSUITE INFRASTRUCTURE
+
+The rest of this document deals with writing tests for Insight. This reading
+is only noteworthy for developers and contributors.
+
+The Insight testsuite consists of two large portions of code: code which is
+run in dejagnu and code which runs in Insight's built-in Tcl interpreter. Files
+containing dejagnu code (those files ending in ".exp" in the testsuite directory)
+are "glue code" between gdb's dejagnu testsuite and Insight's Tcl testsuite.
+
+Dejagnu testsuite files are considered "drivers" for any particular set of
+tests, since they allow dejagnu to control Insight's Tcl testsuite.
+
+
+Dejagnu Testsuite Infrastructure
+
+The dejagnu code is responsible for doing several things. Some of the more
+important responsibilities include:
+
+o Initializing the display
+o Determining if tests should be run
+o Results accounting
+o Compiling testcases in various languages
+o Reporting results to gdb's testsuite
+
+There are various functions defined to facilitate the writing of tests. These
+functions currently reside in gdb's gdb.exp (src/gdb/testsuite/lib/gdb.exp) and
+include:
+
+Public functions:
+proc gdbtk_initialize_display {}
+
+  gdbtk_initialize_display should be the first function called from the
+  (dejagnu) test file. It initializes the DISPLAY variable on unix systems
+  and determines (for all host systems) whether or not the testsuite should
+  run. It returns 1 if the test should run. If tests should not run, it
+  marks the test as "untested" and leaves a suitable message about why
+  the test should not run. If gdbtk_initialize_display returns zero, a test
+  should simply exit.
+
+proc gdbtk_start {test}
+
+  This function marks the start of a test and will execute Insight for
+  testing. The TEST parameter should be the file name of the Tcl test
+  file to load into Insight's Tcl interpreter. It returns a list of
+  test results suitable for passing to gdbtk_done or gdbtk_analyze_results.
+  See gdbtk_analyze_results for more information on the format of results.
+
+  gdbtk_start is responsible for communicating target startup information
+  to Insight, so that Insight's testsuite may be run on any target supported
+  by gdb. It does this by setting several environment variables just before
+  it starts Insight. These environment variables are:
+
+  OBJDIR
+    The object directory of the dejagnu testsuite (i.e.,
+    objdir/gdb/testsuite).
+  SRCDIR
+    The dejagnu source directory in which the tests are located (i.e,
+    src/gdb/testsuite)
+  SUBDIR
+    The dejagnu testsuite subdirectory for the test (i.e., gdb.gdbtk)
+  DEFS
+    The location of the testsuite definitions file (i.e.,
+    src/gdb/testsuite/gdb.gdbtk/defs)
+
+  Note that DEFS is converted to absolute tcl-style paths. On unix,
+  this means that DEFS would point to, for example,
+  /home/keiths/insight/src/gdb/testsuite/gdb.gdbtk/defs. On Cygwin it
+  would point to C:/cygwin/home/keiths/insight/src/gdb/testsuite/gdb.gdbtk/defs.
+  This is because of a descrepency between Cygwin's posix paths and Tcl's
+  not-quite-posix paths.
+
+proc gdbtk_analyze_results {results}
+  This function translates the list of results in RESULTS into dejagnu
+  results, reporting the number of failures, errors, passes, and expected
+  failures and passes. It currently does not deal with "untested" and other
+  test statuses from dejagnu since Insight's tcl testsuite does not
+  issue such results.
+
+  The format of the results expected by gdbtk_analyze_results is simple:
+  it is a list of {status name description msg}. "status" is the execution
+  status of one of the tcl tests run. This can be "PASS", "FAIL", "ERROR",
+  "XFAIL", or "XPASS".
+
+  "name" is the name of the test, and it is reported in all testsuite
+  results in dejagnu. This speeds location of the failing test. This
+  "name" may also be given to Insight's testsuite, telling it to
+  only run this test. See "do_tests" in Tcl Testsuite Infrastructure
+  for more information.
+
+  "description" is a textual description of the test given by "name".
+
+  "msg" is currently not used.
+
+proc gdbtk_done {{results {}}}
+  gdbtk_done takes any RESULTS and passes it gdbtk_analyze_results for
+  outputting to the dejagnu part of the testsuite. It may be called
+  without an argument, in which case it will only terminate Xvfb if it
+  was started. Tests must call gdbtk_done _once_ at the end of their
+  test drivers.
+
+Private functions:
+proc _gdbtk_export_target_info
+  This function exports information about the target into the environment
+  so that Insight's testsuite may run programs on any supported gdb
+  target. This target information is passed into the Tcl testsuite
+  via an environment variable, TARGET_INFO, which is really a Tcl array,
+  i.e., the array is constructed in tcl and exported into the environment
+  with Tcl's "array get" command).
+
+  There are four elements to the array:
+  TARGET_INFO(init)   - (optional) A list of commands to execute in gdb
+                        to initialize the session. This usually includes
+                        setting baud rates and remote protocol options.
+  TARGET_INFO(target) - (required) The complete "target" command to connect
+                        to the given target.
+  TARGET_INFO(load)   - (optional) The complete "load" command to load an
+                        executable into a target.
+  TARGET_INFO(run)    - (required) The complete "run" command, sans arguments,
+			to start a process on the target. For remote targets,
+                        this is usually just "continue".
+  
+proc _gdbtk_xvfb_init
+  This procedure actually determines whether the an Insight test should
+  run and what DISPLAY it should use for that test. It is called by
+  gdbtk_initialize_display to do most of the dirty work.
+
+  It has a simple heuristic: If GDB_DISPLAY is not set and Xvfb is available
+  (on unix), it starts Xvfb, using the current process id as the screen number.
+  If Xvfb is not available and GDB_DISPLAY was not set, it skips the tests.
+
+proc _gdbtk_xvfb_exit
+  _gdbtk_xvfb_exit will kill any previously started Xvfb.
+
+Private globals:
+global _xvfb_spawn_id
+  This variable holds the spawn_id of any Xvfb process started
+  by the testsuite (or it is left undefined).
+
+global _using_windows
+  A global variable which indicates whether the testsuite is running
+  on cygwin. Unfortunately, as of writing, the global variable
+  tcl_platform(platform) is "unix" on Cygwin, so it is not possible
+  to rely on this for platform-dependent operations.
+
+  Instead, this variable is set by gdbtk_initialize_display. The test
+  it uses to determine if Cygwin is being used: it looks for the program
+  cygpath in the PATH. Therefore, cygpath is REQUIRED to run the testsuite
+  on Cygwin. (gdbtk_start also uses cygpath to determine Windows
+  pathnames for Cygwin.)
+
+
+Testsuite Driver Basics
+
+Given the above interfaces for connecting Insight's Tcl testsuite and
+gdb's dejagnu testsuite, the basic testsuite driver file should look
+(minimally) like this:
+
+File: mytest.exp
+1   load_lib "insight-support.exp"
+2   if {[gdbtk_initialize_display]} {
+3     # We found a display to use
+4     gdb_exit;   # Make sure any previous gdb is gone
+5     set results [gdbtk_start mytest.test]
+6
+7     # Done!
+8     gdbtk_done [split $results \n]
+9   }
+
+Line 1 loads the insight testsuite support library which contains definitions
+for all the procedures used in dejagnu to initialize and run the Insight testsuite.
+Line 2 calls gdbtk_initialize_display to ascertain whether there is a display
+to use for the test. This could use an existing display (if GDB_DISPLAY is
+set in the environment) or gdbk_initialize_display could startup an Xvfb
+for use by the testsuite.
+
+Line 4 forces any previously executing gdb to terminate.
+
+Line 5 signals the start of the test run. "mytest.test" is the name of the
+Tcl test file to execute in Insight's built-in Tcl interpreter. The output
+of gdbtk_start_test is all of the results of the Tcl test from Insight, which
+is subsequently passed to gdbk_analyze_results via gdbtk_done on Line 8.
+
+Note how nothing happens if gdbtk_initialize_display returns false.
+
+
+Tcl Testsuite Infrastructure
+
+The heart of Insight's testsuite is its Tcl testsuite. It is these tests
+which run directly in Insight's Tcl interpreter and allow test writers
+access to Insight's internals. Tcl testsuite files have the filename suffix
+".test" to distinguish them from their driver files, which end in ".exp".
+
+The design of the Insight Tcl testsuite parallels Tcl's testsuite. It has
+many powerful features, including the ability to run ANY test in a given
+Tcl test file. See the description of utility routines below for more
+information about running any set of tests from a file.
+
+The bulk of the code implementing the Tcl testsuite infrastructure in
+Insight is contained in the testsuite definitions file, "defs", located
+in src/gdb/testsuite/gdb.gdbtk. This file contains routines necessary
+to write tests for Insight.
+
+Public functions:
+proc gdbtk_read_defs {}
+  This function, located in Insight's core Tcl library, attempts to load
+  the testsuite definitions file. If it fails, it will either pop up
+  a dialog box with the error (if running interactively) or it will
+  print the error to stderr and exit (if running non-interactively).
+
+  If successful, it will return true.
+
+proc gdbtk_test_file {filename}
+  This function is used to load the file given by FILENAME into
+  Insight. It will automatically append ".exe" to any FILENAME
+  on Cygwin-hosted systems.
+
+  If successful, it will load the given file into Insight and
+  return the output of gdb's file command. It will call "error"
+  if it was succesful, therefore all calls to "gdbtk_test_file"
+  should be called using "catch".
+
+  Test authors should not use "gdb_cmd {file FILENAME}" to load
+  files into gdb unless they are testing interface code between
+  gdb and Insight.
+
+proc gdbtk_test_run {{prog_args {}}}
+  gdbtk_test_run runs the previously loaded executable, passing
+  the given arguments to the inferior. Like Insight's Run button,
+  it will do whatever is necessary to get the executable running,
+  including any target initialization (setting baud rate and remote
+  protocol options), downloading the executable to the target, and
+  finally starting execution.
+
+  Test authors should NEVER use "gdb_cmd {run ARGUMENTS}" to run an
+  executable. Doing so will insure that your tests will only run on
+  a native debugger.
+
+  It returns true if successful or false otherwise. It will report
+  the error in a dialog box (if running interactively) or it will
+  print the error to stderr.
+
+proc gdbtk_test {name description script answer}
+  This is Tcl testsuite equivalent of "expect". "name" is a canonical
+  name of the test, usually of the form "shortname-major.minor". This is
+  the name that is used when running selected tests from a given file.
+  If "name" starts with an asterisk (*), it designates that the test
+  is expected to fail.
+
+  "description" is a short textual description of the test to help
+  humans understand what it does.
+
+  "script" is the actual test script to run. The result of this script
+  will be compared against "answer" to determine if the test passed
+  or failed.
+
+  It calls gdbtk_print_verbose to print out the results to the terminal
+  (if running interactively) or to the log file.
+
+proc gdbtk_test_done {}
+  gdbtk_test_done is called at the very end of all tcl tests. It is used
+  to exit Insight and return control back to the dejagnu driver which
+  started the tests.
+  
+proc gdbtk_dotests {file args}
+  Obsolete.
+
+proc do_test {{file {}} {verbose {}} {tests {}}}
+  This procedure is used to invoke the Insight test(s) given in FILE
+  which match the regular expression(s) in TESTS. This is invoked
+  from Insight's console window to run tests interactively.
+
+  VERBOSE sets the verbosity of the test run. When set to one,
+  the testsuite will report all results in human readable form.
+  When set  greater than one, it will print out results as a list,
+  i.e., for passing to gdbtk_analyze_results. If zero, it will only
+  print errors and failures in human readable form.
+
+Public global variables:
+objdir   - The objdir from dejagnu. See gdbtk_start for more information.
+srcdir   - The srcdir from dejagnu. See gdbtk_start for more information.
+test_ran - Indicates whether the last test ran or not. See example below.
+
+Private functions:
+proc gdbtk_test_error {desc}
+  An internal function used to report a framework error in the testsuite.
+  "desc" is a description of the error. It calls gdbtk_test_done.
+
+proc gdbtk_print_verbose {status name description script code answer}
+  A helper procedure to gdbtk_test which prints out results to the terminal
+  or the logfile (or both or none).
+
+Private global variables:
+_test - An array used by the testsuite internals.
+
+
+Tcl Test Basics
+
+Armed with the basic interface described above, it is possible to test Insight's
+GUI. Please do not write tests which attempt to imitate a user (moving the
+mouse and clicking buttons), unless there is no other way to test the functionality.
+
+The basic test file (with one test) looks like this (nonsensical one):
+File: mytest.test
+1  if {![gdbtk_read_defs]} {
+2    break
+3  }
+4  
+5  global objdir test_ran
+6  set program [file join $objdir mytest]
+7  if {[catch {gdbtk_test_file $program} t]} {
+8    gdbtk_test_error "loading \"$program\": $t"
+9  }
+10 if {![gdbtk_test_run]} { exit 1 }
+11
+12 global foo
+13 set foo 1
+14
+15 # Test:  mytest-1.1
+16 # Desc:  check if a source window was created
+17 gdbtk_test mytest-1.1 {source window created} {
+18   set window [ManagedWin::find SrcWin]
+19   llength $window
+20   set foo 13
+21 } {1}
+22
+23 if {$test_ran} {
+24   set foo 1
+25 }
+26
+27 # Done
+28 gdbtk_test_done
+
+Line 1 calls the Inisght function gdbtk_read_defs to read in the testsuite
+definitions file.
+
+Line 6 then specifies the name of a file (mytest) in the object directory
+which is loaded into gdb on Line 7. If loading the file into Insight
+failed, gdbtk_test_error is called to publish the error (and terminate the
+test run for this file).
+
+Line 10 runs the executable on the target, and exits if it was unable
+to do so.
+
+Line 13 simply sets a global variable foo to illustrate the purpose
+of the global "test_ran". Before the test "mytest-1.1" runs, foo is set to
+one. In order to support running specific tests, the state of the debugger
+cannot be altered INSIDE gdbtk_test scripts, since the contents of the
+script may not be run if the user requested only a specific test to run.
+
+Line 20 in the middle of the test modifies the global foo. If subsequent
+test relied on foo being one, we would have a state violation, since
+mytest-1.1 may have (or may have not) run.
+
+Therefore, we can check if a test ran and reset foo by checking the
+global "test_ran". If set, we know that the previous test (mytest-1.1)
+was run, and that foo is now thirteen. We reset the result back to one.
+
+(Aside: Some tests do not follow this rule explicitly: they can assume
+that all tests run sequentially. In these cases, running a specific
+test in the file will probably fail, since the debugger is not brought
+to a known state along the way.)
+
+Lines 17-21 contain the actual test. The test's name is "mytest-1.1". It
+is this name that may be referred to when asking the testsuite to run
+a specific test. The description of this test is "source window created",
+indicating that mytest-1.1's purpose is to check whether a source window
+was created.
+
+If gdbtk_test determines that this test is to run, it will execute the
+next part, lines 18-20, and compare the output of that script (llength
+$window) with "1". If the result is not "1", a failure is recorded. If
+it is "1", a pass is recorded.
+
+Finally, the test file is done and exits on line 28.
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/simple.c stsgdb-6.8/gdb/testsuite/gdb.gdbtk/simple.c
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/simple.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/simple.c	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,23 @@
+#include <string.h>
+#include <stdlib.h>
+
+int
+main(int argc, char * argv[])
+{
+   int i;
+   char *a;
+   char *b = "abc";
+   long  foo;
+
+   a = (char *) malloc (300);
+
+   for (i=0; i < 50; i++)
+     {
+       int j = i % 3;
+       int k = 3 - j;
+       strncpy (&a[i], &b[k], j);
+       foo = (long) j * k / i + 2 * k * k * k;
+     }
+   return 0;
+}
+
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin2.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin2.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin2.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin2.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,899 @@
+#   Copyright (C) 1999, 2001 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Martin Hunt (hunt@cygnus.com)
+
+
+# same as srcwin.test, except test debugging executables
+# when source files are missing.
+
+# Read in the standard defs file
+
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir srcdir
+
+#####                 #####
+#                         #
+#  SECTION 1: Mode Tests  #
+#                         #
+#####                 #####
+
+# Load the test executable
+set program [file join $objdir list]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+set srcwin [ManagedWin::open SrcWin]
+set stw [$srcwin test_get twin]
+set twin [$stw test_get twin]
+set statbar [$srcwin test_get _statbar]
+
+# get things started
+gdb_cmd "break main"
+gdbtk_test_run
+
+# Test: srcwin2-1.1
+# Desc: Check for something in source window
+gdbtk_test srcwin2-1.1 "source window has contents" {
+  set r 0
+  set file1(source) [$twin get 1.0 end]
+  if {$file1(source) == ""} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.2
+# Desc: source->assembly mode change
+gdbtk_test srcwin2-1.2 "source->assembly mode change" {
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  set file1(assembly) [$twin get 1.0 end]
+  # source == assembly because for there is no source
+  string compare $file1(source) $file1(assembly)
+} {0}
+
+# Test: srcwin2-1.3
+# Desc: assembly->mixed mode change
+gdbtk_test srcwin2-1.3 "assembly->mixed mode change" {
+  set r 0
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  set file1(mixed) [$twin get 1.0 end]
+  # mixed != assembly because the lines with source should
+  # be noted, even if source in unavailable. This behaviour is
+  # different for different debug formats, so we accept either.
+  if {$file1(mixed) == ""} {set r -1}
+  if {[$statbar.mode get] != "MIXED"} {set r -2}
+  set r	
+} {0}
+
+# Test: srcwin2-1.4
+# Desc: mixed->src+asm mode change
+gdbtk_test srcwin2-1.4 "mixed->src+asm mode change" {
+  set r 0
+  # mode change may fail if fallover to ASSEMBLY fails
+  if {[catch {$srcwin mode "" SRC+ASM}]} { set r -5 }
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(assembly)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.5
+# Desc: src+asm->source mode change
+gdbtk_test srcwin2-1.5 "src+asm->source mode change" {
+  set r 0
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  if {[$stw test_get bwin] != ""} {set r -2}
+  if {[$twin get 1.0 end] != $file1(assembly)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -3}
+  set r
+} {0}
+
+# Test: srcwin2-1.6
+# Desc: source->mixed mode change
+gdbtk_test srcwin2-1.6 "source->mixed mode change" {
+  set r 0
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(mixed)} {set r -1}
+  if {[$statbar.mode get] != "MIXED"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.7
+# Desc: mixed->source mode change
+gdbtk_test srcwin2-1.7 "mixed->source mode change" {
+  set r 0
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(source)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.8
+# Desc: source->src+asm mode change
+gdbtk_test srcwin2-1.8 "source->src+asm mode change" {
+  set r 0
+  # mode change may fail if fallover to ASSEMBLY fails
+  if {[catch {$srcwin mode "" SRC+ASM}]} { set r -5 }
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  if {[$twin get 1.0 end] != $file1(assembly)} {set r -1}
+  if {$bwin != ""} {set r -2}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -3}
+  set r
+} {0}
+
+# Test: srcwin2-1.9
+# Desc: src+asm->assembly mode change
+gdbtk_test srcwin2-1.9 "src+asm->assembly mode change" {
+  set r 0
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(assembly)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.10
+# Desc: assembly->src+asm mode change
+gdbtk_test srcwin2-1.10 "assembly->src+asm mode change" {
+  set r 0
+  # mode change may fail if fallover to ASSEMBLY fails
+  if {[catch {$srcwin mode "" SRC+ASM}]} { set r -5 }
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  if {[$twin get 1.0 end] != $file1(assembly)} {set r -1}
+  if {$bwin != ""} {set r -2}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -3}
+  set r
+} {0}
+
+# Test: srcwin2-1.11
+# Desc: src+asm->mixed mode change
+gdbtk_test srcwin2-1.11 "src+asm->mixed mode change" {
+  set r 0
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(mixed)} {set r -1}
+  if {[$statbar.mode get] != "MIXED"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.12
+# Desc: mixed->assembly mode change
+gdbtk_test srcwin2-1.12 "mixed->assembly mode change" {
+  set r 0
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(assembly)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin2-1.13
+# Desc: assembly->source mode change
+gdbtk_test srcwin2-1.13 "assembly->source mode change" {
+  set r 0
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $file1(source)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+
+#####                       #####
+#                               #
+#  SECTION 2: Basic Operations  #
+#                               #
+#####                       #####
+
+# Test: srcwin2-2.1
+# Desc: check contents of filename combobox
+gdbtk_test srcwin2-2.1 "check contents of filename combobox" {
+  set names [$statbar.name list get 0 end]
+  set r 0
+  foreach f {list0.c list1.c} {
+    if {[lsearch $names $f] != -1} {
+      incr r
+    }
+  }
+  set r
+} {2}
+
+# Test: srcwin2-2.2
+# Desc: check contents of function combobox
+gdbtk_test srcwin2-2.2 "check contents of function combobox" {
+  set names [$statbar.func list get 0 end]
+  set r 0
+  foreach f {main foo unused} {
+    if {[lsearch $names $f] != -1} {
+      incr r
+    }
+  }
+  set r
+} {3}
+
+# Test: srcwin2-2.3
+# Desc: goto filename
+gdbtk_test srcwin2-2.3 "goto filename" {
+  set func [$srcwin test_get _name 1]
+  $func "" list1.c
+  set twin [$stw test_get twin]
+  set file2(source) [$twin get 1.0 end]
+  expr {![string compare $file1(source) $file2(source)]}
+} {0}
+
+# Test: srcwin2-2.4
+# Desc: check contents of function combobox
+gdbtk_test srcwin2-2.4 "check contents of function combobox" {
+  set names [$statbar.func list get 0 end]
+  set r 0
+  foreach f {bar long_line oof unused} {
+    if {[lsearch $names $f] != -1} {
+      incr r
+    }
+  }
+  set r
+} {4}
+
+# Test: srcwin2-2.5
+# Desc: function combobox entry field should be empty after switching to a new file
+gdbtk_test srcwin2-2.5 "function combobox entry field should be empty" {
+  set names [$statbar.func get]
+  string length $names
+} {0}
+
+# Test: srcwin2-2.6
+# Desc: goto function
+gdbtk_test srcwin2-2.6 "goto function bar" {
+  $srcwin goto_func "" bar
+  set r 0
+
+  # now get a dump of all tags and check that only one line is
+  # marked BROWSE_TAG and no lines are STACK_TAG or PC_TAG.
+
+  # We know that list1.c should have BROWSE_TAG set at index 10.2
+  # for function "bar".  If list1.c is changed or the layout of the source
+  # window is changed, this must be updated.
+  if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+    foreach {k v i} $z {
+      if {$k == "tagon"} {
+	if {$v == "BROWSE_TAG"} {
+	  if {$i == "10.2"} {
+	    incr r
+	  } else {
+	    incr r 5
+	  }
+	}
+	if {$v == "STACK_TAG"} { incr r 10}
+	if {$v == "PC_TAG"} { incr r 100}
+      }
+    }
+  } else {
+    set r -1
+  }
+
+  if {$r == 1} {
+    # things are OK so far, so just verify the function name is displayed
+    # in the combobox entry field.
+    set names [$statbar.func get]
+    if {[string compare $names "bar"]} {set r -2}
+  }
+  set r
+} {1}
+
+# Test: srcwin2-2.7
+# Desc: goto function "oof". This tests that the correct line is highlighted
+# with BROWSE_TAG and no other lines are highlighted. It also checks that
+# the combobox has the correct function name in it.  Finally, list1.c
+# has an extremely long line, line 32, that breaks some functions.  We verify 
+# that the GDBtk has the correct line number.
+
+gdbtk_test srcwin2-2.7 "goto function oof" {
+  $srcwin goto_func "" oof
+  set r 0
+
+  # now get a dump of all tags and check that only one line is
+  # marked BROWSE_TAG and no lines are STACK_TAG or PC_TAG.
+
+  # We know that list1.c should have BROWSE_TAG set at index 38.2
+  # for function "oof".  If list1.c is changed or the layout of the source
+  # window is changed, this must be updated.
+  if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+    foreach {k v i} $z {
+      if {$k == "tagon"} {
+	if {$v == "BROWSE_TAG"} {
+	  if {$i == "38.2"} {
+	    set line_number [$twin get "$i wordstart" "$i wordend"]
+	    if {$line_number == "38"} {
+	      incr r
+	    } else {
+	      incr r -100
+	    }
+	  } else {
+	    incr r 5
+	  }
+	}
+	if {$v == "STACK_TAG"} {incr r 10}
+	if {$v == "PC_TAG"} {incr r 100}
+      }
+    }
+  } else {
+    set r -1
+  }
+
+  if {$r == 1} {
+    # things are OK so far, so just verify the function name is displayed
+    # in the combobox entry field.
+    set names [$statbar.func get]
+    if {[string compare $names "oof"]} {set r -2}
+  }
+  set r
+} {1}
+
+# Test: srcwin2-2.8
+# Desc: This test issues a next command while browsing list1.c.
+# It should display list0.c and highlight the correct line.
+gdbtk_test srcwin2-2.8 "step while browsing" {
+  gdb_immediate "next" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.c"} {set r -1}
+  if {$func != "main"} {set r -2}
+
+  # check that correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file1(source) $a]} {set r -3}
+
+  # check for PC_TAG
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin2-2.11
+# Desc: This test issues a break and a continue
+gdbtk_test srcwin2-2.11 "set BP and continue" {
+  gdb_immediate "break oof" 1
+  gdb_immediate "continue" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  # we must clear the breakpoint first so it doesn't mess up the
+  # comparison...
+  gdb_immediate "clear oof" 1  
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+#####                       #####
+#                               #
+#  SECTION 3: Stack Operations  #
+#                               #
+#####                       #####
+
+# Test: srcwin2-3.1
+# Desc: This tests "stack up" 
+gdbtk_test srcwin2-3.1 "stack up (1)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "long_line"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "26.2"} {
+	      incr r
+	    } else {
+	      incr r 10
+	    }
+	  }
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {2}
+
+# Test: srcwin2-3.2
+# Desc: Another "stack up"  test
+gdbtk_test srcwin2-3.2 "stack up (2)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "bar"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "12.2"} {
+	      incr r
+	    } else {
+	      incr r 10
+	    }
+	  }
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {2}
+
+# Test: srcwin2-3.3
+# Desc: Another "stack up"  test
+gdbtk_test srcwin2-3.3 "stack up (3)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set file3(source) [$twin get 1.0 end]
+  if {![string compare $file2(source) $file3(source)]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin2-3.4
+# Desc: Another "stack up"  test
+gdbtk_test srcwin2-3.4 "stack up (4)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.c"} {set r -1}
+  if {$func != "main"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file1(source) $a]} {set r -3}
+  
+  # check for STACK_TAG
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    incr r
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+
+# Disabled for now because there are different correct results.
+# Test should be rewritten to include those.
+# Test: srcwin2-3.5
+# Desc: "stack up" when we are at the top
+#gdbtk_test srcwin2-3.5 "stack up when at the top" {
+# $srcwin stack up
+#  set r 0
+#  set name [$statbar.name get]
+#  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+#  if {$name != "list0.c"} {set r -1}
+#  if {$func != "main"} {set r -2}
+
+  # check that the correct file is displayed
+#  set twin [$stw test_get twin]
+#  set a [$twin get 1.0 end]
+#  if {[string compare $file1(source) $a]} {set r -3}
+  
+  # check for STACK_TAG
+#  if {$r == 0} {
+#    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+#      foreach {k v i} $z {
+#	if {$k == "tagon"} {
+#	  if {$v == "STACK_TAG"} {
+#	    incr r
+#	  }
+#	  if {$v == "PC_TAG"} {incr r 10}
+#	  if {$v == "BROWSE_TAG"} {incr r 100}
+#	}
+#      }
+#    } else {
+#      set r -4
+#    }
+#  }
+#  set r
+#} {1}
+
+# Test: srcwin2-3.6
+# Desc: "stack down"  test
+gdbtk_test srcwin2-3.6 "stack down" {
+  $srcwin stack down
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {![string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin2-3.7
+# Desc: "stack bottom"  test
+gdbtk_test srcwin2-3.7 "stack bottom" {
+  $srcwin stack bottom
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin2-3.8
+# Desc: "stack down" when at bottom
+gdbtk_test srcwin2-3.8 "stack down when at bottom" {
+  $srcwin stack down
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# 4.1 bp, multiple, balloon, etc
+
+# Test: srcwin2-4.1
+# Desc: Set BP in another file. Tests bp and cache functions
+gdbtk_test srcwin2-4.1 "set BP in another file" {
+  gdb_immediate "break foo" 1
+  $srcwin goto_func "" foo
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "BROWSE_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "PC_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  if {$i == "9.0"} {
+	    incr r
+	  } else {
+	    set r -200
+	  }
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  if {$r == 2} {
+    # clear BP and compare with previous contents. This should succeed,
+    gdb_immediate "clear foo" 1
+    set a [$twin get 1.0 end]
+    if {[string compare $file3(source) $a]} {set r -3}
+  }
+  
+  set r
+} {2}
+
+# Test: srcwin2-4.2
+# Desc: Test temporary BP
+gdbtk_test srcwin2-4.2 "temporary BP" {
+  set r 0
+  if {[catch {gdb_immediate "tbreak foo" 1} msg]} {
+    set r -500
+  }
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+  
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "BROWSE_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "PC_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  if {$i == "9.0"} {
+	    incr r
+	  } else {
+	    set r -200
+	  }
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  gdb_immediate "continue" 1
+  
+  # now check for PC_TAG and no image
+  if {$r == 2} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  set r -200
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  set r
+} {3}
+
+gdbtk_test_done
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin3.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin3.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin3.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin3.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,789 @@
+#   Copyright (C) 1999, 2001 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Martin Hunt (hunt@cygnus.com)
+
+###########################################################
+# same as srcwin.test, except test debugging executables  #
+# build without "-g"                                      #
+###########################################################
+
+# Read in the standard defs file
+
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir srcdir
+
+#####                 #####
+#                         #
+#  SECTION 1: Mode Tests  #
+#                         #
+#####                 #####
+
+# Load the test executable
+set program [file join $objdir list]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+set srcwin [ManagedWin::open SrcWin]
+set stw [$srcwin test_get twin]
+set twin [$stw test_get twin]
+set statbar [$srcwin test_get _statbar]
+
+# get things started
+gdb_cmd "break main"
+gdbtk_test_run
+
+# Test: srcwin3-1.1
+# Desc: Check for something in source window
+gdbtk_test srcwin3-1.1 "source window has contents" {
+  set r 0
+  set source(main) [$twin get 1.0 end]
+  if {$source(main) == ""} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.2
+# Desc: source->assembly mode change
+gdbtk_test srcwin3-1.2 "source->assembly mode change" {
+  set r 0
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  if {$source(main) != [$twin get 1.0 end]} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.3
+# Desc: assembly->mixed mode change
+gdbtk_test srcwin3-1.3 "assembly->mixed mode change" {
+  set r 0
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  if {$source(main) != [$twin get 1.0 end]} {set r -1}
+  if {[$statbar.mode get] != "MIXED"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.4
+# Desc: mixed->src+asm mode change
+gdbtk_test srcwin3-1.4 "mixed->src+asm mode change" {
+  set r 0
+  # mode change may fail if fallover to ASSEMBLY fails
+  if {[catch {$srcwin mode "" SRC+ASM}]} { set r -5 }
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.5
+# Desc: src+asm->source mode change
+gdbtk_test srcwin3-1.5 "src+asm->source mode change" {
+  set r 0
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  if {[$stw test_get bwin] != ""} {set r -2}
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -3}
+  set r
+} {0}
+
+# Test: srcwin3-1.6
+# Desc: source->mixed mode change
+gdbtk_test srcwin3-1.6 "source->mixed mode change" {
+  set r 0
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "MIXED"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.7
+# Desc: mixed->source mode change
+gdbtk_test srcwin3-1.7 "mixed->source mode change" {
+  set r 0
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.8
+# Desc: source->src+asm mode change
+gdbtk_test srcwin3-1.8 "source->src+asm mode change" {
+  set r 0
+  # mode change may fail if fallover to ASSEMBLY fails
+  if {[catch {$srcwin mode "" SRC+ASM}]} { set r -5 }
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {$bwin != ""} {set r -2}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -3}
+  set r
+} {0}
+
+# Test: srcwin3-1.9
+# Desc: src+asm->assembly mode change
+gdbtk_test srcwin3-1.9 "src+asm->assembly mode change" {
+  set r 0
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.10
+# Desc: assembly->src+asm mode change
+gdbtk_test srcwin3-1.10 "assembly->src+asm mode change" {
+  set r 0
+  # mode change may fail if fallover to ASSEMBLY fails
+  if {[catch {$srcwin mode "" SRC+ASM}]} { set r -5 }
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {$bwin != ""} {set r -2}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -3}
+  set r
+} {0}
+
+# Test: srcwin3-1.11
+# Desc: src+asm->mixed mode change
+gdbtk_test srcwin3-1.11 "src+asm->mixed mode change" {
+  set r 0
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "MIXED"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.12
+# Desc: mixed->assembly mode change
+gdbtk_test srcwin3-1.12 "mixed->assembly mode change" {
+  set r 0
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+# Test: srcwin3-1.13
+# Desc: assembly->source mode change
+gdbtk_test srcwin3-1.13 "assembly->source mode change" {
+  set r 0
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  if {[$twin get 1.0 end] != $source(main)} {set r -1}
+  if {[$statbar.mode get] != "ASSEMBLY"} {set r -2}
+  set r
+} {0}
+
+
+#####                       #####
+#                               #
+#  SECTION 2: Basic Operations  #
+#                               #
+#####                       #####
+
+# Test: srcwin3-2.2
+# Desc: check contents of function combobox
+# There won't be any because we have no debug info
+gdbtk_test srcwin3-2.2 "check contents of function combobox" {
+  set names [$statbar.func list get 0 end]
+  llength $names
+} {0}
+
+# Test: srcwin3-2.3
+# Desc: goto filename - this won't work, but should leave things as they were
+gdbtk_test srcwin3-2.3 "goto filename" {
+  set func [$srcwin test_get _name 1]
+  $func "" list1.c
+  set twin [$stw test_get twin]
+  string compare $source(main) [$twin get 1.0 end]
+} {0}
+
+# Test: srcwin3-2.6
+# Desc: goto function
+gdbtk_test srcwin3-2.6 "goto function bar" {
+  $srcwin goto_func "" bar
+  set r 0
+  set twin [$stw test_get twin]
+  set source(bar) [$twin get 1.0 end]
+  
+  if {$source(bar) == $source(main)} {set r -1000}
+
+  # now get a dump of all tags and check that only one line is
+  # marked BROWSE_TAG and no lines are STACK_TAG or PC_TAG.
+
+  # We know that list1.c should have BROWSE_TAG set at index 5.2
+  # for function "bar".  If list1.c is changed or the layout of the source
+  # window is changed, this must be updated.
+  if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+    foreach {k v i} $z {
+      if {$k == "tagon"} {
+	if {$v == "BROWSE_TAG"} {
+	  incr r
+	}
+	if {$v == "STACK_TAG"} { incr r 10}
+	if {$v == "PC_TAG"} { incr r 100}
+      }
+    }
+  } else {
+    set r -1
+  }
+
+  if {$r == 1} {
+    # things are OK so far, so just verify the function name is displayed
+    # in the combobox entry field.
+    set names [$statbar.func get]
+    if {[string compare $names "bar"]} {set r -2}
+  }
+  set r
+} {1}
+
+# Test: srcwin3-2.7
+# Desc: goto function "oof". This tests that the correct line is highlighted
+# with BROWSE_TAG and no other lines are highlighted. It also checks that
+# the combobox has the correct function name in it.  
+
+gdbtk_test srcwin3-2.7 "goto function oof" {
+  $srcwin goto_func "" oof
+  set r 0
+
+  set twin [$stw test_get twin]
+  set source(oof) [$twin get 1.0 end]
+  
+  if {$source(bar) == $source(oof)} {set r -1000}
+  if {$source(oof) == $source(main)} {set r -2000}
+
+  # now get a dump of all tags and check that only one line is
+  # marked BROWSE_TAG and no lines are STACK_TAG or PC_TAG.
+
+  if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+    foreach {k v i} $z {
+      if {$k == "tagon"} {
+	if {$v == "BROWSE_TAG"} {
+	  incr r
+	}
+	if {$v == "STACK_TAG"} {incr r 10}
+	if {$v == "PC_TAG"} {incr r 100}
+      }
+    }
+  } else {
+    set r -1
+  }
+
+  if {$r == 1} {
+    # things are OK so far, so just verify the function name is displayed
+    # in the combobox entry field.
+    set names [$statbar.func get]
+    if {[string compare $names "oof"]} {set r -2}
+  }
+  set r
+} {1}
+
+# Test: srcwin3-2.8
+# Desc: This test issues a nexti command while browsing oof.
+# It should jump back to main
+gdbtk_test srcwin3-2.8 "nexti while browsing" {
+  gdb_immediate "nexti" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of function combobox
+  if {$func != "main"} {set r -2}
+  if {$name != ""} {set r -1}
+
+  # check that correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(main) $a]} {set r -3}
+
+  # check for PC_TAG
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin3-2.11
+# Desc: This test issues a break and a continue
+gdbtk_test srcwin3-2.11 "set BP and continue" {
+  gdb_immediate "break oof" 1
+  gdb_immediate "continue" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "oof"} {set r -2}
+  
+  # check that the correct file is displayed
+  # we must clear the breakpoint first so it doesn't mess up the
+  # comparison...
+  gdb_immediate "clear oof" 1  
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(oof) $a]} {set r -3}
+  
+  # check for PC_TAG
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+#####                       #####
+#                               #
+#  SECTION 3: Stack Operations  #
+#                               #
+#####                       #####
+
+# Test: srcwin3-3.1
+# Desc: This tests "stack up" 
+gdbtk_test srcwin3-3.1 "stack up (1)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "long_line"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set source(long_line) [$twin get 1.0 end]
+  if {![string compare $source(long_line) $source(oof)]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {incr r 5}
+	  if {$v == "STACK_TAG"} {incr r}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin3-3.2
+# Desc: Another "stack up"  test
+gdbtk_test srcwin3-3.2 "stack up (2)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "bar"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(bar) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    set r -100
+	  }
+	  if {$v == "STACK_TAG"} {
+	    incr r
+	  }
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin3-3.3
+# Desc: Another "stack up"  test
+gdbtk_test srcwin3-3.3 "stack up (3)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set source(foo) [$twin get 1.0 end]
+  if {![string compare $source(foo) $source(bar)]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    incr r
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin3-3.4
+# Desc: Another "stack up"  test
+gdbtk_test srcwin3-3.4 "stack up (4)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "main"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(main) $a]} {set r -3}
+  
+  # check for STACK_TAG
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    incr r
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Disabled for now because there are different correct results.
+# Test should be rewritten to include those.
+# Test: srcwin3-3.5
+# Desc: "stack up" when we are at the top
+#gdbtk_test srcwin3-3.5 "stack up when at the top" {
+#  $srcwin stack up
+#  set r 0
+#  set name [$statbar.name get]
+#  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+#  if {$name != ""} {set r -1}
+#  if {$func != "main"} {set r -2}
+
+  # check that the correct file is displayed
+#  set twin [$stw test_get twin]
+#  set a [$twin get 1.0 end]
+#  if {[string compare $source(main) $a]} {set r -3}
+  
+  # check for STACK_TAG
+#  if {$r == 0} {
+#    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+#      foreach {k v i} $z {
+#	if {$k == "tagon"} {
+#	  if {$v == "STACK_TAG"} {
+#	    incr r
+#	  }
+#	  if {$v == "PC_TAG"} {incr r 10}
+#	  if {$v == "BROWSE_TAG"} {incr r 100}
+#	}
+#      }
+#    } else {
+#      set r -4
+#    }
+#  }
+#  set r
+#} {1}
+
+# Test: srcwin3-3.6
+# Desc: "stack down"  test
+gdbtk_test srcwin3-3.6 "stack down" {
+  $srcwin stack down
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(foo) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    incr r
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin3-3.7
+# Desc: "stack bottom"  test
+gdbtk_test srcwin3-3.7 "stack bottom" {
+  $srcwin stack bottom
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(oof) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin3-3.8
+# Desc: "stack down" when at bottom
+gdbtk_test srcwin3-3.8 "stack down when at bottom" {
+  $srcwin stack down
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $source(oof) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# 4.1 bp, multiple, balloon, etc
+
+# Test: srcwin3-4.1
+# Desc: Set BP in another file. Tests bp and cache functions
+gdbtk_test srcwin3-4.1 "set BP in another file" {
+  gdb_immediate "break foo" 1
+  $srcwin goto_func "" foo
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "BROWSE_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "PC_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  incr r
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  if {$r == 2} {
+    # clear BP and compare with previous contents. This should succeed,
+    gdb_immediate "clear foo" 1
+    set a [$twin get 1.0 end]
+    if {[string compare $source(foo) $a]} {set r -3}
+  }
+  
+  set r
+} {2}
+
+# Test: srcwin3-4.2
+# Desc: Test temporary BP
+gdbtk_test srcwin3-4.2 "temporary BP" {
+  set r 0
+  if {[catch {gdb_immediate "tbreak foo" 1} msg]} {
+    set r -500
+  }
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+  
+  # check contents of name and function comboboxes
+  if {$name != ""} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "BROWSE_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "PC_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  incr r
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  gdb_immediate "continue" 1
+  
+  # now check for PC_TAG and no image
+  if {$r == 2} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    incr r
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  set r -200
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  set r
+} {3}
+
+gdbtk_test_done
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,71 @@
+# Copyright 1999, 2001 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+load_lib ../gdb.gdbtk/insight-support.exp
+
+if {[gdbtk_initialize_display]} {
+  if {$tracelevel} {
+    strace $tracelevel
+  }
+
+  #
+  # test source window
+  #
+  set prms_id 0
+  set bug_id 0
+  
+  set testfile "list"
+  set s1 "$srcdir/$subdir/list0.c"
+  set sources "$s1 $srcdir/$subdir/list1.c"
+  set binfile $objdir/$subdir/$testfile
+  if {[file exists $s1.save]} {
+    catch {file delete $s1}
+    file rename $s1.save $s1
+  }
+  set r [gdb_compile $sources "$binfile" executable debug]
+  if  { $r != "" } {
+    gdb_suppress_entire_file \
+      "Testcase compile failed, so some tests in this file will automatically fail."
+  }
+
+  # Start with a fresh gdbtk
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir srcwin.test]]
+  set results [split $results \n]
+  set all_results $results
+
+  # move file with "main" out of the way
+  file rename $s1 $s1.save
+
+  # run slightly different set of tests
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir srcwin2.test]]
+  set results [split $results \n]
+  set all_results [concat $all_results $results]
+
+  # restore file
+  file rename $s1.save $s1
+
+  set r [gdb_compile $sources "$binfile" executable ""]
+  if  { $r != "" } {
+    gdb_suppress_entire_file \
+      "Testcase compile failed, so some tests in this file will automatically fail."
+  }
+  # run slightly different set of tests
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir srcwin3.test]]
+  set results [split $results \n]
+  set all_results [concat $all_results $results]
+
+  # Analyze results
+  gdbtk_done $all_results
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/srcwin.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,1192 @@
+#   Copyright (C) 1999, 2001 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Martin Hunt (hunt@cygnus.com)
+
+# Read in the standard defs file
+
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir srcdir
+
+
+# move the pointer to the center of the bbox relative to $win
+proc move_mouse_to {win bbox} {
+  if {[llength $bbox] != 4} {
+    return 0
+  }
+  set x [expr [lindex $bbox 0] + [lindex $bbox 2] / 2]
+  set y [expr [lindex $bbox 1] + [lindex $bbox 3] / 2]
+  warp_pointer . [winfo rootx $win] [winfo rooty $win]
+
+  set nx 0
+  set ny 0
+
+  while {$nx != $x || $ny != $y} {
+    if {$nx < $x} {incr nx}
+    if {$ny < $y} {incr ny}
+    warp_pointer $win $nx $ny
+  }
+  return 1
+}
+
+proc click {win bbox bnum} {
+  if {![move_mouse_to $win $bbox]} {
+    return 0
+  }
+  update
+
+  set x [expr [lindex $bbox 0] + [lindex $bbox 2] / 2]
+  set y [expr [lindex $bbox 1] + [lindex $bbox 3] / 2]
+
+  if {[catch {event generate $win <Button-$bnum> -x $x -y $y} result]} {
+    return 0
+  }
+  if {[catch {event generate $win <ButtonRelease-$bnum> -x $x -y $y} result]} {
+    return 0
+  }
+  return 1
+}
+
+
+#####                 #####
+#                         #
+#  SECTION 1: Mode Tests  #
+#                         #
+#####                 #####
+
+# Load the test executable
+set program [file join $objdir list]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+set srcwin [ManagedWin::open SrcWin]
+set stw [$srcwin test_get twin]
+set twin [$stw test_get twin]
+
+# get things started
+gdb_cmd "break main"
+gdbtk_test_run
+
+# Test: srcwin-1.1
+# Desc: Check for something in source window
+gdbtk_test srcwin-1.1 "source window has contents" {
+  set file1(source) [$twin get 1.0 end]
+  expr {![string compare $file1(source) ""]}
+} {0}
+
+
+# Test: srcwin-1.2
+# Desc: source->assembly mode change
+gdbtk_test srcwin-1.2 "source->assembly mode change" {
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  set file1(assembly) [$twin get 1.0 end]
+  expr {![string compare $file1(source) $file1(assembly)]}
+} {0}
+
+# Test: srcwin-1.3
+# Desc: assembly->mixed mode change
+gdbtk_test srcwin-1.3 "assembly->mixed mode change" {
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  set file1(mixed) [$twin get 1.0 end]
+  expr {![string compare $file1(mixed) $file1(assembly)]}
+} {0}
+
+# Test: srcwin-1.4
+# Desc: mixed->src+asm mode change
+gdbtk_test srcwin-1.4 "mixed->src+asm mode change" {
+  $srcwin mode "" SRC+ASM
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  set s [$twin get 1.0 end]
+  set a [$bwin get 1.0 end]
+  list [string compare $a $file1(assembly)] [string compare $s $file1(source)] [winfo ismapped $bwin]
+} {0 0 1}
+
+# Test: srcwin-1.5
+# Desc: src+asm->source mode change
+gdbtk_test srcwin-1.5 "src+asm->source mode change" {
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  set bwin [$stw test_get bwin]
+  list [string compare $file1(source) $a] [winfo ismapped $bwin]
+} {0 0}
+
+# Test: srcwin-1.6
+# Desc: source->mixed mode change
+gdbtk_test srcwin-1.6 "source->mixed mode change" {
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  string compare $file1(mixed) $a
+} {0}
+
+# Test: srcwin-1.7
+# Desc: mixed->source mode change
+gdbtk_test srcwin-1.7 "mixed->source mode change" {
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  string compare $file1(source) $a
+} {0}
+
+# Test: srcwin-1.8
+# Desc: source->src+asm mode change
+gdbtk_test srcwin-1.8 "source->src+asm mode change" {
+  $srcwin mode "" SRC+ASM
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  set s [$twin get 1.0 end]
+  set a [$bwin get 1.0 end]
+  list [string compare $a $file1(assembly)] [string compare $s $file1(source)] [winfo ismapped $bwin]
+} {0 0 1}
+
+# Test: srcwin-1.9
+# Desc: src+asm->assembly mode change
+gdbtk_test srcwin-1.9 "src+asm->assembly mode change" {
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  string compare $file1(assembly) $a
+} {0}
+
+# Test: srcwin-1.10
+# Desc: assembly->src+asm mode change
+gdbtk_test srcwin-1.10 "assembly->src+asm mode change" {
+  $srcwin mode "" SRC+ASM
+  set twin [$stw test_get twin]
+  set bwin [$stw test_get bwin]
+  set s [$twin get 1.0 end]
+  set a [$bwin get 1.0 end]
+  list [string compare $a $file1(assembly)] [string compare $s $file1(source)] [winfo ismapped $bwin]
+} {0 0 1}
+
+# Test: srcwin-1.11
+# Desc: src+asm->mixed mode change
+gdbtk_test srcwin-1.11 "src+asm->mixed mode change" {
+  $srcwin mode "" MIXED
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  set bwin [$stw test_get bwin]
+  expr {[string compare $file1(mixed) $a] ||
+	[winfo ismapped $bwin]}
+} {0}
+
+# Test: srcwin-1.12
+# Desc: mixed->assembly mode change
+gdbtk_test srcwin-1.12 "mixed->assembly mode change" {
+  $srcwin mode "" ASSEMBLY
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  string compare $file1(assembly) $a
+} {0}
+
+# Test: srcwin-1.13
+# Desc: assembly->source mode change
+gdbtk_test srcwin-1.13 "assembly->source mode change" {
+  $srcwin mode "" SOURCE
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  string compare $file1(source) $a
+} {0}
+
+
+#####                       #####
+#                               #
+#  SECTION 2: Basic Operations  #
+#                               #
+#####                       #####
+
+# Test: srcwin-2.1
+# Desc: check contents of filename combobox
+gdbtk_test srcwin-2.1 "check contents of filename combobox" {
+  set statbar [$srcwin test_get _statbar]
+  set names [$statbar.name list get 0 end]
+  set r 0
+  foreach f {list0.c list1.c} {
+    if {[lsearch $names $f] != -1} {
+      incr r
+    }
+  }
+  set r
+} {2}
+
+# Test: srcwin-2.2
+# Desc: check contents of function combobox
+gdbtk_test srcwin-2.2 "check contents of function combobox" {
+  set names [$statbar.func list get 0 end]
+  set r 0
+  foreach f {main foo unused} {
+    if {[lsearch $names $f] != -1} {
+      incr r
+    }
+  }
+  set r
+} {3}
+
+# Test: srcwin-2.3
+# Desc: goto filename
+gdbtk_test srcwin-2.3 "goto filename" {
+  set func [$srcwin test_get _name 1]
+  $func "" list1.c
+  set twin [$stw test_get twin]
+  set file2(source) [$twin get 1.0 end]
+  expr {![string compare $file1(source) $file2(source)]}
+} {0}
+
+# Test: srcwin-2.4
+# Desc: check contents of function combobox
+gdbtk_test srcwin-2.4 "check contents of function combobox" {
+  set names [$statbar.func list get 0 end]
+  set r 0
+  foreach f {bar long_line oof unused} {
+    if {[lsearch $names $f] != -1} {
+      incr r
+    }
+  }
+  set r
+} {4}
+
+# Test: srcwin-2.5
+# Desc: function combobox entry field should be empty after switching to a new file
+gdbtk_test srcwin-2.5 "function combobox entry field should be empty" {
+  set names [$statbar.func get]
+  string length $names
+} {0}
+
+# Test: srcwin-2.6
+# Desc: goto function
+gdbtk_test srcwin-2.6 "goto function bar" {
+  $srcwin goto_func "" bar
+  set r 0
+
+  # now get a dump of all tags and check that only one line is
+  # marked BROWSE_TAG and no lines are STACK_TAG or PC_TAG.
+
+  # We know that list1.c should have BROWSE_TAG set at index 5.2
+  # for function "bar".  If list1.c is changed or the layout of the source
+  # window is changed, this must be updated.
+  if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+    foreach {k v i} $z {
+      if {$k == "tagon"} {
+	if {$v == "BROWSE_TAG"} {
+	  if {$i == "10.2"} {
+	    incr r
+	  } else {
+	    incr r 5
+	  }
+	}
+	if {$v == "STACK_TAG"} { incr r 10}
+	if {$v == "PC_TAG"} { incr r 100}
+      }
+    }
+  } else {
+    set r -1
+  }
+
+  if {$r == 1} {
+    # things are OK so far, so just verify the function name is displayed
+    # in the combobox entry field.
+    set names [$statbar.func get]
+    if {[string compare $names "bar"]} {set r -2}
+  }
+  set r
+} {1}
+
+# Test: srcwin-2.7
+# Desc: goto function "oof". This tests that the correct line is highlighted
+# with BROWSE_TAG and no other lines are highlighted. It also checks that
+# the combobox has the correct function name in it.  Finally, list1.c
+# has an extremely long line, line 32, that breaks some functions.  We verify 
+# that the GDBtk has the correct line number.
+
+gdbtk_test srcwin-2.7 "goto function oof" {
+  $srcwin goto_func "" oof
+  set r 0
+
+  # now get a dump of all tags and check that only one line is
+  # marked BROWSE_TAG and no lines are STACK_TAG or PC_TAG.
+
+  # We know that list1.c should have BROWSE_TAG set at index 32.2
+  # for function "oof".  If list1.c is changed or the layout of the source
+  # window is changed, this must be updated.
+  if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+    foreach {k v i} $z {
+      if {$k == "tagon"} {
+	if {$v == "BROWSE_TAG"} {
+	  if {$i == "38.2"} {
+	    set line_number [$twin get "$i wordstart" "$i wordend"]
+	    if {$line_number == "38"} {
+	      incr r
+	    } else {
+	      incr r -100
+	    }
+	  } else {
+	    incr r 5
+	  }
+	}
+	if {$v == "STACK_TAG"} {incr r 10}
+	if {$v == "PC_TAG"} {incr r 100}
+      }
+    }
+  } else {
+    set r -1
+  }
+
+  if {$r == 1} {
+    # things are OK so far, so just verify the function name is displayed
+    # in the combobox entry field.
+    set names [$statbar.func get]
+    if {[string compare $names "oof"]} {set r -2}
+  }
+  set r
+} {1}
+
+# Test: srcwin-2.8
+# Desc: This test issues a next command while browsing list1.c.
+# It should display list0.c and highlight the correct line.
+gdbtk_test srcwin-2.8 "step while browsing" {
+  gdb_immediate "next" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.c"} {set r -1}
+  if {$func != "main"} {set r -2}
+
+  # check that correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file1(source) $a]} {set r -3}
+
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "11.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin-2.9
+# Desc: This test issues a next command while the current
+# PC is ready to call a function.  It should not go into the function and
+# should update the PC highlight correctly.
+gdbtk_test srcwin-2.9 "next" {
+  gdb_immediate "next" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.c"} {set r -1}
+  if {$func != "main"} {set r -2}
+
+  # check that correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file1(source) $a]} {set r -3}
+
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "12.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin-2.10
+# Desc: This test issues a step command while the current
+# PC is ready to call a function.  It should step into the function.
+gdbtk_test srcwin-2.10 "step" {
+  gdb_immediate "step" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that a new file is displayed
+  set twin [$stw test_get twin]
+  set file3(source) [$twin get 1.0 end]
+  if {![string compare $file1(source) $file3(source)]} {set r -3}
+
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin-2.11
+# Desc: This test issues a break and a continue
+gdbtk_test srcwin-2.11 "set BP and continue" {
+  gdb_immediate "break oof" 1
+  gdb_immediate "continue" 1
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  # we must clear the breakpoint first so it doesn't mess up the
+  # comparison...
+  gdb_immediate "clear oof" 1  
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+#####                       #####
+#                               #
+#  SECTION 3: Stack Operations  #
+#                               #
+#####                       #####
+
+# Test: srcwin-3.1
+# Desc: This tests "stack up" 
+gdbtk_test srcwin-3.1 "stack up (1)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "long_line"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    # return n + 1;
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {
+	    # oof (67);
+	    if {$i == "26.2"} {
+	      incr r
+	    } else {
+	      incr r 10
+	    }
+	  }
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {2}
+
+# Test: srcwin-3.2
+# Desc: Another "stack up"  test
+gdbtk_test srcwin-3.2 "stack up (2)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "bar"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    # return n + 1;
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {
+	    # long_line ();
+	    if {$i == "12.2"} {
+	      incr r
+	    } else {
+	      incr r 10
+	    }
+	  }
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {2}
+
+# Test: srcwin-3.3
+# Desc: Another "stack up"  test
+gdbtk_test srcwin-3.3 "stack up (3)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {![string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin-3.4
+# Desc: Another "stack up"  test
+gdbtk_test srcwin-3.4 "stack up (4)" {
+  $srcwin stack up
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.c"} {set r -1}
+  if {$func != "main"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file1(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "12.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Disabled for now because there are different correct results.
+# Test should be rewritten to include those.
+# Test: srcwin-3.5
+# Desc: "stack up" when we are at the top
+#gdbtk_test srcwin-3.5 "stack up when at the top" {
+#  $srcwin stack up
+#  set r 0
+#  set name [$statbar.name get]
+#  set func [$statbar.func get]
+#
+  # check contents of name and function comboboxes
+#  if {$name != "list0.c"} {set r -1}
+#  if {$func != "main"} {set r -2}
+
+  # check that the correct file is displayed
+#  set twin [$stw test_get twin]
+#  set a [$twin get 1.0 end]
+#  if {[string compare $file1(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+#  if {$r == 0} {
+#    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+#      foreach {k v i} $z {
+#	if {$k == "tagon"} {
+#	  if {$v == "STACK_TAG"} {
+#	    if {$i == "12.2"} {
+#	      incr r
+#	    } else {
+#	      incr r 5
+#	    }
+#	  }
+#	  if {$v == "PC_TAG"} {incr r 10}
+#	  if {$v == "BROWSE_TAG"} {incr r 100}
+#	}
+#      }
+#    } else {
+#      set r -4
+#    }
+#  }
+#  set r
+#} {1}
+
+# Test: srcwin-3.6
+# Desc: "stack down"  test
+gdbtk_test srcwin-3.6 "stack down" {
+  $srcwin stack down
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {![string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG and STACK_TAG on correct lines
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "STACK_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "PC_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin-3.7
+# Desc: "stack bottom"  test
+gdbtk_test srcwin-3.7 "stack bottom" {
+  $srcwin stack bottom
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# Test: srcwin-3.8
+# Desc: "stack down" when at bottom
+gdbtk_test srcwin-3.8 "stack down when at bottom" {
+  $srcwin stack down
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list1.c"} {set r -1}
+  if {$func != "oof"} {set r -2}
+
+  # check that the correct file is displayed
+  set twin [$stw test_get twin]
+  set a [$twin get 1.0 end]
+  if {[string compare $file2(source) $a]} {set r -3}
+  
+  # check for PC_TAG on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump -tag 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "38.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {1}
+
+# 4 -  BREAKPOINTS
+
+# Test: srcwin-4.1
+# Desc: Set BP in another file. Tests bp and cache functions
+gdbtk_test srcwin-4.1 "set BP in another file" {
+  gdb_immediate "break foo" 1
+  $srcwin goto_func "" foo
+  set r 0
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "BROWSE_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "PC_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  if {$i == "9.0"} {
+	    incr r
+	  } else {
+	    set r -200
+	  }
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  if {$r == 2} {
+    # clear BP and compare with previous contents. This should succeed,
+    gdb_immediate "clear foo" 1
+    set a [$twin get 1.0 end]
+    if {[string compare $file3(source) $a]} {set r -3}
+  }
+  
+  set r
+} {2}
+
+# Test: srcwin-4.2
+# Desc: Test temporary BP
+gdbtk_test srcwin-4.2 "temporary BP" {
+  set r 0
+  if {[catch {gdb_immediate "tbreak foo" 1} msg]} {
+    set r -500
+  }
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+  
+  # check contents of name and function comboboxes
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "BROWSE_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "PC_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  if {$i == "9.0"} {
+	    incr r
+	  } else {
+	    set r -200
+	  }
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  gdb_immediate "continue" 1
+  
+  # now check for PC_TAG and no image
+  if {$r == 2} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  set r -200
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  
+  set r
+} {3}
+
+# Test: srcwin-4.3
+# Desc: Test BP balloons
+gdbtk_test srcwin-4.3 "BP Balloons" {
+  # move pointer out of the way
+  warp_pointer . 0 0 
+  set r 0
+  gdb_immediate "break 10" 1
+  gdb_immediate "tbreak 10" 1
+
+  set twin [$stw test_get twin]
+  
+  # check for BROWSE_TAG and BP image on correct line
+  if {$r == 0} {
+    if {![catch {set z [$twin dump 1.0 end]}]} {
+      foreach {k v i} $z {
+	if {$k == "tagon"} {
+	  if {$v == "PC_TAG"} {
+	    if {$i == "9.2"} {
+	      incr r
+	    } else {
+	      incr r 5
+	    }
+	  }
+	  if {$v == "STACK_TAG"} {incr r 10}
+	  if {$v == "BROWSE_TAG"} {incr r 100}
+	} elseif {$k == "image"} {
+	  if {$i == "10.0"} {
+	    incr r
+	    # we found the bp image, now we will test the bp balloon messages
+	    set balloon [winfo toplevel [namespace tail $srcwin]].__balloon
+	    # shouldn't be mapped yet
+	    if {[winfo ismapped $balloon]} {
+	      set r -3000
+	      break
+	    }
+	    move_mouse_to $twin [$twin bbox $i]
+	    #wait a second for the balloon message to appear
+	    sleep 1
+	    if {![winfo ismapped $balloon]} {
+	      set r -4000
+	      break
+	    }
+	    # read the contents of the balloon and parse it into lines
+	    set a [split [$balloon.label cget -text] \n]
+	    set i 0
+	    # foreach line parse it and check the type and make sure it is enabled
+	    foreach line $a {
+	      if {[lindex $line 0] == "breakpoint"} {continue}
+	      incr i
+	      set enabled [lindex $line 0]
+	      set bptype [lindex $line 2]
+	      switch $i {
+		1 {
+		  if {$bptype != "donttouch"} {set r -1000}
+		}
+		2 {
+		  if {$bptype != "delete"} {set r -2000}
+		}
+	      }
+	    }
+	  } else {
+	    set r -200
+	  }
+	}
+      }
+    } else {
+      set r -4
+    }
+  }
+  set r
+} {2}
+
+#ManagedWin::open DebugWin
+
+# Test: srcwin-4.4
+# Desc: Click on line to set BP
+gdbtk_test srcwin-4.4 "Click on line to set BP" {
+  set r 0
+
+  # click mouse button 1 at index 20.1
+  if {![click $twin [$twin bbox 20.1] 1]} {
+    set r "Click failed on line 20.1"
+  } else {
+
+    # now look for BP at line 20
+    foreach bpnum [gdb_get_breakpoint_list] {
+      set bpinfo [gdb_get_breakpoint_info $bpnum]
+      lassign $bpinfo file func line pc type enabled disposition \
+	ignore_count commands cond thread hit_count
+      set file [lindex [file split $file] end]
+      if {$file == "list0.h"} {
+	if {$line == "20"} {
+	  if {$enabled == "1"} {incr r}
+	  if {$func == "foo"} {incr r}
+	  if {$type == "breakpoint"} {incr r}
+	  if {$disposition == "donttouch"} {incr r}
+	}
+      }
+    }
+  }
+  set r
+} {4}
+
+
+# Test: srcwin-4.5
+# Desc: Continue till here popup
+gdbtk_test srcwin-4.5 "Continue till here popup" {
+  set twin [$stw test_get twin]
+
+  # Get coordinates of line 16
+  set b [$twin bbox 16.1]
+  set y [expr {[lindex $b 1] + ([lindex $b 3] / 2)}]
+
+  # Continue to here
+  $stw continue_to_here $twin $y
+
+  # Where is the PC_TAG?
+  set pcs {}
+  set tags [$twin tag ranges PC_TAG]
+  foreach {start end} $tags {
+    lappend pcs [expr {int($start)}]
+  }
+
+  # Where are breakpoints?
+  set bps {}
+  set imgs [$twin dump -image 1.0 end]
+  foreach {foo bar line} $imgs {
+    lappend bps $line
+  }
+
+  list $pcs $bps
+} {16 {10.0 20.0}}
+
+# 5.1 balloon variables
+# Test: srcwin-5.1
+# Desc: variable balloon test
+# continues to BP at line 20 and checks to see that value was updated
+gdbtk_test srcwin-5.1 "variable balloon test" {
+  # move pointer out of the way
+  warp_pointer . 0 0 
+  set r 0
+  set twin [$stw test_get twin]
+
+  # move pointer to variable "x" and check balloon
+  set index [string first "x++" [$twin get 20.0 20.end]]
+  move_mouse_to $twin [$twin bbox 20.$index]
+  sleep 1
+  if {[winfo ismapped $balloon]} {
+    if {![string compare "x=9" [$balloon.label cget -text]]} {incr r}
+    gdb_immediate "continue" 1
+    sleep 1
+    if {![string compare "x=13" [$balloon.label cget -text]]} {incr r}
+  } else {
+    set r -1
+  }
+
+  set r
+} {2}
+
+# 6.1 mixed mode disassembly of include file
+# Test: srcwin-6.1
+# Desc: Some versions of GDBtk can't do mixed-mode disassembly of a function
+# that is in an include file. PR# mi/1101
+
+gdbtk_test srcwin-6.1 "mixed mode disassembly of include file (mi/1101)" {
+  set r 0
+  $srcwin mode "" MIXED
+
+  # check contents of name and function comboboxes
+  set name [$statbar.name get]
+  set func [$statbar.func get]
+  if {$name != "list0.h"} {set r -1}
+  if {$func != "foo"} {set r -2}
+  
+  # check contents of source window
+  set twin [$stw test_get twin]
+  set text [$twin get 1.0 end]
+  # Is it correct? I don't know.  Guess we look for some pieces of source...
+  if {[string first "static void" $text] != -1 &&
+      [string first "foo (x)" $text] != -1 &&
+      [string first "bar (x++);" $text] != -1} {
+    set r 1
+  }
+  
+  set r
+} {1}
+
+gdbtk_test_done
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/stack1.c stsgdb-6.8/gdb/testsuite/gdb.gdbtk/stack1.c
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/stack1.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/stack1.c	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,233 @@
+#include <stdlib.h>
+
+/* Functions defined in other files */
+extern void extern_func1_1 (int a, char *b, unsigned long c);
+
+/* Functions defined in this file */
+static void static_func_1  (int a, char *b, unsigned long c);
+static void static_func_2  (int a, char *b, unsigned long c);
+static void static_func_3  (int a, char *b, unsigned long c);
+static void static_func_4  (int a, char *b, unsigned long c);
+static void static_func_5  (int a, char *b, unsigned long c);
+static void static_func_6  (int a, char *b, unsigned long c);
+static void static_func_7  (int a, char *b, unsigned long c);
+static void static_func_8  (int a, char *b, unsigned long c);
+static void static_func_9  (int a, char *b, unsigned long c);
+static void static_func_10  (int a, char *b, unsigned long c);
+static void static_func_11  (int a, char *b, unsigned long c);
+static void static_func_12  (int a, char *b, unsigned long c);
+static void static_func_13  (int a, char *b, unsigned long c);
+static void static_func_14  (int a, char *b, unsigned long c);
+static void static_func_15  (int a, char *b, unsigned long c);
+
+void func_1  (int a, char *b, unsigned long c);
+void func_2  (int a, char *b, unsigned long c);
+void func_3  (int a, char *b, unsigned long c);
+void func_4  (int a, char *b, unsigned long c);
+void func_5  (int a, char *b, unsigned long c);
+void func_6  (int a, char *b, unsigned long c);
+void func_7  (int a, char *b, unsigned long c);
+void func_8  (int a, char *b, unsigned long c);
+void func_9  (int a, char *b, unsigned long c);
+void func_10  (int a, char *b, unsigned long c);
+void func_11  (int a, char *b, unsigned long c);
+void func_12  (int a, char *b, unsigned long c);
+void func_13  (int a, char *b, unsigned long c);
+void func_14  (int a, char *b, unsigned long c);
+void func_15  (int a, char *b, unsigned long c);
+
+int
+main (int argc, char *argv[])
+{
+  int a;
+  char *b;
+  unsigned long c;
+
+  a = 1;
+  b = "This is a string.";
+  c = 0xdeadL;
+
+  func_1 (a, b, c);
+
+  exit (0);
+}
+
+void
+func_1 (int a, char *b, unsigned long c)
+{
+  func_2 (a, b, c);
+}
+
+void
+func_2 (int a, char *b, unsigned long c)
+{
+  func_3 (a, b, c);
+}
+
+void
+func_3 (int a, char *b, unsigned long c)
+{
+  func_4 (a, b, c);
+}
+
+void
+func_4 (int a, char *b, unsigned long c)
+{
+  func_5 (a, b, c);
+}
+
+void
+func_5 (int a, char *b, unsigned long c)
+{
+  func_6 (a, b, c);
+}
+
+void
+func_6 (int a, char *b, unsigned long c)
+{
+  func_7 (a, b, c);
+}
+
+void
+func_7 (int a, char *b, unsigned long c)
+{
+  func_8 (a, b, c);
+}
+
+void
+func_8 (int a, char *b, unsigned long c)
+{
+  func_9 (a, b, c);
+}
+
+void
+func_9 (int a, char *b, unsigned long c)
+{
+  func_10 (a, b, c);
+}
+
+void
+func_10 (int a, char *b, unsigned long c)
+{
+  func_11 (a, b, c);
+}
+
+void
+func_11 (int a, char *b, unsigned long c)
+{
+  func_12 (a, b, c);
+}
+
+void
+func_12 (int a, char *b, unsigned long c)
+{
+  func_13 (a, b, c);
+}
+
+void
+func_13 (int a, char *b, unsigned long c)
+{
+  func_14 (a, b, c);
+}
+
+void
+func_14 (int a, char *b, unsigned long c)
+{
+  func_15 (a, b, c);
+}
+
+void
+func_15 (int a, char *b, unsigned long c)
+{
+  static_func_1 (a, b, c);
+}
+
+static void
+static_func_1 (int a, char *b, unsigned long c)
+{
+  static_func_2 (a, b, c);
+}
+
+static void
+static_func_2 (int a, char *b, unsigned long c)
+{
+  static_func_3 (a, b, c);
+}
+
+static void
+static_func_3 (int a, char *b, unsigned long c)
+{
+  static_func_4 (a, b, c);
+}
+
+static void
+static_func_4 (int a, char *b, unsigned long c)
+{
+  static_func_5 (a, b, c);
+}
+
+static void
+static_func_5 (int a, char *b, unsigned long c)
+{
+  static_func_6 (a, b, c);
+}
+
+static void
+static_func_6 (int a, char *b, unsigned long c)
+{
+  static_func_7 (a, b, c);
+}
+
+static void
+static_func_7 (int a, char *b, unsigned long c)
+{
+  static_func_8 (a, b, c);
+}
+
+static void
+static_func_8 (int a, char *b, unsigned long c)
+{
+  static_func_9 (a, b, c);
+}
+
+static void
+static_func_9 (int a, char *b, unsigned long c)
+{
+  static_func_10 (a, b, c);
+}
+
+static void
+static_func_10 (int a, char *b, unsigned long c)
+{
+  static_func_11 (a, b, c);
+}
+
+static void
+static_func_11 (int a, char *b, unsigned long c)
+{
+  static_func_12 (a, b, c);
+}
+
+static void
+static_func_12 (int a, char *b, unsigned long c)
+{
+  static_func_13 (a, b, c);
+}
+
+static void
+static_func_13 (int a, char *b, unsigned long c)
+{
+  static_func_14 (a, b, c);
+}
+
+static void
+static_func_14 (int a, char *b, unsigned long c)
+{
+  static_func_15 (a, b, c);
+}
+
+static void
+static_func_15 (int a, char *b, unsigned long c)
+{
+  extern_func1_1 (a, b, c);
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/stack2.c stsgdb-6.8/gdb/testsuite/gdb.gdbtk/stack2.c
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/stack2.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/stack2.c	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,107 @@
+/* Functions defined in this file */
+void extern_func1_1 (int, char *, unsigned long);
+void extern_func1_2 (int, char *, unsigned long);
+void extern_func1_3 (int, char *, unsigned long);
+void extern_func1_4 (int, char *, unsigned long);
+void extern_func1_5 (int, char *, unsigned long);
+void extern_func1_6 (int, char *, unsigned long);
+void extern_func1_7 (int, char *, unsigned long);
+void extern_func1_8 (int, char *, unsigned long);
+void extern_func1_9 (int, char *, unsigned long);
+void extern_func1_10 (int, char *, unsigned long);
+void extern_func1_11 (int, char *, unsigned long);
+void extern_func1_12 (int, char *, unsigned long);
+void extern_func1_13 (int, char *, unsigned long);
+void extern_func1_14 (int, char *, unsigned long);
+void extern_func1_15 (int, char *, unsigned long);
+
+void
+extern_func1_1 (int a, char *b, unsigned long c)
+{
+  extern_func1_2 (a, b, c);
+}
+
+void
+extern_func1_2 (int a, char *b, unsigned long c)
+{
+  extern_func1_3 (a, b, c);
+}
+
+void
+extern_func1_3 (int a, char *b, unsigned long c)
+{
+  extern_func1_4 (a, b, c);
+}
+
+void
+extern_func1_4 (int a, char *b, unsigned long c)
+{
+  extern_func1_5 (a, b, c);
+}
+
+void
+extern_func1_5 (int a, char *b, unsigned long c)
+{
+  extern_func1_6 (a, b, c);
+}
+
+void
+extern_func1_6 (int a, char *b, unsigned long c)
+{
+  extern_func1_7 (a, b, c);
+}
+
+void
+extern_func1_7 (int a, char *b, unsigned long c)
+{
+  extern_func1_8 (a, b, c);
+}
+
+void
+extern_func1_8 (int a, char *b, unsigned long c)
+{
+  extern_func1_9 (a, b, c);
+}
+
+void
+extern_func1_9 (int a, char *b, unsigned long c)
+{
+  extern_func1_10 (a, b, c);
+}
+
+void
+extern_func1_10 (int a, char *b, unsigned long c)
+{
+  extern_func1_11 (a, b, c);
+}
+
+void
+extern_func1_11 (int a, char *b, unsigned long c)
+{
+  extern_func1_12 (a, b, c);
+}
+
+void
+extern_func1_12 (int a, char *b, unsigned long c)
+{
+  extern_func1_13 (a, b, c);
+}
+
+void
+extern_func1_13 (int a, char *b, unsigned long c)
+{
+  extern_func1_14 (a, b, c);
+}
+
+void
+extern_func1_14 (int a, char *b, unsigned long c)
+{
+  extern_func1_15 (a, b, c);
+}
+
+void
+extern_func1_15 (int a, char *b, unsigned long c)
+{
+  /* THE END */
+  return;
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/windows.exp stsgdb-6.8/gdb/testsuite/gdb.gdbtk/windows.exp
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/windows.exp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/windows.exp	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,41 @@
+# Copyright 2001, 2004 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License (GPL) as published by
+# the Free Software Foundation; either version 2 of the License, or (at
+# your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+load_lib ../gdb.gdbtk/insight-support.exp
+
+if {[gdbtk_initialize_display]} {
+  if {$tracelevel} {
+    strace $tracelevel
+  }
+
+  #
+  # Basic window tests (basic as in, "do they open")
+  #
+  set prms_id 0
+  set bug_id 0
+
+  set srcfile [file join $srcdir $subdir c_variable.c]
+  set binfile [file join $objdir $subdir c_variable]
+  set r [gdb_compile $srcfile $binfile executable {debug}]
+  if  { $r != "" } {
+    gdb_suppress_entire_file \
+      "Testcase compile failed, so some tests in this file will automatically fail."
+  }
+
+  # Start with a fresh gdbtk
+  gdb_exit
+  set results [gdbtk_start [file join $srcdir $subdir windows.test]]
+  set results [split $results \n]
+
+  # Analyze results
+  gdbtk_done $results
+}
diff -Naur gdb-6.8/gdb/testsuite/gdb.gdbtk/windows.test stsgdb-6.8/gdb/testsuite/gdb.gdbtk/windows.test
--- gdb-6.8/gdb/testsuite/gdb.gdbtk/windows.test	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/gdb/testsuite/gdb.gdbtk/windows.test	2008-09-11 10:34:44.000000000 +0100
@@ -0,0 +1,131 @@
+# Basic window tests
+# Copyright 2001, 2003 Red Hat, Inc.
+#
+# This Program Is Free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@prep.ai.mit.edu
+
+# This file was written by Keith Seitz (keiths@cygnus.com)
+
+# Read in the standard defs file
+if {![gdbtk_read_defs]} {
+  break
+}
+
+global objdir test_ran
+
+# Windows to test
+# FIXME: TfindArgs needs to be updated before it can go in the list...
+set windows [list BpWin BrowserWin Console DebugWin KodWin LocalsWin \
+	     MemWin ProcessWin RegWin StackWin TdumpWin WatchWin]
+
+# Dialogs to test
+# FIXME: ActionhDlg,TraceDlg cannot be independently opened
+set dialogs [list About AttachDlg GlobalPref SrcPref TargetSelection]
+
+# Helper proc to do all the testing
+proc do_open_close {num winlist} {
+  set i 1
+  foreach win $winlist {
+
+    # Test: windows-$num.*
+    # Desc: Open each window before running
+    set win_obj ""
+    gdbtk_test windows-$num.$i "open $win before running" {
+      set err [catch {ManagedWin::open $win} txt]
+      if {$err} {
+	# display error
+	set txt
+      } else {
+	# display "0"
+	set win_obj $txt
+	set err
+      }
+    } {0}
+
+    # Update screen
+    update idletasks
+
+    # Test: windows-{$num+1}.*
+    # Desc: Close each window before running
+    gdbtk_test windows-[expr {$num+1}].$i "close $win before running" {
+      set err [catch {delete object $win_obj} txt]
+      if {$err} {
+	# display error
+	set txt
+      } else {
+	# display "0"
+	set err
+      }
+    } {0}
+
+    # Update screen
+    update idletasks
+    incr i
+  }
+}
+
+#
+# Tests start here
+#
+
+# Counter for tests. Increment by 2 after each call to do_open_close.
+set num 1
+
+#
+# Check if all windows open with no file loaded
+#
+do_open_close $num $windows
+incr num 2
+
+# Sadly, there is no good way to unpost dialogs (except for setting
+# an after callback). Until something better comes along, skip them.
+# do_open_close $num $dialogs
+# incr num 2
+
+#
+# Check if all windows open with file loaded
+#
+
+# Load in a file
+set program [file join $objdir c_variable]
+if {[catch {gdbtk_test_file $program} t]} {
+  # This isn't a test case, since if this fails, we're hosed.
+  gdbtk_test_error "loading \"$program\": $t"
+}
+
+do_open_close $num $windows
+incr num 2
+#do_open_close $num $dialogs
+incr num 2
+
+#
+# Check if all windows open after running
+#
+
+# Break in main and run
+gdb_cmd "break main"
+gdbtk_test_run
+
+do_open_close $num $windows
+incr num 2
+#do_open_close $num $dialogs
+#incr num 2
+
+#
+#  Exit
+#
+gdbtk_test_done
diff -Naur gdb-6.8/gdb/testsuite/gdb.mi/mi-var-cmd.exp stsgdb-6.8/gdb/testsuite/gdb.mi/mi-var-cmd.exp
--- gdb-6.8/gdb/testsuite/gdb.mi/mi-var-cmd.exp	2008-01-01 22:53:20.000000000 +0000
+++ stsgdb-6.8/gdb/testsuite/gdb.mi/mi-var-cmd.exp	2008-09-11 10:34:50.000000000 +0100
@@ -1,5 +1,6 @@
 # Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008
 # Free Software Foundation, Inc.
+# Copyright (C) 2008 STMicroelectronics
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -645,11 +646,11 @@
 # Allow this to succeed whether the value is readable, unreadable, or
 # missing.  Most important is that GDB does not crash.
 mi_gdb_test "-var-update endvar" \
-    {(\^done,changelist=\[.*\]|^".*".*\^error,msg=".*not found")} \
+    {(\^done,changelist=\[.*\]|&".*".*\^error,msg=".*not found")} \
     "update endvar"
 
 mi_gdb_test "-var-delete endvar" \
-    "\\^done,ndeleted=\"1\"" \
+    {(\^done,ndeleted="1"|&".*".*\^error,msg=".*not found")} \
     "delete endvar"
 
 mi_gdb_exit
diff -Naur gdb-6.8/gdb/thread.c stsgdb-6.8/gdb/thread.c
--- gdb-6.8/gdb/thread.c	2008-03-12 22:22:06.000000000 +0000
+++ stsgdb-6.8/gdb/thread.c	2008-09-11 10:35:35.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 1986, 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    Contributed by Lynx Real-Time Systems, Inc.  Los Gatos, CA.
 
@@ -221,7 +222,7 @@
   struct thread_info *tp;
 
   for (tp = thread_list; tp; tp = tp->next)
-    if (tp->num == num)
+    if (tp->num == num && thread_alive (tp))
       return 1;
 
   return 0;
@@ -441,9 +442,14 @@
       if (extra_info)
 	printf_filtered (" (%s)", extra_info);
       puts_filtered ("  ");
-      /* That switch put us at the top of the stack (leaf frame).  */
-      switch_to_thread (tp->ptid);
-      print_stack_frame (get_selected_frame (NULL), 0, LOCATION);
+      if ( arg && strcmp(arg, "nostackframe") == 0 )
+        puts_filtered ("\n");
+      else
+        { 
+          /* That switch put us at the top of the stack (leaf frame).  */
+          switch_to_thread (tp->ptid);
+          print_stack_frame (get_selected_frame (NULL), 0, LOCATION);
+        }
     }
 
   /* Restores the current thread and the frame selected before
diff -Naur gdb-6.8/gdb/top.c stsgdb-6.8/gdb/top.c
--- gdb-6.8/gdb/top.c	2008-01-01 22:53:13.000000000 +0000
+++ stsgdb-6.8/gdb/top.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -364,6 +365,50 @@
 }
 #endif
 
+
+#define ENV_DELIMITER_BEGIN  "${"
+#define ENV_DELIMITER_END  "}"
+static char*
+evaluate_environment_from_string (char* input)
+{
+  char *p1, *p2, *output, *env_var, *env_var_value;
+  int env_var_len, delimiter_begin_len, delimiter_end_len;
+
+  p1 = (char *) strstr (input, ENV_DELIMITER_BEGIN);
+  if (p1 == NULL)
+    return input;
+
+  p2 = (char *) strstr (p1+1, ENV_DELIMITER_END);
+  if (p2 == NULL)
+    return input;
+
+  delimiter_begin_len = strlen (ENV_DELIMITER_BEGIN);
+  delimiter_end_len = strlen (ENV_DELIMITER_END);
+  /* get the env var.  */
+  env_var_len = p2 - p1 - delimiter_begin_len;
+  env_var = xmalloc (env_var_len + 1);
+  strncpy (env_var, p1 + delimiter_begin_len, env_var_len);
+  env_var[env_var_len] = 0;
+
+  /* get its value.  */
+  env_var_value = getenv (env_var);
+  if (env_var_value == NULL) {
+    xfree (env_var);
+    return input;
+  }
+
+  /* replace this value into the original string.  */
+  output = xmalloc (strlen (input) + strlen (env_var_value) - env_var_len 
+                    - delimiter_begin_len - delimiter_end_len + 1);
+  strncpy (output, input, p1-input);
+  strcpy (output+(p1-input), env_var_value);
+  strcat (output+(p1-input), p2 + delimiter_end_len);
+  
+  xfree (env_var);
+  return evaluate_environment_from_string (output);
+}
+
+ 
 /* Execute the line P as a command.
    Pass FROM_TTY as second argument to the defining function.  */
 
@@ -374,7 +419,6 @@
   enum language flang;
   static int warned = 0;
   char *line;
-  
   free_all_values ();
 
   /* Force cleanup of any alloca areas if using C alloca instead of
@@ -385,6 +429,7 @@
   if (p == NULL)
     return;
 
+  p = evaluate_environment_from_string (p);
   target_log_command (p);
 
   while (*p == ' ' || *p == '\t')
diff -Naur gdb-6.8/gdb/tui/tui-io.c stsgdb-6.8/gdb/tui/tui-io.c
--- gdb-6.8/gdb/tui/tui-io.c	2008-01-01 22:53:22.000000000 +0000
+++ stsgdb-6.8/gdb/tui/tui-io.c	2008-09-11 10:34:29.000000000 +0100
@@ -2,6 +2,7 @@
 
    Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
    Contributed by Hewlett-Packard Company.
 
@@ -114,7 +115,8 @@
 
 /* For gdb 5.3, prefer to continue the pipe hack as a backup wheel.  */
 #define TUI_USE_PIPE_FOR_READLINE
-/* #undef TUI_USE_PIPE_FOR_READLINE */
+/* Remove pipe stuff so we can use the TUI on windows.  */
+#undef TUI_USE_PIPE_FOR_READLINE
 
 /* TUI output files.  */
 static struct ui_file *tui_stdout;
diff -Naur gdb-6.8/gdb/utils.c stsgdb-6.8/gdb/utils.c
--- gdb-6.8/gdb/utils.c	2008-01-01 22:53:13.000000000 +0000
+++ stsgdb-6.8/gdb/utils.c	2008-09-11 10:35:35.000000000 +0100
@@ -1158,7 +1158,7 @@
      question we're asking, and then answer "yes" automatically.  This
      way, important error messages don't get lost when talking to GDB
      over a pipe.  */
-  if (! input_from_terminal_p ())
+  if (! input_from_terminal_p () && ! source_file_name)
     {
       wrap_here ("");
       vfprintf_filtered (gdb_stdout, ctlstr, args);
diff -Naur gdb-6.8/gdb/valops.c stsgdb-6.8/gdb/valops.c
--- gdb-6.8/gdb/valops.c	2008-02-04 00:23:04.000000000 +0000
+++ stsgdb-6.8/gdb/valops.c	2008-09-11 10:35:35.000000000 +0100
@@ -574,11 +574,10 @@
   CORE_ADDR addr = VALUE_ADDRESS (val) + value_offset (val);
   int length = TYPE_LENGTH (value_enclosing_type (val));
 
-  struct type *type = value_type (val);
+  set_value_lazy (val, 0);
   if (length)
     read_memory (addr, value_contents_all_raw (val), length);
 
-  set_value_lazy (val, 0);
   return 0;
 }
 
diff -Naur gdb-6.8/gdb/value.c stsgdb-6.8/gdb/value.c
--- gdb-6.8/gdb/value.c	2008-01-18 17:07:40.000000000 +0000
+++ stsgdb-6.8/gdb/value.c	2008-09-11 10:35:35.000000000 +0100
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -826,6 +827,7 @@
       switch (TYPE_CODE (type))
 	{
 	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
 	case TYPE_CODE_PTR:
 	  /* Reverse the bytes.  */
 	  for (i = 0, j = TYPE_LENGTH (type) - 1; i < j; i++, j--)
@@ -1739,6 +1741,12 @@
   return val->initialized;
 }
 
+/* This is just for backwards compatibility.  */
+static void
+keep_variable_command (char *ignored, int from_tty)
+{
+}
+
 void
 _initialize_values (void)
 {
@@ -1762,4 +1770,7 @@
 Set an internal VARIABLE to the result of the EXPRESSION if it does not\n\
 exist or does not contain a value.  The EXPRESSION is not evaluated if the\n\
 VARIABLE is already initialized."));
+
+  add_com ("keep-variable", no_class, keep_variable_command,
+	   _("Ignored. Kept for backwards compatibility."));
 }
diff -Naur gdb-6.8/gdb/version.in stsgdb-6.8/gdb/version.in
--- gdb-6.8/gdb/version.in	2008-03-27 18:06:49.000000000 +0000
+++ stsgdb-6.8/gdb/version.in	2008-09-11 10:35:35.000000000 +0100
@@ -1 +1 @@
-6.8
+6.8-ST-2.0
diff -Naur gdb-6.8/include/ChangeLog.sts-gdb stsgdb-6.8/include/ChangeLog.sts-gdb
--- gdb-6.8/include/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/include/ChangeLog.sts-gdb	2008-09-11 10:32:51.000000000 +0100
@@ -0,0 +1,7 @@
+2006-03-20  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* libiberty.h: Fix build failure with -Werror when NOT on Windows.
+
+2006-03-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* libiberty.h: Add definition for cygpath.c.
diff -Naur gdb-6.8/include/elf/ChangeLog.sts-gdb stsgdb-6.8/include/elf/ChangeLog.sts-gdb
--- gdb-6.8/include/elf/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/include/elf/ChangeLog.sts-gdb	2008-09-11 10:32:48.000000000 +0100
@@ -0,0 +1,3 @@
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh.h: Add st40-300 variants.
diff -Naur gdb-6.8/include/elf/sh.h stsgdb-6.8/include/elf/sh.h
--- gdb-6.8/include/elf/sh.h	2005-05-10 11:21:10.000000000 +0100
+++ stsgdb-6.8/include/elf/sh.h	2008-09-11 10:32:48.000000000 +0100
@@ -1,5 +1,6 @@
 /* SH ELF support for BFD.
    Copyright 1998, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -22,7 +23,7 @@
 
 /* Processor specific flags for the ELF header e_flags field.  */
 
-#define EF_SH_MACH_MASK	0x1f
+#define EF_SH_MACH_MASK	0x3f
 #define EF_SH_UNKNOWN	   0 /* For backwards compatibility.  */
 #define EF_SH1		   1
 #define EF_SH2		   2
@@ -47,6 +48,12 @@
 #define EF_SH2A_SH4        23
 #define EF_SH2A_SH3E       24
 
+#define EF_ST40_300_SH2A_NOFPU 50
+#define EF_ST40_300_SH4A_NOFPU 51
+#define EF_ST40_300_NOFPU      52
+#define EF_ST40_300_SH4A       53
+#define EF_ST40_300            54
+
 /* This one can only mix in objects from other EF_SH5 objects.  */
 #define EF_SH5		  10
 
@@ -77,7 +84,15 @@
 /* EF_SH2A_SH4_NOFPU    */ bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu, \
 /* EF_SH2A_SH3_NOFPU    */ bfd_mach_sh2a_nofpu_or_sh3_nommu, \
 /* EF_SH2A_SH4          */ bfd_mach_sh2a_or_sh4 , \
-/* EF_SH2A_SH3E         */ bfd_mach_sh2a_or_sh3e
+/* EF_SH2A_SH3E         */ bfd_mach_sh2a_or_sh3e, \
+/* 25 - 29              */ 0, 0, 0, 0, 0, \
+/* 30 - 39              */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+/* 40 - 49              */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+/* EF_ST40_300_SH2A_NOFPU */ bfd_mach_st40_300_nofpu_or_sh2a_nofpu, \
+/* EF_ST40_300_SH4A_NOFPU */ bfd_mach_st40_300_nofpu_or_sh4a_nofpu, \
+/* EF_ST40_300_NOFPU    */ bfd_mach_st40_300_nofpu, \
+/* EF_ST40_300_SH4A     */ bfd_mach_st40_300_or_sh4a, \
+/* EF_ST40_300          */ bfd_mach_st40_300
 
 /* Convert arch_sh* into EF_SH*.  */
 int sh_find_elf_flags (unsigned int arch_set);
diff -Naur gdb-6.8/include/libiberty.h stsgdb-6.8/include/libiberty.h
--- gdb-6.8/include/libiberty.h	2007-09-06 18:22:36.000000000 +0100
+++ stsgdb-6.8/include/libiberty.h	2008-09-11 10:32:51.000000000 +0100
@@ -1,6 +1,7 @@
 /* Function declarations for libiberty.
 
    Copyright 2001, 2002, 2005, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2007 STMicroelectronics
    
    Note - certain prototypes declared in this header file are for
    functions whoes implementation copyright does not belong to the
@@ -650,5 +651,28 @@
 }
 #endif
 
+#ifdef __MINGW32__
+char *cygpath (const char *path);
+void cygpath_replace (char **path);
+
+/* The following macros are just to prevent putting #ifdef MINGW everywhere.
+   You still need to if you don't want to overwite the original pointer.  */
+
+/* Reassign the pointer PATH without freeing anything.  */
+#define CYGPATH(path) do {path = cygpath (path);} while(0)
+
+/* Free memory. Intended to be used in conjunction with CYGPATH().  */
+#define CYGPATH_FREE(path) free (path)
+
+/* Reassign the pointer PATH and free the previous content.  */
+#define CYGPATH_REPLACE(path) cygpath_replace (path)
+
+#else
+/* If these were properly empty statements then there might be warnings
+   which would kill a -Werror build.  */
+#define CYGPATH(path) do {} while (0)
+#define CYGPATH_FREE(path) do {} while (0)
+#define CYGPATH_REPLACE(path) do {} while (0)
+#endif
 
 #endif /* ! defined (LIBIBERTY_H) */
diff -Naur gdb-6.8/libdecnumber/aclocal.m4 stsgdb-6.8/libdecnumber/aclocal.m4
--- gdb-6.8/libdecnumber/aclocal.m4	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/aclocal.m4	2008-09-11 10:32:00.000000000 +0100
@@ -11,5 +11,6 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+m4_include([../config/override.m4])
 m4_include([../config/stdint.m4])
 m4_include([../config/warnings.m4])
diff -Naur gdb-6.8/libdecnumber/bid/host-ieee128.c stsgdb-6.8/libdecnumber/bid/host-ieee128.c
--- gdb-6.8/libdecnumber/bid/host-ieee128.c	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/bid/host-ieee128.c	2008-09-11 10:31:59.000000000 +0100
@@ -29,20 +29,35 @@
 
 #include <string.h>
 
+#include "dconfig.h"
 #include "bid-dpd.h"
 #include "decimal128.h"
 
 void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);
 void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);
 
+/* The code for converting 128-bit values between DPD and BID presumes
+   that the 64-bit halves of the 128-bit value are in little-endian
+   order, so they need swapping on big-endian hosts.  */
+
 void
 __host_to_ieee_128 (_Decimal128 in, decimal128 *out)
 {
+#if WORDS_BIGENDIAN
+  memcpy ((char *) out, (char *) &in + 8, 8);
+  memcpy ((char *) out + 8, (char *) &in, 8);
+#else
   memcpy ((char *) out, (char *) &in, 16);
+#endif
 }
 
 void
 __ieee_to_host_128 (decimal128 in, _Decimal128 *out)
 {
+#if WORDS_BIGENDIAN
+  memcpy ((char *) out, (char *) &in + 8, 8);
+  memcpy ((char *) out + 8, (char *) &in, 8);
+#else
   memcpy ((char *) out, (char *) &in, 16);
+#endif
 }
diff -Naur gdb-6.8/libdecnumber/ChangeLog stsgdb-6.8/libdecnumber/ChangeLog
--- gdb-6.8/libdecnumber/ChangeLog	2008-01-25 19:05:42.000000000 +0000
+++ stsgdb-6.8/libdecnumber/ChangeLog	2008-09-11 10:32:00.000000000 +0100
@@ -1,3 +1,35 @@
+2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.in ($(srcdir)/aclocal.m4): Update dependencies.
+	* configure: Regenerate.
+
+2008-06-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.in (datarootdir): New variable.
+
+2008-06-10  Joseph Myers  <joseph@codesourcery.com>
+
+	* dconfig.h: New.
+	* decContext.c, decExcept.c, decExcept.h, decLibrary.c,
+	decNumber.c, decNumberLocal.h, decRound.c, dpd/decimal128.c,
+	dpd/decimal32.c, dpd/decimal64.c: Include dconfig.h not config.h.
+	* dpd/decimal128Local.h (decimal128SetSign, decimal128ClearSign,
+	decimal128FlipSign): Use WORDS_BIGENDIAN not
+	FLOAT_WORDS_BIG_ENDIAN.
+	* bid/host-ieee128.c: Include dconfig.h.
+	(__host_to_ieee_128, __ieee_to_host_128): Swap 64-bit halves of
+	value if WORDS_BIGENDIAN.
+
+2008-04-18  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/35457
+	* aclocal.m4: Regenerate.
+	* configure: Regenerate.
+
+2008-04-18  Ben Elliston  <bje@au.ibm.com>
+
+	* Makefile.in (distclean): Add gstdint.h.
+
 2008-01-25  Janis Johnson  <janis187@us.ibm.com>
 
 	* decCommonSymbols.h: Commit.
diff -Naur gdb-6.8/libdecnumber/configure stsgdb-6.8/libdecnumber/configure
--- gdb-6.8/libdecnumber/configure	2007-10-31 18:37:19.000000000 +0000
+++ stsgdb-6.8/libdecnumber/configure	2008-09-11 10:32:00.000000000 +0100
@@ -313,6 +313,7 @@
 
 ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS SET_MAKE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT RANLIB ac_ct_RANLIB ACLOCAL AUTOCONF AUTOHEADER WARN_CFLAGS WARN_PEDANTIC WERROR CPP EGREP MAINT build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os enable_decimal_float ADDITIONAL_OBJS LIBOBJS LTLIBOBJS'
 ac_subst_files=''
+ac_pwd=`pwd`
 
 # Initialize some variables set by options.
 ac_init_help=
@@ -1252,13 +1253,22 @@
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
-	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+        # differences in whitespace do not lead to failure.
+        ac_old_val_w=`echo x $ac_old_val`
+        ac_new_val_w=`echo x $ac_new_val`
+        if test "$ac_old_val_w" != "$ac_new_val_w"; then
+          { echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
 echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
-echo "$as_me:   former value:  $ac_old_val" >&2;}
-	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
-echo "$as_me:   current value: $ac_new_val" >&2;}
-	ac_cache_corrupted=:
+          ac_cache_corrupted=:
+        else
+          { echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+          eval $ac_var=\$ac_old_val
+        fi
+        { echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
+echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+        { echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
+echo "$as_me:   current value: \`$ac_new_val'" >&2;}
       fi;;
   esac
   # Pass precious variables to config.status.
@@ -1275,6 +1285,8 @@
   fi
 done
 if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
 echo "$as_me: error: changes in the environment can compromise the build" >&2;}
   { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
@@ -1315,6 +1327,9 @@
 
 
 
+
+
+
 case ../config in
   [\\/]* | ?:[\\/]* ) ac_macro_dir=../config         ;;
   *)                      ac_macro_dir=$srcdir/../config ;;
@@ -1666,11 +1681,13 @@
 fi
 
 
-test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+test -z "$CC" && { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&5
 echo "$as_me: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 
 # Provide some information about the compiler.
 echo "$as_me:$LINENO:" \
@@ -1756,11 +1773,13 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: C compiler cannot create executables
 See \`config.log' for more details." >&5
 echo "$as_me: error: C compiler cannot create executables
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
+   { (exit 77); exit 77; }; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
@@ -1785,13 +1804,15 @@
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+	{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
     fi
   fi
 fi
@@ -1829,11 +1850,13 @@
   esac
 done
 else
-  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
@@ -1880,11 +1903,13 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
@@ -2872,11 +2897,13 @@
 if $ac_preproc_ok; then
   :
 else
-  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&5
 echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 ac_ext=c
@@ -4313,19 +4340,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_void_p=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (void *), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -4383,11 +4414,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -4731,19 +4764,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_long=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -4801,11 +4838,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5149,19 +5188,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -5219,11 +5262,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5563,19 +5608,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_short=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -5633,11 +5682,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5977,19 +6028,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_char=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (char), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -6047,11 +6102,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -6637,19 +6694,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -6707,11 +6768,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -7051,19 +7114,23 @@
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_long=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -7121,11 +7188,13 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
diff -Naur gdb-6.8/libdecnumber/dconfig.h stsgdb-6.8/libdecnumber/dconfig.h
--- gdb-6.8/libdecnumber/dconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/libdecnumber/dconfig.h	2008-09-11 10:32:00.000000000 +0100
@@ -0,0 +1,52 @@
+/* Configure decNumber for either host or target.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2, or (at your option) any later
+   version.
+
+   In addition to the permissions in the GNU General Public License,
+   the Free Software Foundation gives you unlimited permission to link
+   the compiled version of this file into combinations with other
+   programs, and to distribute those combinations without any
+   restriction coming from the use of this file.  (The General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into a combine executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifdef IN_LIBGCC2
+
+#include "tconfig.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#ifndef LIBGCC2_WORDS_BIG_ENDIAN
+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN
+#endif
+
+#ifndef LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
+#define LIBGCC2_FLOAT_WORDS_BIG_ENDIAN LIBGCC2_WORDS_BIG_ENDIAN
+#endif
+
+#if LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
+#define WORDS_BIGENDIAN 1
+#endif
+
+#else
+
+#include "config.h"
+
+#endif
diff -Naur gdb-6.8/libdecnumber/decContext.c stsgdb-6.8/libdecnumber/decContext.c
--- gdb-6.8/libdecnumber/decContext.c	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/decContext.c	2008-09-11 10:32:00.000000000 +0100
@@ -37,7 +37,7 @@
 
 #include <string.h>	      /* for strcmp */
 #include <stdio.h>	      /* for printf if DECCHECK */
-#include "config.h"	      /* for GCC definitions */
+#include "dconfig.h"	      /* for GCC definitions */
 #include "decContext.h"	      /* context and base types */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
 
diff -Naur gdb-6.8/libdecnumber/decExcept.c stsgdb-6.8/libdecnumber/decExcept.c
--- gdb-6.8/libdecnumber/decExcept.c	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/decExcept.c	2008-09-11 10:32:00.000000000 +0100
@@ -28,7 +28,7 @@
    02110-1301, USA.  */
 
 #include <fenv.h>
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 #include "decExcept.h"
 
diff -Naur gdb-6.8/libdecnumber/decExcept.h stsgdb-6.8/libdecnumber/decExcept.h
--- gdb-6.8/libdecnumber/decExcept.h	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/decExcept.h	2008-09-11 10:32:00.000000000 +0100
@@ -28,7 +28,7 @@
    02110-1301, USA.  */
 
 #include <fenv.h>
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 
 #define DFP_EXCEPTIONS_ENABLED 1
diff -Naur gdb-6.8/libdecnumber/decLibrary.c stsgdb-6.8/libdecnumber/decLibrary.c
--- gdb-6.8/libdecnumber/decLibrary.c	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/decLibrary.c	2008-09-11 10:32:00.000000000 +0100
@@ -27,7 +27,7 @@
    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 #include "decimal128.h"
 #include "decimal64.h"
diff -Naur gdb-6.8/libdecnumber/decNumber.c stsgdb-6.8/libdecnumber/decNumber.c
--- gdb-6.8/libdecnumber/decNumber.c	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/decNumber.c	2008-09-11 10:32:00.000000000 +0100
@@ -170,7 +170,7 @@
 #include <stdio.h>		   /* for printf [if needed] */
 #include <string.h>		   /* for strcpy */
 #include <ctype.h>		   /* for lower */
-#include "config.h"		   /* for GCC definitions */
+#include "dconfig.h"		   /* for GCC definitions */
 #include "decNumber.h"		   /* base number library */
 #include "decNumberLocal.h"	   /* decNumber local types, etc. */
 
diff -Naur gdb-6.8/libdecnumber/decNumberLocal.h stsgdb-6.8/libdecnumber/decNumberLocal.h
--- gdb-6.8/libdecnumber/decNumberLocal.h	2008-01-25 19:05:42.000000000 +0000
+++ stsgdb-6.8/libdecnumber/decNumberLocal.h	2008-09-11 10:32:00.000000000 +0100
@@ -44,7 +44,7 @@
 
   #include <stdlib.h>	      /* for abs			      */
   #include <string.h>	      /* for memset, strcpy		      */
-  #include "config.h"	      /* for WORDS_BIGENDIAN                  */
+  #include "dconfig.h"	      /* for WORDS_BIGENDIAN                  */
 
   /* Conditional code flag -- set this to match hardware platform     */
   /* 1=little-endian, 0=big-endian	                              */
diff -Naur gdb-6.8/libdecnumber/decRound.c stsgdb-6.8/libdecnumber/decRound.c
--- gdb-6.8/libdecnumber/decRound.c	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/decRound.c	2008-09-11 10:32:00.000000000 +0100
@@ -28,7 +28,7 @@
    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 #include "decRound.h"
 
diff -Naur gdb-6.8/libdecnumber/dpd/decimal128.c stsgdb-6.8/libdecnumber/dpd/decimal128.c
--- gdb-6.8/libdecnumber/dpd/decimal128.c	2008-01-25 19:05:44.000000000 +0000
+++ stsgdb-6.8/libdecnumber/dpd/decimal128.c	2008-09-11 10:32:00.000000000 +0100
@@ -42,7 +42,7 @@
 #include <string.h>	      /* [for memset/memcpy] */
 #include <stdio.h>	      /* [for printf] */
 
-#include "config.h"	      /* GCC definitions */
+#include "dconfig.h"	      /* GCC definitions */
 #define	 DECNUMDIGITS 34      /* make decNumbers with space for 34 */
 #include "decNumber.h"	      /* base number library */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
diff -Naur gdb-6.8/libdecnumber/dpd/decimal128Local.h stsgdb-6.8/libdecnumber/dpd/decimal128Local.h
--- gdb-6.8/libdecnumber/dpd/decimal128Local.h	2007-10-11 19:15:02.000000000 +0100
+++ stsgdb-6.8/libdecnumber/dpd/decimal128Local.h	2008-09-11 10:32:00.000000000 +0100
@@ -34,14 +34,14 @@
 
 /* Set sign; this assumes the sign was previously zero.  */
 #define decimal128SetSign(d,b) \
-  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] |= ((unsigned) (b) << 7); }
+  { (d)->bytes[WORDS_BIGENDIAN ? 0 : 15] |= ((unsigned) (b) << 7); }
 
 /* Clear sign.  */
 #define decimal128ClearSign(d) \
-  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] &= ~0x80; }
+  { (d)->bytes[WORDS_BIGENDIAN ? 0 : 15] &= ~0x80; }
 
 /* Flip sign.  */
 #define decimal128FlipSign(d) \
-  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] ^= 0x80; }
+  { (d)->bytes[WORDS_BIGENDIAN ? 0 : 15] ^= 0x80; }
 
 #endif
diff -Naur gdb-6.8/libdecnumber/dpd/decimal32.c stsgdb-6.8/libdecnumber/dpd/decimal32.c
--- gdb-6.8/libdecnumber/dpd/decimal32.c	2008-01-25 19:05:44.000000000 +0000
+++ stsgdb-6.8/libdecnumber/dpd/decimal32.c	2008-09-11 10:32:00.000000000 +0100
@@ -42,7 +42,7 @@
 #include <string.h>	      /* [for memset/memcpy] */
 #include <stdio.h>	      /* [for printf] */
 
-#include "config.h"	      /* GCC definitions */
+#include "dconfig.h"	      /* GCC definitions */
 #define	 DECNUMDIGITS  7      /* make decNumbers with space for 7 */
 #include "decNumber.h"	      /* base number library */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
diff -Naur gdb-6.8/libdecnumber/dpd/decimal64.c stsgdb-6.8/libdecnumber/dpd/decimal64.c
--- gdb-6.8/libdecnumber/dpd/decimal64.c	2008-01-25 19:05:44.000000000 +0000
+++ stsgdb-6.8/libdecnumber/dpd/decimal64.c	2008-09-11 10:32:00.000000000 +0100
@@ -42,7 +42,7 @@
 #include <string.h>	      /* [for memset/memcpy] */
 #include <stdio.h>	      /* [for printf] */
 
-#include "config.h"	      /* GCC definitions */
+#include "dconfig.h"	      /* GCC definitions */
 #define	 DECNUMDIGITS 16      /* make decNumbers with space for 16 */
 #include "decNumber.h"	      /* base number library */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
diff -Naur gdb-6.8/libdecnumber/gstdint.h stsgdb-6.8/libdecnumber/gstdint.h
--- gdb-6.8/libdecnumber/gstdint.h	2008-03-27 18:25:08.000000000 +0000
+++ stsgdb-6.8/libdecnumber/gstdint.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,47 +0,0 @@
-/* generated for  gcc (GCC) 3.4.6 20060404 (Red Hat 3.4.6-9) */
-
-#ifndef GCC_GENERATED_STDINT_H
-#define GCC_GENERATED_STDINT_H 1
-
-#include <sys/types.h>
-#include <stdint.h>
-/* glibc uses these symbols as guards to prevent redefinitions.  */
-#ifdef __int8_t_defined
-#define _INT8_T
-#define _INT16_T
-#define _INT32_T
-#endif
-#ifdef __uint32_t_defined
-#define _UINT32_T
-#endif
-
-
-/* Some systems have guard macros to prevent redefinitions, define them.  */
-#ifndef _INT8_T
-#define _INT8_T
-#endif
-#ifndef _INT16_T
-#define _INT16_T
-#endif
-#ifndef _INT32_T
-#define _INT32_T
-#endif
-#ifndef _UINT8_T
-#define _UINT8_T
-#endif
-#ifndef _UINT16_T
-#define _UINT16_T
-#endif
-#ifndef _UINT32_T
-#define _UINT32_T
-#endif
-
-/* system headers have good uint64_t and int64_t */
-#ifndef _INT64_T
-#define _INT64_T
-#endif
-#ifndef _UINT64_T
-#define _UINT64_T
-#endif
-
-#endif /* GCC_GENERATED_STDINT_H */
diff -Naur gdb-6.8/libdecnumber/Makefile.in stsgdb-6.8/libdecnumber/Makefile.in
--- gdb-6.8/libdecnumber/Makefile.in	2008-01-25 19:05:42.000000000 +0000
+++ stsgdb-6.8/libdecnumber/Makefile.in	2008-09-11 10:32:00.000000000 +0100
@@ -44,6 +44,7 @@
 RANLIB = @RANLIB@
 SHELL = @SHELL@
 
+datarootdir = @datarootdir@
 datadir = @datadir@
 exec_prefix = @prefix@
 libdir = @libdir@
@@ -95,7 +96,7 @@
 	cd $(srcdir) && $(AUTOCONF)
 
 $(srcdir)/aclocal.m4: @MAINT@ $(srcdir)/../config/stdint.m4 \
-	$(srcdir)/../config/warnings.m4 \
+	$(srcdir)/../config/warnings.m4 $(srcdir)/../config/override.m4 \
 	$(srcdir)/configure.ac
 	cd $(srcdir) && $(ACLOCAL) -I ../config
 
@@ -151,7 +152,7 @@
 distclean: clean
 	-rm -f config.h stamp-h1 config.status config.cache config.log \
 	  configure.lineno configure.status.lineno Makefile localedir.h \
-	  localedir.hs
+	  localedir.hs gstdint.h
 
 maintainer-clean: distclean
 	@echo "This command is intended for maintainers to use"
diff -Naur gdb-6.8/libiberty/ChangeLog.sts-gdb stsgdb-6.8/libiberty/ChangeLog.sts-gdb
--- gdb-6.8/libiberty/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/libiberty/ChangeLog.sts-gdb	2008-09-11 10:32:56.000000000 +0100
@@ -0,0 +1,12 @@
+2006-05-15  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cygpath.c (cygpath): Convert pathnames consisting only of a
+	drive specifier to a valid directory (e.g 'c:' -> 'c:/').
+
+2006-03-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cygpath.c: New file.
+	* config/mh-mingw: New file.
+	* configure.ac: Add mh-mingw makefile fragment when host is MinGW.
+	* configure: Regenerate.
+	* Makefile.in: Add cygpath.[co] .
diff -Naur gdb-6.8/libiberty/config/mh-mingw stsgdb-6.8/libiberty/config/mh-mingw
--- gdb-6.8/libiberty/config/mh-mingw	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/libiberty/config/mh-mingw	2008-09-11 10:32:55.000000000 +0100
@@ -0,0 +1 @@
+EXTRA_OFILES=cygpath.o
diff -Naur gdb-6.8/libiberty/configure stsgdb-6.8/libiberty/configure
--- gdb-6.8/libiberty/configure	2007-07-17 19:05:02.000000000 +0100
+++ stsgdb-6.8/libiberty/configure	2008-09-11 10:32:56.000000000 +0100
@@ -3696,6 +3696,7 @@
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [ -n "${frag}" ]; then
diff -Naur gdb-6.8/libiberty/configure.ac stsgdb-6.8/libiberty/configure.ac
--- gdb-6.8/libiberty/configure.ac	2007-07-17 19:05:02.000000000 +0100
+++ stsgdb-6.8/libiberty/configure.ac	2008-09-11 10:32:56.000000000 +0100
@@ -184,6 +184,7 @@
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [[ -n "${frag}" ]]; then
diff -Naur gdb-6.8/libiberty/cygpath.c stsgdb-6.8/libiberty/cygpath.c
--- gdb-6.8/libiberty/cygpath.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/libiberty/cygpath.c	2008-09-11 10:32:56.000000000 +0100
@@ -0,0 +1,358 @@
+/* Basic Cygwin pathname support for MinGW.
+
+   Copyright (C) 2006 STMicroelectronics
+
+   This file is part of the libiberty library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.
+
+
+   This file implements a limited amount of support for Cygwin paths.
+   It is intended for use by MinGW programs that must interact with Cygwin.
+
+   It is limited to absolute paths only.  I.e. Those beginning with Cygwin
+   mounts, such as /cygdrive/...  See the comment on cygpath() below.  */
+
+#include "libiberty.h"
+#include <string.h>
+#include <ctype.h>
+#include <windows.h>
+
+
+/* These are all the possible settings for the ST_CYGPATH_MODE
+   environment variable.  */
+static enum
+{
+  mode_unset,
+  mode_off,
+  mode_normal,
+  mode_full
+} mode = mode_unset;
+
+
+/* These are the values extracted from the registry.
+   They are extracted the first time cygpath is called.  */
+static const char *cygdrive = NULL;
+static struct mount
+{
+  /* The name of the Cygwin mount point.  E.g. "/usr/bin"  */
+  char *mount;
+
+  /* The actual Windows path that the mount translates to.  */
+  char *actual;
+
+  struct mount *next;
+} *mounts = NULL;
+
+
+/* Read a string from the Windows Registry.
+   KEY should be a valid handle from RegOpenKeyEx().
+   NAME should be the name of the value within the key.
+   The value should be of type REG_SZ.
+   If the value does not exist, is of the wrong typei, or another error
+   occurs, then NULL is returned.
+   Otherwise a malloced string is returned.  */
+static char *
+read_string_from_registry (HKEY key, const char *name)
+{
+  DWORD valuetype = REG_NONE;
+  DWORD valuesize = 0;
+  char *value = NULL;
+
+  if (RegQueryValueEx (key, name, NULL, &valuetype,
+		       NULL, &valuesize) == ERROR_SUCCESS
+      && valuetype == REG_SZ)
+    {
+      value = xmalloc (valuesize);
+      if (RegQueryValueEx (key, name, NULL, &valuetype, (unsigned char *)value,
+			   &valuesize) != ERROR_SUCCESS)
+	{
+	  free (value);
+	  value = NULL;
+	}
+    }
+
+  return value;
+}
+
+
+/* Fill in the mounts list (mounts is defined statically above).
+   All subkeys (not values) of KEY that contain a REG_SZ value named 'native'
+   are added to the start of the mounts list.  */
+static void
+read_mounts (HKEY key)
+{
+  int mountsize = 15;
+  char *mount = xmalloc (mountsize);
+  DWORD size = mountsize;
+  int index = 0;
+  int retval = 0;
+
+  /* For each subkey ...  */
+  while ((retval = RegEnumKeyEx (key, index, mount, &size, 0, NULL, 0, NULL))
+	 != ERROR_NO_MORE_ITEMS)
+    {
+      struct mount *newmount;
+      HKEY subkey;
+      char *actual;
+
+      switch (retval) {
+      case ERROR_MORE_DATA:
+	/* The buffer wasn't large enough for this key name.
+	   Unlike RegQueryValueEx, RegEnumKeyEx won't tell us how big it
+	   should be, so just make it bigger and try again.
+	   Note that this code path does NOT increment index.
+       	   Most of the time we will only be dealing with short strings.  */
+	mountsize += 10;
+	mount = xrealloc (mount, mountsize);
+	break;
+
+      case ERROR_SUCCESS:
+	/* Find the actual windows path.  */
+  	if (RegOpenKeyEx (key, mount, 0, KEY_READ, &subkey) != ERROR_SUCCESS)
+	  {
+	    index++;
+	    break;
+	  }
+	actual = read_string_from_registry (subkey, "native");	
+	RegCloseKey (subkey);
+	if (actual == NULL)
+	  {
+	    index++;
+	    break;
+	  }
+
+	/* Create the new entry in the mount table.  */
+	newmount = xmalloc (sizeof (struct mount));
+	newmount->mount = xstrdup (mount);
+	newmount->actual = actual;
+	newmount->next = mounts;
+	mounts = newmount;
+	index++;
+	break;
+
+      default:
+	/* Don't infinite loop should any other return value occur.  */
+        index++;
+      }
+
+      /* The last call to RegEnumKeyEx may have clobbered size.
+         Fix it before the next call.  */
+      size = mountsize;
+    }
+
+  free (mount);
+}
+
+
+/* The top level registry reading function.
+   Open the keys, call the above functions to get the right values,
+   and clean up.  */
+static void
+read_registry (void)
+{
+  HKEY hcu_key, hlm_key;
+
+  /* Get key handles for the two places cygwin keeps its registry data.  */
+  if (RegOpenKeyEx (HKEY_CURRENT_USER,
+		    "Software\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hcu_key) != ERROR_SUCCESS)
+    hcu_key = NULL;
+
+  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
+		    "SOFTWARE\\Cygnus Solutions\\Cygwin\\mounts v2",
+		    0, KEY_READ, &hlm_key) != ERROR_SUCCESS)
+    hlm_key = NULL;
+
+  /* Get the virtual mount point used for windows drives.  */
+  if (hcu_key)
+    cygdrive = read_string_from_registry (hcu_key, "cygdrive prefix");
+  if (hlm_key && cygdrive == NULL)
+    cygdrive = read_string_from_registry (hlm_key, "cygdrive prefix");
+
+  /* Read the other mount points.
+     Read hlm before hcu to ensure hcu settings get used by preference
+     by being closer on the mounts stack.  */
+  if (hlm_key)
+    read_mounts (hlm_key);
+  if (hcu_key)
+    read_mounts (hcu_key);
+
+  if (hlm_key)
+    RegCloseKey (hlm_key);
+  if (hcu_key)
+    RegCloseKey (hcu_key);
+}
+
+
+/* Given a path of unknown variety, return the same path with any
+   Cygwin mount points substituted.
+   This function always returns a malloced string which should be
+   freed when the the caller is finished with it.
+
+   The mapping is affected by the ST_CYGPATH_MODE environment variable.
+   See the fprintf messages below for full information.
+
+   It can replace /cygdrive/<letter>/..... style pathnames, even if the
+   user has used 'mount -c' to an alternative string.
+
+   It can replace (if enabled) other Cygwin mount points, such as
+   the usual '/', '/usr/bin', '/usr/lib', as well as any other user defined
+   mount points.
+
+   It does NOT attempt to convert any pathnames that look like native Windows
+   names - such as those starting with '<letter>:' or double slash (UNC).
+
+   It does NOT handle relative pathnames passing through cygwin mounts
+   (e.g. '../cygdrive/c'), or absolute paths with repeated directory
+   separators or relative elements within the mount name
+   (e.g. '/usr/./bin').
+   
+   It does NOT allow backslash \ directory separators within the actual mount
+   path (e.g. '/usr\bin').  Cygwin does not always allow them there either.  */
+char *
+cygpath (const char *path)
+{
+  char *result = NULL;
+
+  if (path == NULL)
+    return NULL;
+
+  /* If this is the first time this function has been called then read the
+     environment and registry.  */
+  if (mode == mode_unset)
+    {
+      char *env = getenv ("ST_CYGPATH_MODE");
+
+      if (env == NULL || strcmp (env, "normal") == 0)
+    	mode = mode_normal;
+      else if (strcmp (env, "full") == 0)
+	mode = mode_full;
+      else if (strcmp (env, "off") == 0)
+	mode = mode_off;
+
+      if (mode != mode_off)
+	read_registry();
+
+      if (mode == mode_unset)
+	{
+	  /* The variable was set, but not to any known value.
+	     Set up a default and print an informational message
+	     for the user.  */
+	  mode = mode_normal;
+	  fprintf (stderr, "ST_CYGPATH_MODE should be one of:\n");
+	  fprintf (stderr, " off    - Disable all path translation.\n");
+	  fprintf (stderr, " normal - Translate %s only.\n", cygdrive);
+	  fprintf (stderr, " full   - Translate all Cygwin mounts.\n");
+	}
+    }
+
+  /* First, test if this can only be a windows (non-cygwin) path.
+     This includes paths that start with a drive letter or UNC double slash.  */
+  if ((isalpha (path[0]) && path[1] == ':')
+      || ((path[0] == '\\' || path[0] == '/')
+	  && (path[1] == '\\' || path[1] == '/')))
+    result = xstrdup (path);
+
+  /* Second, handle /cygdrive/<letter>/ (or whatever) paths.  */
+  if (!result && cygdrive != NULL && (mode == mode_normal || mode == mode_full))
+    {
+      int length = strlen (cygdrive);
+      /* Note that cygwin does not allow '\\' instead of '/' in cygdrive.  */
+      if (strncmp (cygdrive, path, length) == 0
+	  && (path[length] == '/' || path[length] == '\\'
+	      || path[length] == '\0')
+	  && isalpha (path[length+1]))
+        {
+	  result = xmalloc (strlen (path) - length+1 + 1);
+	  result[0] = path[length+1];
+	  result[1] = ':';
+	  strcpy (result + 2, path + length + 2);
+	}
+    }
+
+  /* Third, handle other types of cygwin path.  */
+  if (!result && mounts != NULL && mode == mode_full)
+    {
+      int matched = 0;
+      struct mount *foundat = NULL;
+      struct mount *mount = mounts;
+      /* Find the longest matching mount point.
+	 This is important. If we just used the first matching mount point
+	 it would probably always match '/' when '/usr/bin' is right.
+	 Use the first of equal length matches - this allows current-user
+	 mounts to override 'local machine' mounts (can this happen?).
+         It is a match only if the matching part is followed by a directory
+         separator or the end of the path, except for the root mount point.  */
+      while (mount != NULL)
+	{
+	  int length = strlen (mount->mount);
+	  if (strncmp (mount->mount, path, length) == 0
+	      && matched < length
+	      && (length == 1 /* Special case for root mount point '/'.  */
+		  || path[length] == '/' || path[length] == '\\'
+		  || path[length] == '\0'))
+	    {
+	      matched = length;
+	      foundat = mount;
+	    }
+	  mount = mount->next;
+	}
+      if (matched)
+	{
+	  /* There was a match so do the substitution.
+	     If matched is 1 then it can only be the root mount point, in
+	     which case we do not want to remove the matched part as it is the 
+	     directory separator.  */
+	  if (matched == 1)
+	    matched = 0;
+	  result = xmalloc (strlen (foundat->actual) + strlen (path) + 1
+			    - matched);
+	  strcpy (result, foundat->actual);
+	  strcat (result, path + matched);
+	}
+    }
+
+  if (result)
+    {
+      /* Ensure that the return is never just a drive letter.
+	 This is not a valid directory on Windows, but code often
+	 trims trailing slashes.  */
+      int length = strlen(result);
+      if (result[length-1] == ':')
+	{
+	  result = xrealloc (result, length+2);
+	  result[length] = '/';
+	  result[length+1] = '\0';
+	}
+      return result;
+    }
+
+  /* If we get here then it must have been some other kind of path.  */
+  return xstrdup (path);
+}
+
+
+/* This is just to make inserting the conversion more convenient.
+   The CYGPATH_REPLACE is conditionally compiled so it is harder to
+   add clean up code to go with it without this.  */
+void
+cygpath_replace (char **path)
+{
+  char *result = cygpath (*path);
+  free (*path);
+  *path = result;
+}
diff -Naur gdb-6.8/libiberty/Makefile.in stsgdb-6.8/libiberty/Makefile.in
--- gdb-6.8/libiberty/Makefile.in	2007-07-25 07:36:27.000000000 +0100
+++ stsgdb-6.8/libiberty/Makefile.in	2008-09-11 10:32:56.000000000 +0100
@@ -4,6 +4,7 @@
 # Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
 # 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software
 # Foundation
+#   Copyright (C) 2007 STMicroelectronics
 #
 # This file is part of the libiberty library.
 # Libiberty is free software; you can redistribute it and/or
@@ -124,7 +125,7 @@
 CFILES = alloca.c argv.c asprintf.c atexit.c				\
 	basename.c bcmp.c bcopy.c bsearch.c bzero.c			\
 	calloc.c choose-temp.c clock.c concat.c cp-demangle.c		\
-	 cp-demint.c cplus-dem.c					\
+	 cp-demint.c cplus-dem.c cygpath.c				\
 	dyn-string.c							\
 	fdmatch.c ffs.c fibheap.c filename_cmp.c floatformat.c		\
 	fnmatch.c fopen_unlocked.c					\
@@ -180,7 +181,7 @@
 # maint-missing" and "make check".
 CONFIGURED_OFILES = ./asprintf.o ./atexit.o				\
 	./basename.o ./bcmp.o ./bcopy.o ./bsearch.o ./bzero.o		\
-	./calloc.o ./clock.o ./copysign.o				\
+	./calloc.o ./clock.o ./copysign.o cygpath.o			\
 	./_doprnt.o							\
 	./ffs.o								\
 	./getcwd.o ./getpagesize.o ./gettimeofday.o			\
@@ -615,6 +616,12 @@
 	else true; fi
 	$(COMPILE.c) $(srcdir)/cplus-dem.c $(OUTPUT_OPTION)
 
+./cygpath.o: $(srcdir)/cygpath.c $(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h
+	if [ x"$(PICFLAG)" != x ]; then \
+	  $(COMPILE.c) $(PICFLAG) $(srcdir)/cygpath.c -o pic/$@; \
+	else true; fi
+	$(COMPILE.c) $(srcdir)/cygpath.c $(OUTPUT_OPTION)
+
 ./dyn-string.o: $(srcdir)/dyn-string.c stamp-h $(INCDIR)/ansidecl.h \
 	$(INCDIR)/dyn-string.h $(INCDIR)/libiberty.h
 	if [ x"$(PICFLAG)" != x ]; then \
diff -Naur gdb-6.8/Makefile.def stsgdb-6.8/Makefile.def
--- gdb-6.8/Makefile.def	2008-02-20 14:26:58.000000000 +0000
+++ stsgdb-6.8/Makefile.def	2008-09-11 10:35:42.000000000 +0100
@@ -6,6 +6,8 @@
 //
 //   Copyright 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation
 //
+//   Copyright (C) 2007 STMicroelectronics 
+//
 // This file is free software; you can redistribute it and/or modify
 // it under the terms of the GNU General Public License as published by
 // the Free Software Foundation; either version 2 of the License, or
@@ -117,6 +119,14 @@
                 missing=maintainer-clean; };
 host_modules= { module= utils; no_check=true; };
 host_modules= { module= gnattools; };
+host_modules= { module= pdcurses; no_check=true; no_install=true;
+                missing=mostlyclean;
+                missing=distclean;
+                missing=maintainer-clean;
+                missing=info;
+                missing=dvi;
+                missing=TAGS;
+                missing=installcheck; };
 
 target_modules = { module= libstdc++-v3; lib_path=.libs; raw_cxx=true; };
 target_modules = { module= libmudflap; lib_path=.libs; };
@@ -318,6 +328,7 @@
 // Host modules specific to gdb.
 dependencies = { module=configure-gdb; on=all-intl; };
 dependencies = { module=configure-gdb; on=configure-sim; };
+dependencies = { module=configure-gdb; on=configure-pdcurses; };
 dependencies = { module=configure-gdb; on=all-bfd; };
 dependencies = { module=all-gdb; on=all-libiberty; };
 dependencies = { module=all-gdb; on=all-opcodes; };
@@ -326,6 +337,12 @@
 dependencies = { module=all-gdb; on=all-build-byacc; };
 dependencies = { module=all-gdb; on=all-sim; };
 dependencies = { module=all-gdb; on=all-libdecnumber; };
+dependencies = { module=all-gdb; on=all-pdcurses; };
+
+dependencies = { module=install-gdb; on=install-tcl; };
+dependencies = { module=install-gdb; on=install-tk; };
+dependencies = { module=install-gdb; on=install-itcl; };
+dependencies = { module=install-gdb; on=install-libgui; };
 
 dependencies = { module=configure-libgui; on=configure-tcl; };
 dependencies = { module=configure-libgui; on=configure-tk; };
diff -Naur gdb-6.8/Makefile.in stsgdb-6.8/Makefile.in
--- gdb-6.8/Makefile.in	2008-03-27 18:23:26.000000000 +0000
+++ stsgdb-6.8/Makefile.in	2008-09-11 10:35:42.000000000 +0100
@@ -698,7 +698,8 @@
     maybe-configure-tk \
     maybe-configure-libtermcap \
     maybe-configure-utils \
-    maybe-configure-gnattools
+    maybe-configure-gnattools \
+    maybe-configure-pdcurses
 .PHONY: configure-target
 configure-target:  \
     maybe-configure-target-libstdc++-v3 \
@@ -849,6 +850,7 @@
 all-host: maybe-all-libtermcap
 all-host: maybe-all-utils
 all-host: maybe-all-gnattools
+all-host: maybe-all-pdcurses
 
 .PHONY: all-target
 
@@ -962,6 +964,7 @@
 info-host: maybe-info-libtermcap
 info-host: maybe-info-utils
 info-host: maybe-info-gnattools
+info-host: maybe-info-pdcurses
 
 .PHONY: info-target
 
@@ -1068,6 +1071,7 @@
 dvi-host: maybe-dvi-libtermcap
 dvi-host: maybe-dvi-utils
 dvi-host: maybe-dvi-gnattools
+dvi-host: maybe-dvi-pdcurses
 
 .PHONY: dvi-target
 
@@ -1174,6 +1178,7 @@
 pdf-host: maybe-pdf-libtermcap
 pdf-host: maybe-pdf-utils
 pdf-host: maybe-pdf-gnattools
+pdf-host: maybe-pdf-pdcurses
 
 .PHONY: pdf-target
 
@@ -1280,6 +1285,7 @@
 html-host: maybe-html-libtermcap
 html-host: maybe-html-utils
 html-host: maybe-html-gnattools
+html-host: maybe-html-pdcurses
 
 .PHONY: html-target
 
@@ -1386,6 +1392,7 @@
 TAGS-host: maybe-TAGS-libtermcap
 TAGS-host: maybe-TAGS-utils
 TAGS-host: maybe-TAGS-gnattools
+TAGS-host: maybe-TAGS-pdcurses
 
 .PHONY: TAGS-target
 
@@ -1492,6 +1499,7 @@
 install-info-host: maybe-install-info-libtermcap
 install-info-host: maybe-install-info-utils
 install-info-host: maybe-install-info-gnattools
+install-info-host: maybe-install-info-pdcurses
 
 .PHONY: install-info-target
 
@@ -1598,6 +1606,7 @@
 install-pdf-host: maybe-install-pdf-libtermcap
 install-pdf-host: maybe-install-pdf-utils
 install-pdf-host: maybe-install-pdf-gnattools
+install-pdf-host: maybe-install-pdf-pdcurses
 
 .PHONY: install-pdf-target
 
@@ -1704,6 +1713,7 @@
 install-html-host: maybe-install-html-libtermcap
 install-html-host: maybe-install-html-utils
 install-html-host: maybe-install-html-gnattools
+install-html-host: maybe-install-html-pdcurses
 
 .PHONY: install-html-target
 
@@ -1810,6 +1820,7 @@
 installcheck-host: maybe-installcheck-libtermcap
 installcheck-host: maybe-installcheck-utils
 installcheck-host: maybe-installcheck-gnattools
+installcheck-host: maybe-installcheck-pdcurses
 
 .PHONY: installcheck-target
 
@@ -1916,6 +1927,7 @@
 mostlyclean-host: maybe-mostlyclean-libtermcap
 mostlyclean-host: maybe-mostlyclean-utils
 mostlyclean-host: maybe-mostlyclean-gnattools
+mostlyclean-host: maybe-mostlyclean-pdcurses
 
 .PHONY: mostlyclean-target
 
@@ -2022,6 +2034,7 @@
 clean-host: maybe-clean-libtermcap
 clean-host: maybe-clean-utils
 clean-host: maybe-clean-gnattools
+clean-host: maybe-clean-pdcurses
 
 .PHONY: clean-target
 
@@ -2128,6 +2141,7 @@
 distclean-host: maybe-distclean-libtermcap
 distclean-host: maybe-distclean-utils
 distclean-host: maybe-distclean-gnattools
+distclean-host: maybe-distclean-pdcurses
 
 .PHONY: distclean-target
 
@@ -2234,6 +2248,7 @@
 maintainer-clean-host: maybe-maintainer-clean-libtermcap
 maintainer-clean-host: maybe-maintainer-clean-utils
 maintainer-clean-host: maybe-maintainer-clean-gnattools
+maintainer-clean-host: maybe-maintainer-clean-pdcurses
 
 .PHONY: maintainer-clean-target
 
@@ -2393,7 +2408,8 @@
     maybe-check-tk \
     maybe-check-libtermcap \
     maybe-check-utils \
-    maybe-check-gnattools
+    maybe-check-gnattools \
+    maybe-check-pdcurses
 
 .PHONY: check-target
 check-target:  \
@@ -2525,7 +2541,8 @@
     maybe-install-tk \
     maybe-install-libtermcap \
     maybe-install-utils \
-    maybe-install-gnattools
+    maybe-install-gnattools \
+    maybe-install-pdcurses
 
 .PHONY: install-host
 install-host:  \
@@ -2598,7 +2615,8 @@
     maybe-install-tk \
     maybe-install-libtermcap \
     maybe-install-utils \
-    maybe-install-gnattools
+    maybe-install-gnattools \
+    maybe-install-pdcurses
 
 .PHONY: install-target
 install-target:  \
@@ -39687,6 +39705,310 @@
 
 
 
+.PHONY: configure-pdcurses maybe-configure-pdcurses
+maybe-configure-pdcurses:
+@if gcc-bootstrap
+configure-pdcurses: stage_current
+@endif gcc-bootstrap
+@if pdcurses
+maybe-configure-pdcurses: configure-pdcurses
+configure-pdcurses: 
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	test ! -f $(HOST_SUBDIR)/pdcurses/Makefile || exit 0; \
+	$(SHELL) $(srcdir)/mkinstalldirs $(HOST_SUBDIR)/pdcurses ; \
+	$(HOST_EXPORTS) \
+	echo Configuring in $(HOST_SUBDIR)/pdcurses; \
+	cd "$(HOST_SUBDIR)/pdcurses" || exit 1; \
+	case $(srcdir) in \
+	  /* | [A-Za-z]:[\\/]*) topdir=$(srcdir) ;; \
+	  *) topdir=`echo $(HOST_SUBDIR)/pdcurses/ | \
+		sed -e 's,\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \
+	esac; \
+	srcdiroption="--srcdir=$${topdir}/pdcurses"; \
+	libsrcdir="$$s/pdcurses"; \
+	$(SHELL) $${libsrcdir}/configure \
+	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
+	  --target=${target_alias} $${srcdiroption}  \
+	  || exit 1
+@endif pdcurses
+
+
+
+
+
+.PHONY: all-pdcurses maybe-all-pdcurses
+maybe-all-pdcurses:
+@if gcc-bootstrap
+all-pdcurses: stage_current
+@endif gcc-bootstrap
+@if pdcurses
+TARGET-pdcurses=all
+maybe-all-pdcurses: all-pdcurses
+all-pdcurses: configure-pdcurses
+	@: $(MAKE); $(unstage)
+	@r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_HOST_FLAGS)  \
+		$(TARGET-pdcurses))
+@endif pdcurses
+
+
+
+
+.PHONY: check-pdcurses maybe-check-pdcurses
+maybe-check-pdcurses:
+@if pdcurses
+maybe-check-pdcurses: check-pdcurses
+
+check-pdcurses:
+
+@endif pdcurses
+
+.PHONY: install-pdcurses maybe-install-pdcurses
+maybe-install-pdcurses:
+@if pdcurses
+maybe-install-pdcurses: install-pdcurses
+
+install-pdcurses:
+
+@endif pdcurses
+
+# Other targets (info, dvi, pdf, etc.)
+
+.PHONY: maybe-info-pdcurses info-pdcurses
+maybe-info-pdcurses:
+@if pdcurses
+maybe-info-pdcurses: info-pdcurses
+
+# pdcurses doesn't support info.
+info-pdcurses:
+
+@endif pdcurses
+
+.PHONY: maybe-dvi-pdcurses dvi-pdcurses
+maybe-dvi-pdcurses:
+@if pdcurses
+maybe-dvi-pdcurses: dvi-pdcurses
+
+# pdcurses doesn't support dvi.
+dvi-pdcurses:
+
+@endif pdcurses
+
+.PHONY: maybe-pdf-pdcurses pdf-pdcurses
+maybe-pdf-pdcurses:
+@if pdcurses
+maybe-pdf-pdcurses: pdf-pdcurses
+
+pdf-pdcurses: \
+    configure-pdcurses 
+	@: $(MAKE); $(unstage)
+	@[ -f ./pdcurses/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing pdf in pdcurses" ; \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          pdf) \
+	  || exit 1
+
+@endif pdcurses
+
+.PHONY: maybe-html-pdcurses html-pdcurses
+maybe-html-pdcurses:
+@if pdcurses
+maybe-html-pdcurses: html-pdcurses
+
+html-pdcurses: \
+    configure-pdcurses 
+	@: $(MAKE); $(unstage)
+	@[ -f ./pdcurses/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing html in pdcurses" ; \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          html) \
+	  || exit 1
+
+@endif pdcurses
+
+.PHONY: maybe-TAGS-pdcurses TAGS-pdcurses
+maybe-TAGS-pdcurses:
+@if pdcurses
+maybe-TAGS-pdcurses: TAGS-pdcurses
+
+# pdcurses doesn't support TAGS.
+TAGS-pdcurses:
+
+@endif pdcurses
+
+.PHONY: maybe-install-info-pdcurses install-info-pdcurses
+maybe-install-info-pdcurses:
+@if pdcurses
+maybe-install-info-pdcurses: install-info-pdcurses
+
+install-info-pdcurses: \
+    configure-pdcurses \
+    info-pdcurses 
+	@: $(MAKE); $(unstage)
+	@[ -f ./pdcurses/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-info in pdcurses" ; \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-info) \
+	  || exit 1
+
+@endif pdcurses
+
+.PHONY: maybe-install-pdf-pdcurses install-pdf-pdcurses
+maybe-install-pdf-pdcurses:
+@if pdcurses
+maybe-install-pdf-pdcurses: install-pdf-pdcurses
+
+install-pdf-pdcurses: \
+    configure-pdcurses \
+    pdf-pdcurses 
+	@: $(MAKE); $(unstage)
+	@[ -f ./pdcurses/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-pdf in pdcurses" ; \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-pdf) \
+	  || exit 1
+
+@endif pdcurses
+
+.PHONY: maybe-install-html-pdcurses install-html-pdcurses
+maybe-install-html-pdcurses:
+@if pdcurses
+maybe-install-html-pdcurses: install-html-pdcurses
+
+install-html-pdcurses: \
+    configure-pdcurses \
+    html-pdcurses 
+	@: $(MAKE); $(unstage)
+	@[ -f ./pdcurses/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing install-html in pdcurses" ; \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          install-html) \
+	  || exit 1
+
+@endif pdcurses
+
+.PHONY: maybe-installcheck-pdcurses installcheck-pdcurses
+maybe-installcheck-pdcurses:
+@if pdcurses
+maybe-installcheck-pdcurses: installcheck-pdcurses
+
+# pdcurses doesn't support installcheck.
+installcheck-pdcurses:
+
+@endif pdcurses
+
+.PHONY: maybe-mostlyclean-pdcurses mostlyclean-pdcurses
+maybe-mostlyclean-pdcurses:
+@if pdcurses
+maybe-mostlyclean-pdcurses: mostlyclean-pdcurses
+
+# pdcurses doesn't support mostlyclean.
+mostlyclean-pdcurses:
+
+@endif pdcurses
+
+.PHONY: maybe-clean-pdcurses clean-pdcurses
+maybe-clean-pdcurses:
+@if pdcurses
+maybe-clean-pdcurses: clean-pdcurses
+
+clean-pdcurses: 
+	@: $(MAKE); $(unstage)
+	@[ -f ./pdcurses/Makefile ] || exit 0; \
+	r=`${PWD_COMMAND}`; export r; \
+	s=`cd $(srcdir); ${PWD_COMMAND}`; export s; \
+	$(HOST_EXPORTS) \
+	for flag in $(EXTRA_HOST_FLAGS) ; do \
+	  eval `echo "$$flag" | sed -e "s|^\([^=]*\)=\(.*\)|\1='\2'; export \1|"`; \
+	done; \
+	echo "Doing clean in pdcurses" ; \
+	(cd $(HOST_SUBDIR)/pdcurses && \
+	  $(MAKE) $(BASE_FLAGS_TO_PASS) "AR=$${AR}" "AS=$${AS}" \
+	          "CC=$${CC}" "CXX=$${CXX}" "LD=$${LD}" "NM=$${NM}" \
+	          "RANLIB=$${RANLIB}" \
+	          "DLLTOOL=$${DLLTOOL}" "WINDRES=$${WINDRES}" "WINDMC=$${WINDMC}" \
+	          clean) \
+	  || exit 1
+
+@endif pdcurses
+
+.PHONY: maybe-distclean-pdcurses distclean-pdcurses
+maybe-distclean-pdcurses:
+@if pdcurses
+maybe-distclean-pdcurses: distclean-pdcurses
+
+# pdcurses doesn't support distclean.
+distclean-pdcurses:
+
+@endif pdcurses
+
+.PHONY: maybe-maintainer-clean-pdcurses maintainer-clean-pdcurses
+maybe-maintainer-clean-pdcurses:
+@if pdcurses
+maybe-maintainer-clean-pdcurses: maintainer-clean-pdcurses
+
+# pdcurses doesn't support maintainer-clean.
+maintainer-clean-pdcurses:
+
+@endif pdcurses
+
+
+
 # ---------------------------------------
 # Modules which run on the target machine
 # ---------------------------------------
@@ -51936,6 +52258,7 @@
 configure-stagefeedback-mpfr: maybe-all-stagefeedback-gmp
 configure-gdb: maybe-all-intl
 configure-gdb: maybe-configure-sim
+configure-gdb: maybe-configure-pdcurses
 configure-gdb: maybe-all-bfd
 all-gdb: maybe-all-libiberty
 all-gdb: maybe-all-opcodes
@@ -51944,6 +52267,11 @@
 all-gdb: maybe-all-build-byacc
 all-gdb: maybe-all-sim
 all-gdb: maybe-all-libdecnumber
+all-gdb: maybe-all-pdcurses
+install-gdb: maybe-install-tcl
+install-gdb: maybe-install-tk
+install-gdb: maybe-install-itcl
+install-gdb: maybe-install-libgui
 configure-libgui: maybe-configure-tcl
 configure-libgui: maybe-configure-tk
 all-libgui: maybe-all-tcl
diff -Naur gdb-6.8/md5.sum stsgdb-6.8/md5.sum
--- gdb-6.8/md5.sum	2008-03-27 18:27:21.000000000 +0000
+++ stsgdb-6.8/md5.sum	1970-01-01 01:00:00.000000000 +0100
@@ -1,6426 +0,0 @@
-d32239bcb673463ab874e80d47fae504  bfd/COPYING
-9bc671712217c141772e6cfde646cd34  bfd/ChangeLog
-daabeea83b81f2707d48d2c04dcc37c4  bfd/ChangeLog-0001
-0a3e33c0b179772334e34175da11b64f  bfd/ChangeLog-0203
-d20549a2f701cd99318d0af070416bf3  bfd/ChangeLog-2004
-aa4c260fc770839ccd0776dec1c2353d  bfd/ChangeLog-2005
-57633b8d529989fe966891285e127e78  bfd/ChangeLog-2006
-6ffeb475fe9699cb8c90e32a25d8e148  bfd/ChangeLog-2007
-8dcb7ce2e45911e21ceb6e457e69eacf  bfd/ChangeLog-9193
-6d37ec6ee5f57a1188a0717f2fa5deb0  bfd/ChangeLog-9495
-b7ad288235bf6a3e015e01cb6096cbe7  bfd/ChangeLog-9697
-dbb0d89c90d6c0ec79eb003a5b63f923  bfd/ChangeLog-9899
-d618facc3e8ce8bf3d02ba452e1be6ab  bfd/MAINTAINERS
-0485b3e4f6f21df90d63b6dc2b07ef35  bfd/Makefile.am
-46e50e52c49acb58732838b5e2f05d7f  bfd/Makefile.in
-6455e3c85b31e588ecb75f7d3c945c8d  bfd/PORTING
-2d6a5be3f5d1b33251fe9a8570e943d8  bfd/README
-cd26654c6eb30680694867e434e40044  bfd/TODO
-e97365d4ddb5473cd511987834901b83  bfd/acinclude.m4
-3a52c8c8a1e38186a12f054f7f2735d6  bfd/aclocal.m4
-e603e6d08738d4b1736917eb459895ae  bfd/aix386-core.c
-d4d86967908540c2fd54be7fc9fe2d0b  bfd/aix5ppc-core.c
-c21b0e5bd4dc4012a4f09f46875af652  bfd/aout-adobe.c
-0ac2adc12b94dc6e2342c9ab93323b87  bfd/aout-arm.c
-c1a25cf3be892f06aaec2ba262070777  bfd/aout-cris.c
-0afe37cae2ac4fd9a831a945b1fe61d4  bfd/aout-ns32k.c
-31f8e27b8910f4c12c9a0e1dde6e1c3e  bfd/aout-sparcle.c
-7224752d77aafe652518a6fec2aadcf5  bfd/aout-target.h
-9cfdaeaba1542f9d0c0fb37b6f44124e  bfd/aout-tic30.c
-875a767ed1a951cfe36cb5a5a4492178  bfd/aout0.c
-6b9d033cb8da0c983ca6675c1d986bef  bfd/aout32.c
-c642c3b4e2b633494576fd04758a919e  bfd/aout64.c
-1aec204d64d5b321d35def886f46e078  bfd/aoutf1.h
-fe82230c7e307d3d82db4c72b71f3b7e  bfd/aoutx.h
-ca73353ce44238a1f42a6bef6faff81c  bfd/archive.c
-c0284317dabbcbf786716b33646c2bb8  bfd/archive64.c
-733d4410c3d7f434a340b4519e87ddcc  bfd/archures.c
-5ed657bb294400d6c36a8c00ee83ad48  bfd/armnetbsd.c
-d22b7e2ffd1c69364db743645d64e7cb  bfd/bfd-in.h
-32afeff72e126514558b15da6d24bb2a  bfd/bfd-in2.h
-dab52735ae4d70ab5e047876c51baa35  bfd/bfd.c
-56fe9a0d165b6eecb6a7a57aaa18126e  bfd/bfd.m4
-e50e0af2cfc9742dd9f008553e304d45  bfd/bfdio.c
-c8873031732facb6053cd2e633196938  bfd/bfdwin.c
-c201f275f13e3d336443992e26cee2cb  bfd/binary.c
-dfed9d8377b66fb1dfd8ec51b80feea8  bfd/bout.c
-f2a4b5ff7d48156e32d602d7cda1b6e2  bfd/cache.c
-c03f424c3128044cb2305c7a07d25631  bfd/cf-i386lynx.c
-c0d3cf8b6de5c39e81c9699080fe3846  bfd/cf-sparclynx.c
-4b12cc60b143e518484d62799db2582d  bfd/cisco-core.c
-3f5ae25a291ff1ce07834fe333d6445f  bfd/coff-alpha.c
-87835a8111f66727dc5bae7ee80ac10e  bfd/coff-apollo.c
-f8a83b9575cd8e63169ce889bc7dff60  bfd/coff-arm.c
-6618c4dd6401aef584eacc6f2b3810f3  bfd/coff-aux.c
-1d19deed52cafdad0dd1c003d9907f11  bfd/coff-go32.c
-37a03f9f803d2fe46754c64c11218998  bfd/coff-h8300.c
-6eb01e446ee2be86b713277c3f74a306  bfd/coff-h8500.c
-0e6dcb6a41cd562c0cd1445c318e867e  bfd/coff-i386.c
-cbec39d88719aee399da9c3e828b2d0c  bfd/coff-i860.c
-800fb3d63b83888624b6330c5b070a1c  bfd/coff-i960.c
-d91cf2efa4204be4025a9c5b3bcf6fc3  bfd/coff-ia64.c
-f6fd20f7b8856e4ef857e7826a67af2b  bfd/coff-m68k.c
-783ccd0c47948f5e140ed09dd08489d0  bfd/coff-m88k.c
-e9efeaaf09d30604a7d23b101ee00a8e  bfd/coff-maxq.c
-fbd8490e8ef7957e9ea2e96745a29201  bfd/coff-mcore.c
-275a08ee0ddc49a92a421e1fc365c667  bfd/coff-mips.c
-40f4ed532ea986a8a5c143b5ea290953  bfd/coff-or32.c
-443eb497debc9419047a65572e76c862  bfd/coff-pmac.c
-817d9c35eb15cf1a1eb58c8422145983  bfd/coff-ppc.c
-5b6457cd6f07f61cd7d82f1ee9ce7eaa  bfd/coff-rs6000.c
-676b21339fe6f0cd1253bc3fdc96bfb4  bfd/coff-sh.c
-ab2d640e32ee30e44c8d12c26b1f0fad  bfd/coff-sparc.c
-db6fef095c96b0cb4f973b8638c5fcf9  bfd/coff-stgo32.c
-2274df1fd71728ea99aa6b42726adda0  bfd/coff-svm68k.c
-02ab189f0c6f8a73d657bfc17c25beb0  bfd/coff-tic30.c
-4544f1c0ac105f5741fe3a7f6e422231  bfd/coff-tic4x.c
-146b531604c806dab86dde17fadb982d  bfd/coff-tic54x.c
-890208731e3890727d5f911bc0e17a81  bfd/coff-tic80.c
-00eedaf396ff01e222fbdc29d3a87019  bfd/coff-u68k.c
-5ac8b46f6d4bd97d53e0de77525e027f  bfd/coff-w65.c
-636365e672efba59e2dbdeed3c9850d8  bfd/coff-we32k.c
-7f97ff470200ee7d15ed88fe71804230  bfd/coff-x86_64.c
-cbba2936f1598a3333f70597b7522d8a  bfd/coff-z80.c
-d383d35f3d4739bcdfda052cdd206694  bfd/coff-z8k.c
-10d340c49790a938b0d6fe98366bed04  bfd/coff64-rs6000.c
-d613dc11301ea3e520d4a0d47bfbd0af  bfd/coffcode.h
-e714eaa2f5bbf606cadc5ee6953e7c2f  bfd/coffgen.c
-1d24c7aa106c9645d58f8289de3c58ab  bfd/cofflink.c
-7f049cfb6667ef9e9cff92e7aae0fa8a  bfd/coffswap.h
-7e50e510ae63fa5e8a1793c38d10ea91  bfd/config.bfd
-d0399d2aef264172e9c9f8a3391e362a  bfd/config.in
-f31fe952974a133c33d86db5616f755a  bfd/configure
-a8485b69f68d81f4ef2f29b51bb36d85  bfd/configure.com
-b6168706fdbf981a62df6348ad485b18  bfd/configure.host
-da399f683ff20fe3d1ae125559f9beea  bfd/configure.in
-222c91c7fd6af092606bd158a11dca39  bfd/corefile.c
-19c5f78f1c862407747989dab35b88fd  bfd/cpu-alpha.c
-3146e97bd39d7fff031662ec4345fd8f  bfd/cpu-arc.c
-0483ee559ee1162e5d32b68641e55760  bfd/cpu-arm.c
-94ca8bbad3b6351de5743482564f266c  bfd/cpu-avr.c
-e5359870df01083e350eec26574fc25f  bfd/cpu-bfin.c
-6ae40f951ba2fe744d05c06bc8d64f80  bfd/cpu-cr16.c
-6137f96c44e55bdbccbd68b3f7411a3b  bfd/cpu-cr16c.c
-069151362a6520c1de16762c0e32d588  bfd/cpu-cris.c
-201be83663e22df8700a188488a7c092  bfd/cpu-crx.c
-fd9ae464e85bfd077b88ae2c8abb449f  bfd/cpu-d10v.c
-f39f657b7b404cedd71c44b3254d4fa8  bfd/cpu-d30v.c
-117bf00267f07ffe7bf9671d8f19da32  bfd/cpu-dlx.c
-5062055c4f8090d5b3947490d4c31a3b  bfd/cpu-fr30.c
-b1e1503a6cf4c099386598b00c6eaf89  bfd/cpu-frv.c
-b71f30078b6240ab30ebec040f0c74a0  bfd/cpu-h8300.c
-092d206aa16c5f74936f5dacc4375a4d  bfd/cpu-h8500.c
-f4114b542a75ff7ae9c562954eb3aa65  bfd/cpu-hppa.c
-3f79e3c79d70b495d1de3c4e132d60c8  bfd/cpu-i370.c
-16d97f442e1cb1dde1bd652cb5b2d97c  bfd/cpu-i386.c
-4648ac9555cffdbbef6f663383e5044e  bfd/cpu-i860.c
-912beea98358181eae32b9b0edfde53f  bfd/cpu-i960.c
-0483bf972bfcd713c0909c9f86b82f26  bfd/cpu-ia64-opc.c
-0f6f92467a27a868f4e048370ff7bd54  bfd/cpu-ia64.c
-d90f5422615efa271beab381b8dc0539  bfd/cpu-ip2k.c
-06e4f68fdea1f0fe7e70da5a7e6dcd8f  bfd/cpu-iq2000.c
-d421f6f88f785ed6e0d05acb179bfc61  bfd/cpu-m10200.c
-7db4b6d7476b6b5d133da2c8b132058f  bfd/cpu-m10300.c
-1569c97043be59825282ef4720f134d9  bfd/cpu-m32c.c
-b358d3b9399a0889b7f9560190bc409e  bfd/cpu-m32r.c
-60dfafa30d3bd72f1797c4dbc055b76c  bfd/cpu-m68hc11.c
-8b96a72b8cdef35b4a171908f7531e55  bfd/cpu-m68hc12.c
-4d842a53e8306d0def744e075ae60f1f  bfd/cpu-m68k.c
-56096c3ac16ea392d022789dee477274  bfd/cpu-m88k.c
-45146fc8f3266bbe04380275ef8ed85d  bfd/cpu-maxq.c
-048f358e25aca0536283ecb244d7346d  bfd/cpu-mcore.c
-ee4fb1f8d17e1ef029bc7592340743dd  bfd/cpu-mep.c
-58794e5b04c86a6ce756908ab87ee643  bfd/cpu-mips.c
-eaf40c3e335506df4d065e6e76524a4f  bfd/cpu-mmix.c
-66be3956e65236cec87468d39511beb7  bfd/cpu-msp430.c
-d87f62d816eab577e24ed00e8a1dc82b  bfd/cpu-mt.c
-07ba0d23ca8f838e8ba9b1e2f69cec8b  bfd/cpu-ns32k.c
-ed90c865b990ee8eb060012f44a44313  bfd/cpu-openrisc.c
-8b8c85eb402eb86edb5a534b67f79bec  bfd/cpu-or32.c
-a2199bc7da2784d466429e735c1fbec6  bfd/cpu-pdp11.c
-fdead7e5df81a693b6fb2a0e5e39d169  bfd/cpu-pj.c
-5e93f5a156d5a33eafa04aa3126e1b70  bfd/cpu-powerpc.c
-b2f41a15f63e15bcb890b7bf95487bc2  bfd/cpu-rs6000.c
-917d60aa4422b1021fa1310fe4f1a149  bfd/cpu-s390.c
-d295923201e70b6e9218859aaaff707c  bfd/cpu-score.c
-15511c9f15aaea5a8fc8cb8e0616feeb  bfd/cpu-sh.c
-a70df7b60df59454cb72ccbe1d3c8e64  bfd/cpu-sparc.c
-21a1cb9748c501a39e5542af1f33b611  bfd/cpu-spu.c
-71e698d7f5bc56da54482ee834399cdf  bfd/cpu-tic30.c
-72f3fbdade9d377b536aa623b2a4d20d  bfd/cpu-tic4x.c
-2253f20448669226b4e3f3a7d66455c5  bfd/cpu-tic54x.c
-2b1f7a96dca36ccc76baf89720d9472d  bfd/cpu-tic80.c
-53ae59eb67090b1eebe6b93bb4bacd0b  bfd/cpu-v850.c
-238c0a087aa3d7102cadaca638834400  bfd/cpu-vax.c
-0b78ce6afbea61c4397e8b508af3c5cd  bfd/cpu-w65.c
-bacadfc926e5e86fd227e1e46a18380f  bfd/cpu-we32k.c
-11a6c47e1d51c8bf25715e420f9df31f  bfd/cpu-xc16x.c
-f832d9af0ccbf5341ea8ee1d245f7189  bfd/cpu-xstormy16.c
-8fc73f7704a142f8fa4e1e1239dc15a5  bfd/cpu-xtensa.c
-e17e159f98955683b8194c5d5df31e96  bfd/cpu-z80.c
-aac1ff65acd79dbc88e9b7c1fab5b835  bfd/cpu-z8k.c
-203ce65b4caa57df76c1dd38d8e12b7b  bfd/demo64.c
-85642f7faafe48a08811120e0b61895e  bfd/dep-in.sed
-9e9a26d4ff997d33c54108bbbf25faaf  bfd/dwarf1.c
-653df7577a9dc8c6d229653f48a2851e  bfd/dwarf2.c
-deb5e9b440be44fcbab6bc5f5c25feb1  bfd/ecoff.c
-5f5cc83f0b9ac5a20cbda3e15e3e48e1  bfd/ecofflink.c
-67df9e1bdfc0782dd9e6ad00f505f687  bfd/ecoffswap.h
-fbcf782d13d37bf4d6dd7a236a01ef6f  bfd/efi-app-ia32.c
-6e492f434c484b908c68528ac3569f28  bfd/efi-app-ia64.c
-7bed68d534d6afb62f5ba0c5c15ae8c0  bfd/efi-app-x86_64.c
-b0c671fd206808292cd45ea3ddb3baa8  bfd/efi-bsdrv-ia32.c
-64d78031b6de9ad82489f4dd81a24751  bfd/efi-bsdrv-ia64.c
-df4b8d379d578c1d4545c6d3c2a40275  bfd/efi-bsdrv-x86_64.c
-875adf901dba18130e150efebd74d035  bfd/efi-rtdrv-ia32.c
-794f00db046ce422204d770f27348cb9  bfd/efi-rtdrv-ia64.c
-f648ac46ea7fa3005b0b255e10eb5b05  bfd/efi-rtdrv-x86_64.c
-619ba8a724a50502618825c422cc0f78  bfd/elf-attrs.c
-c8707eee408f96ed7d7b915a839c8970  bfd/elf-bfd.h
-7f53f1e69aa4317fccf11f4eb2a83724  bfd/elf-eh-frame.c
-b227bb38c292d9f3903276cf020d1d9c  bfd/elf-hppa.h
-79a365ef7106074198c153c4c0e200f9  bfd/elf-m10200.c
-a9f2a2f04fd62046e77260b290b7caee  bfd/elf-m10300.c
-80271019a0bbb737af67e29976d2e94e  bfd/elf-strtab.c
-66dfab58767be25c87a3f8297e52379d  bfd/elf-vxworks.c
-fcece4ec5829cd7a597209c75aac00c8  bfd/elf-vxworks.h
-6317c2fab5648e3c20caab32734894ad  bfd/elf.c
-42c1efc1918415fca01b5679c884cc7c  bfd/elf32-am33lin.c
-9d03e5cc8b0719b6fdb483746ba834a0  bfd/elf32-arc.c
-4f4e9c3d23874ae33818a7962b9b26d4  bfd/elf32-arm.c
-a61ced1ee9650e6f9f5ca7991d09f3c9  bfd/elf32-avr.c
-f6846e8628e2f26f82fea28151906429  bfd/elf32-avr.h
-7da116713efb4f2f6dfa3cc9e470a63e  bfd/elf32-bfin.c
-35f97aaf2b6e2c3a1b4b3ee93caeccba  bfd/elf32-cr16.c
-fa78945426a337a74040b33a52206e3c  bfd/elf32-cr16c.c
-fcf877ed941769f05cc59b7adc9cc8b1  bfd/elf32-cris.c
-8e66ed42a2e5179cd57f29412b1f5959  bfd/elf32-crx.c
-77b587dc1b8d03e2fb93bc16f24398f4  bfd/elf32-d10v.c
-01b764239090b59a897ab63da88d8377  bfd/elf32.c
-e9aa232096cc8fe8d530c39db7358897  bfd/elf32-d30v.c
-84fe89797a2292c33e4d4168699e4d81  bfd/elf32-dlx.c
-8eb81deb0cf120cd433b77ce70b014e3  bfd/elf32-fr30.c
-0556efea5bfce06d32abe9c3a989f884  bfd/elf32-frv.c
-2fbdc5d0b99c7ed22cbbc0b5082feb95  bfd/elf32-gen.c
-425487959777f2b7f88c4566b827f95a  bfd/elf32-h8300.c
-1ebfd6b41b834c1521128fbbb2e049a2  bfd/elf32-hppa.c
-48b661e381a9da260f8f8e45417b65d6  bfd/elf32-hppa.h
-a9ca50f8698bf9ec03f461e36a04520f  bfd/elf32-i370.c
-d990745b940107527ec744431f72fedd  bfd/elf32-i386.c
-1ab0be910ab0a36e4661b27748432629  bfd/elf32-i860.c
-af76e3dde2241645d746bcb82f2f86ed  bfd/elf32-i960.c
-4413421b833d2d1e688b8acd16f1a6f8  bfd/elf32-ip2k.c
-534d50e41161e07f9915e7f7a35f58e6  bfd/elf32-iq2000.c
-2502dc77836e3986295917259c94ecd0  bfd/elf32-m32c.c
-0f4f57638cc78075854839114719fc09  bfd/elf32-m32r.c
-a5d8f190381389a162debfe2db3607a7  bfd/elf32-m68hc11.c
-cc2cd21dd8b76fad69e0b39b365a29bd  bfd/elf32-m68hc12.c
-e8ef0901727659759a590c8aded676d7  bfd/elf32-m68hc1x.c
-bb0b9b1ff061f25b5d530a0e297f6ae6  bfd/elf32-m68hc1x.h
-49346abd2f023ceec2c468b379b57093  bfd/elf32-m68k.c
-b64863c70a9bd55274ebfe341bc5255f  bfd/elf32-m88k.c
-ed504b6e47756ba40ae658b0c7bad531  bfd/elf32-mcore.c
-e151468e66c83e227211780312caa898  bfd/elf32-mep.c
-eded37ac0a6621f9b696f06bba75dcff  bfd/elf32-mips.c
-77fcbb6c1fefa4bd9991d7af1c958990  bfd/elf32-msp430.c
-a5b96bf14934c3aa59f1684280da592d  bfd/elf32-mt.c
-12c4270a4084fed5b8b6fa038bd0cb3c  bfd/elf32-openrisc.c
-468e5e58c80e985dfbfa201ce07fe4ba  bfd/elf32-or32.c
-140b65ea1bdd039c81067900b5124da8  bfd/elf32-pj.c
-f910b7d33b833a5d9bbbc516b9b27638  bfd/elf32-ppc.c
-f854f7a23ce07444b5bed5d3a37c1e70  bfd/elf32-ppc.h
-d6bd27a534e198b868f6964885649d93  bfd/elf32-s390.c
-69ca707013e419bd996194319a49abed  bfd/elf32-score.c
-bf9bd77ab501dc5cf32f65247de5c27c  bfd/elf32-sh-relocs.h
-6b2b0b57e9082e1befd399a2e9981a37  bfd/elf32-sh-symbian.c
-11a37a037a9076f43620532a019a9d10  bfd/elf32-sh.c
-12002be0fa209d7cc2afa7767f149a3c  bfd/elf32-sh64-com.c
-89f3cb461b40dfcd880b26383b55711e  bfd/elf32-sh64.c
-bf94bcb1eed782bf504616b52ae8726d  bfd/elf32-sh64.h
-60c3583522abaf41113a1e5ba0a89813  bfd/elf32-sparc.c
-6f1266bbc467c6d14148f24a98bc63ea  bfd/elf32-spu.c
-121a13aee85827a61436223d17fe2951  bfd/elf32-spu.h
-8f3c65fd49b4c3ebff63e6c11b9e92d2  bfd/elf32-v850.c
-f202ae1748badaa8b4ee0e9f525beaa8  bfd/elf32-vax.c
-bfa1af1095fd9d77a0599d4388dc839e  bfd/elf32-xc16x.c
-103d6040671dc899438d880d3e73adf7  bfd/elf32-xstormy16.c
-da433ea6dd87397d9da28812826bbd13  bfd/elf32-xtensa.c
-f53497a73a9074cf0fea52c8f962e267  bfd/elf64-alpha.c
-cb5514787c5264ee0bc353a2c981561f  bfd/elf64-gen.c
-1afd8ea20ad942f0be75a2454ff403d0  bfd/elf64-hppa.c
-5062fc9ba31426e4c7cbb74dc6ae6680  bfd/elf64-hppa.h
-dec6542231b3f550fc84c04f187374f0  bfd/elf64-mips.c
-e39239d5122a6e6e850c95367ba4996b  bfd/elf64-mmix.c
-9beb31405c213788cd4e1ba426995fa7  bfd/elf64-ppc.c
-fed27fbd88b05089cd12ab49f4a80716  bfd/elf64-ppc.h
-ca41de4a366f0f23cd34fd1c89c2bbc5  bfd/elf64-s390.c
-f0b5b9e648c637c5c543b2b1dfafca27  bfd/elf64-sh64.c
-f12c2acc03dbe843ab39119e578ba065  bfd/elf64-sparc.c
-84f6943d6b7f63669dacc83de6c2e949  bfd/elf64-x86-64.c
-5c30a530048261547e4ae10d87b0cbfa  bfd/elf64.c
-4e81c33ec4c438dc701e635a42b1b806  bfd/elfcode.h
-5fe53df67fc0942b73b57299694d1ac3  bfd/elfcore.h
-d9cbf9209249350ded4dec5f4702875c  bfd/elflink.c
-2f414138d88ea74e0411844a0d40b2cc  bfd/elfn32-mips.c
-dd3f6f1a65376150a0657a61b69b6687  bfd/elfxx-ia64.c
-355b3f6e12aeaaca424bcbd935fd940a  bfd/elfxx-mips.c
-7bb9296db2d054a2bf3c3296c0ab5182  bfd/elfxx-mips.h
-91300b2c2291d553fa8bdf984de778ab  bfd/elfxx-sparc.c
-3aa5f4697cd9f2d4c90cc7e3eef4c15a  bfd/elfxx-sparc.h
-454991bcf8bffac1a6f8ca37b8ab8aad  bfd/elfxx-target.h
-07470e76b0f091671a11d5a2ac811d6f  bfd/epoc-pe-arm.c
-d00e03544f496e18a4fef8d86764d3b3  bfd/epoc-pei-arm.c
-379648307b4daadcb51be84a2c9d3b7e  bfd/format.c
-fc8bec4190b9d8fb626bb9395d8c1af0  bfd/freebsd.h
-9eb544f9a3c1766d1b0bbd412e20b6b2  bfd/gen-aout.c
-b0682558ad69d3671cc55f83abebf32d  bfd/genlink.h
-663a6979bd331c91d1385445edeca7b0  bfd/go32stub.h
-15efae39cfae900f46863f1cd88af6a8  bfd/hash.c
-6d6b921f9b5ec74aa504542823910290  bfd/host-aout.c
-408bf81c009b0f85cf82d97a19ea36de  bfd/hp300bsd.c
-812d5d6210841410af8da4b7753e30f1  bfd/hp300hpux.c
-1c1d0668c2208d1e8e0ae3dcbede0a5e  bfd/hppabsd-core.c
-3aec20a67628f04f459009e563c1f750  bfd/hpux-core.c
-f7b33e7dcd153dc5e4a4905f65772e08  bfd/i386aout.c
-809612acccb7840808708f04b7850508  bfd/i386bsd.c
-cc945baf536d570eddfeac100f0f60f9  bfd/i386dynix.c
-8ca4ba5bbc7f148e7af497e77ccaef70  bfd/i386freebsd.c
-98108eee19edc4d00c8efbb36a04d96b  bfd/i386linux.c
-e005482ee2def8790c5eb7a2f89509e3  bfd/i386lynx.c
-f6763468c0cd0cc164dac3d94226e197  bfd/i386mach3.c
-4655c06083c93e2b80e01b6603cc5004  bfd/i386msdos.c
-49dc5eaf6ec5ac1946d2e99559033905  bfd/i386netbsd.c
-404cd1fa010606676603ee2e9823e071  bfd/i386os9k.c
-feeeb60026cd9b59d58ea92a04a5531a  bfd/ieee.c
-6f564213c31fd41a2009b98e642ff442  bfd/ihex.c
-324e8a59afca7e2bfa34d945fa9fe1b8  bfd/init.c
-08ed7b6c97aa814a8e552ad5fbdcc130  bfd/irix-core.c
-44dba4a2c84a0363c5b1217b5b412f4f  bfd/libaout.h
-423da990b0fa936c68684148aae8dc06  bfd/libbfd-in.h
-cbcfca0c42cf775ae8e905ec689539de  bfd/libbfd.c
-73684df4c8be9cc38475d28cba6d8540  bfd/libbfd.h
-09c4970aa61690244eea014af95bd22f  bfd/libcoff-in.h
-c777a041e9260ed0e7e26a8f52723c9f  bfd/libcoff.h
-6adab8e2e0fc3b76998dfc5d87641c1a  bfd/libecoff.h
-9a9573dcff54ad8e5e5384dcf6e5fb2b  bfd/libhppa.h
-cbe1989d75dc6a84125840ab4d90225b  bfd/libieee.h
-10927f5450b2e259198eabc163385d8d  bfd/libnlm.h
-7b3c5c80f8b1a4e43797cc34a2bd69ef  bfd/liboasys.h
-fa0c9aec1d61d5e9d0c8e77f90f7e303  bfd/libpei.h
-356347ff434815c13522743640cf585c  bfd/libxcoff.h
-4502c1c5fcd216bf8815d5b583323916  bfd/linker.c
-bd9d600d85e7cfe668ed1d956cee2d34  bfd/lynx-core.c
-ef253400f2c9d59ede3cfb27981540a7  bfd/m68k4knetbsd.c
-4bb534a382dad69a1dfc88f66e9a17f6  bfd/m68klinux.c
-3ffa450e56c45147c342a5801f6e40ab  bfd/m68knetbsd.c
-9dd9b4b54b5ecd841e02fc09de6733ba  bfd/m88kmach3.c
-0a979e7ae16e76dc1052f87a1a32f21a  bfd/m88kopenbsd.c
-91c4031187c69f537b4ca11564434f30  bfd/mach-o-target.c
-ce988be631a1a71e15729ffc06223607  bfd/mach-o.c
-59ca37017e343fc8e2d7da81677f4536  bfd/mach-o.h
-5de4da6a9169effb512e6ba4d014d420  bfd/makefile.vms
-76a44dbc419f39a2d9cdf76d308b370f  bfd/mep-relocs.pl
-5de2207108a1c228cbbfb68ebcf0ef81  bfd/merge.c
-570d33261091085baa38a403d5234677  bfd/mipsbsd.c
-f0155a5f07f50790b4845ff4bf71d7e2  bfd/mmo.c
-ed505b455f849a508f8500fb319d560c  bfd/netbsd-core.c
-2baf2b7c69f7d6a04d6ba8401438bd23  bfd/netbsd.h
-9109b3153df61e3a234a01c913d439c2  bfd/newsos3.c
-6a66b8c1e8f1e29bf10381d795fa3660  bfd/nlm-target.h
-974dcc60b7cb7d05c3ebc5724c84dc07  bfd/nlm.c
-e3a11b8c38f8beb8cb380d2556b1fe88  bfd/nlm32-alpha.c
-6fab17bbbab49e405c5403c74c8666d4  bfd/nlm32-i386.c
-15616141c4d4ce3cffcba9fd5a64af16  bfd/nlm32-ppc.c
-8d32e21a6406782a4c39726174e14333  bfd/nlm32-sparc.c
-23d887b1a819df094278b51c2a422fb7  bfd/nlm32.c
-deb59f76d1765961ece69df38db4773f  bfd/nlm64.c
-3c34f07f1b6986e384b65f3d4f79e635  bfd/nlmcode.h
-94288f2695f9ec23df20e5a82861525e  bfd/nlmswap.h
-7d24843968787ccead71cb5da5c21adf  bfd/ns32k.h
-fdbfd6f37c3c732d7b622b8fd5fdee3a  bfd/ns32knetbsd.c
-2b9689e29c87a2426371ce0f150b6200  bfd/oasys.c
-a6aade954e078884fe3f8f82d6138758  bfd/opncls.c
-329a6d74a719c29bf82993dc912761a5  bfd/osf-core.c
-3b4ff1a66cffb2130c9129200cbc019a  bfd/pc532-mach.c
-2301e19df2b8cc67404d387128ab81fc  bfd/pdp11.c
-03468d3e2bc5fa10cf27794bf62c9665  bfd/pe-arm-wince.c
-15edbbee751296381490bcf434261d63  bfd/pe-arm.c
-2d604ef41df507a798845df4245ce5e9  bfd/pe-i386.c
-429e3813c481805fcf3d02b86bd8ef31  bfd/pe-mcore.c
-742fe4e887770db9d32aba08d0f78a0d  bfd/pe-mips.c
-74e12cf66e63c8986573ad9eba3b6533  bfd/pe-ppc.c
-9596e8422ef41e6b44cb7d71fec51af9  bfd/pe-sh.c
-0e4988b169d325a195b3269e4932f26e  bfd/pe-x86_64.c
-78b40f707dcd90ba61c3df1555fe5ddd  bfd/peXXigen.c
-12d97ba29117269a1a8cf0ca362de34f  bfd/pef-traceback.h
-36fc1e8b2def5346958a3c738e88722d  bfd/pef.c
-0158421813e11e66bd36ee1a13d7484d  bfd/pef.h
-3b93dbc924bcd6ca464d26c42a679909  bfd/pei-arm-wince.c
-f6f23fe6102fa30cedc1b14a44673c1b  bfd/pei-arm.c
-23e1b0ba34c7954322ad75c4f2198290  bfd/pei-i386.c
-ca07f53b1b635066bdbe8c6c59f9b74b  bfd/pei-mcore.c
-820a3a95994a09998a142a0d98dbefd3  bfd/pei-mips.c
-2a333ffdd2ab4f7609f7536e136c20cd  bfd/pei-ppc.c
-2a09c9b5720588196c8c1e3ff7b2dea3  bfd/pei-sh.c
-6aadb1b45e6c00371ebc0c3ae9c0eac0  bfd/pei-x86_64.c
-e43820c1283011f5bd28c22a96aa2814  bfd/peicode.h
-c735cc97a2e8d91e2e30f1653bf36973  bfd/ppcboot.c
-78d849194351465637bc1666a5eb7e1a  bfd/ptrace-core.c
-e972ddaffd8feb3a838c66301f7a762e  bfd/reloc.c
-4d2f2b16a24f78faf08a6c273ed083a2  bfd/reloc16.c
-1c41e8a05de35e302f80763a264c2cdf  bfd/riscix.c
-e6ab788746739b9e9e330745d106a728  bfd/rs6000-core.c
-57f02d59108f94faed6f657fda967109  bfd/sco5-core.c
-8d45ae6a23db1118341d23d2e7ea9a4f  bfd/section.c
-469b0a5cbaf7d262cd00ce50f5870ea4  bfd/simple.c
-1b93b7868d38f0971aa4f8ead29a6347  bfd/som.c
-f8a5b40f548f7e5319f46a2d49b8fadd  bfd/som.h
-f6362716ba0e09d9f825013d8c77501c  bfd/sparclinux.c
-a2a46b3d42519728843beb7307727724  bfd/sparclynx.c
-15bc544a0d6206a2e530e6648aeed20f  bfd/sparcnetbsd.c
-af0116f2caa80dc1b35a5ac487fbcd86  bfd/srec.c
-69bcfc0b5db15d43a1b2a8160faac94e  bfd/stab-syms.c
-41ee0ac2f140432734cd71e5c06f6cb3  bfd/stabs.c
-1ded054093de910d9786c62bc4fe8cc6  bfd/stamp-h.in
-5118f479c542f65a34576798d2fadc79  bfd/sunos.c
-01b21b82982892dcf91b08fc65cd2bf1  bfd/syms.c
-d0c1075b9426221568ab967638523d9e  bfd/sysdep.h
-994baeb2692fb1d253d2f9e7f09e2d0b  bfd/targets.c
-53357a9b87dd158b90cf790c316fd438  bfd/targmatch.sed
-3a3bcbb02d3fc04818ac27fc2c9f2693  bfd/tekhex.c
-19aa03fbb6ca3f7636da1b6e6fb3c16b  bfd/ticoff.h
-e818a27d3f939421eaf8c4fa3e5ac70f  bfd/trad-core.c
-d34b676b52cca72a65f80aeee196d0dd  bfd/vax1knetbsd.c
-b8003ae4d166819093bf96bc13ad2023  bfd/vaxbsd.c
-5bb97ac813578d24e257cd46d17809ba  bfd/vaxnetbsd.c
-54e368663e3a9ea8b03d0759110ecc23  bfd/versados.c
-1f85160c9f5bd3355e304a0b14b439ff  bfd/version.h
-5bd41598a2d2f1be4742692c5b0219b5  bfd/vms-gsd.c
-4c6703ae91f6d82783c9f29266f26234  bfd/vms-hdr.c
-e918f73060aea21fee785de9a4aab5a9  bfd/vms-misc.c
-6ad8267b8cd091a6f4ae3502af77dc8e  bfd/vms-tir.c
-6e60ac837cc24cc008880a55e71f3c7d  bfd/vms.c
-61f42d3e83c071567956eedfe733fa46  bfd/vms.h
-005c0968f5fea4c0d7ece3060c0121b4  bfd/warning.m4
-68c0de44272c279835cdd26d35dbba06  bfd/xcoff-target.h
-f7fb6965a3fb9d1cdb0fd18220d2e47d  bfd/xcofflink.c
-653a35aa430db1f0b6b3a499a0a0cad2  bfd/xsym.c
-11213bf58c2136189edd119d00671f00  bfd/xsym.h
-a7811ca776512fa01e229b185b9e4f23  bfd/xtensa-isa.c
-65bcd88cdd329e4d5f1e971822b19c0c  bfd/xtensa-modules.c
-1383f2d6c523aef21d4bd0298cce9152  bfd/doc/ChangeLog
-42b5ebab441fcbf65e95c2aa31262147  bfd/doc/ChangeLog-9103
-870ab21acd1d9ae66f39b194427ebd71  bfd/doc/Makefile.am
-fe724ae749ee9f863765e53d7727c545  bfd/doc/Makefile.in
-c2fe876fa07ee9da6c22f80750284d1a  bfd/doc/bfd.texinfo
-f897c6ce84772abd3486ac2c9597cf3b  bfd/doc/bfdint.texi
-5ee7f8ae8b0ec33c7baf2e004084aaa1  bfd/doc/bfdsumm.texi
-ac3798eaf18466c1ac924f79d86129a5  bfd/doc/chew.c
-e67d8b07516154c4ddbee2e3bab3d75e  bfd/doc/doc.str
-1beef3294ce9b67f22254ad8e6ac63f5  bfd/doc/fdl.texi
-39f61ac0fb56eced56e6894e7bc47cef  bfd/doc/header.sed
-5fa24958e8a60b2f879af658e615ccc0  bfd/doc/makefile.vms
-d7a37304ccd7b245f93df4be02797477  bfd/doc/proto.str
-ea276555403bfe0b3e5b470672ac0203  bfd/doc/bfdver.texi
-b1848292a4811cd7301fc6201debe63a  bfd/doc/aoutx.texi
-1ec269e34cd7de48135ce9d4aefb98b6  bfd/doc/archive.texi
-995c4af08531e8b4bdc85f3d4450b5c9  bfd/doc/archures.texi
-ac5c869f189ccd58b989cdb788c7a573  bfd/doc/bfdt.texi
-2afdf80182d7d816eb993fe194d378a3  bfd/doc/cache.texi
-e9283eafea1e7362f84432636f966c9b  bfd/doc/coffcode.texi
-4bdaf36b0c11f0b77d1cc779bdb97c91  bfd/doc/core.texi
-c60b298f07f5a175f2325d48bd009bdb  bfd/doc/elf.texi
-d41d8cd98f00b204e9800998ecf8427e  bfd/doc/elfcode.texi
-930173859dab35d4c1c03efd5ddb18e3  bfd/doc/format.texi
-7d2276b33f6c38de1679adc0ec62edf8  bfd/doc/libbfd.texi
-236e856bb13ee47adc5d7d253037640d  bfd/doc/bfdwin.texi
-5dbf6210f3c226958ef133ba82ac5912  bfd/doc/bfdio.texi
-08cdd2645039224cac888475654eb8dd  bfd/doc/opncls.texi
-8666f5a7abd1c29a19a0a4faab4011c3  bfd/doc/reloc.texi
-b01dcfe5e97730cf17cc6ca653e9bd46  bfd/doc/section.texi
-2b38122ab8aa2a9d46103a69be091622  bfd/doc/syms.texi
-7eefe7c249b3691f0e67103ff25b6334  bfd/doc/targets.texi
-37ba364fb34b96a1dbb55b0f6f612432  bfd/doc/init.texi
-d2b923f7732c26442570c16fd1dfac5a  bfd/doc/hash.texi
-c95953ddde5b54e089ac8d4be18d0b07  bfd/doc/linker.texi
-58f9e78e71f2d034a79e172899e792f6  bfd/doc/mmo.texi
-42581e1b421bd3e5a892444b3db39d16  bfd/doc/bfd.info
-065b0a6c7a8a5427098e677cef40f6ab  bfd/hosts/alphalinux.h
-0c08884333252c272dbc2a1f353f351f  bfd/hosts/alphavms.h
-b456ff19a38c6a50a7b6fcf23fd9e1f0  bfd/hosts/decstation.h
-4fb8d1e636638d7f586e0ae36461592a  bfd/hosts/delta68.h
-05c0edd67951513bd03cc042835684b6  bfd/hosts/dpx2.h
-c1e482f851c42ca2f436d33d928fa4a0  bfd/hosts/hp300bsd.h
-76a5586b3812d98ca98bf4c45cce3a55  bfd/hosts/i386bsd.h
-81aeb95fc7b74ab9b9f8c5fc80d0decd  bfd/hosts/i386linux.h
-edaa62376a9b603f40be272ad9a1f8db  bfd/hosts/i386mach3.h
-512b359313f0c3bf22ddde09f931f9ad  bfd/hosts/i386sco.h
-402e13c6d261e86aaf96c67e3b3cc875  bfd/hosts/i860mach3.h
-670afabed36b3d49e3c7e5fee2cdbb99  bfd/hosts/m68kaux.h
-678db628d91ca1b6e6ab88cc57ea0bda  bfd/hosts/m68klinux.h
-bf8a891bfa8c0536883b8922eeab45cb  bfd/hosts/m88kmach3.h
-c02b894dd2e75ac9c268ece62fc47eda  bfd/hosts/mipsbsd.h
-dbaab9a86bc5130ad99189c8ddceea5f  bfd/hosts/mipsmach3.h
-23b460b9b9ee4bbbc5b43b099d39866e  bfd/hosts/news-mips.h
-68f97cde664f22f1ebe7ffce83564ec9  bfd/hosts/news.h
-495f5ce083fe90efb267ffbbe968e20b  bfd/hosts/pc532mach.h
-55b9dd83897834c020f30e2fa4b150cf  bfd/hosts/riscos.h
-9c4e42b51ed4ef3624d6632d97c5680a  bfd/hosts/symmetry.h
-d210f558099621a92ad1d868d9a94618  bfd/hosts/tahoe.h
-79b07f6c1981ad9b247ce0bc997305d9  bfd/hosts/vaxbsd.h
-a5378aac580fed0c8f5e1f2a7899655b  bfd/hosts/vaxlinux.h
-95385f49273928ccd97630efcf35c91f  bfd/hosts/vaxult.h
-95385f49273928ccd97630efcf35c91f  bfd/hosts/vaxult2.h
-d900f09c506ad5057a3fddd39e3fab7c  bfd/po/BLD-POTFILES.in
-bc54a6c80e6f68f624f5a6b4cebd6bf6  bfd/po/Make-in
-064e5c1fb568c671677bd2ec261860a4  bfd/po/SRC-POTFILES.in
-6bffed55bf29ef080b8d27baea140da0  bfd/po/bfd.pot
-3aae148fb9018854c2d708a4ef931674  bfd/po/da.po
-4dffba55b8a99e440be9ecd838e8275f  bfd/po/es.po
-f3f62c902878365bd55b35d5933231bf  bfd/po/fi.po
-68866d3be8f33a73e3d3a411d7e5d2cb  bfd/po/fr.po
-73b8653e71ee27028caea3884743f7de  bfd/po/ja.po
-8fc4e95db5a00f800bc30c65a30f8a8a  bfd/po/ro.po
-4314f7dc707bdd16e1a3aa6318d52f8a  bfd/po/rw.po
-dfe82e26118652583a47b8f4771e7e1c  bfd/po/sv.po
-95bcedd50b1016d3de8c9f543c6b2bb9  bfd/po/tr.po
-abf6192a404ba26c8c9ba2f66afd4565  bfd/po/vi.po
-759dbab8d78320662dd19d5c9dc5bfa0  bfd/po/zh_CN.po
-35a4480c592584b75a828838b20938a0  bfd/po/da.gmo
-5c9a63d21b7066d17c88eed8b2763204  bfd/po/es.gmo
-d8f606f7cddf353ebd9c24b11b472c8c  bfd/po/fi.gmo
-9632ec7bbacad153aead7446fa0ab100  bfd/po/fr.gmo
-95a86001b071eb80f4745adba10a289a  bfd/po/ja.gmo
-844c1ea598f9bcc47870ecf122b15e7d  bfd/po/ro.gmo
-e15c998ffa3537ef5f5c5ed225c18279  bfd/po/rw.gmo
-b04862da8728ddf3c4c8a45b18ee35f7  bfd/po/sv.gmo
-495dc4f4a2e82ea81d7226370e07294f  bfd/po/tr.gmo
-b0376107e4977969c09c6ee65d4a3048  bfd/po/vi.gmo
-ee7366f8bf4f4bca0d82e3143893174d  bfd/po/zh_CN.gmo
-1027c1d4fa9905ce55c7975a0caef6f3  config/ChangeLog
-6c7b0890dc93bdd97ec3e90d8436b384  config/acinclude.m4
-a83e49e470046e608dc8116398077284  config/acx.m4
-04bdbef77f5fd2e282f7dee0bde60444  config/codeset.m4
-900c21dd1874d8523595f9f0e7e7a4cb  config/confsubdir.m4
-b5a5c394536a15e50be1998bd341fd02  config/depstand.m4
-042203b305962ba9a8f8474ef80edeee  config/enable.m4
-8e54553a2c063659a749e0ef9e5348e4  config/futex.m4
-1282ef4331970c26224afd363968e276  config/gettext-sister.m4
-2056dbab474e474ab2ae01a42ad5359a  config/gettext.m4
-29c9c3d57667bc9e6f14d625b2cd5894  config/glibc21.m4
-c385066b0fe61ef55d44cf2619e79b26  config/gxx-include-dir.m4
-998940a8ee25ca89805ed7da63536782  config/iconv.m4
-7cdde9f19fc614304e49342c660e2d47  config/intdiv0.m4
-e32906a3177f3b368bcd56f9e86a620c  config/inttypes-pri.m4
-b17ad59a69316040fae6c3b09187bcbc  config/inttypes.m4
-0b63117973333c343e0d0819012b8187  config/inttypes_h.m4
-db111161c56fa9d53a03abfb188ad1d0  config/lcmessage.m4
-cbcbd9977ef1239ccac0c5c54d214302  config/ld-symbolic.m4
-aee531078fda99d1e3bbdf408b6c734d  config/lead-dot.m4
-77931c860806547ce9fc56097a731c6f  config/lib-ld.m4
-50120e7fff340d87578219756e55a5e3  config/lib-link.m4
-4455537cdae70977a1283180062a2d8d  config/lib-prefix.m4
-9b65dc7f50a7134932aa278ac0378703  config/mh-armpic
-7b266c44c8a74cfd3aa47c7408b1d9d5  config/mh-cxux
-85f96b330d9ccaefa3b09568acdae202  config/mh-cygwin
-1a368defd90f5893cad171786ee20569  config/mh-decstation
-8b594c219d32fc33f367d70ea30239a1  config/mh-dgux386
-625bacc09b9992290d94831bd7506bd0  config/mh-djgpp
-9b65dc7f50a7134932aa278ac0378703  config/mh-elfalphapic
-9b65dc7f50a7134932aa278ac0378703  config/mh-i370pic
-740855ebe34cb2d01fba1f1bcb4264cf  config/mh-ia64pic
-9240a2b84d379e3feff49d8311072dc7  config/mh-interix
-4025142ef79311b861a05eed3e417a4a  config/mh-lynxrs6k
-740855ebe34cb2d01fba1f1bcb4264cf  config/mh-m68kpic
-2ab6803b8f158cebb9e1b4dbd1028174  config/mh-mingw
-1970cc16887b91d667b9bbfb0f6e67af  config/mh-ncr3000
-fb9d7448a6dab87d4da003658fb4d66d  config/mh-necv4
-9b65dc7f50a7134932aa278ac0378703  config/mh-papic
-a3394c8d52cfd70acd75e214e9909eb3  config/mh-ppc-aix
-a2628132e60b0492f8c93ce6ad8c9fea  config/mh-ppc-darwin
-9b65dc7f50a7134932aa278ac0378703  config/mh-ppcpic
-740855ebe34cb2d01fba1f1bcb4264cf  config/mh-s390pic
-ecf7a936c35e3c5a0e8d2b0721243b85  config/mh-sco
-e4353fd5127f79d601d85fde3925ac76  config/mh-solaris
-fa84a282ce7cd6876d1eac368a31a368  config/mh-sparcpic
-2415a4da9726792701f226bdb0e5ac3f  config/mh-sysv4
-2415a4da9726792701f226bdb0e5ac3f  config/mh-sysv5
-a1f1f0d6fa6e5e849b918f091babef21  config/mh-x86omitfp
-740855ebe34cb2d01fba1f1bcb4264cf  config/mh-x86pic
-3755b5b077053b5de54ff0f781ca9295  config/mt-alphaieee
-96289d06809692c31d71e69c4bedb6d7  config/mt-d30v
-48fa3bdb98c0bf781a96764d777db6ac  config/mt-gnu
-2033f1e2eaf00ab221523e98108ea2c4  config/mt-mep
-9f993e82ece918a7c632796103176a09  config/mt-mips-elfoabi
-2067ce86494ccb89791fe169eee8c198  config/mt-netware
-5aa8f75c6588d513ce199e2e44c206e2  config/mt-ospace
-23e56715f4bf1219d8fe216560c4f3ee  config/mt-sde
-3b8f3e01ef78a641f9a8a75cc9a7056b  config/mt-spu
-9c67d61b28da389337cfaba76ac581ee  config/mt-v810
-12b3030d3d59526c374c15af4f5944dd  config/mt-wince
-33624cdc9c21800a4fbb3bd88ab4b7e4  config/multi.m4
-120ec56e3aa27739a2945bc1c8a2530a  config/nls.m4
-2ca9a51841dae7be00e1969166c7e06a  config/no-executables.m4
-08ac6e38b61b5cee2fa4129284da8fb9  config/po.m4
-d3cecf02bb97035177818aefbb0e0833  config/progtest.m4
-df27a65f2a918654d5a273616b54dda6  config/stdint.m4
-761497fd3445beb86a90919955d5aa20  config/stdint_h.m4
-e1ed6ed2bd6dfcb906a46bafb1bea846  config/tls.m4
-5e1e75893989d0ae3c0452451cf80280  config/uintmax_t.m4
-6b1c349fb182e74fbc464c50c88fe2ee  config/ulonglong.m4
-1a61c5f6c3c36d81b30ac9216d40fe68  config/unwind_ipinfo.m4
-29b370c5ada7de5cd0b45d779dc9f3fe  config/warnings.m4
-19636c52c484cd2a755b9f2ac658257d  config.guess
-fd6715ff0f00625f90716195f55eff61  config-ml.in
-46f36a6ce11978ea07e2199f3c5cd665  config.rpath
-badd56af78d80c8a8492b391f6eba3b6  config.sub
-c40ac466aa677e265604b06334caf398  configure
-263415584aff3e151407114f20bb2411  configure.ac
-59530bdf33659b29e73d4adb9f9f6552  COPYING
-d32239bcb673463ab874e80d47fae504  COPYING3
-6a6a8e020838b23406c81b19c1d46df6  COPYING3.LIB
-9f604d8a4f8e74f4f5140845a21b6674  COPYING.LIB
-474823864e33a34dd1ad32b464f7d9b4  etc/Makefile.in
-c325d87840458206fa874f651e4ac77f  etc/configure
-63ff1cf7937607f0ef7a2e254aa83757  etc/configure.in
-b4ca7d57f486fb2db77fb8588a1b6d6a  etc/standards.texi
-16d5de91d4a0b2dd0259cbf784de927d  etc/make-stds.texi
-51cd5c2a1aff742f088c3a9c9c2407e9  etc/standards.info
-41ad927ae6285207ad5ba60aaa68c84e  etc/configure.texi
-cbfc5c1591c16f34e3eb6397afc8aa3f  etc/configure.info
-a20b40a0a5d3282f6a97c627be1e38c6  etc/configbuild.ein
-570746cd93c4dae506cf2a6153a2a1b3  etc/configbuild.fig
-f97ac2d5e05edeb335b73f8b6beef581  etc/configbuild.jin
-b2851bb6d77822adc89ffc6d323b5fea  etc/configbuild.tin
-e67b330b1ad623f1bd3850483cd4666f  etc/configdev.ein
-c1f7c41d3e596256ab5f5f933a66293f  etc/configdev.fig
-8e14386548b8da4c5072aa2abea55886  etc/configdev.jin
-32fc10cbdbf679bd0ffc8857cf069b43  etc/configdev.tin
-6d3a1129a96ea361138623b9fd40bd39  etc/fdl.texi
-d5faa80d97899ae08accaff400923890  etc/texi2pod.pl
-6abf261d5ab607e93ee3527422be61d7  gdb/CONTRIBUTE
-edcd90d61eb8065d3f52ffc47035779d  gdb/COPYING
-10c603e454962b6eb84bf1f2e7faab6f  gdb/ChangeLog
-42b9f7c51223e595f66c2210064be682  gdb/ChangeLog-1990
-8f5a03c189727d347a330548f3ea9c98  gdb/ChangeLog-1991
-51d2fa6ce8618d5c87150c7c576f1f6d  gdb/ChangeLog-1992
-f971d36e35ec0c3fce64b819d7891f15  gdb/ChangeLog-1993
-526536cf30b137dcebfaaa604fa55615  gdb/ChangeLog-1994
-e5e589fe4f10abb8957a8c2e4cddb7f8  gdb/ChangeLog-1995
-349b188907736d3ac349e30e509f4e37  gdb/ChangeLog-1996
-90e56dea65beb67443d6c83cbc5fed7f  gdb/ChangeLog-1997
-5ec8a13039f178b86804ff04e7cbdf99  gdb/ChangeLog-1998
-5052b57de2fd8b3515777bb814bcd394  gdb/ChangeLog-1999
-da71c479b68a4d95a79d36640b93c9c3  gdb/ChangeLog-2000
-c923fbcaa47240f82d7ef756c59c87ba  gdb/ChangeLog-2001
-872be449ea0ede048ac193747d131870  gdb/ChangeLog-2002
-5652294b4864dfc7241196198f4a8ad6  gdb/ChangeLog-2003
-8231b684b7d88405d04d2bef46a24822  gdb/ChangeLog-2004
-7b8a5048cfb6f899a8199897f0864c8f  gdb/ChangeLog-2005
-d87f8f330dda7f736350ea5dcff5b709  gdb/ChangeLog-2006
-33e82795b3de28ec33551530ec362c2c  gdb/ChangeLog-2007
-1f68d3272b33b380724fe731f1716f7b  gdb/ChangeLog-3.x
-659033435f346e47383bb24b20df8c10  gdb/MAINTAINERS
-d7f229709b0cbb2a09d916abaa80d792  gdb/Makefile.in
-5b79a8e5f5dcf687693890dad00bb905  gdb/NEWS
-8b49462580853b25a40a9905e99b2a49  gdb/PROBLEMS
-6436c1653e71c7a48a5632eea5d98b57  gdb/README
-a64cfca22cb6b4d38fd85a2e19481a07  gdb/acinclude.m4
-e0c2b31ad9d1aefd5fd831c317d2e6b4  gdb/aclocal.m4
-1c472d74932f46db760affa6f79b69ee  gdb/ada-exp.y
-402ae1aabef946220e4c937c3f1e50e0  gdb/ada-lang.c
-ede060dc6d3dfeb71d2f68323d3a0054  gdb/ada-lang.h
-025830c1374bf6272013797e895a2225  gdb/ada-lex.l
-3f7b3e677e26648e4650406df9cc62e4  gdb/ada-typeprint.c
-aeba2bc3d8c22527ca076200747386da  gdb/ada-valprint.c
-9b4590e4f1b630291f2b0451611e6463  gdb/addrmap.c
-4275742654285166b4d356aee7ecb752  gdb/addrmap.h
-dfd2a29e0bc81175e3b71756511188b2  gdb/aix-thread.c
-d257849873bf14faa68cdbf04f357974  gdb/alpha-linux-nat.c
-be760c6da15fe735dbd06172feffe61a  gdb/alpha-linux-tdep.c
-fab1a25297be8b53f267b3f0a7f3c65f  gdb/alpha-mdebug-tdep.c
-508290e7f1cd6ce45449448c465b1e93  gdb/alpha-nat.c
-a197c7c6764d3762cc6c2cb321cab6f0  gdb/alpha-osf1-tdep.c
-d6eb5cf71b9f3db7c20f59b8ea85c0c0  gdb/alpha-tdep.c
-65a81c537bd63c4e715890b3c278bd8e  gdb/alpha-tdep.h
-3fc819c515b8fff600943d9b54bf31a9  gdb/alphabsd-nat.c
-e8df9a4b5dd3537085ad5880d9a874b9  gdb/alphabsd-tdep.c
-5f77478ac16b46f6b722b324fb16940d  gdb/alphabsd-tdep.h
-6a314f29e1ee744f9abf59e7dac2ecba  gdb/alphafbsd-tdep.c
-59960b621daf522f1ebaceaa581f7897  gdb/alphanbsd-tdep.c
-3283f5c26f8c6adaecc16b8b5c93caae  gdb/alphaobsd-tdep.c
-9dd9197748bc4e621e026864ac19d743  gdb/amd64-linux-nat.c
-ff1cfe25fd1fe846b43a98d426e039dc  gdb/amd64-linux-tdep.c
-d0bacff0cf198c3da4932ddf690e1922  gdb/amd64-linux-tdep.h
-3322a015d5ccdb3933018c01efa5a304  gdb/amd64-nat.c
-a99587923cd037d838a2aae3363e2fd4  gdb/amd64-nat.h
-7e74c5b6e9c5ee1662c15c1a07091dc5  gdb/amd64-sol2-tdep.c
-cc78ae95c5e7edd8a66eb30c02e4ab49  gdb/amd64-tdep.c
-dabe1b462ab7e423cdcca0b43259c2a7  gdb/amd64-tdep.h
-fce52fc78a973579d1911b664bf33bf6  gdb/amd64bsd-nat.c
-04f8681438fbfa94471078516b2f7b2a  gdb/amd64fbsd-nat.c
-9e97f851960968621af6d990bb2e2d1c  gdb/amd64fbsd-tdep.c
-a9b789bdcd5cc501aaa99d2862a997d8  gdb/amd64nbsd-nat.c
-fc88e29eacc91a81032a58d15f93bedd  gdb/amd64nbsd-tdep.c
-0e8795ad2939bfaadeadfea346d8bfd6  gdb/amd64obsd-nat.c
-795ea0ccf30e49a4314889c40700dda3  gdb/amd64obsd-tdep.c
-6bf18a0592709bdc3035ba9ad75496e1  gdb/annotate.c
-99469211935559accd5e6e523c4b5ba4  gdb/annotate.h
-8a92532885a5ea4b532768163d60fb1d  gdb/arch-utils.c
-97c4c01298fb85ac02137e1a4db9835e  gdb/arch-utils.h
-ac7a85c30614beb3987f6d0f56775f69  gdb/arm-linux-nat.c
-0afdea42607b90294dedd7c063c5575c  gdb/arm-linux-tdep.c
-5cc25fba8bfa6202d52f08575998366d  gdb/arm-linux-tdep.h
-1aca62343b1b2bf6d0409ab6dd3076c1  gdb/arm-tdep.c
-a7be5a5fce8bc59972150834cb3cee9a  gdb/arm-tdep.h
-aeb332c4fe7456a5268ed1a375e3029d  gdb/arm-wince-tdep.c
-9e0de9c2ca720af100e2d6bedef970a8  gdb/armbsd-tdep.c
-f4fb4ad86c8d0c6519c28efde5ba3729  gdb/armnbsd-nat.c
-7b605854aae7c5e0249f9f2d9ecffca9  gdb/armnbsd-tdep.c
-12cc11670d7d7399124b8278f0c857ad  gdb/armobsd-tdep.c
-54df1d348d8ddde71b3a4dd07ba4dd8a  gdb/auxv.c
-d78427c82c3d53da27fd8ed2361cd536  gdb/auxv.h
-2227084e5e99a22f2611d4bdb7657100  gdb/avr-tdep.c
-f194aa8c03ef1940cabf03afd1d0c8d2  gdb/ax-gdb.c
-e3cde1bc35e85f675af9b9a89e56a2a5  gdb/ax-gdb.h
-bda521d6ccb5952d7c2c1d7be33b10f8  gdb/ax-general.c
-c1f087422cb8f49a480809c7965e8fbe  gdb/ax.h
-ec85dda2a6a6df56f95a385e3c9247cc  gdb/bcache.c
-dba79060b11c840a32043ceecad7e45f  gdb/bcache.h
-2cc80235d6be16bdb0931399ede99d95  gdb/bfd-target.c
-44e1bcec4bfea201892e7ed51b511bd5  gdb/bfd-target.h
-a9f1efeca5f602c632636bbf534036bd  gdb/block.c
-b9bbbd21a269f337d42e288f07758d3f  gdb/block.h
-103ed6a5c3d0d5332aca4d1ed1a7e8da  gdb/blockframe.c
-a20b1b1a71f329fe2f76eda5f9646679  gdb/breakpoint.c
-cca7ad1b8c17c248decc6c30efc1a8a8  gdb/breakpoint.h
-a896985f2d262472659c6d340a9c2874  gdb/bsd-kvm.c
-87b309323fa202973897c0dfbc1f11b9  gdb/bsd-kvm.h
-d814c68bd929913fd55dc991f10729a4  gdb/bsd-uthread.c
-f9448737cdeb11b2aed0e90b0c9c69c1  gdb/bsd-uthread.h
-6c4c9bcf3bf4e18b642e43cdb1f05ac8  gdb/buildsym.c
-7c6c9903bf3da1f395d8d0f7d94f1a04  gdb/buildsym.h
-5e341e20c7879780683bf00ce1a944cc  gdb/c-exp.y
-f0a547ad4dfe3416d38fbb0af156ca0c  gdb/c-lang.c
-48d9194f5e72c33620f118fe63364576  gdb/c-lang.h
-e447b65dd155b06f24623651964e2ba3  gdb/c-typeprint.c
-61b657c5b4e2ea2302450ec2967cec7f  gdb/c-valprint.c
-1cf1b4d3d412a558136077bfaca43dc3  gdb/call-cmds.h
-b25ec35cf33e8ad79d6e638003e5801e  gdb/charset.c
-b07e3028686f6984a5378a4c9f155e50  gdb/charset.h
-7f162cff568b24f9c893dc2658bea080  gdb/cli-out.c
-89660afe8edb2cd5f74bdba9b4eab954  gdb/cli-out.h
-4647a27d83fd5c2abbcc966c11bc9a1b  gdb/coff-pe-read.c
-243a0f8e88a3257b6765b824f3fb2c0b  gdb/coff-pe-read.h
-8be19fd4fbd188cf9807d713699069bc  gdb/coffread.c
-ce8c8eda23e939f817c576a05ec0e250  gdb/command.h
-8ccd29105ad4647254abe94ca3b63fd4  gdb/complaints.c
-6a135a60d6230358673c813c4bb5e772  gdb/complaints.h
-d7a88312084d15480a7e0746b5a1d6e2  gdb/completer.c
-7d89d49bd1f019b254a9490849e23c23  gdb/completer.h
-f3376c0b48f54f2b803b5a9cb2a03cae  gdb/config.in
-b91bb580d10ed904ca750e55bae8b0e8  gdb/configure
-e42dfd58c31ce9611043f5db7f6b0e10  gdb/configure.ac
-a7511705ba0aee2689abfc892d5873a7  gdb/configure.host
-d6424afa5ef09b7d7fe665736a9a5514  gdb/configure.tgt
-f06ccf06b255a9e149efc728de7c5394  gdb/copying.awk
-e6d5fe91a731e3b4223229d77bf80dd6  gdb/copying.c
-e936db7b91e5eb8489e4f56338b72073  gdb/copyright.sh
-107ca117085362243bed24471bb2d611  gdb/core-regset.c
-904fb3e18f9749abf9f5e7ef1800202f  gdb/corefile.c
-e916a861488e94cd1d3c9274b7b852f3  gdb/corelow.c
-136f17196858da10ebc07647bf8441da  gdb/cp-abi.c
-847d0d6240c2e21f6714d5e20adc426a  gdb/cp-abi.h
-7f79a508813349416c010db771692293  gdb/cp-name-parser.y
-aeeeab98fbdde60cad54e2540c9569c7  gdb/cp-namespace.c
-8857daaf892719ec91d326f73e8cfc0f  gdb/cp-support.c
-142378f361736e42330ed29fc07f08bd  gdb/cp-support.h
-ff4ab3037932c954fdd05df458a6aab8  gdb/cp-valprint.c
-478f589b4fc548dc811aa34e44431806  gdb/cris-tdep.c
-1ba4c33d54b060876ad19944e93cdfc8  gdb/dbug-rom.c
-f6cbbe130a8f8c56c8afc5f0d26ef36c  gdb/dbxread.c
-0746be00830f00033dc7c47b741cc96d  gdb/dcache.c
-74d5dee3c438dacc02f5a5e333925405  gdb/dcache.h
-76f9de1b18c059a225879b96edc27080  gdb/defs.h
-22a2e535a3d97d96f9f54864921fc199  gdb/demangle.c
-10bb45b72010650972a12d8a8a6f484f  gdb/dfp.c
-a6c34f9fbdffef9b0184a041beadb04c  gdb/dfp.h
-7528424f444ed54925b7708600d27361  gdb/dictionary.c
-5c12324a3b71396bca78a417cf1c3894  gdb/dictionary.h
-b80724742947fe0c390938eb1357d982  gdb/dink32-rom.c
-be64e370d31c52ea4b4c39d1e82a4183  gdb/disasm.c
-aa212bbec32ec3a69692220b0d0d9cb3  gdb/disasm.h
-4f83ad0fa510b30d23bf1423e72007b0  gdb/doublest.c
-d5c410c882abc09f581ab34ea25d1814  gdb/doublest.h
-37efafcdaf6979af04612eaba2fb7e8a  gdb/dsrec.c
-935b48440841e38c63450d460a086f40  gdb/dummy-frame.c
-b0a3a84b118aef402fd9c8ae650a4440  gdb/dummy-frame.h
-42e651637acfc81afc4f679a4c007e2f  gdb/dwarf2-frame.c
-1cda6fd9094bbb3c58655abd0ea728cc  gdb/dwarf2-frame.h
-76b7757d93b2b31f2860542260346e12  gdb/dwarf2expr.c
-a8ca6c803488f4a1191432a29d03cbda  gdb/dwarf2expr.h
-9f497806163685c1116cbce3b9153fd9  gdb/dwarf2loc.c
-6b26f75dad58a4d8ea5777cdcee7d309  gdb/dwarf2loc.h
-1b64efe1925c987e67cfdc0766e027e8  gdb/dwarf2read.c
-7ad08fce7d9f4d093e3ee1f801281312  gdb/elfread.c
-f9ff01b45a3cf18e5da9aa81149e371d  gdb/environ.c
-bbaba0d9b9578d1c2cd4261d8cfb427f  gdb/environ.h
-73cccab6b454054fa8a7222cbb307b5f  gdb/eval.c
-f25f28d0c323fc6d46c1b23d843bfee0  gdb/event-loop.c
-cb70f9433d8ba1c2164a9df720a86b8a  gdb/event-loop.h
-9a837a2417b7a251130b484b487a38a2  gdb/event-top.c
-c2b1609705406deebd8b613673236e25  gdb/event-top.h
-1f6b545be0b6822eca215d0b5f1edfc2  gdb/exc_request.defs
-fc7485d3b753dfce554239d8817c044d  gdb/exceptions.c
-3fdf62efd74f18c0420e5340ac4f0869  gdb/exceptions.h
-a77b15c88f8d9727f9c499f5b3c6ec32  gdb/exec.c
-4af409ec28d2b50c86011ae3db47bdcb  gdb/exec.h
-b35fe673ded3e1bd366057cf5d2eae29  gdb/expprint.c
-69acac058b88bc071db4ebfe69ac8f7c  gdb/expression.h
-c1f7213baad59631e11e4f6572460841  gdb/f-exp.y
-aaff7f65b562c3be1b26d56e34adbdb5  gdb/f-lang.c
-e81d6c5d6b2902e723961b97cad01d0e  gdb/f-lang.h
-831dbaf4c84e02c2f6ddccdcd6ecb3a7  gdb/f-typeprint.c
-ba55ded02a53e00b56db61518241c31c  gdb/f-valprint.c
-d8ee8265f45486f3b87aed944832bc3c  gdb/fbsd-nat.c
-6f6a6e7c9df17feffd067a6098d8d3cf  gdb/fbsd-nat.h
-8a53ac3e49f196e9c60190d7505a617f  gdb/findvar.c
-799aa1af51d747ebaf1e1a7241002ec5  gdb/fork-child.c
-f84fe734418f08a7a432ed08544bd748  gdb/frame-base.c
-9f46c9097b7551a0cbf1436e439cdadf  gdb/frame-base.h
-19450c9b49f73d19b58b61f76c9603dd  gdb/frame-unwind.c
-6cbfdbf9470aa390a470b289f173e145  gdb/frame-unwind.h
-c25c6f7c7852a6f830bfe54edd3ece64  gdb/frame.c
-e3311c36efe593e7daccadb3e6679c3b  gdb/frame.h
-664705ff3161dfe4494d325daa0b0aeb  gdb/gcore.c
-60a63b8f8ae908637c3dab7285f6272e  gdb/frv-linux-tdep.c
-032a100df05e1ff1306bfc9ae0ab747d  gdb/frv-tdep.c
-4d78a9d5d10e78d923929b7d9667d4a6  gdb/frv-tdep.h
-253356091d28cb863f3e9996cdf07f1e  gdb/gdb-events.c
-090f660cb805c304744efa3564ddb4b4  gdb/gdb-events.h
-6afba00c4c0c777d978c14bbca37875b  gdb/gdb-events.sh
-1e84eb5584630ce153fe39897d50954b  gdb/gdb-stabs.h
-ae226bca21ce0f553dbce038ec6bbceb  gdb/gdb.1
-ca84118e22a9bc7d45eb59564d1d13a4  gdb/gdb.c
-9198f7b1807c968098814aa2a3901aee  gdb/gdb.gdb
-631a3d90044b6ba417795538b7d7bcb2  gdb/gdb.h
-72faedbfb36871b704a264d0eb4da1cd  gdb/gdb_assert.h
-1c33a842c1c4a67547012d29e18f3429  gdb/gdb_buildall.sh
-7617eb3db5e3f931fbb52d4dc456a80b  gdb/gdb_curses.h
-2673c9dd8c00a7e94277b152030e491c  gdb/gdb_dirent.h
-c50f43c2ac1bde3f92d7b7c3ca16db12  gdb/gdb_expat.h
-6cd10f9b9b1be6652a8b78fd837d0aad  gdb/gdb_gcore.sh
-9d9baf6ee79baadc2a660370cb2c1afc  gdb/gdb_indent.sh
-747bd2ace33db51ba3f82783d58bae4b  gdb/gdb_locale.h
-a3a68db037e7758303a76b3777d9c61d  gdb/gdb_mbuild.sh
-7ba580ec3457dc7cdee2023975236c38  gdb/gdb_obstack.h
-79c0175cc157454c47d924e89a0ab7b1  gdb/gdb_proc_service.h
-c9e70ed1ab00afa825eec4d86f85c587  gdb/gdb_ptrace.h
-b2dcaae1dc627ecb118d2287e472465d  gdb/gdb_regex.h
-44f80b7420b2a2a8b93d90b7690fcaed  gdb/gdb_select.h
-763eae44dd17bd5d5b7e906823a0c74b  gdb/gdb_stat.h
-153361d13fc39307c37453d09dc6740a  gdb/gdb_string.h
-a96c188936227190ea66f289d6fe6bed  gdb/gdb_thread_db.h
-6e800866a7dd32b707fe0e2b915af260  gdb/gdb_vfork.h
-a6750eaf82080eab9ecf399857022975  gdb/gdb_wait.h
-107bd4655fc2f042b0ff8305b8d4b2f2  gdb/gdbarch.c
-c329d8221b9041ec8bad3fa81560c247  gdb/gdbarch.h
-b1124a45818d2b1c3ad35645f43b5a08  gdb/gdbarch.sh
-51fb37f394f88fc51b136a7114fd597c  gdb/gdbcmd.h
-8afdc2fbe79a2177f5bb5ea4f7230af9  gdb/gdbcore.h
-fc3a24041b070e4d007c5847e3ce3b69  gdb/gdbinit.in
-a1540660b9d480e531fcb1ea5c72cf19  gdb/gdbthread.h
-07fc91e819807bef1dba88a91b95ae25  gdb/gdbtypes.c
-0f3553266b4915fddedaff0ee0b85eba  gdb/gdbtypes.h
-09096a3e3cb5d69801bdfc67281b1e7f  gdb/glibc-tdep.c
-36112e602c1f4fec605d53578ddd3e34  gdb/glibc-tdep.h
-82e7f1f5451d0f42d921b570c56b9d40  gdb/gnu-nat.c
-bde6ce83a441f76257c1c680e210d091  gdb/gnu-nat.h
-d803077ec9d46d0884d838d38b6d27c8  gdb/gnu-v2-abi.c
-693e4ccdec94acbdec9875fc8925405d  gdb/gnu-v2-abi.h
-382536845ce3d514e0a2bfa9ad936561  gdb/gnu-v3-abi.c
-17da90636db764cd30b655a8a3715e4f  gdb/go32-nat.c
-63b4a64d491bb2120fcd5284ff4b02b9  gdb/gregset.h
-2dbe379cc52661a71d1cad0457a486e5  gdb/h8300-tdep.c
-a37fe4c15b9b4266b1f094de3a915fb5  gdb/hppa-hpux-nat.c
-d99a3323f5b9111f54878d748ce71f46  gdb/hppa-hpux-tdep.c
-a4e8f3e5b1faeaa5e2f3d384ab2aa173  gdb/hppa-linux-nat.c
-21019c454d58b754850dea8c7dfd3e53  gdb/hppa-linux-offsets.h
-ed75e1f299626508b95ec6b5d6b7e8fc  gdb/hppa-linux-tdep.c
-2f2f7a2f1ea42eab9041e7ab0275b86a  gdb/hppa-tdep.c
-c052d9c527f28d47f6554d6510f330cf  gdb/hppa-tdep.h
-d6c850f23ec960442bceaa21b9639e5c  gdb/hppabsd-nat.c
-a43c04cff7ab60ae77c1f2bbd2f3788f  gdb/hppabsd-tdep.c
-2f34f77940d55fe8793a7da81563965b  gdb/hppanbsd-nat.c
-fe60d24064b24e6216c3f6d3bd0d6d1c  gdb/hppanbsd-tdep.c
-c110db5330519133ec1a7789f3c6b84d  gdb/hppaobsd-tdep.c
-cf82f2ffa6971ac5eaeaa9b0f51ae8e1  gdb/hpux-thread.c
-1444598c38f6df628ed75825453607f9  gdb/i386-cygwin-tdep.c
-8619e89921e8d345ca4f7ca66482f978  gdb/i386-cygwin-tdep.h
-7fdb85a846a169a6746000115ac3ec65  gdb/i386-linux-nat.c
-0af423faca337a9a0343db187d3f68d6  gdb/i386-linux-tdep.c
-1ddbc6bb52a915956297f11998215fbd  gdb/i386-linux-tdep.h
-bffeee0dad311a971b2c9c1411e9ba40  gdb/i386-nat.c
-5bcbc7732793d8a5f1441da62c2ce092  gdb/i386-nto-tdep.c
-10d39da28cc0b2a00393cbbb8f945aa1  gdb/i386-sol2-nat.c
-d208221e4a5dd5160c8e2a405281f953  gdb/i386-sol2-tdep.c
-3e019a9ef1ea4d05b7342841e4b54e69  gdb/i386-stub.c
-8e2f46e8be676391d942c0fcda242c13  gdb/i386-tdep.c
-653351d917a7b945d6bb391581267090  gdb/i386-tdep.h
-30afd8567ea67b75d98e32d2198c770a  gdb/i386bsd-nat.c
-29bd526b07fa7ff126f0a69ac4c7ea6a  gdb/i386bsd-nat.h
-c8502523475ee7aafc283db9ecd00068  gdb/i386bsd-tdep.c
-de83428a92d4e5c758fec768794c9686  gdb/i386fbsd-nat.c
-95d488af6185d22e2f12eddef61fb3e5  gdb/i386fbsd-tdep.c
-a72d33755266c55e38c84cc61e05ac02  gdb/i386gnu-nat.c
-31504394e361012c517dce3a906f67de  gdb/i386gnu-tdep.c
-e566a2b755c9c9664a54669c1cf9c237  gdb/i386nbsd-nat.c
-1ec350b1797a7c2303608a2a7205fde2  gdb/i386nbsd-tdep.c
-75a6c72186289e7a2d13f891a7e8d1b8  gdb/i386obsd-nat.c
-5c532f9131c4fdd2164a972a93860d9d  gdb/i386obsd-tdep.c
-55e28398b902e8c51b7508f371c8ef0b  gdb/i386v4-nat.c
-c40c8fbbd54cc443cb7b880a1556607c  gdb/i387-tdep.c
-e3e61243a7ecf529c09e4092aa48a705  gdb/i387-tdep.h
-8d9dcb326d70f7d25255fd36346dfeaa  gdb/ia64-linux-nat.c
-87fda5ab3055a03c06340709d1f4fe87  gdb/ia64-linux-tdep.c
-c39a5bad5b2e1883d268763110b6f235  gdb/ia64-tdep.c
-d4d3948173c54aa74ef1db32b623c36f  gdb/ia64-tdep.h
-d62867749a8c65cb7e0cfd63e444c995  gdb/inf-child.c
-0f1d7e25c463660d80462ae638aaa14b  gdb/inf-child.h
-8aeff302970991793526566408c48524  gdb/inf-loop.c
-6d0011c8f826e0ed26fcafb2d8eeaed2  gdb/inf-loop.h
-9a9ad451cdf60b378b352b8865891086  gdb/inf-ptrace.c
-7af50eb1ae934ea1fb3ae93e17b83f78  gdb/inf-ptrace.h
-973d06d8f14c895858441588457b310f  gdb/inf-ttrace.c
-e59f146236a0689c20e3dd8ed2e9de76  gdb/inf-ttrace.h
-8255fe71d8ecfc660e95f1330f4e4d66  gdb/infcall.c
-dc3089fed95b3a2c6de5343bd0162d68  gdb/infcall.h
-6c1d1ba6c8ac31e8ad411170dfc9ba50  gdb/infcmd.c
-3bdefca8a36bb77ba321f1e69298a500  gdb/inferior.h
-99028565e909b57c2fc9fef1db901350  gdb/inflow.c
-a5ac672fef29a2ebecb0a915f208de75  gdb/inflow.h
-ad1e8d2d476089cb1b1f8e3b96ec6795  gdb/infrun.c
-116fc9f1af22177a0631319fb2d814e3  gdb/interps.c
-b1384da9bcc104362c70477400a6f7f6  gdb/interps.h
-41c66a04734e9d8683e5766eee1b2437  gdb/iq2000-tdep.c
-1b2f3c7498fbdc542f02c39186f3aa50  gdb/irix5-nat.c
-c447a1d223ec3fee6a13d6d760bf1713  gdb/jv-exp.y
-e51c92af25c450ee121b16792c73547c  gdb/jv-lang.c
-a4fd250e736ab95002fa76da4658a28f  gdb/jv-lang.h
-af6471fed00d7658159892dd0385660f  gdb/jv-typeprint.c
-d7e7baa6ee3f3da91c85755efeb13075  gdb/jv-valprint.c
-ff35eb2f6669557c01504e88ff164767  gdb/language.c
-76a5d8a3a108fd6f29191011feedf62d  gdb/language.h
-c4f36163bbf60c0eea3ac0cb061919ad  gdb/libunwind-frame.c
-196d254dc337eabc37f6aca80f07829b  gdb/libunwind-frame.h
-7617958c58be612dce0cfb6e5358a167  gdb/linespec.c
-5bbb8e39879096ba49ea2b9442991c33  gdb/linespec.h
-da37c3ff3b9567996c0428fb9a35680a  gdb/linux-fork.c
-9f3cd64ae4fa77333f42c06689cc3dce  gdb/linux-fork.h
-34f66e3454ebf21b3ab6d2c7f0912300  gdb/linux-nat.c
-46d649857bf5ae7ef46bbb9b806381e9  gdb/linux-nat.h
-4ff0b3c02e0a8def8560e2be913c8ce3  gdb/linux-thread-db.c
-d12f1c0905f1759d4bdadb0ce75cdfe3  gdb/m2-exp.y
-5d8b296b6fc754581fa86644d9bd9be6  gdb/m2-lang.c
-f32ef5ebd1236d2f6eb110dc70d80429  gdb/m2-lang.h
-8c0f66d2059f5da3a0d39b0c49e9aab3  gdb/m2-typeprint.c
-772ea59839f070a70ad5d2950ee8efce  gdb/m2-valprint.c
-870010a34f3b1a1d2640b11c94ff25d1  gdb/m32c-tdep.c
-8451965430f9272fd5f0ac9cb12a044b  gdb/m32r-linux-nat.c
-c9a1436c9accadf97ff4e50dd9bcb687  gdb/m32r-linux-tdep.c
-da8d6c0bb4a6ce72ec86afc9858346b2  gdb/m32r-rom.c
-ef7f67e5720cf7b193349f8687243947  gdb/m32r-stub.c
-c402bd5747a60e4028126faecf9012e8  gdb/m32r-tdep.c
-e5cc5559314034876590ba4bc392bbdc  gdb/m32r-tdep.h
-5dc4dd0fe7542574de289574d0ba5fba  gdb/m68hc11-tdep.c
-04ef5745a7e6781587638a72b849da35  gdb/m68k-stub.c
-74968a80f7ed0729abe97f865cf0cd9e  gdb/m68k-tdep.c
-3b7f2ede41a7b6afb63838d6a7f0771f  gdb/m68k-tdep.h
-9a0f243fddb012e6d301943ccb4daa7a  gdb/m68kbsd-nat.c
-522141564593b17cc01522992f03505a  gdb/m68kbsd-tdep.c
-7ee886fe9b31e7c54bf7f655abc62983  gdb/m68klinux-nat.c
-a4ee7372e59d7c9faffaf7a0e4ba042d  gdb/m68klinux-tdep.c
-deb3a3564921ff95d21cfa57bc870e0a  gdb/m88k-tdep.c
-4fc0848be4551659841de8b97fa962e7  gdb/m88k-tdep.h
-747e8dade7f65e06409e53ca46988355  gdb/m88kbsd-nat.c
-23be578cc9bace5b4609dcaf90b2575a  gdb/macrocmd.c
-7e51b2a4975cf75196431f64801ca4ab  gdb/macroexp.c
-f774b99f7c0b0f55874d90d1603fce38  gdb/macroexp.h
-b5fe5889f41065ce7e84d06b14336009  gdb/macroscope.c
-33e9aff3c79945841fa8aeb77239a45b  gdb/macroscope.h
-79693564780597471684efc19c6202fb  gdb/macrotab.c
-af8e65054177f9f95c2e6144816cc751  gdb/macrotab.h
-2c6fea0db8ac12887e7a504826c5fd18  gdb/main.c
-4bfe53722559f4a1cd67677800054e11  gdb/main.h
-c2c9a2c3010ebfe6c7e61458275c33d3  gdb/maint.c
-0e010b94a66cabffa3ab7c9da19cc40c  gdb/mdebugread.c
-a7d7ab80f575dfc386fb7b8b89d94128  gdb/mdebugread.h
-d59b112c313707a7a2b6cb4875353243  gdb/mem-break.c
-4dade1985a7dae39b1be2d1f79e759a0  gdb/memattr.c
-b669b4209d77645efbc74d19af152e6f  gdb/memattr.h
-51be04617d1b873283bf0aed13dbd907  gdb/memory-map.c
-2e82e076e7e2ebd93e9883d743a5bdaa  gdb/memory-map.h
-52290926e677b52a2f9ec2373f68ec55  gdb/mep-tdep.c
-5a65ea47c40b73cb33e52e34cbd5df06  gdb/mingw-hdep.c
-685e5b48a1d3400a68168d828fbcc3c6  gdb/minsyms.c
-f2a97701d2bee15049516591ba10b0c5  gdb/mips-irix-tdep.c
-2aa6cfba096e893c2be3ab4831799009  gdb/mips-linux-nat.c
-eb6460321d669449acef5a5bad094a89  gdb/mips-linux-tdep.c
-2b3c8f4cbb92f54577719abafed73490  gdb/mips-linux-tdep.h
-4e49384550bb95e34aa284a0bd76fb27  gdb/mips-tdep.c
-5b68a4cc3ef7782f91f9a9648cf734b4  gdb/mips-tdep.h
-ac906be47be40d89800deb71a10e1218  gdb/mips64obsd-nat.c
-fe8347b4b4a7fb416b887f2cfa37e316  gdb/mips64obsd-tdep.c
-53b41c8407fee95eb96df76cc3510ac5  gdb/mipsnbsd-nat.c
-3111b1d81593aa7b72642383797afcbe  gdb/mipsnbsd-tdep.c
-d80d3decf7733f40d42068531562a18a  gdb/mipsnbsd-tdep.h
-2ed00c0d38717229c352c209ac9260b3  gdb/mipsread.c
-95aabbf786a9d22c0eb794d487b3c8a9  gdb/mn10300-linux-tdep.c
-4e9344dc1ddc0bec49d6ddb66b70cfc5  gdb/mn10300-tdep.c
-49bff69db479910db2a1cb804b4151c0  gdb/mn10300-tdep.h
-9659f69c6501971816c6f7ce45a9191a  gdb/monitor.c
-1a457809ba070de30aa6b8bb0bcc9740  gdb/monitor.h
-31c83b4bb1c5c9c771fe8e1ec3f1e9ba  gdb/msg.defs
-24096aca3294cab3717506c2c69a7272  gdb/msg_reply.defs
-abcd766cd9a467681fd17c29db890fce  gdb/mt-tdep.c
-1a6904f71010c73904e9634a8ff936c3  gdb/osabi.c
-7d17d15ddc6d8670f3b7d5c4e70e3d9d  gdb/nbsd-nat.c
-0f765de9b9dbdd160d49ac9a5bfb70ff  gdb/nbsd-nat.h
-77bd21b9c6cf28e4b2b90e4e7843eeaf  gdb/nbsd-tdep.c
-cf812132198e7d161b2e9579d054cf27  gdb/nbsd-tdep.h
-21b85dc2ed09d1125c8ab4fbdb043c7a  gdb/notify.defs
-c0a74dedca780f6d62dc14b1cec5cf0d  gdb/nto-procfs.c
-0cd760dfec11690c694cbb4ed7b55200  gdb/nto-tdep.c
-9c4b83c3ee442b619fe4b2f2a69587bf  gdb/nto-tdep.h
-a7a2a0441c89d97929246904bfcfe48f  gdb/objc-exp.y
-5e1c9d3457717f2046035526f6e04991  gdb/objc-lang.c
-206a9cd009b595edb2ac1c024d140e7c  gdb/objc-lang.h
-ab9f6420cdc3ed3bca99e21a3ddc4ae1  gdb/objfiles.c
-5e39878894fa31a1d3a0151d9bded0af  gdb/objfiles.h
-364405c7f886613dd73f3137240dbf68  gdb/obsd-tdep.c
-8374ce2c71a555d31a9c2a8b99a56faa  gdb/obsd-tdep.h
-0ba50084965117a82e4039206d9eed6d  gdb/observer.c
-32a9b1f7ddaa7827eee64eced017fb1c  gdb/observer.sh
-b78689f9088bcda5c7af507657276d53  gdb/osabi.h
-bd9da9b80e3b99b9f8cd2a173dc82923  gdb/p-exp.y
-c5c8596bb67c3df6f72ad73fae8f28bc  gdb/p-lang.c
-a886f0f260c07020d8c053f717956290  gdb/p-lang.h
-5912c1d37439e2f4c88f2e4b47351d3b  gdb/p-typeprint.c
-5a2dc750df22907af615caf4846877a8  gdb/p-valprint.c
-2ba8aef1c0e34c5e3486abfa7c5fc7e9  gdb/parse.c
-df62f634cc9b38ca7d478fcb0ad57a67  gdb/parser-defs.h
-e3502610bebbd850b0eb13df47f4c1a1  gdb/posix-hdep.c
-adc9f46862b04a089d7727ebd280a4d4  gdb/ppc-linux-nat.c
-fa0f5a5f8a286e1806e04ac1b06e4fd7  gdb/ppc-linux-tdep.c
-358f401f78576197b971bf21dac7e836  gdb/ppc-sysv-tdep.c
-79949f9943b78c9d81794bac5b3c6c73  gdb/ppc-tdep.h
-81a781bf789f855a36c336483a4ef4d3  gdb/ppcbug-rom.c
-b2e16ab9122f3945e6aa90874daa2c86  gdb/ppcnbsd-nat.c
-c9169b1404b71ff4371d24cdd263d208  gdb/ppcnbsd-tdep.c
-14fbfb9f865ca546ff60e89f160cfb79  gdb/ppcnbsd-tdep.h
-6014fda6e831cd1788daed70fd329909  gdb/ppcobsd-nat.c
-631dd2fb54bf06a7952b1ee029b26e4a  gdb/ppcobsd-tdep.c
-7f044956b2e63ab3421cc1676632cf25  gdb/ppcobsd-tdep.h
-f6ad53f140513fdb667bc5f0f542e166  gdb/printcmd.c
-bc43d93898eef71cbc2675f844034306  gdb/proc-api.c
-51d28ca167c2362a937b05b9741d3b04  gdb/proc-events.c
-ec87d284f292a3544478c397fa83367b  gdb/proc-flags.c
-914095b956b6e343300baebce0021727  gdb/proc-service.c
-68b39fa2a370b0b19f39d85d8e241028  gdb/proc-utils.h
-317da96af03e7330ad8b6c3aa32497c4  gdb/proc-why.c
-1de2e2c8bd6fc22a95d8484cbf584e4d  gdb/process_reply.defs
-55c49dea3c809464780d90f4bf6a33dd  gdb/procfs.c
-27ec1464fbb45ff1e22c17c63c055ef3  gdb/prologue-value.c
-b4828fbfc50489584467ec54487d301d  gdb/prologue-value.h
-a64eb16bb7a40a594a4c717d05876d7b  gdb/regcache.c
-197875f86a2a0a1a6ac03472138d0dad  gdb/regcache.h
-6831622c478bb4c07778a3c5f084ca47  gdb/reggroups.c
-736ecf70948a9d7a9c80f2313ead3252  gdb/reggroups.h
-086badf08a3c27583d7c493468467c42  gdb/regset.c
-60572a7767a6c594408114c72be1cfd8  gdb/regset.h
-b72dd52f0aadde83e5981b2cbc96d9db  gdb/remote-fileio.c
-f32aef228a72da1b9e9dbd7422e75c73  gdb/remote-fileio.h
-e4d76d81c41971a75c9de28864e08375  gdb/remote-m32r-sdi.c
-b93a8c42849800eb0166de377a4bc543  gdb/remote-mips.c
-c0fc64ebc8f72cdcc11ba96837a451eb  gdb/remote-sim.c
-178cdba53328ba8df867dce45942a2aa  gdb/remote.c
-085c918830075f36ea412ef6d5ba31c0  gdb/remote.h
-2e5cfd98dd4f8ca864a2e1edecb91fe1  gdb/reply_mig_hack.awk
-a637e9682adeff4fb9b9155dd4a743cd  gdb/rs6000-aix-tdep.c
-c6785d8948bafa3cc4dbcede6201b5a1  gdb/rs6000-nat.c
-947090653e2fbca5d350d9a654209191  gdb/rs6000-tdep.c
-b5774758ad85f56df7c6185d8a317b87  gdb/rs6000-tdep.h
-344ae1bb284021900feaf8ddddb29c94  gdb/s390-nat.c
-c6d7deb6898959286cf700a36b0cca58  gdb/s390-tdep.c
-21ec9bff03a3ca660721d2305551cf66  gdb/s390-tdep.h
-ac8288b2c5a5f65d1e5c1b33cfec3a27  gdb/scm-exp.c
-7622c6122dd9b475d10152ba29df8428  gdb/scm-lang.c
-b4dbd4c71726d6754b1bd76d30064174  gdb/scm-lang.h
-59a2af989c23384855eb143c2a16ce76  gdb/scm-tags.h
-24de90f44b746d1e7259b6227f7cbb76  gdb/scm-valprint.c
-d571e190586566db520d0ed4d712858d  gdb/score-tdep.c
-5f70fa21d964ba88039e5bef330c53b4  gdb/score-tdep.h
-f6551ef4126b477ceefe036b80e4a3e0  gdb/sentinel-frame.c
-7c99dc23d354b4278bdfa1c0cef37efd  gdb/sentinel-frame.h
-188c72ee15abc0fa1f1b61dac47d02a6  gdb/ser-base.c
-62580e5629882e41853e6afd85076bf3  gdb/ser-base.h
-0b3d8f61c70b25e0b7e9b8623e6872b0  gdb/ser-go32.c
-b03a7cd1d12dabcd52a81ae0b306ea97  gdb/ser-mingw.c
-654e2f7619d3618aede4d3857dfb6034  gdb/ser-pipe.c
-7587eb1ed80859d9e73afa05efbc07bb  gdb/ser-tcp.c
-fc89bb63de2f851efb6459a2db24b8f6  gdb/ser-tcp.h
-3da761aaa6002f4b5b77a44119ad9555  gdb/ser-unix.c
-8abbc76a3f589c94186740e408547119  gdb/ser-unix.h
-248e0043710ed5799f8864ab74662409  gdb/serial.c
-7d979be910d21c7d3b1a8bebd2e8126b  gdb/serial.h
-5dd7a73c21a239b2e9d6f2b963db9fe5  gdb/sh-linux-tdep.c
-ffc93e69a8813484cec63da022b68375  gdb/sh-stub.c
-43dcce4c4263692b886fb2ab4ed86f7f  gdb/sh-tdep.c
-d1db115ffcf78af688e5510aea938da6  gdb/sh-tdep.h
-9d4c5fca2a31267de0c746abba29c6c1  gdb/sh64-tdep.c
-fbd28f3a114e362be1c14da9b80e13b8  gdb/shnbsd-nat.c
-84edb87c7543b291cfacef87f63903a5  gdb/shnbsd-tdep.c
-edf6c06e2e1415b94d670dce9d58df60  gdb/shnbsd-tdep.h
-952689cfcb2a46bae4f199f10f80e927  gdb/sim-regno.h
-13b37f928cf3da87a96efbe0025b795b  gdb/sol-thread.c
-8732bd7e86a4fe830d5928b2ee227cce  gdb/sol2-tdep.c
-3d6336939c89cb4bb2d5c9017c84d646  gdb/sol2-tdep.h
-932a314338805169ac900110b4687fe6  gdb/solib-frv.c
-7f559d406023f803fbf1189e17345a42  gdb/solib-irix.c
-c380147220198e4acc5f5cb613346ec3  gdb/solib-irix.h
-d348ad0b7574da3ff9e29e20b780c699  gdb/solib-null.c
-599ebc5fdb535f3db60253fb7c96e0c6  gdb/solib-osf.c
-834048062dc0b2bb6bb3ed8d5d026a6a  gdb/solib-pa64.c
-7098c4d09f2d99b49838b0bc5dc345ca  gdb/solib-pa64.h
-60ac9b00dffeda09bb0edb9d0785f552  gdb/solib-som.c
-94b19c8a88e1ac18094c05c63cf3ce04  gdb/solib-som.h
-73836f16289cf5601028137f1359883d  gdb/solib-sunos.c
-b64e3140325ca752125423932005f485  gdb/solib-svr4.c
-9e05f849bdae33a3364c170b7950b95d  gdb/solib-svr4.h
-f56145ffb8ea9325f7264c4c7029011f  gdb/solib-target.c
-0d3b86db861e2e6977fea2b548debcbf  gdb/solib-target.h
-bac3f66c440d7f62badb261ef83b1010  gdb/solib.c
-d192ea649aa4cd2e970ee1cf7a5fb03e  gdb/solib.h
-31d5f60fd16b071b0a60f0946c58208e  gdb/solist.h
-04caa2ef99ebe1100da04901a7169363  gdb/somread.c
-f81062af71b1d80cb9efbf24189568ad  gdb/source.c
-bd81bdaa1a6f9da9346a9f584414ca98  gdb/source.h
-ccd83bbe8e0afe6dca93dbedfec303ee  gdb/sparc-linux-nat.c
-1ad24d3fbbdae1eadb227691dc60e737  gdb/sparc-linux-tdep.c
-e4c421edb606f82ad1bdee4e44756169  gdb/sparc-nat.c
-c6e38e3e408b1438ab3fe7b7fe5feb42  gdb/sparc-nat.h
-34f91b1805af0bb02bf714354b8fc39e  gdb/sparc-sol2-nat.c
-3e532481ccccbe727317f1f70d215e42  gdb/sparc-sol2-tdep.c
-8edc014e1b5928dd9761408fa7df0d64  gdb/sparc-stub.c
-aea2fa2b751c53182083fa3f86e5a1cd  gdb/sparc-tdep.c
-bffd6746c727d12bb018db82accdbc05  gdb/sparc-tdep.h
-533fab4f58a56183ce651ac191903e90  gdb/sparc64-linux-nat.c
-7ab0c06695b673db70528a2f40a32440  gdb/sparc64-linux-tdep.c
-dcac15da2684f8c8b51efd3ba378aa32  gdb/sparc64-nat.c
-7edf5af51dc35b95491c74fb37f50a8f  gdb/sparc64-sol2-tdep.c
-4ff546b45729046aa2793e3b2baba81f  gdb/sparc64-tdep.c
-9a86b55d76e9d67b02f21eab1bc6e5cb  gdb/sparc64-tdep.h
-5b43a7d6fb34e83fcc440e3b5c6ef28d  gdb/sparc64fbsd-nat.c
-ce81fe979308fb9760f4d27008981fe1  gdb/sparc64fbsd-tdep.c
-f6b5c28ccafa9477092bab346c9cb451  gdb/sparc64nbsd-nat.c
-773fe0cc3502f55407f721ced544816e  gdb/sparc64nbsd-tdep.c
-0269c52997478bc111808a0e94959979  gdb/sparc64obsd-tdep.c
-e3586f8d726d7769f6178d5244e68a04  gdb/sparcnbsd-nat.c
-7d3f728b5e48e2afe4d241f76ffecd01  gdb/sparcnbsd-tdep.c
-a986df021943a3513349b4ee918429e7  gdb/sparcobsd-tdep.c
-2cbb1df57638fb6adbed7d1c73c03d20  gdb/spu-linux-nat.c
-770bad4eb9f92a5f841af9f75f0ff470  gdb/spu-tdep.c
-db2049233b5441a41d1d12599d009b29  gdb/spu-tdep.h
-1a92646413129209f35c6b151b1a9b1c  gdb/srec.h
-ca4e5d4cb78e0aa5bfa51132afc8feac  gdb/stabsread.c
-9fd647a9d4eb51a07f6e24945f924d92  gdb/stabsread.h
-ef82ed48ac894dec273d6aa22bb6c095  gdb/stack.c
-d48fb79b8c9379f89bac271c7fad3755  gdb/stack.h
-87dd3335a905a7c670bf014ddd9f9f15  gdb/std-regs.c
-43bb40bc856002b19d393d850842397f  gdb/symfile-mem.c
-79d06c933ef10cf5da91ab814cb85018  gdb/symfile.c
-5027d07558bc752fc649103c38056ad3  gdb/symfile.h
-e69e6426a45d021c856188b376d61223  gdb/symmisc.c
-f7c2cde7d017350dbf53803bdd43b398  gdb/symtab.c
-923ec0d5ae8704dd8e9cdd7c02d61eda  gdb/symtab.h
-44e1fc373ca81ca76cbcdc1a76d76076  gdb/target-descriptions.c
-ba6528b7986fc63bd1883d6ad63fde15  gdb/target-descriptions.h
-3adda6d903da3f1aaf31134812bb5f4a  gdb/target-memory.c
-6b75539ac3bcdf813cd497aa9247f3aa  gdb/target.c
-78814944400f18ae74bfae5f0a3dbc86  gdb/target.h
-c9b2305889020dcd46a29d505c477046  gdb/terminal.h
-b17d575600dc7721414a5ad7d9d9b499  gdb/thread.c
-fc91c2c557c2a787614bc2fa1f4cb69c  gdb/top.c
-5294832f17574e6330cc632236cd3222  gdb/top.h
-2d84120303ebbabf45cd00af9a3d0e0e  gdb/tracepoint.c
-fb6e81161f18824e4d59f50f00e0c1da  gdb/tracepoint.h
-f38ed2098d630746043945a6c1d14ed4  gdb/trad-frame.c
-0caf01892c7b3e7f1cfb1849a5b02fb3  gdb/trad-frame.h
-f3e2899b78b6cc527c94209d0e17206b  gdb/tramp-frame.c
-0871b58883c26ee6462c5bd49138969a  gdb/tramp-frame.h
-46561d5b7d79efc26363571055c1b876  gdb/typeprint.c
-35b6170853203156eadeddcff263d687  gdb/typeprint.h
-2f280cf47bc8494ec7a593e3058acbe3  gdb/ui-file.c
-4b75147cf058361b9bd27c79e805c2fe  gdb/ui-file.h
-a8f796a27f33622005f602502c4efc7b  gdb/ui-out.c
-6d8ed538016d28b1a8f2578656a71814  gdb/ui-out.h
-8e51feff23352a61300fbf530cc5d29d  gdb/user-regs.c
-a4ed5ac137b60689b822948ec93e8883  gdb/user-regs.h
-1c8e26e3945ae11942caebd33490fa17  gdb/utils.c
-1ab0e639e3d5b4178d57d5edcbf741d0  gdb/v850-tdep.c
-a2c1cb61fe0cd99b5b56d7b5e4686f91  gdb/valarith.c
-e4b846de927bf715759b1a47223a0600  gdb/valops.c
-71170354968fa505eb83cdcb83cc6b46  gdb/valprint.c
-2280596d968bbd27ac23de3ac8f9948a  gdb/valprint.h
-565a980e461b79256b24bcd9c591c890  gdb/value.c
-d9cd5f00a1cc804cd6de841219bea640  gdb/value.h
-3558d2ae17daa1ab850df5c2a4a22af2  gdb/varobj.c
-d51d19b0686f19ea3ae759b32937a2e6  gdb/varobj.h
-f2fbc2199a36bdbbda3cc811e26db7e2  gdb/vax-nat.c
-7b481415bc16181b6c5745808b3fb4d4  gdb/vax-tdep.c
-79cba2dc00fecfea6018e7d03800bb1b  gdb/vax-tdep.h
-a5bf55a0dffd0c6c0b01fcc9045ef7ea  gdb/vaxbsd-nat.c
-0b8c562a36963ab4082d156915ba6f63  gdb/vaxnbsd-tdep.c
-065c8c6dfb87cd6fb35eda19152060fb  gdb/vaxobsd-tdep.c
-1eee433ba8a5702fa0d0f4c78a22815a  gdb/vec.c
-87b2e993911fa637001402fcf14243ef  gdb/vec.h
-532f45268db8c15cde6f2577d90b3fea  gdb/version.h
-38c9443c3374a3606299e6e16c6df1e8  gdb/version.in
-4a4b9b53efefd083d86d8bfdfdce6f7d  gdb/win32-nat.c
-6464bd887dd655462b8059cbeba3fd92  gdb/win32-termcap.c
-041e08fb66e6fb172d8d2676e60e6425  gdb/wrapper.c
-6b0c309c5d4b184365a9d446ff869d9a  gdb/wrapper.h
-e14ec14de2b74a4a0c931b51e724cf6c  gdb/xcoffread.c
-75987139161ffc98e3cc54ed716684fe  gdb/xcoffsolib.c
-ef306e5a920686f00d05396c00e07a78  gdb/xcoffsolib.h
-acaf22e52ad8ca2cb46e801ddb60322a  gdb/xml-support.c
-c0de64d273249e784936925396bd57b3  gdb/xml-support.h
-6f062d0a84c1557b74ff353e034523a5  gdb/xml-tdesc.c
-96700f965fdacaf234478403d3ecc654  gdb/xml-tdesc.h
-e560481725eec1b2ec5062d572302e11  gdb/xstormy16-tdep.c
-1abb0aea1cf79c0dd14de4a00952574e  gdb/xtensa-config.c
-e2dca9c8644aee81883a4fc7e8743a8d  gdb/xtensa-linux-nat.c
-32005535ca803586a497d6389333d4cf  gdb/xtensa-linux-tdep.c
-6c987f01ab229bf22009028429a3da30  gdb/xtensa-tdep.c
-82ab4805fe17045129bd90be55300f44  gdb/xtensa-tdep.h
-7f4ac8f445ddc3f2167a610e33632372  gdb/xtensa-xtregs.c
-28ecde6ac0551209741f3f4e6feebf31  gdb/cli/cli-cmds.c
-f8449a6de3de05f495a94a2c8605b467  gdb/cli/cli-cmds.h
-e95f114d1d38962749570d4273ccc0e8  gdb/cli/cli-decode.c
-40a4acf9da466065b18c43a3c9eb0e09  gdb/cli/cli-decode.h
-8096596bd255d72fcbb68214bedd19e8  gdb/cli/cli-dump.c
-0b05416c8e860bb6f1d2e312cdf486a8  gdb/cli/cli-dump.h
-0a1adfd64c9d04692af4fe23a4144686  gdb/cli/cli-interp.c
-029319e5c737ebce592951a20c252a27  gdb/cli/cli-logging.c
-557203bb8b379ab18c30d515bba4d904  gdb/cli/cli-script.c
-1f0befb40b0bdf2780c6f560280c3e8f  gdb/cli/cli-script.h
-80c696b31342fdacae3480fbe7e2237a  gdb/cli/cli-setshow.c
-cce40d2548c85ce1d05b9244ab6e6ad1  gdb/cli/cli-setshow.h
-b3fd8718e3ee05d01360e7171cd318b2  gdb/cli/cli-utils.c
-4ee99bb77a59e3e32ff6197a398180b3  gdb/cli/cli-utils.h
-d3240cecafcb661eb5b17b513a9a2237  gdb/config/nm-linux.h
-3a8a14defa424e45e6fa1dc7c7d9af3c  gdb/config/nm-nto.h
-4d369173081925b20459a494fb523d62  gdb/config/alpha/alpha-linux.mh
-50e1e213ab4b1bc643b300cc0435ef9a  gdb/config/alpha/alpha-osf3.mh
-dbd8fbfca3f36bdb4eacbe1e01621f86  gdb/config/alpha/fbsd.mh
-20481186c3d462f0c728913b6cc6edfe  gdb/config/alpha/nbsd.mh
-b4cc2663e6b1f8f220b7e56bf3d8ec16  gdb/config/alpha/nm-osf3.h
-a850978f00149d8ebd4004411ec080f6  gdb/config/arm/linux.mh
-b13eecd76b59b56aaeadbff80a7e368e  gdb/config/arm/nbsdaout.mh
-5d7cd55964cdcb59a85bfa7e1b9ecb57  gdb/config/arm/nbsdelf.mh
-bde487afd956fa6e0e51bc1c36ba2daa  gdb/config/djgpp/README
-be4b4ca32026912bc85608d1b46a4390  gdb/config/djgpp/config.sed
-0e81c0d814454405b9e032e50363dd3b  gdb/config/djgpp/djcheck.sh
-e029b1dc99e705fbd924540ae1b7e144  gdb/config/djgpp/djconfig.sh
-1dcd11be9ae7139722e49c51ecf81536  gdb/config/djgpp/fnchange.lst
-669ad61633b376f9831c058cd12cdeec  gdb/config/i386/cygwin.mh
-d40cc22b630a18133c4bc0fb0541a898  gdb/config/i386/fbsd.mh
-2a9aba909b91b5f5214abfbc9f372443  gdb/config/i386/fbsd64.mh
-67124e287ca9778e5753d758965921c4  gdb/config/i386/go32.mh
-3f7e657196694e32375964b42b4aba38  gdb/config/i386/i386gnu.mh
-fc7642463b0d9b27cdda69241e1944a9  gdb/config/i386/i386sol2.mh
-9ef9400302952be0acfb05c10f3872b0  gdb/config/i386/linux.mh
-6212cf2382da86aca049f39349dbd19d  gdb/config/i386/linux64.mh
-669ad61633b376f9831c058cd12cdeec  gdb/config/i386/mingw.mh
-227ba98d865063107c08a9530ac2f8fe  gdb/config/i386/nbsd64.mh
-87558d4b911e222ecb22ad12cc3564c9  gdb/config/i386/nbsdaout.mh
-9a03d523853e2737c9ad0b72551727f3  gdb/config/i386/nbsdelf.mh
-e8b6d86fc6dd4a2ba1a0efa3de2e5a81  gdb/config/i386/nm-cygwin.h
-91278f7291a54983d019fb7419d935db  gdb/config/i386/nm-fbsd.h
-086b2cbcdc3f6569bb6478d91c3f01b7  gdb/config/i386/nm-go32.h
-8ed963bbec9185829c6b5673232eb7dd  gdb/config/i386/nm-i386.h
-b147fc997bcb0bc8e0d1a1246feb7b12  gdb/config/i386/nm-i386gnu.h
-5be219f65b245d2959e27cbae53b727d  gdb/config/i386/nm-i386sol2.h
-968df92b1d2aad34f467b3fda96cb084  gdb/config/i386/nm-linux.h
-d723a1dba8aeec4df7b6156811a00305  gdb/config/i386/nm-linux64.h
-768aafd492586f1951ce658073749015  gdb/config/i386/nto.mh
-fbecf9fa0f174ad85ebc30c2f02a1b17  gdb/config/i386/obsd.mh
-611c0da16ce75d39f6890ff211438c70  gdb/config/i386/obsd64.mh
-aa061d4665eb9c96abb60eb720b1bc84  gdb/config/i386/obsdaout.mh
-adb93847694e775a95c3cdd678b34135  gdb/config/i386/sol2-64.mh
-9c5ebeb6a7190ea1665e37f7a695a94c  gdb/config/ia64/linux.mh
-50a6960d35a4cdd0f889c52be09dfe11  gdb/config/m32r/linux.mh
-6b2d45bf43c9f6de9720571ce83f9869  gdb/config/m68k/linux.mh
-ee16d60a2b24a2609a6faa5062c4cd98  gdb/config/m68k/nbsdaout.mh
-cb8b6190eebde036c1376deb445c072b  gdb/config/m68k/nbsdelf.mh
-9ab03f6984d3ced1312b58bd5ec9a3f5  gdb/config/m68k/obsd.mh
-48bfa91312c1e6daebf1f587fa78df9e  gdb/config/m88k/obsd.mh
-e384b517a773c660d7fec8b5de69ced7  gdb/config/mips/irix5.mh
-7a1f2a4121ef432595dcda129ea2786c  gdb/config/mips/irix6.mh
-1dbfa7304f4162463902298c6fdee8a1  gdb/config/mips/linux.mh
-35cc06513a613ea3ddfbbcafd2806b8c  gdb/config/mips/nbsd.mh
-a5eeafc5f12fd0e75d20a12aa32a37ca  gdb/config/mips/nm-irix5.h
-a134a67c299c643f4737f5d819837aca  gdb/config/mips/obsd64.mh
-d53c46263b02d71e60e61c6ed804a5cb  gdb/config/pa/hpux.mh
-d713df73dfda6658370a7ce59c7f3df8  gdb/config/pa/linux.mh
-c8a8841e6cc8fd8534ff677f827e804f  gdb/config/pa/nbsd.mh
-0e6e3c4eaf0de24e8e98ea1aea7e81cd  gdb/config/pa/obsd.mh
-85c67b213cef469499b50fd73d312eee  gdb/config/powerpc/aix.mh
-0d799b32486be1e3a2b6ce5dd5f3735b  gdb/config/powerpc/linux.mh
-8ad26d2ccfeec2da7581634421706cbf  gdb/config/powerpc/nbsd.mh
-39d15590e8e579a501673e1f776cb85b  gdb/config/powerpc/obsd.mh
-30dd880a4bfc1fc69956236c9a18c261  gdb/config/powerpc/ppc64-linux.mh
-d58f6e1a77b3da7ef4494e34f8e2bc53  gdb/config/powerpc/spu-linux.mh
-f348b401e6a533d177250162204d8ee9  gdb/config/rs6000/nm-rs6000.h
-d036a2d9ef8ea0f6b08100212c4e9439  gdb/config/s390/s390.mh
-869f55b72d1468bff76771d7f03aa275  gdb/config/sh/nbsd.mh
-3b8689dcc7df679a848fcc970d9b902b  gdb/config/sparc/fbsd.mh
-b6866f764115e374ef093094bfa0ad74  gdb/config/sparc/linux.mh
-76958432c4dfd8053e0e7b144df0cd7f  gdb/config/sparc/linux64.mh
-1c336614ad1c95795851d0b836ef97a0  gdb/config/sparc/nbsd64.mh
-3126d04fdb01a598a2cb29fa483baf92  gdb/config/sparc/nbsdaout.mh
-fa5c681e54a6e249012314eb54849460  gdb/config/sparc/nbsdelf.mh
-777d1574ef5bef3554669bf675b2ca07  gdb/config/sparc/nm-sol2.h
-5097a63e97d9f426dbcfce68160daf27  gdb/config/sparc/sol2.mh
-d836ebc31d840fdc54f71e37b118605f  gdb/config/vax/nbsdaout.mh
-474ecf1428fe010bbb7c2fe21b33af0a  gdb/config/vax/nbsdelf.mh
-51bd75312393d4a9db52f4ee825f0051  gdb/config/vax/obsd.mh
-07aa8677ded37951f4bfec7278b68a4a  gdb/config/vax/vax.mh
-0a59067bcab4737b3533471527214756  gdb/config/xtensa/linux.mh
-062b1fa9caf4313d76ecec475d2aa76c  gdb/doc/ChangeLog
-cde55cb7bff1f00bd1c4b1ec0336c922  gdb/doc/LRS
-ce4dc3b9a29c98c8a3d2c5d51d22c665  gdb/doc/Makefile.in
-d5d06eaf9b4d44aa442a4a281aa9aea4  gdb/doc/a4rc.sed
-8b856d480d8428d53c52382c8d552f72  gdb/doc/agentexpr.texi
-1f51e7972df835e8c2e611ff0c8e8147  gdb/doc/all-cfg.texi
-ebad416a5dd6e03399955d96726a8164  gdb/doc/annotate.texinfo
-31bd0ac1e6dfe337bbaa1b2caafbbbc7  gdb/doc/configure
-6a92e053295cc1cddd85684f2c442ef6  gdb/doc/configure.ac
-4bf4b39ae966f92502c10f5c082aeb88  gdb/doc/fdl.texi
-9ae86e6ea6680a5b8f17714232bc787f  gdb/doc/gdb.texinfo
-6d33bdf501b793b7debd07ca3716d890  gdb/doc/gdbint.texinfo
-2161f711c8f9c45df79c8b8feb6e6607  gdb/doc/gpl.texi
-73ec71cd3b2e7f61bc530f19d4b35056  gdb/doc/lpsrc.sed
-1eb153ea091c576cda490a178cb455d9  gdb/doc/observer.texi
-8108dd8f906f2654fecc74958cf383db  gdb/doc/psrc.sed
-86729eea9c9f967365e4218d73e91f4d  gdb/doc/refcard.tex
-36e63723da472269b9e80db3c6dc20a3  gdb/doc/stabs.texinfo
-9df474dbe6dadc1ad36d820de11c4c43  gdb/doc/gdb.info
-92501558f347a4b2a0fed7fc04dd08bf  gdb/doc/GDBvn.texi
-b24f27fcd893046a0dfc4dfa8a4c10b4  gdb/doc/gdb.info-1
-402ff90cdf4b4d48e2eef54abd4824a6  gdb/doc/gdb.info-2
-13fead891c1f59348ccd90a510360459  gdb/doc/gdb.info-3
-a8a0569e96484263da1c387e354ba0cb  gdb/doc/gdb.info-4
-3a9639852ce532971eb98b1b14406c86  gdb/doc/gdbint.info
-22e01e4c2718f06d0be78537d84aa5ce  gdb/doc/gdbint.info-1
-f31dcb9cfb66e1e37a249a9ecf59d27a  gdb/doc/gdbint.info-2
-f4c785bdc70554871abfdfea7f6bb8bf  gdb/doc/stabs.info
-b090d0ca1fb105614758275a0b13b4b6  gdb/doc/annotate.info
-78cb69158d79bf78940d355e907daaf3  gdb/features/Makefile
-e764e40ecdfd4b44472c52e0fd588775  gdb/features/arm-core.xml
-f9e1f5a8e97726210cf45b2e4a2bef84  gdb/features/arm-fpa.xml
-40a800e78e4f8911a10518a46ca24a16  gdb/features/arm-with-iwmmxt.c
-f7698f92180810b535296f918ffa0f9b  gdb/features/arm-with-iwmmxt.xml
-4680dcd2db6e2eb2918d558ec6c40d92  gdb/features/feature_to_c.sh
-12a8bb69a866a481c5b2ae3969e06153  gdb/features/gdb-target.dtd
-7f858498e3b882463c1ca8c0ffcc73c6  gdb/features/gdbserver-regs.xsl
-410aa38fcee52bc6c8c7378f479e52f2  gdb/features/library-list.dtd
-eb48d62f60511f719e1037ac6c96918a  gdb/features/mips-cp0.xml
-006c7b0ff982e018afcd9674958db1d1  gdb/features/mips-cpu.xml
-18f3d250709cbdbe7a46b129b2f90c50  gdb/features/mips-fpu.xml
-bda2f9795fbf4370d2b7a003377e8604  gdb/features/mips-linux.c
-995fd1f4a6d2ace4fe4c69942508d714  gdb/features/mips-linux.xml
-11cbe3675905e295eca9ce46cd993f90  gdb/features/mips64-cp0.xml
-5cc2247f997ff3c13e4837448158af15  gdb/features/mips64-cpu.xml
-1366c639a037d1aa079f08701bf549a9  gdb/features/mips64-fpu.xml
-34d116c1e4bdb0bf9d0dbe4324a8c62d  gdb/features/mips64-linux.c
-7ca55f8d2bb18eb73ff32b4bc0c31006  gdb/features/mips64-linux.xml
-344651c03e3550054486c97346dbe87e  gdb/features/number-regs.xsl
-a74f670e27b892b83c13054809c82473  gdb/features/sort-regs.xsl
-77464f25b8a6578d738cf30142c49c5a  gdb/features/xinclude.dtd
-7b6862f1a273d1cfab1e5a03d7d38da3  gdb/features/xscale-iwmmxt.xml
-ae46604f07acf179f9fe43d67ee7fc52  gdb/features/rs6000/power-altivec.xml
-ea0366484c06ef49c49e29708399e405  gdb/features/rs6000/power-core.xml
-050a621e773f3038d2c6d5ef6c6ce25f  gdb/features/rs6000/power-fpu.xml
-a678040562e0a3d3e88608539ef5f83f  gdb/features/rs6000/power-oea.xml
-f7298a385b2d76853e25859310c6c5a8  gdb/features/rs6000/power-spe.xml
-94dc7336132789a30d52863fe8f878cc  gdb/features/rs6000/power64-core.xml
-65fb935a8b46dcf8d72c8e55d98fb032  gdb/features/rs6000/powerpc-32.c
-20850e9ce00e2148354bb38f45b09462  gdb/features/rs6000/powerpc-32.xml
-1d2ed661a660c0c77f5bf85658f32739  gdb/features/rs6000/powerpc-403.c
-61a57cc11a35e3f98c3e3c9f1b2dda3a  gdb/features/rs6000/powerpc-403.xml
-d562803be4c079ec79282ca0be59c400  gdb/features/rs6000/powerpc-403gc.c
-09bf820a84669257fc67e268bf199e51  gdb/features/rs6000/powerpc-403gc.xml
-ce9756086a79de3f646103940481e855  gdb/features/rs6000/powerpc-505.c
-4bb1364a49eed44ffdd779bd8c5a3f5b  gdb/features/rs6000/powerpc-505.xml
-5ca2d089344bb7ed4cdc6a780c310675  gdb/features/rs6000/powerpc-601.c
-e9d14d68b220a53b26c7ad1955b0d97d  gdb/features/rs6000/powerpc-601.xml
-eccb0732969fd539395e832761372be7  gdb/features/rs6000/powerpc-602.c
-0dc8a2557f00de90ee93b50e92ee6176  gdb/features/rs6000/powerpc-602.xml
-4823c5a46d4730161e2ee2d6aebffb32  gdb/features/rs6000/powerpc-603.c
-fe821c42c827e1b9eef7f055387a4b5b  gdb/features/rs6000/powerpc-603.xml
-b4db0c54282f8b07bb07008288d96163  gdb/features/rs6000/powerpc-604.c
-46fcef14bbe4c2e4aaae5b296650ba84  gdb/features/rs6000/powerpc-604.xml
-159908332c2abce0d61a4e9f245af641  gdb/features/rs6000/powerpc-64.c
-68bd61c3a4de05564732bd848c34be2c  gdb/features/rs6000/powerpc-64.xml
-92e80e899eea1a33ee001b1355b3d297  gdb/features/rs6000/powerpc-7400.c
-8c640d0967f9e6111d2113d41b61ade7  gdb/features/rs6000/powerpc-7400.xml
-40559313f563d1e5b2f3144b5595d191  gdb/features/rs6000/powerpc-750.c
-f8a5ed2eecbdd6206271706617f80dc1  gdb/features/rs6000/powerpc-750.xml
-54eef925fe7b592e8324df90f0b8fe06  gdb/features/rs6000/powerpc-860.c
-7b49a75b79e41de4329b0406a0ee4cfe  gdb/features/rs6000/powerpc-860.xml
-8e870201f2a200ad3a64c4eb44fccb60  gdb/features/rs6000/powerpc-e500.c
-5d1b6b3205ae0087319d2d8fc7e2e203  gdb/features/rs6000/powerpc-e500.xml
-f056b3fd0c57e092a57c32aba5eaa23e  gdb/features/rs6000/rs6000.c
-89ffe16c4c07b46c3473569bb1cc21b8  gdb/features/rs6000/rs6000.xml
-9c85d4d110b3997eadeeef2eed9b7d9b  gdb/gdbserver/ChangeLog
-3a45f7b918f5012e9677bac6536c91f1  gdb/gdbserver/Makefile.in
-b83ec58b14455b20a7bf80b99149b49e  gdb/gdbserver/README
-be7525cf31c0a75398cc1256bf500a07  gdb/gdbserver/acinclude.m4
-965f6e48234db83731e69a90d829e385  gdb/gdbserver/aclocal.m4
-da7a1e868730a511910e4098a66aa0ba  gdb/gdbserver/config.in
-6b2407b445883da8960cb2c50b2bf3ba  gdb/gdbserver/configure
-591be496806f2e2865b82c7fa61f60bf  gdb/gdbserver/configure.ac
-09d4726c806743dbbb1857024c8cb859  gdb/gdbserver/configure.srv
-64a106076420622c52222950c475934c  gdb/gdbserver/gdb_proc_service.h
-503f0c671086a2afd7b00cbd53f14e1f  gdb/gdbserver/gdbreplay.c
-9dd0f7ff199b8265e4bf28fc80065051  gdb/gdbserver/gdbserver.1
-58321d404ef4c41ddea5e66e7945a00a  gdb/gdbserver/hostio-errno.c
-39117caeda44cd908f5406c96232792e  gdb/gdbserver/hostio.c
-f51a967cbaff5e7fc94688ba7ee502f0  gdb/gdbserver/i387-fp.c
-c8106e77cd958444b19e6b012eece011  gdb/gdbserver/i387-fp.h
-8854b5886a85230494bd7571543cac04  gdb/gdbserver/inferiors.c
-5136b750c61968120503248111693597  gdb/gdbserver/linux-arm-low.c
-6ba4b3a4dcc10f9d73c622323a86931b  gdb/gdbserver/linux-cris-low.c
-8910ebcfa2ac5f7037dbe42949f39c28  gdb/gdbserver/linux-crisv32-low.c
-5b6d715ddb1321018c77c6d987a55bf5  gdb/gdbserver/linux-i386-low.c
-2bb5c634663eeac01b588d43e9eb180f  gdb/gdbserver/linux-ia64-low.c
-dc7a45a5f6bfe8dee0966ac2104ed0ba  gdb/gdbserver/linux-low.c
-f4f2dc90a5f40a4bd8b044781c67d4f1  gdb/gdbserver/linux-low.h
-6044a4590886446ca5c4125e90cea922  gdb/gdbserver/linux-m32r-low.c
-4f100f34a034595886bdb5a46ec91838  gdb/gdbserver/linux-m68k-low.c
-f33a40f961a941ce122d2c89cd4f56d8  gdb/gdbserver/linux-mips-low.c
-b9fbbd17bc7932f3c2453e71513e9462  gdb/gdbserver/linux-ppc-low.c
-29d445bd835a568ff14e3ba1494aeca9  gdb/gdbserver/linux-ppc64-low.c
-f2a953fdb88c2bc70a76d2040e53961a  gdb/gdbserver/linux-s390-low.c
-dff678efc3f106479fd8b724f27a48e4  gdb/gdbserver/linux-sh-low.c
-1ced149a97ab1680c819fcb91a655c4a  gdb/gdbserver/linux-x86-64-low.c
-637f7ef3177837b93fc5cfea74f16db3  gdb/gdbserver/linux-xtensa-low.c
-4aed71e8bf1c7cab748d60e7706cf49b  gdb/gdbserver/mem-break.c
-26efb6d9340138814baac1de888aa80a  gdb/gdbserver/mem-break.h
-b40f6b2c4ed79f72876f7ec768ba80a8  gdb/gdbserver/proc-service.c
-44407477273b8aee1c00a016b87043b1  gdb/gdbserver/regcache.c
-41b8af71fa9db2f6d4eb08b07c036d83  gdb/gdbserver/regcache.h
-3e0b68fffec44b417181ddfb6983ab0c  gdb/gdbserver/remote-utils.c
-351f50bc766d3e5b7de5b11c59576eca  gdb/gdbserver/server.c
-315092ee3338b375ae4e42c002c1bfac  gdb/gdbserver/server.h
-3e89481ba520b58783bda2121631d51e  gdb/gdbserver/spu-low.c
-8402944e1e1ea3c7c388335254feeec0  gdb/gdbserver/target.c
-003ce5d7f09ee2d36a101e8e0c41404e  gdb/gdbserver/target.h
-5557cd6cd25eb45108c3016b68c07b96  gdb/gdbserver/terminal.h
-3cc338e2428ceed264f4db359776969e  gdb/gdbserver/thread-db.c
-7e52ed367db6f06ba31f5b59eeab27cd  gdb/gdbserver/utils.c
-485030fa21ff923caa7d5147a233d3f4  gdb/gdbserver/win32-arm-low.c
-785209205b62de685a2404e96ac87239  gdb/gdbserver/win32-i386-low.c
-6e6ebd2cd699b21436cf6c6f511b5743  gdb/gdbserver/win32-low.c
-99293c3f207762166f40ab38380e7a6e  gdb/gdbserver/win32-low.h
-a77a66bb7cebd5bd2ae027fdbbba50a7  gdb/gdbserver/wincecompat.c
-9d14491519228deda331db3d0f5c4a9f  gdb/gdbserver/wincecompat.h
-7f4ac8f445ddc3f2167a610e33632372  gdb/gdbserver/xtensa-xtregs.c
-90b81f951a2351c88c1b4a1fedbb492f  gdb/mi/ChangeLog-1999-2003
-a864ea77e53fb943fba5bfd82b0d419f  gdb/mi/gdb-mi.el
-19bb70efeaca816cc4732fdb034705cd  gdb/mi/mi-cmd-break.c
-f75de8f74a12cd649b081edbea64bdf6  gdb/mi/mi-cmd-disas.c
-22aa0332c7ed1dd6832fcf561123b4ad  gdb/mi/mi-cmd-env.c
-f5112e5874251fe082fa87cba4a58f33  gdb/mi/mi-cmd-file.c
-252c8b3c9af16931a526d4218b2a2b6b  gdb/mi/mi-cmd-stack.c
-4427c9bb804a2540209af58596390038  gdb/mi/mi-cmd-target.c
-571d0b0b2bb75c188287b6505af9bf36  gdb/mi/mi-cmd-var.c
-f7ae0e1508513830e8c099e70214948b  gdb/mi/mi-cmds.c
-3740df5fd195be0080fd519e721268ec  gdb/mi/mi-cmds.h
-df47e701e086fb84f6e99abbdf5e7933  gdb/mi/mi-common.c
-51d3a45182d6e5bfe3a8853ab19513c5  gdb/mi/mi-common.h
-a930e8560572cbb033eee775a4c400d3  gdb/mi/mi-console.c
-f3871099303a85f4029df41f3936873c  gdb/mi/mi-console.h
-b349b3edc38027b358a7b72232ec8aae  gdb/mi/mi-getopt.c
-275fd1f0d492e25f0e45bc2810b81108  gdb/mi/mi-getopt.h
-92f54937fabe2d726560a6eb6f3c775a  gdb/mi/mi-interp.c
-5a50e5006ca74b8a0ff79e3b0d264d1b  gdb/mi/mi-main.c
-b600054be44cbf4b2f235d93a98fecf5  gdb/mi/mi-main.h
-f4014d230f114347b78022e8e2b7f129  gdb/mi/mi-out.c
-a2d19ccbf987530caac92fce04f9f1e6  gdb/mi/mi-out.h
-841f9c7fe4160e658d57021591025b90  gdb/mi/mi-parse.c
-beab117029b63507d8e19a62f324020a  gdb/mi/mi-parse.h
-f959dda4fc877161c11b53a5354bafb5  gdb/mi/mi-symbol-cmds.c
-912ea9d855fcc23de552c2d674d37812  gdb/osf-share/README
-314092b3f105af13bbccc4fc39481123  gdb/osf-share/cma_attr.h
-ec11d7d3ff9dbfa4d20d96c6ecea4aea  gdb/osf-share/cma_deb_core.h
-531f430005d3dfefbbe460e835dd4011  gdb/osf-share/cma_debug_client.h
-b2dbbcf3ce19d6aac60aabe2461688f5  gdb/osf-share/cma_errors.h
-509c48bb5521057f577d861d34415db0  gdb/osf-share/cma_handle.h
-9347ef23e2404f0ee033107934ae0cdb  gdb/osf-share/cma_init.h
-5c6c1190b6d93f82d69a7c24a243e17d  gdb/osf-share/cma_list.h
-4e1ef48ceb062c4de2d02498037e7d27  gdb/osf-share/cma_mutex.h
-aa4922b22db6dcb97919aefdf6611ff3  gdb/osf-share/cma_sched.h
-e543eac7a41953f1de602b9abf91c3b0  gdb/osf-share/cma_semaphore_defs.h
-c1f9f7112e573c94a6a72bfef19e8c9a  gdb/osf-share/cma_sequence.h
-5c6ed620494d12976faee79e8a8be4c9  gdb/osf-share/cma_stack.h
-987386e076ca49cc3407fc4ee3a4290e  gdb/osf-share/cma_stack_int.h
-a51385c695f3a215a2b71e98d6bea995  gdb/osf-share/cma_tcb_defs.h
-c20fd87765652ad7ba50f43a0ec95088  gdb/osf-share/cma_util.h
-77b2f029b50b47ab8989da00b35b9438  gdb/osf-share/AT386/cma_thread_io.h
-7cd3745f37bbbfcd24086735939ead52  gdb/osf-share/HP800/cma_thread_io.h
-36cb16e3cf86ddd4609d275a6a3052f5  gdb/osf-share/RIOS/cma_thread_io.h
-1851bff0653201a488dcae18dde7efad  gdb/po/gdbtext
-48170d535b37172811e97e9372ca0892  gdb/po/gdb.pot
-3648d53f36a3b4742b741dd9345cf206  gdb/regformats/arm-with-iwmmxt.dat
-392319664d12b1c4ad26580e5bc6282a  gdb/regformats/mips-linux.dat
-5198f08f53a660cc59657bb5a06b9134  gdb/regformats/mips64-linux.dat
-9ed735c435a35313ad491c309fd32cf6  gdb/regformats/reg-arm.dat
-f548472e3d5eb277710a2e79e6ec84a1  gdb/regformats/reg-cris.dat
-d36d59c17f75a762e053889f55c97454  gdb/regformats/reg-crisv32.dat
-8936fb07afdc018021e787498e8fbe81  gdb/regformats/reg-i386-linux.dat
-22247e6f668678c70523438e2602e99e  gdb/regformats/reg-i386.dat
-a1c09888ecf3221afc983f497bf2c032  gdb/regformats/reg-ia64.dat
-804cd0c318f49e2da247a3f965fcb5b6  gdb/regformats/reg-m32r.dat
-767b3762219584b4953a737251b6347f  gdb/regformats/reg-m68k.dat
-89725b9eb486c038a497e375ea8aabfd  gdb/regformats/reg-ppc.dat
-7f791bfc29e6e6a5ae01c29402a44a65  gdb/regformats/reg-ppc64.dat
-e337d7dff9b66f4ecb3813b1fa8b53f9  gdb/regformats/reg-s390.dat
-d3e9824914e44c31e310e78047754192  gdb/regformats/reg-s390x.dat
-657ed262c66093acacf0ccf85f97c55c  gdb/regformats/reg-sh.dat
-13b5571e5f691f8929ab67dbb6576657  gdb/regformats/reg-spu.dat
-7a14b55f93c66077cd571b738e286fda  gdb/regformats/reg-x86-64-linux.dat
-8c71b67411765da5ab92789a60f27516  gdb/regformats/reg-x86-64.dat
-4daef8f69e61fab4d7c5a9c1d664e467  gdb/regformats/reg-xtensa.dat
-967474a51cdde5a237e6a16a834c4dda  gdb/regformats/regdat.sh
-bd5c0dac60e7fd7d3074c511beeb901a  gdb/regformats/regdef.h
-d6f3a907ab250e927a1ee611f1a3867b  gdb/regformats/rs6000/powerpc-32.dat
-916380a008b0da8fadaa61a9f0a495c0  gdb/regformats/rs6000/powerpc-64.dat
-753593250f22007f42d8e799b442a0c6  gdb/regformats/rs6000/powerpc-e500.dat
-87ef72000d707ecb273d4518c5ae793b  gdb/signals/signals.c
-32b68d52cb813a01f3eac71017f56d2e  gdb/testsuite/.gdbinit
-ef75e2db1a73fa15f1e028e20fe75622  gdb/testsuite/ChangeLog
-d322ddadc95e97564e6eb58f23889b8e  gdb/testsuite/Makefile.in
-1b9bb551736dbc95577c91620b81fb6c  gdb/testsuite/TODO
-b5699ace5597a3740fc821cc022de5f4  gdb/testsuite/aclocal.m4
-f2744de525e7a053fd7e9d81f73bdd62  gdb/testsuite/configure
-46ad236a9b2e17b9caf8dacfb5bdcfb3  gdb/testsuite/configure.ac
-fee369d654e97f06fe1c1e5a6680a672  gdb/testsuite/config/arm-ice.exp
-39d68537d9753a4fd1597be7de5cfe3c  gdb/testsuite/config/cfdbug.exp
-fee369d654e97f06fe1c1e5a6680a672  gdb/testsuite/config/cygmon.exp
-7fe959b4f86bcf8e241cbf32570b1ace  gdb/testsuite/config/d10v.exp
-a7b54a9b33154aea0547195e173662d9  gdb/testsuite/config/default.exp
-feae68a80ca45032d1bd01bdf38cadb6  gdb/testsuite/config/dve.exp
-7832fde2eb74426a726e89c095f87b8b  gdb/testsuite/config/gdbserver.exp
-fee369d654e97f06fe1c1e5a6680a672  gdb/testsuite/config/h8300.exp
-e4708e4b23e4e6ddd07c7245736d37b3  gdb/testsuite/config/i386-bozo.exp
-9a43a106550a780645e47deacfafb49b  gdb/testsuite/config/i960.exp
-50f6a13c0fd1efa871f0b7c0dc273e0d  gdb/testsuite/config/m32r-stub.exp
-cf9e96be9f017d4c8f9d7dd45acd9c22  gdb/testsuite/config/m32r.exp
-3b4962b783a530746573abd6b4e2bd9b  gdb/testsuite/config/m68k-emc.exp
-a16cb60ff78add75403714a5885a725f  gdb/testsuite/config/mips-idt.exp
-a16cb60ff78add75403714a5885a725f  gdb/testsuite/config/mips.exp
-feae68a80ca45032d1bd01bdf38cadb6  gdb/testsuite/config/mn10300-eval.exp
-adefd82571f63a75853beec81b5904ac  gdb/testsuite/config/monitor.exp
-9a43a106550a780645e47deacfafb49b  gdb/testsuite/config/proelf.exp
-9a43a106550a780645e47deacfafb49b  gdb/testsuite/config/rom68k.exp
-9a43a106550a780645e47deacfafb49b  gdb/testsuite/config/sh.exp
-cb9f18645fced95d41604e91a613806b  gdb/testsuite/config/sid.exp
-bfe62eb805636398f9ecb0f2c1af2b8e  gdb/testsuite/config/sim.exp
-8c91e8719de95984eacb657a99406f3c  gdb/testsuite/config/slite.exp
-95d503845c5d8c56e4385736251a192b  gdb/testsuite/config/unix.exp
-9a43a106550a780645e47deacfafb49b  gdb/testsuite/config/vr4300.exp
-9a43a106550a780645e47deacfafb49b  gdb/testsuite/config/vr5000.exp
-044fefe8f234811133f9632f44bc3088  gdb/testsuite/config/vx.exp
-59a336123fec1c413f1207bda6bdabd7  gdb/testsuite/config/vxworks.exp
-8b6f2df498c77af3c4c4ca6e5e123ad4  gdb/testsuite/config/vxworks29k.exp
-9b87b0cfbd7cbaee4e8f1d0f91d23292  gdb/testsuite/gdb.ada/Makefile.in
-09b25220e828531f8e6d8e80b8031e19  gdb/testsuite/gdb.ada/array_bounds.exp
-bebbaf0913659c9e86d34ad54cc6cc4f  gdb/testsuite/gdb.ada/array_return.exp
-4d971b9344f2c91f5f5e7cb4a39fb024  gdb/testsuite/gdb.ada/array_subscript_addr.exp
-5b51625fe25780d3f1d1139bd133ad26  gdb/testsuite/gdb.ada/arrayidx.exp
-4ce415755d4c8dc4c8d75e08f0688c5e  gdb/testsuite/gdb.ada/arrayparam.exp
-4b587eb4ed5ea56a35d5703196577a43  gdb/testsuite/gdb.ada/arrayptr.exp
-c443290333a30f3ead35c34a75c7e1be  gdb/testsuite/gdb.ada/boolean_expr.exp
-614d34966fd8394a26b6497ef3dc62af  gdb/testsuite/gdb.ada/catch_ex.exp
-be6e8bef66e933ab9eede767ebfeb80b  gdb/testsuite/gdb.ada/char_param.exp
-558159366e6a1ec32d507452f64c6a5f  gdb/testsuite/gdb.ada/complete.exp
-83c13172abf43e8b9aa6fe3ecc0c0601  gdb/testsuite/gdb.ada/exec_changed.exp
-56146207b17f5c04b954caebf879240f  gdb/testsuite/gdb.ada/exprs.exp
-72875aa62fa19d759a09e8c4a3421218  gdb/testsuite/gdb.ada/fixed_cmp.exp
-69b7566a3789768bf604e84a3d26eaf4  gdb/testsuite/gdb.ada/fixed_points.exp
-45872a09c6e0de06d9fd10aced3e00c0  gdb/testsuite/gdb.ada/formatted_ref.exp
-c81d1367b1f2e423d31e95cb20f29d9b  gdb/testsuite/gdb.ada/frame_args.exp
-720be2c5cbeddb7ea702c95b1e0febfc  gdb/testsuite/gdb.ada/fun_addr.exp
-1f2605223495722eee08fafc3fc4a596  gdb/testsuite/gdb.ada/fun_in_declare.exp
-65362af6c4f2735a4462be7342f175ae  gdb/testsuite/gdb.ada/funcall_param.exp
-db26972cf71513bae21d3e172f5c2030  gdb/testsuite/gdb.ada/gnat_ada.gpr
-9d8c8c9f6c89384fc284d7135a7c988a  gdb/testsuite/gdb.ada/homonym.exp
-2a6aa07d59fe46d8616fd7f8e41f4ac3  gdb/testsuite/gdb.ada/interface.exp
-18fdde8140a3c03ae6e10f7a798862b0  gdb/testsuite/gdb.ada/nested.exp
-48bde01c7dfc000ed570c38c33a0563a  gdb/testsuite/gdb.ada/null_array.exp
-2253196a36af38ca74416b56aab8289d  gdb/testsuite/gdb.ada/null_record.exp
-2108d5b23fc89664b092aa061c6382b6  gdb/testsuite/gdb.ada/packed_array.exp
-74f98e472851d4fe9af5555be586ebb3  gdb/testsuite/gdb.ada/packed_tagged.exp
-468666373efd1da437b9b8f4acbc0ba0  gdb/testsuite/gdb.ada/print_chars.exp
-aa691c12ea753f855536b6fa694ba0d8  gdb/testsuite/gdb.ada/print_pc.exp
-3975332c1ad830aa5ab3da0dc0df6733  gdb/testsuite/gdb.ada/ptype_field.exp
-08586dfccd13fb908cba3e7e6ca1823c  gdb/testsuite/gdb.ada/ref_param.exp
-b0d1a86df3ce8faf86727b4fe2abb984  gdb/testsuite/gdb.ada/start.exp
-04fe70423783bfae92f7aa5fec18660f  gdb/testsuite/gdb.ada/str_ref_cmp.exp
-e63b6805377c46a1eb93646139e9205a  gdb/testsuite/gdb.ada/sym_print_name.exp
-717712ff263d87f7c54585fbb2cd5226  gdb/testsuite/gdb.ada/taft_type.exp
-cf46a780c0b330b26b2c2f75bf608449  gdb/testsuite/gdb.ada/tagged.exp
-9af3703cf59962ae8b89505a48550df8  gdb/testsuite/gdb.ada/type_coercion.exp
-86cf42fb9bbb00f8f0819191e6716af2  gdb/testsuite/gdb.ada/watch_arg.exp
-59f7008404d5d25196237479b98b9e96  gdb/testsuite/gdb.ada/array_bounds/bar.adb
-14ed17604375dbf721856f4a328a07e6  gdb/testsuite/gdb.ada/array_return/p.adb
-3e3cec1d067eb72b4b25dfacdd17f5ba  gdb/testsuite/gdb.ada/array_return/pck.adb
-2d1ebee71f0c8b63b1bbd57ea4d34874  gdb/testsuite/gdb.ada/array_return/pck.ads
-8b3cb6d0958063e235647342cbf3ff68  gdb/testsuite/gdb.ada/array_subscript_addr/p.adb
-e3ae9fa9a7ca2dc0b87c9195aad54fd5  gdb/testsuite/gdb.ada/arrayidx/p.adb
-14a26834e8ed7249ce9fd228450976a2  gdb/testsuite/gdb.ada/arrayparam/foo.adb
-d8e1703160c59ebd7d8d0f570cd59a01  gdb/testsuite/gdb.ada/arrayparam/pck.adb
-4766e48f3f1f42dbe55f1d2794b8e101  gdb/testsuite/gdb.ada/arrayparam/pck.ads
-d5b217b631f57a0176b4bcd66409cc87  gdb/testsuite/gdb.ada/arrayptr/foo.adb
-2fe0ae2d16e36a329309bc5b582eb16e  gdb/testsuite/gdb.ada/arrayptr/pck.adb
-d3a3e69793d7d31ac7882b1eac0a4ffe  gdb/testsuite/gdb.ada/arrayptr/pck.ads
-95672331b835fe8cf2f928c91e2fdc0a  gdb/testsuite/gdb.ada/catch_ex/foo.adb
-fa2b7e5028fab804d09cc2c75c661ae6  gdb/testsuite/gdb.ada/char_param/foo.adb
-5cfb36053fa8b110cfdd5a6cfd00783d  gdb/testsuite/gdb.ada/char_param/pck.adb
-94bb3e252a3b3d64289044d42e57e0ac  gdb/testsuite/gdb.ada/char_param/pck.ads
-57026bca458758b8abb02772d9b94e64  gdb/testsuite/gdb.ada/complete/foo.adb
-50763932bde34dc01ece481fbbbf5d1d  gdb/testsuite/gdb.ada/complete/pck.adb
-4cd06a710254c807e43db4bbfbd5fad6  gdb/testsuite/gdb.ada/complete/pck.ads
-83a64770db7a53f3f535d5c2cb9a89f6  gdb/testsuite/gdb.ada/exec_changed/first.adb
-f01fb3c6b3b24ab3dbf7dfdbe1fcae75  gdb/testsuite/gdb.ada/exec_changed/second.adb
-aa0a330d5cd251d4166489d4ac7b81e3  gdb/testsuite/gdb.ada/exprs/p.adb
-86671c7c7af800bb276d5ce6857ddc99  gdb/testsuite/gdb.ada/fixed_cmp/fixed.adb
-dc9e319b9377dbeae70d7a14b51e9b9b  gdb/testsuite/gdb.ada/fixed_cmp/pck.adb
-a8e19d171b39943a3e6175d52b0c5ba3  gdb/testsuite/gdb.ada/fixed_cmp/pck.ads
-61949f4648b7d11a7e110946970200c6  gdb/testsuite/gdb.ada/fixed_points/fixed_points.adb
-76a529ff43a45f7907f03f9c3307d7eb  gdb/testsuite/gdb.ada/formatted_ref/defs.adb
-240048d77c52c46f067404fa3a008ad2  gdb/testsuite/gdb.ada/formatted_ref/defs.ads
-d8dbaa4b83b883e9970604e6eced478c  gdb/testsuite/gdb.ada/formatted_ref/formatted_ref.adb
-b2986de8b11cd1db5143f2582ed739a5  gdb/testsuite/gdb.ada/frame_args/foo.adb
-64778a7ffa3179254fc13effc83be256  gdb/testsuite/gdb.ada/frame_args/pck.adb
-07e8dd90c633f3d21acfef0ad12a10db  gdb/testsuite/gdb.ada/frame_args/pck.ads
-e037c9758d096aa52613d5d8442261ca  gdb/testsuite/gdb.ada/fun_addr/foo.adb
-7a4dccb033cb0f13fef643ce0cca960e  gdb/testsuite/gdb.ada/fun_in_declare/foo.adb
-325eb1216ce2444fc360accfe5e1a992  gdb/testsuite/gdb.ada/fun_in_declare/pck.adb
-45c4fa47c33dfb32a62a17339cf84988  gdb/testsuite/gdb.ada/fun_in_declare/pck.ads
-c3c137887749dda1afe7cd001e467708  gdb/testsuite/gdb.ada/funcall_param/foo.adb
-0967fb549f5bef456eb7d6121cee8687  gdb/testsuite/gdb.ada/funcall_param/pck.adb
-f9f0f53dd0a71c48616e070d109b5b57  gdb/testsuite/gdb.ada/funcall_param/pck.ads
-3789c6863cab39eeff29c9e172f6b045  gdb/testsuite/gdb.ada/homonym/homonym.adb
-1c500a23eb2f863b89d17f3e5a9929f6  gdb/testsuite/gdb.ada/homonym/homonym.ads
-7678b7ee57207a789930291fc1392127  gdb/testsuite/gdb.ada/homonym/homonym_main.adb
-ce18f260275ec9f0036d9ef54978b00c  gdb/testsuite/gdb.ada/interface/foo.adb
-31edc461b19d8105bb422ca9bae62706  gdb/testsuite/gdb.ada/interface/types.adb
-b89f86a60a1e4b8aa722b7c474ce8268  gdb/testsuite/gdb.ada/interface/types.ads
-c2782025abd62ce1418d96feadfcd3a2  gdb/testsuite/gdb.ada/nested/hello.adb
-ba85b06a8a480d9ad7bd7d5bd8cfb438  gdb/testsuite/gdb.ada/null_array/foo.adb
-32d5bffdafc5a65474d29bc81d553a8d  gdb/testsuite/gdb.ada/null_array/pck.adb
-d983388fb8b79a7b9f92af78f477cc0d  gdb/testsuite/gdb.ada/null_array/pck.ads
-dc02ae42cf148504992bbc5f9599c3fd  gdb/testsuite/gdb.ada/null_record/bar.adb
-adbb4697cdfafa37320e4b023abd7773  gdb/testsuite/gdb.ada/null_record/bar.ads
-b3b8073b5bfb86490d7005e74e7d4be7  gdb/testsuite/gdb.ada/null_record/null_record.adb
-fbe37613f7121dc2a23d1590706bd73e  gdb/testsuite/gdb.ada/packed_array/pa.adb
-82f22670c3f55992aab1d50c0fabb71f  gdb/testsuite/gdb.ada/packed_tagged/comp_bug.adb
-7e19a4a05e8feff0e6d56ef81311b780  gdb/testsuite/gdb.ada/print_chars/foo.adb
-dc9e319b9377dbeae70d7a14b51e9b9b  gdb/testsuite/gdb.ada/print_chars/pck.adb
-a8e19d171b39943a3e6175d52b0c5ba3  gdb/testsuite/gdb.ada/print_chars/pck.ads
-e1aa52de8fba0bf42bfab02266b45461  gdb/testsuite/gdb.ada/ptype_field/foo.adb
-2e6ddb872a9f702bdf74ac43dc7daf1c  gdb/testsuite/gdb.ada/ptype_field/pck.adb
-b3151037c81d34c9fa22cb3a48f69d59  gdb/testsuite/gdb.ada/ptype_field/pck.ads
-7b8657b47114cfc02a67790a4aa53984  gdb/testsuite/gdb.ada/ref_param/foo.adb
-6a732d392ef941d8dbe5e857bc89208a  gdb/testsuite/gdb.ada/ref_param/pck.adb
-cb91078c63fe82900e8f6926ba164944  gdb/testsuite/gdb.ada/ref_param/pck.ads
-c9b77975eba7ef9bba1b097a07897472  gdb/testsuite/gdb.ada/start/dummy.adb
-c63232a144a892516dccb52f0aec17d5  gdb/testsuite/gdb.ada/str_ref_cmp/foo.adb
-a89384696a45ba525dde9b0461fffcdd  gdb/testsuite/gdb.ada/str_ref_cmp/pck.ads
-68fd863a7db304a27bc67190ecc25513  gdb/testsuite/gdb.ada/sym_print_name/foo.adb
-e237e434de913ad488d6a5e4474aceb9  gdb/testsuite/gdb.ada/sym_print_name/pck.adb
-0650f89664b4dfa85a3b2d2f29fe598d  gdb/testsuite/gdb.ada/sym_print_name/pck.ads
-dc307b811dae43226fee19dacb5819d8  gdb/testsuite/gdb.ada/taft_type/p.adb
-2d0976def623a9f717bd40adefbca014  gdb/testsuite/gdb.ada/taft_type/pck.adb
-a30df42802b5256e9b66409684a19ba4  gdb/testsuite/gdb.ada/taft_type/pck.ads
-0b626a30e44ff8fcd623a52af5d6dfeb  gdb/testsuite/gdb.ada/tagged/foo.adb
-ab0ea7031ac64a30caa6aa263f908162  gdb/testsuite/gdb.ada/tagged/pck.adb
-19fa60b19348f8d8a831564d2b6a2241  gdb/testsuite/gdb.ada/tagged/pck.ads
-b6782336f83c38135b9517757f05d239  gdb/testsuite/gdb.ada/type_coercion/assign.adb
-f0e487e325b3e0575837cc463a8de68e  gdb/testsuite/gdb.ada/type_coercion/ident.adb
-7e08b8b0aca21d160d667fbf4aa34db2  gdb/testsuite/gdb.ada/watch_arg/watch.adb
-f6c31f326a6a8a5fe922841a22e861cb  gdb/testsuite/gdb.arch/Makefile.in
-506a321720167cf48173a2e8a5facbc5  gdb/testsuite/gdb.arch/alpha-step.c
-0d20917962f56ec09ec2b2208f9ba211  gdb/testsuite/gdb.arch/alpha-step.exp
-8512d3cf77bca3f120284ed9cfb3f64a  gdb/testsuite/gdb.arch/altivec-abi.c
-a6c3bd7c73ad85f8c1394cf817c19ea9  gdb/testsuite/gdb.arch/altivec-abi.exp
-a4b44663a9c9d2ac554ea371750489cf  gdb/testsuite/gdb.arch/altivec-regs.c
-541954b7e8e06879f93c1b4de6889181  gdb/testsuite/gdb.arch/altivec-regs.exp
-11389013dfeba005022a1d910728c9d7  gdb/testsuite/gdb.arch/e500-abi.c
-46dc00f775fbe6927a6cb1c2d4a8a11f  gdb/testsuite/gdb.arch/e500-abi.exp
-8b0b1fa6081901e3ea323871f5fe5d0b  gdb/testsuite/gdb.arch/e500-prologue.c
-9a484beffd39d83dd0025548fe4fe1cd  gdb/testsuite/gdb.arch/e500-prologue.exp
-fcd0dd3432e917999e1b351b9467f52f  gdb/testsuite/gdb.arch/e500-regs.c
-6eff232c2f2fff09042a3dbf9537cfa8  gdb/testsuite/gdb.arch/e500-regs.exp
-9708fbf12acb2894977b159769567197  gdb/testsuite/gdb.arch/gdb1291.exp
-0f8a125be81607b19d3c8abbbcf80e02  gdb/testsuite/gdb.arch/gdb1291.s
-a30131751399a9831cd7e43950bf1ab6  gdb/testsuite/gdb.arch/gdb1431.exp
-4ccf6a0cbb8b45f13e74739a4e052134  gdb/testsuite/gdb.arch/gdb1431.s
-94fe187174ee92dc451cf8eaffa830ad  gdb/testsuite/gdb.arch/gdb1558.c
-dc4e17e600a1b1d00c27781fce30f80d  gdb/testsuite/gdb.arch/gdb1558.exp
-e2e6db61bc902ee57e65da866da3aea1  gdb/testsuite/gdb.arch/i386-cpuid.h
-4a05dadae9bfa792fb20c5ef354323f6  gdb/testsuite/gdb.arch/i386-gnu-cfi-asm.S
-c21b66a4778f7aeaa479262a4115f190  gdb/testsuite/gdb.arch/i386-gnu-cfi.c
-680d6bf40d8f43d30440348b976f6818  gdb/testsuite/gdb.arch/i386-gnu-cfi.exp
-d14d4d7d828397dc1dfec72f46f0a409  gdb/testsuite/gdb.arch/i386-prologue.c
-faeee917cdc113e831e3d37628d12d00  gdb/testsuite/gdb.arch/i386-prologue.exp
-47919978de959817cb56790e150a672d  gdb/testsuite/gdb.arch/i386-signal.c
-41d4d4d78815b11482b46c36e10cdc1f  gdb/testsuite/gdb.arch/i386-signal.exp
-216024fac2e264ab6ce47a8724295135  gdb/testsuite/gdb.arch/i386-size-overlap.c
-8cefb337a1fe74964242e3cfa2e6f99f  gdb/testsuite/gdb.arch/i386-size-overlap.exp
-d8676854dcd0cfe0f7d2ad4811be1689  gdb/testsuite/gdb.arch/i386-size.c
-4d9aa3cb775cdc02d92eaa5e897e5729  gdb/testsuite/gdb.arch/i386-size.exp
-ed24e1b01d58821317b660d3755f3050  gdb/testsuite/gdb.arch/i386-sse.c
-67cca6ba09c9172b75d345f075660605  gdb/testsuite/gdb.arch/i386-sse.exp
-8dce059f23e6dde228cb55fa8242dabd  gdb/testsuite/gdb.arch/i386-unwind.c
-eefef61cbc09630e9332da1a6d8705e4  gdb/testsuite/gdb.arch/i386-unwind.exp
-1f42cade13e9155abcca3ae4838a0e6c  gdb/testsuite/gdb.arch/iwmmxt-regs.c
-87f49d5905a395632d71b24ac1d9d800  gdb/testsuite/gdb.arch/iwmmxt-regs.exp
-6a2c0847c21256991bebd4eb42c3df16  gdb/testsuite/gdb.arch/pa-nullify.exp
-7e15fe36f59b8e04c5fb0265a6950c3e  gdb/testsuite/gdb.arch/pa-nullify.s
-5fb2eaef8fa3678d2f93e1b0c7c65be6  gdb/testsuite/gdb.arch/pa64-nullify.s
-a722427500fe4e2975c19583ad57ce2a  gdb/testsuite/gdb.arch/powerpc-aix-prologue.c
-722e85d04af4e558cfb05c164f8cf309  gdb/testsuite/gdb.arch/powerpc-aix-prologue.exp
-f773561447caeeb975e654edd13b0d65  gdb/testsuite/gdb.arch/powerpc-d128-regs.c
-156d7a41fb0820df13f503a93f641b1a  gdb/testsuite/gdb.arch/powerpc-d128-regs.exp
-9fc255e2a2796ca932b7c724aea84d0e  gdb/testsuite/gdb.arch/powerpc-prologue.c
-f89cf79c45018ba179c0f6e36db7d9f9  gdb/testsuite/gdb.arch/powerpc-prologue.exp
-6a6b11d9e558927a7f166d4075ecbfea  gdb/testsuite/gdb.arch/ppc64-atomic-inst.c
-3e643fa6d272fc88978c29b8cde9397a  gdb/testsuite/gdb.arch/ppc64-atomic-inst.exp
-eec02b8d866ade4fe9af38c61f316eb6  gdb/testsuite/gdb.arch/spu-info.c
-0b448f05b47080d3f59682c0c8523835  gdb/testsuite/gdb.arch/spu-info.exp
-fcbf42f018095ed6b20b85bbf09ec1e3  gdb/testsuite/gdb.arch/thumb-prologue.c
-e8963ea2486d50275ecab720150b9ff0  gdb/testsuite/gdb.arch/thumb-prologue.exp
-f2e003c28af0ab5d01be9fc57e01b1cb  gdb/testsuite/gdb.asm/Makefile.in
-577585273ffc0fef150e7e01df7cebf9  gdb/testsuite/gdb.asm/alpha.inc
-73f28b814430e5f1534678ff549c32cc  gdb/testsuite/gdb.asm/arm.inc
-9dcf2e6637087c7fb6309bbb7fc32931  gdb/testsuite/gdb.asm/asm-source.exp
-5f09d8277f673fb83ee1483edc03abbc  gdb/testsuite/gdb.asm/asmsrc1.s
-08a59dcdce475e0de4d4e5cd882c3c0a  gdb/testsuite/gdb.asm/asmsrc2.s
-7450e0fb35df49b1087ec197a4046ac1  gdb/testsuite/gdb.asm/common.inc
-b3f11b21e5921c419a43f93720dedf85  gdb/testsuite/gdb.asm/empty.inc
-c1af33e47ebc93f30c55b5c06d62783a  gdb/testsuite/gdb.asm/frv.inc
-561956b7afd2c11c4c23bede641b024d  gdb/testsuite/gdb.asm/h8300.inc
-3b5b119fd551ea7bb3d99b3025d74699  gdb/testsuite/gdb.asm/i386.inc
-3ac68989375cc36de41334e4c629f40a  gdb/testsuite/gdb.asm/ia64.inc
-ebdbf0ff3c07743179410487fd400598  gdb/testsuite/gdb.asm/iq2000.inc
-f7aa57ad2dc302e4d47fcda58eb1c01d  gdb/testsuite/gdb.asm/m32c.inc
-b3bdc251c6b1eaf09953283df330eb9a  gdb/testsuite/gdb.asm/m32r-linux.inc
-7aab094990e39f5827eb3942d43a8e8e  gdb/testsuite/gdb.asm/m32r.inc
-583de4033345bc72fc5e10e2c913c70d  gdb/testsuite/gdb.asm/m68hc11.inc
-efc7a21c1c978e155224ad5143df8bd1  gdb/testsuite/gdb.asm/m68k.inc
-cf9905b35d641b6c44fa17870eaf36d7  gdb/testsuite/gdb.asm/mips.inc
-c4d2ba6404c6cf567a68a9e710a973a0  gdb/testsuite/gdb.asm/netbsd.inc
-84e7dd06d6793d60a4572e6024408f80  gdb/testsuite/gdb.asm/openbsd.inc
-bc2f2b56b97a741661cae171ca969cf0  gdb/testsuite/gdb.asm/pa.inc
-f2f66e4e9590af6782690580df003342  gdb/testsuite/gdb.asm/pa64.inc
-39ebc659f663bc0102201771dbadaba8  gdb/testsuite/gdb.asm/powerpc.inc
-c2ab6abca2f2009bd9b4b7f2501e8f9a  gdb/testsuite/gdb.asm/s390.inc
-59ed9adaed6dc7b887446707cf6c2d5f  gdb/testsuite/gdb.asm/s390x.inc
-96af5da159a5e8f03a3468db854d05a3  gdb/testsuite/gdb.asm/sh.inc
-004e3184dcbd00cdedc9969b1a860626  gdb/testsuite/gdb.asm/sparc.inc
-bef01819157e0cca7af4ba8058f5eaab  gdb/testsuite/gdb.asm/sparc64.inc
-fec2ca2fbcc0b02d6f21dcf2d73970b3  gdb/testsuite/gdb.asm/spu.inc
-e3c5be9e840a34c66a75b0204fe24a05  gdb/testsuite/gdb.asm/v850.inc
-7d06fead332c40b8b2b7b7e2e0cda153  gdb/testsuite/gdb.asm/x86_64.inc
-425d8b8ae6d12133808165dd066a3f6c  gdb/testsuite/gdb.asm/xstormy16.inc
-4009b43c0b4ee5a6d0ae5ddcefac64ce  gdb/testsuite/gdb.base/Makefile.in
-6d0db77a72100bcb7c95134c6f877bf0  gdb/testsuite/gdb.base/a2-run.exp
-006e8779c9e23af3419a58591b7eab7e  gdb/testsuite/gdb.base/advance.c
-16ddab1caeaa504f94b77bf650f30a9c  gdb/testsuite/gdb.base/advance.exp
-15069bfe301f42db9afa215b8dbe38ce  gdb/testsuite/gdb.base/all-bin.exp
-7a6a57ab31ce1cf79d80fe6b690ba253  gdb/testsuite/gdb.base/all-types.c
-f76f09cd7572a5024b5ec2307f4f7a9b  gdb/testsuite/gdb.base/annota1.c
-82b3e2f3ee4b08624ea504db915abb86  gdb/testsuite/gdb.base/annota1.exp
-f76f09cd7572a5024b5ec2307f4f7a9b  gdb/testsuite/gdb.base/annota3.c
-5d130be09c4c89187222ab8c1ac1a1bd  gdb/testsuite/gdb.base/annota3.exp
-246912b4a24edf28c2896b2b0581372b  gdb/testsuite/gdb.base/args.c
-4083c73f398690eca138672ebd8a551c  gdb/testsuite/gdb.base/args.exp
-51c1d4870799ce58aded7ce3572d190e  gdb/testsuite/gdb.base/arithmet.exp
-7622b86569ffff310ffdb5cc81aa16b0  gdb/testsuite/gdb.base/arrayidx.c
-91a6084376c4ec0dd5c2a88565a76fbc  gdb/testsuite/gdb.base/arrayidx.exp
-cc5b29b166c97833c3216d3e4ea2bffd  gdb/testsuite/gdb.base/assign.exp
-7c164cbba3852ca6d8407f5461733f76  gdb/testsuite/gdb.base/async.c
-c4bf34ba6d664ac998b97092455fdeca  gdb/testsuite/gdb.base/async.exp
-67f370c8661ab05209185c9be1b1266f  gdb/testsuite/gdb.base/attach.c
-48fa7b79d8ce5e3395db8c939ef4741c  gdb/testsuite/gdb.base/attach.exp
-40ea0b637bee041d22c72ad5ce356d17  gdb/testsuite/gdb.base/attach2.c
-8e3356f52b574c0d37a72a42f3a57906  gdb/testsuite/gdb.base/auxv.c
-5260799ab3597213ae69123f5c9781e3  gdb/testsuite/gdb.base/auxv.exp
-d8f766041b8c03338b5833d6c37c5008  gdb/testsuite/gdb.base/average.c
-8bf448c47be4a8156cf5dc9e173adfd2  gdb/testsuite/gdb.base/bang.exp
-94c1f1818c9234b5e8e7669b457865c1  gdb/testsuite/gdb.base/bar.c
-875a150f7fd4db096ea08b9acd105dae  gdb/testsuite/gdb.base/baz.c
-0f09fee483dc56093e6ca523b2da658f  gdb/testsuite/gdb.base/bfp-test.c
-2c96da2ebaa2481ea60bb7e68f351689  gdb/testsuite/gdb.base/bfp-test.exp
-e6ea67caae0388200688dbd8eb084e74  gdb/testsuite/gdb.base/bigcore.c
-0f199dacd7887988e563d66a5854579f  gdb/testsuite/gdb.base/bigcore.exp
-22193e74f9a52aac8fe5375e117ac5de  gdb/testsuite/gdb.base/bitfields.c
-9878b5a9d9ad25681070af49b64381ec  gdb/testsuite/gdb.base/bitfields.exp
-b8c369bd4563ac0d10948d5771de0aeb  gdb/testsuite/gdb.base/bitfields2.c
-9d000284b8c557deaa31fe44e59149db  gdb/testsuite/gdb.base/bitfields2.exp
-7f6a4778ce1dce05437ac89f5248a764  gdb/testsuite/gdb.base/bitops.exp
-601f4ed2b5be1d234ba175e76d7bba62  gdb/testsuite/gdb.base/branches.c
-92c24f0179f9de4b20ceb6c042eb1a59  gdb/testsuite/gdb.base/break.c
-186ed1391fb2906275a71b4fe9c77cbc  gdb/testsuite/gdb.base/break.exp
-f2fc4c4d5ced558cc61ba4f95c348095  gdb/testsuite/gdb.base/break1.c
-00423b6818e5837317fd66f9609d152b  gdb/testsuite/gdb.base/call-ar-st.c
-7368669feb9cd9baad6b0138cb042645  gdb/testsuite/gdb.base/call-ar-st.exp
-868c4632e7860280ad3ddd0c7713c819  gdb/testsuite/gdb.base/call-rt-st.c
-2d5ec00c80a8ac7a9b1677f03b7ed121  gdb/testsuite/gdb.base/call-rt-st.exp
-f801e76d8c1794445bc0b0733d4812b4  gdb/testsuite/gdb.base/call-sc.c
-c238179c42fda049bb89f48b95653f36  gdb/testsuite/gdb.base/call-sc.exp
-0903784a2f2f16faef989543e584e31e  gdb/testsuite/gdb.base/call-strs.c
-954f10a2871260f41c9d6f6c69a63692  gdb/testsuite/gdb.base/call-strs.exp
-9301a8bb75f208d196298439ebeae51e  gdb/testsuite/gdb.base/callfuncs.c
-79ca1eea4cf567019b6aa0c3eaabbc3f  gdb/testsuite/gdb.base/callfuncs.exp
-a7e971296b00830908dcc74c4bff1075  gdb/testsuite/gdb.base/charset.c
-59d4e1c26c010eabaa62057ce00beff0  gdb/testsuite/gdb.base/charset.exp
-88267a34479ed7effc29fa693210220f  gdb/testsuite/gdb.base/checkpoint.c
-d19b1f0c06f6b6ba58683168a98295dd  gdb/testsuite/gdb.base/checkpoint.exp
-91a9797c36773f25d2961a2478d37c89  gdb/testsuite/gdb.base/chng-syms.c
-0be121d4f951ae9d507958ca5d333574  gdb/testsuite/gdb.base/chng-syms.exp
-ba9b04ea2539bc6f2f7c98fb08b0cbf8  gdb/testsuite/gdb.base/code-expr.exp
-91156bc6ee6206ffac7de55ba84f8b0f  gdb/testsuite/gdb.base/commands.exp
-2052d09faa2b0de0d09125302a541681  gdb/testsuite/gdb.base/completion.exp
-8191e2434ee97faa0c882c6fe5df904a  gdb/testsuite/gdb.base/complex.c
-616fd317f6b371a5ef1a4c1c82c5b5dd  gdb/testsuite/gdb.base/complex.exp
-dd56a025cd0559ac1ae8552c66908900  gdb/testsuite/gdb.base/cond-expr.exp
-970c6b2a76ef766756ba2c64abc2cc77  gdb/testsuite/gdb.base/condbreak.exp
-0a38768b03d77eda97cc0c83af11699d  gdb/testsuite/gdb.base/consecutive.c
-864713d9c1385ed4fc5070aafdced645  gdb/testsuite/gdb.base/consecutive.exp
-f4624ddb27023419c80621cd0bacb5b2  gdb/testsuite/gdb.base/constvars.c
-66ac65d3ac4a516ae8b80253c38fed4c  gdb/testsuite/gdb.base/constvars.exp
-987914cf8f7fe5782d8d64a7ef5cc732  gdb/testsuite/gdb.base/corefile.exp
-c882f34600d8ac2ab38411bfc50a14d6  gdb/testsuite/gdb.base/coremaker.c
-29905cd2b5983321107a47f7abb1c4a0  gdb/testsuite/gdb.base/coremaker2.c
-43b6baabb0081783b08a91ed1f2a5f03  gdb/testsuite/gdb.base/cursal.c
-cfe1f1ac882943e2a76ca5edf3551470  gdb/testsuite/gdb.base/cursal.exp
-69923a6e72d188cd0dbf547eaf433688  gdb/testsuite/gdb.base/cvexpr.c
-769060a2653d6aeaf092ccccb85b4530  gdb/testsuite/gdb.base/cvexpr.exp
-c8b29ef2ecb662f50ea8aa7966c163f8  gdb/testsuite/gdb.base/d10v.ld
-35ce0d1e8a6cc6a278649ec7464d8a1c  gdb/testsuite/gdb.base/d10vovly.c
-3116417b3ccf43f71a19242f8cd9de74  gdb/testsuite/gdb.base/dbx.exp
-7c6f0f7ff9e64e3a7b6b16dc0d127231  gdb/testsuite/gdb.base/default.exp
-3f1ff767d745aad3e93ed4513d498010  gdb/testsuite/gdb.base/define.exp
-0fce7fb9d8b8bda503a1d4c635a1072b  gdb/testsuite/gdb.base/del.c
-823b9322076c3b3c6a163bbbf3f45b39  gdb/testsuite/gdb.base/del.exp
-d6722c0691bfb113a7b9e018516ca735  gdb/testsuite/gdb.base/detach.exp
-5ad0fffb5691cebf605d705d39498078  gdb/testsuite/gdb.base/dfp-exprs.exp
-1253acbc45e13389dd142deedbb1daa2  gdb/testsuite/gdb.base/dfp-test.c
-84f6b46dbb4f2be287a853a2b1c2c630  gdb/testsuite/gdb.base/dfp-test.exp
-6cd78185592d6b4044a13581688e6cf8  gdb/testsuite/gdb.base/display.c
-ae4e53a1d9204dc9ca14bed51d157938  gdb/testsuite/gdb.base/display.exp
-ca9ff510856000f9ee111095ef00f913  gdb/testsuite/gdb.base/dump.c
-9b76e1d6e43fa5286e3ea24036e1093d  gdb/testsuite/gdb.base/dump.exp
-d4d19b90f6c9890bef93049c4023a488  gdb/testsuite/gdb.base/echo.exp
-307f9c3c6c8a7a20016632fd6216e58c  gdb/testsuite/gdb.base/ena-dis-br.exp
-b9638337fbfa28806436681d540a2311  gdb/testsuite/gdb.base/ending-run.c
-9528d75f3bc1b6548bfc40fe6351ef89  gdb/testsuite/gdb.base/ending-run.exp
-1dd778a6012b446d1252b60e8d6c6e64  gdb/testsuite/gdb.base/environ.exp
-74a9d6e1bd045e645ac465ef758f6231  gdb/testsuite/gdb.base/eval-skip.exp
-fe778e4ca9af81e067b376479c5f876d  gdb/testsuite/gdb.base/execd-prog.c
-1d710c58afe5ae3a2ab25270f64b7051  gdb/testsuite/gdb.base/expand-psymtabs.c
-7ec8aaf21d72b2a61e7d0f69d599765d  gdb/testsuite/gdb.base/expand-psymtabs.exp
-2d5e42c7a5399e6b0e5088388b4cfcc0  gdb/testsuite/gdb.base/exprs.c
-74b990040ec8f84b8f32fa962bb108d3  gdb/testsuite/gdb.base/exprs.exp
-e294cc8355af4c41ad49310279c3767e  gdb/testsuite/gdb.base/fileio.c
-f81377bb48a65ad09d0b3eacea5d9010  gdb/testsuite/gdb.base/fileio.exp
-9d220db923beba18b1a4a4476dedd17b  gdb/testsuite/gdb.base/finish.exp
-3604002068cbe8f6e34a84f2ae66e628  gdb/testsuite/gdb.base/float.exp
-5acfdd7a2dd0575778a59acf1e3e899e  gdb/testsuite/gdb.base/foll-exec.c
-b2f1c822c9e3aefdaf016bc92eee8e4b  gdb/testsuite/gdb.base/foll-exec.exp
-9ab04e56d1356b09f45c460f3338996f  gdb/testsuite/gdb.base/foll-fork.c
-877b5b855f503627ad9a9d1bcabeaddc  gdb/testsuite/gdb.base/foll-fork.exp
-a7ea93bfb6e477f12e7a3c6404410b88  gdb/testsuite/gdb.base/foll-vfork.c
-cbb8004aea07f371406f7f1393f8ec92  gdb/testsuite/gdb.base/foll-vfork.exp
-c6a16edc9359f0384e9bb01cc216272c  gdb/testsuite/gdb.base/foo.c
-cd0d5e6755b2e77c13bbdec54111793f  gdb/testsuite/gdb.base/frame-args.c
-fcff40550c5748cacea2944a4c14d220  gdb/testsuite/gdb.base/frame-args.exp
-a6cd7365f4ab97f2f5a6472c849c366b  gdb/testsuite/gdb.base/freebpcmd.c
-979df24e346227cdf654246cd369ce37  gdb/testsuite/gdb.base/freebpcmd.exp
-e263d03bb6f3616f05e38769be7a0c5d  gdb/testsuite/gdb.base/funcargs.c
-dc079be793b021eb08d8f55464bd5e71  gdb/testsuite/gdb.base/funcargs.exp
-0058722587924079e87c733d2821b4ed  gdb/testsuite/gdb.base/gcore-buffer-overflow.c
-c4dd53545df4d570f02a472c32532d11  gdb/testsuite/gdb.base/gcore-buffer-overflow.exp
-c6f9e178b6344cac8e7282ecd01cea34  gdb/testsuite/gdb.base/gcore.c
-eadcae6b913f683ce5308a199d1710dc  gdb/testsuite/gdb.base/gcore.exp
-9ee591c14ed794700c27a8bdabe483b1  gdb/testsuite/gdb.base/gdb1056.exp
-92d352dc2372b2c5f9d0762b4384309f  gdb/testsuite/gdb.base/gdb1090.c
-3e2e84cdbcbc4eefbbd259cfa1db3e79  gdb/testsuite/gdb.base/gdb1090.exp
-99fc0a3a9ad9d98004eb3e5764a0ba87  gdb/testsuite/gdb.base/gdb1250.c
-e00d475a9a1c6a8f6727d2704fdc877c  gdb/testsuite/gdb.base/gdb1250.exp
-75c7b64dcf5f54bf76ce7a2e825a7644  gdb/testsuite/gdb.base/gdb1555-main.c
-4cea9d584c9f1f735a82fc7044f20aee  gdb/testsuite/gdb.base/gdb1555.c
-13eff4568729e3cc9dfcc97997905b67  gdb/testsuite/gdb.base/gdb1555.exp
-d865778b2be275b9bd1c946dc7c2405a  gdb/testsuite/gdb.base/gdb1821.c
-a8824b1acea4325dfd0d47e9b9077b74  gdb/testsuite/gdb.base/gdb1821.exp
-a2bfa5dea845c91374b0ca3348d5fe1c  gdb/testsuite/gdb.base/gdb_history
-8f09535471d58408d63129bc827f0f28  gdb/testsuite/gdb.base/gdbvars.exp
-9cd4ef136dfbee149a4056477283fa41  gdb/testsuite/gdb.base/grbx.c
-b267ce5f41844aab9315fe7e827d5858  gdb/testsuite/gdb.base/help.exp
-1a35c6065c10f7f5e7d5fdc9d0136d67  gdb/testsuite/gdb.base/huge.c
-8ff7101e90d09fa56886cb0cbcab391e  gdb/testsuite/gdb.base/huge.exp
-ae36cb1a3f330084b7e05f9677e47490  gdb/testsuite/gdb.base/ifelse.exp
-1789aa99feb5ac00b5f59502236b06f7  gdb/testsuite/gdb.base/included.c
-f71b1fa668a8a85bc9d336dfd3983b63  gdb/testsuite/gdb.base/included.exp
-3dcec44c3223f4e319ef80b75a08d3f6  gdb/testsuite/gdb.base/included.h
-7597c9f479d1c814fb90880acce2b867  gdb/testsuite/gdb.base/infnan.c
-e39f6f87aac498ddb5d7a02ddbd0d3a5  gdb/testsuite/gdb.base/infnan.exp
-18353303d87f6c7d556a4300187c3638  gdb/testsuite/gdb.base/info-proc.exp
-55bbb1088e1173143dd23818588c559c  gdb/testsuite/gdb.base/int-type.c
-5b81185846995b5eb10b109cfdd1490f  gdb/testsuite/gdb.base/interp.exp
-57e887f3379fccaae0cdaeb9f2a5a400  gdb/testsuite/gdb.base/interrupt.c
-145b142ce6d1a081c1618e3b6f549cd1  gdb/testsuite/gdb.base/interrupt.exp
-5fefadea13c06424265ee8e5dbf68dd6  gdb/testsuite/gdb.base/jump.c
-226b33ba1a44ea49793170dc9d72b549  gdb/testsuite/gdb.base/jump.exp
-fa92eb92a1d43b3c66b22c54a7282c3a  gdb/testsuite/gdb.base/langs.exp
-a7fcf828c54dbdc1100d525500c41a4c  gdb/testsuite/gdb.base/langs0.c
-2d0b8bc2c2b4eb4f8a28b7cb39ce5dca  gdb/testsuite/gdb.base/langs1.c
-823ccdf3ec56d8acb08d21598d0f1d8e  gdb/testsuite/gdb.base/langs1.f
-c62aebd49fcf2ece63ec68610c644c0e  gdb/testsuite/gdb.base/langs2.c
-c90e022fb5ef3df8a5639df233f9c350  gdb/testsuite/gdb.base/langs2.cxx
-78e5943d56b5a904e2e29e51749312ed  gdb/testsuite/gdb.base/lineinc.c
-19f47f73c0210cb17cf9b1e99d7b8f84  gdb/testsuite/gdb.base/lineinc.exp
-0b4e499f872cfeaab21e0b173c718ca9  gdb/testsuite/gdb.base/lineinc1.h
-f6a96ae4d88de9220856194dacc8c9c8  gdb/testsuite/gdb.base/lineinc2.h
-80fb742c6028f138e4ad580d729b403a  gdb/testsuite/gdb.base/lineinc3.h
-4bad3a6b49a44375b6f090308e83cfb5  gdb/testsuite/gdb.base/list.exp
-e7d4aa964e0ac3b22a0ecfeef466c437  gdb/testsuite/gdb.base/list0.c
-d98c219c48dd073b09144e6cdb9de268  gdb/testsuite/gdb.base/list0.h
-8b38bf10b14906aeede912d147c23b43  gdb/testsuite/gdb.base/list1.c
-0323f373a16487ccf3f4730cf12c99e6  gdb/testsuite/gdb.base/logical.exp
-f88725dd68d9cfc9ae78f948fedd1ef3  gdb/testsuite/gdb.base/long_long.c
-5a2d1ce3fe8134dbaffd9c5cbc4f70e3  gdb/testsuite/gdb.base/long_long.exp
-d89474265b62f35df0c23a47bf1cc11a  gdb/testsuite/gdb.base/m32r.ld
-35ce0d1e8a6cc6a278649ec7464d8a1c  gdb/testsuite/gdb.base/m32rovly.c
-9d207119a48f6c3e23706d7c59f96ae9  gdb/testsuite/gdb.base/macscp.exp
-3f678def3cc5c8c57803f411fd798d0d  gdb/testsuite/gdb.base/macscp1.c
-256625bcc48a090ec4e5b85d1affa9bc  gdb/testsuite/gdb.base/macscp2.h
-bbd68c316d4ba5e21f8aac02eb605fa4  gdb/testsuite/gdb.base/macscp3.h
-dc1c7b2d0d97de5e07f0046fca14d586  gdb/testsuite/gdb.base/macscp4.h
-2000031450437a2144d25005a42dfd8c  gdb/testsuite/gdb.base/maint.exp
-c779221fb70a0e5b29aa0fffeb4b46b2  gdb/testsuite/gdb.base/mips_pro.c
-058cd19920074e96f1d14f2df50c6406  gdb/testsuite/gdb.base/mips_pro.exp
-643671e20fe8eff654f14011ab332137  gdb/testsuite/gdb.base/miscexprs.c
-3be030111bc62de6cce8fa46cbe9fa8e  gdb/testsuite/gdb.base/miscexprs.exp
-951b66324ed844118e76c28a488e3918  gdb/testsuite/gdb.base/multi-forks.c
-ec4048518006552841ca816cd1cbfcec  gdb/testsuite/gdb.base/multi-forks.exp
-b7d340c5410e83eab50f73e499be0759  gdb/testsuite/gdb.base/nodebug.c
-88f148c9754db03346aedd4fd07ff256  gdb/testsuite/gdb.base/nodebug.exp
-66cf0c909d1fb7e9f9d5d38c988dba14  gdb/testsuite/gdb.base/nofield.c
-cb9f0a295f28b5a68f3ad1fee1fb236c  gdb/testsuite/gdb.base/nofield.exp
-09e488c4d73f3a0cca0a72e22badc609  gdb/testsuite/gdb.base/opaque.exp
-52ba3d967b2b82fff0684a32c9306380  gdb/testsuite/gdb.base/opaque0.c
-177d0aa2dc05a0887607543ae7a63ae4  gdb/testsuite/gdb.base/opaque1.c
-cc19ee1eb79fe010ad5bab989640c407  gdb/testsuite/gdb.base/overlays.c
-88fbb22f4f0836ca70fc85fdef1eca15  gdb/testsuite/gdb.base/overlays.exp
-f7aec7811932b17ea2e12b59c13e377e  gdb/testsuite/gdb.base/ovlymgr.c
-beb7ddd8ac440e541b4ff7458987281f  gdb/testsuite/gdb.base/ovlymgr.h
-647ab0ce081439299124808311db60a8  gdb/testsuite/gdb.base/page.exp
-0fec50da02e7cd3be0581d9269e8b27b  gdb/testsuite/gdb.base/pc-fp.c
-806d3db3d5be14b3492d77891746b2d1  gdb/testsuite/gdb.base/pc-fp.exp
-e0c76a416b1a82540d0f10d2daab7d48  gdb/testsuite/gdb.base/pending.c
-4417033daa22f94d26c9c822b2514360  gdb/testsuite/gdb.base/pending.exp
-c1fc48f1ba7538e7c89b4ff6411c06b7  gdb/testsuite/gdb.base/pendshr.c
-d227cd5acdb0fca7bc3bc43b226fcf96  gdb/testsuite/gdb.base/pi.txt
-8d268468e492f058d3ca8b553a0cfc54  gdb/testsuite/gdb.base/pointers.c
-f18f5b48ecc21d3e32ad20abf2a4717b  gdb/testsuite/gdb.base/pointers.exp
-4001c85534386a74ee6988771f0e0624  gdb/testsuite/gdb.base/prelink-lib.c
-2e8b5ed13cd6e16bba1ce6639f6285cd  gdb/testsuite/gdb.base/prelink.c
-75c5922afb130515c42abe46458ea2e1  gdb/testsuite/gdb.base/prelink.exp
-20a5cda7d951262d0e36cb599fdb8857  gdb/testsuite/gdb.base/printcmds.c
-40d62c319b6e4d6c9ad5d2159d84a25c  gdb/testsuite/gdb.base/printcmds.exp
-383f301ce1ca0248bf942df1bcf159f8  gdb/testsuite/gdb.base/prologue.c
-134902e4fa21c9c43fe099c04ff867fc  gdb/testsuite/gdb.base/prologue.exp
-e6acd189e8c348fa5116ac01f1ad337e  gdb/testsuite/gdb.base/psymtab.exp
-b263e085b920ccae2568157fcc33189f  gdb/testsuite/gdb.base/psymtab1.c
-f356ff50643e59000ef3d9f24089698b  gdb/testsuite/gdb.base/psymtab2.c
-ff92343fd0a401ca16b1b1434bda2bc7  gdb/testsuite/gdb.base/ptr-typedef.c
-4030759eb21b9e321ae12dd1abce27a3  gdb/testsuite/gdb.base/ptr-typedef.exp
-eb0f2703e499be5fe3bb000684f13d52  gdb/testsuite/gdb.base/ptype.c
-f2f4eebb279345ac2decedd7c1f532dc  gdb/testsuite/gdb.base/ptype.exp
-46b4c46217f2fcdabd1bba7e9afaf4bd  gdb/testsuite/gdb.base/ptype1.c
-106e54de116670ee724b5ca0041092a1  gdb/testsuite/gdb.base/radix.exp
-b23fded5c5b9ab4fa0de27f7252616e4  gdb/testsuite/gdb.base/readline.exp
-b7c0b9263a943f4e519a0f797e126317  gdb/testsuite/gdb.base/recurse.c
-323397d33e1e7a873ed0edc709337094  gdb/testsuite/gdb.base/recurse.exp
-12a86a3a7844287bc54fc7f3ed792632  gdb/testsuite/gdb.base/regs.exp
-a07c596b0386f3c79fb0d1b9f2a1527c  gdb/testsuite/gdb.base/relational.exp
-4a6dc7a903d2a300b694df8f74aa0881  gdb/testsuite/gdb.base/relativedebug.c
-78defa6db77a2e63cc5c9d17ae93896d  gdb/testsuite/gdb.base/relativedebug.exp
-f46ed9e2f2f390d6bb0554c92b4ff556  gdb/testsuite/gdb.base/relocate.c
-a1f347e3abe947fd39908e11e16c5d7a  gdb/testsuite/gdb.base/relocate.exp
-79696e315e518bcff76ca31d67e55856  gdb/testsuite/gdb.base/remote.c
-cef22d1561044bb5d80aa893cd0f98f4  gdb/testsuite/gdb.base/remote.exp
-c9e0370496daf1c8fdefaa963ba21ea3  gdb/testsuite/gdb.base/remotetimeout.exp
-16266f8b6672b625edce63bd944fdb4f  gdb/testsuite/gdb.base/reread.exp
-b27553d250bc9c1302b8081e241e4630  gdb/testsuite/gdb.base/reread1.c
-a3e9015380f0b2b958c6387b733901ab  gdb/testsuite/gdb.base/reread2.c
-73ff82c7b16f3bcaf1f90091e4b283a0  gdb/testsuite/gdb.base/restore.c
-010f528d8832bf40b2f900c24f4346fe  gdb/testsuite/gdb.base/restore.exp
-a8afc935fcccb233c94780a5db339e1b  gdb/testsuite/gdb.base/return.c
-6836f0eda06c9a1076d22dc60e680890  gdb/testsuite/gdb.base/return.exp
-a083d8d4881ea947f4ec0a7af80e02e8  gdb/testsuite/gdb.base/return2.c
-b27c8bd93d440eefffbae7d4a9a957b0  gdb/testsuite/gdb.base/return2.exp
-d9eeb3be3ebabd9f01a38401b6df8314  gdb/testsuite/gdb.base/run.c
-920319a46e55d26bb6275957a976d0ab  gdb/testsuite/gdb.base/savedregs.c
-41872e83a0e7b05e83dd0e2efd8ae89d  gdb/testsuite/gdb.base/savedregs.exp
-2daea5ebc885a404ade7ae51a5f8d5b0  gdb/testsuite/gdb.base/scope.exp
-a2b39c6753b63d36e9076b2bc12609ea  gdb/testsuite/gdb.base/scope0.c
-f3b699a47e41a789efbd9f2bf3192364  gdb/testsuite/gdb.base/scope1.c
-6467d1bb4c568a7780b6efe0d6945754  gdb/testsuite/gdb.base/sect-cmd.exp
-91047c438dce8bdddc5d51639b17105a  gdb/testsuite/gdb.base/sep-proc.c
-6a1d25a15ddbf314abe64f08cfc0bbb7  gdb/testsuite/gdb.base/sep.c
-a977c9e85f3ba608b64611f92a62e31e  gdb/testsuite/gdb.base/sep.exp
-c7ca60ce8dded534a202ddbb70a1fa5b  gdb/testsuite/gdb.base/sepdebug.c
-4a7d0fd87e3af0505791096517cbcab9  gdb/testsuite/gdb.base/sepdebug.exp
-f011abd369c45bf7e48f3a619a173608  gdb/testsuite/gdb.base/sepsymtab.c
-59fcb6c122f9e8f0aada55bdb7623b90  gdb/testsuite/gdb.base/sepsymtab.exp
-fafd35fef08af25708189125b443c4f4  gdb/testsuite/gdb.base/set-lang-auto.exp
-fd21df76b25003cb1b35af07ebac8991  gdb/testsuite/gdb.base/setshow.c
-5e98dbf23eeb6bd99ac6a382a87407d3  gdb/testsuite/gdb.base/setshow.exp
-366a61f5feeadf4733e79506ff7f4271  gdb/testsuite/gdb.base/setvar.c
-a19295ba3038cc736851b5ce058cb2dc  gdb/testsuite/gdb.base/setvar.exp
-3f96d93715ced66f6254de7c80a3e759  gdb/testsuite/gdb.base/shlib-call.exp
-4417659f325c1872e097516a2b17a031  gdb/testsuite/gdb.base/shmain.c
-ea313b317035fa79cc1ae9bf6ef7d4ca  gdb/testsuite/gdb.base/shr1.c
-4c06f99b8d9db6a8a11b0e5474c3b5f5  gdb/testsuite/gdb.base/shr2.c
-3764973c71d5aa701031b4e66fd276d3  gdb/testsuite/gdb.base/shreloc.c
-503d46bc8a51d0f198bb1fdf7ee52b0b  gdb/testsuite/gdb.base/shreloc.exp
-18a49ceae996869f718980356f5f6b45  gdb/testsuite/gdb.base/shreloc1.c
-06a92d148b60fd5c50de17ed658ab73e  gdb/testsuite/gdb.base/shreloc2.c
-3b7f301a16a1a39bc10a75f8f4b3ae83  gdb/testsuite/gdb.base/sigall.c
-4b6a67880341bb131f838e4e262f5818  gdb/testsuite/gdb.base/sigall.exp
-ab232214e6b02de676f818844275853d  gdb/testsuite/gdb.base/sigaltstack.c
-5ae03b28fdaca0dbdf74f2c9b4ac865c  gdb/testsuite/gdb.base/sigaltstack.exp
-fcaeb80f2621874c74d1468753cb2dc1  gdb/testsuite/gdb.base/sigbpt.c
-2313a14072f6caaca05e45f5716f60c8  gdb/testsuite/gdb.base/sigbpt.exp
-7ac7e3252bf57225dca3b2fa5fbcdc66  gdb/testsuite/gdb.base/siginfo-addr.c
-652de817dd7c8bc503d0526b140eb3a5  gdb/testsuite/gdb.base/siginfo-addr.exp
-603f526e99779a47430d20cc7822109b  gdb/testsuite/gdb.base/siginfo.c
-084f98b079475258e2488799f6650592  gdb/testsuite/gdb.base/siginfo.exp
-24ddac9178f2f43b2b0f577c77aef032  gdb/testsuite/gdb.base/signals.c
-bb9eb69d8338ba6b7689b747e8cee848  gdb/testsuite/gdb.base/signals.exp
-40b5f52ab06d604e37e1430598660a96  gdb/testsuite/gdb.base/signull.c
-07c445eae5255e0bb1ac3dc3b4715cf8  gdb/testsuite/gdb.base/signull.exp
-07dd97a9d402f3114401bffd225645e0  gdb/testsuite/gdb.base/sigrepeat.c
-82e78c5bc1940b6e2f2d6dc4b9560bee  gdb/testsuite/gdb.base/sigrepeat.exp
-b6fdb2126ea51c3fd0c8980f71d2288c  gdb/testsuite/gdb.base/sigstep.c
-b856f12ea0bf8890dea8804c121bc450  gdb/testsuite/gdb.base/sigstep.exp
-2d5b486956a7f497ac3e5969bac13c3f  gdb/testsuite/gdb.base/sizeof.c
-95bbef56c76e65b9ffceeb3cdaf80b20  gdb/testsuite/gdb.base/sizeof.exp
-a7da6531d39dce0586f84083cc709aed  gdb/testsuite/gdb.base/so-disc-shr.c
-e711a6cfdf17afc08fbd300867145dd6  gdb/testsuite/gdb.base/so-impl-ld.c
-5057058ea5ce5d4eab492bcd33030c0d  gdb/testsuite/gdb.base/so-impl-ld.exp
-1429ffbb9973f67ebe556228ae4dfc66  gdb/testsuite/gdb.base/so-indr-cl.c
-13e6ac7f5b24c084609f8dbbd5f7b494  gdb/testsuite/gdb.base/so-indr-cl.exp
-3e439deaee6f5f1c60a8460fc4b0b56c  gdb/testsuite/gdb.base/solib-disc.c
-b2a86af6a3c7caad35770cee548008bb  gdb/testsuite/gdb.base/solib-disc.exp
-97f4280ac29133df670887f5ecaddd4b  gdb/testsuite/gdb.base/solib-symbol-lib.c
-1e44ba4343882e7a1f12fa72c61397bd  gdb/testsuite/gdb.base/solib-symbol-main.c
-b7b322873ca47666d39f971c9f4c39f4  gdb/testsuite/gdb.base/solib-symbol.exp
-baee74319cba1cd31d778e64919feaf3  gdb/testsuite/gdb.base/solib-weak.c
-c135abbf0c9ff301b44a902a36d94927  gdb/testsuite/gdb.base/solib-weak.exp
-0cdb3ac52471574e63518d04e7490c77  gdb/testsuite/gdb.base/solib.c
-fbc506cca18d84fc824601b7d9d7f054  gdb/testsuite/gdb.base/solib.exp
-09b3514ecddad4ca9dd40f06f77ca5cc  gdb/testsuite/gdb.base/solib1.c
-c08d6d5da171e08cd8bce11e6ee9ffb5  gdb/testsuite/gdb.base/solib2.c
-96cc94d2bb8dbebef5565d826afea12a  gdb/testsuite/gdb.base/source-error.gdb
-2c498e6316d4a87c7d767dbe49c25576  gdb/testsuite/gdb.base/source.exp
-b4816e4b91e99aa3e905b5d44802e907  gdb/testsuite/gdb.base/spu.ld
-25dd3e940b7f381b4985683b64dff8cf  gdb/testsuite/gdb.base/ss.h
-b44443bb463e1f99c74113dc675abfd2  gdb/testsuite/gdb.base/start.c
-4ccc5c668409585f5258d1b118b3a1ac  gdb/testsuite/gdb.base/start.exp
-0d3a2cf7ddbcd7228f1385154310e860  gdb/testsuite/gdb.base/step-bt.c
-6e58fa38c209607a94123c7690e33001  gdb/testsuite/gdb.base/step-bt.exp
-63b2398ae1df21322b955b7005cc8278  gdb/testsuite/gdb.base/step-line.c
-0d9ee85c5609e7ddfd77649134bf6527  gdb/testsuite/gdb.base/step-line.exp
-dff8f6cd42ca00fd6c42554bb325a398  gdb/testsuite/gdb.base/step-line.inp
-9ffc2cd8e384888785a57bd5ed8168d2  gdb/testsuite/gdb.base/step-test.c
-748e3a2655d7e294b98b7f45eb1bfaba  gdb/testsuite/gdb.base/step-test.exp
-1ea088b852b87134ad1b9038b0dd2204  gdb/testsuite/gdb.base/store.c
-df265acea064c46400c9e5cf4bc10189  gdb/testsuite/gdb.base/store.exp
-09a6fc6891440eb8ba1eec3681d7eda0  gdb/testsuite/gdb.base/structs.c
-fa444fb29d5f951d0d29088f820372c8  gdb/testsuite/gdb.base/structs.exp
-ea9603592d237a2624d44c1a417ebaef  gdb/testsuite/gdb.base/structs2.c
-2f781b66f4cd3f83ebd90bfd7e207776  gdb/testsuite/gdb.base/structs2.exp
-d63a92b3b1dc3a7c37093ff948714bd7  gdb/testsuite/gdb.base/subst.exp
-f979f053e2cd1a61d9630b75d70607ef  gdb/testsuite/gdb.base/sum.c
-c10100382a4e077f2196389bc601ea70  gdb/testsuite/gdb.base/term.exp
-e89c1a135fc287d5435475e92bc8dbc5  gdb/testsuite/gdb.base/trace-commands.exp
-e230b8767f5ad5901a40b01435d17089  gdb/testsuite/gdb.base/twice.c
-a4cad162d11f310f2e372b59833ee2f3  gdb/testsuite/gdb.base/twice.exp
-038a1873b4da495e55357b25430ea605  gdb/testsuite/gdb.base/type-opaque-lib.c
-77adda005c23f5bd3e75514173dc450d  gdb/testsuite/gdb.base/type-opaque-main.c
-9eb2e441871b8217ea1ef33c254ae832  gdb/testsuite/gdb.base/type-opaque.exp
-5505298b41b3e659f9c36e38d11a22dc  gdb/testsuite/gdb.base/unload.c
-1ad23433ed4c866f09e4109e9dd8b440  gdb/testsuite/gdb.base/unload.exp
-e6cd142cc2c4423872af8a6016b47ffa  gdb/testsuite/gdb.base/unloadshr.c
-cf953485fab28a5e8a31bca9f38824b3  gdb/testsuite/gdb.base/until.exp
-27120a964678d7be0acda6d1687f65dc  gdb/testsuite/gdb.base/varargs.c
-fa81c8ccd4a13eeb1a73c8007dc99365  gdb/testsuite/gdb.base/varargs.exp
-1a9fca83cee9e223ab94207b280c403b  gdb/testsuite/gdb.base/vforked-prog.c
-d58b03888202699839d3235bcbd48cd0  gdb/testsuite/gdb.base/volatile.exp
-c1ed8e2fae81a0ce27a2674c00907129  gdb/testsuite/gdb.base/watch_thread_num.c
-71de31bfbda30ead210739c6dbbb6699  gdb/testsuite/gdb.base/watch_thread_num.exp
-d8d9519cd6e881d4e59044c8760ce2bf  gdb/testsuite/gdb.base/watchpoint-solib-shr.c
-dc444034537a96c6b5397c57235d09d9  gdb/testsuite/gdb.base/watchpoint-solib.c
-469c2c1343736f66aff905c25ba4e2ec  gdb/testsuite/gdb.base/watchpoint-solib.exp
-2394ca7c0136f073f6ef282624a651d3  gdb/testsuite/gdb.base/watchpoint.c
-287e4f2ac3d67a40ec5fa0d7d08c6ef0  gdb/testsuite/gdb.base/watchpoint.exp
-b24929a390e78a5b211ba5c217b66bf8  gdb/testsuite/gdb.base/weaklib1.c
-ac42733755a18b7d9c60bf6828f3f7dc  gdb/testsuite/gdb.base/weaklib2.c
-28d867e681a7a3c15f9603f3e9fff8cc  gdb/testsuite/gdb.base/whatis-exp.exp
-9be8d8972b50b5430875d52ddd53a6a1  gdb/testsuite/gdb.base/whatis.c
-134b52f696146e39e129f76138501da9  gdb/testsuite/gdb.base/whatis.exp
-6a72518d64835ef176e31abca8f2f654  gdb/testsuite/gdb.cp/Makefile.in
-fa88dcd56730da0447f3d14fe40a5cd0  gdb/testsuite/gdb.cp/ambiguous.cc
-f1817399bef785ae1d787b706307e9e7  gdb/testsuite/gdb.cp/ambiguous.exp
-2088f98bb23167ea5e0c8b394c560519  gdb/testsuite/gdb.cp/annota2.cc
-23778b9d7b897d35f8da6eda2a213a70  gdb/testsuite/gdb.cp/annota2.exp
-2088f98bb23167ea5e0c8b394c560519  gdb/testsuite/gdb.cp/annota3.cc
-4d906e08dd1c3c5503aa1b4aae1e2a13  gdb/testsuite/gdb.cp/annota3.exp
-5221a33cd93ea0eba10ad76e6c55a030  gdb/testsuite/gdb.cp/anon-union.cc
-a5bd9a93692e504686e4ee88b08aadad  gdb/testsuite/gdb.cp/anon-union.exp
-41bf66afbc66687572c3e91db211a5be  gdb/testsuite/gdb.cp/arg-reference.cc
-f77cc1ce472d5d9646227ace7d599d9c  gdb/testsuite/gdb.cp/arg-reference.exp
-05fd14839c517350684056fe5e355938  gdb/testsuite/gdb.cp/bool.cc
-c47ca9241c702bcf36ebd97740dcb882  gdb/testsuite/gdb.cp/bool.exp
-88bf3d21d4f644d9b7723754432fca0f  gdb/testsuite/gdb.cp/breakpoint.cc
-ad5c927bd1b0cbf4193f0c2625430ee5  gdb/testsuite/gdb.cp/breakpoint.exp
-4be274446fa1b04394734f6e8942efc8  gdb/testsuite/gdb.cp/bs15503.cc
-1aa7f9502aa45f5fe9e906e08939a2a7  gdb/testsuite/gdb.cp/bs15503.exp
-d6757a494fc4ca63e75dce0f69ea634d  gdb/testsuite/gdb.cp/call-c-1.c
-d8de090b76804259bee4c9816fb4097c  gdb/testsuite/gdb.cp/call-c.cc
-164434c40a015623128b465cb104ceea  gdb/testsuite/gdb.cp/call-c.exp
-49d31866e1b2029326c237b6d0195eb8  gdb/testsuite/gdb.cp/casts.cc
-195dcd870ac8ae1a6714e8ebdca11f4b  gdb/testsuite/gdb.cp/casts.exp
-d787fe884aa5f0151d8b07ff95bd2755  gdb/testsuite/gdb.cp/class2.cc
-ac8ae89791f588c3b686132b719a6292  gdb/testsuite/gdb.cp/class2.exp
-da1829b3bcf59940b6778b68da802434  gdb/testsuite/gdb.cp/classes.cc
-334e3ae75cc99d74c2cde3d772e4a2ee  gdb/testsuite/gdb.cp/classes.exp
-12a9d35074987272d8a4ee3a326bf156  gdb/testsuite/gdb.cp/cp-relocate.cc
-d362a24a6864db9558e488a051f750a9  gdb/testsuite/gdb.cp/cp-relocate.exp
-8b5504ea8f47f041cd1e870dd5674f53  gdb/testsuite/gdb.cp/cplusfuncs.cc
-1105f3795f41ec13eed7bb2f3b730364  gdb/testsuite/gdb.cp/cplusfuncs.exp
-e432c32a814dfce372b4dae049d6cdf5  gdb/testsuite/gdb.cp/ctti.exp
-af7ef89d8481fa75842673c450bdcdd7  gdb/testsuite/gdb.cp/cttiadd.cc
-e1464b0cabfe3164a5d44523daccfac0  gdb/testsuite/gdb.cp/cttiadd1.cc
-eeaa00f0a0c591c0f9695b2cbfc9fadd  gdb/testsuite/gdb.cp/cttiadd2.cc
-a74c15ac31af71395b22ff9c89c66444  gdb/testsuite/gdb.cp/cttiadd3.cc
-20aa580a62ba92788f29ddfd869d8318  gdb/testsuite/gdb.cp/demangle.exp
-d4c5d86832a3728253bb6e303dca8814  gdb/testsuite/gdb.cp/derivation.cc
-945f68c7e85720faffb9ddd4a1d11a41  gdb/testsuite/gdb.cp/derivation.exp
-0530556c256bf906c330c7a82e7e4b29  gdb/testsuite/gdb.cp/exception.cc
-46217c89487bfd0e89c8498ef767d98b  gdb/testsuite/gdb.cp/exception.exp
-9fe1b9710e8bdb09575a32bf017c18d8  gdb/testsuite/gdb.cp/formatted-ref.cc
-4affd1dd37993d8e7e619d1f88287352  gdb/testsuite/gdb.cp/formatted-ref.exp
-dcbaddb5552d4990c58221d1ce771d2d  gdb/testsuite/gdb.cp/gdb1355.cc
-34cacc34f4af0a3a0f8f115b419ac796  gdb/testsuite/gdb.cp/gdb1355.exp
-b87f9b4f6a1e270152ae82704d013d1a  gdb/testsuite/gdb.cp/gdb2384-base.cc
-5b9edb23b4c9f4d90cc0a9d7019b8d41  gdb/testsuite/gdb.cp/gdb2384-base.h
-e8af6778d2cb360b12f145956a4f0dcb  gdb/testsuite/gdb.cp/gdb2384.cc
-a260426fdb0f93d79812dda2d69b3039  gdb/testsuite/gdb.cp/gdb2384.exp
-bec5831953699a0daf2274369c6f1ed1  gdb/testsuite/gdb.cp/hang.H
-768747fec9f1b1d3f70809e5bc3344c5  gdb/testsuite/gdb.cp/hang.exp
-22f928abbcff4e8dc10dfac79ea86311  gdb/testsuite/gdb.cp/hang1.C
-221eed5a3233c502015a7f69c71eb693  gdb/testsuite/gdb.cp/hang2.C
-81270652e911c432e26ef4b3bec6bc66  gdb/testsuite/gdb.cp/hang3.C
-823a0ea3a352482d4cf6a2f161276fc7  gdb/testsuite/gdb.cp/inherit.exp
-584a50069ae4ae90c745978c0bb994db  gdb/testsuite/gdb.cp/local.cc
-bd3db1056e245fb547c7eb3bde9ef106  gdb/testsuite/gdb.cp/local.exp
-010af669f824c8194c82fb921c6c2b2f  gdb/testsuite/gdb.cp/m-data.cc
-f0a4caa2fde7ab29a4ea6cbbd44812eb  gdb/testsuite/gdb.cp/m-data.exp
-4f5efd907b071b60ce5beaca84a5f5c6  gdb/testsuite/gdb.cp/m-static.cc
-ecec6908e9b124ce24e1f0deba6b05d1  gdb/testsuite/gdb.cp/m-static.exp
-03381ee9b0fe1ce8cf8d596fbbe8cd50  gdb/testsuite/gdb.cp/m-static.h
-7844dbfb63d5ee815db3c14cb769c796  gdb/testsuite/gdb.cp/m-static1.cc
-536d111a9b84e7b2f75b537632881ea6  gdb/testsuite/gdb.cp/maint.exp
-7d62b85617b0ab00c08a7ce1a68ce7a1  gdb/testsuite/gdb.cp/mb-ctor.cc
-9b02ea179c9a8b675254cb382af056fd  gdb/testsuite/gdb.cp/mb-ctor.exp
-02caf305e2888c61a02a6bf1ff0384b6  gdb/testsuite/gdb.cp/mb-inline.exp
-96706412305a32adea0f1f9654eb3e3c  gdb/testsuite/gdb.cp/mb-inline.h
-6f1a67cc2d33e69041b44c5d847ee888  gdb/testsuite/gdb.cp/mb-inline1.cc
-35c33fb85929f1b0cc9765d9ce02303c  gdb/testsuite/gdb.cp/mb-inline2.cc
-96776277e7c61028c4b644eb53798191  gdb/testsuite/gdb.cp/mb-templates.cc
-1623bb211d53a882469b4cc8e146270a  gdb/testsuite/gdb.cp/mb-templates.exp
-05cc275d8072fec2872b3a243590722d  gdb/testsuite/gdb.cp/member-ptr.cc
-f25870ca39232de7b6ff66a0d9950f96  gdb/testsuite/gdb.cp/member-ptr.exp
-53d65c3b49d4d39b7a1c8ff6d68c8a65  gdb/testsuite/gdb.cp/method.cc
-4c3e53300a7dc4129ef07d669586a71e  gdb/testsuite/gdb.cp/method.exp
-4e402d8c3d4006f294952831e26242fa  gdb/testsuite/gdb.cp/method2.cc
-7694a217432cd44f9fadd6c939709fc1  gdb/testsuite/gdb.cp/method2.exp
-4f1c6505a105f29362d8f0dc42a8a176  gdb/testsuite/gdb.cp/misc.cc
-9741c58040a6eca8f55d9cfd9505c2e0  gdb/testsuite/gdb.cp/misc.exp
-593e2413f186870185480c45ed5efe0f  gdb/testsuite/gdb.cp/namespace.cc
-e6c830c0f2d72dabf51bdda9453e2093  gdb/testsuite/gdb.cp/namespace.exp
-f0bd21bcfb9662618edcf3ed713bf714  gdb/testsuite/gdb.cp/namespace1.cc
-0a0023c3a8cf474ec7e85481879828d0  gdb/testsuite/gdb.cp/overload.cc
-8e9dc997ef15545d7c727bfb87c32317  gdb/testsuite/gdb.cp/overload.exp
-1e6ecfe65de278a0c1e062badc9789e3  gdb/testsuite/gdb.cp/ovldbreak.cc
-0af5c7a9dce509758e10b247620d20e5  gdb/testsuite/gdb.cp/ovldbreak.exp
-2bd8d00029e40e0a5ff2da40bb266619  gdb/testsuite/gdb.cp/pass-by-ref.cc
-c06a6d74ff73178fcf5a429c3fdf95e2  gdb/testsuite/gdb.cp/pass-by-ref.exp
-0a15a0bc517ee0acca862308c89de14b  gdb/testsuite/gdb.cp/pr-1023.cc
-184a21eb3af964f39787815b394a345d  gdb/testsuite/gdb.cp/pr-1023.exp
-07fa7f618722031893284e4df11fe13e  gdb/testsuite/gdb.cp/pr-1210.cc
-7cc8e143ed4b7b71559d797b17afbf31  gdb/testsuite/gdb.cp/pr-1210.exp
-2ed9da8d60682552fe1a64864fc1bc98  gdb/testsuite/gdb.cp/pr-574.cc
-fc1ea10528191c06254f7041d71fa762  gdb/testsuite/gdb.cp/pr-574.exp
-e660a8349fa4da9fa455aa6a5d53a7ed  gdb/testsuite/gdb.cp/printmethod.cc
-1a39696715353c81c62b6ccedb9ce1e3  gdb/testsuite/gdb.cp/printmethod.exp
-bcd2f08fcb50e026ac66d86d6fbaa91f  gdb/testsuite/gdb.cp/psmang.exp
-703f2ed56fd3ad3a2723400f5aef4350  gdb/testsuite/gdb.cp/psmang1.cc
-ad9c42c1f3bc7e19a391893b12660dbd  gdb/testsuite/gdb.cp/psmang2.cc
-3ab85f2c480c3a7447620bd55f7f7823  gdb/testsuite/gdb.cp/ref-params.cc
-fa93326d83170047926878bb6c93d856  gdb/testsuite/gdb.cp/ref-params.exp
-f33fb9aa407795fc3b80e0a9251d28b2  gdb/testsuite/gdb.cp/ref-types.cc
-92b49a093d32e290dd42ab4d225c57d2  gdb/testsuite/gdb.cp/ref-types.exp
-fff72ee61f805b75c3d892859871f3b3  gdb/testsuite/gdb.cp/rtti.exp
-da7e76e6255a34e14c48e19d95e0eca0  gdb/testsuite/gdb.cp/rtti.h
-2dfbc2befea5442834b19b4dcf09e0d7  gdb/testsuite/gdb.cp/rtti1.cc
-830ad6cb59a824d180a40901d6743abf  gdb/testsuite/gdb.cp/rtti2.cc
-1536cc5f65a058b4d13dfcd79fbd8619  gdb/testsuite/gdb.cp/templates.cc
-c88e5fad0c75f7f204b100a5494caecd  gdb/testsuite/gdb.cp/templates.exp
-39f4ad8177dd3fcc48a36c0093e56708  gdb/testsuite/gdb.cp/try_catch.cc
-4061c222a2b9d9280ae11995838b0986  gdb/testsuite/gdb.cp/try_catch.exp
-cb62ae614660f593110f13eb03a53c92  gdb/testsuite/gdb.cp/userdef.cc
-21b80df4fda06876c32dc80860fa8c38  gdb/testsuite/gdb.cp/userdef.exp
-d793909ea323b69888259173f9f245fb  gdb/testsuite/gdb.cp/virtfunc.cc
-fd8982d0df1c0fdcd6cf14cbfe0234a1  gdb/testsuite/gdb.cp/virtfunc.exp
-7223f89fe13042a716303a40db766767  gdb/testsuite/gdb.disasm/Makefile.in
-3832be44cf5eea738550c29104071f30  gdb/testsuite/gdb.disasm/am33.exp
-9d7ec73ab52e55ec1f83ec9e35523702  gdb/testsuite/gdb.disasm/am33.s
-896f8ae849ab19e4bd155c6125b59e91  gdb/testsuite/gdb.disasm/h8300s.exp
-cb76fc798d647b1ee8ba82f8ad9a5584  gdb/testsuite/gdb.disasm/h8300s.s
-e40e4f751b91ff047e8e506b612ec9b3  gdb/testsuite/gdb.disasm/hppa.exp
-1531e9f2d8c5fe8c476a72c8621ac6f5  gdb/testsuite/gdb.disasm/hppa.s
-8df48a7abc7ba3009ba5f49d74d3c8f9  gdb/testsuite/gdb.disasm/mn10200.s
-ec7641f83b598ceb27ac7e841a0a81a3  gdb/testsuite/gdb.disasm/mn10300.exp
-e02ce2008b0f7cd2c4bd231e78d46c8c  gdb/testsuite/gdb.disasm/mn10300.s
-ec758787bd556e185b6fcb7a27030d19  gdb/testsuite/gdb.disasm/sh3.exp
-e546b5aa7eb88708555537439de19900  gdb/testsuite/gdb.disasm/sh3.s
-7455e8e3a7c82ed281905fcc0ad05018  gdb/testsuite/gdb.disasm/t01_mov.exp
-b0c212de85c1acb1e14a705f4e40a6e9  gdb/testsuite/gdb.disasm/t01_mov.s
-ebcf6342c0318d16232d83640e7bbcb6  gdb/testsuite/gdb.disasm/t02_mova.exp
-fa6a2c9c9ae47e840be659d01a4750d8  gdb/testsuite/gdb.disasm/t02_mova.s
-51e8e8c3cbae2bbeaf3ad844430b6abc  gdb/testsuite/gdb.disasm/t03_add.exp
-d20f8c266b73f0682f9b33a40641f923  gdb/testsuite/gdb.disasm/t03_add.s
-fe6308e074be019d828f9bfb98a70d17  gdb/testsuite/gdb.disasm/t04_sub.exp
-70b15852295559a37b00c60d55167563  gdb/testsuite/gdb.disasm/t04_sub.s
-e8903151fbf81577c02dbdc03696eeab  gdb/testsuite/gdb.disasm/t05_cmp.exp
-13d33a0e2d93ee9c30330c55b1f370d1  gdb/testsuite/gdb.disasm/t05_cmp.s
-279730f00fc4895d58a9190373e9a174  gdb/testsuite/gdb.disasm/t06_ari2.exp
-9f2e1d0972a5fdf62643f281a80de560  gdb/testsuite/gdb.disasm/t06_ari2.s
-d1590c2e76effbe699b21832afec437e  gdb/testsuite/gdb.disasm/t07_ari3.exp
-c02c125e2e5010129e46e393e2cdef81  gdb/testsuite/gdb.disasm/t07_ari3.s
-0bc5abff19b7f241ee2200b7892d5075  gdb/testsuite/gdb.disasm/t08_or.exp
-dbbb53f76688f2006bfe0b9c14fd4241  gdb/testsuite/gdb.disasm/t08_or.s
-49cd76e1a42900429a50f58209e043bc  gdb/testsuite/gdb.disasm/t09_xor.exp
-82c2e284f051cc293b39b6ce0741aa89  gdb/testsuite/gdb.disasm/t09_xor.s
-896e7ca5c5d065de0ee4a04f026e28bf  gdb/testsuite/gdb.disasm/t10_and.exp
-a640da1752a98c70b4dae81fd6dc759b  gdb/testsuite/gdb.disasm/t10_and.s
-edf2aa4b831cc9dbeffc251da5e8dc5f  gdb/testsuite/gdb.disasm/t11_logs.exp
-e14e8cc3e96d350310aaac726d4ea5e3  gdb/testsuite/gdb.disasm/t11_logs.s
-747d1fdebc7b3462b3f8e934795865d1  gdb/testsuite/gdb.disasm/t12_bit.exp
-a36c2e9f8bf7f9d788db20927e18e921  gdb/testsuite/gdb.disasm/t12_bit.s
-c3caa54133fe80f85ede55a07c1e6fa6  gdb/testsuite/gdb.disasm/t13_otr.exp
-ec9241c34e56cabb8f4eadadad6c69d3  gdb/testsuite/gdb.disasm/t13_otr.s
-4b340aa2b6e2149ee0b7357f501ccec2  gdb/testsuite/gdb.dwarf2/Makefile.in
-2d793a4187b79664be45013d5acd218f  gdb/testsuite/gdb.dwarf2/dup-psym.S
-bc3fe7c9d94272bd3a41109d5d896c53  gdb/testsuite/gdb.dwarf2/dup-psym.exp
-af2eb3da014f524385bf82d59f3d0f83  gdb/testsuite/gdb.dwarf2/dw2-basic.S
-4c3b2d283ddda6e7d0847529fdcc0160  gdb/testsuite/gdb.dwarf2/dw2-basic.exp
-65912e4163bb43a1cfb8328df16019a5  gdb/testsuite/gdb.dwarf2/dw2-intercu.S
-e48c951210a887ceabd742a01323ea49  gdb/testsuite/gdb.dwarf2/dw2-intercu.exp
-47bcd1f27021625134942e5ba6e14ff7  gdb/testsuite/gdb.dwarf2/dw2-intermix.S
-dde2e25f635396f9d8b78825a8239d6d  gdb/testsuite/gdb.dwarf2/dw2-intermix.exp
-c7da0d8245d258c95c975e57f39614c6  gdb/testsuite/gdb.dwarf2/dw2-noloc.S
-6cab147b86e9af02a92cf50c5a910cd0  gdb/testsuite/gdb.dwarf2/dw2-noloc.exp
-9d2d01ec62ac43082c9d7d64f151c8c1  gdb/testsuite/gdb.dwarf2/dw2-producer.S
-1b8459f31031ac83617e690cf8caae93  gdb/testsuite/gdb.dwarf2/dw2-producer.exp
-ed8c87022a3d7bca5c227975aa1e1a11  gdb/testsuite/gdb.dwarf2/dw2-ranges.S
-db38e34103f2ad2dd34a4249188e0a20  gdb/testsuite/gdb.dwarf2/dw2-ranges.exp
-54b8a6b0ff52958ee33024c56b9bd2bd  gdb/testsuite/gdb.dwarf2/file1.txt
-19a20a2bedef21d1eba4b27123d1aeaf  gdb/testsuite/gdb.dwarf2/mac-fileno.S
-c599e8fdde97dcfe03b631f7c8dd81f0  gdb/testsuite/gdb.dwarf2/mac-fileno.exp
-5d4af51091eaa6580907565fd25d20fd  gdb/testsuite/gdb.dwarf2/main.c
-4df8e706c406a8ebf6474d46e39d1e19  gdb/testsuite/gdb.fortran/Makefile.in
-14ea1c0b89adaf313ee2d7126f955a6f  gdb/testsuite/gdb.fortran/array-element.exp
-9c5518605e7b96e722600e308982d3b5  gdb/testsuite/gdb.fortran/array-element.f
-35bb7c766ab95739d9cfbfe2a2dec4ba  gdb/testsuite/gdb.fortran/complex.exp
-364cf986081ed00f9474e4ad10450eaa  gdb/testsuite/gdb.fortran/complex.f
-ad03e7feab26221169050869c8c8eb40  gdb/testsuite/gdb.fortran/derived-type.exp
-1cb238beec0d5374c89a5b502fc3a33d  gdb/testsuite/gdb.fortran/derived-type.f90
-3d469aae26d042cf8077766a4c9c4da2  gdb/testsuite/gdb.fortran/exprs.exp
-2c4eb0f46cd2d94c11528760e535ecfc  gdb/testsuite/gdb.fortran/subarray.exp
-f6eaaebdc4d5f60187bc7b6365cc406f  gdb/testsuite/gdb.fortran/subarray.f
-b3480122ff3a5d6780beaacea9911466  gdb/testsuite/gdb.fortran/types.exp
-c316b5dd42521b1ceb90daacbe344e87  gdb/testsuite/gdb.gdb/complaints.exp
-34de2ec56d19cf68fb5b0fd2fef9bb10  gdb/testsuite/gdb.gdb/observer.exp
-e3324a410b546dc22de17d649ebe5d15  gdb/testsuite/gdb.gdb/selftest.exp
-5bf4ed552eae7579f8c4b404915bdf13  gdb/testsuite/gdb.gdb/xfullpath.exp
-a904198187ddbad3444244c4ac4352cd  gdb/testsuite/gdb.hp/Makefile.in
-7df18f0036be5552765a4ec8cd754019  gdb/testsuite/gdb.hp/configure
-db7812fc627ffc0529c669971e23edbf  gdb/testsuite/gdb.hp/configure.ac
-5ea7cc25704c6afa026b129b8211748b  gdb/testsuite/gdb.hp/gdb.aCC/Makefile.in
-8316679ea8ec2609000ab39969b0ef18  gdb/testsuite/gdb.hp/gdb.aCC/configure
-14c81c0942509019918ae03360dec504  gdb/testsuite/gdb.hp/gdb.aCC/configure.ac
-d90a4eb75820358b20683ede58be9c56  gdb/testsuite/gdb.hp/gdb.aCC/exception.exp
-cc53bf59d2a9c47d276d1aac84bd0f50  gdb/testsuite/gdb.hp/gdb.aCC/optimize.c
-0576593cd9340d727a2f294c4956f68c  gdb/testsuite/gdb.hp/gdb.aCC/optimize.exp
-2fefc4288b99b3e947ca1e21a82fc5ce  gdb/testsuite/gdb.hp/gdb.aCC/run.c
-fe81b471e8b5a8c2b608abaec6cd421b  gdb/testsuite/gdb.hp/gdb.aCC/watch-cmd.exp
-8428aa0ac90cc1baaec1f80269b59295  gdb/testsuite/gdb.hp/gdb.base-hp/Makefile.in
-14c754799fcbf620f6a249cbc446e003  gdb/testsuite/gdb.hp/gdb.base-hp/callfwmall.c
-e4590296e90f7780d99c3908b0b48db5  gdb/testsuite/gdb.hp/gdb.base-hp/callfwmall.exp
-dee90d7b6210218f00b95db323d19d74  gdb/testsuite/gdb.hp/gdb.base-hp/configure
-b647d1a5f57f36905c409baf687f79ea  gdb/testsuite/gdb.hp/gdb.base-hp/configure.ac
-aa06298d5aa3e73236eb27c425fa4846  gdb/testsuite/gdb.hp/gdb.base-hp/dollar.c
-bea5d8600b5cd113487aa45d1f7ae4bf  gdb/testsuite/gdb.hp/gdb.base-hp/dollar.exp
-d26b78129f6ede5217efccfb06f9d80d  gdb/testsuite/gdb.hp/gdb.base-hp/genso-thresh.c
-54e77a9296dcc133c8c1e6f11ca3b9e2  gdb/testsuite/gdb.hp/gdb.base-hp/hwwatchbus.c
-edb914aecae3838577e04a77a4ab8c73  gdb/testsuite/gdb.hp/gdb.base-hp/hwwatchbus.exp
-3dea1b9bc2e3aed256501550bf68d4cb  gdb/testsuite/gdb.hp/gdb.base-hp/pxdb.c
-1880a5e92edb3eb8f852233530ffa948  gdb/testsuite/gdb.hp/gdb.base-hp/pxdb.exp
-df78ac51dfaa269e2462e7e21f3e6218  gdb/testsuite/gdb.hp/gdb.base-hp/reg-pa64.exp
-905458dab9cfbee0df58ed9240e14af1  gdb/testsuite/gdb.hp/gdb.base-hp/reg-pa64.s
-53024fa9dbc5cc59ab44c82b780e6d9f  gdb/testsuite/gdb.hp/gdb.base-hp/reg.exp
-dead9d35aee1ff308fe3522dabedc3b8  gdb/testsuite/gdb.hp/gdb.base-hp/reg.s
-465f43278cc7d0e79520ac7cd4420a02  gdb/testsuite/gdb.hp/gdb.base-hp/sized-enum.c
-e742d59a44e2bd7f7cfc9be0de4a72a1  gdb/testsuite/gdb.hp/gdb.base-hp/sized-enum.exp
-c15be63beeee7dafdb5b735d15c7d1ed  gdb/testsuite/gdb.hp/gdb.base-hp/so-thresh.exp
-826cb85910a25693b5ec8940b9f17f02  gdb/testsuite/gdb.hp/gdb.base-hp/so-thresh.mk
-484344e9489d51e698048e6a91576363  gdb/testsuite/gdb.hp/gdb.base-hp/so-thresh.sh
-f3b9253b314a12126d1438b64f607792  gdb/testsuite/gdb.hp/gdb.compat/Makefile.in
-00f1943eda306eea1225aa67d0716842  gdb/testsuite/gdb.hp/gdb.compat/average.c
-304ba78964726622bfd754bea74a8566  gdb/testsuite/gdb.hp/gdb.compat/configure
-70f808f7da32512ca84493f5b480522e  gdb/testsuite/gdb.hp/gdb.compat/configure.ac
-efdc8ddc5dba749425497347498fc5ab  gdb/testsuite/gdb.hp/gdb.compat/sum.c
-fbf537e72ce89db0e107c27b0339b49b  gdb/testsuite/gdb.hp/gdb.compat/xdb.c
-1d6255c634ec5650bf05e168820e52d6  gdb/testsuite/gdb.hp/gdb.compat/xdb0.c
-87882e6b6268aeb4258a5d999f17c0fe  gdb/testsuite/gdb.hp/gdb.compat/xdb0.h
-943ae15521dca9cb0098128efc3b280a  gdb/testsuite/gdb.hp/gdb.compat/xdb1.c
-2c1895ff8cf408060a57ab8b52223ba2  gdb/testsuite/gdb.hp/gdb.compat/xdb1.exp
-6ace5b55735d76b32ef9c52d439bf4f6  gdb/testsuite/gdb.hp/gdb.compat/xdb2.exp
-c7962027e6adc3b045ee7420d802d3ad  gdb/testsuite/gdb.hp/gdb.compat/xdb3.exp
-9710952c98dc8eeefe0b4a1bd211af04  gdb/testsuite/gdb.hp/gdb.defects/Makefile.in
-db822d6cd121c4db2c5386f1b18327d3  gdb/testsuite/gdb.hp/gdb.defects/bs14602.c
-bd2e0786113e62b5acc6ad6291a76f34  gdb/testsuite/gdb.hp/gdb.defects/bs14602.exp
-b89a38ff039e1a6cda633dd6ed78a00c  gdb/testsuite/gdb.hp/gdb.defects/configure
-ac252b8def00c5d064bc082d0c4764b5  gdb/testsuite/gdb.hp/gdb.defects/configure.ac
-408c16c2ba0801d824d0c16563aa93a6  gdb/testsuite/gdb.hp/gdb.defects/solib-d.c
-ee60870935b9618eb6d7e3d6b9a6aa48  gdb/testsuite/gdb.hp/gdb.defects/solib-d.exp
-2c0a2c964be9bd822394d4c27d94351f  gdb/testsuite/gdb.hp/gdb.defects/solib-d1.c
-03f1b83c4f54667b4f0078457b15a52f  gdb/testsuite/gdb.hp/gdb.defects/solib-d2.c
-fe1cbe605feca5f78a08210252dfed66  gdb/testsuite/gdb.hp/gdb.objdbg/Makefile.in
-1cb5074223dd79d318e5b54e0c564809  gdb/testsuite/gdb.hp/gdb.objdbg/configure
-03369e00bee923b2441aeda2da58dded  gdb/testsuite/gdb.hp/gdb.objdbg/configure.ac
-ca52df3afa039a549a88b19060802c4f  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg01.exp
-dd0a17c68eb2f7cdf7451933c41d3693  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg02.exp
-6722a7e0e6bed1da32e7dc8dd3734325  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg03.exp
-d3ca892fcdeb9c029324f75e6f36ac7c  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg04.exp
-c12f8a440f9d7eab2053d5fb263d654f  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg01/x1.cc
-64a248fedafc6f5f792d6092a904faaa  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg01/x2.cc
-dfae478e1d95497e262872ee20047863  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg01/x3.cc
-a9b4b350ab56451624e9364e1e2b6738  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg01/x3.h
-930c3959f1e04319936c5a861682c7d6  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg02/x1.cc
-afaf2237a24a13e7d47ff8dc5358bd2d  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg02/x2.cc
-1ac202c7c27f08ce5de62831fe6230fe  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg02/x3.cc
-54bba4286fdf72276ee52dba78eeb61e  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg03/x1.cc
-b93935b37dba86bc6c49acaae960efa9  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg03/x2.cc
-ab81c17425f162902b2593b2af2965bc  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg03/x3.cc
-146898361af7f03a16dfcc18ace2a23f  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg04/x.h
-48806746c4205bdf0d050b7c3a32210b  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg04/x1.cc
-76af0d0b7dd89e3eb8fdd7dd10334d59  gdb/testsuite/gdb.hp/gdb.objdbg/objdbg04/x2.cc
-37540d440cd0e9f5280d7123f3f963ed  gdb/testsuite/gdb.hp/gdb.objdbg/tools/symaddr
-4f3c4e1c924d553e18775df711389e81  gdb/testsuite/gdb.hp/gdb.objdbg/tools/symaddr.pa64
-d1035b543709f23158df094b6d49742b  gdb/testsuite/gdb.hp/gdb.objdbg/tools/test-objdbg.cc
-8e84c7c14c0bfef46c0aa768c32904bf  gdb/testsuite/gdb.hp/tools/odump
-ef06d8cfb625aa9c73eff51184bb10fd  gdb/testsuite/gdb.java/Makefile.in
-31d269a14cb4ea9e36c3cf2f69fb1906  gdb/testsuite/gdb.java/jmain.exp
-030f9fc25e9acc988163f24817c83ee9  gdb/testsuite/gdb.java/jmain.java
-c71e7ed59890c58145a8bfe0c0211506  gdb/testsuite/gdb.java/jmisc.exp
-e3a680cfde66129ed9607ad7c20fd6a0  gdb/testsuite/gdb.java/jmisc.java
-f4ba699b8faab9c58509da0066394d57  gdb/testsuite/gdb.java/jprint.exp
-e6955dcea272f29ee3065a79b59ec294  gdb/testsuite/gdb.java/jprint.java
-bb1b61e184dce1fb6f91cdb79f9accca  gdb/testsuite/gdb.java/jv-exp.exp
-f93e90ca86a8fdfebd1fa8853a847c7d  gdb/testsuite/gdb.java/jv-print.exp
-1efe6f6402cbf322cd8aa810521f4b17  gdb/testsuite/gdb.mi/ChangeLog-1999-2003
-a137c3c02589a00e9ec245499b6da025  gdb/testsuite/gdb.mi/Makefile.in
-9f2268bf2d4ae03cc2eda7d4a8332a33  gdb/testsuite/gdb.mi/array.f
-1fe70acff197a0e19cfea3390c5e0854  gdb/testsuite/gdb.mi/basics.c
-422907163cd2231375ef39db3b441cff  gdb/testsuite/gdb.mi/gdb669.exp
-a480d1908f6392d3c8b2b402c02ec931  gdb/testsuite/gdb.mi/gdb680.exp
-bbff496566f190853c0830bf572d6d95  gdb/testsuite/gdb.mi/gdb701.c
-a658c9196b6e5bba2acef933f1fd1235  gdb/testsuite/gdb.mi/gdb701.exp
-a57794f9629bee4dc7f3868362e8d4ff  gdb/testsuite/gdb.mi/gdb792.cc
-94eacd7e873c9e61ab2669866f4e6ddb  gdb/testsuite/gdb.mi/gdb792.exp
-1ec47e8b8ee0fea6f73fe24acd211e66  gdb/testsuite/gdb.mi/mi-basics.exp
-df22e776f540619e8f1bce4cc0dbc1f6  gdb/testsuite/gdb.mi/mi-break.exp
-aefabafe57bf26d1a7917a6ddb1fb741  gdb/testsuite/gdb.mi/mi-cli.exp
-2748c57b9ccc6f5d68d793f547c07d42  gdb/testsuite/gdb.mi/mi-console.c
-227b7a21094b3fa381090145ae859904  gdb/testsuite/gdb.mi/mi-console.exp
-23537935f1bce16d1d7e835943bb18f5  gdb/testsuite/gdb.mi/mi-disassemble.exp
-a55daeec1f0615bb3f0b25aba2909a05  gdb/testsuite/gdb.mi/mi-eval.exp
-7d6bdb390fc10f11079ac5cbb10d14d7  gdb/testsuite/gdb.mi/mi-file-transfer.exp
-d4db47ea0ad65cd491e4621f5ac0f4b7  gdb/testsuite/gdb.mi/mi-file.exp
-ae1ceb6c0b5a1b08c6a988f54625e7f7  gdb/testsuite/gdb.mi/mi-hack-cli.exp
-fbff6aa5cb33f7005afd7fe2ab7d81cd  gdb/testsuite/gdb.mi/mi-pending.c
-563cd8531b454371a4e71a8b2b0dafe7  gdb/testsuite/gdb.mi/mi-pending.exp
-512a8a7401ae2fc4ecf7f4b1df9d5c59  gdb/testsuite/gdb.mi/mi-pendshr.c
-8758d38de5efe99ab8b4f813196b6991  gdb/testsuite/gdb.mi/mi-pthreads.exp
-d842f3134dbac91b77ca50d320988178  gdb/testsuite/gdb.mi/mi-read-memory.c
-cee05bd0be59ae5345c43fc18fc9829c  gdb/testsuite/gdb.mi/mi-read-memory.exp
-58c7d177d757e1ebaef33681ef8943c5  gdb/testsuite/gdb.mi/mi-regs.exp
-693c2d1fcba1b665aa557079514572fc  gdb/testsuite/gdb.mi/mi-return.exp
-84fec3cb2427fb35221ef721aae6fe04  gdb/testsuite/gdb.mi/mi-simplerun.exp
-08a1bac7db7e7f87da0b0e58b285d4bd  gdb/testsuite/gdb.mi/mi-stack.c
-80d604e85273d7b0c27ea08939742109  gdb/testsuite/gdb.mi/mi-stack.exp
-84eebf576c80e124cdd61b438d4d410e  gdb/testsuite/gdb.mi/mi-stepi.exp
-1565f94ed6c8335f69603a1f258ab010  gdb/testsuite/gdb.mi/mi-syn-frame.c
-5c2a61b673f2cc99f0b3a7726fccfa68  gdb/testsuite/gdb.mi/mi-syn-frame.exp
-2211832e85fb292eb8d1276119a0caa9  gdb/testsuite/gdb.mi/mi-until.exp
-410cfd6246cec55d8f9c03da426cecd3  gdb/testsuite/gdb.mi/mi-var-block.exp
-0ef20ddc9463e42a35a8c5f177c46e7e  gdb/testsuite/gdb.mi/mi-var-child-f.exp
-ccc1f9ae9cc7b16438feee80cd3a996d  gdb/testsuite/gdb.mi/mi-var-child.c
-3f1c13dd6c6110b4653498f89078fb46  gdb/testsuite/gdb.mi/mi-var-child.exp
-94952751f51273e810a3ff6e0275946f  gdb/testsuite/gdb.mi/mi-var-cmd.exp
-1c4eadc1c2c49e60736e08d8ef70fe50  gdb/testsuite/gdb.mi/mi-var-cp.cc
-a74e4b33b25b187ecb528d8ed362514d  gdb/testsuite/gdb.mi/mi-var-cp.exp
-f77a184f59dd8a2f5e81bef1a8c95616  gdb/testsuite/gdb.mi/mi-var-display.exp
-da1a79020fffc08809bdf2b9ea4597c5  gdb/testsuite/gdb.mi/mi-var-invalidate.exp
-3a273a9124525a0fc2ac1675bced3636  gdb/testsuite/gdb.mi/mi-watch.exp
-c9af88c3bfa6d170058b78e4d49d2c6e  gdb/testsuite/gdb.mi/mi2-basics.exp
-b263fb45fc17bfaa9fbe448584776f4c  gdb/testsuite/gdb.mi/mi2-break.exp
-c0d9d44a77c866629052a6fc0e63313c  gdb/testsuite/gdb.mi/mi2-cli.exp
-fb2fee5d420ecbaae094178795bbaa01  gdb/testsuite/gdb.mi/mi2-console.exp
-19aabc0d12dd2c7e19d5311e7fa95852  gdb/testsuite/gdb.mi/mi2-disassemble.exp
-db7c331d1bbfa4f5d09ebbe6b5ed2e0b  gdb/testsuite/gdb.mi/mi2-eval.exp
-20db44a4e7253e7f3334bb63b6c1075c  gdb/testsuite/gdb.mi/mi2-file.exp
-641b0f7a347b263e197024e70913e1dc  gdb/testsuite/gdb.mi/mi2-hack-cli.exp
-1a401192c7d6b2c31bd3c286d53c8cdd  gdb/testsuite/gdb.mi/mi2-pthreads.exp
-4de938725322259a2e0246a4b4273070  gdb/testsuite/gdb.mi/mi2-read-memory.exp
-a3e4df0db816bd23c716f1a4e2662de4  gdb/testsuite/gdb.mi/mi2-regs.exp
-ff34a5202868ba4eb256b257ab2ac6f0  gdb/testsuite/gdb.mi/mi2-return.exp
-33db06c28be45ef04bd7e3440ec16aca  gdb/testsuite/gdb.mi/mi2-simplerun.exp
-9e53eb2400bdc2a5b8034602e89638fe  gdb/testsuite/gdb.mi/mi2-stack.exp
-3879e31c5f53f7a70000c50923c994a3  gdb/testsuite/gdb.mi/mi2-stepi.exp
-d46edba7adcf2f5223846fb0a5a7d074  gdb/testsuite/gdb.mi/mi2-syn-frame.exp
-253f011383c1eda1bcaa72c93d143eb7  gdb/testsuite/gdb.mi/mi2-until.exp
-58c71ca1ca5309da53ca8fe0bc625503  gdb/testsuite/gdb.mi/mi2-var-block.exp
-d62d7f44ddc73eb9792f5574a7928a43  gdb/testsuite/gdb.mi/mi2-var-child.exp
-c82cf4cd53b9347093bae92566b54ff6  gdb/testsuite/gdb.mi/mi2-var-cmd.exp
-b137523dfc9555c6f2d3ad009f98f32d  gdb/testsuite/gdb.mi/mi2-var-display.exp
-34f6b4cd93e7fd8eca484da3af4f13a3  gdb/testsuite/gdb.mi/mi2-watch.exp
-ad528e624df73da11eca7040538406c9  gdb/testsuite/gdb.mi/pthreads.c
-6b58acbe5f1fe573c27b67f2e2a2fee1  gdb/testsuite/gdb.mi/testcmds
-e69d1583b75cdf649449a0263d46822f  gdb/testsuite/gdb.mi/until.c
-43d9604ef46ea7a6572417148f0edb4f  gdb/testsuite/gdb.mi/var-cmd.c
-cb59d0ae8684cbe2702deeed75399d2e  gdb/testsuite/gdb.modula2/Makefile.in
-9e54f84b00a59aec2cbbe535eb75f79b  gdb/testsuite/gdb.modula2/unbounded-array.exp
-74c7f97ee8cba49d3fcd242d5bb0321f  gdb/testsuite/gdb.modula2/unbounded1.c
-36e97171745197c81e50560f5eaf680b  gdb/testsuite/gdb.modula2/Makefile
-2985193fddc2986e50caa3b7b1d62063  gdb/testsuite/gdb.objc/Makefile.in
-c97727665b8b3293f09d80f3d41716de  gdb/testsuite/gdb.objc/basicclass.exp
-f0f471d0b077ed32873ec23acd184ae2  gdb/testsuite/gdb.objc/basicclass.m
-27c952b162a764c756b1a48cc3b368a3  gdb/testsuite/gdb.objc/nondebug.exp
-680e14fd32f14cd93c56886bcb05f177  gdb/testsuite/gdb.objc/nondebug.m
-c12e14fb57086b798b995993fea7efcf  gdb/testsuite/gdb.objc/objcdecode.exp
-5bf9075727dbd558ccbf123d9e11859a  gdb/testsuite/gdb.objc/objcdecode.m
-d1d292e2b1b9141cc688d607b683a976  gdb/testsuite/gdb.opt/Makefile.in
-80b294a889d993540e08b4a3e8f63d81  gdb/testsuite/gdb.opt/clobbered-registers-O2.c
-ce6406ed87a97d96fea04945bd881134  gdb/testsuite/gdb.opt/clobbered-registers-O2.exp
-241dd7864b174dcfde2c9e0d56adae12  gdb/testsuite/gdb.opt/Makefile
-aaf57ca27cf0e8e9df8e1cd9cf3643a6  gdb/testsuite/gdb.pascal/Makefile.in
-856f2989472cdaaff066064348a7a942  gdb/testsuite/gdb.pascal/floats.exp
-cf364cdb117ac7ad0a10d5a8aa839747  gdb/testsuite/gdb.pascal/floats.pas
-cbfa5f6aeb396cc2281f6ebba8b816a7  gdb/testsuite/gdb.pascal/hello.exp
-19990cb5b198325b185af673b5ee5b4f  gdb/testsuite/gdb.pascal/hello.pas
-2779dca8190af2c30d2afb8d16bf1b2c  gdb/testsuite/gdb.pascal/integers.exp
-2d6f84a97b412cc55aa6ea9e9aaf9ccc  gdb/testsuite/gdb.pascal/integers.pas
-ff49e541208f6ecb807573018bb2b790  gdb/testsuite/gdb.pascal/types.exp
-5e4f9f960a2335840d6e0b256b030cec  gdb/testsuite/gdb.server/Makefile.in
-054528a0e5c3da178c625dc7aabe027a  gdb/testsuite/gdb.server/ext-attach.c
-598a7e0598d4ce5b1ef5068373859d31  gdb/testsuite/gdb.server/ext-attach.exp
-fcf9bd15c5e9051bb685d448f448184e  gdb/testsuite/gdb.server/ext-run.exp
-4e8e6b2a221aa6111c9e174f7286125d  gdb/testsuite/gdb.server/file-transfer.exp
-524a5cee9fcc7d5b97cd9051c8dad8d2  gdb/testsuite/gdb.server/server-mon.exp
-45124aa72e7b6c930822e8708f6827ff  gdb/testsuite/gdb.server/server-run.exp
-f6dc3d3433501f3417c8fe807588e7ce  gdb/testsuite/gdb.server/server.c
-b83c8391da68f1e641f679bf1eed5690  gdb/testsuite/gdb.server/transfer.txt
-e5ec493e3f6d7fe09f728ab9bacb4028  gdb/testsuite/gdb.stabs/Makefile.in
-85d0360ff6db4270acb85d73092c7de9  gdb/testsuite/gdb.stabs/aout.sed
-de510e510518d3b9e9f3ef8ffcbd8003  gdb/testsuite/gdb.stabs/configure
-f403d094532df23c7e1d536415698b78  gdb/testsuite/gdb.stabs/configure.ac
-6fb5c366d78fe2c47f31555c035ddcb3  gdb/testsuite/gdb.stabs/ecoff.sed
-41732304546f9f1c046f74b60eb3d56c  gdb/testsuite/gdb.stabs/exclfwd.exp
-67986cef83e2baf6b23c4d3c1e27c292  gdb/testsuite/gdb.stabs/exclfwd.h
-586704ec1a303c4e2824f8f223b1eabb  gdb/testsuite/gdb.stabs/exclfwd1.c
-88b719db7a8c3d232e42f1eb13f16dd1  gdb/testsuite/gdb.stabs/exclfwd2.c
-c616dc41c0e3352e3100cec80c2bab68  gdb/testsuite/gdb.stabs/hppa.sed
-2fee77e25d05036cb6fa5a7b28cb6f5e  gdb/testsuite/gdb.stabs/weird.def
-530391420222fe0aee6d7f0dc84576a4  gdb/testsuite/gdb.stabs/weird.exp
-fc215bfd0d5b89f95282f2bd7f807c55  gdb/testsuite/gdb.stabs/xcoff.sed
-5673f18f6ae92e0b3a46e6be53e63362  gdb/testsuite/gdb.threads/Makefile.in
-e3cebd208d6f3f40e0e0c98da33328fc  gdb/testsuite/gdb.threads/bp_in_thread.c
-20108531e87229bf22fe6910cdd2f0f9  gdb/testsuite/gdb.threads/bp_in_thread.exp
-4b2bd5f904b2882393a51b186aaa444b  gdb/testsuite/gdb.threads/fork-child-threads.c
-6a897c4e75ff579d24eb86e6e81d85d9  gdb/testsuite/gdb.threads/fork-child-threads.exp
-5ec4b3c5392edc9c950fb389946ecafd  gdb/testsuite/gdb.threads/gcore-thread.exp
-2886d670382b87a19bceaee3c53ef58e  gdb/testsuite/gdb.threads/killed.c
-21ceaea2e8e3b422616d96ab5fcb37ea  gdb/testsuite/gdb.threads/killed.exp
-a60f402187882610e3160c4f6c4dd4b1  gdb/testsuite/gdb.threads/linux-dp.c
-d6818fb6f7f377b5431cb8831feda528  gdb/testsuite/gdb.threads/linux-dp.exp
-90cff188c7d52ce1ab01e389e8e542fb  gdb/testsuite/gdb.threads/manythreads.c
-819ec6d74d87d0cbdc435c6f6bb9ebaf  gdb/testsuite/gdb.threads/manythreads.exp
-874bab4d6c4f33e79411393925c15cc6  gdb/testsuite/gdb.threads/multi-create.c
-88d73b4265824d4f1c0d80e6a70152c2  gdb/testsuite/gdb.threads/multi-create.exp
-df82452f754ef15a81d71f46a0892757  gdb/testsuite/gdb.threads/print-threads.c
-d11bed626fc42f82725bf354ee87c7cf  gdb/testsuite/gdb.threads/print-threads.exp
-e3cebd208d6f3f40e0e0c98da33328fc  gdb/testsuite/gdb.threads/pthread_cond_wait.c
-ef9587ac04a4829a5ea7fb507416bd3f  gdb/testsuite/gdb.threads/pthread_cond_wait.exp
-9e1221f536f8f53304e0aa1d00ebe87f  gdb/testsuite/gdb.threads/pthreads.c
-1b97d56e9f882dfeeaeb00060cbe4e62  gdb/testsuite/gdb.threads/pthreads.exp
-e057d037ac034dcf9a45bfbe26f53533  gdb/testsuite/gdb.threads/schedlock.c
-da3822a0d0caedf616219e6d3747f3aa  gdb/testsuite/gdb.threads/schedlock.exp
-0b0761fb016e8bcdfefea3dcb870c6a4  gdb/testsuite/gdb.threads/sigthread.c
-c7dc4bd5b790adb0764c42d9a299b548  gdb/testsuite/gdb.threads/sigthread.exp
-624847f91ae0c0b09f68138d63b48ec1  gdb/testsuite/gdb.threads/staticthreads.c
-245e7788987bbe8af1ca5492b1bbdb94  gdb/testsuite/gdb.threads/staticthreads.exp
-6abe05b4e05fce5d6c228dd5ef8ec9cb  gdb/testsuite/gdb.threads/step.c
-d1d8e8702d274f7ba255061dcfa5456c  gdb/testsuite/gdb.threads/step.exp
-9ffd032c37878f3a743a67ffb3ed8199  gdb/testsuite/gdb.threads/step2.exp
-4df931add518c8d197280a88a939b538  gdb/testsuite/gdb.threads/switch-threads.c
-a2a90b4d0ed52a464eef36e78645a672  gdb/testsuite/gdb.threads/switch-threads.exp
-d52c42fa365c942de77bc68f2bfbc531  gdb/testsuite/gdb.threads/thread-specific.c
-fe020915361c8bfdf8707224a46bf43f  gdb/testsuite/gdb.threads/thread-specific.exp
-aba292608b60fd864523de7145b0e42a  gdb/testsuite/gdb.threads/thread_check.c
-9afc4b9a3491da23418c8ff203b35f6f  gdb/testsuite/gdb.threads/thread_check.exp
-deaa0f807b7ee78720c3b5a34dca1d41  gdb/testsuite/gdb.threads/thread_events.c
-f972be157062be24ba7bd94d769fa501  gdb/testsuite/gdb.threads/thread_events.exp
-bb3705c44bcdfc26baf70e8c5898c527  gdb/testsuite/gdb.threads/threadapply.c
-248f8bee9b7007d55c70294e3a8030c8  gdb/testsuite/gdb.threads/threadapply.exp
-0bc37c048361582d53f69d0700501c98  gdb/testsuite/gdb.threads/tls-main.c
-6bd939c206a5be543cda268e0851129b  gdb/testsuite/gdb.threads/tls-nodebug.c
-9e01959e19402180d2094007b3f4a38f  gdb/testsuite/gdb.threads/tls-nodebug.exp
-ca92dcd6537aed1d73f8b67fdf1f766a  gdb/testsuite/gdb.threads/tls-shared.c
-56bc14ae1d80b327aba38548ba0a08ce  gdb/testsuite/gdb.threads/tls-shared.exp
-c6fe7b489cd5c7c6944dbe27afdb0e3f  gdb/testsuite/gdb.threads/tls.c
-2472f947a2ae096d17e2de81c11bfc5a  gdb/testsuite/gdb.threads/tls.exp
-088148a3adaf30229526cfbcdfa6de59  gdb/testsuite/gdb.threads/watchthreads.c
-4890393c146d7a0c6ee58f0128c9e6fc  gdb/testsuite/gdb.threads/watchthreads.exp
-980f2448cee4484a705fe6a0d292d777  gdb/testsuite/gdb.trace/Makefile.in
-51f9a67e86dd3beecb45253c1322782a  gdb/testsuite/gdb.trace/actions.c
-86c6b9cdc8da2af1fab4c453d977ae96  gdb/testsuite/gdb.trace/actions.exp
-b3081b5ea94493c02f7d9db83c2751d8  gdb/testsuite/gdb.trace/backtrace.exp
-d2edd9bfb6b15369a5e3296908d0bf6d  gdb/testsuite/gdb.trace/circ.c
-31b508d11ec49885fba54dcd692d6a9d  gdb/testsuite/gdb.trace/circ.exp
-d22f8c48119d0a899e1e9d6e80f9c016  gdb/testsuite/gdb.trace/collection.c
-080a07897f71e7ee10dd3459499763b1  gdb/testsuite/gdb.trace/collection.exp
-71d62812046afb9d1935ea2764524632  gdb/testsuite/gdb.trace/deltrace.exp
-b5d2f0e0b4205415517bca254223e8c0  gdb/testsuite/gdb.trace/gdb_c_test.c
-aaa898bdf9adba4a0e50fb4016f88e12  gdb/testsuite/gdb.trace/infotrace.exp
-08512b1543a9be7aff8ac4bb4b0eaf6e  gdb/testsuite/gdb.trace/limits.c
-6ea6aca39327f027ba34e85933dd9e0f  gdb/testsuite/gdb.trace/limits.exp
-305c8889a98994b1153083ae77d5b00e  gdb/testsuite/gdb.trace/packetlen.exp
-50c5afa6379aaff5787075e47e69533d  gdb/testsuite/gdb.trace/passc-dyn.exp
-9faab61558062115bca6035b47695d23  gdb/testsuite/gdb.trace/passcount.exp
-24c18ffd071e85b6b5ac65b3e6fa83b6  gdb/testsuite/gdb.trace/report.exp
-da83edaefa19221974047f982b8e81e3  gdb/testsuite/gdb.trace/save-trace.exp
-10c4db99222bc7d76fddee262e3c7662  gdb/testsuite/gdb.trace/tfind.exp
-09bde51380fba39b6f7773257106250e  gdb/testsuite/gdb.trace/tracecmd.exp
-06518e5d8554455a6770c4b02330bc2b  gdb/testsuite/gdb.trace/while-dyn.exp
-3c9e5f8da9d76783a4f2a53738067fc3  gdb/testsuite/gdb.trace/while-stepping.exp
-77232051a3af26da3e11f8c71dd31f6e  gdb/testsuite/gdb.xml/Makefile.in
-4f6f7233919a7b5cbebb97e0d9b9fcf6  gdb/testsuite/gdb.xml/bad-include.xml
-6822163e38e7af33a0d81cdac6768ac9  gdb/testsuite/gdb.xml/core-only.xml
-3cdda2845c327c6189b0154d9bae1757  gdb/testsuite/gdb.xml/extra-regs.xml
-9bbc43406da2744f6c8a7c38b97bb02c  gdb/testsuite/gdb.xml/inc-2.xml
-db4894f09a7324b25de6b98a23383a5d  gdb/testsuite/gdb.xml/inc-body.xml
-b17141653a2a7f81010b78ba903cfdec  gdb/testsuite/gdb.xml/includes.xml
-4f957259a1af66b87b45b94b81dba00d  gdb/testsuite/gdb.xml/loop.xml
-8eb46c680c302af7d9de78ea3edb52fc  gdb/testsuite/gdb.xml/single-reg.xml
-c0deb64ef2df11de3e5bc43344df15d4  gdb/testsuite/gdb.xml/tdesc-arch.exp
-217bac7412f8837f007be696d457b70c  gdb/testsuite/gdb.xml/tdesc-bogus.xml
-256f978d5dd143fff5495099e98c7e82  gdb/testsuite/gdb.xml/tdesc-errors.exp
-a710010226af255ca8861be158364cd7  gdb/testsuite/gdb.xml/tdesc-regs.exp
-f8e7043a6ec28fe297b2ed7aacd0501b  gdb/testsuite/gdb.xml/tdesc-unknown.xml
-a6f8fa382f98350695eaefa00dca4f90  gdb/testsuite/gdb.xml/tdesc-xinclude.exp
-0762eff212b3c7e9fe3c7047b5f037d9  gdb/testsuite/gdb.xml/trivial.xml
-df93264946b800db751ec44cb6d5a5da  gdb/testsuite/lib/ada.exp
-939f65a17a9a40012a5d21eeae4ea292  gdb/testsuite/lib/compiler.c
-daeb8ee2417631736be23af5c1e4d08a  gdb/testsuite/lib/compiler.cc
-872d5490ccaa19c1b5aae22108b998ee  gdb/testsuite/lib/cp-support.exp
-48a27665f33817b43a3452988f80966a  gdb/testsuite/lib/emc-support.exp
-f249b5e35dda7c07bf1a3063a73f9c47  gdb/testsuite/lib/gdb.exp
-a6d8932f14d518793f383a5640ca01b1  gdb/testsuite/lib/gdbserver-support.exp
-839006bd97b7cbd8b0ef3378fd065d42  gdb/testsuite/lib/java.exp
-924f9c54720ee00422b039623474922b  gdb/testsuite/lib/mi-support.exp
-fbd8f34b30c3dae14bc2ec3d71c25fae  gdb/testsuite/lib/pascal.exp
-352ebd857b3c6aa1ab760d79e07e07be  gdb/testsuite/lib/trace-support.exp
-0415f3bd7a379430b752618c1e8c7cd4  gdb/tui/ChangeLog-1998-2003
-57b279d65f3cd9d557450c21a3478175  gdb/tui/tui-command.c
-87728477744ceb10b5e0d4c563453883  gdb/tui/tui-command.h
-1438325cd8403f0b863f7edfa7cff1d2  gdb/tui/tui-data.c
-8c3e55e989687de9c0d8480802941d65  gdb/tui/tui-data.h
-eec9299b26e80ba911e875ed0b853ee4  gdb/tui/tui-disasm.c
-eac21a7eff7960ee27038f90c9980393  gdb/tui/tui-disasm.h
-384e5017c780ce5e5d981717079a864b  gdb/tui/tui-file.c
-a02d0a67fe05578285a403f79be152ed  gdb/tui/tui-file.h
-faa435ef10ded602e519a910bdf3eb3d  gdb/tui/tui-hooks.c
-0df7044cf3db498041b3e292478299e9  gdb/tui/tui-hooks.h
-b3cf22fec7c0d530568efde22a895463  gdb/tui/tui-interp.c
-02277e7e824cd477e80e27c0653eaf72  gdb/tui/tui-io.c
-32543b1e1991e36ef509712e211e22ed  gdb/tui/tui-io.h
-dcf3f811e8ad7d07389b6164b647628b  gdb/tui/tui-layout.c
-1a119e79f2d41fb56e14fe9693e5a54b  gdb/tui/tui-layout.h
-77e140c998befe57717f29ee700ea9f5  gdb/tui/tui-main.c
-173dbaf27084c54b4721e5e8683da8a8  gdb/tui/tui-out.c
-afc0c9450c26720f8e3ff612460ab6f0  gdb/tui/tui-regs.c
-2eeb8404d153d8fe22c046c37737134d  gdb/tui/tui-regs.h
-89356a548cb064bff7bf1398f576e8a8  gdb/tui/tui-source.c
-920fad6d86bd5615ddfcec78f380d456  gdb/tui/tui-source.h
-e52dbe418625d9386143cb00bee5e8cd  gdb/tui/tui-stack.c
-1c73c70a0effc512110d14f558f077f2  gdb/tui/tui-stack.h
-74b1168ecd5ef8aa278987111762baea  gdb/tui/tui-win.c
-8e983f1383aa933b1a6a20a50f312f9a  gdb/tui/tui-win.h
-3f56dda3ec7718f6ed743f1dc7f4c16f  gdb/tui/tui-windata.c
-da7f25dbdaca3bc736a895b8f8213b1f  gdb/tui/tui-windata.h
-5418e185e31cd3d2cd6fb2a10592d7ca  gdb/tui/tui-wingeneral.c
-a4e53ba6fa194c74dacfe59f71bd6cd0  gdb/tui/tui-wingeneral.h
-d703f53c8bb94504cf071d5017213cb0  gdb/tui/tui-winsource.c
-28a81cd64fba6893ed859d2e52bb6051  gdb/tui/tui-winsource.h
-a39f78ecc2308cb6664967f2a7700ef9  gdb/tui/tui.c
-e43d0462594483d4e5677d7c557fbed6  gdb/tui/tui.h
-081f33bec096563ab57e82c4241d8358  gdb/objc-exp.c
-55fb93e33421448c7a0b3ed0ab7112f6  gdb/c-exp.c
-aa5eef050ee3129b0aa55dba59683ee5  gdb/ada-lex.c
-c6b022fe7fadae753b71c31ea122c737  gdb/cp-name-parser.c
-be3070e7086872059986385ebdb74a8b  gdb/ada-exp.c
-3e8c859efd7a23a866598e6fa35b5fe1  gdb/jv-exp.c
-c986e43338353efd83847aaeda6ebb36  gdb/f-exp.c
-233e554d13c0ed82756b2f555bae6eb0  gdb/m2-exp.c
-123cb8b0ca0c62263b8c8b70d285b3a4  gdb/p-exp.c
-59530bdf33659b29e73d4adb9f9f6552  include/COPYING
-d32239bcb673463ab874e80d47fae504  include/COPYING3
-afa146a88c20fa3ac0879b0c3ec30259  include/ChangeLog
-24516b717009640ce59780ea65675d4f  include/ChangeLog-9103
-d618facc3e8ce8bf3d02ba452e1be6ab  include/MAINTAINERS
-de46742edca3a9276eefa5ae8fdee5eb  include/alloca-conf.h
-f7d3e7ee65516643f4847560778a30cf  include/ansidecl.h
-6bc11541c9960b12dcc6236f34f28f20  include/bfdlink.h
-b6e1fac26f93147f8011414af5669be7  include/bout.h
-c761fbe28e130c5e46a936fa663b0f6c  include/demangle.h
-3d709d8cc1f51024725a62457b01d777  include/dis-asm.h
-bf491c715785399f572f97dec7b6241c  include/dyn-string.h
-e3351927fc3d8abd8345b9e8e239cc73  include/fibheap.h
-ce9346fdb0e61bf25e69d340cf7534b2  include/filenames.h
-2f91642214295b0fa0aff9ff209f1470  include/floatformat.h
-7d6baaede380aa3344526a4bbf8a294f  include/fnmatch.h
-b2cd17a9267bc2e92df461d3170cb15c  include/fopen-bin.h
-87444b5c85b3c2bc734f8b86157b15db  include/fopen-same.h
-2f3ef0265ac665d61a8721a78c47a79f  include/fopen-vms.h
-c6c79c7650e939987e61782932471d6f  include/gdbm.h
-2df953364d736c4cc07d3f3b0ff63714  include/getopt.h
-c7907270bfd5633f14250a01b762459e  include/hashtab.h
-d89699ccd4afc2579ab5bf69b57a688a  include/hp-symtab.h
-97a8767b7f95bd5bb7207d0215541d10  include/ieee.h
-e8bfa29f9ebcda2aac81072d4f1c1960  include/libiberty.h
-ab862fcf8a47a603ed95984f9a214e7e  include/md5.h
-85efe50116a443b4459eb4219cafe6e4  include/oasys.h
-44b3dbe9efa457af0cf4f032193dd1f5  include/objalloc.h
-5fd93204de68ae19148e1cb24c4be9f3  include/obstack.h
-10cbf87ea52bafe84a696ec172e072d5  include/os9k.h
-b212dcdaf1121bd8a14b03ebb2ce5ce1  include/partition.h
-ce441968fb1b5f3f68ae7afa86ad0476  include/progress.h
-4a10474f2f043d12cb8c292f1d1cf002  include/safe-ctype.h
-ffc879400e93c3be7e8727262ff65700  include/sort.h
-b42994ba61536949b70f9ffbae5b2f25  include/splay-tree.h
-c665cdb0d6c3bfb5d86841b168a2d1f9  include/symcat.h
-9e4da3ee24c6f11a47fa7d5cae9a03d0  include/xregex.h
-0294cecbb1f66d640ccba3a5d862d05b  include/xregex2.h
-31fd4b5d7f1f63a5d361533029b50a46  include/xtensa-config.h
-03811f8e9b017b7b37906f68809fa334  include/xtensa-isa-internal.h
-b210059997076f16f46d4a4ff8172212  include/xtensa-isa.h
-bfbddb97d982b17ead77438a3e39527f  include/aout/ChangeLog
-ae9a5ddc0875226806a75d71b92b86a6  include/aout/adobe.h
-4422d348bb36da4d740bc54e0c9ad6a6  include/aout/aout64.h
-1c114e056a798c5903e8990d753ab005  include/aout/ar.h
-695d96120641c7143548d4a44fd354ad  include/aout/dynix3.h
-76631c25323f65b5001e710fa5119709  include/aout/encap.h
-ca0752eaebd88a1a8d30a733635e68da  include/aout/host.h
-e9475def89c7b448a2621cd554420a7c  include/aout/hp.h
-14c5f23e05dc2b318cd39ac37f3802b7  include/aout/hp300hpux.h
-d82993bf02befd5682dcd44b076ad991  include/aout/hppa.h
-ae3ad0b0d7fee250d99c10168b4415ee  include/aout/ranlib.h
-82d76b30b1d9c9cf6c2d87ecad66e49c  include/aout/reloc.h
-1ca28658abcad7d60eb8c7cdea9a82f7  include/aout/stab.def
-e99c59a5de1219513446f03723c90a41  include/aout/stab_gnu.h
-c3ae2f22fc1e70400c4418a3ad6f6a4b  include/aout/sun4.h
-11f018e5c861964718c03b55bfef0668  include/coff/ChangeLog
-3bad510fca185cf87d7b28b5e6bfe35a  include/coff/ChangeLog-9103
-0eae126d2322eae7cb85fda3b3c51d4e  include/coff/alpha.h
-ba1e7d1f5ed257158d5ce1495995b9ab  include/coff/apollo.h
-97343a0f0e1064cdae2854878798c8dc  include/coff/arm.h
-729600399e3cfb12f73b155e267a5d30  include/coff/aux-coff.h
-4e12ca7185f8d144173a617b0ac92b8d  include/coff/ecoff.h
-d8d0bb770386357f1e9881ba2dfdae2d  include/coff/external.h
-46d03711f6f0939aa9523a094fdffafb  include/coff/go32exe.h
-4275dab863d75a6b49ecda9b4c37ca33  include/coff/h8300.h
-91500d53e9b51b394784be4e4bf5f7a8  include/coff/h8500.h
-41e91ec85d00ab0e8cd625e21d68879e  include/coff/i386.h
-3b0aef260c80bb67215de0dc4cd96454  include/coff/i860.h
-e70ee7eb497858f6370980c80946498b  include/coff/i960.h
-5deae24ffdc3e1b93412e1ece5a2fcb5  include/coff/ia64.h
-426bc276fbd6eb19dca0e57b391db1ce  include/coff/internal.h
-09329bb0498e551cdd09bf38c56daf7e  include/coff/m68k.h
-fcb6774ebbf89db35e32160ac541679c  include/coff/m88k.h
-96eab139e18329604788f0c10077628c  include/coff/maxq.h
-47a9032db74c3fedae0b23f5a1200a1e  include/coff/mcore.h
-30bb1d9629c4218edbe49f7130ee170c  include/coff/mips.h
-8656c472a72618bd586255fadc6fa8b8  include/coff/mipspe.h
-a13d0ca109cfd6f4e1ea734b3637042d  include/coff/or32.h
-a9d9197f620bce572e6bbf608845c60d  include/coff/pe.h
-08fbcf988bd369f711e603ce2467f905  include/coff/powerpc.h
-e3095276c227f9c73621e91f83e74ef4  include/coff/rs6000.h
-b050d6103fa249e4e7cdf4237b59d9d4  include/coff/rs6k64.h
-f7e3a4193c5b29821677e7dd0adcdf7e  include/coff/sh.h
-de7d4e6e42df84a83d7138b1dedcbac7  include/coff/sparc.h
-49952fda1e759e5aa659f8f78d7e0ba0  include/coff/sym.h
-250886881b64624348d6043a56bcefd5  include/coff/symconst.h
-bb610eeefc1dfc39b3e906fc4f2346ba  include/coff/ti.h
-77efd9ccf458c8539ecc9569b7715407  include/coff/tic30.h
-a34de85c5f5044db79154ca0a2e95074  include/coff/tic4x.h
-b9fa24f3cd1280d6f2052413b4193b97  include/coff/tic54x.h
-d69855973c384ee0192e5e4e21c45354  include/coff/tic80.h
-5958a33fd090d8406f641548559d87a4  include/coff/w65.h
-2b4a080b92706ac0f203568e4eaa6d69  include/coff/we32k.h
-b22ec9d7c9cb1b936a6a3d5d91091ea8  include/coff/x86_64.h
-99af63719b508b5fdc4a257d5ea0de80  include/coff/xcoff.h
-80c0c3a0d6335bbfd1d824da25a7b17e  include/coff/z80.h
-efc04a704e22032ea0d2d205894414d2  include/coff/z8k.h
-f2b0804ffd4159c975d87b02a31ecb2d  include/elf/ChangeLog
-98f9c5b892b53edff47e277ff7d497f8  include/elf/ChangeLog-9103
-b58e070600ebd49e546a44c9a02b4433  include/elf/alpha.h
-7d6deb8bc79137df149e5e38f4ff6079  include/elf/arc.h
-1354476187e3f3c1538285649788cbd5  include/elf/arm.h
-552c6690302cb4580c8546a4a0d6c604  include/elf/avr.h
-53604e89830fe7d85e0a636c5ca6d9e6  include/elf/bfin.h
-201f189e310de70af7ba3c65f92d9b01  include/elf/common.h
-5bf164706c8aaae964d34a3a96d4e9fe  include/elf/cr16.h
-d924ee9028ad17079d39a235defab8ef  include/elf/cr16c.h
-427e00afa9dde7c6115399837c1c3c75  include/elf/cris.h
-5dd7586b87f24bbd4749d19486bd5300  include/elf/crx.h
-bc79fbb9f0e87729313cb97592c79c03  include/elf/d10v.h
-bb5bd273174d8bd520076ea66a3bc2d3  include/elf/d30v.h
-bfc96913a28a31449092f62688a79084  include/elf/dlx.h
-65f0065f73a3caaf1dd6f9cb28356d9c  include/elf/dwarf.h
-e28a75b6b911b22eb3a199e043423df4  include/elf/dwarf2.h
-d96bf078f11268c89a4a366703f3d1c1  include/elf/external.h
-46a012edb3cfe8db6e59ff9d1036d10f  include/elf/fr30.h
-e1d390cfe5a8a79ec58062ef55ef3ed9  include/elf/frv.h
-88eb11a3df1f08642f138865e8f66e4f  include/elf/h8.h
-d0dfb27102c04656901005dd160ad75d  include/elf/hppa.h
-6f1c67c88e221bd0d385ecfd473dce06  include/elf/i370.h
-c59da055f495beaa2c41d3c619211912  include/elf/i386.h
-0c701d120f36661160ae45dd063f6be5  include/elf/i860.h
-f5bb1235e968501b5320183ee92dd0ed  include/elf/i960.h
-56ce7d296f05119af909d490665e1c09  include/elf/ia64.h
-f0b0a9a4e117963a6fdbf660fcd70843  include/elf/internal.h
-065b0a6729f94d495ea2ad655c02c2e9  include/elf/ip2k.h
-cb5cd7dcdea1e5c68c68f20500290350  include/elf/iq2000.h
-cb39c0ed20eec57eaa682f6eb8a5ebbb  include/elf/m32c.h
-3df7375253d6ae2c25fed8c53763417a  include/elf/m32r.h
-cbefa6ba736a3611d255754284ab9223  include/elf/m68hc11.h
-19f34fcea6ede85679de09a698dad7d5  include/elf/m68k.h
-f2dc7fdfa778cf42d76a6906ad6a1396  include/elf/mcore.h
-e27206bced4fdfe9b3cd8739970759ce  include/elf/mep.h
-b923305178670fc2b3334a3b7b0c5222  include/elf/mips.h
-5e7d7fef55a18f51d17ba9065aaa84c0  include/elf/mmix.h
-d47d228e2347d084861d5f598ccaab01  include/elf/mn10200.h
-ccc949431c77de0330ee3c20548b7e67  include/elf/mn10300.h
-3666529d279f69fa8a487c2efed2120c  include/elf/msp430.h
-e5f6a2d8b0999a623ed80ad96097711a  include/elf/mt.h
-67c44a12efec004686c5da82c283fea9  include/elf/openrisc.h
-77f09d73d2331ef33a81df01367e759a  include/elf/or32.h
-4e3af9766a70428a794053db9ac26982  include/elf/pj.h
-978cfb5d0f121b256b9ee4938371407d  include/elf/ppc.h
-29c4a93c369bbf45f588d48b35631b4c  include/elf/ppc64.h
-aedd40ef93ab60bad551acf0984d1373  include/elf/reloc-macros.h
-b163e0ddc4c8cceb00f746535ecf0785  include/elf/s390.h
-8a7b4cc32d64d94ee2485317671dbb3f  include/elf/score.h
-bd4fb4257fe6081aac1e4d4403106504  include/elf/sh.h
-3d51236a10c7eeaf2af6abb280004561  include/elf/sparc.h
-eec26a4abff7951e1d83288ec6d4f16b  include/elf/spu.h
-a8c47b2cda0f7540afe82ce3dba22b76  include/elf/v850.h
-0ae089c7740d126d10cd9ab688b94f28  include/elf/vax.h
-7ceaa6ddb9edcf008570c49fcff9dc7b  include/elf/vxworks.h
-d02b9a35256696e7b25dc444e121bc26  include/elf/x86-64.h
-09e0b6ad16cf4079a52a3009ca040f1b  include/elf/xc16x.h
-00e34077e494d9c3e6093746cd6a25b0  include/elf/xstormy16.h
-aa155b177d8e639b1c27af26fbb03cd7  include/elf/xtensa.h
-d8f341a6a1b073ac117a0b3b9727a7ae  include/gdb/ChangeLog
-6e3604022d04d6f8cb2d0dd81f7d1652  include/gdb/callback.h
-c194cec1f373078803bf7c4c68fe6d1e  include/gdb/fileio.h
-5192dea0bdf6150db9d130d96760c007  include/gdb/remote-sim.h
-79bc20d7835bb8e4ef99e3267d6b1f15  include/gdb/signals.h
-d68fae8c3605bcf10e7d35f5c9d2abb3  include/gdb/sim-arm.h
-9a99a8d15df9c424ce0c73a9e7775058  include/gdb/sim-d10v.h
-63bdf1d76865f94e0318c0b6f8efbaef  include/gdb/sim-frv.h
-5adc4b0b838fbd1c0995031be6bd7308  include/gdb/sim-h8300.h
-9224c7a8e8a4a9dead0692e8c7d78f65  include/gdb/sim-m32c.h
-7b9b40a8c7153fd80cb9b198ea65aab2  include/gdb/sim-ppc.h
-eed3c72e6c13d9086facc388f41fda7f  include/gdb/sim-sh.h
-85854dd656ed5fbf086b7fdb5e950359  include/nlm/ChangeLog
-54cee2a0525584cecf2cf268ee88175d  include/nlm/alpha-ext.h
-7a4e6e5f18929594dc5b0d6ef5858e2f  include/nlm/common.h
-2393dc0b908a7ecf55b9b02616df17b7  include/nlm/external.h
-270e90217aa54f2a3c538778c3dc1c72  include/nlm/i386-ext.h
-99606cfc1f9e1f099d5d64690d7fd074  include/nlm/internal.h
-f8585e7636d4318d333971cae5fa1426  include/nlm/ppc-ext.h
-80e4ebf217e787161fa6662bcc0f81d4  include/nlm/sparc32-ext.h
-6a3b973ac3c23c47bd7b72a0db6a2f67  include/opcode/ChangeLog
-422ec9ceff6284c1c213760d8d847ace  include/opcode/ChangeLog-9103
-86b8a7bdbef8a292cda1c038821f7ee7  include/opcode/alpha.h
-5c8e5bf2038b8f9ae20bd546d37f1ebf  include/opcode/arc.h
-a64cbce5aca20f6ae5494bcc7323a9ca  include/opcode/arm.h
-23e308242e971b6f9601e80ee7f859c5  include/opcode/avr.h
-78416be72b2f3dadf47cd3629fc3b173  include/opcode/bfin.h
-af8bccb33b7ca465db204a4eb95c328f  include/opcode/cgen-bitset.h
-2d8d653463e6fa90a098ffe1228a871a  include/opcode/cgen.h
-faedfd0e7f1562d4523e8bb320c48de5  include/opcode/convex.h
-ba5b753c5e0570488df6b46efb40d458  include/opcode/cr16.h
-bde1e60ce5ef4b6efcad85a727b04a8a  include/opcode/cris.h
-38dea709f86fae45e9b13dfb9448154f  include/opcode/crx.h
-0eb4c8cbc9ce9f9d0be1fd9ec84867fe  include/opcode/d10v.h
-414159e130a7e40f2cd0b7741c53c536  include/opcode/d30v.h
-097c19fc9fcd748d0a3256728486156b  include/opcode/dlx.h
-6b8b5ae78bc320893b2f85920fe84830  include/opcode/h8300.h
-75c87b41820eb6716f9b6f82921e5bb7  include/opcode/hppa.h
-e2abffb49369201c7c30170378f798f2  include/opcode/i370.h
-dea43f78da1ba181e56dba39a54c231d  include/opcode/i386.h
-0a40ce915904333da0f263d7efb46656  include/opcode/i860.h
-67e4cee6956b5fca66ffac36db6c73fe  include/opcode/i960.h
-0908e763c96961ff41e7185d24f5cb4a  include/opcode/ia64.h
-95ae213b1c61ddc5d456c961e032fab0  include/opcode/m68hc11.h
-91093fd5739b3df9b431b74b450a02ef  include/opcode/m68k.h
-0888ff065c912ec6e6325fa900a63771  include/opcode/m88k.h
-3be129ef66722d6cabc1f6288b9f8924  include/opcode/maxq.h
-f4cc817760293f9e4aba8b15326c6e65  include/opcode/mips.h
-23cc30640f22293a09d4169f7dbcbb9a  include/opcode/mmix.h
-92d353be1492265b3b61d72c88226d1b  include/opcode/mn10200.h
-b8426a1dcde081d18d4fe2d6a6b297c2  include/opcode/mn10300.h
-0a0c7439c713a0808e3f8c0d56bb881b  include/opcode/msp430.h
-d705f2b7070a6d7ddcfe31e50aa152bc  include/opcode/np1.h
-33fd5191bee7756176d0e10a4a419ebb  include/opcode/ns32k.h
-4a7ef121dca3c8198545a2296e0e1222  include/opcode/or32.h
-d88ba58f65e451dc8f863aba1874df81  include/opcode/pdp11.h
-77e78f430ef39ad52f45418f89b01f18  include/opcode/pj.h
-3c4f6d4e25e3d4c1bc66709f2299ba01  include/opcode/pn.h
-7423905bb912e9c2a608b091475da7b0  include/opcode/ppc.h
-fc84f44059a03947e686d95420baff58  include/opcode/pyr.h
-0d394ab1f282a148677ead58bdc0443e  include/opcode/s390.h
-32afb568d2cf31c22726d78ae3c9797e  include/opcode/score-datadep.h
-51d6c8bc9c2872aaf29101bb0ca158c1  include/opcode/score-inst.h
-be55f06fea077b43aeb73ef735ecc430  include/opcode/sparc.h
-2343fc6d5186311d6bf8286f4efe8571  include/opcode/spu-insns.h
-862b724ebc664738dbe390820b90e02d  include/opcode/spu.h
-c69e19287023c929ac20ee5311acfadc  include/opcode/tahoe.h
-99017c8f58643ff84c7dafaed00ff781  include/opcode/tic30.h
-c8a4c1ec48cc797787eaba11a19132c7  include/opcode/tic4x.h
-96cf03df8866b7e0b91b3e21019ab9f3  include/opcode/tic54x.h
-b80c748813b723b5bd9c3e89696060d2  include/opcode/tic80.h
-6b80a1f237267d6badfb4df07569e813  include/opcode/v850.h
-187cfeb91ed5171f7e834812d8110288  include/opcode/vax.h
-aded5875c5d5830de6653181e8ced19c  install-sh
-fba959c99e36c648cba109635abc8ec0  intl/ChangeLog
-d2413516bb4932a3f3a3642164ac38f8  intl/Makefile.in
-6ec998bb4716c744bf8185e607f69301  intl/README
-76ca170a525d5b84d90f0478fe788931  intl/VERSION
-9f2cd7720d43a1e32a19f9a922e94fa2  intl/aclocal.m4
-d4abe82ea322701d2385778a2fcd0804  intl/bindtextdom.c
-8d681f6f96799ca356c0ec51ac3bb19a  intl/config.h.in
-8a751062d7db9b6e8163667e5626fcb5  intl/config.intl.in
-730ace174102eb2472bea1bf9cc49612  intl/configure
-efe3fe832deb9fdc1164141aaa52e892  intl/configure.ac
-ff5c358b1507e45a2106b23b7e6c70a3  intl/dcgettext.c
-81b58accbd88cd8159471d322723c42d  intl/dcigettext.c
-0cfc94e602bc20d958f014c77ebf357c  intl/dcngettext.c
-c8501675ab40fcf8fe39364ab9de0e42  intl/dgettext.c
-45bd4be597b118d4bbbff6c9c6958e87  intl/dngettext.c
-6e671cf01cbb93dedaf7b3688062d7b8  intl/eval-plural.h
-1e4b5d6e86db4708199e0b7b61d06232  intl/explodename.c
-6f008e715086ccfb7e8e44c007fc7bc9  intl/finddomain.c
-24c6e42d8020a8759b3c8b13e0c37493  intl/gettext.c
-27f0efcc3ff8493519140cb36aeead2a  intl/gettextP.h
-c6620ffc92d5853137d3ac11300de38a  intl/gmo.h
-049ba34a0c8d1fe665e8119e579dce4c  intl/hash-string.h
-7b5af5c4e777690b9851b3e85603bcc8  intl/intl-compat.c
-9f41e951f166a5aedcc25268c161d1da  intl/l10nflist.c
-05f03dc9d9297a33c64a74880c06a7ea  intl/libgnuintl.h
-0ad4083e3b5df1f764bb605dcf657b88  intl/loadinfo.h
-d8e3733cf513bbf862ca090cf6403edf  intl/loadmsgcat.c
-0ff7bc241f5ea36688cf8bb6ac801b5d  intl/localcharset.c
-4d8b75dcdafb699870e4133fba5b58f0  intl/localcharset.h
-bb9312cab68737125445f5932ae7140a  intl/locale.alias
-bdad874b80d29c70bb040f2ddeb67c5d  intl/localealias.c
-8179cdac0affac17e1f1ed2087b4595a  intl/localename.c
-78672e3784df9ceba75d1d004d6a1f78  intl/log.c
-040acf17db43770b3eeab4337e031fc0  intl/ngettext.c
-506ef276b14575f52af7a6982d58e666  intl/osdep.c
-12ff40e8c89d99dc7b704bac9434124a  intl/plural-exp.c
-4109118983200f4aa853bf0cb466c586  intl/plural-exp.h
-0f3d1bb596252bdacce100082392dedf  intl/plural.c
-d50a8c6c5b41089930accbdce767d3c0  intl/plural.y
-b4758a0194e3e41362b939911472ce62  intl/relocatable.c
-bedade7bcfc3bc5eb09a2c6844f637f3  intl/relocatable.h
-43f287d082528203fc85c1d2d81bf30d  intl/textdomain.c
-347dc3cc55a6ac6b3d852c425c2b9063  libdecnumber/ChangeLog
-c91fc32f10a70a98f8a4a1fbb30e4741  libdecnumber/Makefile.in
-44f4920dd8bf48cc126c580e7fa143fc  libdecnumber/aclocal.m4
-af852a51fecdcb9edcf1950268b6158b  libdecnumber/config.in
-5b642114a50c05aaaa0eaec693195534  libdecnumber/configure
-c2221eba3c8e658e139b198fca0f95f3  libdecnumber/configure.ac
-92436be50d6a57768b2578fd2ff46f29  libdecnumber/decBasic.c
-7e446ef620cfcb1b4a8223543bd4c319  libdecnumber/decCommon.c
-2f89d012c7a8a2912e7dce02bd4a08dc  libdecnumber/decCommonSymbols.h
-12ad455c6cc2ffff8768c1d3e8168c18  libdecnumber/decContext.c
-4bfeab9d029b0a5194d1b1ce5da90453  libdecnumber/decContext.h
-53b67627dab6d36fba960317d84c1487  libdecnumber/decContextSymbols.h
-52a3266ee80d6fe15dcb59f450b27873  libdecnumber/decDPD.h
-8f3ac08d4cc421cc89035e90c890bb09  libdecnumber/decDPDSymbols.h
-945c595c0170256b5f2909256f47fbbc  libdecnumber/decDouble.c
-88f9eee6e774052b6809f4e30dc337e6  libdecnumber/decDouble.h
-22e16083bf3d0b76c4736f7f6382cfb6  libdecnumber/decDoubleSymbols.h
-cfd35e4f5167f851a9bbde06beed1fad  libdecnumber/decExcept.c
-0b8c4d4a7f027c629f17342e88028d50  libdecnumber/decExcept.h
-15a0124a2cea2a4dd77cc8ff843a0cc3  libdecnumber/decLibrary.c
-f164af940f7dc20348ffce5bcfac99de  libdecnumber/decNumber.c
-25dc30ac022711d62558e7379b02d51c  libdecnumber/decNumber.h
-e52a0a2b7de82eb8ac80e5e9a3ee0624  libdecnumber/decNumberLocal.h
-dd46d36cafe0d7dcb669ad059fbed9b6  libdecnumber/decNumberSymbols.h
-d11e177706206ff3ba356d2b99bf3711  libdecnumber/decPacked.c
-6d8c04560cf0bffbe124c6ab9ab5b34a  libdecnumber/decPacked.h
-287ad6ebf8b8179aa843368e9600a3fb  libdecnumber/decPackedSymbols.h
-5788b20bc9ab8d943b8a15cc3c91a442  libdecnumber/decQuad.c
-7ce1f5d6ee8445aaadbde0b7ffa3d46f  libdecnumber/decQuad.h
-3851bae03416db42a85be1c5610f438b  libdecnumber/decQuadSymbols.h
-739b9a849a9e28793a01dead4696650d  libdecnumber/decRound.c
-08d5a5e552e76f84d976006c8719db31  libdecnumber/decRound.h
-b45884614008456d09a9966f0d9dc4ce  libdecnumber/decSingle.c
-bbbca6c39f2c0c858eb5e212bae66aa9  libdecnumber/decSingle.h
-8998c4f3e69ea3d218b574a2defb9a98  libdecnumber/decSingleSymbols.h
-368025fbca677831a7e5eeb189c8cd7a  libdecnumber/bid/bid-dpd.h
-e27ef303bd60327e0236a2f1efc730b2  libdecnumber/bid/bid2dpd_dpd2bid.c
-51ea5c7f2c38dde9bc5ab64500e1699e  libdecnumber/bid/bid2dpd_dpd2bid.h
-2ca20638423d5ab9fb70f42b9f4c04cc  libdecnumber/bid/decimal128.c
-47afd72790bc284aceb5a23597cc6146  libdecnumber/bid/decimal128.h
-f8df5b96d86c867ad233c6f0d3e2541f  libdecnumber/bid/decimal128Local.h
-eab7eeba10520ab4a805774d42b8f9dd  libdecnumber/bid/decimal128Symbols.h
-cc276684923de9429823cfeddacf1a53  libdecnumber/bid/decimal32.c
-43b6b2bd872ad984104804b1b20fb10c  libdecnumber/bid/decimal32.h
-c5864ab84549ca0f34188ce5b057bbee  libdecnumber/bid/decimal32Symbols.h
-1e3b89b86cca82db83bf3c290efe4d2f  libdecnumber/bid/decimal64.c
-8c612aadae9886f1a72212f93d8651c0  libdecnumber/bid/decimal64.h
-9f903ba71afb574bfa3a0f3cd2f9fbc7  libdecnumber/bid/decimal64Symbols.h
-7d611d782aea149a9acc62f801ac2d54  libdecnumber/bid/host-ieee128.c
-54cbe88dfafd4fafdcf4a0ea1492db0c  libdecnumber/bid/host-ieee32.c
-27b264d898b6983d97bc5fa179cccd7e  libdecnumber/bid/host-ieee64.c
-ee7387d7b9712bd93e11fcf6902b25e5  libdecnumber/dpd/decimal128.c
-da6f612bad67529e5eed41721e618804  libdecnumber/dpd/decimal128.h
-5138bee3bcf48a0f75ecba60b9fe5519  libdecnumber/dpd/decimal128Local.h
-2f6da07ba897ca626a4f6d283feeef93  libdecnumber/dpd/decimal128Symbols.h
-3e70bfdb22a432846e3db8e2639219fb  libdecnumber/dpd/decimal32.c
-e8711c6b7ea5e06d843f1046dfa896f5  libdecnumber/dpd/decimal32.h
-a97c47969dfc92a7666dfe3c2e1e1448  libdecnumber/dpd/decimal32Symbols.h
-c71d2f5f6685486715144d439b503afb  libdecnumber/dpd/decimal64.c
-77337fb64594d9c488a93554cfa792d5  libdecnumber/dpd/decimal64.h
-0f6db29710e7075c2fd62bc4478b3b8d  libdecnumber/dpd/decimal64Symbols.h
-4ad3647a7331b6d44e4385a146b595d7  libdecnumber/gstdint.h
-a916467b91076e631dd8edb7424769c7  libiberty/COPYING.LIB
-94444f57e11aecc4e72bd5b17229eaf6  libiberty/ChangeLog
-70e8a3e4810e436a1e73bf061ee1a1a9  libiberty/Makefile.in
-294191545dc71f5ad13229b0a5bfd7b1  libiberty/README
-8797cb1a6faa84f3c7fe3d12164a4b13  libiberty/_doprnt.c
-87a91c36f3eb910fda4ed424c7e90be2  libiberty/aclocal.m4
-e60c2e7c5dcdd19510066c13f1a527d3  libiberty/alloca.c
-e3fe2ed2aefd116d97d1657ce6b9e3e1  libiberty/argv.c
-1ff1c82c53060dceecc901cf0b63c950  libiberty/asprintf.c
-a16ea056b95fd70c21333db132da14ff  libiberty/at-file.texi
-c34119797a13e71989722851c14b711b  libiberty/atexit.c
-ab8d4cd68aa4892e2318d2c71864cc56  libiberty/basename.c
-17a1f1d7f5acf01ce922d98210067542  libiberty/bcmp.c
-a707d2e5daa09d204d4441e8713048ca  libiberty/bcopy.c
-fe609e6de441faf95f55a6b481804e41  libiberty/bsearch.c
-4a0acb9356a52f3bcfd67efa26997b58  libiberty/bzero.c
-5bd055836a440051d7c561a9f591ecbb  libiberty/calloc.c
-f8f0d3215901ed5fc5fa9cf09e55b0cd  libiberty/choose-temp.c
-a8391a5d7431a4e11f61be41386a3356  libiberty/clock.c
-7696d31c3756d5ad3fa306cef3599c5b  libiberty/concat.c
-fdaf5fdc2a84ff34103604588aea1a3b  libiberty/config.h-vms
-dd2971acf38c8b94a06c8309086d6de5  libiberty/config.in
-becde32ab10bd3f19a832596c208b520  libiberty/configure
-048dfcffa3f90547aed5c13366ad78db  libiberty/configure.ac
-a8959f1d1758eb14819753023f89d199  libiberty/copying-lib.texi
-fe053283d3559af3ec5cac45f8ead009  libiberty/copysign.c
-9b4cbcd99144a04e69692a22369e6174  libiberty/cp-demangle.c
-8a3c5b6d5c8ca6e1ebd34d5ffbea4fad  libiberty/cp-demangle.h
-a57edfd55211c46358188905b2dfac7d  libiberty/cp-demint.c
-8505f3fa0dfa13c4bcc1501ba64a4267  libiberty/cplus-dem.c
-7e772185592cfb1b5ecf5335889e71a0  libiberty/dyn-string.c
-d7cc74911527c672bba716c9a793ed94  libiberty/fdmatch.c
-0c2635175b975823b40980974dfc2110  libiberty/ffs.c
-1dd36e1601883f5bc897c94e6f06b33b  libiberty/fibheap.c
-dae4b30d8ef72bb7602b48e37e555839  libiberty/filename_cmp.c
-abdccce119a731670b0c0c2da8516974  libiberty/floatformat.c
-aa0f79d836563e6a0cd92ab678b07aaf  libiberty/fnmatch.c
-30a2550d37938d1e3354632161ac1d0b  libiberty/fnmatch.txh
-2ae40f31f6899f80f81abe3810702435  libiberty/fopen_unlocked.c
-2ce15cef1b16a98ed70abb654f1cff8c  libiberty/functions.texi
-9a504fc6f981505eee669fd71657624a  libiberty/gather-docs
-754c5ef42440c5d1b62146174a6636e4  libiberty/getcwd.c
-eb843075f87d187630f6a3d849b93e64  libiberty/getopt.c
-7c932073da197aa34eb3383960a114fd  libiberty/getopt1.c
-bb0043d92c716691cc17b80c845c336b  libiberty/getpagesize.c
-5e520e600636a692f52e62dcfb01921c  libiberty/getpwd.c
-5c0eb869d31323424849c0aab9247722  libiberty/getruntime.c
-0c70ad1e35bb090b52ed593865025741  libiberty/gettimeofday.c
-a77ffcc9460c2ddf20f211aa0512255c  libiberty/hashtab.c
-048d9004ba3a2badb7abe6e0afd8f663  libiberty/hex.c
-4d485e7735be430b22aea0abb4938e26  libiberty/index.c
-63603f59c10b854880473f2105993706  libiberty/insque.c
-dd4459d067ddcc1144926103908d94bb  libiberty/lbasename.c
-18b9304d730b955b7e77b09e91d50418  libiberty/libiberty.texi
-2c56f9552603480f87b7136972894128  libiberty/lrealpath.c
-cb0494d53e1c4c2bab0f4e427f22c614  libiberty/maint-tool
-8435398af48008acab7cd7fa5ddad03f  libiberty/make-relative-prefix.c
-3a2fa59555ba074a642f332e8ed421ec  libiberty/make-temp-file.c
-e331b31ce1cbf27a44f2fbeb54fa7b17  libiberty/makefile.vms
-cae2c391feb26227e1cf16d6419da2fa  libiberty/md5.c
-c8e83a77812bbb5089066e944e77128c  libiberty/memchr.c
-a528eda37da892ba47489adc65a5876c  libiberty/memcmp.c
-95ce22742f0fff45d387a5edfafe5ea0  libiberty/memcpy.c
-17849b03ded61c7a4eab9a092a1ec466  libiberty/memmove.c
-302752b6f91e8b56b9944c1a48d780f9  libiberty/mempcpy.c
-d165e2ea5dd22486fc47a26cb1122187  libiberty/memset.c
-5dd06d52541d76216c306a9b34b2bc39  libiberty/mkstemps.c
-7897e43bedd2def4beb6eb73003efa68  libiberty/msdos.c
-684ab2f5de6b46501aac279f2bd2f92b  libiberty/objalloc.c
-ab0f43a6703e0705b4e8bac274635b56  libiberty/obstack.c
-051d336f4d87cf832d5adf343a10cbe0  libiberty/obstacks.texi
-f4ec5461a2fdb28214092b95b39ef186  libiberty/partition.c
-4d86c052a39ff61e8b90bf44be80fc81  libiberty/pex-common.c
-00e8da1bee1b9e91a8374563c3bf3015  libiberty/pex-common.h
-0a57f00f2b3b14f3e42d30027ce62b47  libiberty/pex-djgpp.c
-5e3182c10dd9892264b8ba80c2a15f46  libiberty/pex-msdos.c
-d67a9b0906ffa961fdc411aa936fdfb1  libiberty/pex-one.c
-8d9a2d5d9141cfa2cd46d5f4f563ace1  libiberty/pex-unix.c
-bf2d288ddf1330db19a28807ce7867c1  libiberty/pex-win32.c
-fa294b254945587548ca6b32d7922d03  libiberty/pexecute.c
-c1d142cbfaed8c716e67a5d03343a599  libiberty/pexecute.txh
-af9bee5d1912e623defe1a7ee0ebc296  libiberty/physmem.c
-f7e45d3f23f83574372065030595efa7  libiberty/putenv.c
-db9be0bda70e724fa67044d66299b85d  libiberty/random.c
-60656698122b80711c2cc8d35f29d9da  libiberty/regex.c
-24eab3d83825c3be13549dc62b6d63d6  libiberty/rename.c
-74850488731148a9c9f410042144f37d  libiberty/rindex.c
-b91dd39a7b9d4c9d03edc8a6cdf81978  libiberty/safe-ctype.c
-26cebc96bf0afd6f4549daa75df55ad1  libiberty/setenv.c
-cafcb336a6d21898592c5cdaa7c5a3a7  libiberty/sigsetmask.c
-508df49caf0f63878c515fb3998b5a27  libiberty/snprintf.c
-32ea90e5aded75d1cbed83fc52123753  libiberty/sort.c
-d86a2cadfe8dbad9abe796fca261dd06  libiberty/spaces.c
-94ac06264d2033f2bb515033872c1e1c  libiberty/splay-tree.c
-bac20c1a198662917e6bc775ad9bd0cf  libiberty/stpcpy.c
-ec776b1c7d69d111cf8371fa0a1ff356  libiberty/stpncpy.c
-0c900e9180d750a26ac0ddb237151832  libiberty/strcasecmp.c
-13cce636dd9882e42c9fc5d607351f4f  libiberty/strchr.c
-9f681e91439ac44c9df8e1b1deef33b5  libiberty/strdup.c
-b3aaeed201f3c6fd293e9f9618350bfe  libiberty/strerror.c
-2d414e20c053293f373a5306192db8f5  libiberty/strncasecmp.c
-7a2af59d38fecd41d10bb27112051f66  libiberty/strncmp.c
-2d92725e49581d86d7cf06fb40def19d  libiberty/strndup.c
-5b0eb0000c746fc4c1854f00bb80b53d  libiberty/strrchr.c
-b16102aa1ce8dbb1d26be2730cdf1e30  libiberty/strsignal.c
-e2f3721273c7ef1ab0194aad78ffa3aa  libiberty/strstr.c
-f824ac0dcaa3a91b48d01cc80a7d17ef  libiberty/strtod.c
-975b1003b58e3cca76c06e7237a14e0d  libiberty/strtol.c
-26196a9a92fae743a06d65f0e081084b  libiberty/strtoul.c
-9e1bb6fe95ebb6415672ddf1da29ec65  libiberty/strverscmp.c
-6b513119d8c36af928821e8ec24265d7  libiberty/tmpnam.c
-fed47804d20d26873d480f5166e7d864  libiberty/unlink-if-ordinary.c
-76ece2eeaeac16005683a3e7bae1f2cb  libiberty/vasprintf.c
-8e71982d77e91c0e3c57ca86c8a1b548  libiberty/vfork.c
-dc973aeb02b4545e42f179263612a4d6  libiberty/vfprintf.c
-9a46f8a6bd6b911849f209d09e94b66f  libiberty/vmsbuild.com
-9cf75296ffdf5af13ece69eea5cb16a4  libiberty/vprintf.c
-bed73a98fd3178ecd9433e0f6a3ed214  libiberty/vsnprintf.c
-9e789d58cebe756b96be30941debb05e  libiberty/vsprintf.c
-9c22926d0b260822786460b98e517ad8  libiberty/waitpid.c
-f32b581d10bcc500277b6f4b4f923a4e  libiberty/xatexit.c
-22389f4e282e4b739e0c1d70cba66cc1  libiberty/xexit.c
-cdc140ce93944c5bb2ac62cd3dfd86d6  libiberty/xmalloc.c
-344bbf391c173eb006d2b3fa364f63db  libiberty/xmemdup.c
-9609edf2f881f61eb24039301994216a  libiberty/xstrdup.c
-6f774a92661ca4a067f1691a7925524b  libiberty/xstrerror.c
-c6e7ef53b4ff115a136d917511222656  libiberty/xstrndup.c
-4004fdcde347fda58406b4b84a995c66  libiberty/config/mh-aix
-7b65854f594c84e80295173de277b3dc  libiberty/config/mh-cxux7
-044204f5b4bcac5eae2face0602129ae  libiberty/config/mh-fbsd21
-904bdcd9daf97fa55a9ca8901ffe7435  libiberty/config/mh-openedition
-38e76da568ab25260754fdb9d5080513  libiberty/config/mh-windows
-8f24f8939540ed6d58ad0dcdf1132562  libiberty/testsuite/Makefile.in
-e544db43315749d2ce7416493877732c  libiberty/testsuite/demangle-expected
-260c6daa082aed2403b1a5b12d233f27  libiberty/testsuite/test-demangle.c
-9c8adfe97eb319577a25393de6ee66c8  libiberty/testsuite/test-expandargv.c
-e9e958dbfc45a08dbbbbe48c83d3987e  libiberty/testsuite/test-pexecute.c
-72cf9e5b7f5a8cf4d974caf00bb37946  libtool.m4
-9a1a6f4657d0c117543d9a7e64abaaa4  ltmain.sh
-30a8b53c7f817eeac318be041f345068  ltoptions.m4
-453a1265f327eec81714e88992efe8c3  ltsugar.m4
-6630b6f86dadfa5f58141ffa5f9e4d6d  ltversion.m4
-e75e3fb8a78253903f24b249b939297b  Makefile.def
-6730de5b8ec56e2e3bb03214434ce78d  Makefile.in
-c115e92b73cee5cda86ed3307071055c  Makefile.tpl
-5d58f0dd4262171a71b65bd515d85d07  missing
-64e8ff72710e830f15a347863b848c7d  mkinstalldirs
-a20215c156b06261d944ae7f30a3b75c  move-if-change
-43ac060e21315f7c0b3a9635f4fcc971  opcodes/ChangeLog
-1b4b8646bdc7ad5a2f9071d8ac8b024e  opcodes/ChangeLog-0001
-83ac14eead5eda1862cc926b82d35cea  opcodes/ChangeLog-0203
-d4cca6dd9882292b6f2e17604bed6cbd  opcodes/ChangeLog-2004
-95966cf6bc7711aae732addbfd33ce65  opcodes/ChangeLog-2005
-7ba43e2b6e32ab09a694143b260d7f93  opcodes/ChangeLog-2006
-066e38fddf56239fcd4ab773798695c3  opcodes/ChangeLog-2007
-568db2b4641150f46a18da55529d8d3b  opcodes/ChangeLog-9297
-fc3adcd099179b77d2adb79ada21a89c  opcodes/ChangeLog-9899
-d618facc3e8ce8bf3d02ba452e1be6ab  opcodes/MAINTAINERS
-27ddf01bbe42808f0ff4c3f678a31d7b  opcodes/Makefile.am
-6a37a8ecc3a8b40fa5eb222e75ee9829  opcodes/Makefile.in
-bd09d7d44cd43fad1a139844641075d8  opcodes/aclocal.m4
-a5c055472f45b412c5ba8c59576d7afa  opcodes/alpha-dis.c
-b2c7455ac27ff79f81ccb4aee922e6a1  opcodes/alpha-opc.c
-4086bffd4ad243d379965f6e8b1dc70d  opcodes/arc-dis.c
-fae56f2f9d23b3d77a8eaacc04edfa62  opcodes/arc-dis.h
-600df541c72eff91184a227ec5b04088  opcodes/arc-ext.c
-b3d65ebfe89e547896663c61def89981  opcodes/arc-ext.h
-e016668afed76e3602ac2c0b9c8c5f9d  opcodes/arc-opc.c
-ec12cef72debf41872371c0b6be4cea0  opcodes/arm-dis.c
-ae4f2a39a7f46edb22eeca762f1d87c4  opcodes/avr-dis.c
-140fac384bb397b3b28c36f5723b8aa3  opcodes/bfin-dis.c
-2dd0a010d072b2fd4a49b2a8eb852449  opcodes/cgen-asm.c
-5c9906ceedfa2656cfe43eb314e7fbde  opcodes/cgen-asm.in
-0b0210d764d8b2d2d24842103bcd6f82  opcodes/cgen-bitset.c
-6d1aefb4e9040b32bf03004c716f6982  opcodes/cgen-dis.c
-1449f347e6999bbc80403fd177894d4c  opcodes/cgen-dis.in
-842ed58d6b8c7713e5fa8d004024bea6  opcodes/cgen-ibld.in
-5ec14fee27c9af0fd836335d2c68bcdb  opcodes/cgen-opc.c
-2b9b845f7b161ef7455edd51eac1685c  opcodes/cgen-ops.h
-7c5687f0e245054341ed9ff9169a0343  opcodes/cgen-types.h
-84cce3e9d957ee5665df4256f70cb8a0  opcodes/cgen.sh
-166d42fc0ba33c6b93c8e0b316fb21ba  opcodes/config.in
-b33d30400bc444455b2304d6bb128ca4  opcodes/configure
-551aca12183d708c031a2bf4f67760d7  opcodes/configure.in
-f89174fd743d917be3fa8afc931f810a  opcodes/cr16-dis.c
-09ab709a66931f9fb495aefb52fd66f2  opcodes/cr16-opc.c
-8916c27d1729a24e5c604cfa915bd9cc  opcodes/cris-dis.c
-8258eeb704a1a535862263a798637bfa  opcodes/cris-opc.c
-c76b3e25aa7553d398da0745b5599b44  opcodes/crx-dis.c
-276813701e7ee17fe80fa484cb5e160c  opcodes/crx-opc.c
-9f37ca078c8fbbc619657203997c305d  opcodes/d10v-dis.c
-5c21bad7c90f4bd8ab78609f15065f5e  opcodes/d10v-opc.c
-a29d37b42a4be24dfdb47090cbfca0b9  opcodes/d30v-dis.c
-fa8f5111930e274b56b6ca49e0304e7f  opcodes/d30v-opc.c
-da4bd373cf3a7057c992b6ab8ccd0e08  opcodes/dep-in.sed
-ab4e0c1bffa30358cda7a28bccdfcebe  opcodes/dis-buf.c
-a9d4640fa03415902e04ff5f959f8b28  opcodes/dis-init.c
-524b8da6fcdc7d15dfb28a9ae07233e8  opcodes/disassemble.c
-03e07ea45aecb2e4b5e5704f7822219d  opcodes/dlx-dis.c
-470d9470c1715415873e97dddb54354d  opcodes/fr30-asm.c
-680150f6d61d39bf7b0d4f9b0b816322  opcodes/fr30-desc.c
-56e42291d6dbf40a4f616cf20483ea96  opcodes/fr30-desc.h
-acec997a701177bb294773bb9a5d4660  opcodes/fr30-dis.c
-1ed0fbbcf70a72a9ff03f61907dba57a  opcodes/fr30-ibld.c
-e4595d32a07c08e9ae3ae76a24d096f1  opcodes/fr30-opc.c
-994c4038bce927929b607f64defc1fb6  opcodes/fr30-opc.h
-5f90fefcf002d68f0c4739d868922ae1  opcodes/frv-asm.c
-63ad85891e4e1a6860e86a8d120b9b59  opcodes/frv-desc.c
-7472040bf4b8000b77829c03ca9c6131  opcodes/frv-desc.h
-994e6e5fd8bc2c5d5d2eb6a539e954c3  opcodes/frv-dis.c
-d70446d74c4b71df39122ee2237c79c4  opcodes/frv-ibld.c
-8b77399814698f51bf8e2fcac8fe0e95  opcodes/frv-opc.c
-5fdc211e0fe9596e29b39ba6294bfcba  opcodes/frv-opc.h
-6196bd354097085311d6d54e194747d4  opcodes/h8300-dis.c
-5a693843e782ddb552dbc1f012f8e74e  opcodes/h8500-dis.c
-d979e067824c2c188bb31e37a5b736d6  opcodes/h8500-opc.h
-ad26a63b16a72b70636d567fe20b812d  opcodes/hppa-dis.c
-c86a545a6e8fe8ac8cec0f3d8d09a82d  opcodes/i370-dis.c
-218308bad0ffc625fd4598939457dc2e  opcodes/i370-opc.c
-387e2ad1c8af4994528669dbca8372da  opcodes/i386-dis.c
-500567943dd17afb74b18cfe8eef5397  opcodes/i386-gen.c
-1ef3cb9f75dff7f27f8347206e5499f2  opcodes/i386-init.h
-b349e449b7242ffccadc2905ba3bf302  opcodes/i386-opc.c
-3fed043ad3895630a1a9a9f824c237a4  opcodes/i386-opc.h
-91158183460e204cd7b516ce0752fd0d  opcodes/i386-opc.tbl
-fc0c918fa8bb8048a394766cea1cc1e4  opcodes/i386-reg.tbl
-96d16a20f53451d48887ceab930e5734  opcodes/i386-tbl.h
-d8620dcd5e29d3eb2e7f62fe494d9255  opcodes/i860-dis.c
-fe5baa0e901f4b050a0efa1c298af1e1  opcodes/i960-dis.c
-b1cb606c1361788d9221ec5fff8965e9  opcodes/ia64-asmtab.c
-da02bae95ce8891a3c3dc5ead687ed79  opcodes/ia64-asmtab.h
-167cf1566aad73895ef32f27075b0941  opcodes/ia64-dis.c
-45fdf781d36808d415ce5adf32e133c4  opcodes/ia64-gen.c
-41e950dec35d001ca963244ffedefc7c  opcodes/ia64-ic.tbl
-61d907892a111d7d0bb5e412953798a6  opcodes/ia64-opc-a.c
-04102fc7c39ffc3c658e8d9c85a0cb3c  opcodes/ia64-opc-b.c
-494774980e817ea25d14c3ad107e5b3f  opcodes/ia64-opc-d.c
-1ba00d5047269068a3737b9be8903f43  opcodes/ia64-opc-f.c
-687f51d9d0a0cfae6e3dc242957b24e7  opcodes/ia64-opc-i.c
-06f24bf672d8e90c18552713280a853c  opcodes/ia64-opc-m.c
-8a1ea104d37994d245ebaf786a3510bb  opcodes/ia64-opc-x.c
-893b74c1d9fec18fb67994ace592d4bd  opcodes/ia64-opc.c
-34c13118bf7c1f27ed2413588449c811  opcodes/ia64-opc.h
-c381105b01ca12a44c06ed3e3bd869ce  opcodes/ia64-raw.tbl
-b3d7452b4310332b7974b34b09f65a6d  opcodes/ia64-war.tbl
-990b6616634d6569e45dbb2c39457a3c  opcodes/ia64-waw.tbl
-904259384c140c5221b718e10d3e5ac9  opcodes/ip2k-asm.c
-1ef97ec52f7f58942668d46f096bef1a  opcodes/ip2k-desc.c
-62473431e909c2d18b86c471d9292503  opcodes/ip2k-desc.h
-c403372026b970047f7cf383b301583f  opcodes/ip2k-dis.c
-4aef13c0815696b318d174105f4a1904  opcodes/ip2k-ibld.c
-2e4bd77935cc7abbace40f5bf50b0e74  opcodes/ip2k-opc.c
-6547e30f1204bd8fcc211932be781297  opcodes/ip2k-opc.h
-7a47bc3fd2a7adf0ddaa636e4ef8be37  opcodes/iq2000-asm.c
-632abe0cf04a62c2a74f0678a683bbf9  opcodes/iq2000-desc.c
-b55a73c5c2f7de45c17e68e430619030  opcodes/iq2000-desc.h
-f37e402c4812585db2a55214bb26cae6  opcodes/iq2000-dis.c
-c2cc76f15e415228de9eb587f33420fb  opcodes/iq2000-ibld.c
-6771c1857f1eef64dcfa6876faef6a97  opcodes/iq2000-opc.c
-d324768327b961a4d00b0b85357ceea4  opcodes/iq2000-opc.h
-6cd99590cdb5cc96648741f375819ee1  opcodes/m10200-dis.c
-6362ae05ee6b6c4c97304f8799d176a0  opcodes/m10200-opc.c
-6fa875346f1ecf4d6769949d0b077238  opcodes/m10300-dis.c
-90d3a0ec76d63a36cc5169ec0cb377f5  opcodes/m10300-opc.c
-13996fcb19622e949671a23f65e1bfb4  opcodes/m32c-asm.c
-5025b7877c644a8508d8134aab173958  opcodes/m32c-desc.c
-cfb2ec0351c4bcbe0aa1ee72f503499c  opcodes/m32c-desc.h
-de0640758fd5eb50e90fe9b085deed6f  opcodes/m32c-dis.c
-fa52cabbe06e1c927d2fb220a835ae97  opcodes/m32c-ibld.c
-9ef80c67b481fc154e7efbf94855a8e0  opcodes/m32c-opc.c
-a5322cba19560d222b06908a3ff328e4  opcodes/m32c-opc.h
-cc8ec90e79ac120dd7467af4e1265bbf  opcodes/m32r-asm.c
-e0c99117dd3ecbb8b80d08c3d86dc036  opcodes/m32r-desc.c
-2ef24bc1347675940f01dc81b97a3fd9  opcodes/m32r-desc.h
-53144cae4da256d59839598aac16a5b1  opcodes/m32r-dis.c
-54188b5725ef9d25b2bc2886e7942d85  opcodes/m32r-ibld.c
-dac53c94af6e76a0d01c681b36453202  opcodes/m32r-opc.c
-2313fe4941fbacb06e29ec3a25904737  opcodes/m32r-opc.h
-b9c537f04116c50ff96c3bb6018fda24  opcodes/m32r-opinst.c
-e9cf6f7e3d7b2fe30060886214c4310b  opcodes/m68hc11-dis.c
-ad9c9708644da65234eefff9c4612b8b  opcodes/m68hc11-opc.c
-df98e1f9eb054585aa8d49850e427ad9  opcodes/m68k-dis.c
-dae7dd85a2570046068493d3315602f7  opcodes/m68k-opc.c
-cfd5f3ab32dee93a9ef1bcfb3fc07e40  opcodes/m88k-dis.c
-d129eed92c6947db4372b285656ef9a1  opcodes/makefile.vms
-82353381607aa08d0214f80b2374196e  opcodes/maxq-dis.c
-3f5af46b942a7ca1babafde70935a996  opcodes/mcore-dis.c
-dfb6033c1b21bfb50445ac029e030465  opcodes/mcore-opc.h
-cd5b3b8663c045fb25cd40cf7dbd4c62  opcodes/mep-asm.c
-1bc564735eeda278bfec049d030fb3ea  opcodes/mep-desc.c
-daec043901be6279d5b47b4f5942d8a2  opcodes/mep-desc.h
-3ebdfef28ad6aacf37ef32a358622399  opcodes/mep-dis.c
-67fae68fb3c376b795180355547fe93a  opcodes/mep-ibld.c
-1c7130a56940b3375e4d7e1261d322ac  opcodes/mep-opc.c
-42313df705003df76eafd1372589ae58  opcodes/mep-opc.h
-88e98f8ffbd27c68f7f2edca380da440  opcodes/mips-dis.c
-fd46ef294e605ac370e97e014fadf850  opcodes/mips-opc.c
-fa97d2c652a7995bbb7f209bfc4b3de8  opcodes/mips16-opc.c
-b35dada4bfb482e98b0d476d6bf1d2d7  opcodes/mmix-dis.c
-91df6c8691104f790688fbdd1d6aaa93  opcodes/mmix-opc.c
-eeae753d29dfbdd7afb3db6ec28ba619  opcodes/msp430-dis.c
-48bbbdfb9d686193abf931f52e510564  opcodes/mt-asm.c
-fbdd95b573287cd99c57560eb131489f  opcodes/mt-desc.c
-fc2321d3b2c4dc075c778a285ff37ab9  opcodes/mt-desc.h
-63655479602dc092c1d0a22913b3c338  opcodes/mt-dis.c
-570b98f8f2a61af9656e3e89052e4489  opcodes/mt-ibld.c
-b1c417de8e88762a362ac23cfa9a7245  opcodes/mt-opc.c
-b09dcba1c1bcf1f8397a28c87ffe13ec  opcodes/mt-opc.h
-1ae7c22f9cca988d66e5da9a19506348  opcodes/ns32k-dis.c
-4dcc09f7483fb5ce2e60064aa9cb71b2  opcodes/openrisc-asm.c
-4ed34cd76d3631bde6af8be4df62e1cc  opcodes/openrisc-desc.c
-e691a9bedbc2b0209fd1e4189ecf213a  opcodes/openrisc-desc.h
-386fdaf90342772aa2126a8909743cab  opcodes/openrisc-dis.c
-099800653758e9553c00b81dad09833f  opcodes/openrisc-ibld.c
-211e7e5485eb6efa3fac012173f8ea64  opcodes/openrisc-opc.c
-b617a649f72248fce5054fa61edbbb08  opcodes/openrisc-opc.h
-3e9ea27f2c97ac18f9d2732f0d3b355e  opcodes/opintl.h
-aa448f84a4250a2a49e802c59d2de4f3  opcodes/or32-dis.c
-2e9653014039eac96ea98f4c1abd251d  opcodes/or32-opc.c
-2e878a17084801b0c09d6edae4e65862  opcodes/pdp11-dis.c
-8386c7c5831239b2635c84ad8266de3e  opcodes/pdp11-opc.c
-7c044dbd081ea712eb68d6fbffe19b00  opcodes/pj-dis.c
-5b71b88cadcb5a40b87df9d7c96a1aff  opcodes/pj-opc.c
-62e82633139e1f77b55d188899f53557  opcodes/ppc-dis.c
-f0b32bb082f0a48bc97b604c91e12fa6  opcodes/ppc-opc.c
-338c1a035a6bd8627ab3afd0f14f08c1  opcodes/s390-dis.c
-5597ea19114bf48f1b17a6322827cff5  opcodes/s390-mkopc.c
-e3fd78fbe481b850c321c3e982722fb6  opcodes/s390-opc.c
-1f5794ea71af0166bae4ee692d058d47  opcodes/s390-opc.txt
-213c6ec6a4b9c6b973b8127e95efcd54  opcodes/score-dis.c
-c6866fcacbd9426cbf9f5885d842758a  opcodes/score-opc.h
-8de937e4e44d23196b526e3a0da6ab35  opcodes/sh-dis.c
-aea44dd53e979c11216c7c3fc7848fe0  opcodes/sh-opc.h
-1e8d73f2511b9b964d33561b64783941  opcodes/sh64-dis.c
-a19107f1f537008ba6f57b9ebef96ef9  opcodes/sh64-opc.c
-7943afc57410d3bcaad658530afc5d9f  opcodes/sh64-opc.h
-d14f54d25324e00a5cf223178dce3707  opcodes/sparc-dis.c
-603d354de59e7e2df41966c3d7b9698e  opcodes/sparc-opc.c
-01e7f445ed905e16f1438fec795fc17f  opcodes/spu-dis.c
-d2cd7ae58ae776e075b0d64bb18a5f76  opcodes/spu-opc.c
-1ded054093de910d9786c62bc4fe8cc6  opcodes/stamp-h.in
-e76f735e3c67647d0e86b5a8ca01061c  opcodes/sysdep.h
-8bc07fab66ea67a61f92d4ccbf9814ee  opcodes/tic30-dis.c
-d8bd324a75e601ace2b2d2eb4a525e52  opcodes/tic4x-dis.c
-9df276fc1e2f700eb56f5cbe57079e55  opcodes/tic54x-dis.c
-cd3bf5fad4de6bb417cbd872dc4cdaac  opcodes/tic54x-opc.c
-0b799451ba231a6be1a404f1d6b2be41  opcodes/tic80-dis.c
-2e9717181f511f0250a11cf654c8d1f5  opcodes/tic80-opc.c
-23cdda3cdd926ab6dc457d7bb998a47e  opcodes/v850-dis.c
-ffccde4e48d32bd36d867af1e61e2add  opcodes/v850-opc.c
-78fa1f13fcdd28f9e41f42fd1a211739  opcodes/vax-dis.c
-4760e70a223de43a1a22033ca2e21dda  opcodes/w65-dis.c
-8d324cbc9101e373aba1cd5bf8362d1b  opcodes/w65-opc.h
-e10c986d4ca34e044cfc001e64e8e89f  opcodes/xc16x-asm.c
-ea8eca1ddd4dd85e24d51f704f721f87  opcodes/xc16x-desc.c
-6cd27ff6ef4e8855c4fc17d1cc177a49  opcodes/xc16x-desc.h
-5afd3ff476138692a118573473c27bd2  opcodes/xc16x-dis.c
-2dc6c6205bfc7beec77ada4d3d28a7c2  opcodes/xc16x-ibld.c
-94874a082e99805585b80e87fb821cd7  opcodes/xc16x-opc.c
-009ffd0851a0429715df1d48ec017cbf  opcodes/xc16x-opc.h
-e1020768833ad866510c6ce3506a8a04  opcodes/xstormy16-asm.c
-a9299432b4d7fa54ae3edca0525ee13c  opcodes/xstormy16-desc.c
-0235fd3b6000dd93df83efebaad0e377  opcodes/xstormy16-desc.h
-e1e8c6fe45fd66802743bd31999dfba0  opcodes/xstormy16-dis.c
-dad71a48c9582453bdbce8658403079e  opcodes/xstormy16-ibld.c
-e82ec067808b6f2cb788afa9b0fb9821  opcodes/xstormy16-opc.c
-7494edcca188a418fb7e50751789034b  opcodes/xstormy16-opc.h
-f0f673238281a16d508540c065afadda  opcodes/xtensa-dis.c
-abe9333f302ab80b8198e33c4113e5f2  opcodes/z80-dis.c
-f8dd23e35b4b2399e99bd3263cad8ce3  opcodes/z8k-dis.c
-f4b9e954666100050db2d4ba293882f4  opcodes/z8k-opc.h
-74cf70291b689f8a0022a94c0df19ba0  opcodes/z8kgen.c
-75e85a221aa0c07daf43bad05f5ebbaf  opcodes/po/Make-in
-41622d5e5aa556164adad07e8d791be2  opcodes/po/POTFILES.in
-6d3b93858658dada9e01f04ea2aa2155  opcodes/po/da.po
-baba2506d17c4e2214d6fdd5868e6699  opcodes/po/de.po
-e02d4eed12310144d4c1532d776e384d  opcodes/po/es.po
-85f81a804cda11af43c4eaee0e432b71  opcodes/po/fi.po
-a57e28d667d8136a39108d891c6a09b8  opcodes/po/fr.po
-3dfb63e38e43f4954de3d9b251ba594b  opcodes/po/ga.po
-195fea77b114bb5405df61cf8bd287db  opcodes/po/id.po
-034f69d7f2a90f71322ffae462bb1693  opcodes/po/nl.po
-af670ca39e5fdf9646b596ef410d5455  opcodes/po/opcodes.pot
-30f5fa421474edf39ae99a8985bd42e9  opcodes/po/pt_BR.po
-27e9fec6ee5c546b5d5f4afb80b287ed  opcodes/po/ro.po
-45db317868bfb202300160e0657f06ea  opcodes/po/sv.po
-8ddcec300546b39bc1d9a13098637b64  opcodes/po/tr.po
-3255cf55b46a5927cb14ca3d225e246a  opcodes/po/vi.po
-5f9e62904aed88b112efa945548f622f  opcodes/po/zh_CN.po
-bb1c7be180e128c17ef71889d8e21d40  opcodes/po/da.gmo
-6881ecf19052fe945c5dfefc588207ab  opcodes/po/de.gmo
-ab90665e8def5852c39ec17b4a5e5e57  opcodes/po/es.gmo
-bffa9fb8319d660135eec6224c329a1f  opcodes/po/fi.gmo
-68cc370681fab9c95313f4ec78b4acc6  opcodes/po/fr.gmo
-5f38487e6feaec725f5be4daa4af1785  opcodes/po/ga.gmo
-b6c960d660ea6c9ef46f51a98cd15d76  opcodes/po/id.gmo
-b01800f503a96e3e026185e6d1d28c3c  opcodes/po/nl.gmo
-1b79e075af1926ef6736fa317f054702  opcodes/po/pt_BR.gmo
-e216f1583ca03a04f8849dfb96b59c3f  opcodes/po/ro.gmo
-d7c42d78dd00ae4c8b71fecb736fd17c  opcodes/po/sv.gmo
-179cd41f0e8af51dd577fd5d7ab36c79  opcodes/po/tr.gmo
-2bd7b97ffb6a298196a7b49ffc9d5de0  opcodes/po/vi.gmo
-35aff368921bb92ebaee91c25b2f6af7  opcodes/po/zh_CN.gmo
-facba8cf28ba2898a1907fcaee497026  readline/CHANGELOG
-40017af5420793322a3d484621554f6a  readline/CHANGES
-03b36fdd84f74b8d8189a202b980b67f  readline/COPYING
-b57a5e72e86b142f6dcacca6f2abff32  readline/ChangeLog.gdb
-16d0d5e08f3e07664ca3e1229f9ff34a  readline/INSTALL
-0033b76eb773dd9025c7c51cb432cbd5  readline/MANIFEST
-157e4fd41cf9f3456c07669274f0ca3f  readline/Makefile.in
-bc3e7db07d55afcbefead9513539fc76  readline/NEWS
-7573975b23bda66935ffd7940fabf52c  readline/README
-0bb4ff5a1ee6f767d0d1b7ded925a8a3  readline/USAGE
-4a6acf519f9fc680d11cad53b5e14a87  readline/aclocal.m4
-5ba16ea9e4b1c5691c974aef544c1061  readline/ansi_stdlib.h
-75c6e2bad200aa3d3e40c563f6ac7401  readline/bind.c
-6c87e572b0a656e5f365384f3bbad394  readline/callback.c
-3278c245b7acd6bf0af6b0cc41dbbb3e  readline/chardefs.h
-24752ab06bbbee3765f042d37ab9374b  readline/compat.c
-562b96984507cfca4f31e9e82016365f  readline/complete.c
-853005368e616a55dd1d9d6c4857a207  readline/config.h.in
-e2e7009cdcdd035c7d228c4bd19a5718  readline/configure
-2b0a4dd8bc9952c2b3df90c4a91cd559  readline/configure.in
-676f5c1c99715a5c0c03f1aa8547c214  readline/display.c
-60a4546c8db39eaac33f4bbbec0f1996  readline/emacs_keymap.c
-13a9a27aad09b465f162e6d99d41c4ba  readline/funmap.c
-ee8b5cd223ea0e5cddd158de9ef9652a  readline/histexpand.c
-6ac2c76fde1f2de38019670acec5c019  readline/histfile.c
-1cdba3464d48009e931fd4bc5d934213  readline/histlib.h
-3eb3748a070318d9d8acc8eda707d509  readline/history.c
-c039d4e54021102088da43f5de8b4c61  readline/history.h
-af426ac23284b488c2d5a153aa5fd9de  readline/histsearch.c
-91b3d49446a6f2ebe666dfc98b1a1f7e  readline/input.c
-ee6f8bb4441747552200bb81888ee42f  readline/isearch.c
-a6bd7ca11fe55ed7f44562e21ae3c882  readline/keymaps.c
-38d541623817bd4dc2758068330590a0  readline/keymaps.h
-c353e892cd5c42b85800d16db8a72a94  readline/kill.c
-2616f708323ebb93530fe2f085e4a54f  readline/macro.c
-7d7cd7eeee3ca4d5d01ec9e0ccc347fb  readline/mbutil.c
-8ebd051df30db0a3197c3c72d7811b3c  readline/misc.c
-7b283b5a69a90988ba9f741f980d8fab  readline/nls.c
-bf658e37af0d52db2c27f2828b5d0a5e  readline/parens.c
-b6e2b7c5e1d65010c056eb4502e8367d  readline/posixdir.h
-ba2252d2626050ddb462015bd5598ab9  readline/posixjmp.h
-be2d0a8b9d9c3dc679f13e886caf156e  readline/posixstat.h
-46ceaac05e176feddd6f7c69b1af28ed  readline/readline.c
-8d671e476fed6b8df87789ec6b71c4ab  readline/readline.h
-09e4df265548342608087435161e41de  readline/rlconf.h
-2c737594d0fb0900c76e9080a388a8a0  readline/rldefs.h
-6ad400a2e353661712c1db75242d13d2  readline/rlmbutil.h
-b979260ce031d4d45c0053bd74ea1af5  readline/rlprivate.h
-aa300b9013a81a43e35516f679addd24  readline/rlshell.h
-0d782ea4ee574ac1767f15094b85d8d6  readline/rlstdc.h
-e691fee9abef655a69eb2729098dc5bf  readline/rltty.c
-382de785c49e05c94db83333f1845537  readline/rltty.h
-23c54c5d057b8f6dfb6ea8a2803e1322  readline/rltypedefs.h
-e8cb411d7338299f99b64c3f5d49ac55  readline/rlwinsize.h
-df9e04636d671daee977af996f8c98ec  readline/savestring.c
-97c8aef64c8a21d86e1c0421019b7cc2  readline/search.c
-03f9a7a027de5a49d2aea3a37c06a800  readline/shell.c
-40dc0b31d6f3f17592d87d1e48703eba  readline/signals.c
-bb45491aeade9cdfe66512671ca8bafd  readline/tcap.h
-6764787a3d104c6ef49ad7e3c5fc9916  readline/terminal.c
-3c9fb02d80d37f3fbaf627caf95af61f  readline/text.c
-bddc171a4d00511acdb08c6f16c0efab  readline/tilde.c
-6125ce9e8d9aad5a97986bd56ae95de6  readline/tilde.h
-21f02193e539736ec12a6544b8889f93  readline/undo.c
-eef096328d19d2d8e77f205c141a80a6  readline/util.c
-aea0011f1ace6567d4d52a1a0681170b  readline/vi_keymap.c
-ca44fd2a2082ea30bc3aefa56de390c6  readline/vi_mode.c
-75a84e2713d83894f93e2d1e3aa87375  readline/xmalloc.c
-b0779f99427cda84ad6a7e60a0b7cd3a  readline/xmalloc.h
-75ad677f6feb3097e69d1431dafd10e6  readline/cross-build/cygwin.cache
-116bc07f3e01af3d29cfa129b42f6639  readline/doc/ChangeLog.gdb
-6a35036a6e8eb045457c02bab1fac33a  readline/doc/Makefile.in
-87eec88509944f0cfd95ca033984a646  readline/doc/fdl.texi
-343c75f89f3392538452e35aa673f9ad  readline/doc/history.3
-49e622eb1811e3f93efb6eb205bcd2a5  readline/doc/history.texi
-02fa54553d32f95441cc6bf0758fe208  readline/doc/hstech.texi
-c2d6ed4bf2ab0ba804a0e4561354ed12  readline/doc/hsuser.texi
-368bfa900f836bfde6ce54b8ddadaf72  readline/doc/inc-hist.texinfo
-e41e839512c79f6d82945566d537791d  readline/doc/readline.3
-438797a8a51146a1ca8f1572dd703b6b  readline/doc/rlman.texi
-00b2a1eb33e94c793a3921fee84295de  readline/doc/rltech.texi
-9e6098aaa15ea2e493e3777cd2496cba  readline/doc/rluser.texi
-2e3595751800697331cf5b2a9d0159e4  readline/doc/rluserman.texi
-c91b35f2c7ea4cca8bbf0ee83b844935  readline/doc/texi2dvi
-1533827bfb0ccf07fdfe9577b4e55a5b  readline/doc/texi2html
-286e98202d4aee431835f53b7f5cb049  readline/doc/version.texi
-40d83063d1bfb64e6f7f9042d62459f7  readline/examples/ChangeLog.gdb
-587fa73058e332ae6e39ef9ad7428e62  readline/examples/Inputrc
-c4bbd1dc647e01df0b10cb9a74e2e711  readline/examples/Makefile.in
-8666715709699f6e24c7d85af2da595d  readline/examples/excallback.c
-4576f906dff3be5f91f6e301eaee5711  readline/examples/fileman.c
-12f5c07ed90343584fa2b8c26266de39  readline/examples/histexamp.c
-fef6c62715bbcb6b842fa69dd1d51558  readline/examples/manexamp.c
-24b0a86fbc0c767a55657c0eeffe3a33  readline/examples/readlinebuf.h
-ea7fe1b44b4a1115732c66c65a73d16e  readline/examples/rl-fgets.c
-9dd8edfe6c273f622aeea4ad2ca87f19  readline/examples/rl.c
-4d33bbc29ffe122fd920c9fec2e1b06e  readline/examples/rlcat.c
-1a44680ab75405e02c58d6a0e4fb3acd  readline/examples/rlptytest.c
-9378bbca91ad2e8ee4d20c92fbe1c374  readline/examples/rltest.c
-23230eb3c3fac3148c0318859404e4b7  readline/examples/rlversion.c
-fd9ea29df3e304482f598fca47ca76c1  readline/examples/rlfe/ChangeLog
-7afa716959a757c0ee15a0328b8db97f  readline/examples/rlfe/Makefile.in
-3981e9f1510b5ba899f5bf79aa28b340  readline/examples/rlfe/README
-b4ebffbf9722b6f57538a3138a319e48  readline/examples/rlfe/config.h.in
-96fd73e6298446a7b4bc13493414df3a  readline/examples/rlfe/configure
-bb250de5053983c79ddfa3f2dbe16985  readline/examples/rlfe/configure.in
-9634c48499c4308f5c991d35101c6781  readline/examples/rlfe/extern.h
-23ccf623352ce5ba7a76aebf0470a30b  readline/examples/rlfe/os.h
-911d2fc32153d0a5992287e0d1016436  readline/examples/rlfe/pty.c
-b17a279841f83d0b88a03b32c5fa9ac7  readline/examples/rlfe/rlfe.c
-f3235e9449b83cf111d88c55da53a05c  readline/examples/rlfe/screen.h
-19ccb820766ec42765731d6c90da3155  readline/shlib/Makefile.in
-dd4451f9cdfc36cdb86703965f758ec2  readline/support/config.guess
-697e549e7b5504f8de63e95a7158a53d  readline/support/config.rpath
-6cdae8120da06ebd9981c7a5a813550b  readline/support/config.sub
-f01cade8404f87f796fee1a0a296092d  readline/support/install.sh
-058be45f92bc8f999144c2c6f5c831a8  readline/support/mkdirs
-b52be3f200cba0442c23371ba15f69c6  readline/support/mkdist
-792922784eade1d03ecb1b33ba8bb7c3  readline/support/mkinstalldirs
-709e2c2cb34ceeceb7c940391e71e632  readline/support/shlib-install
-456a922143c00a8e7de4eeeb271a49e7  readline/support/shobj-conf
-c58f004fea2277f6e472db636b82e46c  readline/support/wcwidth.c
-07c33a285703b40cd6f93a478e97e03b  README
-a656be62d556829e347a5ee13d2639d3  sim/ChangeLog
-9095c84c9ba27bd65a44f294a5cda2c4  sim/MAINTAINERS
-f7a046b449234cdf376ae2f6442ab7cd  sim/Makefile.in
-72ce537cb34d5416875ebff0eab06b9a  sim/README-HACKING
-001107dffe455d34061722225c1793a2  sim/configure
-0d4e8f0388dc1a3a4b8854ba6b82576a  sim/configure.ac
-14bc6ee8b2e2b409be599212867d126e  sim/arm/COPYING
-6a54fd118864e9e2a887d87385119be0  sim/arm/ChangeLog
-3bf5aed86cb34c6b31018f4bd9e28626  sim/arm/Makefile.in
-a62a77605003de7a8ba75d8247fd77b7  sim/arm/README
-a20b31a1cfc24dce8fb7601327fe0c7a  sim/arm/armcopro.c
-4ad759c1968c6f2e3fd7eaa392c0bf4b  sim/arm/armdefs.h
-114976046c7fcdb42851d0915113936f  sim/arm/armemu.c
-7c2851c537f77e06f008793e4684b5ca  sim/arm/armemu.h
-ded7212f9d62ac0997ddcbe1350367e7  sim/arm/armfpe.h
-c69b626b513453d5223b57dffab6fa6c  sim/arm/arminit.c
-64b922cbaef316d578f579d2778e1fa8  sim/arm/armopts.h
-1f9b28083d7ea614929f129c5b0d9300  sim/arm/armos.c
-4127159c4a3261623bce72380a1dd9fa  sim/arm/armos.h
-0afe5554850dc9b1b903ec4c3c60d989  sim/arm/armrdi.c
-64f892395607da5af2ca624f8232c226  sim/arm/armsupp.c
-0261c13c25f58ec5f0dfefc0793fa5d8  sim/arm/armvirt.c
-1b6e842e7008f76204477cd03638711c  sim/arm/bag.c
-f2c0339f1bc254b9a2852a36d5073c01  sim/arm/bag.h
-3c8d00b8cc1ea09ceadc017fb04e3373  sim/arm/communicate.c
-6c63e70994d6749376838b490acba130  sim/arm/communicate.h
-3b4a112254529fcac240d57d948d4d18  sim/arm/config.in
-c56c69aadb94aec55913fb48967d4051  sim/arm/configure
-84d212f244190790b603d10082172755  sim/arm/configure.ac
-8c039053e2def9e4fc910caf4b23ea56  sim/arm/dbg_conf.h
-0f8adbd409f2cc2e5d2fd74104196b39  sim/arm/dbg_cp.h
-c8b47b00060bb7c0c2fccb5716d7dbbf  sim/arm/dbg_hif.h
-9736491b1b70cd7fada031570bdcad8e  sim/arm/dbg_rdi.h
-511adfc39990e1f59846a517ffc5f8d2  sim/arm/gdbhost.c
-a5c768768f460eea56e86a6ea3a322d0  sim/arm/gdbhost.h
-4538035b44d9b31dfda69705d1f4bdf8  sim/arm/iwmmxt.c
-aea167251a19a40eb2f6caf2367d015a  sim/arm/iwmmxt.h
-80dbc3fdd45227ac41bd32f2d129afda  sim/arm/kid.c
-f114cae5e3079ef54c4f6211135c7b82  sim/arm/main.c
-60dfb50c28176fba0319108d9baf4687  sim/arm/maverick.c
-b7b9aeaee9f61608836d2192e5f9d2b3  sim/arm/parent.c
-954e1b0a1dc87a295e02d42020117638  sim/arm/tconfig.in
-e94963f48831b61c449faf5f53b36f27  sim/arm/thumbemu.c
-7f8e6a7ef69c704b7894da072248563f  sim/arm/wrapper.c
-44f4df9c745f91a22ecae07ad06446de  sim/common/ChangeLog
-0744d9678dcf442bb2294639f488bd40  sim/common/Make-common.in
-c21cff3a676385d175698d165ddd7234  sim/common/Makefile.in
-069e544edd29f20ff81c8390f2ef4f32  sim/common/aclocal.m4
-08152d67908e5450faf6117f9b565e04  sim/common/callback.c
-794c6e8c2a5a008da07306a22ddf43c8  sim/common/cgen-accfp.c
-056f124179ccc4132cd5db071952b0ed  sim/common/cgen-cpu.h
-a133cac0a4c6cf8cde1cc28809b47f80  sim/common/cgen-defs.h
-3e68340103087620ba24de8632829065  sim/common/cgen-engine.h
-ed8b05c07d34977e0e69ce33032d809f  sim/common/cgen-fpu.c
-8149048d71beac8331d23655b2ebe540  sim/common/cgen-fpu.h
-ff0c794cbdfd37e2930e0217e3962b36  sim/common/cgen-mem.h
-3de9ad7d5eaf2acdf24af01d7d725d74  sim/common/cgen-ops.h
-e0dc692facba4f19af7f949cab823600  sim/common/cgen-par.c
-675390a2c4d51fbb105b016d0aacb97c  sim/common/cgen-par.h
-4ca50875aeecfa4237d0b233f2025cea  sim/common/cgen-run.c
-4adfc54bda82696a06b2d546c3acd23a  sim/common/cgen-scache.c
-23ba1dab04c4ff3e6468be3afc0201b4  sim/common/cgen-scache.h
-d59d4c2fcc565af81d8784c17748bd2e  sim/common/cgen-sim.h
-5d6fe9649455301f13be031b840845e3  sim/common/cgen-trace.c
-00ce5f26283641f7e8f7006d2f93f2b7  sim/common/cgen-trace.h
-8bfe2faa78a59b8d34db80c08228dd21  sim/common/cgen-types.h
-2440675a57c7a691f4a56498a400ae20  sim/common/cgen-utils.c
-0bea0955e000e01a5ee67cf755bd93f4  sim/common/cgen.sh
-0e828ba45649a0b4ded6943c251c39f2  sim/common/common.m4
-6ff876ea8d0edcf5b4edde44b7fe4982  sim/common/config.in
-0f03391e783a2cd4d3e22635b29a131a  sim/common/configure
-e9387dd313fd2189463dde5c9d8c2a91  sim/common/configure.ac
-248bec4977a8941787edb48f79bbf040  sim/common/dv-core.c
-4ad9126570952f401fb9752d4278bbe4  sim/common/dv-glue.c
-0d203b983b6cd320d0265f40700f0d20  sim/common/dv-pal.c
-3cc09725a93db0053f11fa8e65b8a330  sim/common/dv-sockser.c
-59130191a829b740e79fe6a69f0d8121  sim/common/dv-sockser.h
-4ac4de2f5cbaa78e805d696918722ad1  sim/common/gdbinit.in
-2f93fa5e8c226b7fc9519494353011b7  sim/common/genmloop.sh
-e0691ba078ee06b3827945ab5cf5091a  sim/common/gennltvals.sh
-2281f5fa34ad8e9cf673469a424e676f  sim/common/gentmap.c
-0cd5aec0350eb378abd59b9e9c5050e3  sim/common/gentvals.sh
-715090571caf7c540348130baba4aaed  sim/common/hw-alloc.c
-4b546e4bd9507156d93858e2299a5a44  sim/common/hw-alloc.h
-856e5611cd528e8a7244d888a4ebbfb7  sim/common/hw-base.c
-9ce0d48c3e3a22ed15d6e81cf8f0aa7d  sim/common/hw-base.h
-e65941db99bc25655d0ffb39d50818d9  sim/common/hw-device.c
-e96e4db106eec74482049637d3aedd7b  sim/common/hw-device.h
-1cdcadafc48e02246bf37b30a0f60246  sim/common/hw-events.c
-cb04af36e17b451931241a9680a81a73  sim/common/hw-events.h
-33af6dbbf16162e07fa854a1733f85c0  sim/common/hw-handles.c
-cd1dcbea32f70e8fef8470510e02658e  sim/common/hw-handles.h
-ae441276f518d234bcf612d9bfa5ad67  sim/common/hw-instances.c
-1aacad9f6e894d7510e236b40cd36170  sim/common/hw-instances.h
-e7755c33c513899fdc5af2ab8d201986  sim/common/hw-main.h
-d1dee724c89dd28f7be7f9147b6ec99e  sim/common/hw-ports.c
-d65db8cc0c7227e86baff97f2926fea1  sim/common/hw-ports.h
-ddb5eacc79fbb0bfde966cac30433abc  sim/common/hw-properties.c
-d03f3793f48ad69a8bf442e77799bd11  sim/common/hw-properties.h
-4758c3933808f62224487e5a476298f4  sim/common/hw-tree.c
-856eeb9427492bcad9acee7e571c8950  sim/common/hw-tree.h
-fc555cebdd7df0a92d3b6ec6480a89e6  sim/common/nltvals.def
-f9bd7f302e895185d5a1604c86723388  sim/common/nrun.c
-a796a5e1a0889ae76c35087c87b8685e  sim/common/run-sim.h
-685c7e3a259e9ea674a11b8dc51b1be6  sim/common/run.1
-30a938256f85cc1f6e6777fbf9323b70  sim/common/run.c
-9b77d53cd41c68dce707c3bdd8b52b78  sim/common/sim-abort.c
-7137591aa0260f26736550f9aeef4d0b  sim/common/sim-alu.h
-5e8fae4c8536bca2a2503370b9fa5951  sim/common/sim-arange.c
-67b1aef55802bfa12f40d4b3bb21374d  sim/common/sim-arange.h
-87de8bd6ec21e3d048b63cea5398636f  sim/common/sim-assert.h
-c24f74b29afaf3b4dbab321094348288  sim/common/sim-base.h
-75f581d30c24cf5335dca196330ae6ea  sim/common/sim-basics.h
-dc34bf9981025dab33885569dd4ad6eb  sim/common/sim-bits.c
-24ba5b4addf122f084f6c40b03e27a5a  sim/common/sim-bits.h
-2580b51e9e4f8e259d383ef27cef0bab  sim/common/sim-config.c
-18bc1165aeeb2a2112bb72b0090dd300  sim/common/sim-config.h
-0b04085213d839ac347437170509fa87  sim/common/sim-core.c
-39f7a2a990dd6537685de927b514623a  sim/common/sim-core.h
-0c9d0987aac8c394db9ed6c866233c87  sim/common/sim-cpu.c
-456fbd4f7802f6dd4ff8bf5eac194ef4  sim/common/sim-cpu.h
-7d8201eb93b1d64af1305f616603b96c  sim/common/sim-endian.c
-de3f68cd07216e1dc88951eb5f025fb3  sim/common/sim-endian.h
-6960257b33b9cd826faa9c084e948f87  sim/common/sim-engine.c
-4f18c3fde0d805383863363012247a92  sim/common/sim-engine.h
-1708bfd02f481196cc8c6fc4a65efe8d  sim/common/sim-events.c
-6de4568cc871da8065bd3a9f9ef9ff20  sim/common/sim-events.h
-4bd362e07f66cc4b558a45243dc9f54c  sim/common/sim-fpu.c
-64b7532d34906080d18f6ececf0cd8ba  sim/common/sim-fpu.h
-87248e0611fb58dc4c831f8952c88b2a  sim/common/sim-hload.c
-3590d8ae45a544106755da7025a934d0  sim/common/sim-hrw.c
-d05333fd7333251bb0261e075f3493c3  sim/common/sim-hw.c
-d58b90cb7aca6a126361d17c691fdba9  sim/common/sim-hw.h
-d6ea87b3537dba6130db80c75b73f74c  sim/common/sim-info.c
-5cb3b3eac5a38d53f5eb640b91f285d9  sim/common/sim-inline.c
-fe71bc314232dcd769edd5a096de041b  sim/common/sim-inline.h
-aecbd773c236a38000dafa66871b90c5  sim/common/sim-io.c
-21cfffc33b0b98ff1992ed1f78b2d5d2  sim/common/sim-io.h
-22cafa8aa3a57781d1fbeb32d290c72f  sim/common/sim-load.c
-ad7c6df4052b7866f54796f286b36c6d  sim/common/sim-memopt.c
-73a123417f2046331d9110c1c88952d3  sim/common/sim-memopt.h
-6db2c00e051ba8f537287fed88ac3430  sim/common/sim-model.c
-0e38f2916fe8ad5b1143096fd0170918  sim/common/sim-model.h
-757a7e92f7c033b5d3163658aa47ca35  sim/common/sim-module.c
-a5f32912834e7e2d2c1ee9a4b2ed6a05  sim/common/sim-module.h
-b003ad410d20f4d74d4aaaba08e9bd33  sim/common/sim-n-bits.h
-932d3ec999c394bca50ca2feb2ad9a84  sim/common/sim-n-core.h
-a259c4b522570f59dd607ab336b41646  sim/common/sim-n-endian.h
-9a372c6deba534d39620a1367dd70323  sim/common/sim-options.c
-31eec1b087c8de95098e140e3cc1034f  sim/common/sim-options.h
-991f2356b243b30b2c057bedf9b6f175  sim/common/sim-profile.c
-5b7c21bc00ddd51f14334bdcd38846d7  sim/common/sim-profile.h
-4c90fb98076b021802756238aa71392b  sim/common/sim-reason.c
-89ea087b3917705045091a1f622873f3  sim/common/sim-reg.c
-ba9268c4ffefca5191227627aa2d0955  sim/common/sim-resume.c
-d8061deffae7d8866d83a95107c4f5c8  sim/common/sim-run.c
-2f5c8c9513240f25785f334816b73466  sim/common/sim-signal.c
-72c9d162b1636436ffc1e30f0a9adf3d  sim/common/sim-signal.h
-2f0663beec7e545b971c12b48a90fb7f  sim/common/sim-stop.c
-d24a80ad4ae3b39840c5bacd94ab9907  sim/common/sim-trace.c
-d04233cebe313f6972cd0fb81ab6dfa4  sim/common/sim-trace.h
-fce69bb781fd2a687662176049b9f260  sim/common/sim-types.h
-338fd9f5d16e39199471bbb218980c7b  sim/common/sim-utils.c
-2b152a6732347372ca3dfc30ef501e03  sim/common/sim-utils.h
-2cd8b621e948de5bad55bed9f8ddfba6  sim/common/sim-watch.c
-c37527810c11d517b5e1c5296b72f0c2  sim/common/sim-watch.h
-7dfaa6ac90ca92b5ebd06388de14d014  sim/common/syscall.c
-bd5c87daaac42725e636fe648650fc7c  sim/common/tconfig.in
-cbd8a9966d1c27964092d6c3186d6ca8  sim/cris/Makefile.in
-19447013671477ccf549f962d70577af  sim/cris/arch.c
-a55ae0577ed7de3e8b9a9ed2ff9d504c  sim/cris/arch.h
-06b10361cbcaf957fa583758c33af6ba  sim/cris/config.in
-521177248fe36f85b73aea425a206810  sim/cris/configure
-dda7f57a919ab84abf58368736669f5a  sim/cris/configure.ac
-1b87ba3bce07e5507bb324201ee4e1c4  sim/cris/cpuall.h
-fbad343e8945530bff4cb391f779c34f  sim/cris/cpuv10.c
-70fe5b5c353ec60091964ccd0d93a3be  sim/cris/cpuv10.h
-f2391eefb3e66bf9a8515e2fad499d68  sim/cris/cpuv32.c
-31bab4995877f20c26416f7ae9a26456  sim/cris/cpuv32.h
-875f73518af2e95b585afbf97295d8a5  sim/cris/cris-desc.c
-ef0d2db63a88a7635b4c3994fad769bf  sim/cris/cris-desc.h
-ed8f9fdaf361b23ac9f809354f6ee84c  sim/cris/cris-opc.h
-0b172da9689f97c99af6565dd4eb5ad0  sim/cris/cris-sim.h
-9bc9e97604e53f5d47e2dcd4a5d7dd91  sim/cris/cris-tmpl.c
-5e736fee9b25c827c247474c6f71ea2a  sim/cris/crisv10f.c
-7c31a79b52d906dda8d865f9a871b87c  sim/cris/crisv32f.c
-3344c2bc9a2fe343ec9c39e7b9f74dd6  sim/cris/decodev10.c
-9cada119aec76ff051cb7f5a477e13a8  sim/cris/decodev10.h
-0cdf5aecefd4d85b01a264d6d0794c25  sim/cris/decodev32.c
-ff68cfc66d03442debd28ef9396196e1  sim/cris/decodev32.h
-a15b1cd87bea8b15781cdd7be79cbac0  sim/cris/devices.c
-0d2adc518cb9a779131c4faf376db9d7  sim/cris/dv-cris.c
-f76b5812ddd92952cf889fa441276ef0  sim/cris/dv-rv.c
-0da7661609d501905da2b85ae6e0841b  sim/cris/mloop.in
-8a84fa9dabb032823f612e9faca25c73  sim/cris/modelv10.c
-1593ed0f46b5ec6202c9ae02012f2fe5  sim/cris/modelv32.c
-7b0931b192e787ee848ca2d2b3e72d7b  sim/cris/rvdummy.c
-63d4337c9f60b67bd02abbe2b7bd6e61  sim/cris/semcrisv10f-switch.c
-e4fdf61f13a31ccf05adce2aea829f4d  sim/cris/semcrisv32f-switch.c
-5b1e2c58566ae47c302994b5490f2f84  sim/cris/sim-if.c
-a892916a8848bd4baa4c476431acac78  sim/cris/sim-main.h
-c3fa8bcdab06c434d9a74b4f3dc135ec  sim/cris/tconfig.in
-b696982a96a66132331342a178fc4d6a  sim/cris/traps.c
-41e3504113488d0fffec7f7c2cbd8705  sim/d10v/ChangeLog
-65a11700dc333aa218bfebea59ae503a  sim/d10v/Makefile.in
-3b4a112254529fcac240d57d948d4d18  sim/d10v/config.in
-019bd36ffe74f9cbc88f1efcbbdff249  sim/d10v/configure
-b69d9273edcca83cc240dd642b9eef5e  sim/d10v/configure.ac
-986e8bfc01b0e0cfe1be748f55d862e3  sim/d10v/d10v_sim.h
-7cf4cd44539377c57e6d64f3715397fd  sim/d10v/endian.c
-4dda487eecd2318dd4c38275683196c8  sim/d10v/gencode.c
-2f080b6beac1b2173c789eea402c6a10  sim/d10v/interp.c
-be35730e9f08c186e180c980154411b4  sim/d10v/simops.c
-631ab8d5f224be1f15355948aa9d169e  sim/erc32/ChangeLog
-105e807eda58da28a9820c9588941817  sim/erc32/Makefile.in
-9f2cbd625dfef51b3d1162ba9dbb8a4f  sim/erc32/NEWS
-72fececbe452af10d0adb31b037040dc  sim/erc32/README.erc32
-ce58de7fe1b8736ff94d663cb47bcf4a  sim/erc32/README.gdb
-8d0b5212c0ce4ec7e01d67b407af3ba8  sim/erc32/README.sis
-3b4a112254529fcac240d57d948d4d18  sim/erc32/config.in
-69024b844c5ff1a7c18914ee38fc3962  sim/erc32/configure
-49365eccb96f6e4558685f06ff63fe20  sim/erc32/configure.ac
-fb82f2de8f5ca5a041a8f5a0c8536984  sim/erc32/end.c
-5f964603ecf383d79bf916cd00e3c524  sim/erc32/erc32.c
-7d54dae354889ffcefb0514fd4ddb55b  sim/erc32/exec.c
-cd61f3c64f81cf4df13045a4542d2423  sim/erc32/float.c
-4d1a12e5fbe41bc246aa1a884268f1b0  sim/erc32/func.c
-5d55e685281806e6fb65aae7ea51a36e  sim/erc32/help.c
-0240c310d1c40997b34b61475587e21b  sim/erc32/interf.c
-035eec13c0ba5d97797f2c2751d852ba  sim/erc32/sis.c
-4e9b2b2599387377b967a67f46bb6f6a  sim/erc32/sis.h
-e7a02f18ba69be1512d680e05b4c44da  sim/erc32/startsim
-80ffae75e339af301cabe5e6eb205139  sim/frv/ChangeLog
-26896cac9748846e88a76db3edb1b383  sim/frv/Makefile.in
-1dcb16936dd94db21e5b82f208506a6a  sim/frv/README
-4327df77a7932a933cf53cd14051fdc0  sim/frv/TODO
-56d709141d6a5bd8596a6f5011b65087  sim/frv/arch.c
-f00da7f3f6fe0527bd421a98115b54a3  sim/frv/arch.h
-8852c2ac5e6a59f0265b622be24e03b3  sim/frv/cache.c
-3254eab813257035852ebf7916d262a1  sim/frv/cache.h
-053f1c67a2e7193e3d2e26f8fd93b60b  sim/frv/config.in
-926d86c683a7796609bb5dc20188fbf8  sim/frv/configure
-76fe59a932bffa0e975b911d4eba2065  sim/frv/configure.ac
-93dcc08d831d47c166a9028dc2ca2c10  sim/frv/cpu.c
-423797d8e4d574f2e561fc83cbc0e0c7  sim/frv/cpu.h
-cc4677337a60fd0a8fc5a11146039c87  sim/frv/cpuall.h
-cbac88fa174fbcc30687dfc22a375857  sim/frv/decode.c
-1ea45cf3c6528961056bc654f365e4fc  sim/frv/decode.h
-475e5b6496e094182cb251dfcc8a9bda  sim/frv/devices.c
-ce3ef514e55577266ed8072641492f62  sim/frv/frv-sim.h
-e232378ef4af8f9053636401d3624daa  sim/frv/frv.c
-b6b7ff76fa7b11e623d22e763d4e5be2  sim/frv/interrupts.c
-c2d7aef622d3e6303f442c22172ac0dc  sim/frv/memory.c
-bb1a41c57164b4177fb42cc2d44645e0  sim/frv/mloop.in
-73ba42022ad78db0d40138ff32d7ae92  sim/frv/model.c
-c13024f8e14737d1ee2fe0aa33d18971  sim/frv/options.c
-d50d7119d3e582dc49ecae8c4036d70c  sim/frv/pipeline.c
-be93653d19e6970205d64d9fac4d7f0a  sim/frv/profile-fr400.c
-d66bede69b9ea781387ac21cb582a150  sim/frv/profile-fr400.h
-4ec05d0484f7797584f92e65579c51dd  sim/frv/profile-fr450.c
-8cfab0c2e401aa49b44468326026bcc3  sim/frv/profile-fr500.c
-282786d8bb53d4a62d457383dbb64081  sim/frv/profile-fr500.h
-95db6dce0ade91b999ce625a0d8e410e  sim/frv/profile-fr550.c
-e54bf854edf61647f596c6ea4ae67885  sim/frv/profile-fr550.h
-7eb424a51ceaa76581c331f7d81816e3  sim/frv/profile.c
-e20c882b1f0d3dc9b47af5fbdb79dcc0  sim/frv/profile.h
-113d30eacfcbde2050aa3573b094b69d  sim/frv/registers.c
-8c1edf8f17390a5125a0117fc1536a72  sim/frv/registers.h
-064db7fbb8e6b067710cce1142e63158  sim/frv/reset.c
-3d08588d37c9eeef28beef8776fc3c2d  sim/frv/sem.c
-06b951ba7ced38a4309369f9fd582390  sim/frv/sim-if.c
-1bcb42e0f7caba1b73cc9376e4a04f8a  sim/frv/sim-main.h
-87e1b2f71a8938597514fda93676e466  sim/frv/tconfig.in
-4c7b028e76471ddc6c9acfb78bd3f5ca  sim/frv/traps.c
-9c24e061cb3ed917e0658eb088d4fd7e  sim/h8300/ChangeLog
-44ed3ff1b91b45729e3a2d7e1e866fac  sim/h8300/Makefile.in
-08fac4aa238ef4faf52bbe1f1080891d  sim/h8300/compile.c
-3318e1f9e456eef6cad8b2c1f188843b  sim/h8300/config.in
-32dcfbe2d8ffbf1cb5e669c46040164b  sim/h8300/configure
-467236b0b2e3746f421bae1ba668e9f6  sim/h8300/configure.ac
-c5fc0ac18cf227f20bd9e218f219d811  sim/h8300/inst.h
-57ddd7ec6dc75f46110af89cca60a0a9  sim/h8300/sim-main.h
-f180a66ef231f5eabfe450962b4225cf  sim/h8300/tconfig.in
-5a198f6b19aed858570b289330bf44f2  sim/h8300/writecode.c
-8e92404a1cfb2a100b26a0bd42b67546  sim/igen/ChangeLog
-63e236cf05ba41192f3c87dae5fddb34  sim/igen/Makefile.in
-fab3960be65bd4e039456fe09b3a22ad  sim/igen/compare_igen_models
-0de3ee334acce1efb307af65ce3ae23a  sim/igen/config.in
-72431778f34ba1f3e0912b6d76634ef5  sim/igen/configure
-24c562320dab1ac654b448e05ce4624f  sim/igen/configure.ac
-a1d46165fca0b313536f56606805e45c  sim/igen/filter.c
-198e8bc3fa88dcfb193bb65409847521  sim/igen/filter.h
-ae442e18363158bc95b346e3deb575a2  sim/igen/filter_host.c
-55311906bac8aa688154b7340b7e1351  sim/igen/filter_host.h
-66b67556db2b5131ef7699e785b02756  sim/igen/gen-engine.c
-1a3b48793cb657f53f2e975f9df56fb2  sim/igen/gen-engine.h
-94042807a950daf1df0bea78d24eba30  sim/igen/gen-icache.c
-eb3c79a1fe8272846f9aec0dc8f93775  sim/igen/gen-icache.h
-9f9f21573dedfae0f960f6c7dc999e42  sim/igen/gen-idecode.c
-a7931f0a3f4f602920967fba8f653b32  sim/igen/gen-idecode.h
-0818ff6b68f30cdf6344c32d5f47b452  sim/igen/gen-itable.c
-a2c8deee7c4038746fda08571158166b  sim/igen/gen-itable.h
-5398f1d56af7000efae370e4056a4e1e  sim/igen/gen-model.c
-c1ebe0a1bcc13577c8b8094ad7cb6c45  sim/igen/gen-model.h
-ee6251b7888a4f43645778855086697f  sim/igen/gen-semantics.c
-773b720083e908b3dc8a2106e59bb2c2  sim/igen/gen-semantics.h
-888fea875dea0d623ae78d1f8f2c6e70  sim/igen/gen-support.c
-f5e3a13451514e52a8b11ce3facbda87  sim/igen/gen-support.h
-c5278b8d66575dc067927b1700b41ab4  sim/igen/gen.c
-91f1a14241ba458add3d34e5b19fa5d7  sim/igen/gen.h
-8891ed11f59db3c8d7c9a1a29951d10a  sim/igen/igen.c
-066bbaee53aa7a17cefd418f0daba782  sim/igen/igen.h
-54863ff305ce99379b6b281aa79e1659  sim/igen/ld-cache.c
-a1e9d76454c6fd2ab4d98d19b6d89c2b  sim/igen/ld-cache.h
-fbc83c407c3cdd4e76cbeca75726c291  sim/igen/ld-decode.c
-bb667592613cbf51a9e7102b2af464ef  sim/igen/ld-decode.h
-6deaa98869bf91c1b4336189613bfe65  sim/igen/ld-insn.c
-2f990a41095f7f0899d6a167cfaccd0e  sim/igen/ld-insn.h
-1c19dc7c9af84e07c7df09802073d100  sim/igen/lf.c
-11bc01db1d74519edc4e754f380f2ab1  sim/igen/lf.h
-cc55f41d3ca9e59edefa66da8e628a13  sim/igen/misc.c
-d122797076903ec754e7d2e54173918f  sim/igen/misc.h
-7c71db2434904c664abba098c523a373  sim/igen/table.c
-eb54304fc64b5c223a3d3f21a8267b6c  sim/igen/table.h
-e066e267bf758bbf4ca5b481aa1e3f75  sim/iq2000/ChangeLog
-f7a73307eeae799bd575d3d32b9ec3ef  sim/iq2000/Makefile.in
-dca5ac78f825cdbdf891dffa338c2678  sim/iq2000/arch.c
-e4dce8abddc10a94dfdcbb2d5523c944  sim/iq2000/arch.h
-053f1c67a2e7193e3d2e26f8fd93b60b  sim/iq2000/config.in
-05a4362a0dd094b8d7c0853a9e9b7397  sim/iq2000/configure
-6490ec17b5e04338a51730fb4e9d1742  sim/iq2000/configure.ac
-39c18263efe90e28e0f918c4b60e9021  sim/iq2000/cpu.c
-3d7c1e7fe46f22b2b5691ef28e62db91  sim/iq2000/cpu.h
-7b95afce49ff47834c44d3ac7f4b7eb5  sim/iq2000/cpuall.h
-a43890e772b0e623cb32b6b6b8c066b8  sim/iq2000/decode.c
-d7a4fdf4ae3c87a35fa01b39f479a490  sim/iq2000/decode.h
-3456621dac61f6b6ac7ea3fcbb6fafae  sim/iq2000/iq2000-sim.h
-ed38a25c146e52280bc97353bee134f8  sim/iq2000/iq2000.c
-fdb7b69a8a2746509bc4242cbe5430fb  sim/iq2000/mloop.in
-136621ee6aa6b0450f7c0380bac50a4c  sim/iq2000/model.c
-ce5e207126552663f5ef050a81fc982c  sim/iq2000/sem-switch.c
-072fb58df1c8722127b700a65c3bcc7d  sim/iq2000/sem.c
-1093d25469e1aa65768cde06cb9da78b  sim/iq2000/sim-if.c
-aa1461ca5a06866e1b574bee397435c2  sim/iq2000/sim-main.h
-696a9d79c383c9b3ce4655d27f5948e8  sim/iq2000/tconfig.in
-c43ea98a60b7781c65c66b3a4da3a7d2  sim/m32c/ChangeLog
-60ac5ce6d42a3d4b583b567c798e6f59  sim/m32c/Makefile.in
-369ab7ded7255b02db141082c3a26043  sim/m32c/blinky.S
-d41d8cd98f00b204e9800998ecf8427e  sim/m32c/config.in
-d349a6c1fd691adfd8aba779bf0106f7  sim/m32c/configure
-e9c1b658e95eeff30dd9f67eab03ac19  sim/m32c/configure.in
-848f3d614fbb2013dc5b024319a2e6e6  sim/m32c/cpu.h
-e35033e442452894be0a4de2824ddc0c  sim/m32c/gdb-if.c
-86efbbe1a87100639c518610c1735579  sim/m32c/gloss.S
-ca36ed25d0ca8d20e5ba36877ab0532a  sim/m32c/int.c
-f579eefcc9304cdcf8f96aeff685421e  sim/m32c/int.h
-724e4b548f7ab5c2b6f039467b617954  sim/m32c/load.c
-6e1e89009eb5d19dc8b38bf58c6a6450  sim/m32c/load.h
-78cc7949925c47d1a5345784db79e134  sim/m32c/m32c.opc
-40cfb0ba489d2be8859e0c4b2a16c1d5  sim/m32c/main.c
-ad9bb6971d81098abe09d1ea8e94fa3f  sim/m32c/mem.c
-908c56902c82a244212ca6c42997bf0c  sim/m32c/mem.h
-43b0f924886b9ecdf4bdb7151e0ed117  sim/m32c/misc.c
-06ec88f1ec230b4d69ed281f6a540315  sim/m32c/misc.h
-2856afab971e92b2e729b1c066db3999  sim/m32c/opc2c.c
-fb41b8ac1843ed73d97b482f24255d46  sim/m32c/r8c.opc
-873b46ab058bdcb4d9f7d8a2ed35dcca  sim/m32c/reg.c
-55ed1d68d4f7be6d5739ae72d6159a1c  sim/m32c/safe-fgets.c
-5bda7bb2b2a90d9380488949e8af996e  sim/m32c/safe-fgets.h
-cf68ccb0971fc7e3a3e203767ed21e51  sim/m32c/sample.S
-2ec80b31a9ed00feef14901694040972  sim/m32c/sample.ld
-23d252e46e76bafbed3aac9b045e7790  sim/m32c/sample2.c
-d159a29a10ebe82992f2b90f394b9e4e  sim/m32c/srcdest.c
-24e2f861da06951620983b5a9ca6efe2  sim/m32c/syscall.h
-5a59ce75734357b0dd7f63339ad67d1b  sim/m32c/syscalls.c
-36e479604a49913d42d42f96778e3b0a  sim/m32c/syscalls.h
-91e853daccac33d97458395c95d414cf  sim/m32c/trace.c
-b53b921ef5f580cbfecbb5decd570762  sim/m32c/trace.h
-d0d0029a9a35e7b495a791508e1fe37d  sim/m32r/ChangeLog
-21dad0f59ba2ec8b689fa88ed962a156  sim/m32r/Makefile.in
-23b6e82d29f42c31a097d431b0f73004  sim/m32r/README
-7aa7d02d4d195447e0ae6c176fc6ceb4  sim/m32r/TODO
-21f4ccad60649fc0beb672f7dcbc0e9b  sim/m32r/arch.c
-21954afcfc9dedcfb9b30f8cf0398028  sim/m32r/arch.h
-053f1c67a2e7193e3d2e26f8fd93b60b  sim/m32r/config.in
-bd97d7539129df27de1cdcd446f0ada9  sim/m32r/configure
-4ee0d93e6193bf7b24624a7c6570daaf  sim/m32r/configure.ac
-5981e23f81076db74346a7e105d7f080  sim/m32r/cpu.c
-3783fdc9608491bf34e5268cae09c21d  sim/m32r/cpu.h
-346659d14ccc2afb8b5e79f9b98a7b25  sim/m32r/cpu2.c
-f7b92937b9e0f04fe119435a57ced746  sim/m32r/cpu2.h
-f4ad2ba519f27cf1c1a1eb039282655e  sim/m32r/cpuall.h
-ee0362e82bbb5a9cc1498fe8687815f9  sim/m32r/cpux.c
-5bceac4a95d1b71ff1f29fd1c543b21e  sim/m32r/cpux.h
-499a9a497f845832291187a2a67eb831  sim/m32r/decode.c
-69c5e2d5f2a90228efdde003f769b2cf  sim/m32r/decode.h
-aef86abf7014a0fbd8d7f905a1860eeb  sim/m32r/decode2.c
-de639252aad92048d7e71131345140a3  sim/m32r/decode2.h
-43b7c0fbf4164c2605b85fcdb901e322  sim/m32r/decodex.c
-6c9102fb663d162bdb33577baf3d03aa  sim/m32r/decodex.h
-c25a7766f7bc2e68920dac6a280c0c87  sim/m32r/devices.c
-fbb608eb36b427b916eefebabf08300e  sim/m32r/m32r-sim.h
-8bb38c29209a6dc26acccc42208a80bb  sim/m32r/m32r.c
-dc00d5e7e53f3221da22d56bbafceb44  sim/m32r/m32r2.c
-cc882fb43ddb6b794086384472d96b94  sim/m32r/m32rx.c
-871dbcbe81927b021032d6b63b9b9b8c  sim/m32r/mloop.in
-f334944da5cdd514c39a13b21767ceb9  sim/m32r/mloop2.in
-bde96cc9f16b9d7c27492260ac78adaf  sim/m32r/mloopx.in
-065d0e6f567870d43f9031f7d0863394  sim/m32r/model.c
-7dc2e50d34cc3d9f1aed0b5a8e78153d  sim/m32r/model2.c
-76b4c19ae5b19cf6bd2ae185c9ef8e9e  sim/m32r/modelx.c
-a8892220f49486859dbd2d5957da1bec  sim/m32r/sem-switch.c
-5763569ff86e4b846f2aba44e741c61d  sim/m32r/sem.c
-11c63869e34c341a17f4da439462b0a6  sim/m32r/sem2-switch.c
-e35685305e42e42067f7212182a493ef  sim/m32r/semx-switch.c
-17ee3da9e8e56c61a8c9d5d1149463ea  sim/m32r/sim-if.c
-a24af2c954c1781817ac3519604b8e37  sim/m32r/sim-main.h
-e401ce81778d171f79151b58eeef8bb0  sim/m32r/syscall.h
-e962644fafd12290fbf81ebc5bf75941  sim/m32r/tconfig.in
-32f6ff955cff3d0f08b579dd8dcf6837  sim/m32r/traps-linux.c
-60d5263c0f550aa28094e92d6add930f  sim/m32r/traps.c
-2153a1a7d4e661efca1f7c53e95b710d  sim/m68hc11/ChangeLog
-b1b19676be0ae3e07a41844445713ae5  sim/m68hc11/Makefile.in
-053f1c67a2e7193e3d2e26f8fd93b60b  sim/m68hc11/config.in
-1493462865258a9178687b2baac2fc5f  sim/m68hc11/configure
-5870475043f63b0dd86c4b505241907e  sim/m68hc11/configure.ac
-cd7fc2a64b0cb080fa63a3ded8ba5b47  sim/m68hc11/dv-m68hc11.c
-f4446b1d91907c4c0da6fa8b6e6ecc21  sim/m68hc11/dv-m68hc11eepr.c
-0c36f0cc82dfe45e6bd5e650e477e9ae  sim/m68hc11/dv-m68hc11sio.c
-f9fae5a5d3b44c38387210cf8b722459  sim/m68hc11/dv-m68hc11spi.c
-8ca8cc467d03d8669966355bd10cdc1c  sim/m68hc11/dv-m68hc11tim.c
-7a6a034ad9e6c84021453d397e77b945  sim/m68hc11/dv-nvram.c
-c217a05d9e0d3a992c76800974eebede  sim/m68hc11/emulos.c
-c45ce782880adf88ba66433d769db1c1  sim/m68hc11/gencode.c
-ca1a24528d76a89a89f4b1d51f5303b9  sim/m68hc11/interp.c
-f13329ec4f5010d34d1cc6043eae08c7  sim/m68hc11/interrupts.c
-a9d5cb354d7c560970a022cc1cba090b  sim/m68hc11/interrupts.h
-2908735dd7f803d25686775381753798  sim/m68hc11/m68hc11_sim.c
-8c146bf4bd8138a056897599ac86186f  sim/m68hc11/sim-main.h
-adf3fef9f6e13bf14c1343cf964cdfcd  sim/mcore/ChangeLog
-d920140c0f97ee202eb6efe0f40a40b3  sim/mcore/Makefile.in
-3b4a112254529fcac240d57d948d4d18  sim/mcore/config.in
-44536e356e1939b4b548b75c7914ec05  sim/mcore/configure
-921d78f436356fe658f80ca54eed649b  sim/mcore/configure.ac
-d3b0903441d8efbdf1eb83532b0af1d1  sim/mcore/interp.c
-89f2215e2f81d8a2ba851b8056d66240  sim/mcore/sysdep.h
-728bfc8fa71954f21775b19a5c579928  sim/mips/ChangeLog
-76dd53b72ecdf1fea7e9de74dda67085  sim/mips/Makefile.in
-65f7e35c979221f8e9c00b0f9745c053  sim/mips/config.in
-b769b11e708001cc5890021e1ca0de4f  sim/mips/configure
-932e6fd8d299869f8d955248dbc7bd38  sim/mips/configure.ac
-4536b055f3a5764ec2d35218f9e50744  sim/mips/cp1.c
-0e7ce3ff532ffc3ba8f9985557e05e62  sim/mips/cp1.h
-04c86645dd49cdefbb88eec93703c93d  sim/mips/dsp.c
-82cc6b7bf1db9dd23498095670a3dc5d  sim/mips/dsp.igen
-d166308ef94224c28d3cdc953ace7804  sim/mips/dsp2.igen
-dc0e9a7204535713ce2d6fa4e1eb788d  sim/mips/dv-tx3904cpu.c
-d84479be190d5b704f4ad4643b6f2115  sim/mips/dv-tx3904irc.c
-2e8d2afda7818b168ef8a47d857fa450  sim/mips/dv-tx3904sio.c
-28f636d38086ba71989fab505f0b2d4a  sim/mips/dv-tx3904tmr.c
-27db1b8d82ccd2f943cf646dad91b606  sim/mips/interp.c
-61566dc2819979301d3d92473a37bbc3  sim/mips/m16.dc
-8793eaebb46c2a817387548abc7ef322  sim/mips/m16.igen
-fb7ba65fd8f17c67c716cc2a2d00195c  sim/mips/m16e.igen
-383c97095ceeb7131e415af4e6089bec  sim/mips/m16run.c
-5bc61469836f371abf0592a6bd25b6de  sim/mips/mdmx.c
-087bac7445196cfa5c69a2708da6b705  sim/mips/mdmx.igen
-0cc85f54d1aaffc21fa0a619b2e23020  sim/mips/mips.dc
-7f57bec4befc510a50b53d8f77d09806  sim/mips/mips.igen
-2955109c984178dc710ab12258db408e  sim/mips/mips3264r2.igen
-edfa77d39279c571714b1d4aeb4a81f3  sim/mips/mips3d.igen
-60ce6cb5ea54aba454ba62a93edac75f  sim/mips/sb1.igen
-7dab3d41ec64a57cdc85cba9f9e191a3  sim/mips/sim-main.c
-aef2563ccdc10b6985597f0b1886ffb4  sim/mips/sim-main.h
-30e6869d78b9aa70ff03a05a3921a476  sim/mips/smartmips.igen
-520d024eada0d4a3ca8c17772361b8c0  sim/mips/tconfig.in
-e90e73eee445d44f164749dc8d8c0a4d  sim/mips/tx.igen
-b35a5093e668223efdc8aa2ef2d27f8b  sim/mips/vr.igen
-2b7b2f92307724cb7f82a7588960797d  sim/mn10300/ChangeLog
-a7be1ba7ce0bbb15efb00a0d8d98cd6a  sim/mn10300/Makefile.in
-c37a8063b25bb881b34e79630d4988b3  sim/mn10300/am33-2.igen
-c85c745f515c4346479864123eba7cef  sim/mn10300/am33.igen
-6382b4fa97b8c3f6b0d124a39da830ad  sim/mn10300/config.in
-b377e8a001c74d834262c3ab2343d1c1  sim/mn10300/configure
-702c0c67cadcd3e1ecc8b26ec61bb9ad  sim/mn10300/configure.ac
-d0b583abf76f2050e39e28be4b9b9286  sim/mn10300/dv-mn103cpu.c
-243ed6635ee5a5eda009919079342a95  sim/mn10300/dv-mn103int.c
-7f14922ea75fc9cee7c199c7934382d4  sim/mn10300/dv-mn103iop.c
-a5b9b769eedcb967cc312d386a90d751  sim/mn10300/dv-mn103ser.c
-4af5cbe4870a215793cb1e1c7dbd37b1  sim/mn10300/dv-mn103tim.c
-04593eb7bae55b5cbe2d5bef9b8ff9fd  sim/mn10300/interp.c
-a02c306411614c8de463bf278aac5d2e  sim/mn10300/mn10300.dc
-a7335227cef936abda2f0c8402e79570  sim/mn10300/mn10300.igen
-0f2f6763bb1b6158e4f629b5da8c871f  sim/mn10300/mn10300_sim.h
-6a0ae1f6ed62bce5bd7d506cb87ed7f3  sim/mn10300/op_utils.c
-9560a29b6c94d4955a447290ab5d050a  sim/mn10300/sim-main.c
-94f7e6ff509aa051b49ea862e8c1dee6  sim/mn10300/sim-main.h
-a123cfe902117497cd3549ffb9746f78  sim/mn10300/tconfig.in
-9386f74bff5fd3a25d4cea3f6cb22bda  sim/ppc/.gdbinit
-36407106664516616438a622329f6f1c  sim/ppc/BUGS
-0636e73ff0215e8d672dc4c32c317bb3  sim/ppc/COPYING
-55ca817ccb7d5b5b66355690e9abc605  sim/ppc/COPYING.LIB
-2fa873c6be4d48f3a9eb7afe76cc7536  sim/ppc/ChangeLog
-1bad061e853e13647aa63e38a9f1001f  sim/ppc/ChangeLog.00
-ecd61aaafc1737616ae87c802cc0a8e1  sim/ppc/INSTALL
-7e2c4dcc50abc4fc9009e6bd7c888fda  sim/ppc/Makefile.in
-851c77c4a526e09ac6fb7a77cba89b89  sim/ppc/README
-9b98a3220b34ead882ebd988dec298a4  sim/ppc/RUN
-d41d8cd98f00b204e9800998ecf8427e  sim/ppc/aclocal.m4
-5a77066671e4f6e4e41d6e798e47f7ea  sim/ppc/altivec.igen
-5f662e60889993fd1d8af8db6719a8ea  sim/ppc/altivec_expression.h
-42356e2f9ae8365e1e29519db09da5af  sim/ppc/altivec_registers.h
-9652d7609f72d7caed40808ebe8fb88e  sim/ppc/basics.h
-65f3366c7c3689220435a25a2ba082cf  sim/ppc/bits.c
-26ed1de12dff50c6a0519d14c73875eb  sim/ppc/bits.h
-4cb3d76f0038ed5a17f3309bda545304  sim/ppc/cap.c
-8f88189396a532d2824fcef2d85db174  sim/ppc/cap.h
-ccdc3530c8183a2c965775bcc70ee2ff  sim/ppc/config.in
-7a3e60b7ba3ee3503760241bbc859514  sim/ppc/configure
-efb1e5218eb3602bc86de4aa058f54b7  sim/ppc/configure.ac
-131b92c2bfc60c0a0fa11c7127f01151  sim/ppc/corefile-n.h
-29769d29b23530fc8e7468cb63db2338  sim/ppc/corefile.c
-2ad9c889b2483dc6b2f700cc50d5b5fb  sim/ppc/corefile.h
-660e642bfccbe4d4b4b24f8d276f2353  sim/ppc/cpu.c
-89dfdf1a4d8b1700564cc4e5f27a8254  sim/ppc/cpu.h
-d3057ff75f6c17550e153338da749f6d  sim/ppc/dc-complex
-7e0b4be2388bf97887228aa76e954bfd  sim/ppc/dc-simple
-763cc8428117c5c2bd847cfd06bad1d0  sim/ppc/dc-stupid
-b055ce44c5462421dd15b911a2062f25  sim/ppc/dc-test.01
-f41d30b6b933ba4acab16757fff79de7  sim/ppc/dc-test.02
-a6d011adc9e4de62790722e892b94c97  sim/ppc/debug.c
-40b9eb72287e10011898a3f69ca9a9e8  sim/ppc/debug.h
-67401955dff214152654f4bb80fcebaf  sim/ppc/device.c
-fee7a267accd496b6e2c4650b01c9b3d  sim/ppc/device.h
-22be58a024fde413f5c3cce2886bb260  sim/ppc/device_table.c
-1f064536d367de4ddd18a25453c994ae  sim/ppc/device_table.h
-c2f21558a815c20612b2ed4f41a34197  sim/ppc/dgen.c
-e08cfb709d371ce5e6f9f34d81ac9828  sim/ppc/double.c
-472874a3782f78a476801619247551bb  sim/ppc/dp-bit.c
-4cb40ff7aba81ee9ba5ec726663d580f  sim/ppc/e500.igen
-04b68a8ca55c8dad0c13707024ec500b  sim/ppc/e500_expression.h
-99eafe584482ceb5da5382094a3b0bf6  sim/ppc/e500_registers.h
-8d7c7a1e56f7107ac82a523d0259e338  sim/ppc/emul_bugapi.c
-f3d6d8d54f0b5c045c86907af1622bb1  sim/ppc/emul_bugapi.h
-ade49d06e52abba4f8ec33a1fe674c90  sim/ppc/emul_chirp.c
-9ef23ee673b667efd253b033f899761e  sim/ppc/emul_chirp.h
-c6d335c965bc9ac0fd8a69490abc036e  sim/ppc/emul_generic.c
-ed6d07b7f4e68168b0ac37650d30dce0  sim/ppc/emul_generic.h
-6c0d3c5fee5ca2bca997e09e80b934f7  sim/ppc/emul_netbsd.c
-7b33787dcf41c03863f43b596f3e4a50  sim/ppc/emul_netbsd.h
-a4e4e013e8b2294a88c492637eab3f40  sim/ppc/emul_unix.c
-3f59054ed73fc405d309edc3c0cd58c0  sim/ppc/emul_unix.h
-e0f8bb1f315522473bf26e2561c51239  sim/ppc/events.c
-6cbdba37de3215094841c9436c4a706a  sim/ppc/events.h
-f6e4ee2195d564b95790b8b48423ab68  sim/ppc/filter.c
-5d83db32f82407624ef3e44877bfc901  sim/ppc/filter.h
-b0e13975e4c92bc339a5db359eeeaa0f  sim/ppc/filter_filename.c
-e19c72f467811559af2500ff99310762  sim/ppc/filter_filename.h
-8d3cf6ed1d9079d6398540372133121f  sim/ppc/gdb-sim.c
-82c063a4f15c6576229bd0c5a77d0061  sim/ppc/gen-icache.c
-de741bee50e72c9eecf54eb31a57ce18  sim/ppc/gen-icache.h
-7c88da65d2064ea39325546b703797ee  sim/ppc/gen-idecode.c
-397ac3ac567e76ac1f4f7eb47f9dfe65  sim/ppc/gen-idecode.h
-382f9371a894b71e4ed2afb83f8512f3  sim/ppc/gen-itable.c
-31313c242173b2fe764f90edd57ce459  sim/ppc/gen-itable.h
-5da7ebf67f12aabf1833e7ada1ac3537  sim/ppc/gen-model.c
-d43fa565ffb41b1c78dd6065ae0845f0  sim/ppc/gen-model.h
-218fb15b91e0b63886b2f201c703fa1c  sim/ppc/gen-semantics.c
-dec70a4d4d0f2e04b9eb9c27aa842c79  sim/ppc/gen-semantics.h
-8f683225ed38466273adb6e821a62cb5  sim/ppc/gen-support.c
-125e5cd58b108f5a52c65544d1ba6638  sim/ppc/gen-support.h
-66fff86ce57112322b003c08f8082358  sim/ppc/hw_com.c
-54811845fe3d62433b00e07da46dc594  sim/ppc/hw_core.c
-5abc6e083931e0d458473da276a7c6a4  sim/ppc/hw_cpu.c
-0a5a25a4fecbe3cbbf7f70711c577567  sim/ppc/hw_cpu.h
-121bcfcb4285245e045b8596c3a747f8  sim/ppc/hw_disk.c
-50a89c1f61bf77a7ff0dcb467a0206a4  sim/ppc/hw_eeprom.c
-e6e7b45f07996b30fcddc8e10cae366a  sim/ppc/hw_glue.c
-ad5239b2e25df84fcd6f0955cdae794d  sim/ppc/hw_htab.c
-c2b3a77eb45c504654e71b7e16ea2adf  sim/ppc/hw_ide.c
-1d8a1b0c5ba88c40314ba8d018d07f7e  sim/ppc/hw_init.c
-5fc19100c2410b42430334c970b7026b  sim/ppc/hw_iobus.c
-194c545e87c2f690b8949843bbac306c  sim/ppc/hw_memory.c
-d4c516dbc656ce6b2b16caf4ee9aebfb  sim/ppc/hw_nvram.c
-ba5acc7a95cdafcda3aac022b9b6e0e3  sim/ppc/hw_opic.c
-e492e3614a6bd470ccf9bc24071c32ec  sim/ppc/hw_pal.c
-1cfd2049fa85129d72af534948c7244b  sim/ppc/hw_phb.c
-0782b28bb03134bea2f77d3e21431333  sim/ppc/hw_phb.h
-2f38620fcb80950224c5db7b896d6c0f  sim/ppc/hw_register.c
-3ba943992b311c50ca4937797d08dba2  sim/ppc/hw_trace.c
-0d7cacf1fbfd3bf3483f3fe89f9aa88d  sim/ppc/hw_vm.c
-8ad4143e2bdd2ef9a398710de5877613  sim/ppc/idecode_branch.h
-63e7f1f0dfc6d16de67e47829d6f6750  sim/ppc/idecode_expression.h
-a2a6140315cd3e6453fca3098ea6e0ab  sim/ppc/idecode_fields.h
-c8aed2d71502b4d53e12b87f201953cd  sim/ppc/igen.c
-1f88347bb2decb1fcd7487967bdca59b  sim/ppc/igen.h
-52907d4b0d9210c127a37368437d0ddd  sim/ppc/inline.c
-03137ec9c557c5729790f1bb1563fa34  sim/ppc/inline.h
-ae8d0a3696f84324c18d529193e3a0aa  sim/ppc/interrupts.c
-d36e61a48bbeb0fc22d6a43502618468  sim/ppc/interrupts.h
-a2376b46e21317f87a63c93cabab96a3  sim/ppc/ld-cache.c
-5c6c90b8dbfdf6f0e8fb8f01a599061b  sim/ppc/ld-cache.h
-e8ca4a4c2e2662ef78e50e1516e3bc4e  sim/ppc/ld-decode.c
-c96a0234594399abd61c514cf7885206  sim/ppc/ld-decode.h
-ad52b61bb3c6f286d96c54d156a7ea26  sim/ppc/ld-insn.c
-593a5550b97ea2cd864a310b6ee04ec1  sim/ppc/ld-insn.h
-daebea50f263bbad71ae4a076eb048ef  sim/ppc/lf.c
-267c9ade5fa517ed0fbc29c776dc3cc9  sim/ppc/lf.h
-d04db63c46f629ef831a4e87a08184b0  sim/ppc/main.c
-685bbe6ed4a3962eda1f367838cb09cf  sim/ppc/misc.c
-01dfdfb64f654f8a7501ba41e05a3fa2  sim/ppc/misc.h
-213ccd2e7b903475f306cb61e3de7b25  sim/ppc/mon.c
-3287b3ce2acbf89f0c76939187857022  sim/ppc/mon.h
-af7c9c433b85abb5c5e61673fea77b45  sim/ppc/options.c
-39bcc46ecea434624fdb42fae9ce598d  sim/ppc/options.h
-955e62ba48085a359721fc988df0affe  sim/ppc/os_emul.c
-ec00d27d9b5b0ee84e478874c7952855  sim/ppc/os_emul.h
-dad3b3f6b9a6e1551b7767d567f2814e  sim/ppc/pk_disklabel.c
-208abcefe4c29f5ab031d02c0789e676  sim/ppc/ppc-instructions
-fea984afca834b59ac7bc3d62d547432  sim/ppc/ppc-spr-table
-7ef1469cfb0809ffbafba1a6f43cc98b  sim/ppc/ppc.mt
-575c4f4a0c267b5e28dfcbfe167e553e  sim/ppc/psim.c
-14dfb8864f8b7f98b5c2a1f2b0cecd7d  sim/ppc/psim.h
-3451a21ba5941444fe5ee2960d137449  sim/ppc/psim.texinfo
-edc5e08e83b415d070176ec878fc1b10  sim/ppc/registers.c
-e20c3fefc2cff3ff71658b6cea230773  sim/ppc/registers.h
-27f339dcae5a8605568b933ad52ed9c9  sim/ppc/sim-endian-n.h
-b4fd27207dfbdd0fa5586a006a50b670  sim/ppc/sim-endian.c
-36e42da97cca42a96b3fc8208163c6a2  sim/ppc/sim-endian.h
-48c6b8643d82c832a08fc5aad6c182c3  sim/ppc/sim-main.h
-0ad8328ca8283dba3769232464c7b3bf  sim/ppc/sim_callbacks.h
-0a380a0e1b7bacd29d1220eb341d3f6b  sim/ppc/sim_calls.c
-2591babcc19cd684b6fdbfcbd6f7e126  sim/ppc/std-config.h
-e7451d70081236bfb7163f267c854741  sim/ppc/table.c
-393b81b772e44da580c2183af38e50c5  sim/ppc/table.h
-691c38b91b3012a65bce7d5961ceceda  sim/ppc/tree.c
-7d4718788552f69de36ec96b0916a849  sim/ppc/tree.h
-e3af8bab4cb4fccf3b5830b93523c0fb  sim/ppc/vm.c
-f5e70f8a845ecb64afee001c9d36535c  sim/ppc/vm.h
-ed994e6b649eff89844e1e09fb217d02  sim/ppc/vm_n.h
-c317eb318225097de547a50b0f676fe6  sim/ppc/words.h
-b7fccb7b4bb4835baffed7e5612ba0a2  sim/sh/ChangeLog
-01c3cc51432863fbd088a4c6b65eb0c7  sim/sh/Makefile.in
-3b4a112254529fcac240d57d948d4d18  sim/sh/config.in
-44536e356e1939b4b548b75c7914ec05  sim/sh/configure
-921d78f436356fe658f80ca54eed649b  sim/sh/configure.ac
-906094942d44b3938dca210bdf91daf5  sim/sh/gencode.c
-91e5c13ac89760f78545b03e4fa39f17  sim/sh/interp.c
-485762a39054bcf5bf3a3ee2a4de586f  sim/sh/syscall.h
-d0f4fcd32d377647d675b8d3ef85db09  sim/sh/tconfig.in
-01545f94a0069c6ecf7f4ee0eb68fa9c  sim/sh64/ChangeLog
-3163c30a9d8225c9c98f53ca3bc5a6e1  sim/sh64/Makefile.in
-c6ddb8adf998249ed4cf0c7e23a1a853  sim/sh64/arch.c
-19a6066acd9474907f65937bf98fac15  sim/sh64/arch.h
-053f1c67a2e7193e3d2e26f8fd93b60b  sim/sh64/config.in
-fabc4b09bff5ce6ed497034cf4725a92  sim/sh64/configure
-477388f2b5f358f546e98d21d2f52b35  sim/sh64/configure.ac
-afe93cd4f93601a65a52bc18139deb0c  sim/sh64/cpu.c
-dd0d98b31fb19bffbc9ab889cc88ab7b  sim/sh64/cpu.h
-8efd3c4ab3cac7a4ce7d378ff347cfb9  sim/sh64/cpuall.h
-59c1c4a92b14127580f5a2c728e77fce  sim/sh64/decode-compact.c
-e91123de7657bed5d4f9ae9327b14c53  sim/sh64/decode-compact.h
-2db4d19b2509ff4a2c1a5abe3092a327  sim/sh64/decode-media.c
-8f5609eb996aa1860b581d360d2c1c05  sim/sh64/decode-media.h
-5d324bee9f66166b122b0864f3a90ff7  sim/sh64/decode.h
-62f499c84710ec855dcb879eb0c6704d  sim/sh64/defs-compact.h
-ff8b87cef503ee1d0df46cce814c15e1  sim/sh64/defs-media.h
-ac213d1c73055fd163b9db0c56963dfd  sim/sh64/eng-compact.h
-afd9cbd34a7ea99ba02812493e0d6712  sim/sh64/eng-media.h
-f5c770aed65a5e620250377e5b30037c  sim/sh64/eng.h
-3aae7c2203bcd595b5b014f96b84a8c8  sim/sh64/mloop-compact.c
-afae0b57695fda02335f53ed36037a39  sim/sh64/mloop-media.c
-05f0575c178c1c46378486c8b69678b0  sim/sh64/sem-compact-switch.c
-2c35930b929fd274f54e6a03b2912a82  sim/sh64/sem-compact.c
-6c5486d9a00215f0608147eed88f70c3  sim/sh64/sem-media-switch.c
-f29a8a1937b5203f4556aa1d44016a73  sim/sh64/sem-media.c
-852447e5828fd8ccb860d7b17e43904f  sim/sh64/sh-desc.c
-d333be12003f77b84ddbac470501abc8  sim/sh64/sh-desc.h
-e976e9c55c8665c14741054e24fc8f1d  sim/sh64/sh-opc.h
-2ff456ba29f9c7c9c4a75cd105a16463  sim/sh64/sh64-sim.h
-96fee9d095e700b54b095202b99e2449  sim/sh64/sh64.c
-24d4b1a1aba0262b80c9ae9fa29dc98c  sim/sh64/sim-if.c
-5b99599096dc654535fd4a12919319ca  sim/sh64/sim-main.h
-16ef05475d28f88f3cffe19f1743a5eb  sim/sh64/tconfig.in
-e2f5f5c6fea67b69193c50e21c5f79fb  sim/testsuite/ChangeLog
-e21c2fbc045008efa24af69966378dd1  sim/testsuite/Makefile.in
-ca84afa69a4e8364c885c52102c3e872  sim/testsuite/configure
-1694d3de53bfa25899e8c459165d8cdc  sim/testsuite/configure.ac
-8b1814b871166305ec8fc7a06cc9a84d  sim/testsuite/common/Make-common.in
-09db0759c17936e2d8cf6dea6eda8fb1  sim/testsuite/common/Makefile.in
-9980219e011c42205bbd14e46d21fc8f  sim/testsuite/common/alu-n-tst.h
-56912c8f1ff672daf4dbab4a0fb12a54  sim/testsuite/common/alu-tst.c
-eea41f9412ca2d43e9eff21b6a67343a  sim/testsuite/common/bits-gen.c
-2c97e49ca99e657e07ca12a6fd5d6f69  sim/testsuite/common/bits-tst.c
-874ac49fc37d49f2822c8b409d285004  sim/testsuite/common/fpu-tst.c
-6f85f5b126eda2839d687ef1b5cc9587  sim/testsuite/config/default.exp
-543bbd1fdfa18e65ef9c8b82046aaa96  sim/testsuite/d10v-elf/ChangeLog
-caa0a2367211b8b9dec34275bed92480  sim/testsuite/d10v-elf/Makefile.in
-f1da902dea5b056dc9db2df841772439  sim/testsuite/d10v-elf/configure
-aeb9f246be0c025b69dcf144b916ce33  sim/testsuite/d10v-elf/configure.ac
-2092af64ed30dac7b430156bd2387770  sim/testsuite/d10v-elf/exit47.s
-df56df219276d06d750e8fb6f6b1581b  sim/testsuite/d10v-elf/hello.s
-f9e7c86333f37f05849bb0913d84040e  sim/testsuite/d10v-elf/loop.s
-246424eed873ed649d2a32c1de0a12cb  sim/testsuite/d10v-elf/t-ae-ld-d.s
-517096aa5ab9c0e44c70c067d41b0536  sim/testsuite/d10v-elf/t-ae-ld-i.s
-1d77729ab41b4cc1ef00c09482ec6715  sim/testsuite/d10v-elf/t-ae-ld-id.s
-266aa2fe095d30aad29b83c25851971e  sim/testsuite/d10v-elf/t-ae-ld-im.s
-75cd5a849fb6a73f45b92c5173201ad0  sim/testsuite/d10v-elf/t-ae-ld-ip.s
-880e8e02eb0c803c436bfc733723664c  sim/testsuite/d10v-elf/t-ae-ld2w-d.s
-e407a9027a51a971d55c14a9deac7d15  sim/testsuite/d10v-elf/t-ae-ld2w-i.s
-3b139d94efcc709b303318543337cee4  sim/testsuite/d10v-elf/t-ae-ld2w-id.s
-94f087c25d14650e94905d367ac781c8  sim/testsuite/d10v-elf/t-ae-ld2w-im.s
-d35bfeba95637ae41856f6692744cbdb  sim/testsuite/d10v-elf/t-ae-ld2w-ip.s
-ccf5bb0090436bc56ae6e5ab152f9be6  sim/testsuite/d10v-elf/t-ae-st-d.s
-c52f1cfa2ba8e7eb55aa93e564a0164f  sim/testsuite/d10v-elf/t-ae-st-i.s
-776264e34418e424ca53627692e3170d  sim/testsuite/d10v-elf/t-ae-st-id.s
-a25febe699e92863dd860f733c9dd22d  sim/testsuite/d10v-elf/t-ae-st-im.s
-6a1e686613656c7345b1feb238e31066  sim/testsuite/d10v-elf/t-ae-st-ip.s
-7edbadafb83e173b875ef37b4728d3f9  sim/testsuite/d10v-elf/t-ae-st-is.s
-f831b90857d7d08faa607a4c5d2fc618  sim/testsuite/d10v-elf/t-ae-st2w-d.s
-2c65c61ce821576fd7642ae775e053ee  sim/testsuite/d10v-elf/t-ae-st2w-i.s
-6e39b3ee1a1f446f2aea2265a13e824e  sim/testsuite/d10v-elf/t-ae-st2w-id.s
-44c3061ac426dfdcf4a850fe15376b2f  sim/testsuite/d10v-elf/t-ae-st2w-im.s
-0492a673d4276924c61d9ce568802546  sim/testsuite/d10v-elf/t-ae-st2w-ip.s
-670f5bcbd96246bf460d84b57bea1102  sim/testsuite/d10v-elf/t-ae-st2w-is.s
-9324e63160953a8b19ec76988361aa95  sim/testsuite/d10v-elf/t-dbt.s
-fcab1b7a79a3a82158f92a79f01fc1b6  sim/testsuite/d10v-elf/t-ld-st.s
-24adce9358d8640ca6ae226ecbeb41c7  sim/testsuite/d10v-elf/t-mac.s
-ace81e2c0d0d2ac060e2172d5fc8e655  sim/testsuite/d10v-elf/t-macros.i
-d028e41377d7e4afcdc3b979f9e026d7  sim/testsuite/d10v-elf/t-mod-ld-pre.s
-ba2eb8bb4b43be12c27308bebccab16d  sim/testsuite/d10v-elf/t-msbu.s
-be230dfdf2fc8a9548a086fd285ea00e  sim/testsuite/d10v-elf/t-mulxu.s
-c61c5fd4a6a85120020dea1782d72d65  sim/testsuite/d10v-elf/t-mvtac.s
-744e0ee2abcec900b154f72ccf20434f  sim/testsuite/d10v-elf/t-mvtc.s
-202b3272059c697b714c5f14d21e8418  sim/testsuite/d10v-elf/t-rac.s
-5850459c815d7a2cea95632d02288d93  sim/testsuite/d10v-elf/t-rachi.s
-d3f2b6a8713945840267c5b38031db57  sim/testsuite/d10v-elf/t-rdt.s
-d68929f5405fbc0fa82b417d61e8389c  sim/testsuite/d10v-elf/t-rep.s
-c2989be701fa58229f9d2c51d1d89b9a  sim/testsuite/d10v-elf/t-rie-xx.s
-b318831c796a5daf3c008a72a1bcff77  sim/testsuite/d10v-elf/t-rte.s
-2e29d477a767f8c3e7b9806e5061b73a  sim/testsuite/d10v-elf/t-sac.s
-34070ba49d956128040f988eb91c46b7  sim/testsuite/d10v-elf/t-sachi.s
-e8c67bf69426a7db6ecb7c2cafcc0a99  sim/testsuite/d10v-elf/t-sadd.s
-ec7bb92d79cec389c2cf4685d0c91150  sim/testsuite/d10v-elf/t-slae.s
-655e71f960343e657e230eba7ecb5f61  sim/testsuite/d10v-elf/t-sp.s
-67a11da95718e0f31001311302fe7743  sim/testsuite/d10v-elf/t-sub.s
-3bf62ddddb5d760ebd4a96790f02efd9  sim/testsuite/d10v-elf/t-sub2w.s
-dd04c4735e06d614b03e76a552d4fcb6  sim/testsuite/d10v-elf/t-subi.s
-b5b7dcb39e5fe37d20f5fbad5c205b6a  sim/testsuite/d10v-elf/t-trap.s
-26a25e60b7fff6e496ba5436c74f5da4  sim/testsuite/frv-elf/ChangeLog
-6712e8c487474b59bdfc725a69c5208e  sim/testsuite/frv-elf/Makefile.in
-ad3cb74cb4f5e1145c323d436230b3f4  sim/testsuite/frv-elf/cache.s
-f1da902dea5b056dc9db2df841772439  sim/testsuite/frv-elf/configure
-aeb9f246be0c025b69dcf144b916ce33  sim/testsuite/frv-elf/configure.ac
-70ca72190bc26acee97deb6d5974053f  sim/testsuite/frv-elf/exit47.s
-e30b4c8b1165f133ffd45b28034a33a7  sim/testsuite/frv-elf/grloop.s
-cc16675e19f20d246b81ba1aa64e2c05  sim/testsuite/frv-elf/hello.s
-02ebc2d23f1397660d56c21d6a0866c6  sim/testsuite/frv-elf/loop.s
-d694c0f7b4fddeffcad20fb5e728948f  sim/testsuite/lib/sim-defs.exp
-ac98ff988f0277b310cf429aece8596e  sim/testsuite/m32r-elf/ChangeLog
-6e19ffe9294a5c1d88cf74be5fadb3ee  sim/testsuite/m32r-elf/Makefile.in
-f1da902dea5b056dc9db2df841772439  sim/testsuite/m32r-elf/configure
-aeb9f246be0c025b69dcf144b916ce33  sim/testsuite/m32r-elf/configure.ac
-fdcd1bf835b2c2a0ce2ec539624e2a6c  sim/testsuite/m32r-elf/exit47.s
-d855cd1f7a63aa5913126e4c9cbbdca4  sim/testsuite/m32r-elf/hello.s
-61aac381a61d722e21e84faa6146d7be  sim/testsuite/m32r-elf/loop.s
-9546bb057985a629b21308bfe08a0534  sim/testsuite/mips64el-elf/ChangeLog
-df208b92c49592dbb2c96430846947dc  sim/testsuite/mips64el-elf/Makefile.in
-f1da902dea5b056dc9db2df841772439  sim/testsuite/mips64el-elf/configure
-aeb9f246be0c025b69dcf144b916ce33  sim/testsuite/mips64el-elf/configure.ac
-5477dc224f249d5d847bb14b5809df81  sim/testsuite/sim/arm/adc.cgs
-1c290ff406eb9de96060785ccfb36a33  sim/testsuite/sim/arm/add.cgs
-a3aa42f1d4d1630a0f42c3e640f6ee0d  sim/testsuite/sim/arm/allinsn.exp
-58ac8d4d5ea2fe8c946251b4592629c6  sim/testsuite/sim/arm/and.cgs
-99933c6f18e0fe8c3cbfeea3222bc270  sim/testsuite/sim/arm/b.cgs
-8e130c393453b06b0c4f168915320147  sim/testsuite/sim/arm/bic.cgs
-d3676059d440e43421abe9377b45644e  sim/testsuite/sim/arm/bl.cgs
-d8cbbc37fbab2579e37ca9ed2c82d6e3  sim/testsuite/sim/arm/bx.cgs
-d80faf2d614f5b40636508bb03f723ff  sim/testsuite/sim/arm/cmn.cgs
-514c9855ea49dbd189076992160d290a  sim/testsuite/sim/arm/cmp.cgs
-5b1a485b23f4ada997bc9c482f4b142d  sim/testsuite/sim/arm/eor.cgs
-e7ed4d8b65d61b3addaa13b237d5d630  sim/testsuite/sim/arm/hello.ms
-7b279b86516c39f3610fd701192e55da  sim/testsuite/sim/arm/ldm.cgs
-93e27d311dd9c978b5fd3238d8a96ff7  sim/testsuite/sim/arm/ldr.cgs
-2f129d54e1238525995fbb61345511b6  sim/testsuite/sim/arm/ldrb.cgs
-3d8cacbe82b517293ac2230f4947d142  sim/testsuite/sim/arm/ldrh.cgs
-bef5c11ab14ef76a4adf86bdb29f3fa7  sim/testsuite/sim/arm/ldrsb.cgs
-b70b6932231ba7b22b55aa6b0dabd2da  sim/testsuite/sim/arm/ldrsh.cgs
-248009f835f984c6659530b0d8ac3d6b  sim/testsuite/sim/arm/misaligned1.ms
-e094567de77b483869bfaa906a58c5f0  sim/testsuite/sim/arm/misaligned2.ms
-61d1b5a430c450fa09d944dac4f6e9e9  sim/testsuite/sim/arm/misaligned3.ms
-c0491db4475978a5556ce7e8d3940329  sim/testsuite/sim/arm/misc.exp
-7c8eb7b1180e26892ff171384548e3df  sim/testsuite/sim/arm/mla.cgs
-cae028721a4860ba721bb0b6a45e28de  sim/testsuite/sim/arm/mov.cgs
-138b2c1c179325a81f413db374952dda  sim/testsuite/sim/arm/mrs.cgs
-5f5776bf35261a0924e7314d31bbec74  sim/testsuite/sim/arm/msr.cgs
-0ad30943dc3310c090723d102d0c0c72  sim/testsuite/sim/arm/mul.cgs
-28a00b5d6dacadae53e6f32c439dd867  sim/testsuite/sim/arm/mvn.cgs
-e36fa83cfe6f8c23c2c4a874d15d6bb5  sim/testsuite/sim/arm/orr.cgs
-0b54dec83ea8c2148335d0c9411f827a  sim/testsuite/sim/arm/rsb.cgs
-2db4b0c1e930d96e870724d2ecb71ec1  sim/testsuite/sim/arm/rsc.cgs
-24953ef6d2f93fbc574722cfeb6f0508  sim/testsuite/sim/arm/sbc.cgs
-424eae0aeb212b99a0423296d92432f9  sim/testsuite/sim/arm/smlal.cgs
-5daa27aad0853ba541927ca858d54e0e  sim/testsuite/sim/arm/smull.cgs
-7caaf16bdd001c1cfdc6d204be0595d5  sim/testsuite/sim/arm/stm.cgs
-510262d467a1cf529e9ebf863f5510bc  sim/testsuite/sim/arm/str.cgs
-bb3da4ab25011ccabcc1c8437f907d7d  sim/testsuite/sim/arm/strb.cgs
-982a00c19684480239a8d14ca04bd9e5  sim/testsuite/sim/arm/strh.cgs
-1be7d9195c233759510ea7aea222287f  sim/testsuite/sim/arm/sub.cgs
-7853156003daa0909a44ee8c2b159869  sim/testsuite/sim/arm/swi.cgs
-05ae9969a70c8f236c50630fd2f7d113  sim/testsuite/sim/arm/swp.cgs
-f38f5ed68bbf76a6bb802723f8e111ac  sim/testsuite/sim/arm/swpb.cgs
-2f52c300639b0dccd15ed3b15bf2949b  sim/testsuite/sim/arm/teq.cgs
-f0a99de3c5c47c3aa91c95c25879b41f  sim/testsuite/sim/arm/testutils.inc
-853c04dea43ce219f8fbb2d4dda8f96c  sim/testsuite/sim/arm/tst.cgs
-a06bb01624f0127d797df273c0f0ae39  sim/testsuite/sim/arm/umlal.cgs
-da2138a738648ab058990d5e495fb407  sim/testsuite/sim/arm/umull.cgs
-fff690cc3c0b4cab7f417d747f0b6274  sim/testsuite/sim/arm/iwmmxt/iwmmxt.exp
-cb91cfc8d87632674bb08655b37257af  sim/testsuite/sim/arm/iwmmxt/tbcst.cgs
-f0a99de3c5c47c3aa91c95c25879b41f  sim/testsuite/sim/arm/iwmmxt/testutils.inc
-fd328a7cecef16b062706133bd86a185  sim/testsuite/sim/arm/iwmmxt/textrm.cgs
-676c13c4e65bd1da95adcdacc048ee0d  sim/testsuite/sim/arm/iwmmxt/tinsr.cgs
-27a5dff0fce99446ea9b92149fd87aad  sim/testsuite/sim/arm/iwmmxt/tmia.cgs
-b87db8b330bbfc39e8cc5c193bfd6752  sim/testsuite/sim/arm/iwmmxt/tmiaph.cgs
-7f91c1c6ee07a5fa069f79687e6d3b18  sim/testsuite/sim/arm/iwmmxt/tmiaxy.cgs
-e3314ba0fb5456272846893666ca6076  sim/testsuite/sim/arm/iwmmxt/tmovmsk.cgs
-7a8797138da5f79dd25a529ca6aafda9  sim/testsuite/sim/arm/iwmmxt/wacc.cgs
-aade4be67b5af16a82727edd01ff01a5  sim/testsuite/sim/arm/iwmmxt/wadd.cgs
-88c71104de87e83e76badb90eee05b15  sim/testsuite/sim/arm/iwmmxt/waligni.cgs
-e40211a7420484d7931c301a38d87629  sim/testsuite/sim/arm/iwmmxt/walignr.cgs
-6f34dbce9217355b0034e980065123b2  sim/testsuite/sim/arm/iwmmxt/wand.cgs
-1eeac0b2b5efecd25602ca32932a301e  sim/testsuite/sim/arm/iwmmxt/wandn.cgs
-b468e9e418a1e1a91063cde9f01a5b65  sim/testsuite/sim/arm/iwmmxt/wavg2.cgs
-23189fcb39a2352d1f2aebd9fa472b86  sim/testsuite/sim/arm/iwmmxt/wcmpeq.cgs
-ade7f421e7229ac22b99232d633506d8  sim/testsuite/sim/arm/iwmmxt/wcmpgt.cgs
-f0f803cfe86027c9376da8bd15d603dc  sim/testsuite/sim/arm/iwmmxt/wmac.cgs
-bf292aeb577d786f1a5d93be72786c39  sim/testsuite/sim/arm/iwmmxt/wmadd.cgs
-3d4113ef895254186382634bb9654300  sim/testsuite/sim/arm/iwmmxt/wmax.cgs
-154a974a65e03d5b99e084a97aae5048  sim/testsuite/sim/arm/iwmmxt/wmin.cgs
-7f2e2adae5b6face7645ef4d178af158  sim/testsuite/sim/arm/iwmmxt/wmov.cgs
-7155fabca12e398a7ae30604e6010df6  sim/testsuite/sim/arm/iwmmxt/wmul.cgs
-d3866e29becc0eb004bf50d7adcf21bc  sim/testsuite/sim/arm/iwmmxt/wor.cgs
-7cbe9df76667e549020ee9154febcb84  sim/testsuite/sim/arm/iwmmxt/wpack.cgs
-da03e694abbabd2571357cc9ed058c70  sim/testsuite/sim/arm/iwmmxt/wror.cgs
-81f8cb5a71451f972f4e040b980f6606  sim/testsuite/sim/arm/iwmmxt/wsad.cgs
-538bf57041e5e509121767d9ead1147e  sim/testsuite/sim/arm/iwmmxt/wshufh.cgs
-182edb4dbe3c5f16e8bbc90c344f5958  sim/testsuite/sim/arm/iwmmxt/wsll.cgs
-648dcf66cfd2ce5849d2cbb42c74e3ef  sim/testsuite/sim/arm/iwmmxt/wsra.cgs
-372409901bb2e34b4370c142151e635c  sim/testsuite/sim/arm/iwmmxt/wsrl.cgs
-b759e1c2be6dc0fb3b9656e41302b73c  sim/testsuite/sim/arm/iwmmxt/wsub.cgs
-966e30e2028caa8495f566e530a4e4d2  sim/testsuite/sim/arm/iwmmxt/wunpckeh.cgs
-33dad8b13e3c06ffd72fefbae3ae328c  sim/testsuite/sim/arm/iwmmxt/wunpckel.cgs
-2ece72d7f9fed70851599aeafeb8fd75  sim/testsuite/sim/arm/iwmmxt/wunpckih.cgs
-d4cf1dd1687b956976c326aa10e0da93  sim/testsuite/sim/arm/iwmmxt/wunpckil.cgs
-37722d747ac7f2623a99bd2d5d04c319  sim/testsuite/sim/arm/iwmmxt/wxor.cgs
-7f8a6603491a9bdea9261b3aefecd67a  sim/testsuite/sim/arm/iwmmxt/wzero.cgs
-f39dfdec26af7f089c85d0156d96f853  sim/testsuite/sim/arm/thumb/adc.cgs
-a3a364cbdc5b492650e011da6f9c6de2  sim/testsuite/sim/arm/thumb/add-hd-hs.cgs
-0c8a4f0432c4d3abeea38a2f31a8fed2  sim/testsuite/sim/arm/thumb/add-hd-rs.cgs
-65de2dbbc1d1963e22a7ed146018c9cf  sim/testsuite/sim/arm/thumb/add-rd-hs.cgs
-3b1245f3b53f4f2fd1788169d9d1e5a5  sim/testsuite/sim/arm/thumb/add-sp.cgs
-44fc3fa4d4212c68997074146cd2081d  sim/testsuite/sim/arm/thumb/add.cgs
-34994f81445d814b87b6aebce14a53c9  sim/testsuite/sim/arm/thumb/addi.cgs
-d9a906c124e9554e0980cc53b336b377  sim/testsuite/sim/arm/thumb/addi8.cgs
-7fecc3e47bed5457f394e92e9c496247  sim/testsuite/sim/arm/thumb/allthumb.exp
-995d38ff3ed038c4f5cbcad2d78e0207  sim/testsuite/sim/arm/thumb/and.cgs
-a1eda67b5040ebb08367e07d0624ee8a  sim/testsuite/sim/arm/thumb/asr.cgs
-4dd23bc630fc11c4eca7cbea9fc36231  sim/testsuite/sim/arm/thumb/b.cgs
-05d4b004a36c86c46a3ba8f3a485c488  sim/testsuite/sim/arm/thumb/bcc.cgs
-9679a91ccf07238a1c0161cde847fe85  sim/testsuite/sim/arm/thumb/bcs.cgs
-e162af7a697a2fa2e10ecc1a56b45be1  sim/testsuite/sim/arm/thumb/beq.cgs
-359c1c1f673e082a73606aea537c22ce  sim/testsuite/sim/arm/thumb/bge.cgs
-cc9025ac9679ebfbd9e3fc340edbc697  sim/testsuite/sim/arm/thumb/bgt.cgs
-244babd31dcba228ef3637cbcca9c16b  sim/testsuite/sim/arm/thumb/bhi.cgs
-4a2f10cac1edd904293441d716cad0f1  sim/testsuite/sim/arm/thumb/bic.cgs
-6ed6d54faafbb0319c1604112b0c16c4  sim/testsuite/sim/arm/thumb/bl-hi.cgs
-a8c07a4b4764c4cc4c88cd2633394160  sim/testsuite/sim/arm/thumb/bl-lo.cgs
-f25edf66e54fa2c53957abc6aa807d00  sim/testsuite/sim/arm/thumb/ble.cgs
-ead31b659b0f0e78ca8054010fc195a9  sim/testsuite/sim/arm/thumb/bls.cgs
-b1866a0b3f4e1244f6f32c7890b4623f  sim/testsuite/sim/arm/thumb/blt.cgs
-ec7f950054226d26fe7c00da759b2c4e  sim/testsuite/sim/arm/thumb/bmi.cgs
-5ae8870812f676720ebfc69b48c04ebb  sim/testsuite/sim/arm/thumb/bne.cgs
-03a9889899898201a14082970138178d  sim/testsuite/sim/arm/thumb/bpl.cgs
-cd68a29c2b8bdaf0c8aed77438819e18  sim/testsuite/sim/arm/thumb/bvc.cgs
-5ea6bc2fd59bbd0f3a4bd46fd117a8be  sim/testsuite/sim/arm/thumb/bvs.cgs
-fcaed4c8608ce095dc4625f37383b515  sim/testsuite/sim/arm/thumb/bx-hs.cgs
-23d58ec2e23ff3bed4784642cc48aa06  sim/testsuite/sim/arm/thumb/bx-rs.cgs
-2588c865bab15990f4bd3546b3d82fe7  sim/testsuite/sim/arm/thumb/cmn.cgs
-189891b42b0a10d5895c36ed13267a7e  sim/testsuite/sim/arm/thumb/cmp-hd-hs.cgs
-6c4154b82d1b8a3579a0f42b4142aad5  sim/testsuite/sim/arm/thumb/cmp-hd-rs.cgs
-bc1c96814fecd239a7955bc76320fae5  sim/testsuite/sim/arm/thumb/cmp-rd-hs.cgs
-9e9f7b260681e86c6c0b7e0006cd2154  sim/testsuite/sim/arm/thumb/cmp.cgs
-b44832f5d79102e7efeee45f69462a66  sim/testsuite/sim/arm/thumb/eor.cgs
-7bceba1198328ea2930942d76eca4da4  sim/testsuite/sim/arm/thumb/lda-pc.cgs
-b0b760fd79039fbf1125dc0a526be229  sim/testsuite/sim/arm/thumb/lda-sp.cgs
-a25b0fe3d7a82e5a2f7605f685e15f46  sim/testsuite/sim/arm/thumb/ldmia.cgs
-3896f647e72d591e262a40e5af29adf9  sim/testsuite/sim/arm/thumb/ldr-imm.cgs
-f558e4e07d5886e42d8da753f5adc9c2  sim/testsuite/sim/arm/thumb/ldr-pc.cgs
-c41ea1558f80aa2acb0eabcfda617729  sim/testsuite/sim/arm/thumb/ldr-sprel.cgs
-4aebea08153a18c59cb89377cd0cd6e6  sim/testsuite/sim/arm/thumb/ldr.cgs
-ed9f50e3848ffa46f1f6918df9be8d9e  sim/testsuite/sim/arm/thumb/ldrb-imm.cgs
-8575173ee07cb511f33d4ba01c67152a  sim/testsuite/sim/arm/thumb/ldrb.cgs
-4983cedc4b15f2b1ff5dec0e01ec8705  sim/testsuite/sim/arm/thumb/ldrh-imm.cgs
-674db4c1215bd277651130d87a64a915  sim/testsuite/sim/arm/thumb/ldrh.cgs
-91148c7f6657e7dd4e227a43f6ec7cfc  sim/testsuite/sim/arm/thumb/ldsb.cgs
-a2f21e7ede5faef4d9cee034a88928ae  sim/testsuite/sim/arm/thumb/ldsh.cgs
-0054af714a4db9a939abde5126dabe11  sim/testsuite/sim/arm/thumb/lsl.cgs
-15cd5436a6e963ccd32b54e22c7a8b21  sim/testsuite/sim/arm/thumb/lsr.cgs
-5e5452b3461b69cffd6b8f23f4e7140c  sim/testsuite/sim/arm/thumb/mov-hd-hs.cgs
-a11035d426ce96b9dd0c5b94664abcc1  sim/testsuite/sim/arm/thumb/mov-hd-rs.cgs
-b4f45a3bb387a75a6db056bef516b07b  sim/testsuite/sim/arm/thumb/mov-rd-hs.cgs
-eb4d0f5b458b6c6e2a847d5c8673e3e6  sim/testsuite/sim/arm/thumb/mov.cgs
-13116b55efce4632651233f650d7dc78  sim/testsuite/sim/arm/thumb/mul.cgs
-70faca670e6c72adda93fb641c480b1f  sim/testsuite/sim/arm/thumb/mvn.cgs
-8bcf6d16383ab1c7ef09466857afbc37  sim/testsuite/sim/arm/thumb/neg.cgs
-6cf3e8b7ef426b8914b47d8f7ec0a456  sim/testsuite/sim/arm/thumb/orr.cgs
-0250cdbde1a106526ec9f3b4861b8d4a  sim/testsuite/sim/arm/thumb/pop-pc.cgs
-2f5ae83cda2f549b102b57569f78f8d9  sim/testsuite/sim/arm/thumb/pop.cgs
-fa00d6fb1a2926732b0eb28ae0c77c47  sim/testsuite/sim/arm/thumb/push-lr.cgs
-6656596a7ff9c3b412deae76b7e38624  sim/testsuite/sim/arm/thumb/push.cgs
-8c2c133f6c72015561ac976d7438ebe9  sim/testsuite/sim/arm/thumb/ror.cgs
-56f88f8627fec54cd96656de2828c1f2  sim/testsuite/sim/arm/thumb/sbc.cgs
-e89c8dd1ff6ae4faa4b4dff6b626a850  sim/testsuite/sim/arm/thumb/stmia.cgs
-1d8dd64ff6c23b570bbaa4d7afff968e  sim/testsuite/sim/arm/thumb/str-imm.cgs
-c5c60347531697a069a2800842ee3902  sim/testsuite/sim/arm/thumb/str-sprel.cgs
-f9d716a1d842d091c8ed298f1b5b1ae9  sim/testsuite/sim/arm/thumb/str.cgs
-06e7eb2e9fd2173cafaaf5cbd62eac9b  sim/testsuite/sim/arm/thumb/strb-imm.cgs
-10371b41438911cf843b9cec25c67e1d  sim/testsuite/sim/arm/thumb/strb.cgs
-ca60a519f04c50e1e8b316b49a7e4e9d  sim/testsuite/sim/arm/thumb/strh-imm.cgs
-62c721a2ca73cdae002eba9841199014  sim/testsuite/sim/arm/thumb/strh.cgs
-c1a57f0215877e8992c61e54d2446278  sim/testsuite/sim/arm/thumb/sub-sp.cgs
-acb920479677a598ba5544db15addd06  sim/testsuite/sim/arm/thumb/sub.cgs
-1e72cd9a9e01d015ac44deadf9a8eb0d  sim/testsuite/sim/arm/thumb/subi.cgs
-4ed486b285f8dd6272168154f0e7df58  sim/testsuite/sim/arm/thumb/subi8.cgs
-84459a09af60b4a3de23776a8bf0adcc  sim/testsuite/sim/arm/thumb/swi.cgs
-93c6ea09186e29b651ae931a0ba07760  sim/testsuite/sim/arm/thumb/testutils.inc
-c45fc39f2f692299fe4bf891668833d8  sim/testsuite/sim/arm/thumb/tst.cgs
-f2c30ed356d350356f1edcb1484c6f57  sim/testsuite/sim/arm/xscale/blx.cgs
-64304cffe7caf82616cedaf41498ac45  sim/testsuite/sim/arm/xscale/mia.cgs
-03c925a228ba4258f15e01eef3fceb5b  sim/testsuite/sim/arm/xscale/miaph.cgs
-ff267c0f1ed5b05d883ec3584f8bb6f9  sim/testsuite/sim/arm/xscale/miaxy.cgs
-0a98c2c1558ae770328e84c180ac3616  sim/testsuite/sim/arm/xscale/mra.cgs
-f0a99de3c5c47c3aa91c95c25879b41f  sim/testsuite/sim/arm/xscale/testutils.inc
-c041e18e1c56fcb743b7e2c2d8ca5ec5  sim/testsuite/sim/arm/xscale/xscale.exp
-01748fb2e18517d90562bb0e840828da  sim/testsuite/sim/cris/asm/abs.ms
-a909c3f9eca7ac8afed8e09345f10da2  sim/testsuite/sim/cris/asm/addc.ms
-745fe5dbcb1bd5a9cf09833d2c60720d  sim/testsuite/sim/cris/asm/addcpc.ms
-1102b074c017814da29cde832273f482  sim/testsuite/sim/cris/asm/addcv32c.ms
-442b4a68caf03f8c6144395f140812eb  sim/testsuite/sim/cris/asm/addcv32m.ms
-d29aeee229d1ca94d1ca4f83d292403d  sim/testsuite/sim/cris/asm/addcv32r.ms
-437759a2c57580b8695a4fcf6c5dd353  sim/testsuite/sim/cris/asm/addi.ms
-dfc9197bbe28a36c018d958bf9542575  sim/testsuite/sim/cris/asm/addiv32.ms
-d1a8f7bf8185d66d74bcb7813e215796  sim/testsuite/sim/cris/asm/addm.ms
-0da25d08fc1e025db45507b9c21666d7  sim/testsuite/sim/cris/asm/addoc.ms
-eaa47e885647f776382ab73a6f5961ec  sim/testsuite/sim/cris/asm/addom.ms
-b4c3d4cf958efce78de12dbe055158b1  sim/testsuite/sim/cris/asm/addoq.ms
-6accf667f81ed8bfb8c56f18e8e844c9  sim/testsuite/sim/cris/asm/addq.ms
-6817aaa89fa3d0012a8d28db17c3e311  sim/testsuite/sim/cris/asm/addqpc.ms
-e1164adb4965589fb668a12b9cabad32  sim/testsuite/sim/cris/asm/addr.ms
-1ee7b9da11c1883f071654c33c6f4e3b  sim/testsuite/sim/cris/asm/addswpc.ms
-0e4cdcc3d930dbe4bb1960224de30c37  sim/testsuite/sim/cris/asm/addxc.ms
-96fbb5c40c0c7c3e819ab1beafa25c6e  sim/testsuite/sim/cris/asm/addxm.ms
-c14bbe5dd88bc327ff41446190b09f35  sim/testsuite/sim/cris/asm/addxr.ms
-e3520c7d04732f9662598a2f73bdaf2e  sim/testsuite/sim/cris/asm/andc.ms
-ecbc0cdebce612428dd2396bfd1ffec8  sim/testsuite/sim/cris/asm/andm.ms
-bd42a08cc8373b1308928957194e0fec  sim/testsuite/sim/cris/asm/andq.ms
-7836790af2b06306d3925d8041bbfd6c  sim/testsuite/sim/cris/asm/andr.ms
-fdb9910cb573813f746d7d849359d9f9  sim/testsuite/sim/cris/asm/asm.exp
-f31c11e9c405d7c29ecfa40d76563afc  sim/testsuite/sim/cris/asm/asr.ms
-70731cd0eb6983253223310f3deebf30  sim/testsuite/sim/cris/asm/ba.ms
-9699750e3f1ac479aa04674025cae818  sim/testsuite/sim/cris/asm/bare1.ms
-99f079bf224cebd25f0293326f1056d0  sim/testsuite/sim/cris/asm/bare2.ms
-caa837951bcc527ba2ca4cf972905162  sim/testsuite/sim/cris/asm/bas.ms
-70712ff7b9b19a93be512af7e15c245b  sim/testsuite/sim/cris/asm/bccb.ms
-b42f2d6fa449133e5fe5168860eacb72  sim/testsuite/sim/cris/asm/bdapc.ms
-de59b44165a54822f1e186794fe2ba46  sim/testsuite/sim/cris/asm/bdapm.ms
-20f91c681dc2609edb3caf20351e4c45  sim/testsuite/sim/cris/asm/bdapq.ms
-97ef65c3f3d9068fb73f9b40eb072c79  sim/testsuite/sim/cris/asm/bdapqpc.ms
-272797f68936986d5f91637d3773b3ca  sim/testsuite/sim/cris/asm/biap.ms
-655db8f5621d9a019c169c33a538f5b6  sim/testsuite/sim/cris/asm/boundc.ms
-72b76cf328e602ac59d0eb6d3828db10  sim/testsuite/sim/cris/asm/boundm.ms
-3bf811af64069fafddd0997ff8fbca50  sim/testsuite/sim/cris/asm/boundmv32.ms
-c0d5a8770803259746508dc445dd8854  sim/testsuite/sim/cris/asm/boundr.ms
-2242370394be8c61d84f559201c21c38  sim/testsuite/sim/cris/asm/break.ms
-33c03c3be0ae8e449a15c3c9f595fe07  sim/testsuite/sim/cris/asm/btst.ms
-67eb34187ea6ebf749c0ade2acb648ec  sim/testsuite/sim/cris/asm/ccr-v10.ms
-57d425c5b4b9fef24cb94071a1a2dbde  sim/testsuite/sim/cris/asm/ccs-v32.ms
-2214b2e2ed7ea02738a11f0b28c7dd4e  sim/testsuite/sim/cris/asm/clearfv10.ms
-9488a97f680e48ad7132c79e4cf055cb  sim/testsuite/sim/cris/asm/clearfv32.ms
-980dc5105a922cccdbc3260960087e09  sim/testsuite/sim/cris/asm/clrjmp1.ms
-90fbd294e25dc0ba8bba226c06d0cb22  sim/testsuite/sim/cris/asm/cmpc.ms
-797ca60d36294ec7548da5326ab314fe  sim/testsuite/sim/cris/asm/cmpm.ms
-2546f493ea0e6e5a6c380ea297355c1a  sim/testsuite/sim/cris/asm/cmpq.ms
-11e3f6289d1e6d546f9ad47e4f21820f  sim/testsuite/sim/cris/asm/cmpr.ms
-fac7339a938456bd828ee00b51c8f648  sim/testsuite/sim/cris/asm/cmpxc.ms
-a9438c1d50113d9dd4cd1a1da3878fc4  sim/testsuite/sim/cris/asm/cmpxm.ms
-5da23c5c235f9234e2f92203712100c4  sim/testsuite/sim/cris/asm/dflags.ms
-3fa72767063631d49bf4feaa0f4f6639  sim/testsuite/sim/cris/asm/dip.ms
-5b1a83a07ae1f436fae2c9afc9e32e0a  sim/testsuite/sim/cris/asm/dstep.ms
-6de4abd05e77fc1ff5a6532b86ee877f  sim/testsuite/sim/cris/asm/fidxd.ms
-c32801173ab04d7c48810448ac9ac41d  sim/testsuite/sim/cris/asm/fidxi.ms
-42b8ad76ab83648bc21de617564e2f41  sim/testsuite/sim/cris/asm/ftagd.ms
-5e016def3b1f2378d046da635d23ed30  sim/testsuite/sim/cris/asm/ftagi.ms
-e6d17a5c04658ee4296a5564eeb0bda1  sim/testsuite/sim/cris/asm/halt.ms
-b216800662427ef7d209ef094910e8bc  sim/testsuite/sim/cris/asm/io1.ms
-750db2caea6a5174fce9f0e83d686cbb  sim/testsuite/sim/cris/asm/io2.ms
-1d44f5e46380b9ef890396e82e843e8b  sim/testsuite/sim/cris/asm/io3.ms
-074dc6598e23e28f78546cee905c554b  sim/testsuite/sim/cris/asm/io4.ms
-5fdad03a8aa07112fd066b9c8feff6f3  sim/testsuite/sim/cris/asm/io5.ms
-47671131454820ec2fcc7e91587ef745  sim/testsuite/sim/cris/asm/io6.ms
-6e5ae74837dbabc6ea0ba4b2126a6980  sim/testsuite/sim/cris/asm/io7.ms
-da80d870be0a30685884c47a9fde8040  sim/testsuite/sim/cris/asm/io8.ms
-5ff83437c8ed81814c917502031bd4e0  sim/testsuite/sim/cris/asm/io9.ms
-af31a5dab88b669267a99dfef2f68de1  sim/testsuite/sim/cris/asm/jsr.ms
-cac8a4df22fecf18b6f4a8a8343dc311  sim/testsuite/sim/cris/asm/jsrmv10.ms
-36af380c716d4cd34eca6173940a89cd  sim/testsuite/sim/cris/asm/jumpmp.ms
-47666f39f5eb8756ba8f49ab48e7d66e  sim/testsuite/sim/cris/asm/jumppv32.ms
-52063e38d4a4290cb5d64ef44023f8f4  sim/testsuite/sim/cris/asm/lapc.ms
-17dd79fca49908b8c928b404e00814dc  sim/testsuite/sim/cris/asm/lsl.ms
-a3f7925f637528a6ed229eefe49fc69e  sim/testsuite/sim/cris/asm/lsr.ms
-347b1a9e1c63a246cfcd0334e0b2011b  sim/testsuite/sim/cris/asm/lz.ms
-b7870ec565bcc1c4e6a59cc359e85330  sim/testsuite/sim/cris/asm/mcp.ms
-0027c92c821b64aa99e62a63306c59c4  sim/testsuite/sim/cris/asm/movdelsr1.ms
-7ee0c813a6c857f1e2790f75518d6b0b  sim/testsuite/sim/cris/asm/movecpc.ms
-4a4c657a9d8be8e6567a4b26be9c0b26  sim/testsuite/sim/cris/asm/movecr.ms
-f618263e1a5fe35414d390c5e698da43  sim/testsuite/sim/cris/asm/movecrt10.ms
-152588b5fbb59aab4a789c32082baecd  sim/testsuite/sim/cris/asm/movecrt32.ms
-565043672daf4f7395eb4efe7c2dc629  sim/testsuite/sim/cris/asm/movect10.ms
-8265c3e5f0cec4ddb884b9740689ce56  sim/testsuite/sim/cris/asm/movei.ms
-f281c7e575f851b5dde60ee7b72fdde1  sim/testsuite/sim/cris/asm/movempc.ms
-dd2500a9c794d29818b9b89fbff9899e  sim/testsuite/sim/cris/asm/movemr.ms
-d972f2e08c829a759859a71e68b136dd  sim/testsuite/sim/cris/asm/movemrv10.ms
-abb5e89b50f55827e90d50ca04cbc2ed  sim/testsuite/sim/cris/asm/movemrv32.ms
-36508141125864999a9d627f47d85d7d  sim/testsuite/sim/cris/asm/movepcb.ms
-18ae624b3c2bbfa410dec0cdf25b49c6  sim/testsuite/sim/cris/asm/movepcd.ms
-5677bd81887a8a8d1cc44d6e0b2b8fe3  sim/testsuite/sim/cris/asm/movepcw.ms
-dff4cfde15294bc9a91d3c44534b8793  sim/testsuite/sim/cris/asm/moveq.ms
-99a55a2f2e0305cd73bc387ffe75c701  sim/testsuite/sim/cris/asm/moveqpc.ms
-c538f86c2d76489f295e6173a1bb8fc2  sim/testsuite/sim/cris/asm/mover.ms
-25ca120518990aa077c0e1c6a7c789de  sim/testsuite/sim/cris/asm/moverbpc.ms
-25ca120518990aa077c0e1c6a7c789de  sim/testsuite/sim/cris/asm/moverdpc.ms
-5118adbb201cb7bf5a37bef5da1c11fa  sim/testsuite/sim/cris/asm/moverm.ms
-21ecb091b9d8a63ed2986ba3001bff42  sim/testsuite/sim/cris/asm/moverpcb.ms
-b237b59f3cda9ba8783de6f3ec0dc9de  sim/testsuite/sim/cris/asm/moverpcd.ms
-4ac50ad29d540ee3522e4b61f5aa0b03  sim/testsuite/sim/cris/asm/moverpcw.ms
-25ca120518990aa077c0e1c6a7c789de  sim/testsuite/sim/cris/asm/moverwpc.ms
-fe9ec586c2fc70714864986dcf435482  sim/testsuite/sim/cris/asm/movesmp.ms
-6b8b85b69157e96282007e991e0065b4  sim/testsuite/sim/cris/asm/movmp.ms
-2dee3459d1adb88a531c1d807414630a  sim/testsuite/sim/cris/asm/movmp8.ms
-760e24ee5627c4e168d8870342fecb10  sim/testsuite/sim/cris/asm/movpmv10.ms
-3b9da18c291a6594a818808ab4524114  sim/testsuite/sim/cris/asm/movpmv32.ms
-b9e9c6cde823013b27e9d342a7cabb48  sim/testsuite/sim/cris/asm/movppc.ms
-c3c61f8d4c0515eeee975292dc0a718f  sim/testsuite/sim/cris/asm/movpr.ms
-461cec9d6dc84c3e170d3d48e567fca2  sim/testsuite/sim/cris/asm/movprv10.ms
-c715f5d22e83bf04003f9fc87087d65b  sim/testsuite/sim/cris/asm/movprv32.ms
-0e0c749b12b2842a5a162e7fae07263c  sim/testsuite/sim/cris/asm/movrss.ms
-df716e941d204c32f43af5effb0832d8  sim/testsuite/sim/cris/asm/movscpc.ms
-785a6bb740608dac717c73e57591deaa  sim/testsuite/sim/cris/asm/movscr.ms
-c67e215c008a0948de2968a3ac09b3eb  sim/testsuite/sim/cris/asm/movsm.ms
-c336d6a5c7f95498870e5c8a8419adac  sim/testsuite/sim/cris/asm/movsmpc.ms
-ebdf7ba59efa1850437aa3f32a2d17c5  sim/testsuite/sim/cris/asm/movsr.ms
-6c6a4cc3065b3267b236626d6ac47da1  sim/testsuite/sim/cris/asm/movsrpc.ms
-0d623805dbce567108dbf01a0fc5e565  sim/testsuite/sim/cris/asm/movssr.ms
-09d55b9f243be642c3274a0b7e3de327  sim/testsuite/sim/cris/asm/movucpc.ms
-213ed16674863ab8a94a648b4bacce9b  sim/testsuite/sim/cris/asm/movucr.ms
-b1fbda4cbc4148fcd1d52e10fac71369  sim/testsuite/sim/cris/asm/movum.ms
-f2882847ad3562b04049a44787285639  sim/testsuite/sim/cris/asm/movumpc.ms
-9dfa0a22cdc4310a491a61947e6ee18d  sim/testsuite/sim/cris/asm/movur.ms
-a3312cd2dfac8a338882fed18002d48e  sim/testsuite/sim/cris/asm/movurpc.ms
-7096f57332180f0f76e67be2df346d57  sim/testsuite/sim/cris/asm/mstep.ms
-967a768f7f4979c667a416d786211233  sim/testsuite/sim/cris/asm/msteppc1.ms
-6457b748159a9431e298113cf0d4d3ba  sim/testsuite/sim/cris/asm/msteppc2.ms
-7556676c19b21185c5d2d6a5c90f1935  sim/testsuite/sim/cris/asm/msteppc3.ms
-8c2eb325206f4b871171eed08ef84121  sim/testsuite/sim/cris/asm/mulv10.ms
-7f4b76ce2acc68884932a32ea46a3e7c  sim/testsuite/sim/cris/asm/mulv32.ms
-d8ee30b386546c5a4a5ef566f40403a3  sim/testsuite/sim/cris/asm/mulx.ms
-9833d52ddc745d1efcd7fd275647731c  sim/testsuite/sim/cris/asm/neg.ms
-111ab9f77dc7b41429a69ceda23db0e7  sim/testsuite/sim/cris/asm/nonvcv32.ms
-179a2d91e5cb558001696b20ec54c0d7  sim/testsuite/sim/cris/asm/nopv10t.ms
-38cf597a973dd9df4ea28b4872bc73b9  sim/testsuite/sim/cris/asm/nopv32t.ms
-3edb27491dd96dfda8285e7048dc1bb2  sim/testsuite/sim/cris/asm/nopv32t2.ms
-f2dffb8e24bb84e9340456f16901bd82  sim/testsuite/sim/cris/asm/nopv32t3.ms
-9e4218d5ddcfefb5541438b39a0a7e69  sim/testsuite/sim/cris/asm/nopv32t4.ms
-562df25c42da35363dd3d75ea3811f37  sim/testsuite/sim/cris/asm/not.ms
-6a41028ccbd191bab8591a495714b7df  sim/testsuite/sim/cris/asm/op3.ms
-65b2948bbaa9a9ff05df2a315d85037c  sim/testsuite/sim/cris/asm/opterr1.ms
-fe878493b053e82a05ca32cb114f3d25  sim/testsuite/sim/cris/asm/opterr2.ms
-8827577d2a0e20172dda7213c21a6805  sim/testsuite/sim/cris/asm/option1.ms
-9ef4d5feb8539d6586664b1275112ae3  sim/testsuite/sim/cris/asm/option2.ms
-7d0116d90d1fb2cde17c9aa42dcb2a52  sim/testsuite/sim/cris/asm/option3.ms
-9393cf1098b1bd5dae16cd948ef96f08  sim/testsuite/sim/cris/asm/option4.ms
-de067018bde6e6a1ba0c704e9f4a5ff1  sim/testsuite/sim/cris/asm/orc.ms
-fa06e0d70373d18ab8ae7182c42ad155  sim/testsuite/sim/cris/asm/orm.ms
-9b14a01d3bbba327dc100d7365b400a2  sim/testsuite/sim/cris/asm/orq.ms
-251d9c56c1a593339dbd56c764dc6d5e  sim/testsuite/sim/cris/asm/orr.ms
-25567231e8a01af2321bcb2b171fefb6  sim/testsuite/sim/cris/asm/pcplus.ms
-fbccae3a6f364b56c1d99624f359cd68  sim/testsuite/sim/cris/asm/raw1.ms
-a50ba432b1e9caafbf89399c1b308c27  sim/testsuite/sim/cris/asm/raw10.ms
-d307d3c141635b01f94fa57aad27491d  sim/testsuite/sim/cris/asm/raw11.ms
-0789486ef7e7e48f0d011b6753e0a61a  sim/testsuite/sim/cris/asm/raw12.ms
-fbdc943a9cb4c111b4847a8c5c14d950  sim/testsuite/sim/cris/asm/raw13.ms
-732a4b2c72c297f341dbba90410b1720  sim/testsuite/sim/cris/asm/raw14.ms
-5977c357ba7e18ac39e0c31bd47676be  sim/testsuite/sim/cris/asm/raw15.ms
-2db17fe6f4defa264e7cde99cffa8044  sim/testsuite/sim/cris/asm/raw16.ms
-28e25ab8991ba77ab89f1821d8133c56  sim/testsuite/sim/cris/asm/raw17.ms
-bc3f5069bc4718bbb9ffee12e416bdc6  sim/testsuite/sim/cris/asm/raw2.ms
-e9054d5776e6b5bb2e96b8f759575c48  sim/testsuite/sim/cris/asm/raw3.ms
-9f89dec5b8e1258f49b6dca9aaac3d3d  sim/testsuite/sim/cris/asm/raw4.ms
-267cb619594093cb439088e46c9df7ee  sim/testsuite/sim/cris/asm/raw5.ms
-f75b29130d9dab5a61f14c36ffb9384a  sim/testsuite/sim/cris/asm/raw6.ms
-f9b13410a674bdf42f84bf2238bfff9f  sim/testsuite/sim/cris/asm/raw7.ms
-da50619c2878e9a3e3bda17fbdafa435  sim/testsuite/sim/cris/asm/raw8.ms
-f8a0fd268e1e283ce98a93f08d462c7f  sim/testsuite/sim/cris/asm/raw9.ms
-726b5ab1d6dc49b8f877375c303005a4  sim/testsuite/sim/cris/asm/ret.ms
-3173b88b402a0711ac76f427a87b94b1  sim/testsuite/sim/cris/asm/rfe.ms
-f838f05b6522e477701884e02acaf2d1  sim/testsuite/sim/cris/asm/rfg.ms
-63adf223c2a656abb48a0043eb8fdf86  sim/testsuite/sim/cris/asm/rfn.ms
-2e86c644ce91fc382ad08f3a562de572  sim/testsuite/sim/cris/asm/sbfs.ms
-47d66dfd6c2b779644000a0d6c49eda8  sim/testsuite/sim/cris/asm/scc.ms
-30bc829c5021270dec933e8b5fc63d6a  sim/testsuite/sim/cris/asm/sfe.ms
-a33563a1f08346e7ea9ed16b4ca551af  sim/testsuite/sim/cris/asm/subc.ms
-1fc031c1da27d1c01da817c0c079ab0b  sim/testsuite/sim/cris/asm/subm.ms
-a81626c906efa0bcb8640d2d3dc2a691  sim/testsuite/sim/cris/asm/subq.ms
-1fdc774bc504c38cfa755a12367f5c2c  sim/testsuite/sim/cris/asm/subqpc.ms
-a3c92164147ee43f0b7866106074e567  sim/testsuite/sim/cris/asm/subr.ms
-e1a4ba67d2b7566edb96dbf069c4565e  sim/testsuite/sim/cris/asm/subxc.ms
-3c2d6762617530e584961f7630a34d58  sim/testsuite/sim/cris/asm/subxm.ms
-9222bee00f67bbb2bd16ff303efe46b4  sim/testsuite/sim/cris/asm/subxr.ms
-14961b2c32c9eba83a0bc5f5fc48eae5  sim/testsuite/sim/cris/asm/swap.ms
-a0edb51e5a425ccf881203ac68e404ed  sim/testsuite/sim/cris/asm/tb.ms
-02cf2500b611340a806d5d24828c2ae6  sim/testsuite/sim/cris/asm/test.ms
-ad02c5a2ac774bb2d6adc47502962bba  sim/testsuite/sim/cris/asm/testutils.inc
-7e588bd15391b40da304cf0ac6a12e78  sim/testsuite/sim/cris/asm/tjmpsrv32-2.ms
-18838432ce304ca531ba5932926b055c  sim/testsuite/sim/cris/asm/tjmpsrv32.ms
-ced76c9fa7ed26ba58076969d2478a47  sim/testsuite/sim/cris/asm/tjsrcv10.ms
-823aaac6a92b15ff53557fa9db198a41  sim/testsuite/sim/cris/asm/tjsrcv32.ms
-c173fb572b6df495c772e07f5363d46a  sim/testsuite/sim/cris/asm/tmemv10.ms
-22149fe91d725b6543fdcfe3a410c8dd  sim/testsuite/sim/cris/asm/tmemv32.ms
-3cffca323f9415f5a625f5b1242f533b  sim/testsuite/sim/cris/asm/tmulv10.ms
-b121c92d80063306def3d775b9979af3  sim/testsuite/sim/cris/asm/tmulv32.ms
-0324485cfaaf9118b075dfe3c7b1e3db  sim/testsuite/sim/cris/asm/tmvm1.ms
-eac55b1a5230bf3303fdc49b22a01b58  sim/testsuite/sim/cris/asm/tmvm2.ms
-a95ef7879071b9764ea063bf81183262  sim/testsuite/sim/cris/asm/tmvmrv10.ms
-521f5b458b8acca2fdef5ed414808f63  sim/testsuite/sim/cris/asm/tmvmrv32.ms
-06fedf705fd1d73f7df0f480a1e79110  sim/testsuite/sim/cris/asm/tmvrmv10.ms
-1ab6df2dfb8d3923abfff30ab2a9d321  sim/testsuite/sim/cris/asm/tmvrmv32.ms
-e4293514637b06706f6dcfe22f8c6548  sim/testsuite/sim/cris/asm/user.ms
-5d9082ffb5e6bbd88f4abe2d31142504  sim/testsuite/sim/cris/asm/x0-v10.ms
-391227b378b00377d2b79839b2c297c0  sim/testsuite/sim/cris/asm/x0-v32.ms
-3860abd7038ac35c0dd6b7d8ed864bf4  sim/testsuite/sim/cris/asm/x1-v10.ms
-c74fca6bdce3306512f05cf52ed25d17  sim/testsuite/sim/cris/asm/x1-v32.ms
-08340e3cd22828a9ea7b39ac3ab76a1a  sim/testsuite/sim/cris/asm/x10-v10.ms
-2910348ebc6b4fbc44558873d0cefd39  sim/testsuite/sim/cris/asm/x2-v10.ms
-6a3998da3b99d4ec714f919324b141d6  sim/testsuite/sim/cris/asm/x2-v32.ms
-153d9dfda7a2e7408435a4275c6627ec  sim/testsuite/sim/cris/asm/x3-v10.ms
-7d960ca6c9dc4a75b2f202e4743af3fd  sim/testsuite/sim/cris/asm/x3-v32.ms
-8c5264009df1ce14f68aa8da0b466fdf  sim/testsuite/sim/cris/asm/x4-v32.ms
-30dfac72b8fcf65e759d63135754eb58  sim/testsuite/sim/cris/asm/x5-v10.ms
-364156f156b8a7a6947d966d6bd74470  sim/testsuite/sim/cris/asm/x5-v32.ms
-db32e99bf41f9de5768a45b4e9903015  sim/testsuite/sim/cris/asm/x6-v10.ms
-5c135a54385ba1496f41c19577a7d0e0  sim/testsuite/sim/cris/asm/x6-v32.ms
-4afaec581991cef7a06f93749c270620  sim/testsuite/sim/cris/asm/x7-v10.ms
-d4276914b1dd16998d507727bab55d1e  sim/testsuite/sim/cris/asm/x7-v32.ms
-87aebcbccef1737739b9e1ff3dd2855f  sim/testsuite/sim/cris/asm/x8-v10.ms
-edefc7200870247aa1d8995ba517ba50  sim/testsuite/sim/cris/asm/x9-v10.ms
-78b6bcb1c8e05fee20f391868e884ac1  sim/testsuite/sim/cris/asm/xor.ms
-f1e11f695bb093625be81b8fc324de82  sim/testsuite/sim/cris/c/append1.c
-b29b7a67451e365293c87d70fd624660  sim/testsuite/sim/cris/c/c.exp
-0269530a71d3427dabbb84aeb11f3c0a  sim/testsuite/sim/cris/c/clone1.c
-aa50b7df97a5974860b06781313fefb4  sim/testsuite/sim/cris/c/clone2.c
-b976c33ef4b4a551c903d495708c81c3  sim/testsuite/sim/cris/c/clone3.c
-b61cf3cca5bf399335c11308f3a8bc52  sim/testsuite/sim/cris/c/clone4.c
-ed06fc45ffdd02256f0837acf4cc2cd5  sim/testsuite/sim/cris/c/clone5.c
-23a35358f6b5397b05295030549fb462  sim/testsuite/sim/cris/c/clone6.c
-7f8e2cee9aa8074fd03e27007034b38f  sim/testsuite/sim/cris/c/ex1.c
-62bbe8dd85a06ed358a98ef02ea0d3af  sim/testsuite/sim/cris/c/fcntl1.c
-86c2ceb180ebd532b644605f3da83107  sim/testsuite/sim/cris/c/fcntl2.c
-636048f3ba0304af174e7096f70abd17  sim/testsuite/sim/cris/c/fdopen1.c
-2e215ceef67a0ea53f763ecc91012fab  sim/testsuite/sim/cris/c/fdopen2.c
-9e857c786f649510740550577636fa60  sim/testsuite/sim/cris/c/freopen1.c
-f9ab2babd200f7bbd9b679f60c9dc136  sim/testsuite/sim/cris/c/freopen2.c
-1f8a017092ba6fcbdb63831a6d1fddfc  sim/testsuite/sim/cris/c/ftruncate1.c
-ce16bacf1d60113a5c0e03a1bb070d89  sim/testsuite/sim/cris/c/ftruncate2.c
-8d9ec2d8e98873231644fd2928eedd11  sim/testsuite/sim/cris/c/getcwd1.c
-749c4a65acd72ed14fa1ac3b2cb21028  sim/testsuite/sim/cris/c/gettod.c
-3eb9b7f3e6a1a8e35ac66cbf048e5bf4  sim/testsuite/sim/cris/c/hello.c
-2dc90db6492c7915acfd9d8c4c4b7fd3  sim/testsuite/sim/cris/c/kill1.c
-127bd507205856f25eee41bf62694d5b  sim/testsuite/sim/cris/c/kill2.c
-e04084e0ff81457675caa9fd22851711  sim/testsuite/sim/cris/c/kill3.c
-76252d805935152a8a395d166eb58367  sim/testsuite/sim/cris/c/mapbrk.c
-397784202fb51fa115d948fee98595f5  sim/testsuite/sim/cris/c/mmap1.c
-244728880f7a59ca8197581196366a8e  sim/testsuite/sim/cris/c/mmap2.c
-2c2a2069d8fcbc006396cfb9ae749a91  sim/testsuite/sim/cris/c/mmap3.c
-bd5c39f48eecbeab01151501a46817b5  sim/testsuite/sim/cris/c/mprotect1.c
-b6dede668026bc1b3a88551a29d37998  sim/testsuite/sim/cris/c/mprotect2.c
-d2eebcf4b27d666f115002238a95e9cc  sim/testsuite/sim/cris/c/mremap.c
-76a475d64d7a621fe12d8107b35de203  sim/testsuite/sim/cris/c/openpf1.c
-631048ddb6f9dff670e4a59beaabc81f  sim/testsuite/sim/cris/c/openpf2.c
-32afb9e16db589c161e15936615b72d8  sim/testsuite/sim/cris/c/openpf3.c
-2e9729e3376302b1ef46bde8bc7f88a5  sim/testsuite/sim/cris/c/openpf4.c
-59b654800ab7895cebfbc7b0f7114045  sim/testsuite/sim/cris/c/openpf5.c
-bed307959abae151f8251a2aa94f5fb3  sim/testsuite/sim/cris/c/pipe1.c
-46698027bdeb7ff534bcaae25cfed3ea  sim/testsuite/sim/cris/c/pipe2.c
-d240d97f980a2b5bf5e50f40cda75cb8  sim/testsuite/sim/cris/c/pipe3.c
-6652ae9c1f46ef0e790abe331a413cc2  sim/testsuite/sim/cris/c/pipe4.c
-b9526b425c4ac2ec2b08f90beb14868b  sim/testsuite/sim/cris/c/pipe5.c
-a6d1101c58781140696015731a836765  sim/testsuite/sim/cris/c/pipe6.c
-6caec686cea8fd103570f5a11d22103f  sim/testsuite/sim/cris/c/pipe7.c
-67ec38ee427de40a93d1dab24bca2787  sim/testsuite/sim/cris/c/readlink1.c
-dedbe73fd0801fd79e3926d56d5d3b69  sim/testsuite/sim/cris/c/readlink10.c
-255e7480e65cb422a35a979131718266  sim/testsuite/sim/cris/c/readlink11.c
-b4406066f629d45fa7a492ad97bb35fb  sim/testsuite/sim/cris/c/readlink2.c
-f13f3eb93fb037c514f32acce267e780  sim/testsuite/sim/cris/c/readlink3.c
-cddeadd523c716f3e065b3db91c6598d  sim/testsuite/sim/cris/c/readlink4.c
-198abb3f5d618e7e284a4339db78b38c  sim/testsuite/sim/cris/c/readlink5.c
-bb344255c26b7ff66ba972f594a52ff9  sim/testsuite/sim/cris/c/readlink6.c
-1394f715c3c3f448462016b2114396e2  sim/testsuite/sim/cris/c/readlink7.c
-6caf43a36fee1de1cd658dd7b9df9f28  sim/testsuite/sim/cris/c/readlink8.c
-85d07e227f3da16227efd370d4bd98e8  sim/testsuite/sim/cris/c/readlink9.c
-1d9766a687655c334147a81547f4d35b  sim/testsuite/sim/cris/c/rename2.c
-b022b9f20cf29fd4ddd8ff817ba9b256  sim/testsuite/sim/cris/c/rtsigprocmask1.c
-871e76b97d097a594ac69b273cd490ab  sim/testsuite/sim/cris/c/rtsigprocmask2.c
-4849952b6a39baee774d91c13bf86bec  sim/testsuite/sim/cris/c/rtsigsuspend1.c
-1a3574caa2bc1a3e97b486486582a550  sim/testsuite/sim/cris/c/rtsigsuspend2.c
-1b12a53abdcc110b05a27f86ec82a144  sim/testsuite/sim/cris/c/sched1.c
-2451f3d36cbfbe0fcac765781a858f0e  sim/testsuite/sim/cris/c/sched2.c
-994f44c9411fbf0f86e3bb31f3b086da  sim/testsuite/sim/cris/c/sched3.c
-bb365d27eec3e78769965aefa87ecf04  sim/testsuite/sim/cris/c/sched4.c
-56b085b53eea3eaff52ed3cbd614538f  sim/testsuite/sim/cris/c/sched5.c
-b55556b825ca9d54124a043dc3ed4911  sim/testsuite/sim/cris/c/sched6.c
-2606622deb8f7164b7dd52c54e8e0764  sim/testsuite/sim/cris/c/sched7.c
-e726def043e06af10f26f71f05989453  sim/testsuite/sim/cris/c/sched8.c
-ded7029b6558766ad174b8ad68e2a6ac  sim/testsuite/sim/cris/c/sched9.c
-b002267b24d426d4ae91610f8bea22ad  sim/testsuite/sim/cris/c/seek1.c
-dc28b3a9345098c89c39ac4c0ef02f86  sim/testsuite/sim/cris/c/seek2.c
-88553eaf83703a59cbc8361643680b59  sim/testsuite/sim/cris/c/setrlimit1.c
-bd926ac35b64d187f9466e95e69139be  sim/testsuite/sim/cris/c/sig1.c
-86279febd490f4c3df90f0b720149a09  sim/testsuite/sim/cris/c/sig10.c
-db54627436abb0ecfd7a5dc02f15d649  sim/testsuite/sim/cris/c/sig11.c
-e0ff04c2f66d5683806accf52c5a5c85  sim/testsuite/sim/cris/c/sig12.c
-aa0cc3e3a6590e21d1422c36e67d46f0  sim/testsuite/sim/cris/c/sig13.c
-2cc75950d1deb441cd82effb9a01ea94  sim/testsuite/sim/cris/c/sig2.c
-e99458c448500fd05e90d3a3ece06d9b  sim/testsuite/sim/cris/c/sig3.c
-349d8502d2d59845f68b8274721bb30f  sim/testsuite/sim/cris/c/sig4.c
-d3a8ade9091c19e8ae0f007ef249674c  sim/testsuite/sim/cris/c/sig5.c
-58be07d3625d5a3c39683cbc40e44445  sim/testsuite/sim/cris/c/sig6.c
-18d847c1e595ce572121ea443a15485e  sim/testsuite/sim/cris/c/sig7.c
-e0a416ad8d473e373c72594166064d96  sim/testsuite/sim/cris/c/sig8.c
-29c2f654808c90dbb79584a57bb693bc  sim/testsuite/sim/cris/c/sig9.c
-5aa665b959234a5539ad2545d6ed6780  sim/testsuite/sim/cris/c/sigreturn1.c
-cc2b1ab0259914e2ece1d15c0d4ddb7d  sim/testsuite/sim/cris/c/sigreturn2.c
-3399987136f5aa5a07a144e772b4eb8a  sim/testsuite/sim/cris/c/sigreturn3.c
-96353e6f0e8a0a7e6f52e4d55e03e0db  sim/testsuite/sim/cris/c/sigreturn4.c
-bd5bc121e85df515345f34f12c3c294d  sim/testsuite/sim/cris/c/sjlj.c
-b370018cab1c72d75c1ea87610fd7773  sim/testsuite/sim/cris/c/sock1.c
-c0e04f2b9fefcb80eb53e1550116f49f  sim/testsuite/sim/cris/c/stat1.c
-15815c6cf12beefc7597f68d9b5148c2  sim/testsuite/sim/cris/c/stat2.c
-654a16be0a1e70047321ae73a8e34c25  sim/testsuite/sim/cris/c/stat3.c
-01e1821708be4a05ad45a85c900f4daf  sim/testsuite/sim/cris/c/stat4.c
-cb3173d4abb5e27ab24ff09d049646bd  sim/testsuite/sim/cris/c/stat5.c
-be489bb1f78e97b8b3e47474a4b07933  sim/testsuite/sim/cris/c/stat7.c
-10eb2f4b61f6908d3cb3a06f0a8f2def  sim/testsuite/sim/cris/c/stat8.c
-ae1f0bf3a9c19be2d22882e324b4d36a  sim/testsuite/sim/cris/c/syscall1.c
-382a4423fb5f541e5fa2810c7b7ee7f3  sim/testsuite/sim/cris/c/syscall2.c
-bfa88f17cfcde03ee37379f87a5fcd2b  sim/testsuite/sim/cris/c/syscall3.c
-54e90fb194ebee986dfa9915ef03e704  sim/testsuite/sim/cris/c/syscall4.c
-858217cb5c5ddb0c2cffbb7ed06e5fe7  sim/testsuite/sim/cris/c/syscall5.c
-4556ba96585517de2f2eb2d2c898f2a1  sim/testsuite/sim/cris/c/syscall6.c
-f1411b703fcd6badb90f276646d32f24  sim/testsuite/sim/cris/c/syscall7.c
-11192685d2e3b68b4da90f7cf68fe582  sim/testsuite/sim/cris/c/syscall8.c
-9cef688125999d097b8fab9239621f08  sim/testsuite/sim/cris/c/sysctl1.c
-59df9318c8e3d0aebdfdc8e1769252ea  sim/testsuite/sim/cris/c/sysctl2.c
-28acfc17ffb85e9ad08bf03b54364eea  sim/testsuite/sim/cris/c/sysctl3.c
-537da8824f256e117c4f392687279519  sim/testsuite/sim/cris/c/thread2.c
-48d76b9632e424203cafd7d2a10424fa  sim/testsuite/sim/cris/c/thread3.c
-0c9e2d022ccbfd44ca86687c68f5d67e  sim/testsuite/sim/cris/c/thread4.c
-5aef57f0aa440d4a2e9cd8ebad961daa  sim/testsuite/sim/cris/c/thread5.c
-b8cf5d844a877a014c7e928e17856db0  sim/testsuite/sim/cris/c/time1.c
-c065dec5d6d385dfd55808a041c17ab1  sim/testsuite/sim/cris/c/time2.c
-17706d61b6ff3a97993baa049383e034  sim/testsuite/sim/cris/c/truncate1.c
-dade7a63298c84d0174ebda71a7fa376  sim/testsuite/sim/cris/c/truncate2.c
-754e51048e1a20f21f95d5f5b76e315a  sim/testsuite/sim/cris/c/ugetrlimit1.c
-d7574d3043705abb13a00a2684b5d915  sim/testsuite/sim/cris/hw/rv-n-cris/host1.ms
-dbe2031bb4db0e18eb8b262a35576545  sim/testsuite/sim/cris/hw/rv-n-cris/irq1.ms
-aa7ad744b0bc60196bdf954177f2cb95  sim/testsuite/sim/cris/hw/rv-n-cris/irq2.ms
-16170ceabd6c9848db05b8cfc2eedcf7  sim/testsuite/sim/cris/hw/rv-n-cris/irq3.ms
-84d3ac00e10363039e374d6c6f0981ea  sim/testsuite/sim/cris/hw/rv-n-cris/irq4.ms
-3b551095d657c411e3f6ae88d9d00f77  sim/testsuite/sim/cris/hw/rv-n-cris/irq5.ms
-44e633f375ddc4d5894941c26c1c45f8  sim/testsuite/sim/cris/hw/rv-n-cris/irq6.ms
-6332e0f695520a5fd138ddfc5de0dcea  sim/testsuite/sim/cris/hw/rv-n-cris/mbox1.ms
-772a3407fa1e2fc1a810157f58887cde  sim/testsuite/sim/cris/hw/rv-n-cris/mem1.ms
-8a8d262fc5f4bdd1b576f5085dd86b39  sim/testsuite/sim/cris/hw/rv-n-cris/mem2.ms
-05eff01544466ceb8cc637ae1ed7c96d  sim/testsuite/sim/cris/hw/rv-n-cris/poll1.ms
-ecbeb52370b71fd859dc5f48b2bde71e  sim/testsuite/sim/cris/hw/rv-n-cris/quit.s
-65043cb6d8a120d034020be5662aeb57  sim/testsuite/sim/cris/hw/rv-n-cris/rvc.exp
-447863ee59979057a731bd58463fa304  sim/testsuite/sim/cris/hw/rv-n-cris/std.dev
-c9091f1850cd8db0e2d3f3696e91054a  sim/testsuite/sim/cris/hw/rv-n-cris/testutils.inc
-d74cffc2804266c55d97d7b03388e421  sim/testsuite/sim/cris/hw/rv-n-cris/trivial1.ms
-3073a96241c996d1c0c68974914f74bf  sim/testsuite/sim/cris/hw/rv-n-cris/trivial2.ms
-ef064c7b060493a8f7faf78eb0cae219  sim/testsuite/sim/cris/hw/rv-n-cris/trivial3.ms
-7673098aa15ed428f71f5b22a1f13d0c  sim/testsuite/sim/cris/hw/rv-n-cris/trivial4.ms
-f6d32608623f87d96663d265b179fb6f  sim/testsuite/sim/cris/hw/rv-n-cris/trivial4.r
-4b44b5e187cf10e9a1e097d6d0c785a1  sim/testsuite/sim/cris/hw/rv-n-cris/trivial5.ms
-a2452f548d0fe6d247d6a5b6b4d62721  sim/testsuite/sim/cris/hw/rv-n-cris/wd1.ms
-503d6096668d67d46c257e7895d84d31  sim/testsuite/sim/fr30/add.cgs
-692e2c452c77ecbc6b74405fbfb8764f  sim/testsuite/sim/fr30/add.ms
-726473e3a587a7dc454557dc8b4c43db  sim/testsuite/sim/fr30/add2.cgs
-ae7aebd1064ea16900d3b009feddd60d  sim/testsuite/sim/fr30/addc.cgs
-9d0cb44436f746f3c9888587a0705941  sim/testsuite/sim/fr30/addn.cgs
-030942418ed8e981370a1d4e1489b9b2  sim/testsuite/sim/fr30/addn2.cgs
-8f9d88e4c545aca64898cbd90c3d16a4  sim/testsuite/sim/fr30/addsp.cgs
-78fc35acbc4a167797bd863fd991a785  sim/testsuite/sim/fr30/allinsn.exp
-8987709e3323037c23eb5559a2a05b79  sim/testsuite/sim/fr30/and.cgs
-5948be319fc5808a6b19793d9e5bbc7d  sim/testsuite/sim/fr30/andb.cgs
-85c3eb5c04a5558fa911df3e30e3679b  sim/testsuite/sim/fr30/andccr.cgs
-d33f46c321f6a6972442f4bade06656a  sim/testsuite/sim/fr30/andh.cgs
-3daf2597d21b8195e0c0a1650be412df  sim/testsuite/sim/fr30/asr.cgs
-6cc8644c6594267688e0cfa178a7bd73  sim/testsuite/sim/fr30/asr2.cgs
-63da4dc66d15a7647a2b0612f35a8564  sim/testsuite/sim/fr30/bandh.cgs
-3838077d837c2b8656d8a398cbf96482  sim/testsuite/sim/fr30/bandl.cgs
-c2961d1998d0f226e73fb2f0c8b37746  sim/testsuite/sim/fr30/bc.cgs
-fd0034e39e50a5ad93071dbc6718e3b6  sim/testsuite/sim/fr30/beorh.cgs
-0c254917d1438ef4f7cb6dbd5683cf75  sim/testsuite/sim/fr30/beorl.cgs
-e76365e82b93ee554e15a75585b0c27c  sim/testsuite/sim/fr30/beq.cgs
-528b0bd224d9631b14de438842a363c4  sim/testsuite/sim/fr30/bge.cgs
-8656edc8211fb004093f703158a7c9ee  sim/testsuite/sim/fr30/bgt.cgs
-29f7caeaad4350f3f89236f16849b148  sim/testsuite/sim/fr30/bhi.cgs
-825b7df0d31175f17fb30a27a90d6f05  sim/testsuite/sim/fr30/ble.cgs
-fa428bc4576d35a4d06fe83db66f1e20  sim/testsuite/sim/fr30/bls.cgs
-107058d96ac7c888d901300eb006d5c3  sim/testsuite/sim/fr30/blt.cgs
-11ca26e18c1fa7c05d9980f28911fc84  sim/testsuite/sim/fr30/bn.cgs
-f419d8740920121331afb15e71725c80  sim/testsuite/sim/fr30/bnc.cgs
-b4e156196e642664ce263f393a7f53be  sim/testsuite/sim/fr30/bne.cgs
-78f28bc2aa59a4a6dc4cdd7971e98108  sim/testsuite/sim/fr30/bno.cgs
-00ced4e4a8d48e061be334729bcf9972  sim/testsuite/sim/fr30/bnv.cgs
-93d8f4110bc336023847d2e425d27fac  sim/testsuite/sim/fr30/borh.cgs
-51632bbf7fcc2d274e4b7d4ee75b9786  sim/testsuite/sim/fr30/borl.cgs
-5f0977ee9d55754ffceaf3dc2242781d  sim/testsuite/sim/fr30/bp.cgs
-118242b7ecdaa35cdce8a8504e75b4be  sim/testsuite/sim/fr30/bra.cgs
-50c15ddbc5bfffd5f9b4784313984dd1  sim/testsuite/sim/fr30/btsth.cgs
-c0e8ab52947ed9bccc6646be37f2b82e  sim/testsuite/sim/fr30/btstl.cgs
-b3436c5fa08665c3fd9b9d103bbfd4ca  sim/testsuite/sim/fr30/bv.cgs
-1fb7a6a1cbbdff7ba6882c47dc8b3071  sim/testsuite/sim/fr30/call.cgs
-d5c3720a8d9a8fa88fb45d97681466d2  sim/testsuite/sim/fr30/cmp.cgs
-5fc1b6eee6a98d786ad146de39bee17e  sim/testsuite/sim/fr30/cmp2.cgs
-92b6ed80cfaf734393514a354f558e12  sim/testsuite/sim/fr30/copld.cgs
-68e0c1e7bd73024e03d90e17d1b479e7  sim/testsuite/sim/fr30/copop.cgs
-d82e1c778335479eb3257be5f4027f60  sim/testsuite/sim/fr30/copst.cgs
-8f3d3ac55197c8d27a1bb6022ce7ab9c  sim/testsuite/sim/fr30/copsv.cgs
-1986f8b31251f3fcfead747f2fbc2067  sim/testsuite/sim/fr30/div.ms
-8bca5d07304281074232cf501f58d578  sim/testsuite/sim/fr30/div0s.cgs
-9497d9229865b30c86f4e77508a9a406  sim/testsuite/sim/fr30/div0u.cgs
-42628131079d04c855f5e218a162c210  sim/testsuite/sim/fr30/div1.cgs
-2d45aaaebfe96a478d94442f475255dd  sim/testsuite/sim/fr30/div2.cgs
-82b175871b9a3802f2b0141fdbd69314  sim/testsuite/sim/fr30/div3.cgs
-2ae5a90062cafe57f759112f5b2f3b06  sim/testsuite/sim/fr30/div4s.cgs
-18a90aaef63c891698afe734d2152d18  sim/testsuite/sim/fr30/dmov.cgs
-55b2418400196e2f3a85b8e6b696a252  sim/testsuite/sim/fr30/dmovb.cgs
-1a350c8e3f57a176585fc796b07bfc7d  sim/testsuite/sim/fr30/dmovh.cgs
-1df39f183df8aeeb7fa41d92384a0ad9  sim/testsuite/sim/fr30/enter.cgs
-bc265d868045395c100b7c74d441979a  sim/testsuite/sim/fr30/eor.cgs
-63ca215997d767d234ca89fcd3e11968  sim/testsuite/sim/fr30/eorb.cgs
-9f77138b83e182472a14212e5bb72352  sim/testsuite/sim/fr30/eorh.cgs
-67ece84ba59ec30e07e99a8dfb888f56  sim/testsuite/sim/fr30/extsb.cgs
-98f0923dc897604e64e47dd027c2fab1  sim/testsuite/sim/fr30/extsh.cgs
-006acd8b3fbfdfdc9cf751d3551da65b  sim/testsuite/sim/fr30/extub.cgs
-6b9b96096efcac0f5ee86ff1b1327da4  sim/testsuite/sim/fr30/extuh.cgs
-76cd07dd7c78722fbbfa49bd94b5c61b  sim/testsuite/sim/fr30/hello.ms
-a447d626d0829c31c4cc72b9aca610bc  sim/testsuite/sim/fr30/int.cgs
-c7f3e31654d7134dfec197a23c612f8d  sim/testsuite/sim/fr30/inte.cgs
-a92cc956b699bbdead9c1e8ea21b7d85  sim/testsuite/sim/fr30/jmp.cgs
-bd02ed7b7c8470f6853a555a57818cb3  sim/testsuite/sim/fr30/ld.cgs
-d9bcff3a1f3a6885615cb81215deb73d  sim/testsuite/sim/fr30/ldi20.cgs
-5c29b0babb4c478e18950a01250bacdf  sim/testsuite/sim/fr30/ldi32.cgs
-05c014e0472c8041119ea95bda37df65  sim/testsuite/sim/fr30/ldi8.cgs
-291df7a8065e554654d635d4319a6e07  sim/testsuite/sim/fr30/ldm0.cgs
-40b06cc66fd096915a199de617efa043  sim/testsuite/sim/fr30/ldm1.cgs
-980de17f49e0206c409122a710bd9660  sim/testsuite/sim/fr30/ldres.cgs
-cd540be2b820c7304d49a2cd4c804ebc  sim/testsuite/sim/fr30/ldub.cgs
-7f827594dfa2a9ea9cbdb822808bb96e  sim/testsuite/sim/fr30/lduh.cgs
-f4b6c297ead375254a31836c88c758db  sim/testsuite/sim/fr30/leave.cgs
-ff01a6642b097f295e29b8aad506bf20  sim/testsuite/sim/fr30/lsl.cgs
-e5b073abade7a63209ab21e8757714e5  sim/testsuite/sim/fr30/lsl2.cgs
-fac808112158b0d7c9a972b5c1e51ad9  sim/testsuite/sim/fr30/lsr.cgs
-8fb50d3723a8e4fda2cca68f8138fc68  sim/testsuite/sim/fr30/lsr2.cgs
-58553f1bced962c2d9f26ff2f53aecfc  sim/testsuite/sim/fr30/misc.exp
-cd116a2a1dac5e397ecc2f7456053564  sim/testsuite/sim/fr30/mov.cgs
-e6e56816b0dcb650c26b46a33cb1ffac  sim/testsuite/sim/fr30/mul.cgs
-4e62467dd71697f7cf6d64cebf2531e8  sim/testsuite/sim/fr30/mulh.cgs
-201ea7a49f59a0a5e628e9b549bfb5b8  sim/testsuite/sim/fr30/mulu.cgs
-ee0c0d6979b1682c427b387664c204a8  sim/testsuite/sim/fr30/muluh.cgs
-68d1886400abacb8a7f24d72bda2a966  sim/testsuite/sim/fr30/nop.cgs
-c8347c5b0effef1e42f0249483e5ac6a  sim/testsuite/sim/fr30/or.cgs
-2cf5b46fe78a0e966c03c134642e61c6  sim/testsuite/sim/fr30/orb.cgs
-d01fa8a22cb8df995a868145d71bbf94  sim/testsuite/sim/fr30/orccr.cgs
-8557874b84d96137c9d2163f29a20473  sim/testsuite/sim/fr30/orh.cgs
-89bf2353814e13f2d5a94d209ace80f3  sim/testsuite/sim/fr30/ret.cgs
-16372b76ce969bd0041202b277ab1aae  sim/testsuite/sim/fr30/reti.cgs
-ae8fa268a41ffb274a7a89b9f7344ac3  sim/testsuite/sim/fr30/st.cgs
-6c4bf429941803c250acd9ed35221ec8  sim/testsuite/sim/fr30/stb.cgs
-32b42ce0a2b13161bf8e4d8cab413410  sim/testsuite/sim/fr30/sth.cgs
-5e026ff1027b8aa7cb374c51b5c4b9e8  sim/testsuite/sim/fr30/stilm.cgs
-fae958eef826c19e4e7640eb0378c0c9  sim/testsuite/sim/fr30/stm0.cgs
-5f28ff21c8db4465c66df254b3a6d631  sim/testsuite/sim/fr30/stm1.cgs
-546a174bd7aa7dfa4f54ba99e5b2d617  sim/testsuite/sim/fr30/stres.cgs
-3ad5b0fdc53e83258fadc664f63c6a82  sim/testsuite/sim/fr30/sub.cgs
-f32638a3919a1385e630a7e29518e0ed  sim/testsuite/sim/fr30/subc.cgs
-da584f1cf2dcd0f85046a64bc5d9ba5e  sim/testsuite/sim/fr30/subn.cgs
-c174cd3fd5b8667dbc7b7741ec7449e3  sim/testsuite/sim/fr30/testutils.inc
-9d0e5f42019df498994f84948f9de403  sim/testsuite/sim/fr30/xchb.cgs
-9f35e5c8475a3dce4d3d1f86192b757f  sim/testsuite/sim/frv/add.cgs
-24091903403ffb172b0b81cfbb3f331e  sim/testsuite/sim/frv/add.pcgs
-0328850bbb204540e39224902cea7437  sim/testsuite/sim/frv/addcc.cgs
-1e7f2deead6fb5c78f146ae3eb2fc6be  sim/testsuite/sim/frv/addi.cgs
-30964df0b57f2b91f67fc38a30d8e814  sim/testsuite/sim/frv/addicc.cgs
-d2ab686875a7fa6635f150cf02ff06f9  sim/testsuite/sim/frv/addx.cgs
-0946412ade0a468bd29c482a88af3c60  sim/testsuite/sim/frv/addxcc.cgs
-bb0118ec08792d6499ce7742161f206f  sim/testsuite/sim/frv/addxi.cgs
-02991b6e743da14fcd82acaa74ad2de3  sim/testsuite/sim/frv/addxicc.cgs
-1875ffded69787f7962d216e83812183  sim/testsuite/sim/frv/allinsn.exp
-fe0ecb3cd4f9a5a2a8cd1b994f8e8ae2  sim/testsuite/sim/frv/and.cgs
-558c0693de0aa42e5ba756ef35228332  sim/testsuite/sim/frv/andcc.cgs
-7436eebb11c6129d8a06aa52d0641d19  sim/testsuite/sim/frv/andcr.cgs
-2fdea54dc1608b57111f0b1d657b3daa  sim/testsuite/sim/frv/andi.cgs
-54e056f54d116cde6e23ee7dee9a9c8b  sim/testsuite/sim/frv/andicc.cgs
-4a13d5d2947c3543c94581ba88ec7fc4  sim/testsuite/sim/frv/andncr.cgs
-cf73edecc782c3ef0b7548f1acb34cd5  sim/testsuite/sim/frv/bar.cgs
-b03ca91fbf4d98089e108f2fe411eecb  sim/testsuite/sim/frv/bc.cgs
-36d2a277daae79b65a1fe73b38c101ba  sim/testsuite/sim/frv/bcclr.cgs
-4fe0320394ce9fd521b0b903b37a44de  sim/testsuite/sim/frv/bceqlr.cgs
-17b1b6dc979b707b15d4d415b6a8c50a  sim/testsuite/sim/frv/bcgelr.cgs
-ad6bad34a15a4f2986566b50e2af52b8  sim/testsuite/sim/frv/bcgtlr.cgs
-9b2a570d81405ae96edd05841a00340c  sim/testsuite/sim/frv/bchilr.cgs
-bd1949fa6a0cbbd0faee3d33a7d2ed7b  sim/testsuite/sim/frv/bclelr.cgs
-8a77e7659d777d6c0d67e89e341cf17c  sim/testsuite/sim/frv/bclr.cgs
-e3f8edcf3d2202102c308c006b574282  sim/testsuite/sim/frv/bclslr.cgs
-73a5313d89e6d5975be48f3e2522c1a2  sim/testsuite/sim/frv/bcltlr.cgs
-62439f50d31a64a7d77bfe8d242d68c2  sim/testsuite/sim/frv/bcnclr.cgs
-45750ad0543745a1b21a7b795a774105  sim/testsuite/sim/frv/bcnelr.cgs
-5032a5008a230358b8434e010fa7aa66  sim/testsuite/sim/frv/bcnlr.cgs
-e9aafacc4f7c85928dd1c32c5c79fc5a  sim/testsuite/sim/frv/bcnolr.cgs
-b0d3f8840cbd815c5cf1fed7f60b95ac  sim/testsuite/sim/frv/bcnvlr.cgs
-34c1f1091b4c9bebc5fd6e10d045f570  sim/testsuite/sim/frv/bcplr.cgs
-318cb22eb343ae2ba7c0a11ec86755f3  sim/testsuite/sim/frv/bcralr.cgs
-93142a00f792c55ff26c67e4495c3ee8  sim/testsuite/sim/frv/bctrlr.cgs
-37f80752cbc102b0e3eebab206a7e851  sim/testsuite/sim/frv/bcvlr.cgs
-5f883fbcb2224a26bc0e0d7eb91fd2de  sim/testsuite/sim/frv/beq.cgs
-a49be0c11999c9c5fe7164a2d478236c  sim/testsuite/sim/frv/beqlr.cgs
-d2ca7d2383745ede57de7cf3a71b250b  sim/testsuite/sim/frv/bge.cgs
-0d8bd8099d69931cea52745c2fd79b8b  sim/testsuite/sim/frv/bgelr.cgs
-df584e46e6bbe3d1636c1fbaa73ca746  sim/testsuite/sim/frv/bgt.cgs
-7e5adf4d17b96ce4a3b36beea51aadc6  sim/testsuite/sim/frv/bgtlr.cgs
-894db98a371eaba135a686990f22f504  sim/testsuite/sim/frv/bhi.cgs
-58728788baa01be3e6482ab14b5fde4f  sim/testsuite/sim/frv/bhilr.cgs
-3da93d4f6c18f18193c0441a79758bcc  sim/testsuite/sim/frv/ble.cgs
-e54bc9be577ed53f98a7256e02292a9f  sim/testsuite/sim/frv/blelr.cgs
-313bac7f8246cca4710202da37d93d37  sim/testsuite/sim/frv/bls.cgs
-b04e822dac50d26e600e9af54cc86907  sim/testsuite/sim/frv/blslr.cgs
-aeccfedc8dc931ff8b70da7c99c2236a  sim/testsuite/sim/frv/blt.cgs
-b32fc8a8e6bba1b163e798c7a6b2998a  sim/testsuite/sim/frv/bltlr.cgs
-851005c4ef6143a0dc488d4a100b97f7  sim/testsuite/sim/frv/bn.cgs
-a26faa5267491071d341abedcc58aa36  sim/testsuite/sim/frv/bnc.cgs
-f91ccc0eb4e839737d94f68601bf130f  sim/testsuite/sim/frv/bnclr.cgs
-8b544d33708f95c5fe86075bfc046ba3  sim/testsuite/sim/frv/bne.cgs
-da1d1539bcb135ec8ce2fa2df168cd18  sim/testsuite/sim/frv/bnelr.cgs
-31e7cd50ae42d84c7edbb16ec1824569  sim/testsuite/sim/frv/bnlr.cgs
-3014022934a14b3431fdacf8e86dd3eb  sim/testsuite/sim/frv/bno.cgs
-8f07983738e8be6e8f294385e90a83f1  sim/testsuite/sim/frv/bnolr.cgs
-480ed9fb8591ba5cba8c36bbf8fac25b  sim/testsuite/sim/frv/bnv.cgs
-078c55334418476eb782ff3b071fc106  sim/testsuite/sim/frv/bnvlr.cgs
-6e0ed99106e53f1ae7c54bd6a15d2a7d  sim/testsuite/sim/frv/bp.cgs
-af01f45076997b2efc4cbed1bfbeb90f  sim/testsuite/sim/frv/bplr.cgs
-7d76bf8128cc9482f2de7d01e2bde23a  sim/testsuite/sim/frv/bra.cgs
-36ccbee5f8a7659d1403b57bda54a1cf  sim/testsuite/sim/frv/bralr.cgs
-1faedf52637eb93c36507f38fd31fea3  sim/testsuite/sim/frv/branch.pcgs
-67b49f46f325d357092e83a5af86ffe8  sim/testsuite/sim/frv/break.cgs
-9868adbc8297b59031bb110c1104e524  sim/testsuite/sim/frv/bv.cgs
-1506bd2f46dbdf8b5580412cc36cc631  sim/testsuite/sim/frv/bvlr.cgs
-54b2d852374130520e29e72dc46923e0  sim/testsuite/sim/frv/cadd.cgs
-9ebd87890c8a7abc680822709889778c  sim/testsuite/sim/frv/caddcc.cgs
-36b77ec6afe8955468cfc59058d7e96a  sim/testsuite/sim/frv/call.cgs
-05a1ec4efd6909bce7ced2cff0a0d8c8  sim/testsuite/sim/frv/call.pcgs
-6c696a162425d51ed1a198eadc9e8ec6  sim/testsuite/sim/frv/callil.cgs
-5900af0d1f33281e6a8d166d3cabe74a  sim/testsuite/sim/frv/calll.cgs
-6833a0f9a6a97eca6ec71259ea075028  sim/testsuite/sim/frv/cand.cgs
-35609b2536c1c21599e2d70a762854f6  sim/testsuite/sim/frv/candcc.cgs
-794be640f3ea38845a7fb677c250fe48  sim/testsuite/sim/frv/ccalll.cgs
-61d311d36b7dec576d8be1a6a047278d  sim/testsuite/sim/frv/cckc.cgs
-e7a1ad746f682025747fa48379b5db6f  sim/testsuite/sim/frv/cckeq.cgs
-21793c07586326f7d5b7caeb20faf21b  sim/testsuite/sim/frv/cckge.cgs
-511bee637d7a77e1f4ead6e790993d68  sim/testsuite/sim/frv/cckgt.cgs
-ad7585e6f6dbc249f1e67deba9847034  sim/testsuite/sim/frv/cckhi.cgs
-1f8696a6d62df0c7ee21c40e74d2af30  sim/testsuite/sim/frv/cckle.cgs
-2974e1e8788d707888a2c3ff248a0d82  sim/testsuite/sim/frv/cckls.cgs
-5393775815f48e4a5a811b3a06ff8503  sim/testsuite/sim/frv/ccklt.cgs
-91e3dc0afab2fdfca7731c7e1f37e33f  sim/testsuite/sim/frv/cckn.cgs
-a659a5c06a90b61548ad0d23636f740b  sim/testsuite/sim/frv/ccknc.cgs
-40115dcc72d0b6f1b5b4701a63e94c83  sim/testsuite/sim/frv/cckne.cgs
-da2ea0628931ee759747b3b1568f9e95  sim/testsuite/sim/frv/cckno.cgs
-1516ca30ed3dda235da364d46c38d2a1  sim/testsuite/sim/frv/ccknv.cgs
-dd7b86dd559bc919891c419cc5b9eb45  sim/testsuite/sim/frv/cckp.cgs
-b0b3ba45dce79cce5d0db607ed12fbfe  sim/testsuite/sim/frv/cckra.cgs
-0c3aa7b3b5fd1c05678011c190e83144  sim/testsuite/sim/frv/cckv.cgs
-999bafc99f41d16b6bd3b925cf296de0  sim/testsuite/sim/frv/ccmp.cgs
-ffdac6d343d018ba34d4952027680104  sim/testsuite/sim/frv/cfabss.cgs
-7b8111a1958ac7ac0609e3ec19946402  sim/testsuite/sim/frv/cfadds.cgs
-a557f55cfe20662991a594673e5a877b  sim/testsuite/sim/frv/cfckeq.cgs
-ccbed047cb7e704f8caefbf30b21d58e  sim/testsuite/sim/frv/cfckge.cgs
-7b350a57e6efb69056eeffc36aa0cac4  sim/testsuite/sim/frv/cfckgt.cgs
-34a484991db89cb85939b4735fd01d7d  sim/testsuite/sim/frv/cfckle.cgs
-055fa9b5ef1f3c1f955737457b0f3430  sim/testsuite/sim/frv/cfcklg.cgs
-c3fbed74046a3c4d5d74af309a283001  sim/testsuite/sim/frv/cfcklt.cgs
-42256da6637466abfe0f07b1103c7139  sim/testsuite/sim/frv/cfckne.cgs
-bff6dd1636bea003ff556d16f1e3f843  sim/testsuite/sim/frv/cfckno.cgs
-d8c97eebc3c3db0b2962b1d7181cc6c6  sim/testsuite/sim/frv/cfcko.cgs
-124ee6149a335aca9a615e6e9e9521ff  sim/testsuite/sim/frv/cfckra.cgs
-6dd0a3407bccbe944de3004234e1ee11  sim/testsuite/sim/frv/cfcku.cgs
-d0ac23eed64316704af3b22028e3e476  sim/testsuite/sim/frv/cfckue.cgs
-506b3aaeb2f55f7313b18756c9ea8897  sim/testsuite/sim/frv/cfckug.cgs
-c0d65d42e391ceb55e2d6eed4954f643  sim/testsuite/sim/frv/cfckuge.cgs
-2dce4079bac9e873cc2f7466bbdbc0bd  sim/testsuite/sim/frv/cfckul.cgs
-697ec5d0eb83f0aa0c438264e7dacf74  sim/testsuite/sim/frv/cfckule.cgs
-4ae9085c410dd43f5a03a680a8ef06f0  sim/testsuite/sim/frv/cfcmps.cgs
-255041537a2ba5cddbc94a66463c52ab  sim/testsuite/sim/frv/cfdivs.cgs
-d8e85f1e2dfaa87480b812c7c03ee19b  sim/testsuite/sim/frv/cfitos.cgs
-241fa1bef3f4eb4e60aebeaa3a5e5d8e  sim/testsuite/sim/frv/cfmadds.cgs
-4fa1060d3ea708c05623eaa8fa23a4fd  sim/testsuite/sim/frv/cfmas.cgs
-b69a810fc6f3f907c57797a5721333fd  sim/testsuite/sim/frv/cfmovs.cgs
-258db7edbd93cc7f09cde29e3522194e  sim/testsuite/sim/frv/cfmss.cgs
-8efb2a5d93915406532ba43d46c08545  sim/testsuite/sim/frv/cfmsubs.cgs
-ccde36a3a60f282ea7e7581d6ddbe200  sim/testsuite/sim/frv/cfmuls.cgs
-0eb9d6f24940fa1b3a290ee7f83529e6  sim/testsuite/sim/frv/cfnegs.cgs
-e6cce9c3b04ed7fd801dafb45bcdd866  sim/testsuite/sim/frv/cfsqrts.cgs
-654e92ca5c279eff83c44a07b5a4f8bd  sim/testsuite/sim/frv/cfstoi.cgs
-d6e2c99d07b9c1a5fb5869dd9aecc1a4  sim/testsuite/sim/frv/cfsubs.cgs
-11bfcfb4b6f70c5075adaa4f37dca943  sim/testsuite/sim/frv/cjmpl.cgs
-e3edb4635dd416fa50ea0e1628a69aea  sim/testsuite/sim/frv/ckc.cgs
-bd306d227534038e358e212748f86d46  sim/testsuite/sim/frv/ckeq.cgs
-6829b406203cc09d6ac699fec2378bad  sim/testsuite/sim/frv/ckge.cgs
-c32d71a426bc21b198975069f0bc3503  sim/testsuite/sim/frv/ckgt.cgs
-8496d10703a6df931f2b4ea768c69356  sim/testsuite/sim/frv/ckhi.cgs
-5efca9c9c6f6785859bd2ed1ab619325  sim/testsuite/sim/frv/ckle.cgs
-2f2d7f51d4276d8bc6c7a559cf40358f  sim/testsuite/sim/frv/ckls.cgs
-325a426583fc25d49f02863c763aeb84  sim/testsuite/sim/frv/cklt.cgs
-5724440a0342cfb9923003f93f4e9c28  sim/testsuite/sim/frv/ckn.cgs
-b0fa5261302915fed6a0abb4165bdb3e  sim/testsuite/sim/frv/cknc.cgs
-2377457fe2384816953905fda6c3d04b  sim/testsuite/sim/frv/ckne.cgs
-1cbff10c95fb9390a7cc4d56fef5f794  sim/testsuite/sim/frv/ckno.cgs
-ad9476d15f761b15a7243c9030efa135  sim/testsuite/sim/frv/cknv.cgs
-6b8470231d2eb04c58135b6a02fd63cb  sim/testsuite/sim/frv/ckp.cgs
-5c41b0e945d708f91752456b93ca9c8d  sim/testsuite/sim/frv/ckra.cgs
-d0cadfc6114ffc4c49bd0b7cf87984dc  sim/testsuite/sim/frv/ckv.cgs
-eedecfb8fe25588cda9c858cec87c9e4  sim/testsuite/sim/frv/cld.cgs
-82952c2b9fbbc99ed421717e4ca1e9be  sim/testsuite/sim/frv/cldbf.cgs
-b61f258f8679789df4df0f96f085ed27  sim/testsuite/sim/frv/cldbfu.cgs
-bfc76c12370aafb393d878212832d3e3  sim/testsuite/sim/frv/cldd.cgs
-c466ade998b308dc18869d2a2d2f3ae5  sim/testsuite/sim/frv/clddf.cgs
-4494a0e9c7fd903a3280a5baec16e6db  sim/testsuite/sim/frv/clddfu.cgs
-1dbf3b1f587b8fde305387c2a6d7488c  sim/testsuite/sim/frv/clddu.cgs
-d7fefcc42f8ee556fc3e29e07866f54a  sim/testsuite/sim/frv/cldf.cgs
-01c147956ed40b80f7f01399bd71f33f  sim/testsuite/sim/frv/cldfu.cgs
-7f272aa06c9d1d01570e93ccfc3bed5d  sim/testsuite/sim/frv/cldhf.cgs
-1147cc9e693e642971e9920b10936733  sim/testsuite/sim/frv/cldhfu.cgs
-00bb5f98862bbebc770fac0fa658bf27  sim/testsuite/sim/frv/cldq.cgs
-cbf21bfce7b3ce694a9a0ffbecdd5edf  sim/testsuite/sim/frv/cldqu.cgs
-60dfef5c59d307cd1efd15c4403530ad  sim/testsuite/sim/frv/cldsb.cgs
-2311d8e2e1155bc0747ab69d1d80020c  sim/testsuite/sim/frv/cldsbu.cgs
-76fcbc22cb7f93f51d833bd012609086  sim/testsuite/sim/frv/cldsh.cgs
-218e7bf5cef1de12c72a7b41e0734233  sim/testsuite/sim/frv/cldshu.cgs
-91fd679b72e10313567ecee40d839288  sim/testsuite/sim/frv/cldu.cgs
-2b92477d71c35dbc5340bf6cf73436c4  sim/testsuite/sim/frv/cldub.cgs
-59af60628ef7e7f6c89aa5b2fa0c34c2  sim/testsuite/sim/frv/cldubu.cgs
-b3a1a12789fd5e052662744d3bd0a912  sim/testsuite/sim/frv/clduh.cgs
-f7adffe89325460b83af4ef27b83a02e  sim/testsuite/sim/frv/clduhu.cgs
-7640dbf388ab7b7e4462b20d93ca0dca  sim/testsuite/sim/frv/clrfa.cgs
-1ff43ea60f446681dd0636f4abf0afaf  sim/testsuite/sim/frv/clrfr.cgs
-1162b46f1c6271d41d44fd0376fd0abd  sim/testsuite/sim/frv/clrga.cgs
-3a258f66b006c6af176013d28706f114  sim/testsuite/sim/frv/clrgr.cgs
-6a19cdc6d3c89ca5145cd888160feea0  sim/testsuite/sim/frv/cmaddhss.cgs
-f552807622d2ead6a4c3c72b6ab6ea1c  sim/testsuite/sim/frv/cmaddhus.cgs
-b0ae2b6d72c1546e70b77d0f906ca816  sim/testsuite/sim/frv/cmand.cgs
-054aeba615c6c341369854f1405d85d8  sim/testsuite/sim/frv/cmbtoh.cgs
-c006cffe51ad60e2d97bfe726e6efc27  sim/testsuite/sim/frv/cmbtohe.cgs
-e322b79b6193bc8b98fdf7d2164e1242  sim/testsuite/sim/frv/cmcpxis.cgs
-2d2b7584e0bb578df1f9589e4e90bce6  sim/testsuite/sim/frv/cmcpxiu.cgs
-fb274f110b2b0e732c8ab6b0567641da  sim/testsuite/sim/frv/cmcpxrs.cgs
-2a371679272b85c51ff58344a6870ef8  sim/testsuite/sim/frv/cmcpxru.cgs
-f8de97a7353abe4fe732d79898771e06  sim/testsuite/sim/frv/cmexpdhd.cgs
-c0b5d47d5b02cc1f2017b7642a70d544  sim/testsuite/sim/frv/cmexpdhw.cgs
-031b21c3201bce5ff37ac1d2087209c8  sim/testsuite/sim/frv/cmhtob.cgs
-4907fd3e32af4b4b10ed57c593639002  sim/testsuite/sim/frv/cmmachs.cgs
-12c4a175cb447af16dd27310f13fe496  sim/testsuite/sim/frv/cmmachu.cgs
-f394652f9ebf77a1d90b8a114793c2cb  sim/testsuite/sim/frv/cmmulhs.cgs
-509ea4a10500e161ed7a4c16dca03eed  sim/testsuite/sim/frv/cmmulhu.cgs
-fe9af3628dda1a7e0478b27afcb4a903  sim/testsuite/sim/frv/cmnot.cgs
-d23dcfb1cdc685b13e28f46e60297128  sim/testsuite/sim/frv/cmor.cgs
-c23d94eb48818d1a8830ea6d0edc3260  sim/testsuite/sim/frv/cmov.cgs
-50823aeb4369412ff15e1c422ea6d8f7  sim/testsuite/sim/frv/cmovfg.cgs
-294f97c82070648f417c81cefbf0d68e  sim/testsuite/sim/frv/cmovfgd.cgs
-a92e4825d2c41be84a96f2f6db7de29b  sim/testsuite/sim/frv/cmovgf.cgs
-0772a396d1b99a6fc342b4f3d355d18c  sim/testsuite/sim/frv/cmovgfd.cgs
-fb9380da5f21f1be28670b94115e7cb2  sim/testsuite/sim/frv/cmp.cgs
-bd0fbf9e7faa375603574f1a40665865  sim/testsuite/sim/frv/cmpb.cgs
-0b2e49d6ce9f4d51307d7a0c0884c357  sim/testsuite/sim/frv/cmpba.cgs
-3b2a2c6753bd7ff55bc524a863d3a3cb  sim/testsuite/sim/frv/cmpi.cgs
-72215397d3a25089fcadc96d0449fa9d  sim/testsuite/sim/frv/cmqmachs.cgs
-891b8ae9013d787e9abf3f3980a93682  sim/testsuite/sim/frv/cmqmachu.cgs
-7e7ca53ba30cdcc99c94cd76e31edbfd  sim/testsuite/sim/frv/cmqmulhs.cgs
-9a28ed90097013dbe6c10888f811edec  sim/testsuite/sim/frv/cmqmulhu.cgs
-a030edea39f27d8535b72eab791a946c  sim/testsuite/sim/frv/cmsubhss.cgs
-571559015608fda8e86c36266d8aba4c  sim/testsuite/sim/frv/cmsubhus.cgs
-8b11d75d92bff2f80d736079756072af  sim/testsuite/sim/frv/cmxor.cgs
-d8c6afc2ab9d2f02351d88640635698f  sim/testsuite/sim/frv/cnot.cgs
-2521bd2ee748d58fdae65f585b453033  sim/testsuite/sim/frv/commitfa.cgs
-9f7ea5df90e576f10d78cdac9cc6ef50  sim/testsuite/sim/frv/commitfr.cgs
-122ad6f12a5ab84bec5262e1af02c9f1  sim/testsuite/sim/frv/commitga.cgs
-1abb897f3ac03712dcaf0fa415a85bb3  sim/testsuite/sim/frv/commitgr.cgs
-d68f7809049059eb9fdbdaef18d03edd  sim/testsuite/sim/frv/cop1.cgs
-048a96dcaad276073b908e6c8f4d9189  sim/testsuite/sim/frv/cop2.cgs
-50daedd569566b5f5fd6030c9c961735  sim/testsuite/sim/frv/cor.cgs
-b1bfeba9317d62d449126bee0f7fa720  sim/testsuite/sim/frv/corcc.cgs
-ed7de1b15d6c5535e9d56ff902749a49  sim/testsuite/sim/frv/cscan.cgs
-7482a3b75fcf89d6eac98c42d36722e9  sim/testsuite/sim/frv/csdiv.cgs
-6cc09cbce0f4709083b896f39eb8788b  sim/testsuite/sim/frv/csll.cgs
-f58b45613ae0cc85e07099e0b176a130  sim/testsuite/sim/frv/csllcc.cgs
-0e6828ab5a28105f1606bfcea5961a53  sim/testsuite/sim/frv/csmul.cgs
-97562af5611f19959e068464c8b152c0  sim/testsuite/sim/frv/csmulcc.cgs
-8916d2cace8900da8a1d671e9a0ea2b7  sim/testsuite/sim/frv/csra.cgs
-bff2fec4c10ff1cc52f6708fa1cd9e5a  sim/testsuite/sim/frv/csracc.cgs
-eb2f7e79db41af0b45c8182f92563397  sim/testsuite/sim/frv/csrl.cgs
-d18c2b792211080ccc434210ebb67ba9  sim/testsuite/sim/frv/csrlcc.cgs
-05e30ee19e5c52285f897986f1d22634  sim/testsuite/sim/frv/cst.cgs
-fea6bcd449bfa45bc4f7811913f3bc14  sim/testsuite/sim/frv/cstb.cgs
-29bcdb426188a5bb155dbee07ea1e527  sim/testsuite/sim/frv/cstbf.cgs
-699c2363b47a8ac1c7fdd3607503f872  sim/testsuite/sim/frv/cstbfu.cgs
-9d42de2773bcddcd37eafe1bf37aba97  sim/testsuite/sim/frv/cstbu.cgs
-c0fa479773c62b0865cf7f6646562284  sim/testsuite/sim/frv/cstd.cgs
-4dd6b1d7898b43e9ec3d140c49342862  sim/testsuite/sim/frv/cstdf.cgs
-785f29fcfbdef6e93f772f32635daec4  sim/testsuite/sim/frv/cstdfu.cgs
-91bdb77382d1406d5f98e2331c7a4ff5  sim/testsuite/sim/frv/cstdu.cgs
-bc2f5ebb5a8ed58952e9c92d80b5e5ea  sim/testsuite/sim/frv/cstf.cgs
-4659f8e9e4a139ab3d797621c23c6adf  sim/testsuite/sim/frv/cstfu.cgs
-46c386b55d7d762b12cf33a832c34e33  sim/testsuite/sim/frv/csth.cgs
-d7a05e22c19ec54237285333c21ab720  sim/testsuite/sim/frv/csthf.cgs
-c606963198b1685341b32e14a3384700  sim/testsuite/sim/frv/csthfu.cgs
-a7939f361fa8a4d7152833d17bf9242f  sim/testsuite/sim/frv/csthu.cgs
-94b3e5d6bcfbca96e1d45b116852ee46  sim/testsuite/sim/frv/cstq.cgs
-bb9428edb53dbe935f3f5d3295c296f6  sim/testsuite/sim/frv/cstu.cgs
-4f261153dda57be2acd2d50974b2157a  sim/testsuite/sim/frv/csub.cgs
-46a9440b74727f04cf647f1904d566fd  sim/testsuite/sim/frv/csubcc.cgs
-d59526db81b54d2c091ae65e844abba6  sim/testsuite/sim/frv/cswap.cgs
-6ff863c8f3f5b0a6c8d4e2ba179e7b46  sim/testsuite/sim/frv/cudiv.cgs
-9ca0539cd8fde544f4023712395cfce5  sim/testsuite/sim/frv/cxor.cgs
-ce8352f2c405c5128184546ff69e67e3  sim/testsuite/sim/frv/cxorcc.cgs
-e045ac944c8eccc986873c525e9996fc  sim/testsuite/sim/frv/dcef.cgs
-9bd0746e07695fc69099806146e177fd  sim/testsuite/sim/frv/dcei.cgs
-a1ff6a0459e013e3978913eca23570ca  sim/testsuite/sim/frv/dcf.cgs
-16483dc53cf562ff67a40716ddad4cee  sim/testsuite/sim/frv/dci.cgs
-a95c4bac5e72fe8a7d36b1b822acc3c6  sim/testsuite/sim/frv/fabsd.cgs
-26c749327e953defb5a5af911e83e615  sim/testsuite/sim/frv/fabss.cgs
-9baf3938276561eaa3ae2cd20fcaef2b  sim/testsuite/sim/frv/faddd.cgs
-c50d08df925d5ebe6235a744f5aa2838  sim/testsuite/sim/frv/fadds.cgs
-e82570b7a76dda7f7c8c4c4499b70113  sim/testsuite/sim/frv/fbeq.cgs
-9afa238bffc2569cab1b6c55a3dc8719  sim/testsuite/sim/frv/fbeqlr.cgs
-bc2783dc8045f8376c62a623d04bc452  sim/testsuite/sim/frv/fbge.cgs
-c89a2bf5e53afd9b92868ba2b7233f73  sim/testsuite/sim/frv/fbgelr.cgs
-da685784eb930e42a55444b9982c35f1  sim/testsuite/sim/frv/fbgt.cgs
-32ab332e05431f49f037d528b657d8e5  sim/testsuite/sim/frv/fbgtlr.cgs
-3550e78fee67575b3e364e279299a11e  sim/testsuite/sim/frv/fble.cgs
-d1c296f375a94a01c76d3ab5d7e095e9  sim/testsuite/sim/frv/fblelr.cgs
-bee17829c104e8e5901d5218f8da3030  sim/testsuite/sim/frv/fblg.cgs
-0dfa108dc10c10107281add62d6ca5ff  sim/testsuite/sim/frv/fblglr.cgs
-bb12ea3ce3769e468d058aeacea5e6d6  sim/testsuite/sim/frv/fblt.cgs
-8a304334e1341487c78471b20f879ecd  sim/testsuite/sim/frv/fbltlr.cgs
-0e297dc071234a78bd595a57838d5adc  sim/testsuite/sim/frv/fbne.cgs
-bf2c13262ac9d57aa021ce80e4dbf5a0  sim/testsuite/sim/frv/fbnelr.cgs
-53d642fd09d91db1bfef8cafa2d8c864  sim/testsuite/sim/frv/fbno.cgs
-145a02c3e9ec1831696933a5f22aa31d  sim/testsuite/sim/frv/fbnolr.cgs
-4aabea39aa800e2eab4188a00b9ba7b3  sim/testsuite/sim/frv/fbo.cgs
-ce189b743a628565f7ae69ef124e050e  sim/testsuite/sim/frv/fbolr.cgs
-5f05aa8ededad20eccd884443cd8ee28  sim/testsuite/sim/frv/fbra.cgs
-7b12e32c5f9c78b47dec5eb157449ab8  sim/testsuite/sim/frv/fbralr.cgs
-f5619a1966d02c7c8e4bd23503a40c49  sim/testsuite/sim/frv/fbu.cgs
-e97d9af6760367447c6863fb5e7fb5b0  sim/testsuite/sim/frv/fbue.cgs
-119fa9c79d98e20cd89f8deea6e78dd1  sim/testsuite/sim/frv/fbuelr.cgs
-2145d16c1548268652bcfdc0a032144b  sim/testsuite/sim/frv/fbug.cgs
-c8dca0748024ed82b9c614ccd0579c61  sim/testsuite/sim/frv/fbuge.cgs
-7b549ad8f8a930a4e61411e41d6df7d0  sim/testsuite/sim/frv/fbugelr.cgs
-99c4ae4bd4eb760d9274117748672094  sim/testsuite/sim/frv/fbuglr.cgs
-182d8d5e906c1fe63b1ec15953fbbf0a  sim/testsuite/sim/frv/fbul.cgs
-b6c34d73b6a6bbc7b1547986526a8d60  sim/testsuite/sim/frv/fbule.cgs
-9c00d18bfe2d4a8f3c5221ace6ce38bb  sim/testsuite/sim/frv/fbulelr.cgs
-d1b0b6638a07909bf45f65b454893510  sim/testsuite/sim/frv/fbullr.cgs
-3ddb83bbd7a429a77b68790480613591  sim/testsuite/sim/frv/fbulr.cgs
-6e5cfae9c6ca85c94d69dd30861553e1  sim/testsuite/sim/frv/fcbeqlr.cgs
-e50b5ddbb0d1b0554408f8db8f7da8a4  sim/testsuite/sim/frv/fcbgelr.cgs
-d5e28bf29b3ce725457862f002b4ba2d  sim/testsuite/sim/frv/fcbgtlr.cgs
-f8809a99276af73a606645ea3782eaa4  sim/testsuite/sim/frv/fcblelr.cgs
-ef5f527028300499462fd5457798f5f2  sim/testsuite/sim/frv/fcblglr.cgs
-da932dece8c1932a8e4b322ae96bb5d0  sim/testsuite/sim/frv/fcbltlr.cgs
-2e537bc555c2ad4796ded84bfd87d976  sim/testsuite/sim/frv/fcbnelr.cgs
-be2f0506fae9889d33fdeadc7910e5e5  sim/testsuite/sim/frv/fcbnolr.cgs
-8811726c9441dd7b9f70a3bf6f8ab4fb  sim/testsuite/sim/frv/fcbolr.cgs
-ed61ab14ca73c4d78de8d0e432820ff6  sim/testsuite/sim/frv/fcbralr.cgs
-90d5802ce49387d77932ca25262923af  sim/testsuite/sim/frv/fcbuelr.cgs
-719ef7eb905c6a71373cba4137767d8a  sim/testsuite/sim/frv/fcbugelr.cgs
-a96d3d1ca3ffa9a8c975ff08bcf77a2d  sim/testsuite/sim/frv/fcbuglr.cgs
-e34e76144ebb7dd885f027a37c38ae79  sim/testsuite/sim/frv/fcbulelr.cgs
-8570296a139952dc9cf976d500d2f827  sim/testsuite/sim/frv/fcbullr.cgs
-86c530fd6445d3f516387550e7172fa5  sim/testsuite/sim/frv/fcbulr.cgs
-956c2a9363667d599f0ad75bd639805b  sim/testsuite/sim/frv/fckeq.cgs
-fcf411b3b36ddc44d1d61f595d1730f3  sim/testsuite/sim/frv/fckge.cgs
-a5c4254bb5fb67e6553d7b4245facb4d  sim/testsuite/sim/frv/fckgt.cgs
-702fcbc546ef09f48a9809774f8fec26  sim/testsuite/sim/frv/fckle.cgs
-8335d3357e6e879a7501b1635ce4f821  sim/testsuite/sim/frv/fcklg.cgs
-2fd5797e8c20d9d7b340e095633f2ff6  sim/testsuite/sim/frv/fcklt.cgs
-082bcd35a3b7969bc5b37731b9db0243  sim/testsuite/sim/frv/fckne.cgs
-e05358b9a392f47c2ab2ccebc1dff681  sim/testsuite/sim/frv/fckno.cgs
-09025c57960cb3245c45b229551573d1  sim/testsuite/sim/frv/fcko.cgs
-4aa3a5fba828d2c29dff1b6f57d59678  sim/testsuite/sim/frv/fckra.cgs
-2ba0a93a9c8332f36a0800263efc0511  sim/testsuite/sim/frv/fcku.cgs
-fd10c5f2ffffd0583a7da981ddeca855  sim/testsuite/sim/frv/fckue.cgs
-d025a5adc03c1fa97688e776798e6508  sim/testsuite/sim/frv/fckug.cgs
-935a9c4cf686aaa2f4c480791181b2c9  sim/testsuite/sim/frv/fckuge.cgs
-33411cb293d5fc422c7990104604db74  sim/testsuite/sim/frv/fckul.cgs
-334619e30c816f5a6286de42eff58ebf  sim/testsuite/sim/frv/fckule.cgs
-26a2849fb8c805ffcb118c47ef7bf006  sim/testsuite/sim/frv/fcmpd.cgs
-9d2e37d0bea30c9a00cac2518ddd5947  sim/testsuite/sim/frv/fcmps.cgs
-ebae9cb1aaa0ceb6dbf6976f06d735c7  sim/testsuite/sim/frv/fdabss.cgs
-a1081abe7c71411a62d3f8467141fdbb  sim/testsuite/sim/frv/fdadds.cgs
-7461f81658de5eada83b19dbf47f1c28  sim/testsuite/sim/frv/fdcmps.cgs
-7b12d84395556d02cee66d9a1a5c991a  sim/testsuite/sim/frv/fddivs.cgs
-41eb8f2c4c39e3f8b7914f9a7910eac7  sim/testsuite/sim/frv/fditos.cgs
-66f358e165d3d3c59afa716dc67d1788  sim/testsuite/sim/frv/fdivd.cgs
-444fdecb0192342ea5f61cfd80e48b61  sim/testsuite/sim/frv/fdivs.cgs
-8d77d790c0894ddb71a64a0a13e2e106  sim/testsuite/sim/frv/fdmadds.cgs
-ff1044b90e19b2451b0c3f0233ee3d70  sim/testsuite/sim/frv/fdmas.cgs
-fa4d51b6701d40a568e60a35d730a09c  sim/testsuite/sim/frv/fdmovs.cgs
-d558b5c8f62773391401afa4258ec585  sim/testsuite/sim/frv/fdmss.cgs
-50d1ce458d38dfa7f69fd4f3c0b08419  sim/testsuite/sim/frv/fdmulcs.cgs
-346e48b77e9a031f3f955ecefbd4019f  sim/testsuite/sim/frv/fdmuls.cgs
-b4bfdcbeb1d5db33d9166dc9f77da383  sim/testsuite/sim/frv/fdnegs.cgs
-0ee8af42152ab4d5632be0dba1c8345d  sim/testsuite/sim/frv/fdsads.cgs
-60319f32e98f86da38ff2c3c5212d862  sim/testsuite/sim/frv/fdsqrts.cgs
-ab9fb811cf16eb0998d83984e0cbc430  sim/testsuite/sim/frv/fdstoi.cgs
-42cdb4f8bb24ee39032c4c32ca61b709  sim/testsuite/sim/frv/fdsubs.cgs
-694f1d17123f4bb9c03260c1fe669aac  sim/testsuite/sim/frv/fdtoi.cgs
-c5163110cf891849bed86c0f453b8e02  sim/testsuite/sim/frv/fitod.cgs
-6c26a616dd6fed8bd7e159e371fe4fe4  sim/testsuite/sim/frv/fitos.cgs
-6ea38598142f8f6d50283bafdaf0a0f7  sim/testsuite/sim/frv/fmad.cgs
-82fe9144d5b80fbfd5b4582ca5246df4  sim/testsuite/sim/frv/fmaddd.cgs
-b9ae3c5d73a84096df40cbc04f28abbe  sim/testsuite/sim/frv/fmadds.cgs
-47f01f4c8f9a72792359daab3c1e9212  sim/testsuite/sim/frv/fmas.cgs
-f59368c3bae1aa62bdb68b1edf299c9e  sim/testsuite/sim/frv/fmovd.cgs
-6f5746330962303a04eb519a4b05fa23  sim/testsuite/sim/frv/fmovs.cgs
-f423c77b0989e36e0e8829e450d94c74  sim/testsuite/sim/frv/fmsd.cgs
-7068101bb16125bf823c54313efc9c88  sim/testsuite/sim/frv/fmss.cgs
-38e18b11776fdecb14fcc94311d95b20  sim/testsuite/sim/frv/fmsubd.cgs
-a761e98378b236d13867be6741e673bd  sim/testsuite/sim/frv/fmsubs.cgs
-8dda215c5c85e94e1a385d685127d850  sim/testsuite/sim/frv/fmuld.cgs
-3b5c5fa1e5977ed20ec3d4474eb79431  sim/testsuite/sim/frv/fmuls.cgs
-0553d530d16ef1a9889895d233bd1a23  sim/testsuite/sim/frv/fnegd.cgs
-36024f7e3058972d0b99742ee87119cd  sim/testsuite/sim/frv/fnegs.cgs
-a2266c24dffd8d4a696b3619a897269f  sim/testsuite/sim/frv/fnop.cgs
-a1394d82fbbcdc7278c8ff7b0b749317  sim/testsuite/sim/frv/fsqrtd.cgs
-09a60ae22f077bfd3491cb02114dc22f  sim/testsuite/sim/frv/fsqrts.cgs
-64a8de42436fc5c8f2d468e70c54e9aa  sim/testsuite/sim/frv/fstoi.cgs
-8f0dbbf7ad0b329248d951a35e40a01b  sim/testsuite/sim/frv/fsubd.cgs
-5761527de2c6413c3f8a07d2189ef92a  sim/testsuite/sim/frv/fsubs.cgs
-a7085119fedb3ac3d4e31403309293b1  sim/testsuite/sim/frv/fteq.cgs
-e3482ddd50c998096e309469d49bf60f  sim/testsuite/sim/frv/ftge.cgs
-25805dfe75db053034915ba8a5b33ce2  sim/testsuite/sim/frv/ftgt.cgs
-16bf5094b2c7a186f0e11fa373625fb8  sim/testsuite/sim/frv/ftieq.cgs
-b5a71bd3c822c7000929441e7602c329  sim/testsuite/sim/frv/ftige.cgs
-ce965b75b06cd55ef70169b06c863849  sim/testsuite/sim/frv/ftigt.cgs
-1951d6a3f5242b6e26d9fdb55b1bf1ca  sim/testsuite/sim/frv/ftile.cgs
-80d04d00a7e92cc4c32af000081d5cd4  sim/testsuite/sim/frv/ftilg.cgs
-e913757697385f676de531dc9055b78d  sim/testsuite/sim/frv/ftilt.cgs
-f48f14696dde175e869c7c04abc8573b  sim/testsuite/sim/frv/ftine.cgs
-c2b0345fa9da69b5322eaf83e9506cab  sim/testsuite/sim/frv/ftino.cgs
-f3562f7c11ed638cffff5fb8afd74b8c  sim/testsuite/sim/frv/ftio.cgs
-e2bbc311eb90229f9eb63b3ea456aa51  sim/testsuite/sim/frv/ftira.cgs
-fbd58be2c1178ffbda7cbe566dda3bb4  sim/testsuite/sim/frv/ftiu.cgs
-7aa4b56189a14f023e26984163cb0b4e  sim/testsuite/sim/frv/ftiue.cgs
-821d3e5a5535a52948ced4d48cf4491d  sim/testsuite/sim/frv/ftiug.cgs
-bea6c33251489ce5246ed3d6bf5ac702  sim/testsuite/sim/frv/ftiuge.cgs
-f60030141346c133b53f259287743291  sim/testsuite/sim/frv/ftiul.cgs
-8a5f013616cf1e6db319200b9db548cd  sim/testsuite/sim/frv/ftle.cgs
-680e346877ec40599ab486d183890983  sim/testsuite/sim/frv/ftlg.cgs
-cc345f4d17b80808ee251d600fbbc6b9  sim/testsuite/sim/frv/ftlt.cgs
-47b041b440463afa7c2f9adc16bc48db  sim/testsuite/sim/frv/ftne.cgs
-9ac0ca5fc78d29c5cb125f7f0232ab24  sim/testsuite/sim/frv/ftno.cgs
-0cfc1cccecd9264a187a4fde5a4e1b92  sim/testsuite/sim/frv/fto.cgs
-7f0e3223aefe0347e86016999b785689  sim/testsuite/sim/frv/ftra.cgs
-7e08ead385d09b81452d7e494e24003b  sim/testsuite/sim/frv/ftu.cgs
-7eb6a791ed88c6c8794db6e2d7d1c4cd  sim/testsuite/sim/frv/ftue.cgs
-798fee14d0226828590f274a847fb587  sim/testsuite/sim/frv/ftug.cgs
-b1b5fbe7e86fcaa6a8cb5246c1105383  sim/testsuite/sim/frv/ftuge.cgs
-18c32597076e6690eca21bdaa9b70083  sim/testsuite/sim/frv/ftul.cgs
-b38f99b4027aa8bc54b81cd44830ff0c  sim/testsuite/sim/frv/ftule.cgs
-9b2b24b2080b3778404da0e73b2f4c45  sim/testsuite/sim/frv/icei.cgs
-57b3c53e5a537bbcdd2bbd8bda51c584  sim/testsuite/sim/frv/ici.cgs
-520e9f58107f1a7407724d2b52bbe214  sim/testsuite/sim/frv/icpl.cgs
-28f0887ee88db223fdd12b2024131872  sim/testsuite/sim/frv/icul.cgs
-94f5c3abf0cf2118f97e0a95f79f9dd5  sim/testsuite/sim/frv/interrupts.exp
-6d82b9a4957b0fefdf4b9bd93f868b12  sim/testsuite/sim/frv/jmpil.cgs
-7acb4d8fcf1961a11eb5f86da60a0804  sim/testsuite/sim/frv/jmpl.cgs
-5331aae1c37403328b45cbda9aef7b4b  sim/testsuite/sim/frv/jmpl.pcgs
-fe0935479403ab62bd07f75bc6974752  sim/testsuite/sim/frv/ld.cgs
-2a756ad9c98638728516c303deb87eb0  sim/testsuite/sim/frv/ldbf.cgs
-7907b41ac563ea2be426de33f8910f66  sim/testsuite/sim/frv/ldbfi.cgs
-f77f7688f51f87c5e93a3e56bd0fbc96  sim/testsuite/sim/frv/ldbfu.cgs
-3a18c58e47703c059520340b1b1c3051  sim/testsuite/sim/frv/ldc.cgs
-dcb10a82d61302543652fed0b13575b2  sim/testsuite/sim/frv/ldcu.cgs
-6e3d68aac7b3fc4b6ed2b5e4d847070b  sim/testsuite/sim/frv/ldd.cgs
-20942fb6996945bf7ea82dc541af0991  sim/testsuite/sim/frv/lddc.cgs
-4741f3d629b91d827c5d340249f452c5  sim/testsuite/sim/frv/lddcu.cgs
-f30642deec77165f2dec4409e06fb949  sim/testsuite/sim/frv/lddf.cgs
-a4e3dae18838ea83a10018cf243b37d9  sim/testsuite/sim/frv/lddfi.cgs
-c4fbea8332e5b07b3fd2e18f0fd4fd9f  sim/testsuite/sim/frv/lddfu.cgs
-4cf840661cd9ed9ad76e658e996fc2fb  sim/testsuite/sim/frv/lddi.cgs
-117ef9aa94aacbff810bdc764cce2f12  sim/testsuite/sim/frv/lddu.cgs
-c613f1a55c9e79f62abbd91eee7fde9d  sim/testsuite/sim/frv/ldf.cgs
-2426e56c573364d455e06cf511aa1c1f  sim/testsuite/sim/frv/ldfi.cgs
-873badad1ba22ab85ceded1032e76d7a  sim/testsuite/sim/frv/ldfu.cgs
-e7c1a6655a0477c4a36ead53e726fb48  sim/testsuite/sim/frv/ldhf.cgs
-358001b036e18ae3c266a2d8f245022e  sim/testsuite/sim/frv/ldhfi.cgs
-26d92ac47d2a85071f1c0c26d721e2cc  sim/testsuite/sim/frv/ldhfu.cgs
-003fcd3e132470d58c6ceb7177806c5b  sim/testsuite/sim/frv/ldi.cgs
-e4ece86a7c055e9d7e99ecec010c71ae  sim/testsuite/sim/frv/ldq.cgs
-1b5c559ac60b1eb35f51ca0e4bb70acf  sim/testsuite/sim/frv/ldqc.cgs
-b0a584edcb6525f7880b1f45497c9a2e  sim/testsuite/sim/frv/ldqcu.cgs
-8c87a49e58f46e85f154cc3871f5aff6  sim/testsuite/sim/frv/ldqf.cgs
-84cacbc7723416a4ab6bd038d71dac9b  sim/testsuite/sim/frv/ldqfi.cgs
-747342519c94e5f3d6e4153d144a3774  sim/testsuite/sim/frv/ldqfu.cgs
-7f6546bcb393b36f1e1a1f1552c53160  sim/testsuite/sim/frv/ldqi.cgs
-90cebd7ff7dc2106afca60b9a5a26bed  sim/testsuite/sim/frv/ldqu.cgs
-9ba5b89fa11ddec7e98787ca73fa0115  sim/testsuite/sim/frv/ldsb.cgs
-91548ae1c6a13b8dcdc27ee53cf2c8cd  sim/testsuite/sim/frv/ldsbi.cgs
-fe18fae6d95afe023a4f3c12ee809a7d  sim/testsuite/sim/frv/ldsbu.cgs
-7bff63bb7f11db3619daa65ba575eb4b  sim/testsuite/sim/frv/ldsh.cgs
-04ebe641dcc2681cb7085e49e4b8787d  sim/testsuite/sim/frv/ldshi.cgs
-2578eab56c9efe85e875334d9be745a5  sim/testsuite/sim/frv/ldshu.cgs
-0fcf16c6304ddf56ba06882bf077c739  sim/testsuite/sim/frv/ldu.cgs
-b4281f11b7f00e191f158b23a2115556  sim/testsuite/sim/frv/ldub.cgs
-ce9abd48c84d1abd4b05d248d4e9067e  sim/testsuite/sim/frv/ldubi.cgs
-f3f076fc173ea772baff44f55775ca03  sim/testsuite/sim/frv/ldubu.cgs
-c9e8808a1431699f65ca45e1d96ccb40  sim/testsuite/sim/frv/lduh.cgs
-6839b4b27f67afcd7af9dcbeba8e54e6  sim/testsuite/sim/frv/lduhi.cgs
-e470390ff6d0df7541ce5455d765a606  sim/testsuite/sim/frv/lduhu.cgs
-861233cc66075168ec7d72a804bbffae  sim/testsuite/sim/frv/lrbranch.pcgs
-358b9c46cd5cb979fdaf717f46764b5a  sim/testsuite/sim/frv/mabshs.cgs
-7174dbd57607dbdc45c4243fb7f02aa7  sim/testsuite/sim/frv/maddhss.cgs
-8aa28a7f77fd8f94f1f8d4441330d2de  sim/testsuite/sim/frv/maddhus.cgs
-2e1fd77e3c7dc410824bb62d86c12fa5  sim/testsuite/sim/frv/mand.cgs
-2caa34c2c4802ea92661e98ac6af667f  sim/testsuite/sim/frv/maveh.cgs
-89a846533bf6d66afa6dc6a610bee4de  sim/testsuite/sim/frv/mbtoh.cgs
-be7bc8f47af7ec401ae8edc5735ae83f  sim/testsuite/sim/frv/mbtohe.cgs
-5890a645af954362f462a536301ab07a  sim/testsuite/sim/frv/mclracc.cgs
-4df2335c339344cb1ab773c28eac7047  sim/testsuite/sim/frv/mcmpsh.cgs
-0202236564d839929bc185b5b363483b  sim/testsuite/sim/frv/mcmpuh.cgs
-75f2c544b8e80d583bfc78a32fce7f9f  sim/testsuite/sim/frv/mcop1.cgs
-eac5267f2219d176a231a4394b8a7dbe  sim/testsuite/sim/frv/mcop2.cgs
-0511aebe3ab974e7a9e5fdfa895d9aeb  sim/testsuite/sim/frv/mcplhi.cgs
-dae087e8f55a8ecbfe85b2476c9267e2  sim/testsuite/sim/frv/mcpli.cgs
-40aac5235a3696c45134d86e1e79c5d9  sim/testsuite/sim/frv/mcpxis.cgs
-bf8b42298ba9d65e9cbfb7f621ede0df  sim/testsuite/sim/frv/mcpxiu.cgs
-da93993782224f234cfa217c4c2de3cb  sim/testsuite/sim/frv/mcpxrs.cgs
-2e3efdb33b16bdf036e34506be43620a  sim/testsuite/sim/frv/mcpxru.cgs
-2e85d413681ca26660d8f9691a5c9ab2  sim/testsuite/sim/frv/mcut.cgs
-6f24d372cfa857010330fd99b9ceaa3f  sim/testsuite/sim/frv/mcuti.cgs
-58aae8e7b29223770991f01723b7dd98  sim/testsuite/sim/frv/mcutss.cgs
-d94022526f601563a7d06cde8c8461d5  sim/testsuite/sim/frv/mcutssi.cgs
-c75ed78a7566a8628cf0a0339c5dcf21  sim/testsuite/sim/frv/mdaddaccs.cgs
-5034792548b761b0fe9ad80d44958b6e  sim/testsuite/sim/frv/mdasaccs.cgs
-e81006aee4bbd0e3671448585ab45d5d  sim/testsuite/sim/frv/mdcutssi.cgs
-4ced60215e6ef89c35488866f38fd3c0  sim/testsuite/sim/frv/mdpackh.cgs
-00c2e418966af14d3cc048573279d6fc  sim/testsuite/sim/frv/mdrotli.cgs
-bbe41f9762adbc1e38c19904af9a4622  sim/testsuite/sim/frv/mdsubaccs.cgs
-edb5aa56bcd8e8bca69cf259f36e465f  sim/testsuite/sim/frv/mdunpackh.cgs
-32dde2fe5a74ba57fb63ca5a91948b13  sim/testsuite/sim/frv/membar.cgs
-7351ae1c949d0e80e4c9cac3adb238c0  sim/testsuite/sim/frv/mexpdhd.cgs
-8be433c05488391e44e6d0fd1a0663a5  sim/testsuite/sim/frv/mexpdhw.cgs
-bfc4a4f409782a01b12aafa73820d4a7  sim/testsuite/sim/frv/mhdseth.cgs
-5530ac8f622c5b86676418a439d31062  sim/testsuite/sim/frv/mhdsets.cgs
-6e9d7ee79258240c2e9f8490187d2d1b  sim/testsuite/sim/frv/mhsethih.cgs
-0286e694b02e66084d5fb2649c171379  sim/testsuite/sim/frv/mhsethis.cgs
-889eccff241ad187bd577cfe2fcc0ddc  sim/testsuite/sim/frv/mhsetloh.cgs
-500ddf7a9ca8ca47e62e62cf4257a675  sim/testsuite/sim/frv/mhsetlos.cgs
-a861d845633062758e032a27d5fab174  sim/testsuite/sim/frv/mhtob.cgs
-e326ecc782170966595a854ea64b2786  sim/testsuite/sim/frv/mmachs.cgs
-052b5f3d0e3a1fca5894d9655353d7e3  sim/testsuite/sim/frv/mmachu.cgs
-985bedf1c0cc65d298ccc789ebc69179  sim/testsuite/sim/frv/mmrdhs.cgs
-cf37e0de21739109f45bc6903faef9ff  sim/testsuite/sim/frv/mmrdhu.cgs
-b813da728e948bf7f3d0a70e28fd56de  sim/testsuite/sim/frv/mmulhs.cgs
-20f4895c822bcecaa711c3508043ced9  sim/testsuite/sim/frv/mmulhu.cgs
-5970b5e8ca637b383803588fb78206d8  sim/testsuite/sim/frv/mmulxhs.cgs
-e6ac3d3a2b75c748d32f1dff04690c18  sim/testsuite/sim/frv/mmulxhu.cgs
-73a36ac7ddbc3eb5f02e23e556757534  sim/testsuite/sim/frv/mnop.cgs
-d7e3785dd9d822d3c98edf4a7ca1e462  sim/testsuite/sim/frv/mnot.cgs
-787ba5a828f2060d5163f4dd6493bdfc  sim/testsuite/sim/frv/mor.cgs
-e15b13b9790cd957ef7c1174a414fc91  sim/testsuite/sim/frv/mov.cgs
-e267cd40e466ef09766bb5af7f3ea525  sim/testsuite/sim/frv/movfg.cgs
-1de01bb11a8e27d051b6d84fdf37cbff  sim/testsuite/sim/frv/movfgd.cgs
-b671fcc6ddd6daa079fd31a468749b0e  sim/testsuite/sim/frv/movfgq.cgs
-1f93a0d7fca1cd46156bd7a0c7f3c59f  sim/testsuite/sim/frv/movgf.cgs
-6a708919bfd6e9a6a3b0a1872c48290f  sim/testsuite/sim/frv/movgfd.cgs
-490b859435e3a616aa2c844b9dbed8d6  sim/testsuite/sim/frv/movgfq.cgs
-d2a4394753db3dfcbe7e384ee21e2202  sim/testsuite/sim/frv/movgs.cgs
-5df092435661dcba49b26ede1ae30c8d  sim/testsuite/sim/frv/movsg.cgs
-1e471deced4a3635b4468bd2d1ff88cb  sim/testsuite/sim/frv/mpackh.cgs
-de1b6d1ff997e66d64111e7a69c3f749  sim/testsuite/sim/frv/mqcpxis.cgs
-ddd0fdd0602cb85ada820445cf505820  sim/testsuite/sim/frv/mqcpxiu.cgs
-dc5c412a280bacbbb5fd6a56a6fe53ff  sim/testsuite/sim/frv/mqcpxrs.cgs
-e92162146f80eacb87cc88e02de63d26  sim/testsuite/sim/frv/mqcpxru.cgs
-195ff710aa1e8652dc42e962e6e4d9ce  sim/testsuite/sim/frv/mqlclrhs.cgs
-bfa79960646e1c17eadb4100a422dd9d  sim/testsuite/sim/frv/mqlmths.cgs
-a016768b6c2c21cc9c4354d7cc7f9628  sim/testsuite/sim/frv/mqmachs.cgs
-317e00e7d2fc4d994400b3435e38deba  sim/testsuite/sim/frv/mqmachu.cgs
-bf4cfe49b9af48954b1a4495db0bcb6f  sim/testsuite/sim/frv/mqmacxhs.cgs
-d79cc37be001047a062fd1b16bf5e34e  sim/testsuite/sim/frv/mqmulhs.cgs
-26f559df23ae04f9a1576f793e340163  sim/testsuite/sim/frv/mqmulhu.cgs
-5c07a1afebe94dfc4e0132d66d8c28ea  sim/testsuite/sim/frv/mqmulxhs.cgs
-8674ff984bcbe2b1460d51e69db27c7b  sim/testsuite/sim/frv/mqmulxhu.cgs
-352d41aa9b03ec2820009d90f569a60a  sim/testsuite/sim/frv/mqsaths.cgs
-239d171ff012ca3bfc1ea795eb727b3e  sim/testsuite/sim/frv/mqsllhi.cgs
-32066e6265ce0fd1845b4342336d925a  sim/testsuite/sim/frv/mqsrahi.cgs
-b1cf84b60cf3a908c49512b100a3cf65  sim/testsuite/sim/frv/mqxmachs.cgs
-48ee9ffc570edbbfe8169afd5f2bacee  sim/testsuite/sim/frv/mqxmacxhs.cgs
-d3412bc4c0b67f6c78449fd684463b9b  sim/testsuite/sim/frv/mrdacc.cgs
-cc6399ec148be0f20332c2aeadef5990  sim/testsuite/sim/frv/mrdaccg.cgs
-f428dd31a13e708566a12b6eb23e75aa  sim/testsuite/sim/frv/mrotli.cgs
-a05d5c0d7e028af3383c1e9b237ef156  sim/testsuite/sim/frv/mrotri.cgs
-9b134f75e539c10de4195ec1e51ee136  sim/testsuite/sim/frv/msaths.cgs
-326669d1c76ef080e2d2ddf8c2ee6e6f  sim/testsuite/sim/frv/msathu.cgs
-475e50c7c92b7357b020583b574726a8  sim/testsuite/sim/frv/msllhi.cgs
-5e7cbd14acb0fd1a1bdc89e068e9803d  sim/testsuite/sim/frv/msrahi.cgs
-90c1d817bd4dce7d539e4e9dacb35e90  sim/testsuite/sim/frv/msrlhi.cgs
-f3f08211769783c8fad2413b5f4419a5  sim/testsuite/sim/frv/msubhss.cgs
-c171d116ab1a2be2bd6fe89d40046466  sim/testsuite/sim/frv/msubhus.cgs
-6f29112e0458cbb1fe8d3a0403ed85d7  sim/testsuite/sim/frv/mtrap.cgs
-80d2065efb7d0769f11b1c4881e20500  sim/testsuite/sim/frv/munpackh.cgs
-5f0be0ef1415763840683d1a66cf6b67  sim/testsuite/sim/frv/mwcut.cgs
-28b4f2f9ac438caaebbf3d5fe7b8b9f3  sim/testsuite/sim/frv/mwcuti.cgs
-68b4157ad30443488a491d75a0ddc05f  sim/testsuite/sim/frv/mwtacc.cgs
-82d5838a4cbf516a93892bafbf64af95  sim/testsuite/sim/frv/mwtaccg.cgs
-754cf046515e94f61db9e81c57bbef98  sim/testsuite/sim/frv/mxor.cgs
-ea152c37492f744e98208e25538591cc  sim/testsuite/sim/frv/nandcr.cgs
-9bd25bbc9331a8a7a764970163f8a3c2  sim/testsuite/sim/frv/nandncr.cgs
-5645677fd61cac055a6989382352af7e  sim/testsuite/sim/frv/nfadds.cgs
-f6656b60bec315c613ad5092d5bba892  sim/testsuite/sim/frv/nfdadds.cgs
-6f912abf4768c8b66831a8ce4a5ab658  sim/testsuite/sim/frv/nfdcmps.cgs
-f72cfcf1db3b542e40ae4d24754a8648  sim/testsuite/sim/frv/nfddivs.cgs
-ac7e485b7fc2228e78885a3580c40684  sim/testsuite/sim/frv/nfditos.cgs
-0e30127c5ef9ca2d27a6bf7790128b65  sim/testsuite/sim/frv/nfdivs.cgs
-2d6cd85e83c408920463b9e326312c1d  sim/testsuite/sim/frv/nfdmadds.cgs
-fdd8bd1799f969d718f27d5140c561e1  sim/testsuite/sim/frv/nfdmas.cgs
-75d93040b8b11cd80e200e83f9c3b423  sim/testsuite/sim/frv/nfdmss.cgs
-9564e9d1067be24d75f69103b57a85dc  sim/testsuite/sim/frv/nfdmulcs.cgs
-96c1cae5bdbbfd68972a26ded76a6653  sim/testsuite/sim/frv/nfdmuls.cgs
-60b73bc5cde0341f993a4d3fa218363f  sim/testsuite/sim/frv/nfdsads.cgs
-ccf1387db46bf4985328d9b58f89085e  sim/testsuite/sim/frv/nfdsqrts.cgs
-08bb1af48f043b2ec22ede0e6a2a63c0  sim/testsuite/sim/frv/nfdstoi.cgs
-c76e1c140c00dea2137868c13de73686  sim/testsuite/sim/frv/nfdsubs.cgs
-4f526f2f27056051f986c47b44c9b1ff  sim/testsuite/sim/frv/nfitos.cgs
-5c7a02887eb56676fc4f267dff41f169  sim/testsuite/sim/frv/nfmadds.cgs
-3de97f087ebc932501f95bc2bd775d5f  sim/testsuite/sim/frv/nfmas.cgs
-de42c23dfd886e1e9150e93cfa7a0e30  sim/testsuite/sim/frv/nfmss.cgs
-c133078967d4e2c08e05c0c211483593  sim/testsuite/sim/frv/nfmsubs.cgs
-40981f85eeb4a396327c4e11f7ca792d  sim/testsuite/sim/frv/nfmuls.cgs
-c73e0f9186dae498050376d33b40c1c6  sim/testsuite/sim/frv/nfsqrts.cgs
-a9c95b2f342640586e4acb9faad49772  sim/testsuite/sim/frv/nfstoi.cgs
-147619970eca1511cbd9f636e8aaeeb7  sim/testsuite/sim/frv/nfsubs.cgs
-849a1c54f6b7fc29b1fea32e1adffb98  sim/testsuite/sim/frv/nld.cgs
-cec99b8b35d4fdcdb377d9a66ea62009  sim/testsuite/sim/frv/nldbf.cgs
-285f247c378146a1e4a5a8134ab4c06f  sim/testsuite/sim/frv/nldbfi.cgs
-62fbafc1c264ff3ffa2f95d455138a29  sim/testsuite/sim/frv/nldbfu.cgs
-3cf41818d7d43998028a6204c6d3d1cc  sim/testsuite/sim/frv/nldd.cgs
-484f52adb8fc411974f97082db9d5dbc  sim/testsuite/sim/frv/nlddf.cgs
-2bb049f287b76c978273eaf5c312a4d1  sim/testsuite/sim/frv/nlddfi.cgs
-b21df75a0fc0a38539d562c017b4b670  sim/testsuite/sim/frv/nlddfu.cgs
-903edfdf254dfa703f606ad9ccda17ad  sim/testsuite/sim/frv/nlddi.cgs
-2c42865e66cdf52327e926c6430af676  sim/testsuite/sim/frv/nlddu.cgs
-36d1b5e9f74e8641f51abe8a472c6860  sim/testsuite/sim/frv/nldf.cgs
-4ee6d04ba074cd859443fa0bf726dc3f  sim/testsuite/sim/frv/nldfi.cgs
-ae737e209ef8a22261025cd8102d7861  sim/testsuite/sim/frv/nldfu.cgs
-4f3c2f0fc2e3ed5b6c87cd135a6bbd00  sim/testsuite/sim/frv/nldhf.cgs
-b12b404167348112b47f3650d80a49a1  sim/testsuite/sim/frv/nldhfi.cgs
-23dbb5a7d7175564285ef8cbbafdf4d7  sim/testsuite/sim/frv/nldhfu.cgs
-323956db2a566de88fcd530490661356  sim/testsuite/sim/frv/nldi.cgs
-7e182fb1f729214fcc4e500b45b28c67  sim/testsuite/sim/frv/nldq.cgs
-f0900597e5ab5ecf6b5c7a7767e62980  sim/testsuite/sim/frv/nldqf.cgs
-ad1fb24311a078779b253206335fb321  sim/testsuite/sim/frv/nldqfi.cgs
-6158542e4b6f47593521af161cbefcc4  sim/testsuite/sim/frv/nldqfu.cgs
-27c8a87945ccd5906ecb831c022a2cae  sim/testsuite/sim/frv/nldqu.cgs
-86f2d4d2d5077458a84b7b7717ae2841  sim/testsuite/sim/frv/nldsb.cgs
-6cb71382953aaa573377ba9365cf47c8  sim/testsuite/sim/frv/nldsbi.cgs
-94382ca860759734f699db2c4030a586  sim/testsuite/sim/frv/nldsbu.cgs
-769125b26bae4afc675b0f4ecba3476b  sim/testsuite/sim/frv/nldsh.cgs
-512f6ab69b17ee51ff97983b35376396  sim/testsuite/sim/frv/nldshi.cgs
-288041bebf2361e4e1b14d5487134199  sim/testsuite/sim/frv/nldshu.cgs
-fcdd282d23082a3f4baf0861979ef5bb  sim/testsuite/sim/frv/nldu.cgs
-21e414ff661565b6aa03208928648853  sim/testsuite/sim/frv/nldub.cgs
-4dbc3bfa2a0abb00d11e913ffe7dbfdf  sim/testsuite/sim/frv/nldubi.cgs
-7a14b1a4b9c264ad6fe9fee43a34053c  sim/testsuite/sim/frv/nldubu.cgs
-606377e169feb767df3ada199efb6756  sim/testsuite/sim/frv/nlduh.cgs
-29e215193143b4309c76dec515f0ffb9  sim/testsuite/sim/frv/nlduhi.cgs
-8e6934cc5df77f17ded11b0e56344cc1  sim/testsuite/sim/frv/nlduhu.cgs
-55a7762fcf4065ee0e1e89c09894296b  sim/testsuite/sim/frv/nop.cgs
-c82aab8314691de50e4eb1b4d2deee7f  sim/testsuite/sim/frv/norcr.cgs
-1d754b9b7c803178ecc07bed29a6226c  sim/testsuite/sim/frv/norncr.cgs
-877b1bf25d820494dfcd5c8e060ee0a5  sim/testsuite/sim/frv/not.cgs
-937c6181f24f15a85ce59e24a746f6da  sim/testsuite/sim/frv/notcr.cgs
-9711b61b6a23527c5cde41eaac4eb112  sim/testsuite/sim/frv/nsdiv.cgs
-e7a86181d00e8f0c9684753e86508c74  sim/testsuite/sim/frv/nsdivi.cgs
-6b19d157804a7fa854e78b49a095a638  sim/testsuite/sim/frv/nudiv.cgs
-da4a0f53d7d03d30ce9cca0bf34a2ece  sim/testsuite/sim/frv/nudivi.cgs
-371a4f289d0bc38fee546e49ad327952  sim/testsuite/sim/frv/or.cgs
-5c2413abe5cf30fb4cdd0d5e3c30dbab  sim/testsuite/sim/frv/orcc.cgs
-56f5fdf1970e4a477ff5bcd70ad6128d  sim/testsuite/sim/frv/orcr.cgs
-67bd729e92a8ccbb0ef66f5053e9c7c9  sim/testsuite/sim/frv/ori.cgs
-e1e57ef45323b229f0811de476eadaa8  sim/testsuite/sim/frv/oricc.cgs
-9fc100ac9932ce7d023e9d73fe027dd7  sim/testsuite/sim/frv/orncr.cgs
-6aa3407819f0ab3db9441490901c1c20  sim/testsuite/sim/frv/parallel.exp
-54abbae4f460a1ac2f0f979b48cff91f  sim/testsuite/sim/frv/ret.cgs
-102c16fad8d7c1990921e4b171f62531  sim/testsuite/sim/frv/rett.cgs
-dcdd60cb6a74a2fdf05c27542ce87c00  sim/testsuite/sim/frv/scan.cgs
-a0d99a5f1ae6d699d7551ec0c91ad1f9  sim/testsuite/sim/frv/scani.cgs
-8cfaaa6f7d9be0c7164bd6b95f781486  sim/testsuite/sim/frv/sdiv.cgs
-a0bc228cfda1d7113cd087bfc0298020  sim/testsuite/sim/frv/sdivi.cgs
-0eaa5642821eed78cc9e2c144fe34a92  sim/testsuite/sim/frv/sethi.cgs
-d3a8b5ed0ad285696200a176e326a55b  sim/testsuite/sim/frv/sethilo.pcgs
-6eafdd537ba1f28305cee77fe68ff5fd  sim/testsuite/sim/frv/setlo.cgs
-bb74161afeebbd175cc9296446d7ff46  sim/testsuite/sim/frv/setlos.cgs
-dc65593014b3881fdcff036075e5dad0  sim/testsuite/sim/frv/sll.cgs
-ee34b84c6bf75a9babe137a04ac4b75a  sim/testsuite/sim/frv/sllcc.cgs
-35c7aae3b090f125993fef390d76906f  sim/testsuite/sim/frv/slli.cgs
-8700acd6ed03f5cbac0ad536383ed3c8  sim/testsuite/sim/frv/sllicc.cgs
-0814d3851a44b4bce8357863eec8e600  sim/testsuite/sim/frv/smul.cgs
-8692050bdf66cc6ad2d401c4a4684cef  sim/testsuite/sim/frv/smulcc.cgs
-89a51e07a40a4e8f76ac296cacbb8363  sim/testsuite/sim/frv/smuli.cgs
-2eb6969a0c7a4eb4fff85aac9727721a  sim/testsuite/sim/frv/smulicc.cgs
-2d31dcb15e8a6877017dd3d148b0bf2b  sim/testsuite/sim/frv/sra.cgs
-d41729b132c64711d5d230c8be3b4332  sim/testsuite/sim/frv/sracc.cgs
-1d5380689e9dae36a5ab8b5436118c9e  sim/testsuite/sim/frv/srai.cgs
-3ba660d7dcfb108e50618445716bb95b  sim/testsuite/sim/frv/sraicc.cgs
-204db103ce94f9da0c1f28ed0cd60ba0  sim/testsuite/sim/frv/srl.cgs
-5aceef24e6a30dc790c1cd482bfa40f8  sim/testsuite/sim/frv/srlcc.cgs
-59498912961c5a2bfe37d5631fc3802c  sim/testsuite/sim/frv/srli.cgs
-59addb4ff5949cfea9664343d9f81a38  sim/testsuite/sim/frv/srlicc.cgs
-cc2f98b9ebe473e853c879e903f2f4bd  sim/testsuite/sim/frv/st.cgs
-7da5b6117008820095468c44c991bba7  sim/testsuite/sim/frv/stb.cgs
-038ed75fefa3a9b991855a5b60b5046c  sim/testsuite/sim/frv/stbf.cgs
-ddf4ff091a5b6c5cf352c04d236e2fcc  sim/testsuite/sim/frv/stbfi.cgs
-9fc9892f699a1d3ddc62ae7524e9ce82  sim/testsuite/sim/frv/stbfu.cgs
-e038da35c3e2553c4431a03fe542c5dc  sim/testsuite/sim/frv/stbi.cgs
-fb8002b4e6861b77f536c7629c7bf622  sim/testsuite/sim/frv/stbu.cgs
-64efd173f19902d6a2005148cb3d4831  sim/testsuite/sim/frv/stc.cgs
-c8327289e084ae64868b9257b8646e11  sim/testsuite/sim/frv/stcu.cgs
-791afd243b5e7ed1e6aa29ad1113f218  sim/testsuite/sim/frv/std.cgs
-d34e0187f000a733eaf4b2730118ae03  sim/testsuite/sim/frv/std.pcgs
-04f8995f9af5c9a6d61eb1ab60b34ba0  sim/testsuite/sim/frv/stdc.cgs
-ca358dddc54a8ba43c916ac2a6b45812  sim/testsuite/sim/frv/stdc.pcgs
-285195010d47ac9191d9c97aca80f0e6  sim/testsuite/sim/frv/stdcu.cgs
-b9b610f3e0c8243a5d9e261844251ed7  sim/testsuite/sim/frv/stdf.cgs
-8a296ea605f6ea7504e25318c38b44c4  sim/testsuite/sim/frv/stdf.pcgs
-cdb16f4dfab32f15e7a55fba16afd880  sim/testsuite/sim/frv/stdfi.cgs
-14194ebf318b1a64b5cbc27e067b5110  sim/testsuite/sim/frv/stdfu.cgs
-43e07345873b79b52184a1785a5ce422  sim/testsuite/sim/frv/stdi.cgs
-c1916f813f831be331a1dbc2312fd4bb  sim/testsuite/sim/frv/stdu.cgs
-74d71e1f6d2aa891e6e9cb32cd44e036  sim/testsuite/sim/frv/stf.cgs
-8c68b4f09d376aac18a160f70bbb24c0  sim/testsuite/sim/frv/stfi.cgs
-ef17532bed029b8034a943091bcc8d3a  sim/testsuite/sim/frv/stfu.cgs
-c458c9df8008e8b3f7761d31df5e912d  sim/testsuite/sim/frv/sth.cgs
-8a3789cf60dd4331ea1a6f6e994b76e8  sim/testsuite/sim/frv/sthf.cgs
-8bcf588029874b3f33885374cc496306  sim/testsuite/sim/frv/sthfi.cgs
-4f069f49b6bc39f94f78adf156ce0f43  sim/testsuite/sim/frv/sthfu.cgs
-84ffdd51531190b3f7ab0bd433a36036  sim/testsuite/sim/frv/sthi.cgs
-8ccbca9bbf069a03a4d929333916d88c  sim/testsuite/sim/frv/sthu.cgs
-250d78cd5a5807bcacccc649f4e5d0ad  sim/testsuite/sim/frv/sti.cgs
-5e9fe07f66519bb28e80b540c91d7270  sim/testsuite/sim/frv/stq.cgs
-3a29b1dd11046f8f4dd5c27edc2a8d6f  sim/testsuite/sim/frv/stq.pcgs
-aa46f6b377cfc62824b0be2e6fc1c326  sim/testsuite/sim/frv/stqc.cgs
-73fa8ef52f05985daec1d8a01dbbc29f  sim/testsuite/sim/frv/stqc.pcgs
-e7569bf70d9017f69182cfa2622ebfbf  sim/testsuite/sim/frv/stqcu.cgs
-27da4c018deec302d0e3d6b8c89c9909  sim/testsuite/sim/frv/stqf.cgs
-244caf04384a0a05c44c7299059e0a1e  sim/testsuite/sim/frv/stqf.pcgs
-31598ac83baef878c73a4ac875783821  sim/testsuite/sim/frv/stqfi.cgs
-099e806e30801140def329d0fc74d8f3  sim/testsuite/sim/frv/stqfu.cgs
-01a00c462bcea5bf16545bc7e56ab416  sim/testsuite/sim/frv/stqi.cgs
-3664a976c54024aeb5afceea3da50af6  sim/testsuite/sim/frv/stqu.cgs
-7a55c30063f85e2d54e1cc2841ee7a63  sim/testsuite/sim/frv/stu.cgs
-2faf06039d62d7df322e435075a72433  sim/testsuite/sim/frv/sub.cgs
-7844ed84fbc9b4ee3a16338a630a6b99  sim/testsuite/sim/frv/subcc.cgs
-8c0c31883700925b3a024a0ef3d6e4db  sim/testsuite/sim/frv/subi.cgs
-3a686d8663268c0def363c90e28b1376  sim/testsuite/sim/frv/subicc.cgs
-87cef6e1007d13b030a257ac5991b6e0  sim/testsuite/sim/frv/subx.cgs
-6c55773b2d52d6ed53ba61e9150a8c88  sim/testsuite/sim/frv/subxcc.cgs
-ccb0533eb0f55d739ea829ea6061fd7e  sim/testsuite/sim/frv/subxi.cgs
-0bd2bac2e1c8b477c6ca6c96a9c0d2ec  sim/testsuite/sim/frv/subxicc.cgs
-8aa6fce072b5f76aed92908d9cb37534  sim/testsuite/sim/frv/swap.cgs
-c8282a4995f3299c881dda28d1a95fe6  sim/testsuite/sim/frv/swapi.cgs
-23522584d66a3f774c033e074adf7612  sim/testsuite/sim/frv/tc.cgs
-7ffb238a56ea272bda7a212d95f41684  sim/testsuite/sim/frv/teq.cgs
-2505dee1a39d2cde6c4c38408239b7c0  sim/testsuite/sim/frv/testutils.inc
-a7bdf9822718f81fe29124a9f8da86e6  sim/testsuite/sim/frv/tge.cgs
-04aeccbcf90bc8f88178560c2910dfc7  sim/testsuite/sim/frv/tgt.cgs
-190947262baf5a431a603a9057bd38a6  sim/testsuite/sim/frv/thi.cgs
-d62ead6b5942f8e2a83a67ef8db006bf  sim/testsuite/sim/frv/tic.cgs
-a913dea5c58bfd33d54ec66ebe5abdf3  sim/testsuite/sim/frv/tieq.cgs
-6326a374397a88a326f50a1c5bc7ffe2  sim/testsuite/sim/frv/tige.cgs
-98be2afbdc22e83e7ed60607d14d3586  sim/testsuite/sim/frv/tigt.cgs
-336b596245297750b95b8a77073f7966  sim/testsuite/sim/frv/tihi.cgs
-15b4d16b3eae3485cb76eede88794bbe  sim/testsuite/sim/frv/tile.cgs
-100c61ae3fb0dca4723d52d915d79b03  sim/testsuite/sim/frv/tils.cgs
-ce558734ad2bc060917be3c4618d3552  sim/testsuite/sim/frv/tilt.cgs
-ca0a7cd8b619ec89e936a27126c5809d  sim/testsuite/sim/frv/tin.cgs
-49bc7107d499c26ff0c4f28999dc36ed  sim/testsuite/sim/frv/tinc.cgs
-301a4bafaa39d4e1ab111b7fd38291e9  sim/testsuite/sim/frv/tine.cgs
-51afec41d7406196f09ae12d2ec0db03  sim/testsuite/sim/frv/tino.cgs
-e85d17ee566b10c9e3caeea7e430922e  sim/testsuite/sim/frv/tinv.cgs
-4dcd5dd9170ea1b0782fc5ec7bce6e58  sim/testsuite/sim/frv/tip.cgs
-a01a5cb5837ff3029820691d608c0fe3  sim/testsuite/sim/frv/tira.cgs
-4a3754ff5d07a1bff25b091c6475abad  sim/testsuite/sim/frv/tiv.cgs
-0852100fd0d41a5575a5d49b4b43537e  sim/testsuite/sim/frv/tle.cgs
-e77e2e2eb284cae56dede5c4e7b16bbe  sim/testsuite/sim/frv/tls.cgs
-4a9afe4a49c80157e0738e27bd5f3a52  sim/testsuite/sim/frv/tlt.cgs
-eb0c622a60c8bb2159d3a20ddaf72563  sim/testsuite/sim/frv/tn.cgs
-a58b7d334a64b2f17d8110d347c1fcbe  sim/testsuite/sim/frv/tnc.cgs
-ec7dfbef9d8c3fcfbd2a205998b43499  sim/testsuite/sim/frv/tne.cgs
-533ecf4107a99d0372bd32229bb091ae  sim/testsuite/sim/frv/tno.cgs
-cad1a26e6f61be6236cdf19c6f330241  sim/testsuite/sim/frv/tnv.cgs
-5702a40a3528f6faf8e82e13564087ac  sim/testsuite/sim/frv/tp.cgs
-ecca874070d3e9425aeb8088c8a60d30  sim/testsuite/sim/frv/tra.cgs
-41358b18cb9bba0fa299b05270c44629  sim/testsuite/sim/frv/tv.cgs
-d8ef8851170116f7cc0700416b84aa6a  sim/testsuite/sim/frv/udiv.cgs
-8cb511e7ba50142c3d082aaedf99e2d4  sim/testsuite/sim/frv/udivi.cgs
-9b3fe3689386f452b6a4efa05a509b8c  sim/testsuite/sim/frv/umul.cgs
-77681bcd415a24cb17bbdf0f77eb260b  sim/testsuite/sim/frv/umulcc.cgs
-f6e8f7472bf3297a7b540ebaabc0c1f2  sim/testsuite/sim/frv/umuli.cgs
-9797e25ce9dc0b46d586cd0d92620735  sim/testsuite/sim/frv/umulicc.cgs
-0edd78565b6001f524f716ab9d2d96c0  sim/testsuite/sim/frv/xor.cgs
-9be8c0bf0141c153cf179aa9b42ee2d1  sim/testsuite/sim/frv/xorcc.cgs
-04132b96881a20ec0effc93a6a586ea9  sim/testsuite/sim/frv/xorcr.cgs
-738a395cb2d18169d1b0c2027636cf1b  sim/testsuite/sim/frv/xori.cgs
-887a01bed2d74acf834781ed7fa9f560  sim/testsuite/sim/frv/xoricc.cgs
-f158b414d72856611131bd4eb7db62ff  sim/testsuite/sim/frv/fr400/addss.cgs
-82bc6562aa51560206e828ae2202ca5f  sim/testsuite/sim/frv/fr400/allinsn.exp
-07bb80901aaaa29c4ef20dbef3debb70  sim/testsuite/sim/frv/fr400/csdiv.cgs
-dc7862c2d91981e56cddc36314f0c630  sim/testsuite/sim/frv/fr400/maddaccs.cgs
-4cc9052cb05275a67396e5ea46d54af6  sim/testsuite/sim/frv/fr400/masaccs.cgs
-2039d3b5260700c8371efd1a6ab21552  sim/testsuite/sim/frv/fr400/maveh.cgs
-4ac0a330e6fa287d0f2f2f8500453afc  sim/testsuite/sim/frv/fr400/mclracc.cgs
-285f596d7467307f369b18d453abe1ea  sim/testsuite/sim/frv/fr400/mhdseth.cgs
-5e1be1e0297eb84b961c6dc29d4cce8c  sim/testsuite/sim/frv/fr400/mhdsets.cgs
-9bb2a41f38271c359451454b6d2a79dc  sim/testsuite/sim/frv/fr400/mhsethih.cgs
-dac84369f283aabc0e0c8d6188130e92  sim/testsuite/sim/frv/fr400/mhsethis.cgs
-538622163aded8a4e8f1d47d61db8b5c  sim/testsuite/sim/frv/fr400/mhsetloh.cgs
-a808c8a95fde4532828d00e281c1322c  sim/testsuite/sim/frv/fr400/mhsetlos.cgs
-a1032b0fb6b6923000282a43d3f85a7a  sim/testsuite/sim/frv/fr400/movgs.cgs
-0f2cd9ab4e36a741a77488033a0ceeb0  sim/testsuite/sim/frv/fr400/movsg.cgs
-e4644c48c06766cd34578d5ce34680dd  sim/testsuite/sim/frv/fr400/msubaccs.cgs
-417d0b67f6f7ff0d5e58e0178ef7836c  sim/testsuite/sim/frv/fr400/scutss.cgs
-daad245fe005a9a6394bb569733c9aed  sim/testsuite/sim/frv/fr400/sdiv.cgs
-b90754c53de9e9744ee927d4993920fc  sim/testsuite/sim/frv/fr400/sdivi.cgs
-844d78bc2c7fd493b1e1407468de1927  sim/testsuite/sim/frv/fr400/slass.cgs
-67c70214b5e434fb7bbd3519fe1ad576  sim/testsuite/sim/frv/fr400/smass.cgs
-feeb130ecb5cf4428f8bccbe30eb476e  sim/testsuite/sim/frv/fr400/smsss.cgs
-d8697f0e1b4ecfee90b75abe2f016aa5  sim/testsuite/sim/frv/fr400/smu.cgs
-d23a9bd2315e8430ed038216b2e3e58d  sim/testsuite/sim/frv/fr400/subss.cgs
-621cd869aa5b032b34294f31f3e4a702  sim/testsuite/sim/frv/fr400/udiv.cgs
-146cea8d68ddb592d231ab14478a8d0b  sim/testsuite/sim/frv/fr400/udivi.cgs
-bf7e8ae5fa9de937c99e7e09f42bbac5  sim/testsuite/sim/frv/fr500/allinsn.exp
-9fdc5172e86b3be5621a6faf3f07db74  sim/testsuite/sim/frv/fr500/cmqaddhss.cgs
-1de69657638007870281ce9da005db7f  sim/testsuite/sim/frv/fr500/cmqaddhus.cgs
-76820a559b8411a4ae43b6a383d65b0d  sim/testsuite/sim/frv/fr500/cmqsubhss.cgs
-dc65c316119a5c8162d829bbd7c0223a  sim/testsuite/sim/frv/fr500/cmqsubhus.cgs
-16004a850f6c18d31c7430fbab31f79d  sim/testsuite/sim/frv/fr500/dcpl.cgs
-54a02614046bab2457214898aff37526  sim/testsuite/sim/frv/fr500/dcul.cgs
-99e08a053ed3e5abb1c4bf9c6a64fbc1  sim/testsuite/sim/frv/fr500/mclracc.cgs
-fe34b6bddc9686a443e9025451c3ac88  sim/testsuite/sim/frv/fr500/mqaddhss.cgs
-b113a28c5f41f7ab598d39fab2d5e21f  sim/testsuite/sim/frv/fr500/mqaddhus.cgs
-35285cc52bbb31d9b25d6144f54fa5b5  sim/testsuite/sim/frv/fr500/mqsubhss.cgs
-d5b43c22363018a3259eb6849019a024  sim/testsuite/sim/frv/fr500/mqsubhus.cgs
-d35335c0a9a7da8ef8224e724dc95c81  sim/testsuite/sim/frv/fr550/allinsn.exp
-091a034f51a640f3113ea17c26e3b296  sim/testsuite/sim/frv/fr550/cmaddhss.cgs
-ddaf6b5840f92b8d37a897bac56b86b0  sim/testsuite/sim/frv/fr550/cmaddhus.cgs
-c41c0de91e307c8506c8c5275940f7ea  sim/testsuite/sim/frv/fr550/cmcpxiu.cgs
-9b75556c75c9bfb61102e93aa0b85be4  sim/testsuite/sim/frv/fr550/cmcpxru.cgs
-14be5a3d28703927ea3b168b6140855d  sim/testsuite/sim/frv/fr550/cmmachs.cgs
-df6f7d84607830c79a2f338b8b6160f6  sim/testsuite/sim/frv/fr550/cmmachu.cgs
-dea84ff288f50a75076a9c6df51682c6  sim/testsuite/sim/frv/fr550/cmqaddhss.cgs
-d20b77015f938e4bcf50ebffae74fc6b  sim/testsuite/sim/frv/fr550/cmqaddhus.cgs
-d6946f604c4c119692ac621e5cdf0a92  sim/testsuite/sim/frv/fr550/cmqmachs.cgs
-c28cd342558f4cc6ad9b33d7c80b45aa  sim/testsuite/sim/frv/fr550/cmqmachu.cgs
-9f27020e63e8992a63456f9092967d34  sim/testsuite/sim/frv/fr550/cmqsubhss.cgs
-b13883bf53e547a18365378a79b4ff9a  sim/testsuite/sim/frv/fr550/cmqsubhus.cgs
-cae62d22839ef1abf864fd44a1087197  sim/testsuite/sim/frv/fr550/cmsubhss.cgs
-1b1c3f8892f5ff1108650006f4f2318a  sim/testsuite/sim/frv/fr550/cmsubhus.cgs
-f564e7d684efbe7a682ba9aa24cf39ab  sim/testsuite/sim/frv/fr550/dcpl.cgs
-0bfbdf1314d6a04afa36ce4404a81bf2  sim/testsuite/sim/frv/fr550/dcul.cgs
-cd733adfb1ef5d2f7d93d57183587d7a  sim/testsuite/sim/frv/fr550/mabshs.cgs
-55c8d941be619469d2bf80f7eba5a3cf  sim/testsuite/sim/frv/fr550/maddaccs.cgs
-269e14aaffa3452b360e1f0ddb12df93  sim/testsuite/sim/frv/fr550/maddhss.cgs
-ffbb77202774953b6eb98f6329c3221c  sim/testsuite/sim/frv/fr550/maddhus.cgs
-aed0b1242d7c5a0eada01cb581ef44ab  sim/testsuite/sim/frv/fr550/masaccs.cgs
-594c6a9c3278bcc019e98aa44a86c22a  sim/testsuite/sim/frv/fr550/mdaddaccs.cgs
-7cdef8608795f0ed222e67db1343a635  sim/testsuite/sim/frv/fr550/mdasaccs.cgs
-14183fbd685848d558ab84952c1271b1  sim/testsuite/sim/frv/fr550/mdsubaccs.cgs
-85c318f9489df3a78af9171868d9e789  sim/testsuite/sim/frv/fr550/mmachs.cgs
-7c4ba31a4b54c5449d932fceeeb3aa1d  sim/testsuite/sim/frv/fr550/mmachu.cgs
-f105b296560b5b75436069679f4d6dfd  sim/testsuite/sim/frv/fr550/mmrdhs.cgs
-5ade21b6577e4102c74e56fd9ac67d5d  sim/testsuite/sim/frv/fr550/mmrdhu.cgs
-252cdd83e9dd8de140e437bcc84a45a6  sim/testsuite/sim/frv/fr550/mqaddhss.cgs
-4938bf73cdf15f5d4a195ccc1bc1a426  sim/testsuite/sim/frv/fr550/mqaddhus.cgs
-7ccfed47ea8ad55515dab94b96d6babf  sim/testsuite/sim/frv/fr550/mqmachs.cgs
-aef3c4befd6509d86b1532ddbf3fb4a9  sim/testsuite/sim/frv/fr550/mqmachu.cgs
-76e79dccff8084f4921e771c099fdbe0  sim/testsuite/sim/frv/fr550/mqmacxhs.cgs
-a73a09a1e4d5df6332355e6558054066  sim/testsuite/sim/frv/fr550/mqsubhss.cgs
-e3ef857df51606a95b919b802bc62434  sim/testsuite/sim/frv/fr550/mqsubhus.cgs
-f7992a1f5e0512afb72f4ea8abf785ed  sim/testsuite/sim/frv/fr550/mqxmachs.cgs
-1d35c09a8a300edc364a00ba655ca259  sim/testsuite/sim/frv/fr550/mqxmacxhs.cgs
-60a0aa6675f9b1d37f0b6b58e04e6aba  sim/testsuite/sim/frv/fr550/msubaccs.cgs
-26acdfc92872c06ef0f3750cda5f6f75  sim/testsuite/sim/frv/fr550/msubhss.cgs
-90677e8af5e1904d14d9bfd3e562fcbb  sim/testsuite/sim/frv/fr550/msubhus.cgs
-45902a95cfa0b6432a1cbb6db50830b6  sim/testsuite/sim/frv/fr550/mtrap.cgs
-57f7099366dbf0b511896d03b5343808  sim/testsuite/sim/frv/fr550/udiv.cgs
-55cd07e74cc057a786a2a9c43ed5d8dc  sim/testsuite/sim/frv/fr550/udivi.cgs
-c6ab746acfbb43a0b62848e6626307be  sim/testsuite/sim/frv/interrupts/Ipipe-fr400.cgs
-fad5307c32c5fd7792da21d6fa8034a4  sim/testsuite/sim/frv/interrupts/Ipipe-fr500.cgs
-1442aef29a1429ad5b417d6e072f0bed  sim/testsuite/sim/frv/interrupts/badalign-fr550.cgs
-bb56d8cd61856a2eceb509be16a37354  sim/testsuite/sim/frv/interrupts/badalign.cgs
-ba84baad2c0fbc0fb425f3042fa91e04  sim/testsuite/sim/frv/interrupts/compound-fr550.cgs
-e7920163cd59bc2dd0f5d977fc7566bd  sim/testsuite/sim/frv/interrupts/compound.cgs
-2a80a2eee2d47ba494278b13a0eae8e7  sim/testsuite/sim/frv/interrupts/data_store_error-fr550.cgs
-3b7c9b823a6bdae97b790110baa1cd1b  sim/testsuite/sim/frv/interrupts/data_store_error.cgs
-fec5ed68fd41939cf49c52a4e9869561  sim/testsuite/sim/frv/interrupts/fp_exception-fr550.cgs
-1d3d97d97f5d70897bf41786ed0f81a2  sim/testsuite/sim/frv/interrupts/fp_exception.cgs
-9dc2f73112811f25a5a15f53a6be64e2  sim/testsuite/sim/frv/interrupts/illinsn.cgs
-be93394d8610eb7a13b316901ad8a9b5  sim/testsuite/sim/frv/interrupts/insn_access_error-fr550.cgs
-bc6228cbbffde88aba638f1e9ef39ad5  sim/testsuite/sim/frv/interrupts/insn_access_error.cgs
-d3bf79293e8377be411d124f213784e1  sim/testsuite/sim/frv/interrupts/mp_exception.cgs
-d78319cc00e420d2ea14a943bacb5b73  sim/testsuite/sim/frv/interrupts/privileged_instruction.cgs
-4dcb6ae1f3af2a946fccc0349454555e  sim/testsuite/sim/frv/interrupts/regalign.cgs
-a03ea7e55879465603afc8e54e656577  sim/testsuite/sim/frv/interrupts/reset.cgs
-90377ce05b3a5bfdde34c7349008e3d3  sim/testsuite/sim/frv/interrupts/shadow_regs.cgs
-026ab0d2d0845245adbc296619cc9d46  sim/testsuite/sim/frv/interrupts/timer.cgs
-83e117c2d2f8a4273b4b529c7b9803ad  sim/testsuite/sim/h8300/ChangeLog
-ce415b253063a7fe5cf02f17fb48faab  sim/testsuite/sim/h8300/addb.s
-399b6e09a2ae39da12b2321cd0965b91  sim/testsuite/sim/h8300/addl.s
-2dad02e99bd1422af83cb4353b7e63c0  sim/testsuite/sim/h8300/adds.s
-9766c17a5c5cc1408ada3b9cc437ba28  sim/testsuite/sim/h8300/addw.s
-8cbc4afc2f6b11b850e0aec04ed1a473  sim/testsuite/sim/h8300/addx.s
-1b1082501d2ae954bf8cfe0ef39b83c2  sim/testsuite/sim/h8300/allinsn.exp
-90637fa47d75134bb5869022a29f120c  sim/testsuite/sim/h8300/andb.s
-6fdb213d98f348f1c02d48ffcfd806e5  sim/testsuite/sim/h8300/andl.s
-376c12070675b9d7dd2c58e70ee98842  sim/testsuite/sim/h8300/andw.s
-677b0dc3ede8ba248cb652cab95b9b0c  sim/testsuite/sim/h8300/band.s
-fce577f47862442fa9b2da616615c1d2  sim/testsuite/sim/h8300/bfld.s
-893d0b1072d7416e133a80d501b49cd4  sim/testsuite/sim/h8300/biand.s
-0412ca2321a01a8b7c32897e3f32dd37  sim/testsuite/sim/h8300/bra.s
-e2433fc36981757f93eb5bb4f1b039ac  sim/testsuite/sim/h8300/brabc.s
-a537d28284905856ca4b2c9880fb5b0b  sim/testsuite/sim/h8300/bset.s
-dd6fabe64292ad56b43ca5532e790417  sim/testsuite/sim/h8300/cmpb.s
-5d4de83de24b934dbec418f81b0fbc02  sim/testsuite/sim/h8300/cmpl.s
-16151c89821d742e389f60a77a9c4214  sim/testsuite/sim/h8300/cmpw.s
-4c711137a90bb2ba4b2f44ad3ef33ba7  sim/testsuite/sim/h8300/daa.s
-7032f158ede5e9c1fe95569152aac2a7  sim/testsuite/sim/h8300/das.s
-7038c79de7fb4f02cd5ef969e2cffd30  sim/testsuite/sim/h8300/dec.s
-8ecc998cf6c3e91a5e2f7ca901c6baa2  sim/testsuite/sim/h8300/div.s
-caa5a5b27cbcbfaea63298e864279ae4  sim/testsuite/sim/h8300/extl.s
-a159e301d3202b02c3d6ac416aeedcf6  sim/testsuite/sim/h8300/extw.s
-388f4ab3999f0a563801fbdec2667f71  sim/testsuite/sim/h8300/inc.s
-c5cc1774fded69045dd1d5a31e4eecc7  sim/testsuite/sim/h8300/jmp.s
-5745f4f097642a8d3aa1e6f949b20d72  sim/testsuite/sim/h8300/ldc.s
-677c2ca0cf5c9c3c593a7a9274859bba  sim/testsuite/sim/h8300/ldm.s
-63a01cd1ac69acaa0cb441c4f1ef5b89  sim/testsuite/sim/h8300/mac.s
-4e839f3223289908cd6e2ba525776dec  sim/testsuite/sim/h8300/mova.s
-7cf771780ab43e6a7a25ed05f8a17ee7  sim/testsuite/sim/h8300/movb.s
-abfa7675b179fc4254e14cec675be772  sim/testsuite/sim/h8300/movl.s
-c0f7ecf275c71ba8ba57b2098887abf4  sim/testsuite/sim/h8300/movmd.s
-637fafb5b7e807abbb1f528bca9cc697  sim/testsuite/sim/h8300/movsd.s
-8bfd3316d1c16f85273138771fdbbbf0  sim/testsuite/sim/h8300/movw.s
-9649dc0eb3a2346a3ce916dd57eb1b28  sim/testsuite/sim/h8300/mul.s
-2373f3011c78310592feef6fe9432f0a  sim/testsuite/sim/h8300/neg.s
-99f82cb39a007343d1a5bd8c71960fcb  sim/testsuite/sim/h8300/nop.s
-a1ed4f63b96068eaa77495745494ffea  sim/testsuite/sim/h8300/not.s
-a938731b6a18a4e389d565b373fdb164  sim/testsuite/sim/h8300/orb.s
-62d2fe5825e86377f04ad0167a214c62  sim/testsuite/sim/h8300/orl.s
-5d42a1f9b287e529549796fef4c879c8  sim/testsuite/sim/h8300/orw.s
-b99bd4670fdfe75f10e37ea480d537f0  sim/testsuite/sim/h8300/rotl.s
-f75f1bed46894927fbb7773bc84081fc  sim/testsuite/sim/h8300/rotr.s
-3b4dfe0168e63c6e80583c262c5de759  sim/testsuite/sim/h8300/rotxl.s
-4eecc1e3c8c3ef39f35071a0d35c126e  sim/testsuite/sim/h8300/rotxr.s
-ffef0a19e06ed3716630c870e2c78e97  sim/testsuite/sim/h8300/shal.s
-0b8a477e0fbf76499733fc12811aa4c6  sim/testsuite/sim/h8300/shar.s
-0f85e20fbab15124e67dde283ee4b159  sim/testsuite/sim/h8300/shll.s
-3b3ad8e7276c6719c8adfa92951bef0b  sim/testsuite/sim/h8300/shlr.s
-e1a2e3252f570905ffbdc48d6a44089d  sim/testsuite/sim/h8300/stack.s
-ebd21badf420c5cee8b0d88a08868304  sim/testsuite/sim/h8300/stc.s
-9b63ff9fbde1e63acd708924198b7242  sim/testsuite/sim/h8300/subb.s
-a63920fd12f48e551687aacc6bfae557  sim/testsuite/sim/h8300/subl.s
-c55d9e46ef6b31eb575f129340b18dce  sim/testsuite/sim/h8300/subs.s
-db0176e7c9b6cb42862f2377e55312f5  sim/testsuite/sim/h8300/subw.s
-e0e2129ddb10014bc62124746c911369  sim/testsuite/sim/h8300/subx.s
-81e2e460e06fcf47b7ed621287bfbafa  sim/testsuite/sim/h8300/tas.s
-e889ba6121bfc3b32c11372b6d4c9dcd  sim/testsuite/sim/h8300/testutils.inc
-307b4b54b70c077beb6b886ed1dadc9d  sim/testsuite/sim/h8300/xorb.s
-8ea8bfb6cddf05ef11ea7fb068e218e6  sim/testsuite/sim/h8300/xorl.s
-c2e57a11d5e455cef19248c2a0fb26b0  sim/testsuite/sim/h8300/xorw.s
-16834904d188192c7fbb15f488c53087  sim/testsuite/sim/m32r/add.cgs
-e9adf1458ab377d5d90d1678d2292bd5  sim/testsuite/sim/m32r/add3.cgs
-8cf9213ee7ef813787645bc4c9e12727  sim/testsuite/sim/m32r/addi.cgs
-a7b10e6f679c84fe5b2db48164037526  sim/testsuite/sim/m32r/addv.cgs
-30cfed398315d692a3de98e4c67f90af  sim/testsuite/sim/m32r/addv3.cgs
-690ba3d9db8db10a35899c8eac122f65  sim/testsuite/sim/m32r/addx.cgs
-787a6f21f2739736e0a79118443e311a  sim/testsuite/sim/m32r/allinsn.exp
-7d5b3e41f7f293b573606e13d0a5c301  sim/testsuite/sim/m32r/and.cgs
-29e08614d0fde06b6322dad1cc619d93  sim/testsuite/sim/m32r/and3.cgs
-f57a1ae6784adef83a83d0fc96e627d3  sim/testsuite/sim/m32r/bc24.cgs
-b5eba276aa402a66811d04183ae7da9b  sim/testsuite/sim/m32r/bc8.cgs
-43914dad0473cf29fa8ba7483fcc42a1  sim/testsuite/sim/m32r/beq.cgs
-aa647bf776c6497768956dd13b1bc0e6  sim/testsuite/sim/m32r/beqz.cgs
-bcd9f3fee3d28ed1096a5ef6514c0538  sim/testsuite/sim/m32r/bgez.cgs
-61391eba2b47c3b035c549673a100135  sim/testsuite/sim/m32r/bgtz.cgs
-9041e76bd9e52d5245b6485c481ce1e3  sim/testsuite/sim/m32r/bl24.cgs
-9be91c4daa50b174585b34804fadde45  sim/testsuite/sim/m32r/bl8.cgs
-a38ca2fe69cd52716f929b7be6ee5690  sim/testsuite/sim/m32r/blez.cgs
-b30f0ad9c59b0374e5b52f24e549ae36  sim/testsuite/sim/m32r/bltz.cgs
-1b3b8a230f2693ae45a566995a0b9775  sim/testsuite/sim/m32r/bnc24.cgs
-ae67e7de7ffee3af12ef63c7770eb6be  sim/testsuite/sim/m32r/bnc8.cgs
-7a9b903b84abb5fead9cdfdde1804492  sim/testsuite/sim/m32r/bne.cgs
-2bd489b3cdd376a0a6b2de5f4a26712f  sim/testsuite/sim/m32r/bnez.cgs
-ae803eba46d3c6a6aa1c741aec2783be  sim/testsuite/sim/m32r/bra24.cgs
-0ebb2e3161db55a3203b65392361b6bd  sim/testsuite/sim/m32r/bra8.cgs
-d863c2fc17c8b7509aa0996e8a3f15b4  sim/testsuite/sim/m32r/cmp.cgs
-7d8da1455d2cd44a51707b07b4b00977  sim/testsuite/sim/m32r/cmpi.cgs
-1e2a8c3e0cc7b5988cef7334bf2e14bf  sim/testsuite/sim/m32r/cmpu.cgs
-0e4b1ac17d86c08b1d98e90ee379e7c8  sim/testsuite/sim/m32r/cmpui.cgs
-42509b9f2bc28c62f815e3094e75f4ea  sim/testsuite/sim/m32r/div.cgs
-fc14b150efe66c251e584a8490ab411c  sim/testsuite/sim/m32r/divu.cgs
-f3f4a05a6d442fdb1a2dbe82fbc22d5e  sim/testsuite/sim/m32r/hello.ms
-62c53b4fa4929b659e1b8f3dce7ed101  sim/testsuite/sim/m32r/hw-trap.ms
-72ae1c84434e74d7a53d09e002ab9830  sim/testsuite/sim/m32r/jl.cgs
-3f2b2701b3579de8839bd35d25076d03  sim/testsuite/sim/m32r/jmp.cgs
-34c7f8c3e919f9ba0f0b3c7caa68f237  sim/testsuite/sim/m32r/ld-d.cgs
-e0e5a244234e059b9099534cde98fd29  sim/testsuite/sim/m32r/ld-plus.cgs
-dcbcafa8b504f5c1750e3a7f33d06b04  sim/testsuite/sim/m32r/ld.cgs
-a1584b288866f94579bbf2981c7d812e  sim/testsuite/sim/m32r/ld24.cgs
-8e71d37539927768d17f19c43cfe41bf  sim/testsuite/sim/m32r/ldb-d.cgs
-31a4c374f7d38d4214300cb58342cb7e  sim/testsuite/sim/m32r/ldb.cgs
-55e96d8c138d454b947b0c627268410a  sim/testsuite/sim/m32r/ldh-d.cgs
-101e467bd8d9570809bd743b775e657d  sim/testsuite/sim/m32r/ldh.cgs
-29dd50ce15ab9c0d67791901e45a791d  sim/testsuite/sim/m32r/ldi16.cgs
-ddcce0a4e903b1df7a8d3f9d07b133b4  sim/testsuite/sim/m32r/ldi8.cgs
-5422abf5a05ea36c524bac97c177f79a  sim/testsuite/sim/m32r/ldub-d.cgs
-b464f9a46248faed5a856867decd109b  sim/testsuite/sim/m32r/ldub.cgs
-38f45019c0a3b58549b0dba4f6595f20  sim/testsuite/sim/m32r/lduh-d.cgs
-d0c711109b91fb82235f2c7de6be93e0  sim/testsuite/sim/m32r/lduh.cgs
-17eccc048da153abc362bee34fe42579  sim/testsuite/sim/m32r/lock.cgs
-a249bb8bdbaad16488d816dbd85eb1a1  sim/testsuite/sim/m32r/machi.cgs
-7d3d647734fda959f3b1e738c2b90222  sim/testsuite/sim/m32r/maclo.cgs
-42e2898d542715203fac38dbabe95593  sim/testsuite/sim/m32r/macwhi.cgs
-606cf06f01516f620ade2833b6f4272f  sim/testsuite/sim/m32r/macwlo.cgs
-17924a13af249ae4d0a6df996e622124  sim/testsuite/sim/m32r/misc.exp
-497cfa2e1bc18e2fadb92c99fbcadcab  sim/testsuite/sim/m32r/mul.cgs
-0ea66074ee25fd61d52074d38b4358e6  sim/testsuite/sim/m32r/mulhi.cgs
-951d325ba4e7036401fa243439c0f27f  sim/testsuite/sim/m32r/mullo.cgs
-518d60a9ec3ed23e3da2aff0b1456ac0  sim/testsuite/sim/m32r/mulwhi.cgs
-fbed9d4fe93ebbb695228b4a94655dd5  sim/testsuite/sim/m32r/mulwlo.cgs
-ecaba0191d387d8875378bf790693bbe  sim/testsuite/sim/m32r/mv.cgs
-60ce74d2420a29592309f2f3cbf0bb27  sim/testsuite/sim/m32r/mvfachi.cgs
-ab51940820c840824c1309f87b0c7430  sim/testsuite/sim/m32r/mvfaclo.cgs
-9c2236dea1f22183f110260aac6e7821  sim/testsuite/sim/m32r/mvfacmi.cgs
-aa1ec114448f408800129388f774de40  sim/testsuite/sim/m32r/mvfc.cgs
-ee8c3058b6a4fc408f0725c7e0027956  sim/testsuite/sim/m32r/mvtachi.cgs
-8cfc6346c5ce5f4e7464057b25ec31b7  sim/testsuite/sim/m32r/mvtaclo.cgs
-8f0cac941aa884623e680f3e4ac0c8b1  sim/testsuite/sim/m32r/mvtc.cgs
-98c363f615a992eebb741216c4b99238  sim/testsuite/sim/m32r/neg.cgs
-57368ba4c4be662e4d7e09c2fbf73007  sim/testsuite/sim/m32r/nop.cgs
-b0703d4f2678b98efa516375d14989d8  sim/testsuite/sim/m32r/not.cgs
-9778769d1c0af0c0fc330032708ff835  sim/testsuite/sim/m32r/or.cgs
-4adb31d9941df9283e7d046457611c97  sim/testsuite/sim/m32r/or3.cgs
-9171592763b85a01ee783cc5c814c696  sim/testsuite/sim/m32r/rac.cgs
-ec2520e6aae9332a6671d4c8a8e5b045  sim/testsuite/sim/m32r/rach.cgs
-241464dd5ebda3e9291399db7f07fde6  sim/testsuite/sim/m32r/rem.cgs
-79728809577a7966c7f6d3e74eeeab11  sim/testsuite/sim/m32r/remu.cgs
-e200d0626a3a782b1ba827d77008622c  sim/testsuite/sim/m32r/rte.cgs
-966058aa7f21ef4a7874f1a0d9888543  sim/testsuite/sim/m32r/seth.cgs
-672b4886a81c13ca0bf05d1df568df5f  sim/testsuite/sim/m32r/sll.cgs
-37da8b574adf3cb6f65a7119fab322a7  sim/testsuite/sim/m32r/sll3.cgs
-8a79f97b82a93537f9d0afd46d1ce63e  sim/testsuite/sim/m32r/slli.cgs
-b29c344695a538384d37acf2acf3f974  sim/testsuite/sim/m32r/sra.cgs
-237457a459b83e66c0a0f95ba0842910  sim/testsuite/sim/m32r/sra3.cgs
-c86fb3aef80e809c5161380443aec696  sim/testsuite/sim/m32r/srai.cgs
-cda1698f1a6d640498ce3e6cd47add4f  sim/testsuite/sim/m32r/srl.cgs
-806b43d4fd12897c2b02e9b2f876b308  sim/testsuite/sim/m32r/srl3.cgs
-e43074ac62cc10354b7a7759fe2fe869  sim/testsuite/sim/m32r/srli.cgs
-15a9f901cebcbc565c224f6c61c07326  sim/testsuite/sim/m32r/st-d.cgs
-88d455c342dfa2947283cd4e7b82f3a1  sim/testsuite/sim/m32r/st-minus.cgs
-c66238280149c9f42dd1e19852afd136  sim/testsuite/sim/m32r/st-plus.cgs
-a79a2f93fa80d613b872cc172ef3e9e8  sim/testsuite/sim/m32r/st.cgs
-81e73b1946f04046a562428a766077ec  sim/testsuite/sim/m32r/stb-d.cgs
-d6a79a79477689d7e9bf45ff48a1d65c  sim/testsuite/sim/m32r/stb.cgs
-5b9e264b3d7e3e123150e7933e9776bf  sim/testsuite/sim/m32r/sth-d.cgs
-cc4e95eb280ae19c0d22b639bc9fc601  sim/testsuite/sim/m32r/sth.cgs
-faf25008374bb5be6c2d003c079b6b62  sim/testsuite/sim/m32r/sub.cgs
-8a180be9e21c1fcadb9dbbc751093bb2  sim/testsuite/sim/m32r/subv.cgs
-9bd48d851532a2d84c1edf2872c9a66e  sim/testsuite/sim/m32r/subx.cgs
-45e6e4177ecd2fe6a1ecde8fcb839662  sim/testsuite/sim/m32r/testutils.inc
-54efa34ea2ee72560aa9d26f7f557879  sim/testsuite/sim/m32r/trap.cgs
-cfd913f0a5ee4bd41656b5e4283c96d1  sim/testsuite/sim/m32r/unlock.cgs
-faf23b2f12b51357e3e72b13e79ecc7c  sim/testsuite/sim/m32r/uread16.ms
-9c7bdcfc3ad3791fa0248573c2307cf9  sim/testsuite/sim/m32r/uread32.ms
-6df2ea19b2030cc2ad6f1631641587a6  sim/testsuite/sim/m32r/uwrite16.ms
-749a9149d30e113900b3f089779740ed  sim/testsuite/sim/m32r/uwrite32.ms
-6f6c3fdb3474157358c545914bf2c510  sim/testsuite/sim/m32r/xor.cgs
-3795134a6b03341f5a6480f66e7c29f1  sim/testsuite/sim/m32r/xor3.cgs
-2eb839eb05a26e3a5e32c25337213846  sim/testsuite/sim/mips/ChangeLog
-0793a9181a86167ebddbbd90eabe6f55  sim/testsuite/sim/mips/basic.exp
-e0d825bc919d1cecf677c3a680ae289e  sim/testsuite/sim/mips/fpu64-ps-sb1.s
-23824f277c77ae50de4132ab689dc997  sim/testsuite/sim/mips/fpu64-ps.s
-010a7642804f84eed2c5d95c2e113505  sim/testsuite/sim/mips/hilo-hazard-1.s
-4a5328391392623d88e0157152bf5cdc  sim/testsuite/sim/mips/hilo-hazard-2.s
-a7cc9277eb6ba36b256b2c80492d102d  sim/testsuite/sim/mips/hilo-hazard-3.s
-f535e37ff22fed8de46db57afce1f650  sim/testsuite/sim/mips/mdmx-ob-sb1.s
-02725ea588520413b03083318e76a5ba  sim/testsuite/sim/mips/mdmx-ob.s
-9c2a33617579b2e30edfca8825652a1a  sim/testsuite/sim/mips/mips32-dsp.s
-6fcecb87bfbcd8a4445543fd7f4d66cd  sim/testsuite/sim/mips/mips32-dsp2.s
-b19e0c53b685c87920887bc87dba4579  sim/testsuite/sim/mips/sanity.s
-e6bcd708745b66f4be7bd0181f309147  sim/testsuite/sim/mips/testutils.inc
-aa4ed230347e71fc35e45e43281a8cd0  sim/testsuite/sim/mips/utils-dsp.inc
-cc7f494fd012143e828f1048a618ec9f  sim/testsuite/sim/mips/utils-fpu.inc
-e58cd11281bd103029eac003184a249c  sim/testsuite/sim/mips/utils-mdmx.inc
-8bf0a506ce4372e70d67fe1d8ce76e32  sim/testsuite/sim/sh/ChangeLog
-282a3539572ea760a8d7a480a27800d4  sim/testsuite/sim/sh/add.s
-430ffdb88b8f5c054817526afb4be362  sim/testsuite/sim/sh/allinsn.exp
-f8dca2ef83e73c5c462ef000c13478bb  sim/testsuite/sim/sh/and.s
-4a9329e1cb4c8a230a4e050d69c0b717  sim/testsuite/sim/sh/bandor.s
-055b8ddbb40bf3ffeb7b5eac3057b54b  sim/testsuite/sim/sh/bandornot.s
-f72cc94c6e69883b35e7075dbdcbcea3  sim/testsuite/sim/sh/bclr.s
-556a45437699573fa48c643bd8248712  sim/testsuite/sim/sh/bld.s
-bef19f1e4cfc1d6ad2fb8643c0033ca0  sim/testsuite/sim/sh/bldnot.s
-d292c4a8d61a79c219e38af6dd3c4393  sim/testsuite/sim/sh/bset.s
-379168064f95675285708c5eaf92bad2  sim/testsuite/sim/sh/bst.s
-36e38378e39dd9cceb78c21823b24693  sim/testsuite/sim/sh/bxor.s
-649dca482464a82f27f31481b2f1c8e0  sim/testsuite/sim/sh/clip.s
-3150deaa0636676e8347bb114fe1d308  sim/testsuite/sim/sh/div.s
-69150191761fac26b8276af2f85efd90  sim/testsuite/sim/sh/dmxy.s
-e4e686dacc645b9fc1114279b13b460b  sim/testsuite/sim/sh/fabs.s
-7fcd022e6881b031f0deee8c6816a79a  sim/testsuite/sim/sh/fadd.s
-2f5a45c653e08f75d00a67577a721db7  sim/testsuite/sim/sh/fail.s
-22f8beefa505dc232a3593e167d51b2b  sim/testsuite/sim/sh/fcmpeq.s
-f98492eeeab950ed63e6c2d52a3c57d8  sim/testsuite/sim/sh/fcmpgt.s
-45e3b96fa5b2e581805f106c3d99f968  sim/testsuite/sim/sh/fcnvds.s
-7f6673539421b7915a57f34826612d75  sim/testsuite/sim/sh/fcnvsd.s
-ea612dc8f08a57ade93a63b0b6563e5c  sim/testsuite/sim/sh/fdiv.s
-f008ac5e491f8ceab68b9f59056e9b16  sim/testsuite/sim/sh/fipr.s
-b43309a7445615ae8abafb4900d4f3e7  sim/testsuite/sim/sh/fldi0.s
-5fdca3286426034467b63b36d3a3c5e2  sim/testsuite/sim/sh/fldi1.s
-47831a2ea8e21901de14ee85de649e42  sim/testsuite/sim/sh/flds.s
-47a2df7f664eaff06846045d7e64b5ce  sim/testsuite/sim/sh/float.s
-04ba23f9a7e46a261c68dc833abac5a3  sim/testsuite/sim/sh/fmac.s
-6074ab626f6f749947d90dad804223a8  sim/testsuite/sim/sh/fmov.s
-c3b63bb6fbe1f996d7e66e6ed5ef9f32  sim/testsuite/sim/sh/fmul.s
-e548ee358487284309e5b5717cabf0f9  sim/testsuite/sim/sh/fneg.s
-0b43bcfde07c09c6103965070e9046ae  sim/testsuite/sim/sh/fpchg.s
-9b040b83149755d82c2328509c12535e  sim/testsuite/sim/sh/frchg.s
-2b09fe70d0d48f4cec2f1bd3d656928f  sim/testsuite/sim/sh/fsca.s
-cd42365d5bc0d1bb4979cdfd320ce433  sim/testsuite/sim/sh/fschg.s
-f5d3cc68031f17d500295fbcd18bb1f7  sim/testsuite/sim/sh/fsqrt.s
-b7ea335c1e85ef1fac26f071abdb2fac  sim/testsuite/sim/sh/fsrra.s
-92f8a202d1e874f537d74831851dba46  sim/testsuite/sim/sh/fsub.s
-ed2aa1abfc2026579333e2253c838294  sim/testsuite/sim/sh/ftrc.s
-b1d24d30151886ff5bf5bc86758709b1  sim/testsuite/sim/sh/ldrc.s
-954b6cdc60b0808db2732f2f65d65983  sim/testsuite/sim/sh/loop.s
-d0c8446d0ede1ebe79245b96cb002c8d  sim/testsuite/sim/sh/macl.s
-48d214fbad43f9efc8c0cc2014239984  sim/testsuite/sim/sh/macw.s
-ee7309424adcb28d1aabb8c418ef8930  sim/testsuite/sim/sh/mov.s
-bd7b8686162d8d1030ccd108eb48f610  sim/testsuite/sim/sh/movi.s
-b07d68ae2523ae371be0b115d5cc9253  sim/testsuite/sim/sh/movli.s
-50beb02380bc81e62c64158672183b61  sim/testsuite/sim/sh/movua.s
-0c12a523abb2532f2abb3eeeff95cfce  sim/testsuite/sim/sh/movxy.s
-c43420d54a7dd81d3ea55fbf72cd8d3e  sim/testsuite/sim/sh/mulr.s
-fcad598d555a1a24eaa76710c494e71b  sim/testsuite/sim/sh/pabs.s
-d8c8b220768728a015ad5b9fbb9d2c90  sim/testsuite/sim/sh/padd.s
-8f6a40a17e345540ee1f269d29aa5d9a  sim/testsuite/sim/sh/paddc.s
-be1710af076cee30f8262a7bef8685ab  sim/testsuite/sim/sh/pand.s
-849e99ce0f988f5329a7bf2d582cefd5  sim/testsuite/sim/sh/pass.s
-532a7fc5abd000fbfcdfa409da20f0fa  sim/testsuite/sim/sh/pclr.s
-4152aee3945ac6afc68b16dd206f851a  sim/testsuite/sim/sh/pdec.s
-c3726f7efa272c1305bc3a7ad9225e5b  sim/testsuite/sim/sh/pdmsb.s
-6ee03b6e9943d9a05f82c8206ce794cf  sim/testsuite/sim/sh/pinc.s
-e7a32d44b0b0d9d4309d241eaf991fcf  sim/testsuite/sim/sh/pmuls.s
-dc3cb25df84ca51ea42371f6a4dec6aa  sim/testsuite/sim/sh/prnd.s
-e8ca39483f9c71cfdb1b1b03069df2bc  sim/testsuite/sim/sh/pshai.s
-81c176582a8667af8f6c72a2728737ab  sim/testsuite/sim/sh/pshar.s
-1f420e9b6f74d6d03ae952bdffbd8799  sim/testsuite/sim/sh/pshli.s
-eed4f3e2827f2bdcff0fd693f4be62d0  sim/testsuite/sim/sh/pshlr.s
-698d502e8fcf6a8e8193fee2a1274e94  sim/testsuite/sim/sh/psub.s
-40b3372c773573dc611cbd9c64efa162  sim/testsuite/sim/sh/pswap.s
-1c367b6cd0a26caaab7382c8a4a40578  sim/testsuite/sim/sh/pushpop.s
-472229ecd10ac8f327137e22183f3e92  sim/testsuite/sim/sh/resbank.s
-73bee7558210c5db604fb0929091597e  sim/testsuite/sim/sh/sett.s
-19200c14eefed0db8e7e3f7b7df9a7da  sim/testsuite/sim/sh/shll.s
-c56c6a1871d8e035a8eb50e2c1cb89f0  sim/testsuite/sim/sh/shll16.s
-12c9ce87dbd160a77d59f6aa29ddd375  sim/testsuite/sim/sh/shll2.s
-bd6af3c86e2f58147320c9b2961781cd  sim/testsuite/sim/sh/shll8.s
-9c9f493d16eacff7f4315bd95a0c8b18  sim/testsuite/sim/sh/shlr.s
-f379912c20dda0ba7cd86cecc19eca47  sim/testsuite/sim/sh/shlr16.s
-ddfdbd007dc52a5ecc5e1981dc705462  sim/testsuite/sim/sh/shlr2.s
-eff7f8091a30f489f6cf9bb2c8aeac8d  sim/testsuite/sim/sh/shlr8.s
-5fb60364b4fd1e6b5d37ccdd4c3f4540  sim/testsuite/sim/sh/swap.s
-578530fadcb2c9974c7eb490be9a2aa7  sim/testsuite/sim/sh/testutils.inc
-decca393fdfc52cc877634004f343e3a  sim/testsuite/sim/sh64/ChangeLog
-6bd6f41965a7a151081da4fbde7ad141  sim/testsuite/sim/sh64/compact.exp
-afcc64d9020f7a6621b16c166d1822d1  sim/testsuite/sim/sh64/interwork.exp
-c08a7766568f6ff991184037e7b74b3b  sim/testsuite/sim/sh64/media.exp
-eaee678fb2a62c462d0ca02f3fec06f0  sim/testsuite/sim/sh64/compact/ChangeLog
-ca5039c0a9d247a7ad8a7838814c5a51  sim/testsuite/sim/sh64/compact/add.cgs
-736d9c94762c50c4ebb3873c5882ee6d  sim/testsuite/sim/sh64/compact/addc.cgs
-ac72602f6ed2aa1b241f5c8186b7620b  sim/testsuite/sim/sh64/compact/addi.cgs
-0750fb0a09062e6e3f445b1b5fae47f3  sim/testsuite/sim/sh64/compact/addv.cgs
-0da63009df7cc8ad207a3c904ea3c2fc  sim/testsuite/sim/sh64/compact/and.cgs
-9a9b6aaff790f813fc1d056ad729961f  sim/testsuite/sim/sh64/compact/andb.cgs
-e7022d3945429974472de5e5f3f64aef  sim/testsuite/sim/sh64/compact/andi.cgs
-91740f6d0a7b17e738a97aaf664236f6  sim/testsuite/sim/sh64/compact/bf.cgs
-f6cc357e0e59745b76d58dbcffe87f5f  sim/testsuite/sim/sh64/compact/bfs.cgs
-681d0be46e9f8b182c6a0cbdd6d552b8  sim/testsuite/sim/sh64/compact/bra.cgs
-1bfff6ec47572335250341667cdcfcca  sim/testsuite/sim/sh64/compact/braf.cgs
-7d7669ca1e8e51c376385782db7e4101  sim/testsuite/sim/sh64/compact/brk.cgs
-c601da6c1ba3e906262c28d268e3a58b  sim/testsuite/sim/sh64/compact/bsr.cgs
-ecd016b2d92587918211793c88ab7f69  sim/testsuite/sim/sh64/compact/bsrf.cgs
-6a7e70ef4397a49248108112489c5d6d  sim/testsuite/sim/sh64/compact/bt.cgs
-7c97c36a842284184ed5f0a5bcc23b15  sim/testsuite/sim/sh64/compact/bts.cgs
-3074493d5e04d18b722e379d0cf2a9c8  sim/testsuite/sim/sh64/compact/clrmac.cgs
-07eab8ef284eb295f7e90a098eb87cb2  sim/testsuite/sim/sh64/compact/clrs.cgs
-e1f0a305ba67b9bee68e5144a68a62b7  sim/testsuite/sim/sh64/compact/clrt.cgs
-e0053a70b797cc4fe77f657744cc4084  sim/testsuite/sim/sh64/compact/cmpeq.cgs
-1230586c0d499ad71af2171d5edefc05  sim/testsuite/sim/sh64/compact/cmpeqi.cgs
-2195ebca2557fdb8b9250b6f8119f3c5  sim/testsuite/sim/sh64/compact/cmpge.cgs
-4021dc4dbbb01ff98d3e4fce1ac56845  sim/testsuite/sim/sh64/compact/cmpgt.cgs
-23e954e4ce42ac0831bb431bc6030795  sim/testsuite/sim/sh64/compact/cmphi.cgs
-8c4ca5484616b0c99faaec2b1a829761  sim/testsuite/sim/sh64/compact/cmphs.cgs
-650a78db8b345ce1d2bbe46c3f6f1a8b  sim/testsuite/sim/sh64/compact/cmppl.cgs
-d4663e721d8f95bf5d516d8f2bef0e33  sim/testsuite/sim/sh64/compact/cmppz.cgs
-0625b2ce3e218d065741c215122dddf3  sim/testsuite/sim/sh64/compact/cmpstr.cgs
-a6043d2be7b79df9b7a06f2291a17048  sim/testsuite/sim/sh64/compact/div0s.cgs
-a83b93d213c6ae2251fd3edbcf5b848d  sim/testsuite/sim/sh64/compact/div0u.cgs
-dcc246daa7707392dbeda917c433dfbe  sim/testsuite/sim/sh64/compact/div1.cgs
-440e94cae3b5da94abc9b9d0ffdb8536  sim/testsuite/sim/sh64/compact/dmulsl.cgs
-3960a7b561d89b9c8bfff49df0d5cb13  sim/testsuite/sim/sh64/compact/dmulul.cgs
-b392c69b1d097f321a51487716ca2ac6  sim/testsuite/sim/sh64/compact/dt.cgs
-3755234f585da186aecb8e5d8283dfa6  sim/testsuite/sim/sh64/compact/extsb.cgs
-237f94b7d82bbe794dec21c82e39ac16  sim/testsuite/sim/sh64/compact/extsw.cgs
-911a98f008d4dcf1069a3024fce10c86  sim/testsuite/sim/sh64/compact/extub.cgs
-6cbb4415a81c454139b8dd84d836f5a3  sim/testsuite/sim/sh64/compact/extuw.cgs
-303f83bd4304f1318482a48817287855  sim/testsuite/sim/sh64/compact/fabs.cgs
-9d7e70aee614865172de0ca2019e009d  sim/testsuite/sim/sh64/compact/fadd.cgs
-b18559b12291b7aaf2d2116f2d9388a4  sim/testsuite/sim/sh64/compact/fcmpeq.cgs
-b8ee7c280ee7fd98b740210aa179733e  sim/testsuite/sim/sh64/compact/fcmpgt.cgs
-28323bad885035fa8e7bb5709fed8541  sim/testsuite/sim/sh64/compact/fcnvds.cgs
-ef60dd63fb8069bba5356daa6add3cf7  sim/testsuite/sim/sh64/compact/fcnvsd.cgs
-acf3b37669228c554574f0328cbded2e  sim/testsuite/sim/sh64/compact/fdiv.cgs
-e34dc396e58178682992a585b2ed6b60  sim/testsuite/sim/sh64/compact/fipr.cgs
-3ed23327fc2d63d69658bb695c3d7ff1  sim/testsuite/sim/sh64/compact/fldi0.cgs
-58a4b01f4f30a9b27b10f1b5e006ad74  sim/testsuite/sim/sh64/compact/fldi1.cgs
-7c0f2ee78bc85215e59468673d92a2d1  sim/testsuite/sim/sh64/compact/flds.cgs
-3a13e917c1c5044e74793695d101cc04  sim/testsuite/sim/sh64/compact/float.cgs
-210e09801402bfa631991b5694d7e456  sim/testsuite/sim/sh64/compact/fmac.cgs
-5bff71e04db76173db94a6f710321a3e  sim/testsuite/sim/sh64/compact/fmov.cgs
-744987cc3e82d9f65bd38dba8b94b722  sim/testsuite/sim/sh64/compact/fmul.cgs
-1039cb01c8b78cceef8ab514b90ea88e  sim/testsuite/sim/sh64/compact/fneg.cgs
-ee9aa5e3458c92acbe9ce8ce0a0a2ca2  sim/testsuite/sim/sh64/compact/frchg.cgs
-169370bb1837c9eb0637d793844367ce  sim/testsuite/sim/sh64/compact/fschg.cgs
-8bd60c5fdbda0679771e24aa4d119a84  sim/testsuite/sim/sh64/compact/fsqrt.cgs
-010401013cd6bfc3678a1a3543d3e160  sim/testsuite/sim/sh64/compact/fsts.cgs
-603557da5c50e246d6bc1e557a6c82f9  sim/testsuite/sim/sh64/compact/fsub.cgs
-819df15c8c0c437365a4a55311a1963d  sim/testsuite/sim/sh64/compact/ftrc.cgs
-e2beb2998f3e748874e58926c9bea9b5  sim/testsuite/sim/sh64/compact/ftrv.cgs
-3ff4b89901a61490263925c69da00c1f  sim/testsuite/sim/sh64/compact/jmp.cgs
-6dab94bfaf722b431ad195a2a4293b3d  sim/testsuite/sim/sh64/compact/jsr.cgs
-156851655fea4bdfd6c9677bcdfdb8a6  sim/testsuite/sim/sh64/compact/ldc-gbr.cgs
-a7d1bbe9c0cd6fc3791104baf80a6c22  sim/testsuite/sim/sh64/compact/ldcl-gbr.cgs
-e8172666d081fe5605c35aaad372b337  sim/testsuite/sim/sh64/compact/lds-fpscr.cgs
-1da8d79ce7382470915e3d896cf8bb53  sim/testsuite/sim/sh64/compact/lds-fpul.cgs
-5fd993753cd1d2e5ffa0225b24835161  sim/testsuite/sim/sh64/compact/lds-mach.cgs
-05a733d0240751b80661cfbf8613fe41  sim/testsuite/sim/sh64/compact/lds-macl.cgs
-1aae0513eb31849efab8069b6bb076ab  sim/testsuite/sim/sh64/compact/lds-pr.cgs
-c9e47e035d8047dbf66ceb7ec629ef55  sim/testsuite/sim/sh64/compact/ldsl-fpscr.cgs
-ec99ac48e2a44d9ceaee0a42ca9bef65  sim/testsuite/sim/sh64/compact/ldsl-fpul.cgs
-c5ddcb29af919e712d9195de10a38ad9  sim/testsuite/sim/sh64/compact/ldsl-mach.cgs
-41e9f6ee3d74b2de2deae8166453693a  sim/testsuite/sim/sh64/compact/ldsl-macl.cgs
-8715239f27b8d1960ebdb943d4e5d1a2  sim/testsuite/sim/sh64/compact/ldsl-pr.cgs
-fc724add45239cd526c1d256bc9b11f6  sim/testsuite/sim/sh64/compact/macl.cgs
-a0f6650b39bd08de4cd1725fcd49f868  sim/testsuite/sim/sh64/compact/macw.cgs
-760b6752e59d4567ccaa22144cf5bce6  sim/testsuite/sim/sh64/compact/mov.cgs
-d31249cc284a3c3d2a65235745684829  sim/testsuite/sim/sh64/compact/mova.cgs
-9db8c4c308050e1a094d14f01e40dea2  sim/testsuite/sim/sh64/compact/movb1.cgs
-54ef71450122a228ee56f451b232c8f7  sim/testsuite/sim/sh64/compact/movb10.cgs
-c560820cf73971bf5ad8d1c5e6d34bc2  sim/testsuite/sim/sh64/compact/movb2.cgs
-40549ff3237f5ddffefea6e712cf1aef  sim/testsuite/sim/sh64/compact/movb3.cgs
-d46aad4277c51016c3e2e655ccb04d68  sim/testsuite/sim/sh64/compact/movb4.cgs
-4ec2161356186cb5b58218ea64478d88  sim/testsuite/sim/sh64/compact/movb5.cgs
-565e1c190cf53eb313700574bb75c194  sim/testsuite/sim/sh64/compact/movb6.cgs
-63d652f8bd1167eebf0a01433061bda0  sim/testsuite/sim/sh64/compact/movb7.cgs
-57e6e7addeb114f34244ed0be0408db6  sim/testsuite/sim/sh64/compact/movb8.cgs
-3be59f32d1c642776228836b13ddea6d  sim/testsuite/sim/sh64/compact/movb9.cgs
-55b29cbb9b738f78888fd22e3e8ef172  sim/testsuite/sim/sh64/compact/movcal.cgs
-55ac8e9559a7ea47fdca66bef426da42  sim/testsuite/sim/sh64/compact/movi.cgs
-255d1a9a0a5100e86ddd3be3343fb2d7  sim/testsuite/sim/sh64/compact/movl1.cgs
-c7d45a6557c5fecb06d0953d401ec6e7  sim/testsuite/sim/sh64/compact/movl10.cgs
-e368063a7aee2ddb299b3ee59140b22d  sim/testsuite/sim/sh64/compact/movl11.cgs
-f7765b4706fe2583f09df8ca82774ee0  sim/testsuite/sim/sh64/compact/movl2.cgs
-d3accf8ea5099b4dffe8c67a34a5d4a0  sim/testsuite/sim/sh64/compact/movl3.cgs
-74ca11e119e6ff999a91c28f9dbd9d1a  sim/testsuite/sim/sh64/compact/movl4.cgs
-8c5d3b089d8d6e49fbcc8c985e0123a5  sim/testsuite/sim/sh64/compact/movl5.cgs
-4d88a6bb053bdb9f313cc9e44b3989de  sim/testsuite/sim/sh64/compact/movl6.cgs
-e0aaf9bc61e49ce27dd4d59aa5028430  sim/testsuite/sim/sh64/compact/movl7.cgs
-f7e5d3069f0a25c67f9dd87dba675de9  sim/testsuite/sim/sh64/compact/movl8.cgs
-e47937604ee7a5201268ec0803501b03  sim/testsuite/sim/sh64/compact/movl9.cgs
-873125ad7311a241f63dc14e6174fd73  sim/testsuite/sim/sh64/compact/movt.cgs
-02ad979dbb014a39cc96c1d468fb826d  sim/testsuite/sim/sh64/compact/movw1.cgs
-12e368bfea026db9f75001c7b9a072a6  sim/testsuite/sim/sh64/compact/movw10.cgs
-6b8c97ed1cd766ad0ebddb4cababdc9a  sim/testsuite/sim/sh64/compact/movw11.cgs
-7725779b79cbf00fe9b69189081668b8  sim/testsuite/sim/sh64/compact/movw2.cgs
-fc91f77b312fcd436accecf89f6fef0b  sim/testsuite/sim/sh64/compact/movw3.cgs
-d1bf11e1d56f7f101f57e498c318d058  sim/testsuite/sim/sh64/compact/movw4.cgs
-c44d851bd936d59d26ef94833a896ae2  sim/testsuite/sim/sh64/compact/movw5.cgs
-b412b8b1cba9c4f12b56e8f6d43addcd  sim/testsuite/sim/sh64/compact/movw6.cgs
-f6175c66bb0865e362d80b12d35b4e62  sim/testsuite/sim/sh64/compact/movw7.cgs
-15c13b8d1f8f07f3d8e220b6842cddc3  sim/testsuite/sim/sh64/compact/movw8.cgs
-6ae8403f0db6b164737220728121de32  sim/testsuite/sim/sh64/compact/movw9.cgs
-9d3c5e66f4dbe4445930df3ffe62e665  sim/testsuite/sim/sh64/compact/mull.cgs
-02ba94c0c4976e37c371221fece2ddf0  sim/testsuite/sim/sh64/compact/mulsw.cgs
-552613935856f5613d35b5a4c20b3300  sim/testsuite/sim/sh64/compact/muluw.cgs
-295e0ca6bc578ef653c993cab6ac10d7  sim/testsuite/sim/sh64/compact/neg.cgs
-3e0158a19a50735d50721a69c9fab7d2  sim/testsuite/sim/sh64/compact/negc.cgs
-32da06da3c217fa4db9f558533a350f2  sim/testsuite/sim/sh64/compact/nop.cgs
-c27b8d023bea7b97bd4e34e34d234996  sim/testsuite/sim/sh64/compact/not.cgs
-f41288943b1c077237eee8b1d8595f32  sim/testsuite/sim/sh64/compact/ocbi.cgs
-9805ed817520267b403266701b0aa2b4  sim/testsuite/sim/sh64/compact/ocbp.cgs
-ead7f7ae37ed28acb8fe9ca363446640  sim/testsuite/sim/sh64/compact/ocbwb.cgs
-11b9ddea67ef87692cad2ed3786a8b88  sim/testsuite/sim/sh64/compact/or.cgs
-2badb7a543131dacc5223bdc05bd29b0  sim/testsuite/sim/sh64/compact/orb.cgs
-88aabe91f30a2f4b660ac37395ed8129  sim/testsuite/sim/sh64/compact/ori.cgs
-ccfa2823c1f548e855ef34f0610c279b  sim/testsuite/sim/sh64/compact/pref.cgs
-779dc242c637f859b44a3f6b41d3b505  sim/testsuite/sim/sh64/compact/rotcl.cgs
-db52acf9cd33a8ea5ab7084c31b7a89e  sim/testsuite/sim/sh64/compact/rotcr.cgs
-b5dfa5e1a790085a09620c0c212b66b5  sim/testsuite/sim/sh64/compact/rotl.cgs
-da2ade69bdab794ce3205960172b31bc  sim/testsuite/sim/sh64/compact/rotr.cgs
-13ac597154fa151e3ce2d17689c7dedc  sim/testsuite/sim/sh64/compact/rts.cgs
-f0137811e6c67d782d837b61fbbb3bbe  sim/testsuite/sim/sh64/compact/sets.cgs
-719b877620e0e6689befdfa41fdbbaa3  sim/testsuite/sim/sh64/compact/sett.cgs
-cfd6dc4032d03f7f59178e637076b518  sim/testsuite/sim/sh64/compact/shad.cgs
-aa7790e772f6f7f2ac8a483217e5e7f0  sim/testsuite/sim/sh64/compact/shal.cgs
-bef3697eee05ff945b53aa5953f833b7  sim/testsuite/sim/sh64/compact/shar.cgs
-5c71a3bb3ec9f16d0775cd9b7cc745a8  sim/testsuite/sim/sh64/compact/shld.cgs
-9a06f5824ff0496eb4cc281f036d6bf4  sim/testsuite/sim/sh64/compact/shll.cgs
-4e91b28cf642cde4e656ed0b7e771c26  sim/testsuite/sim/sh64/compact/shll16.cgs
-51493b43a58400a838ed217c7603c5e1  sim/testsuite/sim/sh64/compact/shll2.cgs
-44310b0f1be5895cbbcb6aadf0c8c432  sim/testsuite/sim/sh64/compact/shll8.cgs
-e55068ccbd32488af870d2b89de9000f  sim/testsuite/sim/sh64/compact/shlr.cgs
-1221053b1727f1610e1c810173d2717b  sim/testsuite/sim/sh64/compact/shlr16.cgs
-690b915e479fd620957e41cc04da0f4f  sim/testsuite/sim/sh64/compact/shlr2.cgs
-cbbb7a0b67cfed8979f2802caba20514  sim/testsuite/sim/sh64/compact/shlr8.cgs
-46158c951c41f5cc472de87a41b67b3a  sim/testsuite/sim/sh64/compact/stc-gbr.cgs
-3098a4bf21b00d4c423b39d02909fcb3  sim/testsuite/sim/sh64/compact/stcl-gbr.cgs
-31122c9a09fb41e1767cb1ec56bf3059  sim/testsuite/sim/sh64/compact/sts-fpscr.cgs
-549a3e3cd3e0bbc0904ebc8c7d05a627  sim/testsuite/sim/sh64/compact/sts-fpul.cgs
-c56640f728d4b715e573a22fb5832a81  sim/testsuite/sim/sh64/compact/sts-mach.cgs
-9e9399ae453003f6abca6e2e68613278  sim/testsuite/sim/sh64/compact/sts-macl.cgs
-ce7833e00e1dbffdad8551457da869e9  sim/testsuite/sim/sh64/compact/sts-pr.cgs
-0f56a0c25e45a9de365c44e105bd1481  sim/testsuite/sim/sh64/compact/stsl-fpscr.cgs
-dcfb8af4205710d4ba72426b92d3c58d  sim/testsuite/sim/sh64/compact/stsl-fpul.cgs
-ffda35e809cf16b541e191c13caced95  sim/testsuite/sim/sh64/compact/stsl-mach.cgs
-5b1abceab332756d9e7ad22a1e837553  sim/testsuite/sim/sh64/compact/stsl-macl.cgs
-fd3ea9fd7e5a18185841283340755b0e  sim/testsuite/sim/sh64/compact/stsl-pr.cgs
-ab062a29839df00af15600e6ec555da0  sim/testsuite/sim/sh64/compact/sub.cgs
-a754ffb66032fcfe09d1d0190470afc6  sim/testsuite/sim/sh64/compact/subc.cgs
-a95f07f642bd3ee43a82fe939e19e639  sim/testsuite/sim/sh64/compact/subv.cgs
-8ef35680e34836bb65e0930876d5c052  sim/testsuite/sim/sh64/compact/swapb.cgs
-d5a01716385fce773d06295c1f926f2c  sim/testsuite/sim/sh64/compact/swapw.cgs
-fb3d330172050e46fbd98d776f49aad8  sim/testsuite/sim/sh64/compact/tasb.cgs
-b6ea8a4bfb234524293e2c0f09ed4d98  sim/testsuite/sim/sh64/compact/testutils.inc
-4ec324a6ea217bdf129f4579e7ac1e15  sim/testsuite/sim/sh64/compact/trapa.cgs
-e6dcbfec9f39d518b57c7a06b972cf10  sim/testsuite/sim/sh64/compact/tst.cgs
-683efdfba958a7fa3cf9f8e8fe4a740a  sim/testsuite/sim/sh64/compact/tstb.cgs
-b79bdae0d7c852932a299b669c623c7e  sim/testsuite/sim/sh64/compact/tsti.cgs
-c117ffebe50a4c564bd752511a72f834  sim/testsuite/sim/sh64/compact/xor.cgs
-e07fd593d0da1177a76a264a46e0f41c  sim/testsuite/sim/sh64/compact/xorb.cgs
-c4960e4d2e53ddd17aab483fceae60aa  sim/testsuite/sim/sh64/compact/xori.cgs
-e26665c1228526221c579dc239760f0a  sim/testsuite/sim/sh64/compact/xtrct.cgs
-6a647e424464d48a834d1ef9c048299b  sim/testsuite/sim/sh64/media/ChangeLog
-2c0b29bcb551599cf28f6b48000072ae  sim/testsuite/sim/sh64/media/add.cgs
-c558d2c812f1c91198f6d6068eea2725  sim/testsuite/sim/sh64/media/addi.cgs
-d9d562eac1c48a96eabfeb3312a9be90  sim/testsuite/sim/sh64/media/addil.cgs
-a87d593dbc890eec83f06331f8d76c8a  sim/testsuite/sim/sh64/media/addl.cgs
-76ce8603b52a63abe0fb9369079ad534  sim/testsuite/sim/sh64/media/addzl.cgs
-e56cbd032ad31c5a525ee3045994d047  sim/testsuite/sim/sh64/media/alloco.cgs
-ce0f10a7cb56824949015bf881061997  sim/testsuite/sim/sh64/media/and.cgs
-00d6a437f0b11e7790cc6597fae337bf  sim/testsuite/sim/sh64/media/andc.cgs
-778e7888e0d816fca810990d862c3079  sim/testsuite/sim/sh64/media/andi.cgs
-0a582efef90b421fe20d1bfdb783f8c7  sim/testsuite/sim/sh64/media/beq.cgs
-ce29ea2284e05c7ce8ec675ef12e6685  sim/testsuite/sim/sh64/media/beqi.cgs
-c4e169c36ce16958d300c0361693e173  sim/testsuite/sim/sh64/media/bge.cgs
-2bbc457c0f5aefe554ccba990057dba7  sim/testsuite/sim/sh64/media/bgeu.cgs
-37d51372abfbec0fa574f1b6cdc846b0  sim/testsuite/sim/sh64/media/bgt.cgs
-99ea415b174e6031eac2f0ab762b9a33  sim/testsuite/sim/sh64/media/bgtu.cgs
-643c1e48c75384c5ab4b3f4e291e82e8  sim/testsuite/sim/sh64/media/blink.cgs
-eafa3e6055c2543e8f65baedc5f32801  sim/testsuite/sim/sh64/media/bne.cgs
-807adf144f3a47e85a751a3fbdf81a4d  sim/testsuite/sim/sh64/media/bnei.cgs
-92ae194f7d1cd53869b9afb9028cb10d  sim/testsuite/sim/sh64/media/brk.cgs
-d4bbc2e9533fe235007b502910bbfa3f  sim/testsuite/sim/sh64/media/byterev.cgs
-3a032628732b41bf067fc8e55428a58f  sim/testsuite/sim/sh64/media/cmpeq.cgs
-f497d819ffd67cdb06d419d8c5532b61  sim/testsuite/sim/sh64/media/cmpgt.cgs
-6e7e8abec6fdf76c85011c31cec690a7  sim/testsuite/sim/sh64/media/cmpgtu.cgs
-6abc9a1bb9042f67a6ee425481074a31  sim/testsuite/sim/sh64/media/cmveq.cgs
-c5bb9661c37857bd3f7cdfb9179e9fb8  sim/testsuite/sim/sh64/media/cmvne.cgs
-2256ec480546564403fd17e1f7feaf13  sim/testsuite/sim/sh64/media/fabsd.cgs
-c8f57ef77ae3417d83d696eb539b0e46  sim/testsuite/sim/sh64/media/fabss.cgs
-060fe31b0b91c1e980dffb585566d27e  sim/testsuite/sim/sh64/media/faddd.cgs
-d3dea74ed66e7d66666846d8662d7894  sim/testsuite/sim/sh64/media/fadds.cgs
-2a5f3da39bcd6bfafb792116fc4ff2b1  sim/testsuite/sim/sh64/media/fcmpeqd.cgs
-6f75489c9cc1d58e403d5af0b1585546  sim/testsuite/sim/sh64/media/fcmpeqs.cgs
-a94ff86eb306dfb576126b8b3c0f223c  sim/testsuite/sim/sh64/media/fcmpged.cgs
-66ba4dba51dbcfd5e8ce7d52167b2d5e  sim/testsuite/sim/sh64/media/fcmpges.cgs
-7117be89bbc1032da057d26206ce199b  sim/testsuite/sim/sh64/media/fcmpgtd.cgs
-7affc0c1042b3480f375846d1088c308  sim/testsuite/sim/sh64/media/fcmpgts.cgs
-a8aeb11eef57d970015fcb23cdc873c9  sim/testsuite/sim/sh64/media/fcmpund.cgs
-ee7b2737ae885b341a7efaf393fc4d79  sim/testsuite/sim/sh64/media/fcmpuns.cgs
-4a6666bfe33a68a30aa8b487c325063f  sim/testsuite/sim/sh64/media/fcnvds.cgs
-8b62b811fb18205ad65b8ee8b48f952d  sim/testsuite/sim/sh64/media/fcnvsd.cgs
-e4a1d1c976a76f6c44da4be44a1a1641  sim/testsuite/sim/sh64/media/fdivd.cgs
-29a19726c0af365c1c808e54477cdb95  sim/testsuite/sim/sh64/media/fdivs.cgs
-50c4325ed80bd0ac6d352c3452716257  sim/testsuite/sim/sh64/media/fgetscr.cgs
-859954c33155265599f610ff0ec6422e  sim/testsuite/sim/sh64/media/fiprs.cgs
-345f5eb194aa5c826b88db7a1de4a0ce  sim/testsuite/sim/sh64/media/fldd.cgs
-195734136941d8fb6caf1205014b0897  sim/testsuite/sim/sh64/media/fldp.cgs
-98b6d40ed29f302fc82899263174356d  sim/testsuite/sim/sh64/media/flds.cgs
-b67275a90edc901353d572658789a302  sim/testsuite/sim/sh64/media/fldxd.cgs
-77310578036150b882882fb79cbc7dda  sim/testsuite/sim/sh64/media/fldxp.cgs
-47dc7daa584ec04b01ff797dcad4e32a  sim/testsuite/sim/sh64/media/fldxs.cgs
-23464a5f4245f44835e719135142e31e  sim/testsuite/sim/sh64/media/floatld.cgs
-2d56e3709203765268b33b31906e803f  sim/testsuite/sim/sh64/media/floatls.cgs
-f01c762582353e21851eb14c043b3c31  sim/testsuite/sim/sh64/media/floatqd.cgs
-1b202c7029eea6ae864dfe5a3526b70f  sim/testsuite/sim/sh64/media/floatqs.cgs
-4dac27f822f1416c682a23804e448ca4  sim/testsuite/sim/sh64/media/fmacs.cgs
-5d24af2add6ccdc400d0ca6c052ef72e  sim/testsuite/sim/sh64/media/fmovd.cgs
-375ad3205c51531607c0be84338a8293  sim/testsuite/sim/sh64/media/fmovdq.cgs
-9f1276774332e1c55f90fa3566180d4e  sim/testsuite/sim/sh64/media/fmovls.cgs
-e7ca7125935973bb37ffc2a9c6152024  sim/testsuite/sim/sh64/media/fmovqd.cgs
-1bdc45e1c74cf1262943cb1902a69f5e  sim/testsuite/sim/sh64/media/fmovs.cgs
-3b5b24ec8e109174b008f3908a2c3607  sim/testsuite/sim/sh64/media/fmovsl.cgs
-f655bef64291e78aab1635993ffd3079  sim/testsuite/sim/sh64/media/fmuld.cgs
-9ae3b61a99198960f4baf5d7f79eff88  sim/testsuite/sim/sh64/media/fmuls.cgs
-f9c22dc6393acac0d0e20eb95685035b  sim/testsuite/sim/sh64/media/fnegd.cgs
-591776a8c46e7ca2b29f29c335b32133  sim/testsuite/sim/sh64/media/fnegs.cgs
-91bc8cd1e2117278e49fb4369e00a372  sim/testsuite/sim/sh64/media/fputscr.cgs
-bfb8f066c4e3a9fa294d95b1ff5e78b1  sim/testsuite/sim/sh64/media/fsqrtd.cgs
-7a68dce6ffd80eaee6d187d5d580d8ed  sim/testsuite/sim/sh64/media/fsqrts.cgs
-2bfa24643c3c0250dbde10b3770b7118  sim/testsuite/sim/sh64/media/fstd.cgs
-3e6f232a2c931cb40855a33538905c21  sim/testsuite/sim/sh64/media/fstp.cgs
-707d21183c4b9916a479978b34b839d6  sim/testsuite/sim/sh64/media/fsts.cgs
-2125ef6a28e6c0f847f0f24dbda15562  sim/testsuite/sim/sh64/media/fstxd.cgs
-f930d359669ba95252537dc37fceb444  sim/testsuite/sim/sh64/media/fstxp.cgs
-3efa232854d2fbb0982ebb618ef82f0b  sim/testsuite/sim/sh64/media/fstxs.cgs
-8a8867591c6f0aa6e52a581f3dc7590e  sim/testsuite/sim/sh64/media/fsubd.cgs
-3e7645d763248e43608d4c24d001c9de  sim/testsuite/sim/sh64/media/fsubs.cgs
-561b1a31d5e4d4e4e0f6a176555fd4df  sim/testsuite/sim/sh64/media/ftrcdl.cgs
-52fcbfeca5b4d265b2970475cb256d00  sim/testsuite/sim/sh64/media/ftrcdq.cgs
-9f29c4e3990574afbd44cf2d011e147d  sim/testsuite/sim/sh64/media/ftrcsl.cgs
-8d80fa1d953ab1e454a27359d807595d  sim/testsuite/sim/sh64/media/ftrcsq.cgs
-baba1b97037672cf15d5541ddb5708fd  sim/testsuite/sim/sh64/media/ftrvs.cgs
-b2bdbbe496e858ffc42260510e2dc993  sim/testsuite/sim/sh64/media/getcfg.cgs
-6de85c4710700f4ac394cd6d5dab41ff  sim/testsuite/sim/sh64/media/getcon.cgs
-d681d96dee07b47d57f5ad2bf069957a  sim/testsuite/sim/sh64/media/gettr.cgs
-31ec08556e5b415245abbadcfabee29e  sim/testsuite/sim/sh64/media/icbi.cgs
-0c99b37c2d5eb483c839970bc7ad5700  sim/testsuite/sim/sh64/media/ldb.cgs
-43da021fc1670aff713af73672325c22  sim/testsuite/sim/sh64/media/ldhil.cgs
-1ec9b9915f998b1b5527affbb7b1165f  sim/testsuite/sim/sh64/media/ldhiq.cgs
-ff9be75f4b2823203b287462284b9d23  sim/testsuite/sim/sh64/media/ldl.cgs
-a887a2e5c5042c1cbf4ede41a2ad2aa2  sim/testsuite/sim/sh64/media/ldlol.cgs
-448e41e7a622846e9addd4d68e6dee7b  sim/testsuite/sim/sh64/media/ldloq.cgs
-0a9f54bea7db5d7a96c8479741aae579  sim/testsuite/sim/sh64/media/ldq.cgs
-2689c29380eaa34c757659ba53238d99  sim/testsuite/sim/sh64/media/ldub.cgs
-8223facc3f2040620addb77d76f86d55  sim/testsuite/sim/sh64/media/lduw.cgs
-14efb3c2d768492a71c1b73ab45b4b6d  sim/testsuite/sim/sh64/media/ldw.cgs
-e5ca6ed82dcec1c3b3b7dec680899688  sim/testsuite/sim/sh64/media/ldxb.cgs
-3f17073ba8c0fff8779af811a37c52f9  sim/testsuite/sim/sh64/media/ldxl.cgs
-ea2ef003c1205b0eaf9616c6fd309583  sim/testsuite/sim/sh64/media/ldxq.cgs
-fe5424e3a2ca59f5ad6df0c201b21a4d  sim/testsuite/sim/sh64/media/ldxub.cgs
-318c032459429b25629474531630cee8  sim/testsuite/sim/sh64/media/ldxuw.cgs
-8fe5277c40cde0884fb2e6eac0566167  sim/testsuite/sim/sh64/media/ldxw.cgs
-278918f6f143cad554024e0210cc1bcb  sim/testsuite/sim/sh64/media/mabsl.cgs
-c2b9bf3da80b4223ff83c8c4b2ebca91  sim/testsuite/sim/sh64/media/mabsw.cgs
-b4187964e5978a86eb1382b481447028  sim/testsuite/sim/sh64/media/maddl.cgs
-86ec4698affdaef7978529e10ec47617  sim/testsuite/sim/sh64/media/maddsl.cgs
-5ca6131f741869214aa684d39676d3f0  sim/testsuite/sim/sh64/media/maddsub.cgs
-3ed34a15eb4567f07e0d7998bfe6ec44  sim/testsuite/sim/sh64/media/maddsw.cgs
-deead7f9a94cdaa5efca9f477936761a  sim/testsuite/sim/sh64/media/maddw.cgs
-dd423bee72982fb8c4827535ac0ab3b3  sim/testsuite/sim/sh64/media/mcmpeqb.cgs
-1f02888e70c1cd3e489b0353dda7a199  sim/testsuite/sim/sh64/media/mcmpeql.cgs
-3f13e9adb83f9e617c3ae06db46dcf51  sim/testsuite/sim/sh64/media/mcmpeqw.cgs
-f3f39418b846d6c792e447b0f8102c4b  sim/testsuite/sim/sh64/media/mcmpgtl.cgs
-0fff48c19adde0f7cc4bc15a70a8060b  sim/testsuite/sim/sh64/media/mcmpgtub.cgs
-43a72115a4c49186f8b57a24c747ada9  sim/testsuite/sim/sh64/media/mcmpgtw.cgs
-5a2c9d43d6603f1d1a15f279726aeabc  sim/testsuite/sim/sh64/media/mcmv.cgs
-46c7c9f0d50e3c8c05193849f0f15ee1  sim/testsuite/sim/sh64/media/mcnvslw.cgs
-ab4d95bbe89732a06b5629d36153ff5c  sim/testsuite/sim/sh64/media/mcnvswb.cgs
-238e6fb75904bbf9348ee2e178d02018  sim/testsuite/sim/sh64/media/mcnvswub.cgs
-6a9d2a6855f7661bc838501f1bae5ece  sim/testsuite/sim/sh64/media/mextr1.cgs
-879792361ec250133544683585ebc541  sim/testsuite/sim/sh64/media/mextr2.cgs
-9046090d0a1e4603256bcce96b4cb48f  sim/testsuite/sim/sh64/media/mextr3.cgs
-96720e079b2b534d21eb7f17806d9861  sim/testsuite/sim/sh64/media/mextr4.cgs
-cc6dd7c9f7ffbcc8459556677381b6af  sim/testsuite/sim/sh64/media/mextr5.cgs
-0d2871b1ddc8be351bde323f7de57d24  sim/testsuite/sim/sh64/media/mextr6.cgs
-facfd3bbc0f3ffa3aa6d48ea038660c6  sim/testsuite/sim/sh64/media/mextr7.cgs
-457e3b142accbbc0a3b034e36c8f64e8  sim/testsuite/sim/sh64/media/mmacfxwl.cgs
-576279c2b9b6bacac9c42b1b62ff5ff1  sim/testsuite/sim/sh64/media/mmacnfx-wl.cgs
-07ab156f6646ae2dba70f1c3dafa0bfe  sim/testsuite/sim/sh64/media/mmulfxl.cgs
-f9d1afdf821e290491aff9e12a393afe  sim/testsuite/sim/sh64/media/mmulfxrpw.cgs
-279f2287e09d42fcf95bb6c7c1954668  sim/testsuite/sim/sh64/media/mmulfxw.cgs
-24ac3e05cd975a2c74e937d973dfec18  sim/testsuite/sim/sh64/media/mmulhiwl.cgs
-18cb207fe0e147495b61871bf8a7d6aa  sim/testsuite/sim/sh64/media/mmull.cgs
-75952ee791e76e8cda1902983af57c15  sim/testsuite/sim/sh64/media/mmullowl.cgs
-ab92faebe155f396230755fbbcc7e336  sim/testsuite/sim/sh64/media/mmulsumwq.cgs
-e75c17ddd7eead085e92062b91f900d3  sim/testsuite/sim/sh64/media/mmulw.cgs
-4bb19ac27e630b3ce15dbda8c9757706  sim/testsuite/sim/sh64/media/movi.cgs
-1b1156080c657abb802fa1d024d698d3  sim/testsuite/sim/sh64/media/mpermw.cgs
-c58ca1dc2b7e7397f3f91d84a9c92283  sim/testsuite/sim/sh64/media/msadubq.cgs
-9a5ee455cb4fe7cd30c6e6a13940334a  sim/testsuite/sim/sh64/media/mshaldsl.cgs
-78774529723f51dfef3452f15cacb32a  sim/testsuite/sim/sh64/media/mshaldsw.cgs
-b55bb3005484f5d786afbad9d233811d  sim/testsuite/sim/sh64/media/mshardl.cgs
-fc7b9962b7a23eb5ee130ec9e5b48ffc  sim/testsuite/sim/sh64/media/mshardsq.cgs
-1d0b03597f3929efda09843cf25a1921  sim/testsuite/sim/sh64/media/mshardw.cgs
-e19406336e30c7c1553789123c77be83  sim/testsuite/sim/sh64/media/mshfhib.cgs
-b3c90f618cbdfb2c768d43a47849a3f1  sim/testsuite/sim/sh64/media/mshfhil.cgs
-32ef81f8563b99aa0f92d9b6bce16e51  sim/testsuite/sim/sh64/media/mshfhiw.cgs
-7b5796c6e56c76eedf4d548bb9379f02  sim/testsuite/sim/sh64/media/mshflob.cgs
-c2d384a77172e147e10faa7f98596989  sim/testsuite/sim/sh64/media/mshflol.cgs
-e2c9ca9508255faa5208d3cf788fb80d  sim/testsuite/sim/sh64/media/mshflow.cgs
-4435d87997b90b8430843386079f71a7  sim/testsuite/sim/sh64/media/mshlldl.cgs
-3f15d00cd31419a7ad8c1e08b9f7f5ea  sim/testsuite/sim/sh64/media/mshlldw.cgs
-3a931dfcf601cfdcc15e178ecc1266df  sim/testsuite/sim/sh64/media/mshlrdl.cgs
-74ed9f945ee0bcee562f5615646df4d9  sim/testsuite/sim/sh64/media/mshlrdw.cgs
-a67e8dfae6fe1dbbc27e3ff8408aa429  sim/testsuite/sim/sh64/media/msubl.cgs
-bc4ef44f68a9bfaa0027d5a03d5fe2e0  sim/testsuite/sim/sh64/media/msubsl.cgs
-e920fecc1d427f295341a44f501ae32e  sim/testsuite/sim/sh64/media/msubsub.cgs
-810a402ce7c0fc8c479ed93abe3f7cc4  sim/testsuite/sim/sh64/media/msubsw.cgs
-d25a0a7d3f6e6b2b59f5be8b583cec10  sim/testsuite/sim/sh64/media/msubw.cgs
-a54372d652695a1a6bd199405298e096  sim/testsuite/sim/sh64/media/mulsl.cgs
-728ae0c771c2eb97bf7e1ecdb6c77ad8  sim/testsuite/sim/sh64/media/mulul.cgs
-ea0a6f5053f4682afc6015dcb356b316  sim/testsuite/sim/sh64/media/nop.cgs
-f26ca0c3df6a34480e27e9d7f45b5cb4  sim/testsuite/sim/sh64/media/nsb.cgs
-482de020e815e2991e183a8e12caa476  sim/testsuite/sim/sh64/media/ocbi.cgs
-0f495f99619adbcf8313fdc7ce9380ae  sim/testsuite/sim/sh64/media/ocbp.cgs
-9739bce3941d9fb8347f1c0c90ae5228  sim/testsuite/sim/sh64/media/ocbwb.cgs
-2c84a234f6763a20fe6a6d937974217f  sim/testsuite/sim/sh64/media/or.cgs
-0f29f0219eabcc98ab8c3d4eb9050824  sim/testsuite/sim/sh64/media/ori.cgs
-0ee1f1d000b8d348aebc3cd0deca0686  sim/testsuite/sim/sh64/media/prefi.cgs
-72202c9df10988ee0ab14e200469e5de  sim/testsuite/sim/sh64/media/pta.cgs
-fb4facb88f4269ce1a69e52f4a331022  sim/testsuite/sim/sh64/media/ptabs.cgs
-0ecaa2df7dbd6ac20bbbff648091c1c6  sim/testsuite/sim/sh64/media/ptb.cgs
-b726b030a39b5e8d03179506ea8bbed3  sim/testsuite/sim/sh64/media/ptrel.cgs
-35153e02665b95e1a018851d7e198045  sim/testsuite/sim/sh64/media/putcfg.cgs
-449078d68b16532a731bd08e9e996205  sim/testsuite/sim/sh64/media/putcon.cgs
-ba1d30bad41e82950e1ec4da5068a80e  sim/testsuite/sim/sh64/media/rte.cgs
-acad0b474344fe9bb10aed735b08462a  sim/testsuite/sim/sh64/media/shard.cgs
-a4c69037e69000c2bfea4927c16a7730  sim/testsuite/sim/sh64/media/shardl.cgs
-2d7c997ff0d4c0062704b5553a0eaa6c  sim/testsuite/sim/sh64/media/shari.cgs
-bb522dd2216512dac666e8a54d932a50  sim/testsuite/sim/sh64/media/sharil.cgs
-b0332c26af82f6508597ec86b7043290  sim/testsuite/sim/sh64/media/shlld.cgs
-2a329964d8e276bc4a1e463638078929  sim/testsuite/sim/sh64/media/shlldl.cgs
-a900893a600e8c7b36249f092bd3af97  sim/testsuite/sim/sh64/media/shlli.cgs
-46780ec90276865e100a33aee7da7b91  sim/testsuite/sim/sh64/media/shllil.cgs
-8eaa1c1a294f08a0f0cc11704dc6a6c9  sim/testsuite/sim/sh64/media/shlrd.cgs
-b31ffed1b6c63faace71bae9f2946574  sim/testsuite/sim/sh64/media/shlrdl.cgs
-9b68cc2fd9580f39a3658becb2e21782  sim/testsuite/sim/sh64/media/shlri.cgs
-4921484170b87924852f0d16d2759c7e  sim/testsuite/sim/sh64/media/shlril.cgs
-3b94178fb469c2f76fcb5943c7be6e35  sim/testsuite/sim/sh64/media/shori.cgs
-a21ff91fdfbca28f8b47ffaa5142b0e5  sim/testsuite/sim/sh64/media/sleep.cgs
-6950be0c56405f87f1baa0cea84bb971  sim/testsuite/sim/sh64/media/stb.cgs
-136dec63d822deaaa78a52ebdab53d7f  sim/testsuite/sim/sh64/media/sthil.cgs
-8d100290db53ee7eefeaebd1c7b7dd62  sim/testsuite/sim/sh64/media/sthiq.cgs
-340ee385a6e0296dac7fcfb26d67a1f8  sim/testsuite/sim/sh64/media/stl.cgs
-57087427364f7d03b1966470f81ae64c  sim/testsuite/sim/sh64/media/stlol.cgs
-a010a7dc4864a1d3d16bd18de1cad548  sim/testsuite/sim/sh64/media/stloq.cgs
-e0311adbd968c1a70fbb040b187d84f2  sim/testsuite/sim/sh64/media/stq.cgs
-77b4b0f77af5b81bf2bad3907598356e  sim/testsuite/sim/sh64/media/stw.cgs
-3c138bfeb6f5c6f2192ef864881a8efe  sim/testsuite/sim/sh64/media/stxb.cgs
-7cb6bfcf9b1c8c998133ae9576b408aa  sim/testsuite/sim/sh64/media/stxl.cgs
-fd0765d429901be2d95147ad6de4d3f4  sim/testsuite/sim/sh64/media/stxq.cgs
-f08ebb545f8b741f8182f40123abb0a8  sim/testsuite/sim/sh64/media/stxw.cgs
-602ba68059df6645c442484e37707ccb  sim/testsuite/sim/sh64/media/sub.cgs
-5f32595b1e5308db437c208779156652  sim/testsuite/sim/sh64/media/subl.cgs
-ef21755ea68237459f25c4316a3a4d16  sim/testsuite/sim/sh64/media/swapq.cgs
-4e767dee4b103e6b05d871dc1131598b  sim/testsuite/sim/sh64/media/synci.cgs
-88a17b7a509b166a9245dadb200c3318  sim/testsuite/sim/sh64/media/synco.cgs
-ad28f968a1d98c2efb00d8fd9b4bc680  sim/testsuite/sim/sh64/media/testutils.inc
-15b0cc0d16a86186e5b427915152b48e  sim/testsuite/sim/sh64/media/trapa.cgs
-30c62b03976f8ab78b8fac6daf4c2fdc  sim/testsuite/sim/sh64/media/xor.cgs
-9bbc7190782eedf13e1e86c251c73679  sim/testsuite/sim/sh64/media/xori.cgs
-66f3cbc997f2e5c7d7fdddec7391416a  sim/testsuite/sim/sh64/misc/fr-dr.s
-728bb384853e3de0cd850ba77dbb94f9  sim/testsuite/sim/v850/allinsns.exp
-cdd524c11367ecd095b2fb68cda24cee  sim/testsuite/sim/v850/bsh.cgs
-176f95658c3cdea072a56a08a40fa988  sim/testsuite/sim/v850/div.cgs
-a0299a77158639743570f62da83ce9d5  sim/testsuite/sim/v850/divh.cgs
-8c015488bd973b121a5372038ddde9da  sim/testsuite/sim/v850/divh_3.cgs
-53eb912651c13f0ea8aa537a0e00d398  sim/testsuite/sim/v850/divhu.cgs
-4aded6a92b79c4b62204838e8bf43bdb  sim/testsuite/sim/v850/divu.cgs
-c5f8f5f2c95cb9061411969f8552bd60  sim/testsuite/sim/v850/sar.cgs
-d219d0a7ebfd715328670f348f6fc8cc  sim/testsuite/sim/v850/satadd.cgs
-6f74fc62171d7544adce8e548b696d3d  sim/testsuite/sim/v850/satsub.cgs
-5e49b4ee9bfac127867261aab49d5301  sim/testsuite/sim/v850/satsubi.cgs
-cf2074aef14997231161787d82280ce2  sim/testsuite/sim/v850/satsubr.cgs
-b4859f29935e5b217a201e3996ef936e  sim/testsuite/sim/v850/shl.cgs
-4e33f6ab389381ede55a4ca40ca14064  sim/testsuite/sim/v850/shr.cgs
-a7fde5e930bcca4fab473e7e12a4cd30  sim/testsuite/sim/v850/testutils.cgs
-c5cadbab939f31f2815550c2e1bc4ff4  sim/testsuite/sim/v850/testutils.inc
-639a937f616a677a98a8ddf18fc3607c  sim/v850/ChangeLog
-c316d5fe170c968577a446aa82ce7538  sim/v850/Makefile.in
-6382b4fa97b8c3f6b0d124a39da830ad  sim/v850/config.in
-94cebfe85675fd3d01a53efd1c534794  sim/v850/configure
-fc66e8f040164ad8eab57450896051ce  sim/v850/configure.ac
-d8b6b349332fde351e242d3735926144  sim/v850/interp.c
-5c6de75cf871f9762d4a7c341dcd4afc  sim/v850/sim-main.h
-1d53053ce57ce78a8ac933a1c2a77813  sim/v850/simops.c
-bee4a6a9ecb7e78bab13c75961a998e9  sim/v850/simops.h
-61a55a15e7ef4e104adb33aaa7f55b66  sim/v850/v850-dc
-ca25d8e9c3513185f71aeacb4580e9df  sim/v850/v850.igen
-ec996f52079c4afb02cb86bdd2fd188f  sim/v850/v850_sim.h
-3980d700a203de24ac4af24ce795b148  src-release
-cf2baa0854f564a7785307e79f155efc  symlink-tree
-b97f1c282c19b00608b1680ad02ae227  texinfo/texinfo.tex
-e0a5f7e59d19edfd4b4d26479a141f02  ylwrap
diff -Naur gdb-6.8/opcodes/ChangeLog.sts-gdb stsgdb-6.8/opcodes/ChangeLog.sts-gdb
--- gdb-6.8/opcodes/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/opcodes/ChangeLog.sts-gdb	2008-09-11 10:35:41.000000000 +0100
@@ -0,0 +1,4 @@
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-opc.h: Add st40-300 variants.
+	* sh-dis.c: Likewise.
diff -Naur gdb-6.8/opcodes/sh-dis.c stsgdb-6.8/opcodes/sh-dis.c
--- gdb-6.8/opcodes/sh-dis.c	2007-07-05 10:49:02.000000000 +0100
+++ stsgdb-6.8/opcodes/sh-dis.c	2008-09-11 10:35:41.000000000 +0100
@@ -1,6 +1,7 @@
 /* Disassemble SH instructions.
    Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
    2007  Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of the GNU opcodes library.
 
@@ -692,6 +693,15 @@
 	    case A_R0:
 	      fprintf_fn (stream, "r0");
 	      break;
+	    case A_R1:
+	      fprintf_fn (stream, "r1");
+	      break;
+	    case A_R2:
+	      fprintf_fn (stream, "r2");
+	      break;
+	    case A_R3:
+	      fprintf_fn (stream, "r3");
+	      break;
 	    case A_REG_N:
 	      fprintf_fn (stream, "r%d", rn);
 	      break;
diff -Naur gdb-6.8/opcodes/sh-opc.h stsgdb-6.8/opcodes/sh-opc.h
--- gdb-6.8/opcodes/sh-opc.h	2007-07-05 10:49:02.000000000 +0100
+++ stsgdb-6.8/opcodes/sh-opc.h	2008-09-11 10:35:41.000000000 +0100
@@ -1,6 +1,7 @@
 /* Definitions for SH opcodes.
    Copyright 1993, 1994, 1995, 1997, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2007 Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of the GNU opcodes library.
 
@@ -121,6 +122,12 @@
     A_MACL,
     A_PR,
     A_R0,
+ /* For use of the ST40-300 EXPERIMENTAL mulr instructions.
+    Not for submission to the netsources.  */
+    A_R1,
+    A_R2,
+    A_R3,
+ /* End of experimental.  */
     A_R0_GBR,
     A_REG_M,
     A_REG_N,
@@ -215,7 +222,10 @@
 #define arch_sh4_base	    (1 << 5)
 #define arch_sh4a_base	    (1 << 6)
 #define arch_sh2a_base      (1 << 7)
-#define arch_sh_base_mask   MASK (0, 7)
+#define arch_st40_300_base  (1 << 8)
+#define arch_sh4a_st40_300_base (1 << 9)
+#define arch_st40_300_sh2a_base (1 << 10)
+#define arch_sh_base_mask   MASK (0, 10)
 
 /* Bits 8 ... 24 are currently free.  */
 
@@ -255,6 +265,11 @@
 #define arch_sh2a_nofpu_or_sh3_nommu       (arch_sh2a_sh3_base|arch_sh_no_mmu |arch_sh_no_co)
 #define arch_sh2a_or_sh3e                  (arch_sh2a_sh4_base|arch_sh_no_mmu |arch_sh_sp_fpu)
 #define arch_sh2a_or_sh4                   (arch_sh2a_sh4_base|arch_sh_no_mmu |arch_sh_dp_fpu)
+#define arch_st40_300                      (arch_st40_300_base|arch_sh_has_mmu|arch_sh_dp_fpu)
+#define arch_st40_300_or_sh4a              (arch_sh4a_st40_300_base|arch_sh_has_mmu|arch_sh_dp_fpu)
+#define arch_st40_300_nofpu                (arch_st40_300_base|arch_sh_has_mmu|arch_sh_no_co)
+#define arch_st40_300_nofpu_or_sh4a_nofpu  (arch_sh4a_st40_300_base|arch_sh_has_mmu|arch_sh_no_co)
+#define arch_st40_300_nofpu_or_sh2a_nofpu  (arch_st40_300_sh2a_base|arch_sh_no_mmu |arch_sh_no_co)
 
 #define SH_MERGE_ARCH_SET(SET1, SET2) ((SET1) & (SET2))
 #define SH_VALID_BASE_ARCH_SET(SET) (((SET) & arch_sh_base_mask) != 0)
@@ -296,22 +311,32 @@
  |               |          |`--------------------. |
  |               |          |                      \|
  |              SH3-nommu  SH4-nm-nf/SH2A-nofpu    SH3E/SH2A
- |               |\         |          |      \     |    |
- |               | `------. |     SH2A-nofpu   `----+---.|
- |               |         \|            \          |   SH4/SH2A
- |              SH3     SH4-nommu-nofpu   `---------+--. |   |
- |              /|\         |                       |   \|   |
- | .-----------' | `--------+---------------------. |  SH2A  |
- |/              |          /                      \|        |
- |               | .-------'                        |        |
- |               |/                                 |        |
-SH3-dsp         SH4-nofpu                          SH3E      |
- |               |`-------------------------------. | .-----'
- |               |                                 \|/
- |              SH4A-nofpu                         SH4
- | .------------' `-------------------------------. |
- |/                                                \|
-SH4AL-dsp                                          SH4A
+ |               |\         |          |    `-----. |    |
+ |               | \        | ST40-300-nf/SH2A-nf | |    |
+ |               |  \       |     |       |       `-+--. |
+ |               |   `----. |     |      SH2A-nofpu |   \|
+ |               |         \|     `----.   \        |   SH4/SH2A
+ |              SH3  SH4-nommu-nofpu    \   `-------+--. |   |
+ |              /|\         |            \          |   \|   |
+ | .-----------' | `--------+-------------+-------. |  SH2A  |
+ |/              |          |             |        \|        |
+ |               | .--------'             |         |        |
+ |               |/                       |         |        |
+SH3-dsp         SH4-nofpu                 |        SH3E      |
+ |               |`-----------------------+-------. | .------'
+ |               |                        |        \|/
+ |               |                        |        SH4
+ |              SH4A-nofpu/ST40-300-nofpu |         | 
+ |               |`.        | .-----------'         |
+ |               | |        |/                      |
+ |               | |       ST40-300-nofpu           |
+ |               | |        `-----------------------+------------.
+ |               | `------------------------------. |            |
+ |               |                                 \|            |
+ |              SH4A-nofpu                         SH4A/ST40-300 |
+ | .------------' `-------------------------------. |    | .-----'
+ |/                                                \|    |/
+SH4AL-dsp                                          SH4A ST40-300
 */
 
 /* Central branches.  */
@@ -326,9 +351,12 @@
 		| arch_sh2a_or_sh3e_up \
 		| arch_sh3_nommu_up)
 #define arch_sh2a_nofpu_or_sh4_nommu_nofpu_up  (arch_sh2a_nofpu_or_sh4_nommu_nofpu \
-		| arch_sh2a_nofpu_up \
+		| arch_st40_300_nofpu_or_sh2a_nofpu_up \
 		| arch_sh2a_or_sh4_up \
 		| arch_sh4_nommu_nofpu_up)
+#define arch_st40_300_nofpu_or_sh2a_nofpu_up   (arch_st40_300_nofpu_or_sh2a_nofpu \
+		| arch_sh2a_nofpu_up \
+		| arch_st40_300_nofpu_up)
 #define arch_sh2a_nofpu_up                     (arch_sh2a_nofpu \
 		| arch_sh2a_up)
 #define arch_sh3_nommu_up                      (arch_sh3_nommu \
@@ -342,7 +370,13 @@
 		| arch_sh4_nofpu_up)
 #define arch_sh4_nofpu_up                      (arch_sh4_nofpu \
 		| arch_sh4_up \
+		| arch_st40_300_nofpu_or_sh4a_nofpu_up)
+#define arch_st40_300_nofpu_or_sh4a_nofpu_up   (arch_st40_300_nofpu_or_sh4a_nofpu \
+		| arch_st40_300_nofpu_up \
+		| arch_st40_300_or_sh4a_up \
 		| arch_sh4a_nofpu_up)
+#define arch_st40_300_nofpu_up                 (arch_st40_300_nofpu \
+		| arch_st40_300_up)
 #define arch_sh4a_nofpu_up                     (arch_sh4a_nofpu \
 		| arch_sh4a_up \
 		| arch_sh4al_dsp_up)
@@ -360,8 +394,12 @@
 #define arch_sh3e_up                           (arch_sh3e \
 		| arch_sh4_up)
 #define arch_sh4_up                            (arch_sh4 \
-		| arch_sh4a_up)
+		| arch_st40_300_or_sh4a_up)
+#define arch_st40_300_or_sh4a_up               (arch_st40_300_or_sh4a \
+		| arch_sh4a_up \
+		| arch_st40_300_up)
 #define arch_sh4a_up                           (arch_sh4a)
+#define arch_st40_300_up                       (arch_st40_300)
 
 /* Left branch.  */
 #define arch_sh_dsp_up                         (arch_sh_dsp  \
@@ -452,7 +490,7 @@
 
 /* 0110nnnnmmmm1101 extu.w <REG_M>,<REG_N>*/{"extu.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_D}, arch_sh_up},
 
-/* 0000nnnn11100011 icbi @<REG_N>       */{"icbi",{A_IND_N},{HEX_0,REG_N,HEX_E,HEX_3}, arch_sh4a_nofpu_up},
+/* 0000nnnn11100011 icbi @<REG_N>       */{"icbi",{A_IND_N},{HEX_0,REG_N,HEX_E,HEX_3}, arch_st40_300_nofpu_or_sh4a_nofpu_up},
 
 /* 0100nnnn00101011 jmp @<REG_N>        */{"jmp",{A_IND_N},{HEX_4,REG_N,HEX_2,HEX_B}, arch_sh_up},
 
@@ -840,7 +878,7 @@
 
 /* 0110nnnnmmmm1001 swap.w <REG_M>,<REG_N>*/{"swap.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_9}, arch_sh_up},
 
-/* 0000000010101011 synco               */{"synco",{0},{HEX_0,HEX_0,HEX_A,HEX_B}, arch_sh4a_nofpu_up},
+/* 0000000010101011 synco               */{"synco",{0},{HEX_0,HEX_0,HEX_A,HEX_B}, arch_st40_300_nofpu_or_sh4a_nofpu_up},
 
 /* 0100nnnn00011011 tas.b @<REG_N>      */{"tas.b",{A_IND_N},{HEX_4,REG_N,HEX_1,HEX_B}, arch_sh_up},
 
@@ -1118,7 +1156,7 @@
 /* 1111nnnn01001101 fneg <F_REG_N>     */{"fneg",{F_REG_N},{HEX_F,REG_N,HEX_4,HEX_D}, arch_sh2e_up},
 /* 1111nnn001001101 fneg <D_REG_N>     */{"fneg",{D_REG_N},{HEX_F,REG_N,HEX_4,HEX_D}, arch_sh2a_or_sh4_up},
 
-/* 1111011111111101 fpchg               */{"fpchg",{0},{HEX_F,HEX_7,HEX_F,HEX_D}, arch_sh4a_up},
+/* 1111011111111101 fpchg               */{"fpchg",{0},{HEX_F,HEX_7,HEX_F,HEX_D}, arch_st40_300_or_sh4a_up},
 
 /* 1111101111111101 frchg               */{"frchg",{0},{HEX_F,HEX_B,HEX_F,HEX_D}, arch_sh4_up},
 
@@ -1167,7 +1205,14 @@
   /* 0100mmmm11110000 movml.l <REG_M>,@-R15 */ {"movmu.l",{A_REG_M,A_DEC_R15},{HEX_4,REG_M,HEX_F,HEX_0}, arch_sh2a_nofpu_up},
   /* 0100mmmm11110100 movml.l @R15+,<REG_M> */ {"movmu.l",{A_INC_R15,A_REG_M},{HEX_4,REG_M,HEX_F,HEX_4}, arch_sh2a_nofpu_up},
   /* 0000nnnn00111001 movrt <REG_N> */         {"movrt",{A_REG_N},{HEX_0,REG_N,HEX_3,HEX_9}, arch_sh2a_nofpu_up},
-  /* 0100nnnn10000000 mulr R0,<REG_N> */       {"mulr",{A_R0,A_REG_N},{HEX_4,REG_N,HEX_8,HEX_0}, arch_sh2a_nofpu_up},
+  /* 0100nnnn10000000 mulr R0,<REG_N> */       {"mulr",{A_R0,A_REG_N},{HEX_4,REG_N,HEX_8,HEX_0}, arch_st40_300_nofpu_or_sh2a_nofpu_up},
+
+/* Experimental ST40-300 instructions. Not for submission to the netsources.  */
+  /* 0100nnnn10010000 mulr R1,<REG_N> */       {"mulr",{A_R1,A_REG_N},{HEX_4,REG_N,HEX_9,HEX_0}, arch_st40_300_nofpu_up},
+  /* 0100nnnn10100000 mulr R2,<REG_N> */       {"mulr",{A_R2,A_REG_N},{HEX_4,REG_N,HEX_A,HEX_0}, arch_st40_300_nofpu_up},
+  /* 0100nnnn10110000 mulr R3,<REG_N> */       {"mulr",{A_R3,A_REG_N},{HEX_4,REG_N,HEX_B,HEX_0}, arch_st40_300_nofpu_up},
+/* End of experimental.  */
+
   /* 0000000001101000 nott */                  {"nott",{A_END},{HEX_0,HEX_0,HEX_6,HEX_8}, arch_sh2a_nofpu_up},
   /* 0000000001011011 resbank */               {"resbank",{A_END},{HEX_0,HEX_0,HEX_5,HEX_B}, arch_sh2a_nofpu_up},
   /* 0000000001101011 rts/n */                 {"rts/n",{A_END},{HEX_0,HEX_0,HEX_6,HEX_B}, arch_sh2a_nofpu_up},
diff -Naur gdb-6.8/pdcurses/aclocal.m4 stsgdb-6.8/pdcurses/aclocal.m4
--- gdb-6.8/pdcurses/aclocal.m4	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/aclocal.m4	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,31 @@
+dnl ---------------------------------------------------------------------------
+dnl Determine the system limit for number of signals
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_MAX_SIGNALS],
+[
+save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $SYS_DEFS"
+AC_MSG_CHECKING(for maximum signal specifier:)
+AC_CACHE_VAL(mh_cv_max_signals,
+mh_found="no"
+for mh_sigs in $1; do
+	AC_TRY_COMPILE([#include <signal.h>],
+[return $mh_sigs;],
+  mh_found="yes"; mh_cv_max_signals="$mh_sigs" )
+	if test "$mh_found" = "yes"; then
+		break;
+	fi
+done)
+CPPFLAGS="$save_CPPFLAGS"
+if test "$mh_found" = "no"; then
+	AC_MSG_ERROR(Cannot find a system limit for number of signals. PDCurses cannot be configured on this machine.)
+else
+	AC_DEFINE_UNQUOTED(PDC_MAX_SIGNALS,$mh_cv_max_signals)
+	AC_MSG_RESULT($mh_cv_max_signals)
+fi
+])dnl
+
+dnl
+dnl include our own common routines
+dnl
+sinclude(common/accommon.m4)dnl
diff -Naur gdb-6.8/pdcurses/ChangeLog.sts-gdb stsgdb-6.8/pdcurses/ChangeLog.sts-gdb
--- gdb-6.8/pdcurses/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/ChangeLog.sts-gdb	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,7 @@
+2006-02-23  Denis Pilat  <denis.pilat@st.com>
+
+	Write a new version of configure.in and Makefile.in to be compliant 
+	with cygwin and MSYS environment, target is pdcurses.a library 
+	integrated into sts-gdb repository.
+	* configure: added, generated.
+	* ChangeLog.sts-gdb: added.
diff -Naur gdb-6.8/pdcurses/common/accommon.m4 stsgdb-6.8/pdcurses/common/accommon.m4
--- gdb-6.8/pdcurses/common/accommon.m4	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/common/accommon.m4	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,1278 @@
+dnl ---------------------------------------------------------------------------
+dnl This file offers the following common macros...
+dnl ---------------------------------------------------------------------------
+dnl CHECK_REXX
+dnl MH_IPC
+dnl MH_CHECK_X_INC
+dnl MH_CHECK_X_LIB
+dnl MH_HAVE_PROTO
+dnl MH_HAVE_BROKEN_CXX_WITH_STRING_H
+dnl MH_PROG_CC
+dnl MH_PROG_CXX
+dnl MH_CHECK_X_HEADERS
+dnl MH_CHECK_X_KEYDEFS
+dnl MH_CHECK_X_TYPEDEF
+dnl MH_TRY_LINK
+dnl MH_CHECK_LIB
+dnl MH_HOWTO_SHARED_LIBRARY
+dnl MH_SHARED_LIBRARY
+dnl MH_HOWTO_DYN_LINK
+dnl MH_CHECK_CC_O
+dnl MH_CHECK_LEADING_USCORE
+dnl MH_SHLPST
+
+dnl ---------------------------------------------------------------------------
+dnl Check REXX library and header files
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([CHECK_REXX],
+[
+AC_REQUIRE([AC_CANONICAL_SYSTEM])
+dnl
+dnl Setup various things for different interpreters
+dnl
+extra_rexx_libs=""
+extra_rexx_defines=""
+orexx_incdirs=""
+orexx_libdirs=""
+REXX_LIBS=""
+REXX_INCLUDES=""
+case "$with_rexx" in
+	regina)               dnl -------- Regina
+		AC_DEFINE(USE_REGINA)
+		AC_CHECK_PROG(regina_config, [regina-config], yes, no)
+		rexx_h="rexxsaa.h"
+		rexx_l="regina"
+		REXX_INT="Regina"
+		REXX_TARGET="Regina"
+		if test "$ac_cv_prog_regina_config" = yes; then
+			REXX_INCLUDES=`regina-config --cflags`
+			REXX_LIBS=`regina-config --libs`
+			REXX_INT="Regina (using regina-config)"
+		else
+			case "$target" in
+				*nto-qnx*)
+				AC_SEARCH_LIBS(dlopen,dl)
+				;;
+				*qnx*)
+				;;
+				*hp-hpux*)
+				AC_SEARCH_LIBS(shl_load,dld)
+				;;
+				*)
+			AC_SEARCH_LIBS(dlopen,dl)
+				;;
+			esac
+			AC_SEARCH_LIBS(crypt,crypt)
+			AC_PROG_LEX
+		fi
+dnl for FreeBSD, the use of -pthread with ld doesn't work,
+dnl so remove it.
+		case "$target" in
+			*freebsd*)
+				
+				REXX_LIBS="`echo ${REXX_LIBS} | sed -e s/-pthread//`"
+				;;
+			*)
+				;;
+		esac
+	;;
+	rexxtrans)            dnl -------- Rexx/Trans
+		AC_DEFINE(USE_REXXTRANS)
+		AC_CHECK_PROG(rexxtrans_config, [rexxtrans-config], yes, no)
+		rexx_h="rexxtrans.h"
+		rexx_l="rexxtrans"
+		REXX_INT="Rexx/Trans"
+		REXX_TARGET="RexxTrans"
+		if test "$ac_cv_prog_rexxtrans_config" = yes; then
+			REXX_INCLUDES=`rexxtrans-config --cflags`
+			REXX_LIBS=`rexxtrans-config --libs`
+			REXX_INT="Rexx/Trans (using rexxtrans-config)"
+		else
+			AC_SEARCH_LIBS(dlopen,dl)
+		fi
+	;;
+	objrexx | orexx | objectrexx)              dnl -------- Object Rexx
+	with_rexx="objrexx"
+		AC_DEFINE(USE_OREXX)
+		rexx_h="rexx.h"
+		rexx_l="rexxapi"
+		REXX_INT="Object Rexx"
+		REXX_TARGET="ObjectRexx"
+		extra_rexx_libs="-lrexx"
+		orexx_incdirs="/opt/orexx /usr/local/orexx /usr/lpp/orexx/include"
+		orexx_libdirs="/opt/orexx/lib /usr/local/orexx/lib /usr/lpp/orexx/lib"
+		case "$target" in
+			*linux*)
+			extra_rexx_defines="-DLINUX"
+			;;
+			*)
+			;;
+		esac
+	AC_SEARCH_LIBS(pthread_create,pthread pthreads thread)
+	;;
+	rexximc)              dnl -------- Rexx/imc
+		AC_DEFINE(USE_REXXIMC)
+		rexx_h="rexxsaa.h"
+		rexx_l="rexx"
+		REXX_INT="REXX/imc"
+		REXX_TARGET="REXXimc"
+		AC_SEARCH_LIBS(dlopen,dl)
+	;;
+	rexx6000)             dnl -------- REXX6000
+dnl
+dnl Check that the OS supports REXX/6000
+dnl Only supported it on AIX
+dnl
+		if test "$with_rexx6000" = yes ; then
+		case "$target" in
+			*aix*)
+				;;
+			*)
+					AC_MSG_ERROR(REXX/6000 support only available on AIX; cannot configure)
+					;;
+		esac
+	fi
+		AC_DEFINE(USE_REXX6000)
+		rexx_h="rexxtype.h"
+		rexx_l="rexx"
+		REXX_INT="REXX/6000"
+		REXX_TARGET="REXX6000"
+	;;
+	unirexx)              dnl -------- uni-REXX
+		AC_DEFINE(USE_UNIREXX)
+		rexx_h="rexxsaa.h"
+		rexx_l="rx"
+		REXX_INT="uni-REXX"
+		REXX_TARGET="uni-REXX"
+		AC_SEARCH_LIBS(dlopen,dl)
+	;;
+	none)                 dnl -------- No Rexx interpreter
+		AC_DEFINE(NOREXX)
+		rexx_h=""
+		rexx_l=""
+		REXX_INT="No Rexx Support"
+		REXX_TARGET=""
+	;;
+	*)
+		AC_MSG_ERROR(No Rexx interpreter specified with --with-rexx=int : must be one of: regina rexximc objrexx unirexx rexx6000 rexxtrans none)
+	;;
+esac
+AC_SUBST(REXX_TARGET)
+
+dnl look for REXX header and library, exit if not found
+
+if test "xx$rexx_h" != "xx" -a "x$REXX_INCLUDES" = "x"; then
+dnl look for REXX header and library, exit if not found
+	AC_MSG_CHECKING(for location of Rexx header file: $rexx_h)
+	mh_rexx_inc_dir=""
+	mh_inc_dirs="\
+	    ${REXXINCDIR}             \
+	    ${orexx_incdirs}          \
+	    ${HOME}/include           \
+	    ${HOME}/{MACHTYPE}/include     \
+	    /usr/local/include        \
+	    /usr/contrib/include      \
+	    /opt/include              \
+	    /opt/sfw/include          \
+	    /sw/include               \
+	    /usr/include              \
+	    /usr/unsupported/include"
+dnl
+dnl Provide for user supplying directory
+dnl
+	if test "$with_rexxincdir" != no ; then
+		mh_inc_dirs="$with_rexxincdir $mh_inc_dirs"
+	fi
+dnl
+dnl Try to determine the directory containing Rexx header
+dnl
+	for ac_dir in $mh_inc_dirs ; do
+	  if test -r $ac_dir/$rexx_h; then
+	    mh_rexx_inc_dir=$ac_dir
+	    break
+	  fi
+	done
+	if test "x$mh_rexx_inc_dir" != "x" ; then
+		REXX_INCLUDES="-I$mh_rexx_inc_dir $extra_rexx_defines"
+		AC_MSG_RESULT(found in $mh_rexx_inc_dir)
+	else
+		AC_MSG_ERROR(Cannot find Rexx header file: $rexx_h; cannot configure)
+	fi
+fi
+AC_SUBST(REXX_INCLUDES)
+
+if test "xx$rexx_h" != "xx" -a "x$REXX_LIBS" = "x"; then
+	AC_MSG_CHECKING(for location of Rexx library file: $rexx_l)
+	mh_rexx_lib_dir=""
+	mh_lib_dirs="\
+	    ${REXXLIBDIR}             \
+	    ${orexx_libdirs}          \
+	    ${HOME}/lib               \
+	    ${HOME}/{MACHTYPE}/lib    \
+	    /usr/local/lib            \
+	    /usr/contrib/lib          \
+	    /opt/lib                  \
+	    /opt/sfw/lib              \
+	    /sw/lib                   \
+	    /usr/lib                  \
+	    /usr/unsupported/lib"
+dnl
+dnl Provide for user supplying directory
+dnl
+	if test "$with_rexxlibdir" != no ; then
+		mh_lib_dirs="$with_rexxlibdir $mh_lib_dirs"
+	fi
+dnl
+dnl Try to determine the directory containing Rexx library
+dnl
+	for ac_dir in $mh_lib_dirs ; do
+		for mh_ext in lib${rexx_l}.a lib${rexx_l}.so lib${rexx_l}.sl ${rexx_l}.lib lib${rexx_l}.dylib; do
+		  if test -r $ac_dir/$mh_ext; then
+		     mh_rexx_lib_dir=$ac_dir
+		   break 2
+		  fi
+		done
+	done
+	if test "x$mh_rexx_lib_dir" != "x" ; then
+		REXX_LIBS="-L$mh_rexx_lib_dir -l$rexx_l $extra_rexx_libs"
+		AC_MSG_RESULT(found in $mh_rexx_lib_dir)
+		AC_SUBST(rexxtrans_lib_name)
+	else
+		AC_MSG_ERROR(Cannot find Rexx library file: $rexx_l; cannot configure)
+	fi
+fi
+AC_SUBST(REXX_LIBS)
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine if the system has System V IPC. ie sys/ipc.h and sys/shm.h
+dnl headers.
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_IPC],
+[
+AC_MSG_CHECKING(for System V IPC support)
+AC_CHECK_HEADER(sys/ipc.h)
+if test $ac_cv_header_sys_ipc_h = no; then
+	AC_MSG_ERROR(Cannot find required header file sys/ipc.h; XCurses cannot be configured)
+fi
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Set up the correct X header file location
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_X_INC],
+[
+AC_MSG_CHECKING(for location of X headers)
+mh_x11_dir=""
+mh_x11_xaw_dir=""
+dnl
+dnl specify latest release of X directories first
+dnl
+mh_inc_dirs="\
+    $HOME/include/X11         \
+    $HOME/include             \
+    /tmp/include/X11          \
+    /tmp/include              \
+    /usr/X11R6/include        \
+    /usr/include/X11R6        \
+    /usr/local/X11R6/include  \
+    /usr/local/include/X11R6  \
+
+    /usr/X11R5/include        \
+    /usr/include/X11R5        \
+    /usr/local/X11R5/include  \
+    /usr/local/include/X11R5  \
+    /usr/local/x11r5/include  \
+
+    /usr/X11R4/include        \
+    /usr/include/X11R4        \
+    /usr/local/X11R4/include  \
+    /usr/local/include/X11R4  \
+                              \
+    /usr/X11/include          \
+    /usr/include/X11          \
+    /usr/local/X11/include    \
+    /usr/local/include/X11    \
+                              \
+    /usr/X386/include         \
+    /usr/x386/include         \
+    /usr/XFree86/include/X11  \
+                              \
+    /usr/include              \
+    /usr/local/include        \
+    /usr/unsupported/include  \
+    /usr/athena/include       \
+    /usr/lpp/Xamples/include  \
+                              \
+    /usr/openwin/include      \
+    /usr/openwin/share/include"
+dnl
+dnl Provide for user supplying directory
+dnl
+if test "x$x_includes" != xNONE ; then
+	mh_inc_dirs="$x_includes $mh_inc_dirs"
+fi
+
+dnl
+dnl Try to determine the directory containing X headers
+dnl We will append X11 to all the paths above as an extra check
+dnl
+for ac_dir in $mh_inc_dirs ; do
+  if test -r $ac_dir/Intrinsic.h; then
+    mh_x11_dir=$ac_dir
+    break
+  fi
+  if test -r $ac_dir/X11/Intrinsic.h; then
+    mh_x11_dir="$ac_dir/X11"
+    break
+  fi
+done
+
+dnl
+dnl Try to determine the directory containing Xaw headers
+dnl We will append X11 to all the paths above as an extra check
+dnl
+if test "$with_xaw3d" = yes; then
+	mh_xaw_dir="Xaw3d"
+else
+	if test "$with_nextaw" = yes; then
+		mh_xaw_dir="neXtaw"
+	else
+		mh_xaw_dir="Xaw"
+	fi
+fi
+for ac_dir in $mh_inc_dirs ; do
+  if test -r $ac_dir/$mh_xaw_dir/Box.h; then
+    mh_x11_xaw_dir=$ac_dir
+    break
+  fi
+  if test -r $ac_dir/X11/$mh_xaw_dir/Box.h; then
+    mh_x11_xaw_dir="$ac_dir/X11"
+    break
+  fi
+done
+
+if test "x$mh_x11_dir" != "x" ; then
+	mh_x11_dir_no_x11=`echo $mh_x11_dir | sed 's/\/X11$//'`
+dnl
+dnl Test to see if $mh_x11_dir_no_x11 is /usr/include and we are using gcc
+dnl under Solaris. If so, ignore it.
+	AC_REQUIRE([AC_CANONICAL_SYSTEM])
+	mh_solaris_gcc_usr_include="no"
+	case "$target" in
+		*solaris*)
+			if test "$ac_cv_prog_CC" = "gcc" -a "$mh_x11_dir_no_x11" = "/usr/include" ; then
+				mh_solaris_gcc_usr_include="yes"
+			fi
+			;;
+	esac
+	if test "$mh_x11_dir_no_x11" != "$mh_x11_dir" -a "$mh_solaris_gcc_usr_include" = "no" ; then
+		MH_XINC_DIR="-I$mh_x11_dir -I$mh_x11_dir_no_x11"
+	else
+		MH_XINC_DIR="-I$mh_x11_dir"
+	fi
+else
+	AC_MSG_ERROR(Cannot find required header file Intrinsic.h; XCurses cannot be configured)
+fi
+
+if test "x$mh_x11_xaw_dir" != "x" ; then
+	MH_XINC_DIR="-I$mh_x11_xaw_dir $MH_XINC_DIR"
+else
+	AC_MSG_ERROR(Cannot find required Xaw header file Box.h; XCurses cannot be configured)
+fi
+
+	AC_MSG_RESULT(found in $mh_x11_dir $mh_x11_xaw_dir)
+	AC_SUBST(MH_XINC_DIR)
+
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Set up the correct X library file location
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_X_LIB],
+[
+dnl
+dnl Some systems require extra libraries...
+dnl
+mh_solaris_flag=no
+mh_hpux9_flag=no
+AC_REQUIRE([AC_CANONICAL_SYSTEM])
+case "$target" in
+	*solaris*)
+		mh_solaris_flag=yes
+		;;
+	*pc-sco*)
+		extra_x_libs="Xext"
+		;;
+	sparc*sunos*)
+		extra_x_libs="Xext"
+		if test "$ac_cv_prog_CC" = "gcc" ; then
+			extra_ld_flags="-Wl,-Bstatic"
+			extra_ld_flags2="-Wl,-Bdynamic"
+		else
+			extra_ld_flags="-Bstatic"
+			extra_ld_flags2="-Bdynamic"
+		fi
+		;;
+	*hpux9*)
+		mh_hpux9_flag=yes
+		;;
+esac
+
+AC_MSG_CHECKING(for location of X libraries)
+if test "$with_xaw3d" = yes; then
+	MH_X11_LIBS="Xaw3d Xmu Xt X11"
+else
+	if test "$with_nextaw" = yes; then
+		MH_X11_LIBS="neXtaw Xmu Xt X11"
+	else
+		MH_X11_LIBS="Xaw Xmu Xt X11"
+	fi
+fi
+MH_X11R6_LIBS="SM ICE Xext"
+mh_x11r6=no
+dnl
+dnl specify latest release of X directories first
+dnl
+mh_lib_dirs="\
+    $HOME/lib             \
+    /tmp/lib              \
+    /usr/X11R6/lib        \
+    /usr/lib/X11R6        \
+    /usr/local/X11R6/lib  \
+    /usr/local/lib/X11R6  \
+
+    /usr/X11R5/lib        \
+    /usr/lib/X11R5        \
+    /usr/local/X11R5/lib  \
+    /usr/local/lib/X11R5  \
+    /usr/local/x11r5/lib  \
+
+    /usr/X11R4/lib        \
+    /usr/lib/X11R4        \
+    /usr/local/X11R4/lib  \
+    /usr/local/lib/X11R4  \
+                          \
+    /usr/X11/lib          \
+    /usr/lib/X11          \
+    /usr/local/X11/lib    \
+    /usr/local/lib/X11    \
+                          \
+    /usr/X386/lib         \
+    /usr/x386/lib         \
+    /usr/XFree86/lib/X11  \
+                          \
+    /usr/lib              \
+    /usr/local/lib        \
+    /usr/unsupported/lib  \
+    /usr/athena/lib       \
+    /usr/lpp/Xamples/lib  \
+                          \
+    /usr/openwin/lib      \
+    /usr/openwin/share/lib"
+dnl
+dnl Provide for user supplying directory
+dnl
+if test "x$x_libraries" != xNONE ; then
+	mh_lib_dirs="$x_libraries $mh_lib_dirs"
+fi
+
+dnl
+dnl try to find libSM.[a,sl,so,dylib]. If we find it we are using X11R6
+dnl
+for ac_dir in $mh_lib_dirs ; do
+	for mh_xsm in libSM.a libSM.so libSM.sl libSM.dylib; do
+	  if test -r $ac_dir/$mh_xsm; then
+	    mh_x11r6=yes
+	    break 2
+	  fi
+	done
+done
+
+if test "$mh_x11r6" = yes ; then
+	mh_libs="$MH_X11_LIBS $MH_X11R6_LIBS"
+else
+	mh_libs="$MH_X11_LIBS $extra_x_libs"
+fi
+
+dnl
+dnl Ensure that all required X libraries are found
+dnl
+mh_prev_dir=""
+mh_where_found=""
+mh_where_found_dirs=""
+mh_solaris_path=""
+for mh_lib in $mh_libs; do
+  mh_lib_found=no
+  for ac_dir in $mh_lib_dirs ; do
+    for mh_ext in a so sl dll.a; do
+      if test -r $ac_dir/lib$mh_lib.$mh_ext; then
+        if test "x$mh_prev_dir" != "x$ac_dir" ; then
+          if test "x$mh_prev_dir" = "x" ; then
+             mh_where_found="$mh_where_found found in $ac_dir"
+          else
+             mh_where_found="$mh_where_found and in $ac_dir"
+          fi
+          mh_prev_dir=$ac_dir
+          mh_where_found_dirs="$mh_where_found_dirs $ac_dir"
+          MH_XLIBS="$MH_XLIBS -L$ac_dir"
+          mh_solaris_path="${mh_solaris_path}:$ac_dir"
+        fi
+        MH_XLIBS="$MH_XLIBS -l$mh_lib"
+        mh_lib_found=yes
+        break 2
+      fi
+    done
+  done
+  if test "$mh_lib_found" = no; then
+    AC_MSG_ERROR(Cannot find required X library; lib$mh_lib. XCurses cannot be configured)
+  fi
+done
+AC_MSG_RESULT($mh_where_found)
+mh_solaris_path=`echo $mh_solaris_path | sed 's/^://'`
+if test "$mh_solaris_flag" = yes ; then
+	MH_XLIBS="-R$mh_solaris_path $extra_ld_flags $MH_XLIBS $extra_libs $extra_ld_flags2"
+else
+	MH_XLIBS="$extra_ld_flags $MH_XLIBS $extra_libs $extra_ld_flags2"
+fi
+if test "$mh_hpux9_flag" = yes ; then
+  grep -q XtSetLanguageProc $mh_x11_dir/Intrinsic.h
+  if test $? -eq 0 ; then
+    mh_found_xtshellstrings=no
+    for mh_acdir in $mh_where_found_dirs ; do
+      for mh_xaw in `ls $mh_acdir/libXaw.*` ; do
+        nm $mh_xaw | grep XtShellStrings | grep -qv extern
+        if test $? -eq 0 ; then
+          mh_found_xtshellstrings=yes
+        fi
+      done
+    done
+    if test "$mh_found_xtshellstrings" = no ; then
+      AC_MSG_WARN(The X11 development environment has not been installed correctly.)
+      AC_MSG_WARN(The header file; Intrinsic.h, is for X11R5 while the Athena Widget)
+      AC_MSG_WARN(Set library; libXaw is for X11R4.  This is a common problem with)
+      AC_MSG_WARN(HP-UX 9.x.)
+      AC_MSG_WARN(A set of required X11R5 library files can be obtained from the)
+      AC_MSG_WARN(anonymous ftp sites listed on the PDCurses WWW home page:)
+      AC_MSG_WARN(http://www.lightlink.com/hessling/)
+      AC_MSG_WARN(The file is called HPUX-9.x-libXaw-libXmu.tar.Z)
+      AC_MSG_ERROR(X11 installation incomplete; cannot continue)
+    fi
+  fi
+fi
+	AC_SUBST(MH_XLIBS)
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine if C compiler handles ANSI prototypes
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_HAVE_PROTO],
+[
+AC_MSG_CHECKING(if compiler supports ANSI prototypes)
+dnl
+dnl override existing value of $ac_compile so we use the correct compiler
+dnl SHOULD NOT NEED THIS
+dnl
+ac_compile='$ac_cv_prog_CC conftest.$ac_ext $CFLAGS $CPPFLAGS -c 1>&5 2>&5'
+AC_TRY_COMPILE([#include <stdio.h>],
+[extern int xxx(int, char *);],
+  mh_have_proto=yes; AC_DEFINE(HAVE_PROTO), mh_have_proto=no )
+AC_MSG_RESULT($mh_have_proto)
+])dnl
+
+dnl -----------------------------------------------------
+dnl Determine if compiling <string.h> breaks g++ compiler
+dnl -----------------------------------------------------
+AC_DEFUN([MH_HAVE_BROKEN_CXX_WITH_STRING_H],
+[
+AC_MSG_CHECKING(if g++ compiler cannot compile <string.h>)
+dnl
+dnl override existing value of $ac_compile so we use the correct compiler
+dnl SHOULD NOT NEED THIS
+dnl
+ac_compile='$ac_cv_prog_CC conftest.$ac_ext $CFLAGS $CPPFLAGS -c 1>&5 2>&5'
+AC_TRY_COMPILE([#include <string.h>],
+[extern int xxx(int, char *);],
+  mh_have_broken_cxx_with_string_h=yes; AC_DEFINE(HAVE_BROKEN_CXX_WITH_STRING_H), mh_have_broken_cxx_with_string_h=no )
+AC_MSG_RESULT($mh_have_broken_cxx_with_string_h)
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine the best C compiler to use given a list
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_PROG_CC],
+[
+mh_sysv_incdir=""
+mh_sysv_libdir=""
+all_words="$CC_LIST"
+ac_dir=""
+AC_MSG_CHECKING(for one of the following C compilers: $all_words)
+AC_CACHE_VAL(ac_cv_prog_CC,[
+if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for mh_cc in $all_words; do
+    for ac_dir in $PATH; do
+      test -z "$ac_dir" && ac_dir=.
+      if test -f $ac_dir/$mh_cc; then
+        ac_cv_prog_CC="$mh_cc"
+        if test "$ac_dir" = "/usr/5bin"; then
+          mh_sysv_incdir="/usr/5include"
+          mh_sysv_libdir="/usr/5lib"
+        fi
+        break 2
+      fi
+    done
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_prog_CC" && ac_cv_prog_CC="cc"
+fi
+CC="$ac_cv_prog_CC"
+])
+AC_SUBST(CC)
+if test "$ac_dir" = ""; then
+   AC_MSG_RESULT(using $ac_cv_prog_CC specified in CC env variable)
+else
+   AC_MSG_RESULT(using $ac_dir/$ac_cv_prog_CC)
+fi
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine the best C++ compiler to use given a list
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_PROG_CXX],
+[
+mh_sysv_incdir=""
+mh_sysv_libdir=""
+all_words="$CC_LIST"
+ac_dir=""
+AC_MSG_CHECKING(for one of the following C++ compilers: $all_words)
+AC_CACHE_VAL(ac_cv_prog_CXX,[
+if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CC" # Let the user override the test.
+else
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for mh_cc in $all_words; do
+    for ac_dir in $PATH; do
+      test -z "$ac_dir" && ac_dir=.
+      if test -f $ac_dir/$mh_cc; then
+        ac_cv_prog_CXX="$mh_cc"
+        break 2
+      fi
+    done
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_prog_CXX" && ac_cv_prog_CXX="c++"
+fi
+CXX="$ac_cv_prog_CXX"
+])
+AC_SUBST(CXX)
+if test "$ac_dir" = ""; then
+   AC_MSG_RESULT(using $ac_cv_prog_CXX specified in CXX env variable)
+else
+   AC_MSG_RESULT(using $ac_dir/$ac_cv_prog_CXX)
+fi
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine if the supplied X headers exist.
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_X_HEADERS],
+[
+save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $MH_XINC_DIR"
+for mh_header in $1; do
+	AC_CHECK_HEADERS($mh_header)
+done
+CPPFLAGS="$save_CPPFLAGS"
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine if various key definitions exist in keysym.h
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_X_KEYDEFS],
+[
+save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $MH_XINC_DIR"
+for mh_keydef in $1; do
+	AC_MSG_CHECKING(for $mh_keydef in keysym.h)
+	mh_upper_name="HAVE_`echo $mh_keydef | tr '[a-z]' '[A-Z]'`"
+	AC_TRY_COMPILE([#include <keysym.h>],
+[int i = $mh_keydef;],
+  mh_have_key=yes; AC_DEFINE_UNQUOTED($mh_upper_name,1), mh_have_key=no )
+	AC_MSG_RESULT($mh_have_key)
+done
+CPPFLAGS="$save_CPPFLAGS"
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine if supplied types have been typedefed
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_X_TYPEDEF],
+[
+save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $SYS_DEFS $MH_XINC_DIR"
+for td in $1 ; do
+AC_MSG_CHECKING(if $td is typedefed:)
+AC_TRY_COMPILE(
+[#include "X11/Xlib.h"],
+[$td fred],
+	[mh_td=yes],
+	[mh_td=no]
+)
+if test "$mh_td" = yes ; then
+	TD_upper=`echo $td | tr a-z A-Z`
+	AC_DEFINE_UNQUOTED(${TD_upper}_TYPEDEFED, 1)
+fi
+AC_MSG_RESULT($mh_td)
+done
+CPPFLAGS="$save_CPPFLAGS"
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Provide our own AC_TRY_LINK
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_TRY_LINK],
+[
+mh_link='${LD-ld} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&AC_FD_CC'
+save_CPPFLAGS="$CPPFLAGS"
+CPPFLAGS="$CPPFLAGS $MH_XINC_DIR"
+for mh_keydef in $1; do
+	AC_MSG_CHECKING(for $mh_keydef in keysym.h)
+	mh_upper_name="HAVE_`echo $mh_keydef | tr '[a-z]' '[A-Z]'`"
+	AC_TRY_COMPILE([#include <keysym.h>],
+[int i = $mh_keydef;],
+  mh_have_key=yes; AC_DEFINE_UNQUOTED($mh_upper_name,1), mh_have_key=no )
+	AC_MSG_RESULT($mh_have_key)
+done
+CPPFLAGS="$save_CPPFLAGS"
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Check for presense of various libraries
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_LIB],
+[
+MH_EXTRA_LIBS=''
+for mh_lib in $1; do
+	if test "$on_qnx" = yes; then
+		AC_MSG_CHECKING(for library -l${mh_lib})
+		if test -r /usr/lib/${mh_lib}3r.lib; then
+			AC_MSG_RESULT(found)
+			MH_EXTRA_LIBS="${MH_EXTRA_LIBS} -l${mh_lib}"
+		else
+		AC_MSG_RESULT(not found)
+		fi
+	else
+		AC_CHECK_LIB($mh_lib,main,mh_lib_found=yes,mh_lib_found=no)
+		if test "$mh_lib_found" = yes; then
+			MH_EXTRA_LIBS="${MH_EXTRA_LIBS} -l${mh_lib}"
+		fi
+	fi
+done
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Work out how to create a shared library
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_HOWTO_SHARED_LIBRARY],
+[
+AC_MSG_CHECKING(how to create a shared library)
+mh_compile='${CC-cc} -c $DYN_COMP conftest.$ac_ext 1>&AC_FD_CC'
+cat > conftest.$ac_ext <<EOF
+dnl [#]line __oline__ "[$]0"
+[#]line __oline__ "configure"
+int foo()
+{
+return(0);
+}
+EOF
+if AC_TRY_EVAL(mh_compile) && test -s conftest.o; then
+	mh_dyn_link='ld -shared -o conftest.so.1.0 conftest.o -lc 1>&AC_FD_CC'
+#	mh_dyn_link='${CC} -Wl,-shared -o conftest.so.1.0 conftest.o -lc 1>&AC_FD_CC'
+	if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.so.1.0; then
+		SHL_LD="ld -shared -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'" -lc"
+#		SHL_LD="${CC} -Wl,-shared -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'" -lc"
+	else
+		mh_dyn_link='ld -G -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+#		mh_dyn_link='${CC} -Wl,-G -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+		if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.so.1.0; then
+			SHL_LD="ld -G -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+#			SHL_LD="${CC} -Wl,-G -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+		else
+			mh_dyn_link='ld -o conftest.so.1.0 -shared -no_archive conftest.o  -lc 1>&AC_FD_CC'
+#			mh_dyn_link='${CC} -o conftest.so.1.0 -Wl,-shared,-no_archive conftest.o  -lc 1>&AC_FD_CC'
+			if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.so.1.0; then
+				SHL_LD="ld -o ${SHLPRE}${SHLFILE}${SHLPST} -shared -no_archive "'$('SHOFILES')'" -lc"
+#				SHL_LD="${CC} -o ${SHLPRE}${LIBFILE}${SHLPST} -Wl,-shared,-no_archive "'$('SHOFILES')'" -lc"
+			else
+				mh_dyn_link='ld -b -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+#				mh_dyn_link='${CC} -Wl,-b -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+				if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.so.1.0; then
+					SHL_LD="ld -b -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+#					SHL_LD="${CC} -Wl,-b -o ${SHLPRE}${SHLFILE}.${SHLPST} "'$('SHOFILES')'
+				else
+					mh_dyn_link='ld -Bshareable -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+#					mh_dyn_link='${CC} -Wl,-Bshareable -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+					if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.so.1.0; then
+						SHL_LD="ld -Bshareable -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+#						SHL_LD="${CC} -Wl,-Bshareable -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+					else
+						mh_dyn_link='ld -assert pure-text -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+#						mh_dyn_link='${CC} -Wl,-assert pure-text -o conftest.so.1.0 conftest.o 1>&AC_FD_CC'
+						if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.so.1.0; then
+							SHL_LD="ld -assert pure-text -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+#							SHL_LD="${CC} -Wl,-assert pure-text -o ${SHLPRE}${SHLFILE}${SHLPST} "'$('SHOFILES')'
+						else
+							SHL_LD=""
+						fi
+					fi
+				fi
+			fi
+		fi
+	fi
+fi
+if test "$SHL_LD" = ""; then
+	AC_MSG_RESULT(unknown)
+else
+	AC_MSG_RESULT(found)
+fi
+rm -f conftest*
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Work out how to create a dynamically loaded module
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_HOWTO_DYN_LINK],
+[
+mh_compile='${CC-cc} -c $DYN_COMP conftest.$ac_ext 1>&AC_FD_CC'
+cat > conftest.$ac_ext <<EOF
+dnl [#]line __oline__ "[$]0"
+[#]line __oline__ "configure"
+int foo()
+{
+return(0);
+}
+EOF
+if AC_TRY_EVAL(mh_compile) && test -s conftest.o; then
+	mh_dyn_link='ld -shared -o conftest.rxlib conftest.o -lc 1>&AC_FD_CC'
+#	mh_dyn_link='${CC} -Wl,-shared -o conftest.rxlib conftest.o -lc 1>&AC_FD_CC'
+	if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.rxlib; then
+		LD_RXLIB1="ld -shared"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+#		LD_RXLIB1="${CC} -Wl,-shared"
+		LD_RXLIB2="${REXX_LIBS}"
+		SHLPRE="lib"
+		SHLPST=".so"
+		RXLIBLEN="6"
+	else
+		mh_dyn_link='ld -G -o conftest.rxlib conftest.o 1>&AC_FD_CC'
+#		mh_dyn_link='${CC} -Wl,-G -o conftest.rxlib conftest.o 1>&AC_FD_CC'
+		if AC_TRY_EVAL(mh_dyn_link) && test -s conftest.rxlib; then
+			LD_RXLIB1="ld -G"
+			LD_RXTRANSLIB1="$LD_RXLIB1"
+#			LD_RXLIB1="${CC} -Wl,-G"
+			LD_RXLIB2="${REXX_LIBS}"
+			SHLPRE="lib"
+			SHLPST=".so"
+			RXLIBLEN="6"
+		else
+			LD_RXLIB1=""
+			LD_RXTRANSLIB1="$LD_RXLIB1"
+			LD_RXLIB2=""
+			SHLPRE=""
+			SHLPST=""
+			RXLIBLEN="0"
+		fi
+	fi
+fi
+rm -f conftest*
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Determine how to build shared libraries etc..
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_SHARED_LIBRARY],
+[
+AC_REQUIRE([MH_SHLPST])
+dnl
+dnl If compiler is gcc, then flags should be the same for all platforms
+dnl (just guessing on this)
+dnl
+OSAVE=".o.save"
+OBJ="o"
+EXE=""
+GETOPT=""
+STATIC_LDFLAGS=""
+DYNAMIC_LDFLAGS=""
+AIX_DYN="no"
+BEOS_DYN="no"
+SHLFILE="$1"
+SHLFILES="$*"
+RXPACKEXPORTS=""
+BASE_INSTALL="installbase"
+BASE_BINARY="binarybase"
+SHLPRE="lib"
+LD_RXLIB1=""
+LD_RXTRANSLIB1="$LD_RXLIB1"
+CAN_USE_ABI="no"
+LIBEXE="ar"
+LIBFLAGS="cr"
+LIBPRE="lib"
+LIBPST=".a"
+# OTHER_INSTALLS is set to install a non-version numbered shared library
+# by default; ie. no .\$(ABI) suffix. If the regina executable is not built,
+# then there is no shared library. Set OTHER_INSTALLS="installabilib" if you
+# are building a version numbered shared library.
+OTHER_INSTALLS="installlib"
+EXTRATARGET=""
+
+AC_REQUIRE([AC_CANONICAL_SYSTEM])
+case "$target" in
+	*hp-hpux*)
+		SYS_DEFS="-D_HPUX_SOURCE"
+		EEXTRA="-Wl,-E"
+		LD_RXLIB1="ld -b -q -n"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		DYNAMIC_LDFLAGS="-Wl,+s"
+		;;
+	*ibm-aix*)
+		if test "$with_rexx6000" = yes; then
+			mh_entry="-eInitFunc"
+		else
+			mh_entry="-bnoentry"
+		fi
+		SYS_DEFS="-D_ALL_SOURCE -DAIX"
+		AIX_DYN="yes"
+		DYN_COMP="-DDYNAMIC"
+		STATIC_LDFLAGS="-bnso -bI:/lib/syscalls.exp"
+		LD_RXLIB1="ld $mh_entry -bM:SRE"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		RXPACKEXPORTS="-bE:$SHLFILE.exp"
+		RXPACKEXP="$SHLFILE.exp"
+		;;
+	*dec-osf*)
+		if test "$ac_cv_prog_CC" = "gcc"; then
+			SYS_DEFS="-D_POSIX_SOURCE -D_XOPEN_SOURCE"
+		else
+			SYS_DEFS="-D_POSIX_SOURCE -D_XOPEN_SOURCE -Olimit 800"
+		fi
+		LD_RXLIB1="ld -shared"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*sequent-dynix*)
+		LD_RXLIB1="ld -G"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*solaris*)
+		if test "$ac_cv_prog_CC" = "gcc"; then
+			LD_RXLIB1="gcc -shared"
+			LD_RXTRANSLIB1="$LD_RXLIB1"
+		else
+			LD_RXLIB1="ld -G"
+			LD_RXTRANSLIB1="$LD_RXLIB1"
+		fi
+		;;
+	*esix*)
+		LD_RXLIB1="ld -G"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*dgux*)
+		LD_RXLIB1="ld -G"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	sparc*sunos*)
+		SYS_DEFS="-DSUNOS -DSUNOS_STRTOD_BUG"
+		LD_RXLIB1="ld"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*linux*)
+		LD_RXLIB1="${CC} -shared"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		CAN_USE_ABI="yes"
+		if test "$USE_ABI" = "yes"; then
+			OTHER_INSTALLS="installabilib"
+		fi
+		;;
+	*atheos*)
+		LD_RXLIB1="${CC} -shared"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*freebsd*)
+		LD_RXLIB1="ld -Bdynamic -Bshareable"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*pc-sco*)
+		LD_RXLIB1="ld -dy -G"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*beos*)
+		LD_RXLIB1="${CC} -Wl,-shared -nostart -Xlinker -soname=\$(@)"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		BEOS_DYN="yes"
+		BASE_INSTALL="beosinstall"
+		BASE_BINARY="beosbinary"
+		OTHER_INSTALLS=""
+		;;
+	*nto-qnx*)
+		LD_RXLIB1="${CC} -shared"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*qnx*)
+		LIBPRE=""
+		LIBPST=".lib"
+		SHLPRE=""
+		DYN_COMP="-Q"   # force no check for dynamic loading
+		SHLFILE=""
+		EEXTRA="-mf -N0x20000 -Q"
+		;;
+	*cygwin)
+		LIBPRE="lib"
+		SHLPRE=""
+		DYN_COMP="-DDYNAMIC"
+		LIBPST=".a"
+		EXE=".exe"
+# Only for Rexx/Trans do we produce an import library for the DLL we are
+# building
+		LD_RXLIB1="dllwrap --def ./cygwin.def --target i386-cygwin32 --dllname \$(@)"
+		LD_RXTRANSLIB1="dllwrap --def \$(srcdir)/\$(basename \$(@))w32.def --output-lib ${LIBPRE}\$(basename \$(@))${LIBPST} --target i386-cygwin32 --dllname \$(@)"
+		BASE_INSTALL="cygwininstall"
+		BASE_BINARY="cygwinbinary"
+# cygwininstall target MUST install the shared library itself because
+# it puts it into $(bindir) not $(libdir) as all other platforms
+		OTHER_INSTALLS=""
+		;;
+	*darwin*)
+		DYN_COMP="-fno-common"
+		LD_RXLIB1="${CC} -flat_namespace -undefined suppress -dynamiclib -install_name=\$(@)"
+		LD_RXTRANSLIB1="$LD_RXLIB1"
+		;;
+	*)
+		;;
+esac
+
+dnl
+dnl determine what switches our compiler uses for building objects
+dnl suitable for inclusion in shared libraries
+dnl Only call this if DYN_COMP is not set. If we have set DYN_COMP
+dnl above, then we know how to compile AND link for dynamic libraries
+dnl
+if test "$DYN_COMP" = ""; then
+AC_MSG_CHECKING(compiler flags for a dynamic object)
+
+cat > conftest.$ac_ext <<EOF
+dnl [#]line __oline__ "[$]0"
+[#]line __oline__ "configure"
+int a=0
+EOF
+
+	DYN_COMP=""
+	mh_cv_stop=no
+	save_cflags="$CFLAGS"
+	mh_cv_flags="-fPIC -KPIC +Z"
+	for a in $mh_cv_flags; do
+		CFLAGS="-c $a"
+
+		mh_compile='${CC-cc} -c $CFLAGS conftest.$ac_ext > conftest.tmp 2>&1'
+		if AC_TRY_EVAL(mh_compile); then
+			DYN_COMP=""
+		else
+			slash="\\"
+			mh_dyncomp="`egrep -c $slash$a conftest.tmp`"
+			if test "$mh_dyncomp" = "0"; then
+				DYN_COMP="$a -DDYNAMIC"
+				AC_MSG_RESULT($a)
+				break
+			else
+				DYN_COMP=""
+			fi
+		fi
+	done
+	if test "$DYN_COMP" = ""; then
+		AC_MSG_RESULT(none of $mh_cv_flags supported)
+	fi
+	if test "$LD_RXLIB1" = ""; then
+		MH_HOWTO_DYN_LINK()
+	fi
+	CFLAGS=$save_cflags
+	rm -f conftest.*
+fi
+
+
+aix_exports="config.exports.aix"
+echo "" > $aix_exports
+if test "$ac_cv_header_dl_h" = "yes" -o "$ac_cv_header_dlfcn_h" = "yes" -o "$AIX_DYN" = "yes" -o "$BEOS_DYN" = "yes" -o "$DLFCNINCDIR" != "" -o "$DLFCNLIBDIR" != ""; then
+	if test "$with_rexx" = "rexxtrans" -o "$with_rexx" = "regina" -o  "$with_rexx" = "objrexx" -o "$with_rexx" = "rexx6000"; then
+		EXPS="1,2,3,4,5,6,7,8,9"
+		SHL_TARGETS=""
+		for a in $SHLFILES
+		do
+			if test "$USE_ABI" = "yes" -a "$CAN_USE_ABI" = "yes"; then
+				SHL_TARGETS="${SHL_TARGETS} ${SHLPRE}${a}${SHLPST}.\$(ABI)"
+			else
+				SHL_TARGETS="${SHL_TARGETS} ${SHLPRE}${a}${SHLPST}"
+			fi
+			this=`echo $EXPS | cut -d, -f1`
+			EXPS=`echo $EXPS | cut -d, -f2-`
+			if test "$AIX_DYN" = "yes"; then
+				echo "RXPACKEXP$this=$a.exp" >> $aix_exports
+				echo "RXPACKEXPORTS$this=-bE:$a.exp" >> $aix_exports
+			else
+				echo "RXPACKEXP$this=" >> $aix_exports
+				echo "RXPACKEXPORTS$this=" >> $aix_exports
+			fi
+		done
+	else
+		SHL_TARGETS=""
+	fi
+else
+	SHL_TARGETS=""
+fi
+
+AC_SUBST_FILE(aix_exports)
+AC_SUBST(EEXTRA)
+AC_SUBST(CEXTRA)
+AC_SUBST(OSAVE)
+AC_SUBST(OBJ)
+AC_SUBST(EXE)
+AC_SUBST(GETOPT)
+AC_SUBST(DYN_COMP)
+AC_SUBST(LIBS)
+AC_SUBST(SHLIBS)
+AC_SUBST(LD_RXLIB1)
+AC_SUBST(LD_RXTRANSLIB1)
+AC_SUBST(SHLPRE)
+AC_SUBST(SHLPST)
+AC_SUBST(LIBPST)
+AC_SUBST(LIBPRE)
+AC_SUBST(LIBEXE)
+AC_SUBST(LIBFLAGS)
+AC_SUBST(DYNAMIC_LDFLAGS)
+AC_SUBST(STATIC_LDFLAGS)
+AC_SUBST(SHL_TARGETS)
+AC_SUBST(O2SAVE)
+AC_SUBST(O2SHO)
+AC_SUBST(CC2O)
+AC_SUBST(BASE_INSTALL)
+AC_SUBST(OTHER_INSTALLS)
+AC_SUBST(BASE_BINARY)
+AC_SUBST(SAVE2O)
+AC_SUBST(RXPACKEXPORTS)
+AC_SUBST(RXPACKEXP)
+AC_SUBST(CAN_USE_ABI)
+])dnl
+
+dnl ---------------------------------------------------------------------------
+dnl Check if C compiler supports -c -o file.ooo
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_CC_O],
+[
+AC_MSG_CHECKING(whether $CC understand -c and -o together)
+set dummy $CC; ac_cc="`echo [$]2 |
+changequote(, )dnl
+		       sed -e 's/[^a-zA-Z0-9_]/_/g' -e 's/^[0-9]/_/'`"
+changequote([, ])dnl
+AC_CACHE_VAL(ac_cv_prog_cc_${ac_cc}_c_o,
+[echo 'foo(){}' > conftest.c
+# We do the test twice because some compilers refuse to overwrite an
+# existing .o file with -o, though they will create one.
+eval ac_cv_prog_cc_${ac_cc}_c_o=no
+ac_try='${CC-cc} -c conftest.c -o conftest.ooo 1>&AC_FD_CC'
+if AC_TRY_EVAL(ac_try) && test -f conftest.ooo && AC_TRY_EVAL(ac_try);
+then
+  ac_try='${CC-cc} -c conftest.c -o conftest.ooo 1>&AC_FD_CC'
+  if AC_TRY_EVAL(ac_try) && test -f conftest.ooo && AC_TRY_EVAL(ac_try);
+  then
+    eval ac_cv_prog_cc_${ac_cc}_c_o=yes
+  fi
+fi
+rm -f conftest*
+])dnl
+if eval "test \"`echo '$ac_cv_prog_cc_'${ac_cc}_c_o`\" = yes"; then
+	O2SHO=""
+	O2SAVE=""
+	SAVE2O=""
+	CC2O="-o $"'@'
+	AC_MSG_RESULT(yes)
+else
+	O2SHO="-mv \`basename "$'@'" .sho\`.o "$'@'
+	O2SAVE="-mv \`basename "$'@'" .sho\`.o \`basename "$'@'" .sho\`.o.save"
+	SAVE2O="-mv \`basename "$'@'" .sho\`.o.save \`basename "$'@'" .sho\`.o"
+	CC2O=""
+	AC_MSG_RESULT(no)
+fi
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Work out if functions in dynamically loadable libraries need leading _
+dnl Tests based on glib code and only valid for dlopen() mechanism
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_CHECK_LEADING_USCORE],
+[
+if test "$ac_cv_header_dlfcn_h" = "yes" -o "$HAVE_DLFCN_H" = "1"; then
+   AC_MSG_CHECKING(if symbols need underscore prepended in loadable modules)
+   tmpLIBS="$LIBS"
+   save_cflags="$CFLAGS"
+   LIBS="$LIBS $DLFCNLIBDIR"
+   CFLAGS="$CFLAGS $DLFCNINCDIR"
+   AC_CACHE_VAL(mh_cv_uscore,[
+   AC_TRY_RUN_NATIVE([
+   #include <dlfcn.h>
+   int mh_underscore_test (void) { return 42; }
+   int main() {
+     void *f1 = (void*)0, *f2 = (void*)0, *handle;
+     handle = dlopen ((void*)0, 0);
+     if (handle) {
+       f1 = dlsym (handle, "mh_underscore_test");
+       f2 = dlsym (handle, "_mh_underscore_test");
+     } return (!f2 || f1);
+   }],
+   mh_cv_uscore=yes,
+   mh_cv_uscore=no
+   )
+   ])
+   AC_MSG_RESULT($mh_cv_uscore)
+   if test "x$mh_cv_uscore" = "xyes"; then
+     AC_DEFINE(MODULES_NEED_USCORE)
+   fi
+   LIBS="$tmpLIBS"
+   CFLAGS="$save_cflags"
+fi
+])
+
+dnl ---------------------------------------------------------------------------
+dnl Determines the file extension for shared libraries
+dnl ---------------------------------------------------------------------------
+AC_DEFUN([MH_SHLPST],
+[
+AC_MSG_CHECKING(shared library/external function extensions)
+SHLPST=".so"
+MODPST=".so"
+AC_REQUIRE([AC_CANONICAL_SYSTEM])
+case "$target" in
+        *hp-hpux*)
+                SHLPST=".sl"
+                MODPST=".sl"
+                ;;
+        *ibm-aix*)
+                SHLPST=".a"
+                MODPST=".a"
+                ;;
+        *qnx*)
+                SHLPST=""
+                MODPST=""
+                ;;
+        *cygwin*)
+                SHLPST=".dll"
+                MODPST=".dll"
+                ;;
+        *darwin*)
+                SHLPST=".dylib"
+                MODPST=".dylib"
+                ;;
+esac
+AC_SUBST(SHLPST)
+AC_SUBST(MODPST)
+AC_MSG_RESULT($SHLPST/$MODPST)
+])
diff -Naur gdb-6.8/pdcurses/config.guess stsgdb-6.8/pdcurses/config.guess
--- gdb-6.8/pdcurses/config.guess	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/config.guess	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,1404 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+timestamp='2003-06-17'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Per Bothner <per@bothner.com>.
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# This script attempts to guess a canonical system name similar to
+# config.sub.  If it succeeds, it prints the system name on stdout, and
+# exits with 0.  Otherwise, it exits with 1.
+#
+# The plan is that this can be called by configure scripts if you
+# don't specify an explicit build system type.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit 0 ;;
+    --version | -v )
+       echo "$version" ; exit 0 ;;
+    --help | --h* | -h )
+       echo "$usage"; exit 0 ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep __ELF__ >/dev/null
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+	        os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit 0 ;;
+    amiga:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    arc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hp300:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    macppc:OpenBSD:*:*)
+	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme88k:OpenBSD:*:*)
+	echo m88k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvmeppc:OpenBSD:*:*)
+	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    pmax:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sgi:OpenBSD:*:*)
+	echo mipseb-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    wgrisc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    alpha:OSF1:*:*)
+	if test $UNAME_RELEASE = "V4.0"; then
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+	fi
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	exit 0 ;;
+    Alpha*:OpenVMS:*:*)
+	echo alpha-hp-vms
+	exit 0 ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit 0 ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit 0 ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit 0;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit 0 ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit 0 ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit 0 ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit 0;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit 0;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit 0 ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit 0 ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit 0 ;;
+    DRS?6000:UNIX_SV:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7 && exit 0 ;;
+	esac ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    i86pc:SunOS:5.*:*)
+	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit 0 ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit 0 ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit 0 ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+        exit 0 ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+        echo m68k-atari-mint${UNAME_RELEASE}
+	exit 0 ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+        echo m68k-milan-mint${UNAME_RELEASE}
+        exit 0 ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+        echo m68k-hades-mint${UNAME_RELEASE}
+        exit 0 ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+        echo m68k-unknown-mint${UNAME_RELEASE}
+        exit 0 ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit 0 ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit 0 ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit 0 ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit 0 ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c \
+	  && $dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
+	  && exit 0
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit 0 ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit 0 ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit 0 ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit 0 ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit 0 ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit 0 ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit 0 ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    AViiON:dgux:*:*)
+        # DG/UX returns AViiON for all architectures
+        UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+ 	exit 0 ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit 0 ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit 0 ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit 0 ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit 0 ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit 0 ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
+	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit 0 ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+		echo rs6000-ibm-aix3.2.5
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit 0 ;;
+    *:AIX:*:[45])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit 0 ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit 0 ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit 0 ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit 0 ;;                           # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit 0 ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit 0 ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit 0 ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit 0 ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+                    case "${sc_cpu_version}" in
+                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+                      532)                      # CPU_PA_RISC2_0
+                        case "${sc_kernel_bits}" in
+                          32) HP_ARCH="hppa2.0n" ;;
+                          64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+                        esac ;;
+                    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^              //' << EOF >$dummy.c
+
+              #define _HPUX_SOURCE
+              #include <stdlib.h>
+              #include <unistd.h>
+
+              int main ()
+              {
+              #if defined(_SC_KERNEL_BITS)
+                  long bits = sysconf(_SC_KERNEL_BITS);
+              #endif
+                  long cpu  = sysconf (_SC_CPU_VERSION);
+
+                  switch (cpu)
+              	{
+              	case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+              	case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+              	case CPU_PA_RISC2_0:
+              #if defined(_SC_KERNEL_BITS)
+              	    switch (bits)
+              		{
+              		case 64: puts ("hppa2.0w"); break;
+              		case 32: puts ("hppa2.0n"); break;
+              		default: puts ("hppa2.0"); break;
+              		} break;
+              #else  /* !defined(_SC_KERNEL_BITS) */
+              	    puts ("hppa2.0"); break;
+              #endif
+              	default: puts ("hppa1.0"); break;
+              	}
+                  exit (0);
+              }
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    # avoid double evaluation of $set_cc_for_build
+	    test -n "$CC_FOR_BUILD" || eval $set_cc_for_build
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E -) | grep __LP64__ >/dev/null
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit 0 ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c && $dummy && exit 0
+	echo unknown-hitachi-hiuxwe2
+	exit 0 ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit 0 ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit 0 ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit 0 ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit 0 ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit 0 ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit 0 ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit 0 ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+        exit 0 ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+        exit 0 ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+        exit 0 ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+        exit 0 ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+        exit 0 ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit 0 ;;
+    *:UNICOS/mp:*:*)
+	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
+	exit 0 ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+        exit 0 ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit 0 ;;
+    *:FreeBSD:*:*|*:GNU/FreeBSD:*:*)
+	# Determine whether the default compiler uses glibc.
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#if __GLIBC__ >= 2
+	LIBC=gnu
+	#else
+	LIBC=
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
+	exit 0 ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit 0 ;;
+    i*:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit 0 ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit 0 ;;
+    x86:Interix*:[34]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+	exit 0 ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit 0 ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit 0 ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit 0 ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit 0 ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit 0 ;;
+    *:GNU:*:*)
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit 0 ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit 0 ;;
+    arm*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit 0 ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    mips:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mipsel
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	;;
+    mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef mips64
+	#undef mips64el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=mips64el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=mips64
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
+	test x"${CPU}" != x && echo "${CPU}-unknown-linux-gnu" && exit 0
+	;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-gnu
+	exit 0 ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-gnu
+	exit 0 ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+        esac
+	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
+	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
+	exit 0 ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
+	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
+	  *)    echo hppa-unknown-linux-gnu ;;
+	esac
+	exit 0 ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-gnu
+	exit 0 ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux
+	exit 0 ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
+    x86_64:Linux:*:*)
+	echo x86_64-unknown-linux-gnu
+	exit 0 ;;
+    i*86:Linux:*:*)
+	# The BFD linker knows what the default object file format is, so
+	# first see if it will tell us. cd to the root directory to prevent
+	# problems with other programs or directories called `ld' in the path.
+	# Set LC_ALL=C to ensure ld outputs messages in English.
+	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
+			 | sed -ne '/supported targets:/!d
+				    s/[ 	][ 	]*/ /g
+				    s/.*supported targets: *//
+				    s/ .*//
+				    p'`
+        case "$ld_supported_targets" in
+	  elf32-i386)
+		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
+		;;
+	  a.out-i386-linux)
+		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
+		exit 0 ;;
+	  coff-i386)
+		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
+		exit 0 ;;
+	  "")
+		# Either a pre-BFD a.out linker (linux-gnuoldld) or
+		# one that does not give us useful --help.
+		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
+		exit 0 ;;
+	esac
+	# Determine whether the default compiler is a.out or elf
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <features.h>
+	#ifdef __ELF__
+	# ifdef __GLIBC__
+	#  if __GLIBC__ >= 2
+	LIBC=gnu
+	#  else
+	LIBC=gnulibc1
+	#  endif
+	# else
+	LIBC=gnulibc1
+	# endif
+	#else
+	#ifdef __INTEL_COMPILER
+	LIBC=gnu
+	#else
+	LIBC=gnuaout
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
+	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
+	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
+	;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit 0 ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+        # Unixware is an offshoot of SVR4, but it has its own version
+        # number series starting with 2...
+        # I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+        # Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit 0 ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit 0 ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit 0 ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit 0 ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit 0 ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit 0 ;;
+    i*86:*:5:[78]*)
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit 0 ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit 0 ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+        # uname -m prints for DJGPP always 'pc', but it prints nothing about
+        # the processor, so we play safe by assuming i386.
+	echo i386-pc-msdosdjgpp
+        exit 0 ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit 0 ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit 0 ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit 0 ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit 0 ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit 0 ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit 0 ;;
+    M68*:*:R3V[567]*:*)
+	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+          && echo i486-ncr-sysv4 && exit 0 ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit 0 ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit 0 ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit 0 ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit 0 ;;
+    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+                      # says <Richard.M.Bartel@ccMail.Census.GOV>
+        echo i586-unisys-sysv4
+        exit 0 ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit 0 ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit 0 ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit 0 ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit 0 ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit 0 ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+	        echo mips-nec-sysv${UNAME_RELEASE}
+	else
+	        echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+        exit 0 ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit 0 ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit 0 ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit 0 ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit 0 ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit 0 ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit 0 ;;
+    *:Darwin:*:*)
+	case `uname -p` in
+	    *86) UNAME_PROCESSOR=i686 ;;
+	    powerpc) UNAME_PROCESSOR=powerpc ;;
+	esac
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit 0 ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit 0 ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit 0 ;;
+    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit 0 ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit 0 ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit 0 ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit 0 ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit 0 ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit 0 ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit 0 ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit 0 ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit 0 ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit 0 ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit 0 ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit 0 ;;
+esac
+
+#echo '(No uname command or uname output not recognized.)' 1>&2
+#echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
+
+eval $set_cc_for_build
+cat >$dummy.c <<EOF
+#ifdef _SEQUENT_
+# include <sys/types.h>
+# include <sys/utsname.h>
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+          "4"
+#else
+	  ""
+#endif
+         ); exit (0);
+#endif
+#endif
+
+#if defined (__arm) && defined (__acorn) && defined (__unix)
+  printf ("arm-acorn-riscix"); exit (0);
+#endif
+
+#if defined (hp300) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+    struct utsname un;
+
+    uname(&un);
+
+    if (strncmp(un.version, "V2", 2) == 0) {
+	printf ("i386-sequent-ptx2\n"); exit (0);
+    }
+    if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+	printf ("i386-sequent-ptx1\n"); exit (0);
+    }
+    printf ("i386-sequent-ptx\n"); exit (0);
+
+#endif
+
+#if defined (vax)
+# if !defined (ultrix)
+#  include <sys/param.h>
+#  if defined (BSD)
+#   if BSD == 43
+      printf ("vax-dec-bsd4.3\n"); exit (0);
+#   else
+#    if BSD == 199006
+      printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#    else
+      printf ("vax-dec-bsd\n"); exit (0);
+#    endif
+#   endif
+#  else
+    printf ("vax-dec-bsd\n"); exit (0);
+#  endif
+# else
+    printf ("vax-dec-ultrix\n"); exit (0);
+# endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null && $dummy && exit 0
+
+# Apollos put the system type in the environment.
+
+test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit 0; }
+
+# Convex versions that predate uname can use getsysinfo(1)
+
+if [ -x /usr/convex/getsysinfo ]
+then
+    case `getsysinfo -f cpu_type` in
+    c1*)
+	echo c1-convex-bsd
+	exit 0 ;;
+    c2*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit 0 ;;
+    c34*)
+	echo c34-convex-bsd
+	exit 0 ;;
+    c38*)
+	echo c38-convex-bsd
+	exit 0 ;;
+    c4*)
+	echo c4-convex-bsd
+	exit 0 ;;
+    esac
+fi
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+    ftp://ftp.gnu.org/pub/gnu/config/
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -Naur gdb-6.8/pdcurses/config.h.in stsgdb-6.8/pdcurses/config.h.in
--- gdb-6.8/pdcurses/config.h.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/config.h.in	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,141 @@
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define to empty if the keyword does not work.  */
+#undef const
+
+/* Define if you don't have vprintf but do have _doprnt.  */
+#undef HAVE_DOPRNT
+
+/* Define if your compiler supports ANSI prototypes  */
+#undef HAVE_PROTO
+
+/* Define if you have the vprintf function.  */
+#undef HAVE_VPRINTF
+
+/* Define if you need to in order for stat and other things to work.  */
+#undef _POSIX_SOURCE
+
+/* Define as the return type of signal handlers (int or void).  */
+#undef RETSIGTYPE
+
+/* Define as the system defined limit for number of signals */
+#undef PDC_MAX_SIGNALS
+
+/* Define to `unsigned' if <sys/types.h> doesn't define.  */
+#undef size_t
+
+/* Define if you have the ANSI C header files.  */
+#undef STDC_HEADERS
+
+/* Define if you can safely include both <sys/time.h> and <time.h>.  */
+#undef TIME_WITH_SYS_TIME
+
+/* Define if your <sys/time.h> declares struct tm.  */
+#undef TM_IN_SYS_TIME
+
+/* Define if you have the memmove function.  */
+#undef HAVE_MEMMOVE
+
+/* Define if you have the poll function.  */
+#undef HAVE_POLL
+
+/* Define if you have the select function.  */
+#undef HAVE_SELECT
+
+/* Define if you have the usleep function.  */
+#undef HAVE_USLEEP
+
+/* Define if you have the vsscanf function.  */
+#undef HAVE_VSSCANF
+
+/* Define if you have the <errno.h> header file.  */
+#undef HAVE_ERRNO_H
+
+/* Define if you have the <fcntl.h> header file.  */
+#undef HAVE_FCNTL_H
+
+/* Define if you have the <limits.h> header file.  */
+#undef HAVE_LIMITS_H
+
+/* Define if you have the <memory.h> header file.  */
+#undef HAVE_MEMORY_H
+
+/* Define if you have the <stdarg.h> header file.  */
+#undef HAVE_STDARG_H
+
+/* Define if you have the <string.h> header file.  */
+#undef HAVE_STRING_H
+
+/* Define if you have the <sys/select.h> header file.  */
+#undef HAVE_SYS_SELECT_H
+
+/* Define if you have the <sys/time.h> header file.  */
+#undef HAVE_SYS_TIME_H
+
+/* Define if you have the <time.h> header file.  */
+#undef HAVE_TIME_H
+
+/* Define if you have the <unistd.h> header file.  */
+#undef HAVE_UNISTD_H
+
+/* following manually added as autoheader can't recognise them */
+
+/* Define if you have the <DECkeySym.h> header file.  */
+#undef HAVE_DECKEYSYM_H
+
+/* Define if you have the <Sunkeysym.h> header file.  */
+#undef HAVE_SUNKEYSYM_H
+
+/* Define if you have the <xpm.h> header file.  */
+#undef HAVE_XPM_H
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_DELETE
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_INSERT
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_END
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_DOWN
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_NEXT
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_LEFT
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_RIGHT
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_HOME
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_UP
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_PRIOR
+
+/* Define if you have this defined in <keysym.h>.  */
+#undef HAVE_XK_KP_BEGIN
+
+/* Define if you want to use Xaw3d library  */
+#undef USE_XAW3D
+
+/* Define if you want to use neXtaw library  */
+#undef USE_NEXTAW
+
+/* Define if you want to include LATIN1 key support */
+#undef INCLUDE_LATIN1
+
+/* Define if you want to build XCurses with threads */
+#undef USE_THREADS
+
+/* Define if you want to build XCurses with processes */
+#undef USE_PROCESSES
+
+/* Define XPointer is typedefed in X11/Xlib.h */
+#undef XPOINTER_TYPEDEFED
diff -Naur gdb-6.8/pdcurses/config.sub stsgdb-6.8/pdcurses/config.sub
--- gdb-6.8/pdcurses/config.sub	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/config.sub	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,1504 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+#   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
+
+timestamp='2003-06-17'
+
+# This file is (in principle) common to ALL GNU software.
+# The presence of a machine in this file suggests that SOME GNU software
+# can handle that machine.  It does not imply ALL GNU software can.
+#
+# This file is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330,
+# Boston, MA 02111-1307, USA.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Please send patches to <config-patches@gnu.org>.  Submit a context
+# diff and a properly formatted ChangeLog entry.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
+Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit 0 ;;
+    --version | -v )
+       echo "$version" ; exit 0 ;;
+    --help | --h* | -h )
+       echo "$usage"; exit 0 ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit 0;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis)
+		os=
+		basic_machine=$1
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+ 	-chorusrdb)
+ 		os=-chorusrdb
+		basic_machine=$1
+ 		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
+	| c4x | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k \
+	| m32r | m68000 | m68k | m88k | mcore \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64vr | mips64vrel \
+	| mips64orion | mips64orionel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| msp430 \
+	| ns16k | ns32k \
+	| openrisc | or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
+	| pyramid \
+	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
+	| strongarm \
+	| tahoe | thumb | tic4x | tic80 | tron \
+	| v850 | v850e \
+	| we32k \
+	| x86 | xscale | xstormy16 | xtensa \
+	| z8k)
+		basic_machine=$basic_machine-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12)
+		# Motorola 68HC11/12.
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* \
+	| bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
+	| clipper-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* \
+	| m32r-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | mcore-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipstx39-* | mipstx39el-* \
+	| msp430-* \
+	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
+	| pyramid-* \
+	| romp-* | rs6000-* \
+	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
+	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
+	| v850-* | v850e-* | vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
+	| xtensa-* \
+	| ymp-* \
+	| z8k-*)
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+# I'm not sure what "Sysv32" means.  Should this be sysv3.2?
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	mingw32)
+		basic_machine=i386-pc
+		os=-mingw32
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	mmix*)
+		basic_machine=mmix-knuth
+		os=-mmixware
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	nv1)
+		basic_machine=nv1-cray
+		os=-unicosmp
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	or32 | or32-*)
+		basic_machine=or32-unknown
+		os=-coff
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc)	basic_machine=powerpc-unknown
+		;;
+	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tic54x | c54x*)
+		basic_machine=tic54x-unknown
+		os=-coff
+		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparc | sparcv9 | sparcv9b)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+        # First match some system type aliases
+        # that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
+	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* \
+	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-kaos*)
+		os=-kaos
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		# This also exists in the configure program, but was not the
+		# default.
+		# os=-sunos4
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-ibm)
+		os=-aix
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit 0
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -Naur gdb-6.8/pdcurses/configure stsgdb-6.8/pdcurses/configure
--- gdb-6.8/pdcurses/configure	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/configure	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,2126 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.59.
+#
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+
+# Name of the host.
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+exec 6>&1
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_config_libobj_dir=.
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+
+ac_unique_file="Makefile.in"
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS LIBOBJS LTLIBOBJS CFLAGS LOCAL_CFLAGS LOCAL_LDFLAGS LOCAL_DEFS AR ARFLAGS'
+ac_subst_files=''
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datadir='${prefix}/share'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
+
+ac_prev=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval "$ac_prev=\$ac_option"
+    ac_prev=
+    continue
+  fi
+
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_option in
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
+    datadir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
+
+  -enable-* | --enable-*)
+    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
+   { (exit 1); exit 1; }; }
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
+
+  -without-* | --without-*)
+    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid package name: $ac_package" >&2
+   { (exit 1); exit 1; }; }
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) { echo "$as_me: error: unrecognized option: $ac_option
+Try \`$0 --help' for more information." >&2
+   { (exit 1); exit 1; }; }
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
+      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
+   { (exit 1); exit 1; }; }
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  { echo "$as_me: error: missing argument to $ac_option" >&2
+   { (exit 1); exit 1; }; }
+fi
+
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
+$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$0" : 'X\(//\)[^/]' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$0" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r $srcdir/$ac_unique_file; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+_ACEOF
+
+  cat <<_ACEOF
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+			  [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+			  [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR           user executables [EPREFIX/bin]
+  --sbindir=DIR          system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
+  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
+  --libdir=DIR           object code libraries [EPREFIX/lib]
+  --includedir=DIR       C header files [PREFIX/include]
+  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
+_ACEOF
+
+  cat <<\_ACEOF
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+_ACEOF
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d $ac_dir || continue
+    ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
+    else
+      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi
+    cd $ac_popdir
+  done
+fi
+
+test -n "$ac_init_help" && exit 0
+if $ac_init_version; then
+  cat <<\_ACEOF
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit 0
+fi
+exec 5>config.log
+cat >&5 <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  echo "PATH: $as_dir"
+done
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_sep=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
+    2)
+      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
+      ;;
+    esac
+  done
+done
+$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
+$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    cat <<\_ASBOX
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+_ASBOX
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+{
+  (set) 2>&1 |
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      sed -n \
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
+    *)
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+}
+    echo
+
+    cat <<\_ASBOX
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+_ASBOX
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      cat <<\_ASBOX
+## ------------- ##
+## Output files. ##
+## ------------- ##
+_ASBOX
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      cat <<\_ASBOX
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+_ASBOX
+      echo
+      sed "/^$/d" confdefs.h | sort
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      echo "$as_me: caught signal $ac_signal"
+    echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+     ' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer explicitly selected file to automatically selected ones.
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
+fi
+for ac_site_file in $CONFIG_SITE; do
+  if test -r "$ac_site_file"; then
+    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
+echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file"
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
+    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
+echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
+    esac
+  fi
+else
+  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
+echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
+echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
+echo "$as_me:   former value:  $ac_old_val" >&2;}
+	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
+echo "$as_me:   current value: $ac_new_val" >&2;}
+	ac_cache_corrupted=:
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
+echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+          ac_config_files="$ac_config_files Makefile"
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, don't put newlines in cache variables' values.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+{
+  (set) 2>&1 |
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
+      # `set' does not quote correctly, so add quotes (double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \).
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;;
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
+      ;;
+    esac;
+} |
+  sed '
+     t clear
+     : clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
+    cat confcache >$cache_file
+  else
+    echo "not updating unwritable cache $cache_file"
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then we branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+cat >confdef2opt.sed <<\_ACEOF
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\),-D\1=\2,g
+t quote
+d
+: quote
+s,[	 `~#$^&*(){}\\|;'"<>?],\\&,g
+s,\[,\\&,g
+s,\],\\&,g
+s,\$,$$,g
+p
+_ACEOF
+# We use echo to avoid assuming a particular line-breaking character.
+# The extra dot is to prevent the shell from consuming trailing
+# line-breaks from the sub-command output.  A line-break within
+# single-quotes doesn't work because, if this script is created in a
+# platform that uses two characters for line-breaks (e.g., DOS), tr
+# would break.
+ac_LF_and_DOT=`echo; echo .`
+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr "$ac_LF_and_DOT" ' .'`
+rm -f confdef2opt.sed
+
+
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+
+: ${CONFIG_STATUS=./config.status}
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
+echo "$as_me: creating $CONFIG_STATUS" >&6;}
+cat >$CONFIG_STATUS <<_ACEOF
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+SHELL=\${CONFIG_SHELL-$SHELL}
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+## --------------------- ##
+## M4sh Initialization.  ##
+## --------------------- ##
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
+fi
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# Support unset when possible.
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  as_unset=unset
+else
+  as_unset=false
+fi
+
+
+# Work around bugs in pre-3.0 UWIN ksh.
+$as_unset ENV MAIL MAILPATH
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+for as_var in \
+  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
+  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
+  LC_TELEPHONE LC_TIME
+do
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
+    eval $as_var=C; export $as_var
+  else
+    $as_unset $as_var
+  fi
+done
+
+# Required to use basename.
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+
+# Name of the executable.
+as_me=`$as_basename "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+
+
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
+
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
+
+  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
+  # uniformly replaced by the line number.  The first 'sed' inserts a
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
+  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
+    sed '
+      N
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
+      t loop
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
+    ' >$as_me.lineno &&
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
+   { (exit 1); exit 1; }; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
+  # Exit status is that of the last command.
+  exit
+}
+
+
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
+esac
+
+if expr a : '\(a\)' >/dev/null 2>&1; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+rm -f conf$$ conf$$.exe conf$$.file
+echo >conf$$.file
+if ln -s conf$$.file conf$$ 2>/dev/null; then
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
+    as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
+elif ln conf$$.file conf$$ 2>/dev/null; then
+  as_ln_s=ln
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.file
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p=:
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_executable_p="test -f"
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
+exec 6>&1
+
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.59.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
+_ACEOF
+
+# Files that config.status was made for.
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+ac_cs_usage="\
+\`$as_me' instantiates files from templates according to the
+current configuration.
+
+Usage: $0 [OPTIONS] [FILE]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number, then exit
+  -q, --quiet      do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+  --file=FILE[:TEMPLATE]
+		   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Report bugs to <bug-autoconf@gnu.org>."
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
+
+Copyright (C) 2003 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+srcdir=$srcdir
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+# If no file are specified by the user, then we need to provide default
+# value.  By we need to know if files were specified by the user.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  -*)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
+    ac_need_defaults=false;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; } ;;
+
+  *) ac_config_targets="$ac_config_targets $1" ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+if \$ac_cs_recheck; then
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+fi
+
+_ACEOF
+
+
+
+
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_config_target in $ac_config_targets
+do
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
+echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason to put it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Create a temporary directory, and hook for its removal unless debugging.
+$debug ||
+{
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
+  trap '{ (exit 1); exit 1; }' 1 2 13 15
+}
+
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
+{
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
+} ||
+{
+   echo "$me: cannot create a temporary directory in ." >&2
+   { (exit 1); exit 1; }
+}
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<_ACEOF
+
+#
+# CONFIG_FILES section.
+#
+
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
+  fi
+fi # test -n "$CONFIG_FILES"
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
+  esac
+
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF
+  sed "$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+{ (exit 0); exit 0; }
+_ACEOF
+chmod +x $CONFIG_STATUS
+ac_clean_files=$ac_clean_files_save
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || { (exit 1); exit 1; }
+fi
+
+
+
+
+
+
+
+
+
diff -Naur gdb-6.8/pdcurses/configure.in stsgdb-6.8/pdcurses/configure.in
--- gdb-6.8/pdcurses/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/configure.in	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,14 @@
+dnl Copyright (C) 2006 STMicroelectronics
+dnl Process this file with autoconf to produce a configure script.
+AC_PREREQ(2.5)
+AC_INIT(Makefile.in)
+
+AC_OUTPUT(Makefile)
+
+AC_SUBST(CFLAGS)
+AC_SUBST(LOCAL_CFLAGS)
+AC_SUBST(LOCAL_LDFLAGS)
+AC_SUBST(LOCAL_DEFS)
+
+AC_SUBST(AR)
+AC_SUBST(ARFLAGS)
diff -Naur gdb-6.8/pdcurses/curses.h stsgdb-6.8/pdcurses/curses.h
--- gdb-6.8/pdcurses/curses.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/curses.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,2104 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+$Id: curses.h,v 1.60 2005/12/28 10:41:23 wmcbrine Exp $
+*/
+/*
+*----------------------------------------------------------------------
+*				PDCurses
+*----------------------------------------------------------------------
+* MH
+*	991212	2.4
+*		Key modifiers pressed by themselves are now returned as keys
+*			KEY_SHIFT_L KEY_SHIFT_R
+*			KEY_CONTROL_L KEY_CONTROL_R
+*			KEY_ALT_L KEY_ALT_R
+*			This works on Win32 and X11 ports only
+*		Added support for lcc-win32, supplied by Matthias Burian
+*		Added support for MingW32, and CygnusW32 compilers
+*		Added clipboard support for X11, Win32 and OS/2 ports
+*		Added ability to get to the input file descriptor
+*		New function for X11; Xinitscr() which allows standard X11
+*			switches to be passed to the application
+*		Added X11 shared library support
+*
+* MH
+*	960920	2.3	Added more System V R4 functions
+*
+*			Rewrote X11 port
+*
+*			Added Win32 port - original port by Chris Szurgot
+*				some updates by Mark Hessling
+*				some updates by Gurusamy Sarathy
+*
+*			slk() functions added by Kim Huron
+*
+*			Support for more and newer versions of compilers
+*
+*			Added mouse support for X11 and Win32 ports
+*
+*			Size of chtype now long
+*
+* MH
+*	950126	2.2	Added more System V R4 functions
+*
+*			Added beta Xwindows port
+*
+*			Changed chtype to long
+*
+*			Incorporated panels library
+*
+*			Support for more and newer versions of compilers
+*
+* MH
+*	930531	2.1	Added support for djgpp
+*
+*			Added beta Unix version
+*
+*			Added OS/2 DLL support.
+*
+*			Changed behaviour of overlay(), overwrite() and typeahead()
+*
+*	921120	2.0	Changed #if to #ifdef/#if defined to make it
+*			easier to add new platforms/compilers.
+*
+*			Added System V colour support.
+*
+*			Added OS/2 port.
+*-------
+* Frotz
+*	911221	2.0 pre-beta	Changed back from short to int. (int is the
+*			correct size for the default platform.  Short
+*			might be too short on some platforms.  This
+*			is more portable.  I, also, made this mistake.)
+*
+*			Many functions are now macros.  If you want
+*			the real thing, #undef the macro. (X/Open
+*			requirement.)
+*
+*			Merged many sources into current release.
+*
+*			Added many X/Open routines (not quite all yet).
+*
+*			Added internal documentation to all routines.
+*
+*			Added a HISTORY file to the environment.
+*
+*			Added a CONTRIB file to the environment.
+*-------
+* bl	900114	1.4	Window origin mod in overlay() and overwrite(), on
+*			public (and very reasonable) request. Swapped
+*			#define'd values of OK and ERR; OK now 1, and
+*			ERR is 0/NULL. Conforms better to UNIX
+*			versions.  borderchars[] removed from WINDOW
+*			struct since the border() functions were
+*			redefined. Use of short wherever possible.
+*			Portability improvements, mispelled name of
+*			[w]setscrreg().
+*
+*	881005	1.3	All modules lint-checked with MSC '-W3' and
+*			turbo'C' '-w -w-pro' switches. Support for
+*			border(), wborder() functions.
+*
+*	881002	1.2	Rcsid[] string in all modules, for maintenance.
+*
+*	880306	1.1	'Raw' output routines, revision info in curses.h.
+*
+*	870515	1.0	Initial Release.
+*
+*----------------------------------------------------------------------
+*/
+
+#ifndef  __PDCURSES__
+#define	__PDCURSES__ 1
+
+/*man-start*********************************************************************
+
+All defines are "defined" here.  All compiler and environment
+specific definitions are defined into generic class defines.
+These defines are to be given values so that the code can
+rely on #if, rather than a complicated set of #if defined() or
+#ifdefs...
+
+PDCurses definitions list:  (Only define those needed)
+
+	REGISTERWINDOWS True for auto window update registery.
+	FAST_VIDEO      True if display is memory mapped, or
+	                we can utilize the fast video update routines.
+	DOS             True if compiling for DOS.
+	OS2             True if compiling for OS/2.
+	WIN32           True if compiling for Windoze 95 or Windoze NT
+	FLEXOS          True if compiling for Flexos.
+	HC              True if using a Metaware compiler.
+	TC              True if using a Borland compiler.
+	MSC             True if using a Microsoft compiler.
+	HAVE_PROTO      True if the compiler supports ANSI prototypes.
+	CPLUSPLUS       True if the compiler supports C++.
+	PDC_BUILD       Defines API build version.
+
+PDCurses portable platform definitions list:
+
+	PDCURSES        Enables access to PDCurses-only routines.
+	XOPEN           Always true.
+	SYSVcurses      True if you are compiling for SYSV portability.
+	BSDcurses       True if you are compiling for BSD portability.
+	PDCURSES_WCLR   Makes behaviour of wclrtoeol() and wclrtoeof()
+	                unique to PDCurses. By default Unix behavior is set.
+	                See notes in wclrtoeol() and wclrtoeof().
+**man-end**********************************************************************/
+
+#define PDC_BUILD 2701
+#define	PDCURSES	1	/* PDCurses-only routines	*/
+#define	XOPEN		1	/* X/Open Curses routines	*/
+#define	SYSVcurses	1	/* System V Curses routines	*/
+#define	BSDcurses	1	/* BSD Curses routines		*/
+#define	CHTYPE_LONG	1	/* size of chtype; long		*/
+
+#define	PDC_CDECL		/* default define this as empty */
+
+/*----------------------------------------
+*       BORLAND COMPILERS       Turbo C[++], Borland C[++]
+*
+*       Borland definitions:
+*               TC
+*               DOS
+*               OS2
+*               CPLUSPLUS
+*
+*               __TURBOC__, __MSDOS__,
+*               __OS2__ and __WIN32__
+*               are predefined by compiler.
+*/
+#ifdef __TURBOC__              /* Borland gives defines this as a value*/
+#  define TC    __TURBOC__     /* Define a value for TC                */
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1       /* Borland supports ANSI C prototypes   */
+#  endif
+#  ifdef __MSDOS__
+#    define DOS 6              /* Major release of DOS supported       */
+#    include <bios.h>
+#    include <dos.h>
+#  endif
+#  ifdef __OS2__
+#    define OS2 3              /* Major release of OS/2 supported      */
+#    define INCL_VIO
+#    define INCL_KBD
+#    include <os2.h>
+#  endif
+#  ifdef __WIN32__
+#    ifdef INCLUDE_WINDOWS_H           /* only include for WIN32 files */
+#      include <windows.h>
+#      ifdef MOUSE_MOVED                 /* get rid of Windows #define */
+#        undef MOUSE_MOVED
+#      endif
+#    endif
+#    ifndef WIN32
+#      define WIN32 1
+#    endif
+#  endif
+#  if __TURBOC__ >= 0x290
+#    ifdef  __BCPLUSPLUS__
+#      define CPLUSPLUS   1    /* Define that we are compiling C++.    */
+#    endif
+#    ifdef  __TCPLUSPLUS__
+#      define CPLUSPLUS   1    /* Define that we are compiling C++.    */
+#    endif
+#    ifdef  __CPLUSPLUS__
+#      define CPLUSPLUS   1    /* Define that we are compiling C++.    */
+#    endif
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_STRING_H
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#  ifndef HAVE_VSSCANF
+#    define HAVE_VSSCANF                             /* have vsscanf() */
+#  endif
+#endif
+
+
+/*----------------------------------------
+*       METAWARE COMPILERS      High C
+*
+*       Metaware definitions:
+*               HC
+*               DOS
+*               FLEXOS
+*/
+#ifdef __HIGHC__
+#  define HC    1
+#  pragma off(prototype_override_warnings)
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1      /* Metaware supports ANSI C prototypes   */
+#  endif
+#  ifdef __MSDOS__
+#    define DOS 6              /* Major release of DOS supported       */
+#    include <bios.h>
+#    include <dos.h>
+#  endif
+#  ifdef __FLEXOS__            /* define this on the command line      */
+#    define FLEXOS 2           /* or latest major release value.       */
+#  endif
+#endif
+
+/*----------------------------------------
+*       MICROSOFT COMPILERS      MSC
+*
+*       Microsoft definitions:
+*               MSC
+*               DOS || OS2
+*/
+#ifdef _MSC_VER                                 /* defined by compiler */
+#  define MSC   1
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1     /* Microsoft supports ANSI C prototypes   */
+#  endif
+#  ifdef __OS2__                /* You will have to define in makefile */
+#    define USE_OS2_H 1             /* Use the os2.h for the compiler  */
+#    define OS2 3                   /* Major release of OS/2 supported */
+#    define INCL_VIO
+#    define INCL_KBD
+#    include <os2.h>
+#    define FARKeyword far
+#    define APIRET USHORT
+#  else                            /* no __OS2__ define, so assume DOS */
+#    ifdef _WIN32	
+#      ifndef WIN32
+#        define WIN32
+#      endif
+#      ifdef INCLUDE_WINDOWS_H         /* only include for WIN32 files */
+#        include <windows.h>
+#        ifdef MOUSE_MOVED               /* get rid of Windows #define */
+#          undef MOUSE_MOVED
+#        endif
+#      endif
+#      ifndef HAVE_MEMORY_H
+#        define HAVE_MEMORY_H                       /* have <memory.h> */
+#      endif
+#      ifndef HAVE_STDARG_H
+#        define HAVE_STDARG_H                       /* have <stdarg.h> */
+#      endif
+#    else	
+#      define DOS 6                  /* Major release of DOS supported */
+#      include <bios.h>
+#      include <dos.h>
+#      undef  HAVE_VSSCANF        /* vsscanf() function NOT in library */
+#    endif
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#endif
+
+/*----------------------------------------
+*       MICROSOFT QUICK C COMPILERS      QC
+*
+*/
+#ifdef _QC                                      /* defined by compiler */
+#  define MSC   1
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1        /* QuickC supports ANSI C prototypes   */
+#  endif
+#  define DOS 6                      /* Major release of DOS supported */
+#  include <bios.h>
+#  include <dos.h>
+#  undef  HAVE_VSSCANF            /* vsscanf() function NOT in library */
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#endif
+
+/*----------------------------------------
+*       TOPSPEED compilers     TSC
+*
+*       TOPSPEED definitions:
+*               TSC
+*               DOS || OS2
+*/
+#ifdef __TSC__                   /* You may have to define in makefile */
+#  define TSC   1
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1      /* TopSpeed supports ANSI C prototypes   */
+#  endif
+#  ifdef __OS2__
+#    define OS2 3                   /* Major release of OS/2 supported */
+#    define INCL_VIO
+#    define INCL_KBD
+#    include <os2.h>
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#endif
+
+/*----------------------------------------
+*       IBM C Set/2 Compiler   CSET2
+*
+*       IBM definitions:
+*               CSET2
+*               OS2
+*/
+#ifdef __IBMC__
+#  define CSET2 1
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1        /* C Set/2 supports ANSI C prototypes  */
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#  ifdef __OS2__
+#    define OS2 3                   /* Major release of OS/2 supported */
+#    define INCL_VIO
+#    define INCL_KBD
+#    include <os2.h>
+#  endif
+#endif
+
+/*----------------------------------------
+*       GNU compilers     emx
+*
+*       emx definitions:
+*               EMX
+*               OS2
+*/
+#ifdef __EMX__                   /* You may have to define in makefile */
+#  define EMX   1
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1            /* emx supports ANSI C prototypes  */
+#  endif
+#  ifndef __OS2__
+#    define __OS2__                    /* EMX does not define this :-( */
+#  endif
+#  define OS2 3                     /* Major release of OS/2 supported */
+#  define CURSES__32BIT__
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_STRING_H
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_UNISTD_H
+#    define HAVE_UNISTD_H                           /* have <unistd.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#  ifndef HAVE_VSSCANF
+#    define HAVE_VSSCANF                             /* have vsscanf() */
+#  endif
+#  if defined(EMXVIDEO)
+#    include <stdlib.h>
+#    include <sys/video.h>
+#  else
+#    define INCL_VIO
+#    define INCL_KBD
+#    include <os2.h>
+#  endif
+#endif
+
+/*----------------------------------------
+*       GNU compilers     djgpp
+*
+*		djgpp definitions:
+*				__DJGPP__
+*				GO32 (deprecated)
+*				DOS
+*/
+#ifdef __DJGPP__ 			  /* You may have to define in makefile */
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1         /* DJGPP supports ANSI C prototypes   */
+#  endif
+#  define DOS	6
+#  include <dos.h>
+#  ifdef __FLEXOS__ 		   /* define this on the command line	   */
+#    define FLEXOS 2           /* or latest major release value.       */
+#  endif
+#  define CURSES__32BIT__
+#  ifdef _cplusplus
+#    define CPLUSPLUS 1
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_STRING_H
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_UNISTD_H
+#    define HAVE_UNISTD_H                           /* have <unistd.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#  ifndef HAVE_USLEEP
+#    define HAVE_USLEEP                               /* have usleep() */
+#  endif
+#endif
+
+
+/*----------------------------------------
+*       GNU compilers     Cygnus Win32
+*
+*		cygnus definitions:
+*				WIN32
+*/
+#ifdef __CYGWIN32__  /* You may have to define in makefile */
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1    /* Cygnuc GCC supports ANSI C prototypes   */
+#  endif
+#  ifdef INCLUDE_WINDOWS_H
+#    include <windows.h>
+#    ifdef MOUSE_MOVED
+#      undef MOUSE_MOVED
+#    endif
+#  endif
+#  if !defined( WIN32 ) && !defined(XCURSES)
+#    define WIN32
+#  endif
+#  ifndef INT_MAX
+#    define INT_MAX 32762
+#  endif
+#  define CURSES__32BIT__
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_STRING_H
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_UNISTD_H
+#    define HAVE_UNISTD_H                           /* have <unistd.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#endif
+
+/*----------------------------------------
+*       GNU compilers     Ming Win32
+*
+*		Ming definitions:
+*				WIN32
+*/
+#ifdef __MINGW32__
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1    /* Ming GCC supports ANSI C prototypes   */
+#  endif
+#  ifdef INCLUDE_WINDOWS_H
+#    include <windows.h>
+#    ifdef MOUSE_MOVED
+#      undef MOUSE_MOVED
+#    endif
+#  endif
+#  ifdef _WINDOWS_H
+#    include <windows.h>
+#    ifdef MOUSE_MOVED
+#      undef MOUSE_MOVED
+#    endif
+#  endif
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#  define CURSES__32BIT__
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_STRING_H                             /* have <string.h> */
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#endif
+
+/*----------------------------------------
+*       LCC WIN32
+*
+*/
+#ifdef __LCC__  /* should already be defined by the compiler */
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1         /* LCC-Win32 supports ANSI C prototypes   */
+#  endif
+#  ifdef INCLUDE_WINDOWS_H
+#    include <windows.h>
+#    ifdef MOUSE_MOVED
+#      undef MOUSE_MOVED
+#    endif
+#  endif
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_STRING_H                             /* have <string.h> */
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#endif
+
+/*----------------------------------------
+*       Watcom C/C++ 10.6 compiler
+*
+*       WATCOM definitions:
+*               WATCOMC
+*               OS2
+*               WIN32
+*/
+#ifdef __WATCOMC__
+#  define WATCOMC  1
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1      /* Watcom C supports ANSI C prototypes   */
+#  endif
+#  define CURSES__32BIT__
+#  if defined( __DOS__ ) || defined( __DOS4G__ )
+#    define DOS 7                    /* Major release of DOS supported */
+#    include <bios.h>
+#    include <dos.h>
+#    include <i86.h>
+#    ifdef __386__
+#      define int86 int386
+#      define int86x int386x
+#    endif
+#  endif
+#  if defined( __OS2__ ) || defined( __OS2V2__ )
+#    define OS2 3                   /* Major release of OS/2 supported */
+#    define CURSES__32BIT__
+#    define INCL_VIO
+#    define INCL_KBD
+#    include <os2.h>
+#    ifndef  DISPLAY_MONOCHROME
+#     define DISPLAY_MONOCHROME 0
+#    endif
+#    ifndef  DISPLAY_CGA
+#     define DISPLAY_CGA        1
+#    endif
+#    ifndef  DISPLAY_EGA
+#     define DISPLAY_EGA        2
+#    endif
+#    ifndef  DISPLAY_VGA
+#     define DISPLAY_VGA        3
+#    endif
+#    ifndef  DISPLAY_8514A
+#     define DISPLAY_8514A      7
+#    endif
+#    ifndef  DISPLAY_XGA
+#     define DISPLAY_XGA        9
+#    endif
+#  endif
+#  if defined( __NT__ ) || defined ( WIN32 )
+#    ifdef INCLUDE_WINDOWS_H
+#      include <windows.h>
+#      ifdef MOUSE_MOVED
+#        undef MOUSE_MOVED
+#      endif
+#    endif
+#    ifndef WIN32
+#      define WIN32
+#    endif
+#    ifdef PDC_CDECL
+#      undef PDC_CDECL
+#      define PDC_CDECL cdecl   /* needed for compatibility to other systems */
+#    endif
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#  ifndef HAVE_MEMORY_H
+#    define HAVE_MEMORY_H                           /* have <memory.h> */
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H                           /* have <stdarg.h> */
+#  endif
+#  ifndef HAVE_STRING_H
+#    define HAVE_STRING_H
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE                             /* have memmove() */
+#  endif
+#  ifndef HAVE_VSSCANF
+#    define HAVE_VSSCANF                             /* have vsscanf() */
+#  endif
+#endif
+
+#if 0
+/*----------------------------------------
+*       gcc under UNIX
+*
+*       GNU definitions:
+*               UNIX
+*/
+#ifdef UNIX
+#  define HAVE_PROTO 1                  /* GNU C supports ANSI C prototypes  */
+#  ifdef SUNOS
+#    define NO_VSSCANF
+#    define NO_MEMMOVE
+#    undef BSD
+#  endif
+#  ifdef linux
+#    undef BSD
+#  endif
+#endif
+#endif
+
+/*----------------------------------------
+*       MicroWay NDP C/C++ 386 4.2.0 compiler
+*/
+#ifdef MX386
+#  define HAVE_PROTO 1
+#  define NDP	1
+#  include 	<bios.h>
+#  ifdef DOS
+#    define MK_FP(seg,ofs)	( (((int) (seg)) << 4) + ((int) (ofs)) )
+#    ifdef __i860
+       typedef void _int;
+#    else
+       typedef int      _int;
+#    endif
+#  endif
+#    undef  NO_VSSCANF            /* vsscanf() function NOT in library */
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H                           /* have <limits.h> */
+#  endif
+#endif
+
+/*
+* HI-TECH COMPILERS Pacific C
+*
+* Hi-Tech definitions:
+*  PC
+*
+*  __PACIFIC__, DOS
+*  are predefined by compiler.
+*/
+#ifdef __PACIFIC__
+#  define PC    __PACIFIC__
+#  ifndef HAVE_PROTO
+#    define HAVE_PROTO 1
+#  endif
+#  include <dos.h>
+#  include <ctype.h>
+#  include <string.h>
+#  include <stdlib.h>
+#  ifndef __SMALL__
+#    define __SMALL__
+#  endif
+#  ifndef HAVE_LIMITS_H
+#    define HAVE_LIMITS_H
+#  endif
+#  ifndef HAVE_STDARG_H
+#    define HAVE_STDARG_H
+#  endif
+#  ifndef HAVE_MEMMOVE
+#    define HAVE_MEMMOVE
+#  endif
+#  ifndef HAVE_VSSCANF
+#    define HAVE_VSSCANF
+#  endif
+#endif
+
+/*---------------------------------------------------------------------*/
+#include <stdio.h>		/* Required by X/Open usage below	*/
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+ extern "C"
+   {
+# define bool _bool
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *	PDCurses Manifest Constants
+ *
+ */
+#ifndef FALSE			/* booleans		 */
+#  define	FALSE	0
+#endif
+#ifndef	TRUE			/* booleans		 */
+#  define	TRUE	1
+#endif
+#ifndef	NULL
+#  define NULL	(void*)0	/* Null pointer		 */
+#endif
+#ifndef	ERR
+#  define	ERR	(-1)		/* general error flag	 */
+#endif
+#ifndef	OK
+#  define	OK	0		/* general OK flag	 */
+#endif
+
+
+/*----------------------------------------------------------------------
+ *
+ *	PDCurses Type Declarations
+ *
+ */
+typedef unsigned char bool;	/* PDCurses Boolean type	*/
+
+#ifdef CHTYPE_LONG
+typedef unsigned long chtype;	/* 16-bit attr + 16-bit char	*/
+#else
+typedef unsigned short chtype;	/* 8-bit attr + 8-bit char	*/
+#endif
+
+/*----------------------------------------------------------------------
+ * This defines a new type for attributes.
+ *
+ */
+typedef chtype attr_t;
+
+/*----------------------------------------------------------------------
+ * Define our mouse interface - same as SYSVR4 (with extensions)
+ */
+
+typedef struct
+{
+	int x;           /* absolute column, 0 based, measured in characters */
+	int y;           /* absolute row, 0 based, measured in characters */
+	short button[3]; /* state of each button */
+	int changes;     /* flags indicating what has changed with the mouse */
+} MOUSE_STATUS;
+
+
+#define BUTTON_RELEASED        0000
+#define BUTTON_PRESSED         0001
+#define BUTTON_CLICKED         0002
+#define BUTTON_DOUBLE_CLICKED  0003
+#define BUTTON_TRIPLE_CLICKED  0004
+#define BUTTON_MOVED           0005  /* PDCurses enhancement */
+#define WHEEL_SCROLLED         0006  /* PDCurses enhancement */
+#define BUTTON_ACTION_MASK     0007  /* PDCurses enhancement */
+#define BUTTON_SHIFT           0010  /* PDCurses enhancement */
+#define BUTTON_CONTROL         0020  /* PDCurses enhancement */
+#define BUTTON_ALT             0040  /* PDCurses enhancement */
+#define BUTTON_MODIFIER_MASK   0070  /* PDCurses enhancement */
+
+#define MOUSE_X_POS            (Mouse_status.x)
+#define MOUSE_Y_POS            (Mouse_status.y)
+/*
+ * Bits associated with the .changes field:
+ *   3         2         1         0
+ * 210987654321098765432109876543210
+ *                                 1 <- button 1 has changed
+ *                                10 <- button 2 has changed
+ *                               100 <- button 3 has changed
+ *                              1000 <- mouse has moved
+ *                             10000 <- mouse position report
+ *                            100000 <- mouse wheel up
+ *                           1000000 <- mouse wheel down
+ */
+#define PDC_MOUSE_MOVED         8
+#define PDC_MOUSE_POSITION     16
+#define PDC_MOUSE_WHEEL_UP     32
+#define PDC_MOUSE_WHEEL_DOWN   64
+#define A_BUTTON_CHANGED       (Mouse_status.changes & 7)
+#define MOUSE_MOVED            (Mouse_status.changes & PDC_MOUSE_MOVED)
+#define MOUSE_POS_REPORT       (Mouse_status.changes & PDC_MOUSE_POSITION)
+#define BUTTON_CHANGED(x)      (Mouse_status.changes & (1 << ((x) - 1)))
+#define BUTTON_STATUS(x)       (Mouse_status.button[(x)-1])
+#define MOUSE_WHEEL_UP         (Mouse_status.changes & PDC_MOUSE_WHEEL_UP)
+#define MOUSE_WHEEL_DOWN       (Mouse_status.changes & PDC_MOUSE_WHEEL_DOWN)
+
+/* mouse bit-masks */
+#define BUTTON1_RELEASED        000000000001L
+#define BUTTON1_PRESSED         000000000002L
+#define BUTTON1_CLICKED         000000000004L
+#define BUTTON1_DOUBLE_CLICKED  000000000010L
+#define BUTTON1_TRIPLE_CLICKED  000000000020L
+#define BUTTON1_MOVED           000000000020L /* PDCurses enhancement */
+#define BUTTON2_RELEASED        000000000040L
+#define BUTTON2_PRESSED         000000000100L
+#define BUTTON2_CLICKED         000000000200L
+#define BUTTON2_DOUBLE_CLICKED  000000000400L
+#define BUTTON2_TRIPLE_CLICKED  000000001000L
+#define BUTTON2_MOVED           000000001000L /* PDCurses enhancement */
+#define BUTTON3_RELEASED        000000002000L
+#define BUTTON3_PRESSED         000000004000L
+#define BUTTON3_CLICKED         000000010000L
+#define BUTTON3_DOUBLE_CLICKED  000000020000L
+#define BUTTON3_TRIPLE_CLICKED  000000040000L
+#define BUTTON3_MOVED           000000040000L /* PDCurses enhancement */
+#define MOUSE_WHEEL_SCROLL      000000100000L /* PDCurses enhancement */
+#define ALL_MOUSE_EVENTS        000000777777L
+#define BUTTON_MODIFIER_SHIFT   000001000000L /* PDCurses enhancement */
+#define BUTTON_MODIFIER_CONTROL 000002000000L /* PDCurses enhancement */
+#define BUTTON_MODIFIER_ALT     000004000000L /* PDCurses enhancement */
+#define REPORT_MOUSE_POSITION   000010000000L
+
+/*----------------------------------------------------------------------
+ *
+ *	PDCurses Structure Definitions:
+ *
+ */
+typedef struct _win		/* definition of a window.	   */
+{
+	int	_cury;		/* current pseudo-cursor	   */
+	int	_curx;
+	int	_maxy;		/* max window coordinates	   */
+	int	_maxx;
+	int	_pmaxy;		/* max physical size		   */
+	int	_pmaxx;
+	int	_begy;		/* origin on screen		   */
+	int	_begx;
+	int	_lastpy;	/* last y coordinate of upper left pad display area */
+	int	_lastpx;	/* last x coordinate of upper left pad display area */
+	int	_lastsy1;	/* last upper y coordinate of screen window for pad */
+	int	_lastsx1;	/* last upper x coordinate of screen window for pad */
+	int	_lastsy2;	/* last lower y coordinate of screen window for pad */
+	int	_lastsx2;	/* last lower x coordinate of screen window for pad */
+	int	_flags;		/* window properties		   */
+	attr_t	_attrs;		/* standard A_STANDOUT attributes and colors  */
+	chtype	_bkgd;		/* wrs(4/6/93) background, normally blank */
+	int	_tabsize;	/* tab character size		   */
+	bool	_clear;		/* causes clear at next refresh	   */
+	bool	_leaveit;		/* leaves cursor where it is	   */
+	bool	_scroll;	/* allows window scrolling	   */
+	bool	_nodelay;	/* input character wait flag	   */
+	bool	_immed;	/* immediate update flag	   */
+	bool	_sync;	/* synchronise window ancestors	   */
+	bool	_use_keypad;	/* flags keypad key mode active	   */
+	bool	_use_idl;	/* True if Ins/Del line can be used*/
+	bool	_use_idc;	/* True if Ins/Del character can be used*/
+	chtype**_y;		/* pointer to line pointer array   */
+	int*	_firstch;	/* first changed character in line */
+	int*	_lastch;	/* last changed character in line  */
+	int	_tmarg;	/* top of scrolling region	   */
+	int	_bmarg;	/* bottom of scrolling region	   */
+	int	_delayms;	/* milliseconds of delay for getch()	*/
+	char*	_title;		/* window title			   */
+	char	_title_ofs;	/* window title offset from left   */
+	attr_t	_title_attr;	/* window title attributes	   */
+	chtype	_blank;		/* window's blank character	   */
+	int	_parx, _pary;	/* coords relative to parent (0,0) */
+struct	_win*	_parent;	/* subwin's pointer to parent win  */
+}	WINDOW;
+
+
+
+/*----------------------------------------------------------------------
+*
+*	Private structures that are necessary for correct
+*	macro construction.
+*
+*/
+
+#ifdef	REGISTERWINDOWS
+typedef struct _ref		/* Refresh Window Structure	 */
+{
+	WINDOW*	win;
+struct	_ref*	next;
+struct	_ref*	tail;
+}	ACTIVE;
+
+typedef struct _wins
+{
+	WINDOW*		w;	/* pointer to a visible window	    */
+	struct _wins*	next;	/* Next visible window pointer	    */
+	struct _wins*	prev;	/* Next visible window pointer	    */
+	struct _wins*	tail;	/* Last visible window pointer	    */
+				/* Only head window (stdscr) has    */
+				/* a valid tail pointer.	    */
+}	WINDS;
+#endif
+
+typedef struct		/* structure for ripped off lines */
+{
+	int line;
+#ifdef HAVE_PROTO
+	int (*init)(WINDOW *, int);
+#else
+	int (*init)();
+#endif
+} RIPPEDOFFLINE;
+
+
+typedef struct
+{
+	bool	alive;		/* if initscr() called		    */
+	bool	autocr;		/* if lf -> crlf		    */
+	bool	cbreak;		/* if terminal unbuffered	    */
+	bool	echo;		/* if terminal echo		    */
+	bool	raw_inp;	/* raw input mode (v. cooked input) */
+	bool	raw_out;	/* raw output mode (7 v. 8 bits)    */
+	bool	refrbrk;	/* if premature refresh brk allowed */
+	bool	orgcbr;		/* original MSDOS ^-BREAK setting   */
+	bool	visible_cursor; /* TRUE if cursor is visible	    */
+	bool	audible;	/* FALSE if the bell is visual	    */
+	bool	full_redraw;	/* TRUE for bad performance	    */
+	bool	direct_video;	/* Allow Direct Screen Memory writes*/
+	bool	mono;		/* TRUE if current screen is mono.  */
+	bool	sizeable;	/* TRUE if adapter is resizeable.   */
+	bool	resized;	/* TRUE if TERM has been resized */
+	bool	bogus_adapter;	/* TRUE if adapter has insane values*/
+	bool	shell;		/* TRUE if reset_prog_mode() needs  */
+				/*	to be called.		    */
+	chtype	blank;		/* Background character		    */
+	attr_t	orig_attr;	/* Original screen attributes - top 16 bits background, bottom 16 bits foreground */
+	int	cursrow;	/* position of physical cursor	    */
+	int	curscol;	/* position of physical cursor	    */
+	int	cursor;		/* Current Cursor definition	    */
+	int	visibility;		/* Visibility of cursor	*/
+	int	video_page;	/* Current PC video page	    */
+	int	orig_emulation; /* Original cursor emulation value  */
+	int	orig_cursor;	/* Original cursor size		    */
+	int	font;		/* default font size		    */
+	int	orig_font;	/* Original font size		    */
+	int	lines;		/* New value for LINES		    */
+	int	cols;		/* New value for COLS		    */
+	unsigned long _trap_mbe;		/* trap these mouse button events */
+	unsigned long _map_mbe_to_key;	/* map mouse buttons to slk */
+	int	slklines;		/* Lines in use by slk_init() */
+	WINDOW *	slk_winptr;		/* window for slk */
+	int	linesrippedoff;		/* Lines ripped off via ripoffline() */
+	int	linesrippedoffontop;		/* Lines ripped off on top via ripoffline() */
+	int	delaytenths;		/* 1/10ths second to wait block getch() for */
+	bool	_preserve;		/* TRUE if screen background to be preserved */
+	int	_restore;		/* specifies if screen background to be restored and how*/
+	bool	save_key_modifiers;		/* TRUE if each key modifiers saved with each key press */
+	bool	return_key_modifiers;		/* TRUE if modifier keys are returned as "real" keys */
+
+#ifdef OS2
+# ifdef EMXVIDEO			/* nop if using EMX builtins */
+	int tahead; 			/* Type-ahead value */
+	int adapter;			/* Screen type	*/
+# else
+	VIOMODEINFO scrnmode;	/* default screen mode			*/
+	VIOCONFIGINFO adapter;	/* Screen type				*/
+	KBDINFO kbdinfo;	/* keyboard info */
+# endif
+#else
+	int adapter;			/* Screen type	*/
+#endif
+
+#if defined(DOS) || defined(WIN32)
+	int	scrnmode;	/* default screen mode		    */
+	unsigned video_seg;	/* video base segment		    */
+	unsigned video_ofs;	/* video base offset		    */
+	unsigned long os_version; /* Win32 Version */
+#endif
+
+#if defined (XCURSES)
+	int	XcurscrSize; /* size of Xcurscr shared memory block */
+	bool	sb_on;
+	int	sb_viewport_y;
+	int	sb_viewport_x;
+	int	sb_total_y;
+	int	sb_total_x;
+	int	sb_cur_y;
+	int	sb_cur_x;
+#endif
+
+#ifdef	REGISTERWINDOWS
+	WINDS*	visible;	/* List of visible windows	    */
+	bool	refreshall;	/* Refresh all registered windows?  */
+#endif
+
+	short	line_color;	/* Color of line attributes - default white */
+
+}	SCREEN;
+
+
+/* external variables */
+#if defined(PDC_DLL_BUILD)
+# if !defined(CURSES_LIBRARY)
+__declspec(dllimport)	int	LINES;		/* terminal height		*/
+__declspec(dllimport)	int	COLS;		/* terminal width		*/
+__declspec(dllimport)	WINDOW*	stdscr;		/* the default screen window	*/
+__declspec(dllimport)	WINDOW*	curscr;		/* the current screen image	*/
+__declspec(dllimport)	SCREEN	*SP;	/* curses variables		*/
+__declspec(dllimport)	int	use_emalloc;	/* set to true to use your own malloc,etc */
+__declspec(dllimport)	MOUSE_STATUS Mouse_status;
+__declspec(dllimport)	int COLORS;
+__declspec(dllimport)	int COLOR_PAIRS;
+# else
+__declspec(dllexport) extern	int	LINES;		/* terminal height		*/
+__declspec(dllexport) extern	int	COLS;		/* terminal width		*/
+__declspec(dllexport) extern	WINDOW*	stdscr;		/* the default screen window	*/
+__declspec(dllexport) extern	WINDOW*	curscr;		/* the current screen image	*/
+__declspec(dllexport) extern	SCREEN	*SP;	/* curses variables		*/
+__declspec(dllexport) extern	int	use_emalloc;	/* set to true to use your own malloc,etc */
+__declspec(dllexport) extern	MOUSE_STATUS Mouse_status;
+__declspec(dllexport) extern	int COLORS;
+__declspec(dllexport) extern	int COLOR_PAIRS;
+# endif
+#else
+extern	int	LINES;		/* terminal height		*/
+extern	int	COLS;		/* terminal width		*/
+extern	WINDOW*	stdscr;		/* the default screen window	*/
+extern	WINDOW*	curscr;		/* the current screen image	*/
+extern	SCREEN	*SP;	/* curses variables		*/
+extern	int	use_emalloc;	/* set to true to use your own malloc,etc */
+extern	MOUSE_STATUS Mouse_status;
+extern	int COLORS,COLOR_PAIRS;
+#endif
+
+#if	defined (CURSES_LIBRARY)
+extern	int	_default_lines;	/* For presetting maximum lines	*/
+#endif
+
+#ifdef	REGISTERWINDOWS
+extern	ACTIVE*	CurWins;	/* Currently Visible Windows	*/
+#endif
+
+
+
+
+/*man-start*********************************************************************
+
+PDCurses Text Attributes:
+
+Originally, PDCurses used a short (16 bits) for its chtype. To include 
+colour, a number of things had to be sacrificed from the strict Unix and 
+System V support. The main problem was fitting all character attributes 
+and colour into an unsigned char (all 8 bits!).
+
+Today, PDCurses by default uses a long (32 bits) for its chtype, as in 
+System V. The short chtype is still available, by undefining CHTYPE_LONG 
+and rebuilding the library.
+
+The following is the structure of a win->_attrs chtype:
+
+short form:
+
+-------------------------------------------------
+|15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+-------------------------------------------------
+ colour number |  attrs |   character eg 'a'
+
+The available attribute enhancers are bold, reverse and blink. All other 
+Unix attributes have no effect. The high order char is an index into an 
+array of physical colours (defined in INITPAIR.c). 32 (5 bits) 
+foreground/background colour combinations combined with 8 (3 bits) 
+attribute modifiers are available.
+
+long form:
+
+-------------------------------------------------------------------------------------------------
+|31|30|29|28|27|26|25|24|23|22|21|20|19|18|17|16|15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
+-------------------------------------------------------------------------------------------------
+     colour number      |     modifiers         |      character eg 'a' (potential for DBCS)
+
+The available attribute modifiers are bold, underline, invisible, 
+protect, reverse and blink. 256 (8 bits) colour pairs, 8 bits for 
+modifiers, and 16 bits for character data. (In practice, only 64 colour 
+pairs are available, and only the lower 8 bits of character data are
+currently used.)
+
+**man-end**********************************************************************/
+
+/* Video attribute definitions. */
+#ifdef CHTYPE_LONG
+# define A_NORMAL        0x00000000L
+# define A_UNDERLINE     0x00100000L
+# define A_REVERSE       0x00200000L
+# define A_BLINK         0x00400000L
+# define A_BOLD          0x00800000L
+# define A_RIGHTLINE     0x00010000L
+# define A_DIM           0x00020000L
+# define A_ALTCHARSET    0x00040000L
+# define A_INVIS         0x00080000L
+# define A_ATTRIBUTES    0xFFFF0000L
+# define A_CHARTEXT      0x0000FFFFL
+# define A_COLOR         0xFF000000L
+
+# define A_LEFTLINE      A_DIM
+# define A_ITALIC        A_INVIS
+# define A_STANDOUT      ( A_BOLD | A_REVERSE )
+# define A_PROTECT       ( A_UNDERLINE | A_LEFTLINE | A_RIGHTLINE )
+
+#else
+
+# define A_NORMAL      (chtype)0x0000                  /* System V */
+# define A_ALTCHARSET  (chtype)0x0000                  /* X/Open   */
+# define A_BLINK       (chtype)0x0400                  /* X/Open   */
+# define A_BLANK       (chtype)0x0000                  /* X/Open   */
+# define A_BOLD        (chtype)0x0100                  /* X/Open   */
+# define A_DIM         (chtype)0x0000                  /* X/Open   */
+# define A_PROTECT     (chtype)0x0000                  /* X/Open   */
+# define A_REVERSE     (chtype)0x0200                  /* X/Open   */
+# define A_STANDOUT    ((chtype)(A_REVERSE | A_BOLD))  /* X/Open   */
+# define A_UNDERLINE   (chtype)0x0000                  /* X/Open   */
+# define A_COLOR       (chtype)0xF800                  /* System V  */
+# define A_CHARTEXT    (chtype)(0xFF)                  /* X/Open   */
+# define A_ATTRIBUTES  (chtype)(~A_CHARTEXT)           /* X/Open   */
+
+# define A_LEFTLINE    (chtype)0x0000
+# define A_RIGHTLINE   (chtype)0x0000
+# define A_ITALIC      (chtype)0x0000
+# define A_INVIS       (chtype)0x0000
+#endif
+
+#define CHR_MSK		A_CHARTEXT		/* Obsolete	*/
+#define ATR_MSK		A_ATTRIBUTES	/* Obsolete	*/
+#define ATR_NRM		A_NORMAL			/* Obsolete	*/
+
+#ifdef XCURSES
+extern chtype *acs_map;
+
+# define ACS_BSSB	(acs_map['l'])
+# define ACS_SSBB	(acs_map['m'])
+# define ACS_BBSS	(acs_map['k'])
+# define ACS_SBBS	(acs_map['j'])
+# define ACS_SBSS	(acs_map['u'])
+# define ACS_SSSB	(acs_map['t'])
+# define ACS_SSBS	(acs_map['v'])
+# define ACS_BSSS	(acs_map['w'])
+# define ACS_BSBS	(acs_map['q'])
+# define ACS_SBSB	(acs_map['x'])
+# define ACS_SSSS	(acs_map['n'])
+
+# define ACS_ULCORNER	ACS_BSSB
+# define ACS_LLCORNER	ACS_SSBB
+# define ACS_URCORNER	ACS_BBSS
+# define ACS_LRCORNER	ACS_SBBS
+# define ACS_RTEE	ACS_SBSS
+# define ACS_LTEE	ACS_SSSB
+# define ACS_BTEE	ACS_SSBS
+# define ACS_TTEE	ACS_BSSS
+# define ACS_HLINE	ACS_BSBS
+# define ACS_VLINE	ACS_SBSB
+# define ACS_PLUS	ACS_SSSS
+
+# define ACS_S1		(acs_map['o'])
+# define ACS_S9		(acs_map['s'])
+# define ACS_DIAMOND	(acs_map['\''])
+# define ACS_CKBOARD	(acs_map['a'])
+# define ACS_DEGREE	(acs_map['f'])
+# define ACS_PLMINUS	(acs_map['g'])
+# define ACS_BULLET	(acs_map['~'])
+# define ACS_LARROW	(acs_map[','])
+# define ACS_RARROW	(acs_map['+'])
+# define ACS_DARROW	(acs_map['.'])
+# define ACS_UARROW	(acs_map['-'])
+# define ACS_BOARD	(acs_map['h'])
+# define ACS_LANTERN	(acs_map['i'])
+# define ACS_BLOCK	(acs_map['0'])
+
+# define ACS_S3		(acs_map['p'])
+# define ACS_S7		(acs_map['r'])
+# define ACS_LEQUAL	(acs_map['y'])
+# define ACS_GEQUAL	(acs_map['z'])
+# define ACS_PI		(acs_map['{'])
+# define ACS_NEQUAL	(acs_map['|'])
+# define ACS_STERLING	(acs_map['}'])
+#endif
+
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+/* ALTCHARSET definitions from jshumate@wrdis01.robins.af.mil
+   These match code page 437 and compatible pages (CP850, CP852, etc.)
+*/
+
+/* VT100-compatible symbols */
+
+# define ACS_ULCORNER	(chtype)0xda			/* SysV */
+# define ACS_LLCORNER	(chtype)0xc0			/* SysV	*/
+# define ACS_URCORNER	(chtype)0xbf			/* SysV	*/
+# define ACS_LRCORNER	(chtype)0xd9			/* SysV	*/
+# define ACS_RTEE	(chtype)0xb4			/* SysV	*/
+# define ACS_LTEE	(chtype)0xc3			/* SysV	*/
+# define ACS_BTEE	(chtype)0xc1			/* SysV	*/
+# define ACS_TTEE	(chtype)0xc2			/* SysV	*/
+# define ACS_HLINE	(chtype)0xc4			/* SysV */
+# define ACS_VLINE	(chtype)0xb3			/* SysV */
+# define ACS_PLUS	(chtype)0xc5			/* SysV */
+# define ACS_S1		(chtype)0x2d			/* SysV */
+# define ACS_S9		(chtype)0x5f			/* SysV */
+# define ACS_DIAMOND	((chtype)0x04 | A_ALTCHARSET)	/* SysV */
+# define ACS_CKBOARD	(chtype)0xb1			/* SysV */
+# define ACS_DEGREE	(chtype)0xf8			/* SysV */
+# define ACS_PLMINUS	(chtype)0xf1			/* SysV */
+# define ACS_BULLET	(chtype)0xf9			/* SysV */
+
+# define ACS_BSSB	ACS_ULCORNER
+# define ACS_SSBB	ACS_LLCORNER
+# define ACS_BBSS	ACS_URCORNER
+# define ACS_SBBS	ACS_LRCORNER
+# define ACS_SBSS	ACS_RTEE
+# define ACS_SSSB	ACS_LTEE
+# define ACS_SSBS	ACS_BTEE
+# define ACS_BSSS	ACS_TTEE
+# define ACS_BSBS	ACS_HLINE
+# define ACS_SBSB	ACS_VLINE
+# define ACS_SSSS	ACS_PLUS
+
+/* Teletype 5410v1 symbols -- these are defined in SysV curses, but
+   are not well-supported by most terminals. Stick to VT100 characters
+   for optimum portability.
+*/
+# define ACS_LARROW	((chtype)0x1b | A_ALTCHARSET)	/* SysV */
+# define ACS_RARROW	((chtype)0x1a | A_ALTCHARSET)	/* SysV */
+# define ACS_DARROW	((chtype)0x19 | A_ALTCHARSET)	/* SysV */
+# define ACS_UARROW	((chtype)0x18 | A_ALTCHARSET)	/* SysV */
+# define ACS_BOARD	(chtype)0xb0			/* SysV */
+# define ACS_LANTERN	((chtype)0x0f | A_ALTCHARSET)	/* SysV */
+# define ACS_BLOCK	(chtype)0xdb			/* SysV */
+
+/* That goes double for these -- undocumented SysV symbols. Don't use
+   them. Also, the definitions here aren't compatible with as many
+   code pages as those above.
+*/
+# define ACS_S3         (chtype)0x2d
+# define ACS_S7         (chtype)0x2d
+# define ACS_LEQUAL     (chtype)0xf3
+# define ACS_GEQUAL     (chtype)0xf2
+# define ACS_PI         (chtype)0xe3
+# define ACS_NEQUAL     (chtype)0xd8
+# define ACS_STERLING   (chtype)0x9c
+#endif
+
+/* colour attributes */
+#if defined (XCURSES)
+# define COLOR_BLACK		0
+# define COLOR_RED		1
+# define COLOR_GREEN		2
+# define COLOR_YELLOW		3
+# define COLOR_BLUE		4
+# define COLOR_MAGENTA		5
+# define COLOR_CYAN		6
+# define COLOR_WHITE		7
+#endif
+
+#if defined(DOS) || defined(OS2)
+# define COLOR_BLACK		0
+# define COLOR_BLUE		1
+# define COLOR_GREEN		2
+# define COLOR_CYAN		3
+# define COLOR_RED		4
+# define COLOR_MAGENTA		5
+# define COLOR_YELLOW		6
+# define COLOR_WHITE		7
+#endif
+
+#if defined(WIN32)
+# define MS_MOUSE_MOVED	0x0001
+/*
+ * These defines taken directly from windows.h to reduce
+ * compilation time by only #include'ing <windows.h>
+ * when absolutely necesssary. Cygnus-W32 #defines all of these
+ * so we need to check for that.
+ */
+# ifndef FOREGROUND_BLUE
+#  define FOREGROUND_BLUE	0x0001
+# endif
+# ifndef FOREGROUND_GREEN
+#  define FOREGROUND_GREEN	0x0002
+# endif
+# ifndef FOREGROUND_RED
+#  define FOREGROUND_RED	0x0004
+# endif
+# ifndef FOREGROUND_INTENSITY
+#  define FOREGROUND_INTENSITY	0x0008		/* BOLD */
+# endif
+#define  FOREGROUND_MASK 0x000F
+
+# ifndef BACKGROUND_BLUE
+#  define BACKGROUND_BLUE	0x0010
+# endif
+# ifndef BACKGROUND_GREEN
+#  define BACKGROUND_GREEN	0x0020
+# endif
+# ifndef BACKGROUND_RED
+#  define BACKGROUND_RED	0x0040
+# endif
+# ifndef BACKGROUND_INTENSITY
+#  define BACKGROUND_INTENSITY	0x0080		/* BLINK */
+# endif
+#define  BACKGROUND_MASK 0x00F0
+
+# define COLOR_BLACK     0
+# define COLOR_BLUE      FOREGROUND_BLUE
+# define COLOR_RED       FOREGROUND_RED
+# define COLOR_GREEN     FOREGROUND_GREEN
+# define COLOR_CYAN      (FOREGROUND_BLUE | FOREGROUND_GREEN)
+# define COLOR_MAGENTA   (FOREGROUND_RED | FOREGROUND_BLUE)
+# define COLOR_YELLOW    (FOREGROUND_RED | FOREGROUND_GREEN)
+# define COLOR_WHITE     (FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE)
+#endif
+
+#ifdef CHTYPE_LONG
+#define COLOR_PAIR(n)  ((chtype)(n) << 24)
+#define PAIR_NUMBER(n) (((n) & A_COLOR) >> 24)
+#else
+#define COLOR_PAIR(n)  (((n) << 11) & A_ATTRIBUTES)
+#define PAIR_NUMBER(n) (((n) & A_COLOR) >> 11)
+#endif
+
+/*----------------------------------------------------------------------
+ *
+ *	Function and Keypad Key Definitions.
+ *	Many are just for compatibility.
+ *
+ */
+#define KEY_MIN         0x101   /* Minimum curses key value      */
+#define KEY_BREAK       0x101   /* Not on PC KBD                 */
+#define KEY_DOWN        0x102   /* Down arrow key                */
+#define KEY_UP          0x103   /* Up arrow key                  */
+#define KEY_LEFT        0x104   /* Left arrow key                */
+#define KEY_RIGHT       0x105   /* Right arrow key               */
+#define KEY_HOME        0x106   /* home key                      */
+#define KEY_BACKSPACE   0x107   /* not on pc                     */
+#define KEY_F0          0x108   /* function keys. space for      */
+#define KEY_F(n)    (KEY_F0+(n))/* 64 keys are reserved.         */
+#define KEY_DL         0x148   /* delete line                   */
+#define KEY_IL         0x149   /* insert line                   */
+#define KEY_DC         0x14a   /* delete character              */
+#define KEY_IC         0x14b   /* insert char or enter ins mode */
+#define KEY_EIC        0x14c   /* exit insert char mode         */
+#define KEY_CLEAR      0x14d   /* clear screen                  */
+#define KEY_EOS        0x14e   /* clear to end of screen        */
+#define KEY_EOL        0x14f   /* clear to end of line          */
+#define KEY_SF         0x150   /* scroll 1 line forward         */
+#define KEY_SR         0x151   /* scroll 1 line back (reverse)  */
+#define KEY_NPAGE      0x152   /* next page                     */
+#define KEY_PPAGE      0x153   /* previous page                 */
+#define KEY_STAB       0x154   /* set tab                       */
+#define KEY_CTAB       0x155   /* clear tab                     */
+#define KEY_CATAB      0x156   /* clear all tabs                */
+#define KEY_ENTER      0x157   /* enter or send (unreliable)    */
+#define KEY_SRESET     0x158   /* soft/reset (partial/unreliable)*/
+#define KEY_RESET      0x159   /* reset/hard reset (unreliable) */
+#define KEY_PRINT      0x15a   /* print/copy                    */
+#define KEY_LL         0x15b   /* home down/bottom (lower left) */
+#define KEY_ABORT      0x15c   /* abort/terminate key (any)     */
+#define KEY_SHELP      0x15d   /* short help                    */
+#define KEY_LHELP      0x15e   /* long help                     */
+#define KEY_BTAB       0x15f   /* Back tab key                  */
+#define KEY_BEG        0x160   /* beg(inning) key               */
+#define KEY_CANCEL     0x161   /* cancel key                    */
+#define KEY_CLOSE      0x162   /* close key                     */
+#define KEY_COMMAND    0x163   /* cmd (command) key             */
+#define KEY_COPY       0x164   /* copy key                      */
+#define KEY_CREATE     0x165   /* create key                    */
+#define KEY_END        0x166   /* end key                       */
+#define KEY_EXIT       0x167   /* exit key                      */
+#define KEY_FIND       0x168   /* find key                      */
+#define KEY_HELP       0x169   /* help key                      */
+#define KEY_MARK       0x16a   /* mark key                      */
+#define KEY_MESSAGE    0x16b   /* message key                   */
+#define KEY_MOVE       0x16c   /* move key                      */
+#define KEY_NEXT       0x16d   /* next object key               */
+#define KEY_OPEN       0x16e   /* open key                      */
+#define KEY_OPTIONS    0x16f   /* options key                   */
+#define KEY_PREVIOUS   0x170   /* previous object key           */
+#define KEY_REDO       0x171   /* redo key                      */
+#define KEY_REFERENCE  0x172   /* ref(erence) key               */
+#define KEY_REFRESH    0x173   /* refresh key                   */
+#define KEY_REPLACE    0x174   /* replace key                   */
+#define KEY_RESTART    0x175   /* restart key                   */
+#define KEY_RESUME     0x176   /* resume key                    */
+#define KEY_SAVE       0x177   /* save key                      */
+#define KEY_SBEG       0x178   /* shifted beginning key         */
+#define KEY_SCANCEL    0x179   /* shifted cancel key            */
+#define KEY_SCOMMAND   0x17a   /* shifted command key           */
+#define KEY_SCOPY      0x17b   /* shifted copy key              */
+#define KEY_SCREATE    0x17c   /* shifted create key            */
+#define KEY_SDC        0x17d   /* shifted delete char key       */
+#define KEY_SDL        0x17e   /* shifted delete line key       */
+#define KEY_SELECT     0x17f   /* select key                    */
+#define KEY_SEND       0x180   /* shifted end key               */
+#define KEY_SEOL       0x181   /* shifted clear line key        */
+#define KEY_SEXIT      0x182   /* shifted exit key              */
+#define KEY_SFIND      0x183   /* shifted find key              */
+#define KEY_SHOME      0x184   /* shifted home key              */
+#define KEY_SIC        0x185   /* shifted input key             */
+#define KEY_SLEFT      0x187   /* shifted left arrow key        */
+#define KEY_SMESSAGE   0x188   /* shifted message key           */
+#define KEY_SMOVE      0x189   /* shifted move key              */
+#define KEY_SNEXT      0x18a   /* shifted next key              */
+#define KEY_SOPTIONS   0x18b   /* shifted options key           */
+#define KEY_SPREVIOUS  0x18c   /* shifted prev key              */
+#define KEY_SPRINT     0x18d   /* shifted print key             */
+#define KEY_SREDO      0x18e   /* shifted redo key              */
+#define KEY_SREPLACE   0x18f   /* shifted replace key           */
+#define KEY_SRIGHT     0x190   /* shifted right arrow           */
+#define KEY_SRSUME     0x191   /* shifted resume key            */
+#define KEY_SSAVE      0x192   /* shifted save key              */
+#define KEY_SSUSPEND   0x193   /* shifted suspend key           */
+#define KEY_SUNDO      0x194   /* shifted undo key              */
+#define KEY_SUSPEND    0x195   /* suspend key                   */
+#define KEY_UNDO       0x196   /* undo key                      */
+
+/* PDCurses specific key definitions */
+
+#define ALT_0           0x197   /* Alt-0                PC only  */
+#define ALT_1           0x198   /* Alt-1                PC only  */
+#define ALT_2           0x199   /* Alt-2                PC only  */
+#define ALT_3           0x19a   /* Alt-3                PC only  */
+#define ALT_4           0x19b   /* Alt-4                PC only  */
+#define ALT_5           0x19c   /* Alt-5                PC only  */
+#define ALT_6           0x19d   /* Alt-6                PC only  */
+#define ALT_7           0x19e   /* Alt-7                PC only  */
+#define ALT_8           0x19f   /* Alt-8                PC only  */
+#define ALT_9           0x1a0   /* Alt-9                PC only  */
+#define ALT_A           0x1a1   /* Alt-A                PC only  */
+#define ALT_B           0x1a2   /* Alt-B                PC only  */
+#define ALT_C           0x1a3   /* Alt-C                PC only  */
+#define ALT_D           0x1a4   /* Alt-D                PC only  */
+#define ALT_E           0x1a5   /* Alt-E                PC only  */
+#define ALT_F           0x1a6   /* Alt-F                PC only  */
+#define ALT_G           0x1a7   /* Alt-G                PC only  */
+#define ALT_H           0x1a8   /* Alt-H                PC only  */
+#define ALT_I           0x1a9   /* Alt-I                PC only  */
+#define ALT_J           0x1aa   /* Alt-J                PC only  */
+#define ALT_K           0x1ab   /* Alt-K                PC only  */
+#define ALT_L           0x1ac   /* Alt-L                PC only  */
+#define ALT_M           0x1ad   /* Alt-M                PC only  */
+#define ALT_N           0x1ae   /* Alt-N                PC only  */
+#define ALT_O           0x1af   /* Alt-O                PC only  */
+#define ALT_P           0x1b0   /* Alt-P                PC only  */
+#define ALT_Q           0x1b1   /* Alt-Q                PC only  */
+#define ALT_R           0x1b2   /* Alt-R                PC only  */
+#define ALT_S           0x1b3   /* Alt-S                PC only  */
+#define ALT_T           0x1b4   /* Alt-T                PC only  */
+#define ALT_U           0x1b5   /* Alt-U                PC only  */
+#define ALT_V           0x1b6   /* Alt-V                PC only  */
+#define ALT_W           0x1b7   /* Alt-W                PC only  */
+#define ALT_X           0x1b8   /* Alt-X                PC only  */
+#define ALT_Y           0x1b9   /* Alt-Y                PC only  */
+#define ALT_Z           0x1ba   /* Alt-Z                PC only  */
+#define CTL_LEFT        0x1bb   /* Control-Left-Arrow   PC only  */
+#define CTL_RIGHT       0x1bc   /* Control-Right-Arrow  PC only  */
+#define CTL_PGUP        0x1bd   /* Control-PgUp         PC only  */
+#define CTL_PGDN        0x1be   /* Control-PgDn         PC only  */
+#define CTL_HOME        0x1bf   /* Control-Home         PC only  */
+#define CTL_END         0x1c0   /* Control-End          PC only  */
+
+#if defined(FLEXOS)
+# define KEY_MOUSE       0x1c1 /* "mouse" key  */
+# define KEY_A1          KEY_HOME/* upper left on Virtual keypad  */
+# define KEY_A2          KEY_UP  /* upper middle on Virt. keypad  */
+# define KEY_A3          KEY_PPAGE/* upper right on Vir. keypad   */
+# define KEY_B1          KEY_LEFT/* middle left on Virt. keypad   */
+# define KEY_B2          0x00    /* center on Virt. keypad        */
+# define KEY_B3          KEY_RIGHT/* middle right on Vir. keypad  */
+# define KEY_C1          KEY_LL  /* lower left on Virt. keypad    */
+# define KEY_C2          KEY_DOWN /* lower middle on Virt. keypad */
+# define KEY_C3          KEY_NPAGE /* lower right on Vir. keypad  */
+# define KEY_MAX         KEY_MOUSE /* Maximum curses key        */
+#endif
+
+
+#if defined(DOS)  || defined (OS2) || defined(XCURSES) || defined(WIN32)
+# define KEY_A1          0x1c1   /* upper left on Virtual keypad  */
+# define KEY_A2          0x1c2   /* upper middle on Virt. keypad  */
+# define KEY_A3          0x1c3   /* upper right on Vir. keypad    */
+# define KEY_B1          0x1c4   /* middle left on Virt. keypad   */
+# define KEY_B2          0x1c5   /* center on Virt. keypad        */
+# define KEY_B3          0x1c6   /* middle right on Vir. keypad   */
+# define KEY_C1          0x1c7   /* lower left on Virt. keypad    */
+# define KEY_C2          0x1c8   /* lower middle on Virt. keypad  */
+# define KEY_C3          0x1c9   /* lower right on Vir. keypad    */
+# define PADSLASH        0x1ca   /* slash on keypad               */
+# define PADENTER        0x1cb   /* enter on keypad               */
+# define CTL_PADENTER    0x1cc   /* ctl-enter on keypad           */
+# define ALT_PADENTER    0x1cd   /* alt-enter on keypad           */
+# define PADSTOP         0x1ce   /* stop on keypad                */
+# define PADSTAR         0x1cf   /* star on keypad                */
+# define PADMINUS        0x1d0   /* minus on keypad               */
+# define PADPLUS         0x1d1   /* plus on keypad                */
+# define CTL_PADSTOP     0x1d2   /* ctl-stop on keypad            */
+# define CTL_PADCENTER   0x1d3   /* ctl-enter on keypad           */
+# define CTL_PADPLUS     0x1d4   /* ctl-plus on keypad            */
+# define CTL_PADMINUS    0x1d5   /* ctl-minus on keypad           */
+# define CTL_PADSLASH    0x1d6   /* ctl-slash on keypad           */
+# define CTL_PADSTAR     0x1d7   /* ctl-star on keypad            */
+# define ALT_PADPLUS     0x1d8   /* alt-plus on keypad            */
+# define ALT_PADMINUS    0x1d9   /* alt-minus on keypad           */
+# define ALT_PADSLASH    0x1da   /* alt-slash on keypad           */
+# define ALT_PADSTAR     0x1db   /* alt-star on keypad            */
+# define ALT_PADSTOP     0x1dc   /* alt-stop on keypad            */
+# define CTL_INS         0x1dd   /* ctl-insert                    */
+# define ALT_DEL         0x1de   /* alt-delete                    */
+# define ALT_INS         0x1df   /* alt-insert                    */
+# define CTL_UP          0x1e0   /* ctl-up arrow                  */
+# define CTL_DOWN        0x1e1   /* ctl-down arrow                */
+# define CTL_TAB         0x1e2   /* ctl-tab                       */
+# define ALT_TAB         0x1e3   /* alt-tab                       */
+# define ALT_MINUS       0x1e4   /* alt-minus                     */
+# define ALT_EQUAL       0x1e5   /* alt-equal                     */
+# define ALT_HOME        0x1e6   /* alt-home                      */
+# define ALT_PGUP        0x1e7   /* alt-pgup                      */
+# define ALT_PGDN        0x1e8   /* alt-pgdn                      */
+# define ALT_END         0x1e9   /* alt-end                       */
+# define ALT_UP          0x1ea   /* alt-up arrow                  */
+# define ALT_DOWN        0x1eb   /* alt-down arrow                */
+# define ALT_RIGHT       0x1ec   /* alt-right arrow               */
+# define ALT_LEFT        0x1ed   /* alt-left arrow                */
+# define ALT_ENTER       0x1ee   /* alt-enter                     */
+# define ALT_ESC         0x1ef   /* alt-escape                    */
+# define ALT_BQUOTE      0x1f0   /* alt-back quote                */
+# define ALT_LBRACKET    0x1f1   /* alt-left bracket              */
+# define ALT_RBRACKET    0x1f2   /* alt-right bracket             */
+# define ALT_SEMICOLON   0x1f3   /* alt-semi-colon                */
+# define ALT_FQUOTE      0x1f4   /* alt-forward quote             */
+# define ALT_COMMA       0x1f5   /* alt-comma                     */
+# define ALT_STOP        0x1f6   /* alt-stop                      */
+# define ALT_FSLASH      0x1f7   /* alt-forward slash             */
+# define ALT_BKSP        0x1f8   /* alt-backspace                 */
+# define CTL_BKSP        0x1f9   /* ctl-backspace                 */
+# define PAD0            0x1fa   /* ctl-keypad 0                  */
+# define CTL_PAD0        0x1fb   /* ctl-keypad 0                  */
+# define CTL_PAD1        0x1fc   /* ctl-keypad 1                  */
+# define CTL_PAD2        0x1fd   /* ctl-keypad 2                  */
+# define CTL_PAD3        0x1fe   /* ctl-keypad 3                  */
+# define CTL_PAD4        0x1ff   /* ctl-keypad 4                  */
+# define CTL_PAD5        0x200   /* ctl-keypad 5                  */
+# define CTL_PAD6        0x201   /* ctl-keypad 6                  */
+# define CTL_PAD7        0x202   /* ctl-keypad 7                  */
+# define CTL_PAD8        0x203   /* ctl-keypad 8                  */
+# define CTL_PAD9        0x204   /* ctl-keypad 9                  */
+# define ALT_PAD0        0x205   /* ctl-keypad 0                  */
+# define ALT_PAD1        0x206   /* ctl-keypad 1                  */
+# define ALT_PAD2        0x207   /* ctl-keypad 2                  */
+# define ALT_PAD3        0x208   /* ctl-keypad 3                  */
+# define ALT_PAD4        0x209   /* ctl-keypad 4                  */
+# define ALT_PAD5        0x20a   /* ctl-keypad 5                  */
+# define ALT_PAD6        0x20b   /* ctl-keypad 6                  */
+# define ALT_PAD7        0x20c   /* ctl-keypad 7                  */
+# define ALT_PAD8        0x20d   /* ctl-keypad 8                  */
+# define ALT_PAD9        0x20e   /* ctl-keypad 9                  */
+# define CTL_DEL         0x20f   /* clt-delete                    */
+# define ALT_BSLASH      0x210   /* alt-back slash                */
+# define CTL_ENTER       0x211   /* ctl-enter                     */
+# define SHF_PADENTER    0x212   /* shift-enter on keypad         */
+# define SHF_PADSLASH    0x213   /* shift-slash on keypad         */
+# define SHF_PADSTAR     0x214   /* shift-star  on keypad         */
+# define SHF_PADPLUS     0x215   /* shift-plus  on keypad         */
+# define SHF_PADMINUS    0x216   /* shift-minus on keypad         */
+# define SHF_UP          0x217   /* shift-up on keypad            */
+# define SHF_DOWN        0x218   /* shift-down on keypad          */
+# define SHF_IC          0x219   /* shift-insert on keypad        */
+# define SHF_DC          0x21a   /* shift-delete on keypad        */
+# define KEY_MOUSE       0x21b   /* "mouse" key                   */
+# define KEY_SHIFT_L     0x21c   /* Left-shift                    */
+# define KEY_SHIFT_R     0x21d   /* Right-shift                   */
+# define KEY_CONTROL_L   0x21e   /* Left-control                  */
+# define KEY_CONTROL_R   0x21f   /* Right-control                 */
+# define KEY_ALT_L       0x220   /* Left-alt                      */
+# define KEY_ALT_R       0x221   /* Right-alt                     */
+# define KEY_RESIZE      0x222   /* Window resize                 */
+# define KEY_SUP         0x223   /* Shifted up arrow              */
+# define KEY_SDOWN       0x224   /* Shifted down arrow            */
+# define KEY_MAX         0x224   /* Maximum curses key            */
+#endif
+
+/*----------------------------------------------------------------------
+*       PDCurses function declarations
+*/
+#ifdef HAVE_PROTO
+# define Args(x) x
+#else
+# define Args(x) ()
+#endif
+
+int     PDC_CDECL addchnstr Args(( const chtype *, int ));
+int     PDC_CDECL baudrate Args(( void ));
+int     PDC_CDECL beep Args(( void ));
+int     PDC_CDECL border Args(( chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype ));
+int     PDC_CDECL can_change_color  Args(( void ));
+int     PDC_CDECL cbreak Args(( void ));
+int     PDC_CDECL clearok Args(( WINDOW*, bool ));
+int     PDC_CDECL color_content Args(( short, short*, short*, short* ));
+int     PDC_CDECL copywin Args(( const WINDOW*, WINDOW*, int, int, int, int, int, int, int ));
+int     PDC_CDECL curs_set Args(( int ));
+int     PDC_CDECL def_prog_mode Args(( void ));
+int     PDC_CDECL def_shell_mode Args(( void ));
+int     PDC_CDECL delay_output Args((  int  ));
+void    PDC_CDECL delscreen Args(( SCREEN * ));
+int     PDC_CDECL delwin Args(( WINDOW* ));
+WINDOW* PDC_CDECL derwin Args(( WINDOW*, int, int, int, int ));
+int     PDC_CDECL doupdate Args(( void ));
+WINDOW* PDC_CDECL dupwin Args(( WINDOW* ));
+int     PDC_CDECL endwin Args(( void ));
+int     PDC_CDECL erase Args(( void ));
+char    PDC_CDECL erasechar Args(( void ));
+void    PDC_CDECL filter Args(( void ));
+int     PDC_CDECL flash Args(( void ));
+int     PDC_CDECL flushinp Args(( void ));
+attr_t  PDC_CDECL getattrs Args(( WINDOW* ));
+int     PDC_CDECL getsyx Args(( int*, int* ));
+WINDOW* PDC_CDECL getwin Args(( FILE * ));
+int     PDC_CDECL halfdelay Args(( int ));
+bool    PDC_CDECL has_colors Args(( void ));
+bool 	PDC_CDECL has_ic Args((void));
+bool 	PDC_CDECL has_il Args((void));
+bool 	PDC_CDECL has_key Args((  int  ));
+int     PDC_CDECL hline Args(( chtype, int ));
+int     PDC_CDECL idlok Args(( WINDOW *win, bool bf ));
+int     PDC_CDECL idcok Args(( WINDOW *win, bool bf ));
+int     PDC_CDECL immedok Args(( WINDOW*, bool ));
+int     PDC_CDECL inchnstr Args(( chtype *, int ));
+int     PDC_CDECL init_color Args(( short, short, short, short ));
+int     PDC_CDECL init_pair Args(( short, short, short ));
+WINDOW* PDC_CDECL initscr Args(( void ));
+#ifdef XCURSES
+WINDOW* PDC_CDECL Xinitscr Args(( int, char ** ));
+#endif
+int     PDC_CDECL intrflush Args((  WINDOW*, bool  ));
+int     PDC_CDECL is_linetouched Args((WINDOW *,int));
+int     PDC_CDECL is_wintouched Args((WINDOW *));
+char*   PDC_CDECL keyname Args((  int  ));
+char    PDC_CDECL killchar Args(( void ));
+char*   PDC_CDECL longname Args(( void ));
+int     PDC_CDECL meta Args(( WINDOW*, bool ));
+int     PDC_CDECL move Args(( int, int ));
+int     PDC_CDECL mvcur Args(( int, int, int, int ));
+int     PDC_CDECL mvderwin Args(( WINDOW*, int, int ));
+#ifdef HAVE_STDARG_H
+int     PDC_CDECL mvprintw Args(( int, int, char*,... ));
+int     PDC_CDECL mvscanw Args(( int, int, char*,... ));
+#endif
+int     PDC_CDECL mvwaddnstr Args(( WINDOW*,int,int,const char*,int ));
+int     PDC_CDECL mvwin Args(( WINDOW*, int, int ));
+chtype  PDC_CDECL mvwinch Args(( WINDOW*, int, int ));
+int     PDC_CDECL mvwinsertln Args(( WINDOW*, int, int ));
+#ifdef HAVE_STDARG_H
+int     PDC_CDECL mvwprintw Args(( WINDOW*, int, int, char*,... ));
+int     PDC_CDECL mvwscanw Args(( WINDOW*, int, int, char*,... ));
+#endif
+WINDOW* PDC_CDECL newpad Args(( int, int ));
+SCREEN* PDC_CDECL newterm Args(( char*, FILE*, FILE* ));
+WINDOW* PDC_CDECL newwin Args(( int, int, int, int ));
+int     PDC_CDECL noraw Args(( void ));
+void    PDC_CDECL noqiflush Args(( void ));
+int     PDC_CDECL notimeout Args(( WINDOW *, bool ));
+int     PDC_CDECL overlay Args(( const WINDOW*, WINDOW* ));
+int     PDC_CDECL overwrite Args(( const WINDOW*, WINDOW* ));
+int     PDC_CDECL pair_content Args(( int, short*, short* ));
+int     PDC_CDECL pechochar Args(( WINDOW *, chtype ));
+int     PDC_CDECL pnoutrefresh Args(( WINDOW*, int, int, int, int, int, int ));
+int     PDC_CDECL prefresh Args(( WINDOW*, int, int, int, int, int, int ));
+#ifdef HAVE_STDARG_H
+int     PDC_CDECL printw Args(( char*,... ));
+int     PDC_CDECL scanw Args(( char*,... ));
+#endif
+int     PDC_CDECL putwin Args(( WINDOW *, FILE * ));
+void    PDC_CDECL qiflush Args(( void ));
+int     PDC_CDECL raw Args(( void ));
+int     PDC_CDECL refresh Args(( void ));
+int     PDC_CDECL reset_prog_mode Args(( void ));
+int     PDC_CDECL reset_shell_mode Args(( void ));
+int     PDC_CDECL resetty Args(( void ));
+int     PDC_CDECL ripoffline Args((int, int (*)(WINDOW *, int)));
+int     PDC_CDECL savetty Args(( void ));
+int     PDC_CDECL sb_init Args((void));
+int     PDC_CDECL sb_set_horz Args((int, int, int));
+int     PDC_CDECL sb_set_vert Args((int, int, int));
+int     PDC_CDECL sb_get_horz Args((int *, int *, int *));
+int     PDC_CDECL sb_get_vert Args((int *, int *, int *));
+int     PDC_CDECL sb_refresh Args((void));
+int     PDC_CDECL scr_dump Args((const char *));
+int     PDC_CDECL scr_init Args((const char *));
+int     PDC_CDECL scr_restore Args((const char *));
+int     PDC_CDECL scr_set Args((const char *));
+int     PDC_CDECL scroll Args(( WINDOW* ));
+SCREEN* PDC_CDECL set_term Args(( SCREEN* ));
+int     PDC_CDECL setsyx Args(( int, int ));
+int     PDC_CDECL start_color Args(( void ));
+int     PDC_CDECL slk_init Args((int));
+int     PDC_CDECL slk_set Args((int, const char *, int));
+int     PDC_CDECL slk_refresh Args((void));
+int     PDC_CDECL slk_noutrefresh Args((void));
+char*   PDC_CDECL slk_label Args((int));
+int     PDC_CDECL slk_clear Args((void));
+int     PDC_CDECL slk_restore Args((void));
+int     PDC_CDECL slk_touch Args((void));
+int     PDC_CDECL slk_attron Args((attr_t));
+int     PDC_CDECL slk_attrset Args((attr_t));
+int     PDC_CDECL slk_attroff Args((attr_t));
+int     PDC_CDECL slk_color Args((short));
+WINDOW* PDC_CDECL subpad Args(( WINDOW*, int, int, int, int ));
+WINDOW* PDC_CDECL subwin Args(( WINDOW*, int, int, int, int ));
+int     PDC_CDECL syncok Args((WINDOW*, bool));
+attr_t  PDC_CDECL termattrs Args(( void ));
+char*   PDC_CDECL termname Args(( void ));
+int     PDC_CDECL touchline Args(( WINDOW*, int ,int ));
+int     PDC_CDECL touchwin Args(( WINDOW* ));
+#if !defined (CURSES_LIBRARY)
+void    PDC_CDECL traceoff Args(( void ));
+void    PDC_CDECL traceon Args(( void ));
+#endif
+int     PDC_CDECL typeahead Args(( int ));
+char*   PDC_CDECL unctrl Args(( chtype ));
+void    PDC_CDECL use_env Args(( bool ));
+int     PDC_CDECL vidattr Args(( chtype ));
+int     PDC_CDECL vidputs Args(( chtype, int (*)(int) ));
+int     PDC_CDECL vline Args(( chtype, int ));
+int     PDC_CDECL waddch Args(( WINDOW*, const chtype ));
+int     PDC_CDECL waddchnstr Args(( WINDOW*, const chtype*, int ));
+int     PDC_CDECL waddnstr Args(( WINDOW*, const char*, int ));
+int     PDC_CDECL waddstr Args(( WINDOW*, const char* ));
+int     PDC_CDECL wattroff Args(( WINDOW*, attr_t ));
+int     PDC_CDECL wattron Args(( WINDOW*, attr_t ));
+int     PDC_CDECL wattrset Args(( WINDOW*, attr_t ));
+int     PDC_CDECL wbkgd Args((WINDOW*, chtype));
+void    PDC_CDECL wbkgdset Args((WINDOW*, chtype));
+int     PDC_CDECL wborder Args(( WINDOW*, chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype ));
+int     PDC_CDECL wclear Args(( WINDOW* ));
+int     PDC_CDECL wclrtobot Args(( WINDOW* ));
+int     PDC_CDECL wclrtoeol Args(( WINDOW* ));
+int	PDC_CDECL wcolor_set Args(( WINDOW*, short, void* ));
+void    PDC_CDECL wcursyncup Args((WINDOW*));
+int     PDC_CDECL wdelch Args(( WINDOW* ));
+int     PDC_CDECL wdeleteln Args(( WINDOW* ));
+int     PDC_CDECL werase Args(( WINDOW* ));
+int     PDC_CDECL wgetch Args(( WINDOW* ));
+int     PDC_CDECL wgetnstr Args(( WINDOW*, char*, int ));
+int     PDC_CDECL wgetstr Args(( WINDOW*, char* ));
+int     PDC_CDECL whline Args(( WINDOW*, chtype, int ));
+int     PDC_CDECL winchnstr Args(( WINDOW*, chtype*, int ));
+int     PDC_CDECL winnstr Args(( WINDOW*, char*, int ));
+int     PDC_CDECL winsch Args(( WINDOW*, chtype ));
+int     PDC_CDECL winsdelln Args(( WINDOW*, int ));
+int     PDC_CDECL winsertln Args(( WINDOW* ));
+int     PDC_CDECL winsnstr Args(( WINDOW*, const char*, int ));
+int     PDC_CDECL wmove Args(( WINDOW*, int, int ));
+int     PDC_CDECL wnoutrefresh Args(( WINDOW* ));
+char    PDC_CDECL wordchar Args(( void ));
+#ifdef HAVE_STDARG_H
+int     PDC_CDECL wprintw Args(( WINDOW*, char*,... ));
+int     PDC_CDECL wscanw Args(( WINDOW*, char*,... ));
+#endif
+int     PDC_CDECL wredrawln Args(( WINDOW*, int ,int ));
+int     PDC_CDECL wrefresh Args(( WINDOW* ));
+/* int     PDC_CDECL wresize Args((WINDOW **win, int lins, int cols)); */
+int     PDC_CDECL wscrl Args(( WINDOW*, int ));
+int     PDC_CDECL wsetscrreg Args(( WINDOW*, int, int ));
+int     PDC_CDECL wtimeout Args(( WINDOW *, int ));
+int     PDC_CDECL wtouchln Args((WINDOW *, int, int, int));
+void    PDC_CDECL wsyncdown Args((WINDOW*));
+void    PDC_CDECL wsyncup Args((WINDOW*));
+int     PDC_CDECL wvline Args(( WINDOW*, chtype, int ));
+
+#ifdef  PDCURSES
+int     PDC_CDECL raw_output Args(( bool ));
+int     PDC_CDECL resize_term Args(( int, int ));
+WINDOW* PDC_CDECL resize_window Args(( WINDOW*, int, int ));
+#endif
+
+#ifdef OBSOLETE_OR_TBD
+int     PDC_CDECL mvaddrawch Args(( /* int, int, chtype */ ));
+int     PDC_CDECL mvaddrawstr Args(( /* int, int, char* */ ));
+int     PDC_CDECL mvwinsrawch Args(( /* WINDOW*, int, int, chtype */ ));
+int     PDC_CDECL mvinsrawch Args(( /* int, int, chtype */ ));
+int     PDC_CDECL waddrawstr Args(( /* WINDOW*, char* */ ));
+#endif
+
+#ifdef  XCURSES
+void    PDC_CDECL XCursesExit Args(( void ));
+int     PDC_CDECL nocbreak Args(( void ));
+int     PDC_CDECL cbreak Args(( void ));
+int     PDC_CDECL nocrmode Args(( void ));
+int     PDC_CDECL crmode Args(( void ));
+int     PDC_CDECL noecho Args(( void ));
+int     PDC_CDECL echo Args(( void ));
+int     PDC_CDECL nodelay Args(( WINDOW *,bool ));
+#endif
+
+int     PDC_CDECL mouse_set Args(( unsigned long ));
+int     PDC_CDECL mouse_on Args(( unsigned long ));
+int     PDC_CDECL mouse_off Args(( unsigned long ));
+int     PDC_CDECL request_mouse_pos Args(( void ));
+int     PDC_CDECL map_button Args(( unsigned long ));
+void    PDC_CDECL wmouse_position Args(( WINDOW *, int *, int * ));
+unsigned long PDC_CDECL getmouse Args(( void ));
+unsigned long PDC_CDECL getbmap Args(( void ));
+
+/*
+*       Keep the compiler happy with our macros below...
+*/
+int     PDC_CDECL PDC_chadd Args(( WINDOW*, chtype, bool, bool ));
+int     PDC_CDECL PDC_chins Args(( WINDOW*, chtype, bool ));
+int     PDC_CDECL PDC_ungetch Args(( int ));
+
+void    PDC_CDECL PDC_set_title Args(( char * ));
+
+int     PDC_CDECL PDC_getclipboard Args(( char **, long * ));
+int     PDC_CDECL PDC_setclipboard Args(( char *, long ));
+int     PDC_CDECL PDC_freeclipboard Args(( char * ));
+int     PDC_CDECL PDC_clearclipboard Args(( void ));
+
+unsigned long PDC_CDECL PDC_get_input_fd Args(( void ));
+int     PDC_CDECL PDC_curs_set Args(( int ));
+unsigned long PDC_CDECL PDC_get_key_modifiers Args(( void ));
+
+int     PDC_CDECL PDC_wunderline Args(( WINDOW*, int, bool ));
+int     PDC_CDECL PDC_wleftline Args(( WINDOW*, int, bool ));
+int     PDC_CDECL PDC_wrightline Args(( WINDOW*, int, bool ));
+int     PDC_CDECL PDC_set_line_color Args(( short ));
+
+#undef Args
+
+#ifndef max
+# define max(a,b) (((a) > (b)) ? (a) : (b))
+#endif
+#ifndef min
+# define min(a,b) (((a) < (b)) ? (a) : (b))
+#endif
+
+/*
+*       Functions defined as macros
+*/
+
+#define addch( c )              waddch( stdscr, c )
+#define addchstr( c )           addchnstr( c, -1 )
+#define addstr(str)             waddstr( stdscr, str )
+#define addnstr(str, n)         waddnstr( stdscr, str, n )
+#define attroff(attr)           wattroff( stdscr, attr )
+#define attron(attr)            wattron( stdscr, attr )
+#define attrset(attr)           wattrset( stdscr, attr )
+#define bkgd(c)                 wbkgd(stdscr,c)
+#define bkgdset(c)              wbkgdset(stdscr,c)
+#define border(ls,rs,ts,bs,tl,tr,bl,br)  wborder(stdscr,ls,rs,ts,bs,tl,tr,bl,br)
+#define box( w, v, h )          wborder( w, v, v, h, h, 0, 0, 0, 0 )
+#define clear()                 wclear( stdscr )
+#define clrtobot()              wclrtobot( stdscr )
+#define clrtoeol()              wclrtoeol( stdscr )
+#define color_set(a,b)          wcolor_set( stdscr, a, b )
+#define delch()                 wdelch( stdscr )
+#define deleteln()              wdeleteln( stdscr )
+#define derwin(w,nl,nc,by,bx)   subwin((w),(nl),(nc),(by+(w)->_begy),(bx+(w)->_begx))
+#define draino(ms)              delay_output(ms)
+#define echochar(c)             (addch((chtype)c)==ERR?ERR:refresh())
+#define erase()                 werase( stdscr )
+#define fixterm()               reset_prog_mode()
+#define getbegx(w)              (w)->_begx
+#define getbegy(w)              (w)->_begy
+#define getbegyx(w,y,x)         ( y = (w)->_begy, x = (w)->_begx )
+#define getbkgd(w)              ((w)->_bkgd)
+#define getch()                 wgetch(stdscr)
+#define getmaxx(w)              (w)->_maxx
+#define getmaxy(w)              (w)->_maxy
+#define getmaxyx(w,y,x)         ( y = (w)->_maxy, x = (w)->_maxx )
+#define getparx(w)              (w)->_parx
+#define getpary(w)              (w)->_pary
+#define getparyx(w,y,x)         ( y = (w)->_pary, x = (w)->_parx )
+#define getstr(str)             wgetstr( stdscr, str )
+#define getnstr(str,num)        wgetnstr( stdscr, str, num )
+#define getsyx(y,x)             { if( curscr->_leaveit) (y)=(x)=-1; else getyx(curscr,(y),(x)); }
+#define getyx(w,y,x)            ( y = (w)->_cury, x = (w)->_curx )
+#define has_colors()            ((SP->mono) ? FALSE : TRUE)
+/*#define idcok(w,flag)           OK*/
+/*#define idlok(w,flag)           OK*/
+#define inch()                  (stdscr->_y[stdscr->_cury][stdscr->_curx])
+#define inchstr( c )            inchnstr( c, stdscr->_maxx-stdscr->_curx )
+#define innstr(str,n)           winnstr(stdscr,(str),(n))
+#define insch( c )              winsch( stdscr, c )
+#define insdelln(n)             winsdelln(stdscr,n)
+#define insertln()              winsertln( stdscr )
+#define insnstr(s,n)            winsnstr(stdscr,s,n)
+#define insstr(s)               winsnstr(stdscr,s,(-1))
+#define instr(str)              winnstr(stdscr,(str),stdscr->_maxx)
+#define isendwin()              ((SP->alive) ? FALSE : TRUE)
+#define is_termresized()        (SP->resized)
+#define keypad(w,flag)          (w->_use_keypad  = flag, OK)
+#define leaveok(w,flag)         (w->_leaveit = flag, OK)
+#define move(y,x)               wmove( stdscr, y, x )
+#define mvaddch(y,x,c)          (move( y, x )==ERR?ERR:addch( c ))
+#define mvaddchstr(y,x,c)       (move( y, x )==ERR?ERR:addchnstr( c, -1 ))
+#define mvaddchnstr(y,x,c,n)    (move( y, x )==ERR?ERR:addchnstr( c, n ))
+#define mvaddstr(y,x,str)       (move( y, x )==ERR?ERR:addstr( str ))
+#define mvaddnstr(y,x,str,n)    (move( y, x )==ERR?ERR:addnstr( str, n ))
+#define mvdelch(y,x)            (move( y, x )==ERR?ERR:wdelch( stdscr ))
+#define mvgetch(y,x)            (move( y, x )==ERR?ERR:wgetch(stdscr))
+#define mvgetstr(y,x,str)       (move( y, x )==ERR?ERR:wgetstr( stdscr, str ))
+#define mvhline(y,x,c,n)        (move( y, x )==ERR?ERR:hline( c, n ))
+#define mvinch(y,x)             (move( y, x )==ERR?((chtype)ERR):(stdscr->_y[y][x]))
+#define mvinchstr(y,x,c)        (move( y, x )==ERR?ERR:inchnstr( c, stdscr->_maxx-stdscr->_curx ))
+#define mvinchnstr(y,x,c,n)     (move( y, x )==ERR?ERR:inchnstr( c, n ))
+#define mvinsch(y,x,c)          (move( y, x )==ERR?ERR:winsch( stdscr, c ))
+#define mvinsnstr(y,x,s,n)      (move( y, x )==ERR?ERR:winsnstr(stdscr,s,n))
+#define mvinsstr(y,x,s)         (move( y, x )==ERR?ERR:winsnstr(stdscr,s,(-1)))
+#define mvinstr(y,x,str)        (move( y, x )==ERR?ERR:winnstr(stdscr,(str),stdscr->_maxx))
+#define mvinnstr(y,x,str,n)     (move( y, x )==ERR?ERR:winnstr(stdscr,(str),(n)))
+#define mvvline(y,x,c,n)        (move( y, x )==ERR?ERR:vline( c, n ))
+#define mvwaddch(w,y,x,c)       (wmove( w, y, x )==ERR?ERR:waddch( w, c ))
+#define mvwaddchstr(w,y,x,c)    (wmove( w, y, x )==ERR?ERR:waddchnstr( w, c, -1 ))
+#define mvwaddchnstr(w,y,x,c,n) (wmove( w, y, x )==ERR?ERR:waddchnstr( w, c, n ))
+#define mvwaddrawch(w,y,x,c)    (wmove( w, y, x )==ERR?ERR:waddrawch( w, c ))
+#define mvwaddrawstr(w,y,x,str) (wmove( w, y, x )==ERR?ERR:waddrawstr( w, str ))
+#define mvwaddstr(w,y,x,str)    (wmove( w, y, x )==ERR?ERR:waddstr( w, str ))
+#define mvwdelch(w,y,x)         (wmove( w, y, x )==ERR?ERR:wdelch( w ))
+#define mvwgetch(w,y,x)         (wmove( w, y, x )==ERR?ERR:wgetch( w ))
+#define mvwgetstr(w,y,x,str)    (wmove( w, y, x )==ERR?ERR:wgetstr( w, str ))
+#define mvwgetnstr(w,y,x,str,n) (wmove( w, y, x )==ERR?ERR:wgetnstr( w, str , n ))
+#define mvwhline(w,y,x,c,n)     (wmove( w, y, x )==ERR?ERR:whline( w, c, n ))
+#define mvwinch(w,y,x)          (wmove( w, y, x )==ERR?((chtype)ERR):((w)->_y[y][x]))
+#define mvwinchstr(w,y,x,c)     (wmove( w, y, x )==ERR?ERR:winchnstr( w, c, (w)->_maxx-(w)->_curx ))
+#define mvwinchnstr(w,y,x,c,n)  (wmove( w, y, x )==ERR?ERR:winchnstr( w, c, n ))
+#define mvwinsch(w,y,x,c)       (wmove( w, y, x )==ERR?ERR:winsch( w, c ))
+#define mvwinstr(w,y,x,str)     (wmove( w, y, x )==ERR?ERR:winnstr(w,str,(w)->_maxx))
+#define mvwinnstr(w,y,x,str,n)  (wmove( w, y, x )==ERR?ERR:winnstr(w,str,n))
+#define mvwinsnstr(w,y,x,s,n)   (wmove( w, y, x )==ERR?ERR:winsnstr(w,s,n))
+#define mvwinsstr(w,y,x,s)      (wmove( w, y, x )==ERR?ERR:winsnstr(w,s,(-1)))
+#define mvwvline(w,y,x,c,n)     (wmove( w, y, x )==ERR?ERR:wvline( w, c, n ))
+#define napms(ms)               delay_output(ms)
+#define nl()                    (SP->autocr = TRUE, OK)
+#define nonl()                  (SP->autocr = FALSE, OK)
+#define redrawwin(w)            wredrawln((w),0,(w)->_maxy)
+#define refresh()               wrefresh( stdscr )
+#define resetterm()             reset_shell_mode()
+#define saveterm()              def_prog_mode()
+#define scrl(n)                 wscrl(stdscr,n)
+#define scroll(w)               wscrl((w),1)
+#define scrollok(w,flag)        ((w)->_scroll  = flag)
+#define setscrreg(top, bot)     wsetscrreg( stdscr, top, bot )
+#define setsyx(y,x)             { if( (y)==-1 && (x)==-1) curscr->_leaveit=TRUE; else { curscr->_leaveit=FALSE;wmove(curscr,(y),(x));} }
+#define standend()              wattrset(stdscr, A_NORMAL)
+#define standout()              wattrset(stdscr, A_STANDOUT)
+#define timeout(n)              wtimeout( stdscr, n )
+#define touchline(w,y,n)        wtouchln((w),(y),(n),TRUE)
+#define touchwin(w)             wtouchln((w),0,(w)->_maxy,TRUE)
+#if defined (CURSES_LIBRARY)
+# define traceoff()             {trace_on = FALSE;}
+# define traceon()              {trace_on = TRUE;}
+#endif
+#define ungetch(ch)             PDC_ungetch(ch)
+#define untouchwin(w)           wtouchln((w),0,((w)->_maxy),FALSE)
+#define waddch(w, c)            PDC_chadd( w, (chtype)c, (bool)!(SP->raw_out), TRUE )
+#define waddchstr(w, c)         (waddchnstr( w, c, -1 ))
+#define werase(w)               (wmove((w),0,0), wclrtobot(w))
+#define wclear(w)               ((w)->_clear = TRUE , werase(w))
+#define wechochar(w,c)          (waddch(w,(chtype)c)==ERR?ERR:wrefresh(w))
+#define winch(w)                ((w)->_y[(w)->_cury][(w)->_curx])
+#define winchstr(w, c)          (winchnstr( w, c, (w)->_maxx-(w)->_curx ) )
+#define winsstr(w,str)          winsnstr((w),(str),(-1))
+#define winstr(w,str)           winnstr((w),str,(w)->_maxx)
+#define wresize(w,l,c)          ((w = resize_window(w,l,c)) ? OK : ERR)
+#define wstandend(w)            wattrset(w, A_NORMAL)
+#define wstandout(w)            wattrset(w, A_STANDOUT)
+
+#if !defined(UNIX) && !defined(XCURSES)
+# define nocbreak()             (SP->cbreak = FALSE, SP->delaytenths = 0, OK)
+# define cbreak()               (SP->cbreak = TRUE, OK)
+# define nocrmode()             (SP->cbreak = FALSE, OK)
+# define crmode()               (SP->cbreak = TRUE, OK)
+# define noecho()               (SP->echo = FALSE, OK)
+# define echo()                 (SP->echo = TRUE, OK)
+# define nodelay(w,flag)        (w->_nodelay = flag, OK)
+#endif
+
+#if defined(PDCURSES)
+# define addrawch( c )          waddrawch( stdscr, c )
+# define addrawstr(str)         waddrawstr( stdscr, str )
+# define insrawch( c )          winsrawch( stdscr, c )
+# define waddrawch(w, c)        PDC_chadd( w, (chtype)c, FALSE, TRUE )
+# define winsrawch(w, c)        PDC_chins( w, (chtype)c, FALSE )
+# define PDC_save_key_modifiers(flag) (SP->save_key_modifiers = flag)
+# define PDC_return_key_modifiers(flag) (SP->return_key_modifiers = flag)
+
+/*
+ *      FYI: Need to document these functions...
+ */
+# define title(s,a)             wtitle( stdscr, s, (chtype)a )
+# define titleofs(ofs)          wtitleofs( stdscr, ofs )
+# define wtitle(w,s,a)          (w->_title = s, w->_title_attr = (chtype)a)
+# define wtitleofs(w,ofs)       (w->_title_ofs = ofs)
+#endif
+
+/*
+ * return codes from PDC_getclipboard() and PDC_setclipboard() calls.
+ */
+#define PDC_CLIP_SUCCESS        0
+#define PDC_CLIP_ACCESS_ERROR   1
+#define PDC_CLIP_EMPTY          2
+#define PDC_CLIP_MEMORY_ERROR   3
+
+/*
+ * PDCurses key modifier masks
+ */
+#define PDC_KEY_MODIFIER_SHIFT     (1 << 0)
+#define PDC_KEY_MODIFIER_CONTROL   (1 << 1)
+#define PDC_KEY_MODIFIER_ALT       (1 << 2)
+#define PDC_KEY_MODIFIER_NUMLOCK   (1 << 3)
+
+/*
+ *      Load up curspriv.h.     This should be in the same place as
+ *      stdlib.h.  We allow anyone who defines CURSES_LIBRARY to have
+ *      access to our internal routines.  This provides quick
+ *      PC applications at the expense of portability.
+ */
+#if defined(CURSES_LIBRARY)
+# include <curspriv.h>
+#endif
+
+#endif  /* __PDCURSES__ */
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+# undef bool
+   }
+#endif
+
+#include <stdlib.h>
+
+
diff -Naur gdb-6.8/pdcurses/curspriv.h stsgdb-6.8/pdcurses/curspriv.h
--- gdb-6.8/pdcurses/curspriv.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/curspriv.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,492 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+$Id: curspriv.h,v 1.11 2005/12/07 11:56:05 wmcbrine Exp $
+*/
+/*
+*
+*                          CURSPRIV.H
+*
+* Header file for definitions and declarations for the
+* PDCurses package. These definitions should not be generally
+* accessible to programmers, but are provided if the applications
+* programmer decides to make the decision in favor of speed on a
+* PC over portability.
+*
+* Revision History:
+* Frotz 1.5Beta 900714  Added many levels of compiler support.
+*                       Added mixed prototypes for all "internal" routines.
+*                       Removed all assembly language.  Added EGA/VGA
+*                       support.  Converted all #ifdef to #if in all
+*                       modules except CURSES.H and CURSPRIV.H.
+*                       Always include ASSERT.H.  Added support for an
+*                       external malloc(), calloc() and free().
+*                       Added support for FAST_VIDEO (direct-memory writes).
+*                       Added various memory model support (for FAST_VIDEO).
+*                       Added much of the December 1988 X/Open Curses
+*                       specification.
+* bl    1.3     881005  All modules lint-checked with MSC '-W3' and turbo'C'
+*                       '-w -w-pro' switches.
+* bl    1.2     881002  Support (by #ifdef UCMASM) for uppercase-only
+*                       assembly routine names. If UCMASM if defined,
+*                       all assembler names are #defined as upper case.
+*                       Not needed if you do "MASM /MX. Also missing
+*                       declaration of cursesscroll(). Fixes thanks to
+*                       N.D. Pentcheff
+* bl    1.1     880306  Add _chadd() for raw output routines.
+* bl    1.0     870515  Release.
+*
+*/
+
+#ifndef __CURSES_INTERNALS__
+#define __CURSES_INTERNALS__
+
+/* Always include... */
+#include <assert.h>
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+/*----------------------------------------------------------------------
+*       MEMORY MODEL SUPPORT:
+*
+*       MODELS
+*               TINY            cs,ds,ss all in 1 segment (not enough memory!)
+*               SMALL           cs:1 segment,           ds:1 segment
+*               MEDIUM          cs:many segments        ds:1 segment
+*               COMPACT         cs:1 segment,           ds:many segments
+*               LARGE           cs:many segments        ds:many segments
+*               HUGE            cs:many segments        ds:segments > 64K
+*/
+#ifdef  __TINY__
+#  define SMALL 1
+#endif
+#ifdef  __SMALL__
+#  define SMALL 1
+#endif
+#ifdef  __MEDIUM__
+#  define MEDIUM 1
+#endif
+#ifdef  __COMPACT__
+#  define COMPACT 1
+#endif
+#ifdef  __LARGE__
+#  define LARGE 1
+#endif
+#ifdef  __HUGE__
+#  define HUGE 1
+#endif
+
+
+/*----------------------------------------------------------------------
+*       OPERATING SYSTEM SUPPORT:
+*
+*               DOS             The one we all know and love:-}
+*               OS/2            The new kid on the block.
+*               FLEXOS          A Real-time, protected-mode OS from
+*                               Digital Research, Inc.
+*				(AKA, the 4680 from IBM...)
+*/
+
+/*----------------------------------------*/
+#ifdef  DOS
+#  define FAST_VIDEO 1          /* We can write directly to the screen. */
+#  ifdef NDP
+     typedef union REGS16 Regs;
+#  else
+     typedef union REGS Regs;
+#  endif
+   extern Regs regs;
+#  ifdef __DJGPP__                           /* Note: works only in plain DOS... */
+#    if DJGPP == 2
+#      define _FAR_POINTER(s,o)		((((int)(s))<<4) + ((int)(o)))
+#    else
+#      define _FAR_POINTER(s,o)		(0xe0000000 + (((int)(s))<<4) + ((int)(o)))
+#    endif
+#    define _FP_SEGMENT(p)		(unsigned short)((((long)p) >> 4) & 0xffff)
+#    define _FP_OFFSET(p)		((unsigned short)p & 0x000f)
+#  else
+#    ifdef __TURBOC__
+#      define _FAR_POINTER(s,o)	MK_FP(s,o)
+#    else
+#      if defined(NDP)
+#        define _FAR_POINTER(s,o)	((((int)(s))<<4) + ((int)(o)))
+#      else
+#        if defined(WATCOMC) && defined(__FLAT__)
+#          define _FAR_POINTER(s,o)	((((int)(s))<<4) + ((int)(o)))
+#        else
+#          define _FAR_POINTER(s,o)	(((long)s << 16) | (long)o)
+#        endif
+#      endif
+#    endif
+#    define _FP_SEGMENT(p)		(unsigned short)(((long)p) >> 4)
+#    define _FP_OFFSET(p)		((unsigned short)p & 0x000f)
+#  endif
+
+#  ifdef __DJGPP__
+     unsigned char getdosmembyte (int offs);    /* see: private\_dosmem.c */
+     unsigned short getdosmemword (int offs);
+     void setdosmembyte (int offs, unsigned char b);
+     void setdosmemword (int offs, unsigned short w);
+#  else
+#    if SMALL || MEDIUM || MSC || PC
+#      define getdosmembyte(offs)    (*((unsigned char far *) _FAR_POINTER(0,offs)))
+#      define getdosmemword(offs)    (*((unsigned short far *) _FAR_POINTER(0,offs)))
+#      define setdosmembyte(offs,x)  (*((unsigned char far *) _FAR_POINTER(0,offs)) = (x))
+#      define setdosmemword(offs,x)  (*((unsigned short far *) _FAR_POINTER(0,offs)) = (x))
+#    else
+#      define getdosmembyte(offs)    (*((unsigned char *) _FAR_POINTER(0,offs)))
+#      define getdosmemword(offs)    (*((unsigned short *) _FAR_POINTER(0,offs)))
+#      define setdosmembyte(offs,x)  (*((unsigned char *) _FAR_POINTER(0,offs)) = (x))
+#      define setdosmemword(offs,x)  (*((unsigned short *) _FAR_POINTER(0,offs)) = (x))
+#    endif
+#  endif
+#endif
+
+/*----------------------------------------*/
+#ifdef  FLEXOS
+#  define FAST_VIDEO 1          /* We can use scopy()   */
+#  define GMODE  0 /* KLUDGE ALERT!
+                   * GMODE == 0 defines character mode structures in FLEXTAB.H.
+                   * GMODE == 1 defines graphics  mode structures in FLEXTAB.H.
+                   */
+#include <flextab.h>
+extern VIRCON vir;
+#endif
+
+
+
+
+/*----------------------------------------------------------------------
+*       MALLOC DEBUGGING SUPPORT:
+*
+*       Set EMALLOC and EMALLOC_MAGIC in order to use your private
+*       versions of malloc(), calloc(), and free().  This can help,
+*       but not solve, your malloc problems when debugging...
+*
+*/
+#if defined(INTERNAL) || defined(CURSES_LIBRARY)
+#  define EMALLOC 0             /* Enable/Disable External Malloc       */
+#  define EMALLOC_MAGIC  0x0C0C /* Our magic indicator that we should   */
+                                /* use our external malloc rather than  */
+                                /* the runtime's malloc.                */
+#else
+#  define EMALLOC 0             /* Disable External Malloc	        */
+#endif
+
+
+/*----------------------------------------------------------------------*/
+/* window properties */
+#define _SUBWIN         0x01    /* window is a subwindow            */
+#define _ENDLINE        0x02    /* last winline is last screen line */
+#define _FULLWIN        0x04    /* window fills screen              */
+#define _SCROLLWIN      0x08    /* window lwr rgt is screen lwr rgt */
+#define _PAD            0x10    /* X/Open Pad.                      */
+#define _SUBPAD         0x20    /* X/Open subpad.                   */
+
+
+
+
+/*----------------------------------------------------------------------*/
+/* Miscellaneous */
+#define _INBUFSIZ       512     /* size of terminal input buffer */
+#define _NO_CHANGE      -1      /* flags line edge unchanged     */
+
+
+
+
+/* @@@ THESE SHOULD BE INDIVIDUAL FUNCTIONS, NOT MACROS! */
+#define _BCHAR          0x03    /* Break char	    (^C)         */
+#define _ECHAR          0x08    /* Erase char	    (^H)         */
+#define _DWCHAR         0x17    /* Delete Word char (^W)         */
+#define _DLCHAR         0x15    /* Delete Line char (^U)         */
+#define _GOCHAR         0x11    /* ^Q character                  */
+#define _PRINTCHAR      0x10    /* ^P character                  */
+#define _STOPCHAR       0x13    /* ^S character                  */
+#define  NUNGETCH       256     /* max # chars to ungetch()      */
+
+
+
+
+/* Setmode stuff */
+struct cttyset
+{
+	bool	been_set;
+	SCREEN	saved;
+};
+
+extern struct cttyset c_sh_tty;         /* tty modes for shell_mode */
+extern struct cttyset c_pr_tty;         /* tty modes for prog_mode  */
+extern struct cttyset c_save_tty;
+extern struct cttyset c_save_trm;
+
+/* Printscan stuff */
+extern char c_printscanbuf[];           /* buffer used during I/O */
+
+/* tracing flag */
+extern bool trace_on;
+
+/* Strget stuff */
+extern char*    c_strbeg;
+
+/* doupdate stuff */
+extern WINDOW*  twin;                   /* used by many routines */
+
+
+/* Monitor (terminal) type information */
+#define _NONE           0x00
+#define _MDA            0x01
+#define _CGA            0x02
+#define _EGACOLOR       0x04
+#define _EGAMONO        0x05
+#define _VGACOLOR       0x07
+#define _VGAMONO        0x08
+#define _MCGACOLOR      0x0a
+#define _MCGAMONO       0x0b
+#define _FLEXOS         0x20            /* A Flexos console */
+#define _MDS_GENIUS     0x30
+#define _UNIX_COLOR     0x40
+#define _UNIX_MONO      0x41
+
+/* Text-mode font size information */
+#define _FONT8  8
+#define _FONT14 14
+#define _FONT15 15              /* GENIUS */
+#define _FONT16 16
+
+
+/*----------------------------------------------------------------------
+*       ANSI C prototypes.  Be sure that your compiler conditional
+*       compilation definitions above define HAVE_PROTO if your compiler
+*       supports prototypes.
+*/
+#ifdef HAVE_PROTO
+# define Args(x) x
+#else
+# define Args(x) ()
+#endif
+
+void            PDC_beep Args(( void ));
+int             PDC_backchar Args(( WINDOW*, char*, int* ));
+bool            PDC_breakout Args(( void ));
+int             PDC_chadd Args(( WINDOW*, chtype, bool, bool ));
+bool            PDC_check_bios_key Args(( void ));
+int             PDC_chg_attr Args(( WINDOW*, chtype, int, int, int, int ));
+int             PDC_chins Args(( WINDOW*, chtype, bool ));
+int             PDC_clr_scrn Args(( WINDOW* ));
+int             PDC_clr_update Args(( WINDOW* ));
+int             PDC_copy_win Args(( const WINDOW *,WINDOW *,int,int,int,int,int,int,int,int,bool ));
+int             PDC_cursor_off Args(( void ));
+int             PDC_cursor_on Args(( void ));
+int             PDC_curs_set Args(( int ));
+int             PDC_fix_cursor Args(( int ));
+int             PDC_get_bios_key Args(( void ));
+int             PDC_get_columns Args(( void ));
+bool            PDC_get_ctrl_break Args(( void ));
+int             PDC_get_cur_col Args(( void ));
+int             PDC_get_cur_row Args(( void ));
+int             PDC_get_cursor_pos Args(( int*, int* ));
+int             PDC_get_cursor_mode Args(( void ));
+int             PDC_get_font Args(( void ));
+int             PDC_get_rows Args(( void ));
+int             PDC_get_buffer_rows Args(( void ));
+int             PDC_gotoxy Args(( int, int ));
+int             PDC_init_atrtab Args((void));
+WINDOW*         PDC_makenew Args(( int, int, int, int ));
+int             PDC_mouse_in_slk Args(( int, int ));
+int             PDC_newline Args(( WINDOW*, int ));
+int             PDC_print Args(( int, int, int ));
+int             PDC_putc Args(( chtype, chtype ));
+int             PDC_putchar Args(( chtype ));
+int             PDC_putctty Args(( chtype, chtype ));
+int             PDC_rawgetch Args(( void ));
+int             PDC_reset_prog_mode Args(( void ));
+int             PDC_reset_shell_mode Args(( void ));
+int             PDC_resize_screen Args(( int, int ));
+int             PDC_sanity_check Args(( int ));
+int             PDC_scr_close Args(( void ));
+int             PDC_scr_open Args(( SCREEN*, bool ));
+int             PDC_scroll Args(( int, int, int, int, int, chtype ));
+int             PDC_set_80x25 Args(( void ));
+int             PDC_set_ctrl_break Args(( bool ));
+int             PDC_set_cursor_mode Args(( int, int ));
+int             PDC_set_font Args(( int ));
+int             PDC_set_rows Args(( int ));
+int             PDC_split_plane Args(( WINDOW*, char*, char*, int, int, int, int ));
+void            PDC_sync Args(( WINDOW * ));
+int             PDC_sysgetch Args(( void ));
+bool            PDC_transform_line Args(( int ));
+void            PDC_usleep Args(( long ));
+int             PDC_validchar Args(( int ));
+int             PDC_vsscanf Args(( char *, const char *, va_list));
+
+void            PDC_slk_calc Args(( void ));
+
+
+# if defined( OS2 ) && !defined( EMXVIDEO )
+int             PDC_set_scrn_mode Args(( VIOMODEINFO));
+bool            PDC_scrn_modes_equal  Args((VIOMODEINFO, VIOMODEINFO));
+int             PDC_get_scrn_mode Args(( VIOMODEINFO *));
+int             PDC_query_adapter_type Args(( VIOCONFIGINFO * ));
+int             PDC_get_keyboard_info Args(( KBDINFO * ));
+int             PDC_set_keyboard_binary Args(( void ));
+int             PDC_set_keyboard_default Args(( void ));
+int             PDC_reset_shell_mode Args(( void ));
+int             PDC_reset_prog_mode Args(( void ));
+# else
+int             PDC_set_scrn_mode Args(( int ));
+bool            PDC_scrn_modes_equal  Args((int, int));
+int             PDC_get_scrn_mode Args(( void ));
+int             PDC_query_adapter_type Args(( void ));
+# endif
+
+# ifdef  FLEXOS
+int             PDC_flexos_8bitmode Args(( void ));
+int             PDC_flexos_16bitmode Args(( void ));
+char*           PDC_flexos_gname Args(( void ));
+# endif
+
+# ifdef UNIX
+int             PDC_kbhit Args((void));
+int             PDC_setup_keys Args((void));
+# endif
+
+# ifdef WIN32
+void            PDC_doupdate Args((void));
+# endif
+
+# if defined (XCURSES)
+int             XCurses_redraw_curscr Args((void));
+int             XCurses_display_cursor Args((int,int,int,int,int));
+int             XCurses_rawgetch Args((int));
+bool            XCurses_kbhit Args((void));
+int             XCurses_get_input_fd Args((void));
+int             XCursesInstruct Args((int));
+int             XCursesInstructAndWait Args((int));
+int             XCurses_transform_line Args((chtype*, int , int , int ));
+int             XCursesInitscr Args((char *,int, char **));
+int             XCursesEndwin Args((void));
+void            XCursesCleanupCursesProcess Args((int));
+int             XCursesResizeScreen Args(( int, int ));
+int             XCurses_get_cols Args((void));
+int             XCurses_get_rows Args((void));
+int             XCurses_refresh_scrollbar Args((void));
+void            XCurses_set_title Args((char *));
+int             XCurses_getclipboard Args(( char **, long * ));
+int             XCurses_setclipboard Args(( char *, long ));
+int             XCurses_clearclipboard Args(( void ));
+unsigned long   XCurses_get_key_modifiers Args(( void ));
+# endif
+
+#ifdef PC
+void            movedata Args(((unsigned, unsigned, unsigned, unsigned, unsigned));
+#endif
+
+# ifdef PDCDEBUG
+void PDC_CDECL  PDC_debug Args(( char*,... ));
+# endif
+
+# ifdef  REGISTERWINDOWS
+bool            PDC_inswin Args(( WINDOW*, WINDOW* ));
+int             PDC_addtail Args(( WINDOW* ));
+int             PDC_addwin Args(( WINDOW*, WINDOW* ));
+int             PDC_rmwin Args(( WINDOW* ));
+WINDS*          PDC_findwin Args(( WINDOW* ));
+# endif
+
+#undef Args
+
+#define PDC_COLORS           8
+#define PDC_COLOR_PAIRS     64
+
+#if defined(CHTYPE_LONG)
+#  define PDC_OFFSET       32
+#  define MAX_ATRTAB      ((PDC_COLOR_PAIRS+1)*PDC_OFFSET)
+/* internal macros for attributes */
+#  define chtype_attr(ch)  (atrtab[((ch >> 19) & 0xFFFF)] << 8)
+#else
+#  define PDC_OFFSET        8
+#  define MAX_ATRTAB      272
+/* internal macros for attributes */
+#  define chtype_attr(ch)  ((atrtab[((ch >> 8) & 0xFF)] << 8) & A_ATTRIBUTES)
+#endif
+/*
+ * Internal mouse handling macros
+ */
+#define TRAPPED_MOUSE_X_POS            (Trapped_Mouse_status.x)
+#define TRAPPED_MOUSE_Y_POS            (Trapped_Mouse_status.y)
+#define TRAPPED_A_BUTTON_CHANGED       (Trapped_Mouse_status.changes & 7)
+#define TRAPPED_MOUSE_MOVED            (Trapped_Mouse_status.changes & 8)
+#define TRAPPED_MOUSE_POS_REPORT       (Trapped_Mouse_status.changes & 16)
+#define TRAPPED_BUTTON_CHANGED(x)      (Trapped_Mouse_status.changes & (1 << ((x) - 1)))
+#define TRAPPED_BUTTON_STATUS(x)       (Trapped_Mouse_status.button[(x)-1])
+
+#define ACTUAL_MOUSE_X_POS            (Actual_Mouse_status.x)
+#define ACTUAL_MOUSE_Y_POS            (Actual_Mouse_status.y)
+#define ACTUAL_A_BUTTON_CHANGED       (Actual_Mouse_status.changes & 7)
+#define ACTUAL_MOUSE_MOVED            (Actual_Mouse_status.changes & 8)
+#define ACTUAL_MOUSE_POS_REPORT       (Actual_Mouse_status.changes & 16)
+#define ACTUAL_BUTTON_CHANGED(x)      (Actual_Mouse_status.changes & (1 << ((x) - 1)))
+#define ACTUAL_BUTTON_STATUS(x)       (Actual_Mouse_status.button[(x)-1])
+
+#define TEMP_MOUSE_X_POS            (Temp_Mouse_status.x)
+#define TEMP_MOUSE_Y_POS            (Temp_Mouse_status.y)
+#define TEMP_A_BUTTON_CHANGED       (Temp_Mouse_status.changes & 7)
+#define TEMP_MOUSE_MOVED            (Temp_Mouse_status.changes & 8)
+#define TEMP_MOUSE_POS_REPORT       (Temp_Mouse_status.changes & 16)
+#define TEMP_BUTTON_CHANGED(x)      (Temp_Mouse_status.changes & (1 << ((x) - 1)))
+#define TEMP_BUTTON_STATUS(x)       (Temp_Mouse_status.button[(x)-1])
+
+#if defined(XCURSES)
+#define CURSES_EXIT                999999
+#define CURSES_REFRESH             999998
+#define CURSES_CHILD               999997
+#define CURSES_CURSOR              999996
+#define CURSES_CONTINUE            999995
+#define CURSES_BELL                999994
+#define CURSES_FLASH               999993
+#define CURSES_CLEAR               999992
+#define CURSES_RESIZE              999991
+#define CURSES_REFRESH_SCROLLBAR   999990
+#define CURSES_TITLE               999989
+#define CURSES_GET_SELECTION       999988
+#define CURSES_SET_SELECTION       999987
+#define CURSES_DISPLAY_CURSOR      999986
+#define CURSES_CLEAR_SELECTION     999985
+
+#define XCURSCR_Y_SIZE      (XCursesLINES*XCursesCOLS*sizeof(chtype))
+#define XCURSCR_FLAG_SIZE   (XCursesLINES*sizeof(int))
+#define XCURSCR_START_SIZE  (XCursesLINES*sizeof(int))
+#define XCURSCR_LENGTH_SIZE (XCursesLINES*sizeof(int))
+#define XCURSCR_ATRTAB_SIZE (MAX_ATRTAB*sizeof(unsigned char))
+#define XCURSCR_SIZE        (XCURSCR_FLAG_SIZE+XCURSCR_START_SIZE+XCURSCR_LENGTH_SIZE+XCURSCR_Y_SIZE+XCURSCR_ATRTAB_SIZE)
+
+#define XCURSCR_Y_OFF(y)    ((y)*XCursesCOLS*(sizeof(chtype)))
+#define XCURSCR_FLAG_OFF    (XCURSCR_Y_OFF(0)+XCURSCR_Y_SIZE)
+#define XCURSCR_START_OFF   (XCURSCR_FLAG_OFF+XCURSCR_FLAG_SIZE)
+#define XCURSCR_LENGTH_OFF  (XCURSCR_START_OFF+XCURSCR_START_SIZE)
+#define XCURSCR_ATRTAB_OFF  (XCURSCR_LENGTH_OFF+XCURSCR_LENGTH_SIZE)
+#endif
+
+#endif /* __CURSES_INTERNALS__*/
diff -Naur gdb-6.8/pdcurses/demos/firework.c stsgdb-6.8/pdcurses/demos/firework.c
--- gdb-6.8/pdcurses/demos/firework.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/firework.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,190 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <signal.h>
+#include <curses.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <time.h>
+#define DELAYSIZE 200
+
+#ifdef PDCDEBUG
+char *rcsid_firework  = "$Id: firework.c,v 1.10 2005/12/07 01:37:42 wmcbrine Exp $";
+#endif
+
+#if defined(HAVE_PROTO) && !defined(__STDC__)
+# define __STDC__ 1
+#endif
+
+#ifndef Args
+# if __STDC__
+#  define Args(x) x
+# else
+#  define Args(x) ()
+# endif
+#endif
+
+void myrefresh Args((void));
+void get_colour Args((void));
+void explode Args((int,int));
+
+#if __STDC__
+int main(int argc, char **argv)
+#else
+int main(argc, argv)
+int argc;
+char **argv;
+#endif
+{
+       int start,end,row,diff,flag,direction,seed;
+
+#ifdef XCURSES
+       Xinitscr(argc, argv);
+#else
+       initscr();
+#endif
+       nodelay( stdscr, TRUE );
+       noecho();
+       if (has_colors())
+          start_color();
+       seed = time((time_t *)0);
+       srand(seed);
+       flag = 0;
+       while(getch() == ERR)  /* loop until a key is hit */
+       {
+               do {
+                      start = rand() % (COLS -3);
+                      end = rand() % (COLS - 3);
+                      start = (start < 2) ? 2 : start;
+                      end = (end < 2) ? 2 : end;
+                      direction = (start > end) ? -1 : 1;
+                      diff = abs(start-end);
+                  } while (diff<2 || diff>=LINES-2);
+               attrset(A_NORMAL);
+               for (row=0;row<diff;row++)
+               {
+                       mvprintw(LINES - row,start + (row * direction),
+                              (direction < 0) ? "\\" : "/");
+                       if (flag++)
+                       {
+                               myrefresh();
+                               clear();
+                               flag = 0;
+                       }
+               }
+               if (flag++)
+               {
+                        myrefresh();
+                        flag = 0;
+               }
+               seed = time((time_t *)0);
+               srand(seed);
+               explode(LINES-row,start+(diff*direction));
+               clear();
+               myrefresh();
+       }
+       endwin();
+#ifdef XCURSES
+       XCursesExit();
+#endif
+       return(0);
+}
+
+#if __STDC__
+void explode(int row,int col)
+#else
+void explode(row,col)
+int row,col;
+#endif
+{
+       clear();
+       mvprintw(row,col,"-");
+       myrefresh();
+
+       get_colour();
+       mvprintw(row-1,col-1," - ");
+       mvprintw(row,col-1,"-+-");
+       mvprintw(row+1,col-1," - ");
+       myrefresh();
+
+       get_colour();
+       mvprintw(row-2,col-2," --- ");
+       mvprintw(row-1,col-2,"-+++-");
+       mvprintw(row,  col-2,"-+#+-");
+       mvprintw(row+1,col-2,"-+++-");
+       mvprintw(row+2,col-2," --- ");
+       myrefresh();
+
+       get_colour();
+       mvprintw(row-2,col-2," +++ ");
+       mvprintw(row-1,col-2,"++#++");
+       mvprintw(row,  col-2,"+# #+");
+       mvprintw(row+1,col-2,"++#++");
+       mvprintw(row+2,col-2," +++ ");
+       myrefresh();
+
+       get_colour();
+       mvprintw(row-2,col-2,"  #  ");
+       mvprintw(row-1,col-2,"## ##");
+       mvprintw(row,  col-2,"#   #");
+       mvprintw(row+1,col-2,"## ##");
+       mvprintw(row+2,col-2,"  #  ");
+       myrefresh();
+
+       get_colour();
+       mvprintw(row-2,col-2," # # ");
+       mvprintw(row-1,col-2,"#   #");
+       mvprintw(row,  col-2,"     ");
+       mvprintw(row+1,col-2,"#   #");
+       mvprintw(row+2,col-2," # # ");
+       myrefresh();
+}
+
+void myrefresh Args((void))
+{
+       napms(DELAYSIZE);
+       move(LINES-1,COLS-1);
+       refresh();
+}
+
+void get_colour Args((void))
+{
+       static short tbl[] =
+       {
+               COLOR_RED,
+               COLOR_BLUE,
+               COLOR_GREEN,
+               COLOR_CYAN,
+               COLOR_RED,
+               COLOR_MAGENTA,
+               COLOR_YELLOW,
+               COLOR_WHITE,
+       };
+
+       attr_t bold = (rand() % 2) ? A_BOLD : A_NORMAL;
+
+       init_pair(1, tbl[rand() % 8], COLOR_BLACK);
+       attrset(COLOR_PAIR(1) | bold);
+}
diff -Naur gdb-6.8/pdcurses/demos/Makefile.in stsgdb-6.8/pdcurses/demos/Makefile.in
--- gdb-6.8/pdcurses/demos/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/Makefile.in	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,175 @@
+# Makefile for XCurses demo programs.
+
+SHELL		= /bin/sh
+
+srcdir		= @srcdir@
+prefix		= @prefix@
+exec_prefix	= @exec_prefix@
+libdir		= $(exec_prefix)
+PDCURSES_HOME		=$(srcdir)/..
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+
+CC		= @CC@
+CFLAGS		= @CFLAGS@
+
+INCDIR		= $(srcdir)
+CPPFLAGS	= -I$(INCDIR) -I$(srcdir)/.. -I.. @DEFS@ -DXCURSES @SYS_DEFS@
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS) @MH_XINC_DIR@
+
+LIB_DEPS	=	-L../pdcurses -lXCurses
+LIBXCURSES	=	../pdcurses/libXCurses.a
+
+PANEL_LIB	=	-L../panel -lpanel
+LIBPANEL	=	../panel/libpanel.a
+
+LINK		= @PURIFY@ $(CC)
+#LDFLAGS	= $(LIB_DEPS) @LDFLAGS@ @LIBS@ @MH_XLIBS@ @MH_EXTRA_LIBS@
+LDFLAGS		= $(LIBXCURSES) @LDFLAGS@ @LIBS@ @MH_XLIBS@ @MH_EXTRA_LIBS@
+
+DEMOS = \
+	firework \
+	newdemo \
+	ptest \
+	testcurs \
+	tuidemo \
+	xmas 
+
+all: $(DEMOS) 
+
+$(LIBXCURSES):
+	cd ../pdcurses; $(MAKE) $(MFLAGS)
+
+$(LIBPANEL):
+	cd ../panel; $(MAKE) $(MFLAGS)
+
+firework: firework.o $(LIBXCURSES)
+	$(LINK) firework.o -o $@ $(LDFLAGS)
+
+newdemo: newdemo.o $(LIBXCURSES)
+	$(LINK) newdemo.o -o $@ $(LDFLAGS)
+
+ptest: ptest.o $(LIBXCURSES) $(LIBPANEL)
+#	$(LINK) ptest.o -o $@ $(PANEL_LIB) $(LDFLAGS)
+	$(LINK) ptest.o -o $@ $(LIBPANEL) $(LDFLAGS)
+
+testcurs: testcurs.o $(LIBXCURSES)
+	$(LINK) testcurs.o -o $@ $(LDFLAGS)
+
+tuidemo: tuidemo.o tui.o $(LIBXCURSES)
+	$(LINK) tui.o tuidemo.o -o $@ $(LDFLAGS)
+
+xmas: xmas.o $(LIBXCURSES)
+	$(LINK) xmas.o -o $@ $(LDFLAGS)
+
+
+firework.o: $(srcdir)/firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/firework.c
+
+newdemo.o: $(srcdir)/newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/newdemo.c
+
+ptest.o: $(srcdir)/ptest.c $(PDCURSES_HOME)/panel.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/ptest.c
+
+testcurs.o: $(srcdir)/testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/testcurs.c
+
+tui.o: $(srcdir)/tui.c $(srcdir)/tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/tui.c
+
+tuidemo.o: $(srcdir)/tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/tuidemo.c
+
+xmas.o: $(srcdir)/xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/xmas.c
+
+install:
+	echo Does nothing at the moment
+
+clean:
+	-rm -rf *.o trace $(DEMOS)
+
+distclean: clean
+	-rm -f Makefile
+
+mostlyclean: clean
+
+realclean: distclean
+
+#
+# This section provides for compiling and linking the
+# ncurses test programs.
+#
+ncurses_testdir=$(HOME)/ncurses-5.5/test
+
+NCURSES_TESTS = \
+	bs \
+	gdc \
+	hanoi \
+	knight \
+	rain \
+	tclock \
+	worm \
+	ncurses
+
+ncurses_tests: $(NCURSES_TESTS)
+
+ncurses_clean:
+	-rm -rf *.o trace $(NCURSES_TESTS)
+
+NCFLAGS=-I$(ncurses_testdir)
+
+bs: bs.o $(LIBXCURSES)
+	$(LINK) bs.o -o $@ $(LDFLAGS)
+
+gdc: gdc.o $(LIBXCURSES)
+	$(LINK) gdc.o -o $@ $(LDFLAGS)
+
+hanoi: hanoi.o $(LIBXCURSES)
+	$(LINK) hanoi.o -o $@ $(LDFLAGS)
+
+knight: knight.o $(LIBXCURSES)
+	$(LINK) knight.o -o $@ $(LDFLAGS)
+
+rain: rain.o $(LIBXCURSES)
+	$(LINK) rain.o -o $@ $(LDFLAGS)
+
+tclock: tclock.o $(LIBXCURSES)
+	$(LINK) tclock.o -o $@ $(LDFLAGS) -lm
+
+view: view.o $(LIBXCURSES)
+	$(LINK) view.o -o $@ $(LDFLAGS)
+
+worm: worm.o $(LIBXCURSES)
+	$(LINK) worm.o -o $@ $(LDFLAGS)
+
+ncurses: ncurses.o $(LIBXCURSES) $(LIBPANEL)
+	$(LINK) ncurses.o -o $@ $(LDFLAGS) $(LIBPANEL)
+
+bs.o: $(ncurses_testdir)/bs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/bs.c
+
+gdc.o: $(ncurses_testdir)/gdc.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/gdc.c
+
+hanoi.o: $(ncurses_testdir)/hanoi.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/hanoi.c
+
+knight.o: $(ncurses_testdir)/knight.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/knight.c
+
+rain.o: $(ncurses_testdir)/rain.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/rain.c
+
+tclock.o: $(ncurses_testdir)/tclock.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/tclock.c
+
+view.o: $(ncurses_testdir)/view.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/view.c
+
+worm.o: $(ncurses_testdir)/worm.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/worm.c
+
+ncurses.o: $(ncurses_testdir)/ncurses.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) $(NCFLAGS) -o $@ $(ncurses_testdir)/ncurses.c
diff -Naur gdb-6.8/pdcurses/demos/ncurses_cfg.h stsgdb-6.8/pdcurses/demos/ncurses_cfg.h
--- gdb-6.8/pdcurses/demos/ncurses_cfg.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/ncurses_cfg.h	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,32 @@
+/* This file is only used with the ncurses test programs.
+ *
+ * Have ncurses-5.5 unpacked in your $(HOME) (you don't need to build 
+ * it), or edit ncurses_testdir appropriately in the Makefile. Configure 
+ * and build XCurses. (Sorry, other ports won't work yet.) Change to 
+ * this directory, and:
+ *
+ * "make ncurses_tests" to start.
+ * "make ncurses_clean" when you're done.
+ *
+ * Builds: bs gdc hanoi knight rain tclock worm ncurses
+ */
+
+#include "../config.h"
+#include <curses.h>
+
+#ifdef XCURSES
+# define ExitProgram XCursesExit(),exit
+#else
+# define ExitProgram exit
+#endif
+
+#define HAVE_GETNSTR 1
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_PANEL_H 1
+#define HAVE_LIBPANEL 1
+
+/* Fool ncurses.c so it gives us all the tests, and doesn't redefine 
+   ACS_ chars
+*/
+
+#define NCURSES_VERSION PDCURSES
diff -Naur gdb-6.8/pdcurses/demos/newdemo.c stsgdb-6.8/pdcurses/demos/newdemo.c
--- gdb-6.8/pdcurses/demos/newdemo.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/newdemo.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,460 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+ *  newdemo.c	-	A demo program using PDCurses. The program illustrate
+ *  	 		the use of colours for text output.
+ *
+ *  Hacks by jbuhler@cs.washington.edu on 12/29/96
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <signal.h>
+#include <string.h>
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_newdemo  = "$Id: newdemo.c,v 1.14 2005/12/08 17:27:08 wmcbrine Exp $";
+#endif
+
+#if defined(HAVE_PROTO) && !defined(__STDC__)
+# define __STDC__ 1
+#endif
+
+#ifndef Args
+# if __STDC__
+#  define Args(x) x
+# else
+#  define Args(x) ()
+# endif
+#endif
+
+int WaitForUser Args((void));
+int SubWinTest Args((WINDOW *));
+int BouncingBalls Args((WINDOW *));
+void trap Args((int));
+
+/*
+ *  The Australian map
+ */
+char    *AusMap[17] =
+{
+    "                       A ",
+    "           AA         AA ",
+    "    N.T. AAAAA       AAAA ",
+    "     AAAAAAAAAAA  AAAAAAAA ",
+    "   AAAAAAAAAAAAAAAAAAAAAAAAA Qld.",
+    " AAAAAAAAAAAAAAAAAAAAAAAAAAAA ",
+    " AAAAAAAAAAAAAAAAAAAAAAAAAAAAA ",
+    " AAAAAAAAAAAAAAAAAAAAAAAAAAAA ",
+    "   AAAAAAAAAAAAAAAAAAAAAAAAA N.S.W.",
+    "W.A. AAAAAAAAA      AAAAAA Vic.",
+    "       AAA   S.A.     AA",
+    "                       A  Tas.",
+    ""
+};
+
+/*
+ *  Funny messages
+ */
+
+char    *messages[] =
+{
+    "Hello from the Land Down Under",
+    "The Land of crocs, and a big Red Rock",
+    "Where the sunflower runs along the highways",
+    "The dusty red roads lead one to loneliness",
+    "Blue sky in the morning and",
+    "Freezing nights and twinkling stars",
+    NULL
+};
+
+/*
+ *  Wait for user
+ */
+int WaitForUser Args((void))
+{
+   chtype ch;
+
+   nodelay(stdscr,TRUE);
+   halfdelay(50);
+
+   ch = getch();
+
+   nodelay(stdscr,FALSE);
+   nocbreak();            /* Reset the halfdelay() value */
+   cbreak();
+
+   return (ch == '\033') ? ch : 0;
+}
+
+/*
+ * Test sub windows
+ */
+#if __STDC__
+int SubWinTest(WINDOW *win)
+#else
+int SubWinTest(win)
+WINDOW *win;
+#endif
+{
+   int     w, h, sw, sh, bx, by;
+   WINDOW  *swin1, *swin2, *swin3;
+
+   wattrset(win, 0);
+   getmaxyx(win, h, w);
+   getbegyx(win, by, bx);
+   sw = w / 3;
+   sh = h / 3;
+   if ((swin1 = derwin(win, sh, sw, 3, 5)) == NULL)
+      return  1;
+   if ((swin2 = subwin(win, sh, sw, by+4, bx+8)) == NULL)
+      return  1;
+   if ((swin3 = subwin(win, sh, sw, by+5, bx+11)) == NULL)
+      return  1;
+
+   init_pair(8,COLOR_RED,COLOR_BLUE);
+   wbkgd(swin1, COLOR_PAIR(8));
+   werase(swin1);
+   mvwaddstr(swin1, 0, 3, "Sub-window 1");
+   wrefresh(swin1);
+
+   init_pair(9,COLOR_CYAN,COLOR_MAGENTA);
+   wbkgd(swin2, COLOR_PAIR(9));
+   werase(swin2);
+   mvwaddstr(swin2, 0, 3, "Sub-window 2");
+   wrefresh(swin2);
+
+   init_pair(10,COLOR_YELLOW,COLOR_GREEN);
+   wbkgd(swin3, COLOR_PAIR(10));
+   werase(swin3);
+   mvwaddstr(swin3, 0, 3, "Sub-window 3");
+   wrefresh(swin3);
+
+   delwin(swin1);
+   delwin(swin2);
+   delwin(swin3);
+   WaitForUser();
+   return  0;
+}
+
+/*
+ *  Bouncing balls
+ */
+#if __STDC__
+int BouncingBalls(WINDOW *win)
+#else
+int BouncingBalls(win)
+WINDOW *win;
+#endif
+{
+   chtype c1, c2, c3;
+   chtype ball1, ball2, ball3;
+   int    w, h;
+   int    x1, y1, xd1, yd1;
+   int    x2, y2, xd2, yd2;
+   int    x3, y3, xd3, yd3;
+   int    c;
+
+#if defined(PDCURSES)
+   curs_set(0);
+#endif
+   wbkgd( win, COLOR_PAIR(1) );
+   wrefresh(win);
+   wattrset(win,0);
+
+   init_pair(11,COLOR_RED,COLOR_GREEN);
+   init_pair(12,COLOR_BLUE,COLOR_RED);
+   init_pair(13,COLOR_YELLOW,COLOR_WHITE);
+
+   ball1 = 'O' | COLOR_PAIR(11);
+   ball2 = '*' | COLOR_PAIR(12);
+   ball3 = '@' | COLOR_PAIR(13);
+
+   getmaxyx(win, h, w);
+   x1   = 2 + rand() % (w - 4);
+   y1   = 2 + rand() % (h - 4);
+   x2   = 2 + rand() % (w - 4);
+   y2   = 2 + rand() % (h - 4);
+   x3   = 2 + rand() % (w - 4);
+   y3   = 2 + rand() % (h - 4);
+   xd1 = 1;
+   yd1 = 1;
+   xd2 = 1;
+   yd2 = -1;
+   xd3 = -1;
+   yd3 = 1;
+   nodelay(stdscr,TRUE);
+   while((c = getch()) == ERR)
+   {
+      x1 += xd1;
+      if (x1 <= 1 || x1 >= w - 2)
+         xd1 = (xd1 == 1) ? -1 : 1;
+      y1 += yd1;
+      if (y1 <= 1 || y1 >= h - 2)
+         yd1 = (yd1 == 1) ? -1 : 1;
+      x2 += xd2;
+      if (x2 <= 1 || x2 >= w - 2)
+         xd2 = (xd2 == 1) ? -1 : 1;
+      y2 += yd2;
+      if (y2 <= 1 || y2 >= h - 2)
+         yd2 = (yd2 == 1) ? -1 : 1;
+      x3 += xd3;
+      if (x3 <= 1 || x3 >= w - 2)
+         xd3 = (xd3 == 1) ? -1 : 1;
+      y3 += yd3;
+      if (y3 <= 1 || y3 >= h - 2)
+         yd3 = (yd3 == 1) ? -1 : 1;
+
+      c1 = mvwinch(win, y1, x1);
+      c2 = mvwinch(win, y2, x2);
+      c3 = mvwinch(win, y3, x3);
+
+      mvwaddch(win, y1, x1, ball1);
+      mvwaddch(win, y2, x2, ball2);
+      mvwaddch(win, y3, x3, ball3);
+      wmove(win, 0, 0);
+      wrefresh(win);
+      mvwaddch(win, y1, x1, c1);
+      mvwaddch(win, y2, x2, c2);
+      mvwaddch(win, y3, x3, c3);
+      napms(150);
+   }
+   nodelay(stdscr,FALSE);
+   ungetch(c);
+   return 0;
+}
+
+/*
+ *  Trap interrupt
+ */
+#if __STDC__
+void trap(int sig)
+#else
+void trap(sig)
+int sig;
+#endif
+{
+   if (sig == SIGINT)
+   {
+      endwin();
+#ifdef XCURSES
+      XCursesExit();
+#endif
+      exit(0);
+   }
+}
+
+/*
+ *  Main driver
+ */
+#if __STDC__
+int main(int argc, char **argv)
+#else
+int main(argc, argv)
+int argc;
+char **argv;
+#endif
+{
+WINDOW  *win;
+int     w, x, y, i, j;
+int     width, height;
+chtype  save[80], ch;
+
+#ifdef PDCDEBUG
+/*  traceon();*/
+#endif
+#ifdef XCURSES
+   Xinitscr(argc, argv);
+#else
+   initscr();
+#endif
+   start_color();
+   cbreak();
+   noecho();
+   curs_set(0);
+#if !defined(TC) && !defined(OS2)
+   signal(SIGINT, trap);
+#endif
+   noecho();
+
+/*  refresh stdscr so that reading from it will not cause it to overwrite */
+/*  the other windows that are being created */
+
+   refresh();
+
+   width  = 48;
+   height = 15;                /* Create a drawing window */
+   win = newwin(height, width, (LINES-height)/2, (COLS-width)/2);
+   if (win == NULL)
+   {
+      endwin();
+#ifdef XCURSES
+      XCursesExit();
+#endif
+      return 1;
+   }
+
+   for( ;; )
+   {
+      init_pair(1,COLOR_WHITE,COLOR_BLUE);
+/*        wattrset(win, COLOR_PAIR(1));*/
+      wbkgd(win, COLOR_PAIR(1));
+      werase(win);
+
+      init_pair(2,COLOR_RED,COLOR_RED);
+      wattrset(win, COLOR_PAIR(2));
+      ch = ' ';
+      box(win, ch, ch);
+      wrefresh(win);
+      wattrset(win, 0);
+                              /* Do random output of a character */
+      ch = 'a';
+      nodelay(stdscr,TRUE);
+      for(i=0; i < 5000; ++i)
+      {
+         x = rand() % (width-2)  + 1;
+         y = rand() % (height-2) + 1;
+         mvwaddch(win, y, x, ch);
+         wrefresh(win);
+         if (getch() != ERR)
+             break;
+         if(i == 2000)
+         {
+            ch = 'b';
+            init_pair(3,COLOR_CYAN,COLOR_YELLOW);
+            wattrset(win, COLOR_PAIR(3));
+         }
+      }
+      nodelay(stdscr,FALSE);
+
+      SubWinTest(win);
+                              /* Erase and draw green window */
+      init_pair(4,COLOR_YELLOW,COLOR_GREEN);
+/*        wattrset(win, COLOR_PAIR(4) | A_BOLD);*/
+      wbkgd(win, COLOR_PAIR(4) );
+      wattrset(win, A_BOLD);
+      werase(win);
+      wrefresh(win);
+                              /* Draw RED bounding box */
+      wattrset(win, COLOR_PAIR(2));
+      box(win, ' ', ' ');
+      wrefresh(win);
+                              /* Display Australia map */
+      wattrset(win, A_BOLD);
+      i = 0;
+      while(*AusMap[i])
+      {
+         mvwaddstr(win, i+1, 8, AusMap[i]);
+         wrefresh(win);
+         napms(100);
+         ++i;
+      }
+
+      init_pair(5,COLOR_BLUE,COLOR_WHITE);
+      wattrset(win, COLOR_PAIR(5) | A_BLINK);
+      mvwaddstr(win, height-2, 3, " PDCurses 2.7 for DOS, OS/2, X11 and Win32");
+      wrefresh(win);
+
+      /* Draw running messages */
+      init_pair(6,COLOR_BLACK,COLOR_WHITE);
+      wattrset(win, COLOR_PAIR(6));
+      w = width-2;
+      nodelay(win,TRUE);
+
+      /* jbuhler's re-hacked scrolling messages */
+      for (j=0; messages[j] != NULL; j++)
+      {
+         char *message = messages[j];
+         int msg_len = strlen(message);
+         int scroll_len = w + 2 * msg_len;
+         char *scrollbuf = malloc(scroll_len);
+         char *visbuf = scrollbuf + msg_len;
+         int stop = 0;
+         int i;
+
+         for (i=w+msg_len; i > 0; i--)
+         {
+            memset(visbuf, ' ',w);
+            strncpy(scrollbuf + i, message, msg_len);
+            mvwaddnstr(win,height/2, 1, visbuf, w);
+            wrefresh(win);
+            if (wgetch(win) != ERR)
+            {
+               flushinp();
+               stop = 1;
+               break;
+            }
+            delay_output(100);
+         }
+         free(scrollbuf);
+         if (stop)
+            break;
+      }
+
+      j = 0;
+                                /*  Draw running As across in RED */
+      init_pair(7,COLOR_RED,COLOR_GREEN);
+      wattron(win, COLOR_PAIR(7));
+      for(i=2; i < width - 4; ++i)
+      {
+         ch = mvwinch(win, 5, i);
+         save[j++] = ch;
+         ch = ch & 0x7f;
+         mvwaddch(win, 5, i, ch);
+      }
+      wrefresh(win);
+
+                                /* Put a message up wait for a key */
+      i = height-2;
+      wattrset(win, COLOR_PAIR(5));
+      mvwaddstr(win, i, 3, "   Type a key to continue or ESC to quit  ");
+      wrefresh(win);
+
+      if (WaitForUser() == '\033')
+         break;
+
+      j = 0;                  /* Restore the old line */
+      wattrset(win,0);
+      for (i=2; i < width - 4; ++i)
+          mvwaddch(win, 5, i, save[j++]);
+      wrefresh(win);
+
+      BouncingBalls(win); /* leaves a keystroke in the queue */
+
+      if (WaitForUser() == '\033')
+         break;
+   }
+   endwin();
+#ifdef XCURSES
+   XCursesExit();
+#endif
+   return 0;
+}
+
+/*  End of NEWDEMO.C */
diff -Naur gdb-6.8/pdcurses/demos/ptest.c stsgdb-6.8/pdcurses/demos/ptest.c
--- gdb-6.8/pdcurses/demos/ptest.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/ptest.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,402 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*+-------------------------------------------------------------------------
+	ptest.c
+--------------------------------------------------------------------------*/
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_ptest  = "$Id: ptest.c,v 1.10 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+#include <curses.h>
+#include <panel.h>
+
+PANEL *p1;
+PANEL *p2;
+PANEL *p3;
+PANEL *p4;
+PANEL *p5;
+WINDOW *w1;
+WINDOW *w2;
+WINDOW *w3;
+WINDOW *w4;
+WINDOW *w5;
+
+#define	nap(x)		usleep(1000*x)
+
+long nap_msec = 1;
+
+char *mod[] = 
+{
+	"test ",
+	"TEST ",
+	"(**) ",
+	"*()* ",
+	"<--> ",
+	"LAST "
+};
+
+#if defined(HAVE_PROTO) && !defined(__STDC__)
+# define __STDC__ 1
+#endif
+
+#ifndef Args
+# if __STDC__
+#  define Args(x) x
+# else
+#  define Args(x) ()
+# endif
+#endif
+
+PANEL *mkpanel Args((int, int, int, int));
+void fill_panel Args((PANEL *));
+void pflush Args((void));
+void wait_a_while Args((long));
+void saywhat Args((const char *));
+void rmpanel Args((PANEL *));
+
+/*+-------------------------------------------------------------------------
+	wait_a_while(msec)
+--------------------------------------------------------------------------*/
+#if __STDC__
+void wait_a_while(long msec)
+#else
+void
+wait_a_while(msec)
+long msec;
+#endif
+{
+	getch();
+	return;
+}	/* end of wait_a_while */
+
+/*+-------------------------------------------------------------------------
+	saywhat(text)
+--------------------------------------------------------------------------*/
+#if __STDC__
+void saywhat(const char *text)
+#else
+void
+saywhat(text)
+char *text;
+#endif
+{
+
+	wmove(stdscr,LINES - 1,0);
+	wprintw(stdscr,"%-20.20s",text);
+
+}	/* end of saywhat */
+
+/*+-------------------------------------------------------------------------
+	mkpanel(rows,cols,tly,tlx) - alloc a win and panel and associate them
+--------------------------------------------------------------------------*/
+#if __STDC__
+PANEL *mkpanel(int rows, int cols, int tly, int tlx)
+#else
+PANEL *
+mkpanel(rows,cols,tly,tlx)
+int rows;
+int cols;
+int tly;
+int tlx;
+#endif
+{
+WINDOW *win = newwin(rows,cols,tly,tlx);
+PANEL *pan = (PANEL *)0;
+
+	if (win) {
+		pan = new_panel(win);
+		if (!pan)
+			delwin(win);
+	}
+	return pan;
+}	/* end of mkpanel */
+
+/*+-------------------------------------------------------------------------
+	rmpanel(pan)
+--------------------------------------------------------------------------*/
+#if __STDC__
+void rmpanel(PANEL *pan)
+#else
+void
+rmpanel(pan)
+PANEL *pan;
+#endif
+{
+WINDOW *win = pan->win;
+	del_panel(pan);
+	delwin(win);
+}	/* end of rmpanel */
+
+/*+-------------------------------------------------------------------------
+	pflush()
+--------------------------------------------------------------------------*/
+void pflush Args((void))
+{
+	update_panels();
+	doupdate();
+}	/* end of pflush */
+
+/*+-------------------------------------------------------------------------
+	fill_panel(win)
+--------------------------------------------------------------------------*/
+#if __STDC__
+void fill_panel(PANEL *pan)
+#else
+void
+fill_panel(pan)
+PANEL *pan;
+#endif
+{
+WINDOW *win = pan->win;
+char num = *((char *)pan->user + 1);
+int y,x,maxy,maxx;
+
+	box(win, 0, 0);  
+	wmove(win,1,1);
+	wprintw(win,"-pan%c-",num);
+	getmaxyx(win,maxy,maxx);
+	for(y = 2; y < maxy - 1; y++)
+	{
+		for(x = 1; x < maxx - 1; x++)
+		{
+			wmove(win,y,x);
+			waddch(win,num);
+		}
+	}
+}	/* end of fill_panel */
+
+/*+-------------------------------------------------------------------------
+	main(argc,argv)
+--------------------------------------------------------------------------*/
+#if __STDC__
+int main(int argc, char **argv)
+#else
+int
+main(argc,argv)
+int argc;
+char **argv;
+#endif
+{
+int itmp;
+register int y,x;
+
+	if((argc > 1) && atol(argv[1]))
+		nap_msec = atol(argv[1]);
+
+#ifdef XCURSES
+	Xinitscr(argc, argv);
+#else
+	initscr();
+#endif
+
+	for(y = 0; y < LINES - 1; y++)
+	{
+		for(x = 0; x < COLS; x++)
+			wprintw(stdscr,"%d",(y + x) % 10);
+	}
+	for(y = 0; y < 5; y++)
+	{
+		p1 = mkpanel(10,10,0,0);
+		w1 = panel_window(p1);
+		set_panel_userptr(p1,"p1");
+
+		p2 = mkpanel(14,14,5,5);
+		w2 = panel_window(p2);
+		set_panel_userptr(p2,"p2");
+
+		p3 = mkpanel(6,8,12,12);
+		w3 = panel_window(p3);
+		set_panel_userptr(p3,"p3");
+
+		p4 = mkpanel(10,10,10,30);
+		w4 = panel_window(p4);
+		set_panel_userptr(p4,"p4");
+
+		p5 = mkpanel(10,10,13,37);
+		w5 = panel_window(p5);
+		set_panel_userptr(p5,"p5");
+
+		fill_panel(p1);
+		fill_panel(p2);
+		fill_panel(p3);
+		fill_panel(p4);
+		fill_panel(p5);
+		hide_panel(p4);
+		hide_panel(p5);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("h3 s1 s2 s4 s5;");
+		move_panel(p1,0,0);
+		hide_panel(p3);
+		show_panel(p1);
+		show_panel(p2);
+		show_panel(p4);
+		show_panel(p5);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("s1;");
+		show_panel(p1);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("s2;");
+		show_panel(p2);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("m2;");
+		move_panel(p2,10,10);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("s3;");
+		show_panel(p3);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("m3;");
+		move_panel(p3,5,5);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("b3;");
+		bottom_panel(p3);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("s4;");
+		show_panel(p4);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("s5;");
+		show_panel(p5);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t3;");
+		top_panel(p3);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t1;");
+		top_panel(p1);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t2;");
+		top_panel(p2);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t3;");
+		top_panel(p3);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t4;");
+		top_panel(p4);
+		pflush();
+		wait_a_while(nap_msec);
+
+		for(itmp = 0; itmp < 6; itmp++)
+		{
+			saywhat("m4;");
+			wmove(w4,3,1);
+			waddstr(w4,mod[itmp]);
+			move_panel(p4,4,itmp*10);
+			wmove(w5,4,1);
+			waddstr(w5,mod[itmp]);
+			pflush();
+			wait_a_while(nap_msec);
+			saywhat("m5;");
+			wmove(w4,4,1);
+			waddstr(w4,mod[itmp]);
+			move_panel(p5,7,(itmp*10) + 6);
+			wmove(w5,3,1);
+			waddstr(w5,mod[itmp]);
+			pflush();
+			wait_a_while(nap_msec);
+		}
+
+		saywhat("m4;");
+		move_panel(p4,4,itmp*10);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t5;");
+		top_panel(p5);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t2;");
+		top_panel(p2);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("t1;");
+		top_panel(p1);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("d2;");
+		rmpanel(p2);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("h3;");
+		hide_panel(p3);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("d1;");
+		rmpanel(p1);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("d4; ");
+		rmpanel(p4);
+		pflush();
+		wait_a_while(nap_msec);
+
+		saywhat("d5; ");
+		rmpanel(p5);
+		pflush();
+		wait_a_while(nap_msec);
+		if(nap_msec == 1)
+			break;
+		nap_msec = 100L;
+	}
+	endwin();
+#ifdef XCURSES
+	XCursesExit();
+#endif
+	return 0;
+}	/* end of main */
+
+/* vi: set tabstop=4 shiftwidth=4: */
+/* end of ptest.c */
diff -Naur gdb-6.8/pdcurses/demos/testcurs.c stsgdb-6.8/pdcurses/demos/testcurs.c
--- gdb-6.8/pdcurses/demos/testcurs.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/testcurs.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,900 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+ *
+ * This is a test program for the PDCurses screen package for IBM PC type
+ * machines.
+ * This program was written by John Burnell (johnb@kea.am.dsir.govt.nz)
+ *
+ *  wrs(5/28/93) -- modified to be consistent (perform identically) with either
+ *                  PDCurses or under Unix System V, R4
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#ifdef PDCDEBUG
+# define CURSES_LIBRARY /* needed for the prototype of PDC_debug */
+char *rcsid_testcurs  = "$Id: testcurs.c,v 1.26 2005/12/15 17:08:03 wmcbrine Exp $";
+#endif
+
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <curses.h>
+
+#if defined(PDCURSES) && !defined(XCURSES)
+# define HAVE_RESIZE 1
+#else
+# define HAVE_RESIZE 0
+#endif
+
+#ifdef PDCURSES
+# define HAVE_CLIPBOARD 1
+#else
+# define HAVE_CLIPBOARD 0
+#endif
+
+#if defined(HAVE_PROTO) && !defined(__STDC__)
+# define __STDC__ 1
+#endif
+
+#ifndef Args
+# if __STDC__
+#  define Args(x) x
+# else
+#  define Args(x) ()
+# endif
+#endif
+
+void inputTest Args((WINDOW *));
+void scrollTest Args((WINDOW *));
+void introTest Args((WINDOW *));
+int initTest Args((WINDOW **, int, char **));
+void outputTest Args((WINDOW *));
+void padTest Args((WINDOW *));
+void display_menu Args((int,int));
+
+#if HAVE_RESIZE
+void resizeTest Args((WINDOW *));
+#endif
+
+#if HAVE_CLIPBOARD
+void clipboardTest Args((WINDOW *));
+#endif
+
+struct commands
+{
+ char *text;
+#ifdef __STDC__
+ void (*function)(WINDOW *);
+#else
+ void (*function)();
+#endif
+};
+
+typedef struct commands COMMAND;
+
+#define MAX_OPTIONS (5 + HAVE_RESIZE + HAVE_CLIPBOARD)
+
+COMMAND command[MAX_OPTIONS] =
+{
+ {"Intro Test",introTest},
+ {"Pad Test",padTest},
+#if HAVE_RESIZE
+ {"Resize Test",resizeTest},
+#endif
+ {"Scroll Test",scrollTest},
+ {"Input Test",inputTest},
+ {"Output Test",outputTest},
+#if HAVE_CLIPBOARD
+ {"Clipboard Test",clipboardTest},
+#endif
+};
+
+int     width, height;
+
+#ifdef __STDC__
+int main (int argc, char *argv[])
+#else
+int main (argc, argv)
+int argc;
+char *argv[];
+#endif
+{
+WINDOW  *win;
+int key,old_option=(-1),new_option=0;
+bool quit=FALSE;
+
+#ifdef PDCDEBUG
+	PDC_debug("testcurs started\n");
+#endif
+    if (initTest (&win,argc,argv)) {return 1;}
+
+#ifdef A_COLOR
+    if (has_colors())
+      {
+       init_pair(1,COLOR_WHITE,COLOR_BLUE);
+       wbkgd(win, COLOR_PAIR(1));
+      }
+    else
+#endif
+       wbkgd(win, A_REVERSE);
+
+    erase();
+    display_menu(old_option,new_option);
+    while(1)
+      {
+       noecho();
+       keypad(stdscr,TRUE);
+       raw();
+       key = getch();
+       switch(key)
+         {
+          case 10:
+          case 13:
+          case KEY_ENTER:
+			 old_option = -1;
+                         erase();
+                         refresh();
+                         (*command[new_option].function)(win);
+                         erase();
+                         display_menu(old_option,new_option);
+                         break;
+          case KEY_UP:
+			 old_option = new_option;
+                         new_option = (new_option == 0) ? new_option : new_option-1;
+                         display_menu(old_option,new_option);
+                         break;
+          case KEY_DOWN:
+			 old_option = new_option;
+                         new_option = (new_option == MAX_OPTIONS-1) ? new_option : new_option+1;
+                         display_menu(old_option,new_option);
+                         break;
+          case 'Q':
+          case 'q':
+                         quit = TRUE;
+                         break;
+          default:       break;
+         }
+       if (quit == TRUE)
+          break;
+      }
+
+    delwin (win);
+    endwin();
+#ifdef XCURSES
+    XCursesExit();
+#endif
+    return 0;
+}
+
+#ifdef __STDC__
+void Continue (WINDOW *win)
+#else
+void Continue (win)
+WINDOW *win;
+#endif
+{
+    mvwaddstr(win, 10, 1, " Press any key to continue");
+    wrefresh(win);
+    raw();
+    wgetch(win);
+}
+
+#ifdef __STDC__
+int initTest (WINDOW **win, int argc, char *argv[])
+#else
+int initTest (win, argc, argv)
+WINDOW **win;
+int argc;
+char *argv[];
+#endif
+{
+/*  traceon();*/
+#ifdef PDCDEBUG
+	PDC_debug("initTest called\n");
+#endif
+#ifdef XCURSES
+    Xinitscr(argc, argv);
+#else
+    initscr();
+#endif
+#ifdef PDCDEBUG
+	PDC_debug("after initscr()\n");
+#endif
+#ifdef A_COLOR
+    if (has_colors())
+       start_color();
+#endif
+    width  = 60;
+    height = 13;                /* Create a drawing window */
+    *win = newwin(height, width, (LINES-height)/2, (COLS-width)/2);
+    if(*win == NULL)
+    {   endwin();
+        return 1;
+    }
+    return 0;
+}
+
+#ifdef __STDC__
+void introTest (WINDOW *win)
+#else
+void introTest (win)
+WINDOW *win;
+#endif
+{
+    werase(win);
+    wmove( win, height/2-5, width/2 );
+    wvline( win, ACS_VLINE, 10 );
+    wmove( win, height/2, width/2-10 );
+    whline( win, ACS_HLINE, 20 );
+    Continue(win);
+
+    beep ();
+    werase(win);
+
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+    cbreak ();
+    mvwaddstr(win, 1, 1, "You should have rectangle in the middle of the screen");
+    mvwaddstr(win, 2, 1, "You should have heard a beep");
+    Continue(win);
+}
+
+#ifdef __STDC__
+void scrollTest (WINDOW *win)
+#else
+void scrollTest (win)
+WINDOW *win;
+#endif
+{
+    int i;
+    int OldY, OldX;
+
+/* disable typeahead checking */
+
+    typeahead(-1);
+
+    werase (win);
+    mvwprintw (win, height - 2, 1, "The window will now scroll slowly");
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh (win);
+    scrollok(win, TRUE);
+    napms (500);
+    for (i = 1; i <= height; i++) {
+      napms (150);
+      scroll(win);
+      wrefresh (win);
+    };
+
+    getmaxyx (win, OldY, OldX);
+    mvwprintw (win, 6, 1, "The top of the window will scroll");
+    wmove (win, 1, 1);
+    wsetscrreg (win, 0, 4);
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh (win);
+    for (i = 1; i <= 5; i++)
+      {
+       napms (500);
+       scroll(win);
+       wrefresh (win);
+      }
+
+    mvwprintw (win, 3, 1, "The bottom of the window will scroll");
+    wmove (win, 8, 1);
+    wsetscrreg (win, 5, --OldY);
+    box(win, ACS_VLINE, ACS_HLINE);
+    wrefresh (win);
+    for (i = 5; i <= OldY; i++)
+      {
+       napms (300);
+       wscrl(win,-1);
+       wrefresh (win);
+      }
+    wsetscrreg (win, 0, OldY);
+
+}
+
+#ifdef __STDC__
+void inputTest (WINDOW *win)
+#else
+void inputTest (win)
+WINDOW *win;
+#endif
+{
+    int w, h, bx, by, sw, sh, i, c,num;
+    char buffer [80];
+    WINDOW *subWin;
+    char spinner[4] = "/-\\|";
+    int spinner_count = 0;
+
+    wclear (win);
+
+    getmaxyx(win, h, w);
+    getbegyx(win, by, bx);
+
+    sw = w / 3;
+    sh = h / 3;
+    if((subWin = subwin(win, sh, sw, by + h - sh - 2, bx + w - sw - 2)) == NULL)
+        return;
+
+#ifdef A_COLOR
+    if (has_colors())
+      {
+       init_pair(2,COLOR_WHITE,COLOR_RED);
+       wbkgd(subWin, COLOR_PAIR(2) | A_BOLD);
+      }
+    else
+#endif
+       wbkgd(subWin, A_BOLD);
+
+    box(subWin, ACS_VLINE, ACS_HLINE);
+    wrefresh(win);
+
+    nocbreak();
+
+    wclear (win);
+    mvwaddstr(win, 1, 1, "Press keys (or mouse buttons) to show their names");
+    mvwaddstr(win, 2, 1, "Press spacebar to finish");
+    wrefresh(win);
+    keypad(win, TRUE);
+    raw();
+    noecho();
+    typeahead(-1);
+#if 1
+    wtimeout(win,200); /* we have a timeout of 2/10ths second */
+#else
+    halfdelay(2); /* 2 tenths of a second */
+#endif
+#if defined(PDCURSES)
+    mouse_set(ALL_MOUSE_EVENTS);
+    PDC_save_key_modifiers(TRUE);
+    PDC_return_key_modifiers(TRUE);
+#endif
+    curs_set(0); /* turn cursor off */
+    while(1)
+    {
+       while(1)
+       {
+          c = wgetch(win);
+          if ( c == ERR )
+          {
+             spinner_count++;
+             if (spinner_count == 4 )
+                spinner_count = 0;
+             wmove(win,3,3);
+             waddch(win,spinner[spinner_count]);
+             wrefresh(win);
+          }
+          else
+             break;
+       }
+       wmove(win,3,5);
+       wclrtoeol(win);
+       if (c >= KEY_MIN)
+          wprintw(win,"Key Pressed: %s", keyname(c));
+       else if (isprint(c))
+          wprintw(win,"Key Pressed: %c", c);
+       else
+          wprintw(win,"Key Pressed: %s", unctrl(c));
+#if defined(PDCURSES)
+       if (PDC_get_key_modifiers())
+       {
+          waddstr(win, " Modifier(s):");
+          if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_SHIFT)
+             waddstr(win," SHIFT");
+          if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_CONTROL)
+             waddstr(win," CONTROL");
+          if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_ALT)
+             waddstr(win," ALT");
+          if (PDC_get_key_modifiers() & PDC_KEY_MODIFIER_NUMLOCK)
+             waddstr(win," NUMLOCK");
+       }
+       if (c == KEY_MOUSE)
+       {
+          int button = 0;
+          request_mouse_pos();
+          if (BUTTON_CHANGED(1))
+             button = 1;
+          else if (BUTTON_CHANGED(2))
+             button = 2;
+          else if (BUTTON_CHANGED(3))
+             button = 3;
+          if (BUTTON_STATUS(button) & BUTTON_MODIFIER_MASK)
+          {
+             waddstr(win, " Modifier(s):");
+             if ((BUTTON_STATUS(button) & BUTTON_MODIFIER_MASK) == BUTTON_SHIFT)
+                waddstr(win," SHIFT");
+             if ((BUTTON_STATUS(button) & BUTTON_MODIFIER_MASK) == BUTTON_CONTROL)
+                waddstr(win," CONTROL");
+             if ((BUTTON_STATUS(button) & BUTTON_MODIFIER_MASK) == BUTTON_ALT)
+                waddstr(win," ALT");
+          }
+          wmove(win,4,18);
+          wprintw(win,"Button %d: ",button);
+          if (MOUSE_MOVED)
+             wprintw(win,"moved: ");
+          else if (MOUSE_WHEEL_UP)
+             wprintw(win,"wheel up: ");
+          else if (MOUSE_WHEEL_DOWN)
+             wprintw(win,"wheel down: ");
+          else if ((BUTTON_STATUS(button) & BUTTON_ACTION_MASK) == BUTTON_PRESSED)
+             wprintw(win,"pressed: ");
+          else if ((BUTTON_STATUS(button) & BUTTON_ACTION_MASK) == BUTTON_CLICKED)
+             wprintw(win,"clicked: ");
+          else if ((BUTTON_STATUS(button) & BUTTON_ACTION_MASK) == BUTTON_DOUBLE_CLICKED)
+             wprintw(win,"double: ");
+          else
+             wprintw(win,"released: ");
+          wprintw(win," Position: Y: %d X: %d",MOUSE_Y_POS,MOUSE_X_POS);
+       }
+#endif
+       wrefresh(win);
+       if (c == ' ')
+          break;
+    }
+#if 1
+    wtimeout(win,-1); /* turn off timeout() */
+#else
+    nocbreak(); /* turn off halfdelay() mode */
+#endif
+    curs_set(1); /* turn cursor back on */
+
+#if 0
+    nodelay(win, TRUE);
+    wgetch(win);
+    nodelay(win, FALSE);
+#endif
+#if defined(PDCURSES)
+    mouse_set(0L);
+    PDC_save_key_modifiers(FALSE);
+    PDC_return_key_modifiers(FALSE);
+#endif
+
+    wclear (win);
+    mvwaddstr(win, 2, 1, "Press some keys for 5 seconds");
+    mvwaddstr(win, 1, 1, "Pressing ^C should do nothing");
+    wrefresh(win);
+
+    werase (subWin);
+    box(subWin, ACS_VLINE, ACS_HLINE);
+    for (i = 0; i < 5; i++)
+      {
+       mvwprintw (subWin, 1, 1, "Time = %d", i);
+       wrefresh(subWin);
+       napms(1000);
+       flushinp();
+      }
+
+    delwin (subWin);
+    werase(win);
+    flash();
+    wrefresh(win);
+    napms(500);
+    flushinp();
+
+    mvwaddstr(win, 2, 1, "Press a key, followed by ENTER");
+    wmove(win, 9, 10);
+    wrefresh(win);
+    echo();
+/*
+    noraw();
+*/
+    keypad(win, TRUE);
+    raw();
+    wgetnstr(win, buffer, 3);
+    flushinp();
+
+    wmove(win, 9, 10);
+    wdelch(win);
+    mvwaddstr(win, 4, 1, "The character should now have been deleted");
+    Continue(win);
+
+    refresh();
+    wclear (win);
+    echo();
+    mvwaddstr(win, 3, 2, "The window should have moved");
+    mvwaddstr(win, 4, 2, "This text should have appeared without you pressing a key");
+    mvwaddstr(win, 6, 2, "Enter a number then a string seperated by space");
+    mvwin(win, 2, 1);
+    wrefresh(win);
+    mvwscanw(win, 7, 6, "%d %s", &num,buffer);
+    mvwprintw(win, 8, 6, "String: %s Number: %d", buffer,num);
+    Continue(win);
+
+    refresh();
+    wclear (win);
+    echo();
+    mvwaddstr(win, 3, 2, "Enter a 5 character string: ");
+    wgetnstr(win,buffer,5);
+    mvwprintw(win, 4, 2, "String: %s", buffer);
+    Continue(win);
+}
+
+#ifdef __STDC__
+void outputTest (WINDOW *win)
+#else
+void outputTest (win)
+WINDOW *win;
+#endif
+{
+    WINDOW *win1;
+    char Buffer [80];
+    chtype ch;
+    int by, bx;
+
+    nl ();
+    wclear (win);
+    mvwaddstr(win, 1, 1, "You should now have a screen in the upper left corner, and this text should have wrapped");
+    waddstr(win,"\nThis text should be down\n");
+    waddstr(win,  "and broken into two here ^");
+    Continue(win);
+
+    wclear(win);
+    wattron(win, A_BOLD);
+    mvwaddstr(win, 1, 1, "A new window will appear with this text in it");
+    mvwaddstr(win, 8, 1, "Press any key to continue");
+    wrefresh(win);
+    wgetch(win);
+
+    getbegyx(win, by, bx);
+
+    if (LINES < 24 || COLS < 75)
+      {
+       mvwaddstr(win, 5, 1, "Some tests have been skipped as they require a");
+       mvwaddstr(win, 6, 1, "display of at least 24 LINES by 75 COLUMNS");
+       Continue(win);
+      }
+    else
+      {
+       win1 = newwin(10, 50, 14, 25);
+       if (win1 == NULL)
+         {
+          endwin();
+          return;
+         }
+#ifdef A_COLOR
+       if (has_colors())
+         {
+          init_pair(3,COLOR_BLUE,COLOR_WHITE);
+          wbkgd(win1, COLOR_PAIR(3));
+         }
+       else
+#endif
+          wbkgd(win1, A_NORMAL);
+
+       wclear (win1);
+       mvwaddstr(win1, 5, 1, "This text should appear; using overlay option");
+       copywin(win, win1,0,0,0,0,9,49,TRUE);
+
+       box(win1,ACS_VLINE,ACS_HLINE);
+
+       wmove(win1, 8, 26);
+       wrefresh(win1);
+       wgetch(win1);
+
+       wclear(win1);
+       wattron(win1, A_BLINK);
+       mvwaddstr(win1, 4, 1, "This blinking text should appear in only the second window");
+       wattroff(win1, A_BLINK);
+       mvwin(win1, by, bx);
+       overlay(win, win1);
+       mvwin(win1,14,25);
+       wmove(win1, 8, 26);
+       wrefresh(win1);
+       wgetch(win1);
+       delwin(win1);
+      }
+
+    clear();
+    wclear(win);
+    wrefresh(win);
+    mvwaddstr(win, 6, 2, "This line shouldn't appear");
+    mvwaddstr(win, 4, 2, "Only half of the next line is visible");
+    mvwaddstr(win, 5, 2, "Only half of the next line is visible");
+    wmove(win, 6, 1);
+    wclrtobot (win);
+    wmove(win, 5, 20);
+    wclrtoeol (win);
+    mvwaddstr(win, 8, 2, "This line also shouldn't appear");
+    wmove(win, 8, 1);
+    winsdelln(win,-1);
+    Continue(win);
+
+    wmove (win, 5, 9);
+    ch = winch (win);
+
+    wclear(win);
+    wmove (win, 6, 2);
+    waddstr (win, "The next char should be l:  ");
+    winsch (win, ch);
+    Continue(win);
+
+    mvwinsstr( win, 6, 2, "A1B2C3D4E5" );
+    Continue(win);
+
+    wmove(win, 5, 1);
+    winsdelln (win,1);
+    mvwaddstr(win, 5, 2, "The lines below should have moved down");
+    Continue(win);
+
+    wclear(win);
+    wmove(win, 2, 2);
+    wprintw(win, "This is a formatted string in a window: %d %s\n", 42, "is it");
+    mvwaddstr(win, 10, 1, "Enter a string: ");
+    wrefresh(win);
+    echo();
+    wscanw (win, "%s", Buffer);
+
+    printw("This is a formatted string in stdscr: %d %s\n", 42, "is it");
+    mvaddstr(10, 1, "Enter a string: ");
+    scanw ("%s", Buffer);
+
+    wclear(win);
+    curs_set(2);
+    mvwaddstr(win, 1, 1, "The cursor should appear as a block");
+    Continue(win);
+
+    wclear(win);
+    curs_set(0);
+    mvwaddstr(win, 1, 1, "The cursor should have disappeared");
+    Continue(win);
+
+    wclear(win);
+    curs_set(1);
+    mvwaddstr(win, 1, 1, "The cursor should be an underline");
+    Continue(win);
+
+#ifdef A_COLOR
+    if ( has_colors() )
+      {
+       wclear(win);
+       mvwaddstr(win, 1, 1, "Colors should change after you press a key");
+       Continue(win);
+       init_pair(1, COLOR_RED, COLOR_WHITE);
+       wrefresh(win);
+    }
+#endif
+
+    werase(win);
+    mvwaddstr(win, 1, 1, "Information About Your Terminal");
+    mvwaddstr(win, 3, 1, termname());
+    mvwaddstr(win, 4, 1, longname());
+    if ( termattrs() & A_BLINK )
+       mvwaddstr(win,5, 1, "This terminal claims to support blinking.");
+    else
+       mvwaddstr(win,5, 1, "This terminal does NOT support blinking.");
+
+    mvwaddnstr( win, 7,5, "Have a nice day!ok", 16 );
+    wrefresh(win);
+
+    mvwinnstr( win, 7,5, Buffer, 18 );
+    mvaddstr( LINES-2, 10, Buffer );
+    refresh();
+    Continue(win);
+}
+
+#if HAVE_RESIZE
+# ifdef __STDC__
+void resizeTest(WINDOW *dummy)
+# else
+void resizeTest(dummy)
+WINDOW *dummy;
+# endif
+{
+    WINDOW *win1;
+
+    savetty ();
+    clear();
+    refresh();
+# if defined(PDCURSES) && !defined(XCURSES)
+#  if defined(OS2)
+    resize_term(50,120);
+#  else
+    resize_term(50,80);
+#  endif
+# endif
+
+    win1 = newwin(10, 50, 14, 25);
+    if(win1 == NULL)
+    {   endwin();
+        return;
+    }
+#ifdef A_COLOR
+    if (has_colors())
+      {
+       init_pair(3,COLOR_BLUE,COLOR_WHITE);
+       wattrset(win1, COLOR_PAIR(3));
+      }
+#endif
+    wclear (win1);
+
+    mvwaddstr(win1, 1, 1, "The screen may now have 50 lines");
+    Continue(win1);
+
+    wclear (win1);
+    resetty ();
+
+    mvwaddstr(win1, 1, 1, "The screen should now be reset");
+    Continue(win1);
+
+    delwin(win1);
+
+    clear();
+    refresh();
+
+}
+#endif
+
+#ifdef __STDC__
+void padTest(WINDOW *dummy)
+#else
+void padTest(dummy)
+WINDOW *dummy;
+#endif
+{
+WINDOW *pad,*spad;
+
+ pad = newpad(50,100);
+ wattron(pad, A_REVERSE);
+ mvwaddstr(pad, 5, 2, "This is a new pad");
+ wattrset(pad,0);
+ mvwaddstr(pad, 8, 0, "The end of this line should be truncated here:except  now");
+ mvwaddstr(pad,11, 1, "This line should not appear.It will now");
+ wmove(pad, 10, 1);
+ wclrtoeol(pad);
+ mvwaddstr(pad, 10, 1, " Press any key to continue");
+ prefresh(pad,0,0,0,0,10,45);
+ keypad(pad, TRUE);
+ raw();
+ wgetch(pad);
+
+ spad = subpad(pad,12,25,7,52);
+ mvwaddstr(spad, 2, 2, "This is a new subpad");
+ box(spad,0,0);
+ prefresh(pad,0,0,0,0,15,75);
+ keypad(pad, TRUE);
+ raw();
+ wgetch(pad);
+
+ mvwaddstr(pad, 35, 2, "This is displayed at line 35 in the pad");
+ mvwaddstr(pad, 40, 1, " Press any key to continue");
+ prefresh(pad,30,0,0,0,10,45);
+ keypad(pad, TRUE);
+ raw();
+ wgetch(pad);
+
+ delwin(pad);
+}
+
+#if HAVE_CLIPBOARD
+# ifdef __STDC__
+void clipboardTest (WINDOW *win)
+# else
+void clipboardTest (win)
+WINDOW *win;
+# endif
+{
+    long i,length=0;
+    char *text = "This string placed in clipboard by PDCurses test program, testcurs.";
+    char *ptr=NULL;
+
+/* disable typeahead checking */
+
+    typeahead(-1);
+
+    clear();
+    mvprintw (1, 1, "This test will display the contents of the system clipboard");
+    refresh ();
+    move(LINES-1, 1);
+    clrtoeol();
+    mvaddstr(LINES-1, 1, " Press any key to continue");
+    refresh();
+    raw();
+    getch();
+    scrollok(stdscr, TRUE);
+    i = PDC_getclipboard( &ptr, &length );
+    switch(i)
+    {
+       case PDC_CLIP_ACCESS_ERROR:
+          mvprintw (3, 1, "There was an error accessing the clipboard");
+          refresh ();
+          break;
+       case PDC_CLIP_MEMORY_ERROR:
+          mvprintw (3, 1, "Unable to allocate memory for clipboard contents");
+          break;
+       case PDC_CLIP_EMPTY:
+          mvprintw (3, 1, "There was no text in the clipboard");
+          break;
+       default:
+          wsetscrreg (stdscr, 0, LINES-1);
+          clear();
+          mvprintw (1, 1, "Clipboard contents...");
+          move(2,0);
+          for (i=0;i<length;i++)
+          {
+             addch(*(ptr+i));
+          }
+          addch('\n');
+          break;
+    }
+    move(LINES-1, 1);
+    clrtoeol();
+    mvaddstr(LINES-1, 1, " Press any key to continue");
+    refresh();
+    raw();
+    getch();
+
+    clear();
+    mvprintw (1, 1, "This test will place the following string in the system clipboard:");
+    mvprintw (2, 1, text);
+    refresh ();
+    i = PDC_setclipboard( text, strlen(text) );
+    switch(i)
+    {
+       case PDC_CLIP_ACCESS_ERROR:
+          mvprintw (3, 1, "There was an error accessing the clipboard");
+          refresh ();
+          break;
+       case PDC_CLIP_MEMORY_ERROR:
+          mvprintw (3, 1, "Unable to allocate memory for clipboard contents");
+          break;
+       default:
+          mvprintw (3, 1, "The string was placed in the clipboard successfully");
+    }
+    move(LINES-1, 1);
+    clrtoeol();
+    mvaddstr(LINES-1, 1, " Press any key to continue");
+    refresh();
+    raw();
+    getch();
+}
+#endif
+
+#ifdef __STDC__
+void display_menu(int old_option,int new_option)
+#else
+void display_menu(old_option,new_option)
+int old_option,new_option;
+#endif
+{
+ if (old_option == -1) {
+    int i;
+
+    attrset(A_BOLD);
+    mvaddstr(3,20,"PDCurses Test Program");
+    attrset(A_NORMAL);
+
+    for (i=0;i<MAX_OPTIONS;i++)
+       mvaddstr(5+i,25,command[i].text);
+ } else
+    mvaddstr(5+old_option,25,command[old_option].text);
+
+ attrset(A_REVERSE);
+ mvaddstr(5+new_option,25,command[new_option].text);
+ attrset(A_NORMAL);
+
+ mvaddstr(13,3,"Use Up and Down Arrows to select - Enter to run - Q to quit");
+ refresh();
+}
+
diff -Naur gdb-6.8/pdcurses/demos/tui.c stsgdb-6.8/pdcurses/demos/tui.c
--- gdb-6.8/pdcurses/demos/tui.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/tui.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,887 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/********************************* tui.c ************************************/
+/*
+ * File   : tui.c      'textual user interface'
+ * Author : P.J. Kunst  (kunst@prl.philips.nl)
+ * Date   : 25-02-93
+ * Version: 1.02
+ *
+ * Modified by Mark Hessling and William McBrine
+ * halfdelay() added (and CPUACCOUNT removed) November 22, 2005
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <ctype.h>
+#include <curses.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include "tui.h"
+
+void statusmsg Args((char *));
+int waitforkey Args((void));
+void rmerror Args((void));
+
+#ifdef PDCDEBUG
+char *rcsid_tui  = "$Id: tui.c,v 1.10 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+#if defined(__unix) && !defined(__DJGPP__)
+#include <unistd.h>
+#endif
+
+#ifdef A_COLOR
+# define TITLECOLOR         1                   /* color pair indices */
+# define MAINMENUCOLOR      (2 | A_BOLD)
+# define MAINMENUREVCOLOR   (3 | A_BOLD | A_REVERSE)
+# define SUBMENUCOLOR       (4 | A_BOLD)
+# define SUBMENUREVCOLOR    (5 | A_BOLD | A_REVERSE)
+# define BODYCOLOR          6
+# define STATUSCOLOR        (7 | A_BOLD)
+# define INPUTBOXCOLOR      8
+# define EDITBOXCOLOR       (9 | A_BOLD | A_REVERSE)
+#else
+# define TITLECOLOR         0                   /* color pair indices */
+# define MAINMENUCOLOR      (A_BOLD)
+# define MAINMENUREVCOLOR   (A_BOLD | A_REVERSE)
+# define SUBMENUCOLOR       (A_BOLD)
+# define SUBMENUREVCOLOR    (A_BOLD | A_REVERSE)
+# define BODYCOLOR          0
+# define STATUSCOLOR        (A_BOLD)
+# define INPUTBOXCOLOR      0
+# define EDITBOXCOLOR       (A_BOLD | A_REVERSE)
+#endif
+
+
+#define  th   1                   /* title window height */
+#define  mh   1                   /* main menu height */
+#define  sh   2                   /* status window height */
+#define  bh   (LINES-th-mh-sh-1)  /* body window height */
+#define  bw   COLS                /* body window width */
+
+
+/******************************* STATIC ************************************/
+
+static WINDOW *wtitl, *wmain, *wbody, *wstat; /* title, menu, body, status win*/
+static int nexty, nextx;
+static int key = ERR, ch = ERR;
+static bool quit = FALSE;
+static bool incurses = FALSE;
+
+#ifndef PDCURSES
+static char wordchar Args((void)) { return 0x17; }  /* ^W */ 
+#endif
+
+#if __STDC__
+static char *padstr (char *s,int length)
+#else
+static char *padstr (s,length)
+char *s;
+int length;
+#endif
+{
+  static char buf[MAXSTRLEN];
+  char fmt[10];
+
+  sprintf (fmt, ((int)strlen(s))>length ? "%%.%ds" : "%%-%ds", length);
+  sprintf (buf, fmt, s);
+  return buf;
+}
+
+#if __STDC__
+static char *prepad (char *s, int length)
+#else
+static char *prepad (s,length)
+char *s;
+int length;
+#endif
+{
+  int i;
+  char *p = s;
+
+  if (length > 0)
+  {
+#if __STDC__
+    memmove ((void *)(s+length), (const void *)s, strlen(s)+1);
+#else
+    memmove (s+length, s, strlen(s)+1);
+#endif
+    for (i=0; i<length; i++) *p++ = ' ';
+  }
+  return s;
+}
+
+#if __STDC__
+static void rmline (WINDOW *win, int nr)   /* keeps box lines intact */
+#else
+static void rmline (win, nr)   /* keeps box lines intact */
+WINDOW *win;
+int nr;
+#endif
+{
+  mvwaddstr (win, nr, 1, padstr(" ", bw-2));
+  wrefresh (win);
+}
+
+static void initcolor Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors()) start_color();     /* foreground, background */
+  init_pair (TITLECOLOR       & ~A_ATTR, COLOR_BLACK, COLOR_CYAN);      
+  init_pair (MAINMENUCOLOR    & ~A_ATTR, COLOR_WHITE, COLOR_CYAN);    
+  init_pair (MAINMENUREVCOLOR & ~A_ATTR, COLOR_WHITE, COLOR_BLACK);
+  init_pair (SUBMENUCOLOR     & ~A_ATTR, COLOR_WHITE, COLOR_CYAN);    
+  init_pair (SUBMENUREVCOLOR  & ~A_ATTR, COLOR_WHITE, COLOR_BLACK);   
+  init_pair (BODYCOLOR        & ~A_ATTR, COLOR_WHITE, COLOR_BLUE);      
+  init_pair (STATUSCOLOR      & ~A_ATTR, COLOR_WHITE, COLOR_CYAN);   
+  init_pair (INPUTBOXCOLOR    & ~A_ATTR, COLOR_BLACK, COLOR_CYAN);
+  init_pair (EDITBOXCOLOR     & ~A_ATTR, COLOR_WHITE, COLOR_BLACK);
+#endif
+}
+
+#if __STDC__
+static void setcolor (WINDOW *win, chtype color)
+#else
+static void setcolor (win, color)
+WINDOW *win;
+chtype color;
+#endif
+{
+  chtype attr = color & A_ATTR;  /* extract Bold, Reverse, Blink bits */
+
+#ifdef A_COLOR
+  attr &= ~A_REVERSE;  /* ignore reverse, use colors instead! */
+  wattrset (win, COLOR_PAIR(color & A_CHARTEXT) | attr);
+#else
+  attr &= ~A_BOLD;     /* ignore bold, gives messy display on HP-UX */
+  wattrset (win, attr);
+#endif
+}
+
+#if __STDC__
+static void colorbox (WINDOW *win, chtype color, int hasbox)
+#else
+static void colorbox (win, color, hasbox)
+WINDOW *win;
+chtype color;
+int hasbox;
+#endif
+{
+  int maxy, maxx;
+  chtype attr = color & A_ATTR;  /* extract Bold, Reverse, Blink bits */
+
+  setcolor (win, color);
+#ifdef A_COLOR
+  if (has_colors())
+     wbkgd (win, COLOR_PAIR(color & A_CHARTEXT) | (attr & ~A_REVERSE));
+  else
+#endif
+     wbkgd (win, color);
+
+  werase (win); 
+
+  getmaxyx (win, maxy, maxx);
+
+  if (hasbox && (maxy > 2)) box (win, 0, 0);
+  touchwin (win); wrefresh (win);
+}
+
+static void idle Args((void))
+{
+  char buf[MAXSTRLEN];
+  time_t t;
+  struct tm *tp;
+
+  if (time (&t) == -1) return;  /* time not available */
+  tp = localtime(&t);
+  sprintf (buf, " %.2d-%.2d-%.4d  %.2d:%.2d:%.2d",
+    tp->tm_mday, tp->tm_mon + 1, tp->tm_year+1900,
+    tp->tm_hour, tp->tm_min, tp->tm_sec);
+  mvwaddstr (wtitl, 0, bw-strlen(buf)-2, buf);
+  wrefresh (wtitl); 
+}
+
+#if __STDC__
+static void menudim (menu *mp, int *lines, int *columns)
+#else
+static void menudim (mp, lines, columns)
+menu *mp;
+int *lines;
+int *columns;
+#endif
+{
+  int n, l, mmax = 0;
+
+  for (n=0; mp->func; n++, mp++)
+    if ((l = strlen(mp->name)) > mmax) mmax = l;
+  *lines = n;
+  *columns = mmax + 2;
+}
+
+#if __STDC__
+static void setmenupos (int y, int x)
+#else
+static void setmenupos (y, x)
+int y, x;
+#endif
+{
+  nexty = y; nextx = x;
+}
+
+#if __STDC__
+static void getmenupos (int *y, int *x)
+#else
+static void getmenupos (y, x)
+int *y, *x;
+#endif
+{
+  *y = nexty; *x = nextx;
+}
+
+#if __STDC__
+static int hotkey (char *s)
+#else
+static int hotkey (s)
+char *s;
+#endif
+{
+  int c0 = *s;  /* if no upper case found, return first char */
+
+  for (; *s; s++) if (isupper(*s)) break;
+  return *s ? *s : c0;
+}
+
+#if __STDC__
+static void repaintmenu (WINDOW *wmenu, menu *mp)
+#else
+static void repaintmenu (wmenu, mp)
+WINDOW *wmenu;
+menu *mp;
+#endif
+{
+  int i;
+  menu *p = mp;
+
+  for (i=0; p->func; i++, p++)
+    mvwaddstr (wmenu, i+1, 2, p->name);
+  touchwin (wmenu); wrefresh (wmenu);
+}
+
+#if __STDC__
+static void repaintmainmenu (int width, menu *mp)
+#else
+static void repaintmainmenu (width, mp)
+int width;
+menu *mp;
+#endif
+{
+  int i;
+  menu *p = mp;
+
+  for (i=0; p->func; i++, p++)
+    mvwaddstr (wmain, 0, i*width, prepad (padstr(p->name, width-1), 1));
+  touchwin (wmain); wrefresh (wmain);
+}
+
+static void mainhelp Args((void))
+{
+#ifdef ALT_X
+  statusmsg ("Use arrow keys and Enter to select (Alt-X to quit)");
+#else
+  statusmsg ("Use arrow keys and Enter to select");
+#endif
+}
+
+static void hidecursor Args((void))
+{
+#if defined(PDCURSES) || defined(SYSV)
+  curs_set (0);
+#endif
+}
+
+static void normalcursor Args((void))
+{
+#if defined(PDCURSES) || defined(SYSV)
+  curs_set (1);
+#endif
+}
+
+static void insertcursor Args((void))
+{
+#if defined(PDCURSES) || defined(SYSV)
+  curs_set (2);
+#endif
+}
+
+#if __STDC__
+static void mainmenu (menu *mp)
+#else
+static void mainmenu (mp)
+menu *mp;
+#endif
+{
+  int nitems, barlen, old = -1, cur = 0, c, cur0;
+
+  menudim (mp, &nitems, &barlen);
+  repaintmainmenu (barlen, mp);
+
+  while (!quit)
+  {
+    if (cur != old)
+    {
+      if (old != -1)
+      {
+        mvwaddstr (wmain, 0, old*barlen, 
+          prepad (padstr(mp[old].name, barlen-1), 1));
+        statusmsg (mp[cur].desc);
+      }
+      else mainhelp ();
+      setcolor (wmain, MAINMENUREVCOLOR);
+      mvwaddstr (wmain, 0, cur*barlen, 
+        prepad (padstr(mp[cur].name, barlen-1), 1));
+      setcolor (wmain, MAINMENUCOLOR);
+      old = cur;
+      wrefresh (wmain);
+    }
+    switch (c = (key != ERR ? key : waitforkey()))
+    {
+      case KEY_DOWN:
+      case '\n':                              /* menu item selected ! */
+        touchwin (wbody); wrefresh (wbody);
+        rmerror ();
+        setmenupos (th+mh, cur*barlen);
+        normalcursor ();
+        (mp[cur].func)();                     /* perform function */
+        hidecursor ();
+        switch (key)
+        {
+          case KEY_LEFT:
+            cur = (cur+nitems-1) % nitems;
+            key = '\n';
+            break;
+
+          case KEY_RIGHT:
+            cur = (cur+1) % nitems;
+            key = '\n';
+            break;
+
+          default:
+            key = ERR;
+            break;
+        }
+        repaintmainmenu (barlen, mp);
+        old = -1;
+        break;
+
+      case KEY_LEFT:
+        cur = (cur+nitems-1) % nitems;
+        break;
+
+      case KEY_RIGHT:
+        cur = (cur+1) % nitems;
+        break;
+
+      case KEY_ESC:
+        mainhelp ();
+        break;
+
+      default:
+        cur0 = cur;
+        do { cur = (cur+1) % nitems;
+        } while ((cur != cur0) && (hotkey(mp[cur].name) != toupper(c)));
+        if (hotkey(mp[cur].name) == toupper(c)) key = '\n';
+        break;
+    }
+  }
+  rmerror ();
+  touchwin (wbody); wrefresh (wbody);
+}
+
+static void cleanup Args((void)) /* cleanup curses settings */
+{
+  if (incurses)
+  {
+    delwin (wtitl);
+    delwin (wmain);
+    delwin (wbody);
+    delwin (wstat);
+    normalcursor ();
+    endwin (); 
+#ifdef XCURSES
+    XCursesExit();
+#endif
+    incurses = FALSE;
+  }
+}
+
+
+/******************************* EXTERNAL **********************************/
+
+void clsbody Args((void))
+{
+  werase (wbody); wmove (wbody, 0, 0);
+}
+
+int bodylen Args((void))
+{
+  int maxy, maxx;
+
+  getmaxyx (wbody, maxy, maxx);
+  return maxy;
+}
+
+WINDOW *bodywin Args((void))
+{
+  return wbody;
+}
+
+void rmerror Args((void))
+{
+  rmline (wstat, 0);
+}
+
+void rmstatus Args((void))
+{
+  rmline (wstat, 1);
+}
+
+#if __STDC__
+void titlemsg (char *msg)
+#else
+void titlemsg (msg)
+char *msg;
+#endif
+{
+  mvwaddstr (wtitl, 0, 2, padstr(msg, bw-3));
+  wrefresh (wtitl);
+}
+
+#if __STDC__
+void bodymsg (char *msg)
+#else
+void bodymsg (msg)
+char *msg;
+#endif
+{
+  waddstr (wbody, msg);
+  wrefresh (wbody);
+}
+
+#if __STDC__
+void errormsg (char *msg)
+#else
+void errormsg (msg)
+char *msg;
+#endif
+{
+  beep ();
+  mvwaddstr (wstat, 0, 2, padstr(msg, bw-3));
+  wrefresh (wstat);
+}
+
+#if __STDC__
+void statusmsg (char *msg)
+#else
+void statusmsg (msg)
+char *msg;
+#endif
+{
+  mvwaddstr (wstat, 1, 2, padstr(msg, bw-3));
+  wrefresh (wstat);
+}
+
+bool keypressed Args((void))
+{
+  ch = wgetch(wbody);
+
+  return ch != ERR;
+}
+
+int getkey Args((void))
+{
+  int c = ch;
+
+  ch = ERR;
+#ifdef ALT_X
+  quit = (c == ALT_X);     /* PC only ! */
+#endif
+  return c;
+}
+
+int waitforkey Args((void))
+{
+  do idle (); while (!keypressed());
+  return getkey ();
+}
+
+void DoExit Args((void))   /* terminate program */
+{
+  quit = TRUE;
+}
+
+#if __STDC__
+void domenu (menu *mp)
+#else
+void domenu (mp)
+menu *mp;
+#endif
+{
+  int y, x, nitems, barlen, mheight, mw, old = -1, cur = 0, cur0;
+  bool stop = FALSE;
+  WINDOW *wmenu;
+
+  hidecursor ();
+  getmenupos (&y, &x);
+  menudim (mp, &nitems, &barlen);
+  mheight = nitems+2; mw = barlen+2;
+  wmenu = newwin (mheight, mw, y, x);
+  colorbox (wmenu, SUBMENUCOLOR, 1);
+  repaintmenu (wmenu, mp);
+
+  key = ERR;
+  while (!stop && !quit)
+  {
+    if (cur != old)
+    {
+      if (old != -1)
+        mvwaddstr (wmenu, old+1, 1, prepad (padstr(mp[old].name, barlen-1), 1));
+      setcolor (wmenu, SUBMENUREVCOLOR);
+      mvwaddstr (wmenu, cur+1, 1, prepad (padstr(mp[cur].name, barlen-1), 1));
+      setcolor (wmenu, SUBMENUCOLOR);
+      statusmsg (mp[cur].desc);
+      old = cur;
+      wrefresh (wmenu);
+    }
+    switch (key = ((key != ERR) ? key : waitforkey()))
+    {
+      case '\n':                              /* menu item selected ! */
+        touchwin (wbody); wrefresh (wbody);
+        setmenupos (y+1, x+1);
+        rmerror ();
+        key = ERR;
+        normalcursor ();
+        (mp[cur].func)();                     /* perform function */
+        hidecursor ();
+        repaintmenu (wmenu, mp);
+        old = -1;
+        break;
+
+      case KEY_UP:
+        cur = (cur+nitems-1) % nitems;
+        key = ERR;
+        break;
+
+      case KEY_DOWN:
+        cur = (cur+1) % nitems;
+        key = ERR;
+        break;
+
+      case KEY_ESC:
+      case KEY_LEFT:
+      case KEY_RIGHT:
+        if (key == KEY_ESC) key = ERR;  /* return to previous submenu */
+        stop = TRUE;
+        break;
+
+      default:
+        cur0 = cur;
+        do { cur = (cur+1) % nitems;
+        } while ((cur != cur0) && (hotkey(mp[cur].name) != toupper((int)key)));
+        key = (hotkey(mp[cur].name) == toupper((int)key)) ? '\n' : ERR;
+        break;
+    }
+  }
+  rmerror ();
+  delwin (wmenu);
+  touchwin (wbody); wrefresh (wbody);
+}
+
+#if __STDC__
+void startmenu (menu *mp, char *mtitle)
+#else
+void startmenu (mp, mtitle)
+menu *mp;
+char *mtitle;
+#endif
+{
+  initscr ();
+  incurses = TRUE;
+  initcolor ();
+/*  atexit (cleanup); */
+
+  wtitl = subwin (stdscr, th,  bw,    0, 0);
+  wmain = subwin (stdscr, mh,  bw,   th, 0);
+  wbody = subwin (stdscr, bh,  bw,  th+mh, 0);
+  wstat = subwin (stdscr, sh,  bw, th+mh+bh, 0);
+
+  colorbox (wtitl, TITLECOLOR, 0);
+  colorbox (wmain, MAINMENUCOLOR, 0);
+  colorbox (wbody, BODYCOLOR, 0);
+  colorbox (wstat, STATUSCOLOR, 0);
+
+  if (mtitle) titlemsg (mtitle);
+
+  cbreak ();                /* direct input (no newline required)... */
+  noecho ();                /* ... without echoing */
+  hidecursor ();            /* hide cursor (if possible) */
+  nodelay (wbody, TRUE);    /* don't wait for input... */
+  halfdelay(10);            /* ...well, no more than a second, anyway */
+  keypad (wbody, TRUE);     /* enable cursor keys */
+  scrollok (wbody, TRUE);   /* enable scrolling in main window */
+  leaveok (stdscr, TRUE);
+  leaveok (wtitl, TRUE);
+  leaveok (wmain, TRUE);
+  leaveok (wstat, TRUE);
+
+  mainmenu (mp);
+
+  cleanup ();
+}
+
+
+/*man-start*********************************************************************
+
+  weditstr()     - edit string
+
+  PDCurses Description:
+        The initial value of 'str' with a maximum length of 'field'-1,
+        which is supplied by the calling routine, is editted. The user's 
+        erase (^H), kill (^U) and delete word (^W) chars are interpreted. 
+        The PC insert or Tab keys toggle between insert and edit mode.
+        Escape aborts the edit session, leaving 'str' unchanged.
+        Enter, Up or Down Arrow are used to accept the changes to 'str'.
+
+        NOTE: editstr(), mveditstr(), and mvweditstr() are macros.
+
+  PDCurses Return Value:
+        These functions return the input terminating character on 
+        success (Escape, Enter, Up or Down Arrow) and ERR on error.
+
+  PDCurses Errors:
+        It is an error to call this function with a NULL window pointer.
+        The length of the initial 'str' must not exceed 'field'-1.
+
+  Portability:
+        PDCurses        int weditstr( WINDOW* win, char* str, int field );
+        X/Open Dec '88 
+        BSD Curses    
+        SYS V Curses 
+
+**man-end**********************************************************************/
+
+
+#if __STDC__
+static void repainteditbox (WINDOW *win, int x, char *buf)
+#else
+static void repainteditbox (win, x, buf)
+WINDOW *win;
+int x;
+char *buf;
+#endif
+{
+  int maxy, maxx;
+
+  getmaxyx (win, maxy, maxx);
+  werase (win); mvwprintw (win, 0, 0, "%s", padstr (buf, maxx));
+  wmove (win, 0, x); wrefresh (win); 
+}
+
+#if __STDC__
+int weditstr (WINDOW *win, char *buf, int field)
+#else
+int weditstr (win, buf, field)
+WINDOW *win;
+char *buf;
+int field;
+#endif
+{
+  char org[MAXSTRLEN], *tp, *bp = buf;
+  bool defdisp = TRUE, stop = FALSE, insert = FALSE;
+  int cury, curx, begy, begx, oldattr;
+  WINDOW *wedit;
+  int c=0;
+
+  if ((field>=MAXSTRLEN) || (buf==NULL) || ((int)strlen(buf) > field-1))
+    return ERR;
+  strcpy (org, buf);  /* save original */
+
+  wrefresh (win);
+  getyx (win, cury, curx); getbegyx (win, begy, begx);
+  wedit = subwin (win, 1, field, begy+cury, begx+curx);  /* window relative */
+  oldattr = wedit->_attrs;
+  colorbox (wedit, EDITBOXCOLOR, 0);
+
+  normalcursor ();
+  while (!stop)
+  {
+    repainteditbox (wedit, bp-buf, buf);
+    switch (c = waitforkey())
+    {
+      case KEY_ESC:
+        strcpy (buf, org);  /* restore original */
+        stop = TRUE;
+        break;
+
+      case '\n':  /* ENTER */
+      case KEY_UP:
+      case KEY_DOWN:
+        stop = TRUE;
+        break;
+
+      case KEY_LEFT:
+        if (bp > buf) bp--;
+        break;
+
+      case KEY_RIGHT:
+        defdisp = FALSE;
+        if (bp - buf < (int)strlen(buf)) bp++;
+        break;
+
+      case '\t':     /* TAB, because Insert not properly handled on HP-UX ! */
+      case KEY_IC:   /* enter insert mode */
+      case KEY_EIC:  /* exit insert mode */
+        defdisp = FALSE;
+        insert = !insert;
+        if (insert) insertcursor (); else normalcursor ();
+        break;
+
+      default:
+        if (c == erasechar())  /* backspace, ^H */
+        {
+          if (bp > buf)
+          {
+#if __STDC__
+            memmove ((void *)(bp-1), (const void *)bp, strlen(bp)+1);
+#else
+            memmove (bp-1, bp, strlen(bp)+1);
+#endif
+            bp--;
+          }
+        }
+        else if (c == killchar())  /* ^U */
+        {
+          bp = buf; *bp = '\0';
+        }
+        else if (c == wordchar())  /* ^W */
+        {
+          tp = bp;
+          while ((bp > buf) && (*(bp-1) == ' ')) bp--;
+          while ((bp > buf) && (*(bp-1) != ' ')) bp--;
+#if __STDC__
+          memmove ((void *)bp, (const void *)tp, strlen(tp)+1);
+#else
+          memmove (bp, tp, strlen(tp)+1);
+#endif
+        }
+        else if (isprint(c))
+        {
+          if (defdisp) { bp = buf; *bp = '\0'; defdisp = FALSE; }
+          if (insert)
+          {
+            if ((int)strlen(buf) < field-1)
+            {
+#if __STDC__
+              memmove ((void *)(bp+1), (const void *)bp, strlen(bp)+1);
+#else
+              memmove (bp+1, bp, strlen(bp)+1);
+#endif
+              *bp++ = c;
+            }
+          }
+          else if (bp-buf < field-1)
+          {
+            if (!*bp) bp[1] = '\0'  /* append new string terminator */;
+            *bp++ = c;
+          }
+        }
+        break;
+    }
+  }
+  wattrset (wedit, oldattr);
+  repainteditbox (wedit, bp-buf, buf);
+  delwin (wedit);
+  return c;
+}
+
+#if __STDC__
+WINDOW *winputbox (WINDOW *win, int nlines, int ncols)
+#else
+WINDOW *winputbox (win, nlines, ncols)
+WINDOW *win;
+int nlines, ncols;
+#endif
+{
+  int cury, curx, begy, begx;
+  WINDOW *winp;
+
+  getyx (win, cury, curx); getbegyx (win, begy, begx);
+  winp = newwin (nlines, ncols, begy+cury, begx+curx); /* window relative */
+  colorbox (winp, INPUTBOXCOLOR, 1);
+  return winp;
+}
+
+#if __STDC__
+int getstrings (char *desc[], char *buf[], int field)
+#else
+int getstrings (desc, buf, field)
+char *desc[];
+char *buf[];
+int field;
+#endif
+{
+  WINDOW *winput;
+  int oldy, oldx, maxy, maxx, nlines, ncols, i, n, l, mmax = 0;
+  int c=0;
+  bool stop = FALSE;
+
+  for (n=0; desc[n]; n++) if ((l = strlen(desc[n])) > mmax) mmax = l;
+  nlines = n + 2; ncols = mmax + field + 4;
+  getyx (wbody, oldy, oldx); getmaxyx (wbody, maxy, maxx);
+  winput = mvwinputbox (wbody, (maxy-nlines)/2, (maxx-ncols)/2, nlines, ncols);
+  for (i=0; i<n; i++) mvwprintw (winput, i+1, 2, "%s", desc[i]);
+  i = 0;
+  while (!stop)
+  {
+    switch (c = mvweditstr(winput, i+1, mmax+3, buf[i], field))
+    {
+      case KEY_ESC:
+        stop = TRUE;
+        break;
+
+      case KEY_UP:
+        i = (i+n-1)%n;
+        break;
+
+      case '\n':
+      case '\t':
+      case KEY_DOWN:
+        if (++i == n) stop = TRUE;  /* all passed ? */
+        break;
+    }
+  }
+  delwin (winput);
+  touchwin (wbody); wmove (wbody, oldy, oldx); wrefresh (wbody);
+  return c;
+}
diff -Naur gdb-6.8/pdcurses/demos/tuidemo.c stsgdb-6.8/pdcurses/demos/tuidemo.c
--- gdb-6.8/pdcurses/demos/tuidemo.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/tuidemo.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,265 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/********************************* tuidemo.c ********************************/
+/*
+ * File   : tuidemo.c
+ * Author : P.J. Kunst  (kunst@prl.philips.nl)
+ * Date   : 25-02-93
+ * Version: 1.02
+ *
+ * Purpose: This program demonstrates the use of the 'curses' library
+ *          for the creation of (simple) menu-operated programs.
+ *          In the PD-Curses version, use is made of colors for the
+ *          highlighting of subwindows (title bar, status bar etc).
+ *          The program was tested using DJGPP 1.09 ('GO32') and
+ *          Turbo C (2.0), as well as on a UNIX machine (HP-UX 8.07).
+ *
+ * Acknowledgement: some ideas were borrowed from Mark Hessling's
+ *                  version of the 'testcurs' program.
+ */
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "tui.h"
+
+#ifdef PDCDEBUG
+char *rcsid_tuidemo  = "$Id: tuidemo.c,v 1.5 2005/12/07 01:37:43 wmcbrine Exp $";
+#endif
+
+#if defined(XCURSES)
+#  define FNAME   "demos/tui.c"    /* change this if source at other location */
+#else
+#  define FNAME   "demos\\tui.c"    /* change this if source at other location */
+#endif
+
+/**************************** strings entry box ***************************/
+
+void address Args((void))
+{
+#ifdef __STDC__
+  char *fieldname[6] = {"Name","Street","City","State","Country",(char*)0};
+#else
+  char *fieldname[6];
+#endif
+  char *fieldbuf[5];
+  WINDOW *wbody = bodywin();
+  int i, field = 50;
+
+#ifndef __STDC__
+  fieldname[0] = "Name";
+  fieldname[1] = "Street";
+  fieldname[2] = "City";
+  fieldname[3] = "State";
+  fieldname[4] = "Country";
+  fieldname[5] = (char*)0;
+#endif
+  for (i=0; i<5; i++) fieldbuf[i] = (char *) calloc (field+1, sizeof(char));
+  if (getstrings (fieldname, fieldbuf, field) != KEY_ESC)
+  {
+    for (i=0; fieldname[i]; i++)
+      wprintw (wbody, "%10s : %s\n", fieldname[i], fieldbuf[i]);
+    wrefresh (wbody);
+  }
+  for (i=0; i<5; i++) free (fieldbuf[i]);
+}
+
+/**************************** string entry box ****************************/
+
+#if __STDC__
+char *getfname (char *desc, char *fname, int field)
+#else
+char *getfname (desc, fname, field)
+char *desc;
+char *fname;
+int field;
+#endif
+{
+  char *fieldname[2];
+  char *fieldbuf[1];
+
+  fieldname[0] = desc; fieldname[1] = 0; fieldbuf[0] = fname;
+  return (getstrings (fieldname, fieldbuf, field) == KEY_ESC) ? NULL : fname;
+}
+
+/**************************** a very simple file browser ******************/
+
+#if __STDC__
+void showfile (char *fname)
+#else
+void showfile (fname)
+char *fname;
+#endif
+{
+  int i, bh = bodylen();
+  FILE *fp;
+  char buf[MAXSTRLEN];
+  bool ateof = FALSE;
+
+  statusmsg ("FileBrowser: Hit key to continue, Q to quit");
+
+  if ((fp = fopen (fname, "r")) != NULL)   /* file available ? */
+  {
+    while (!ateof)
+    {
+      clsbody ();
+      for (i=0; i<bh-1 && !ateof; i++)
+      {
+        buf[0] = '\0';
+        fgets (buf, MAXSTRLEN, fp);
+        if (strlen(buf)) bodymsg (buf); else ateof = TRUE;
+      }
+      switch (waitforkey())
+      {
+        case 'Q':
+        case 'q':
+        case 0x1b: /* ESCAPE */
+          ateof = TRUE;
+          break;
+
+        default:
+          break;
+      }
+    }
+    fclose (fp);
+  }
+  else
+  {
+    sprintf (buf, "ERROR: file '%s' not found", fname);
+    errormsg (buf);
+  }
+}
+
+/***************************** forward declarations ***********************/
+
+void sub0 Args((void)), sub1 Args((void)), sub2 Args((void)), sub3 Args((void));
+void func1 Args((void)), func2 Args((void));
+void subfunc1 Args((void)), subfunc2 Args((void));
+void subsub Args((void));
+
+/***************************** menus initialization ***********************/
+
+menu MainMenu[] =
+{
+ { "Asub",     sub0,     "Go inside first submenu" },
+ { "Bsub",     sub1,     "Go inside second submenu" },
+ { "Csub",     sub2,     "Go inside third submenu" },
+ { "Dsub",     sub3,     "Go inside fourth submenu" },
+ { "",         (FUNC)0,  "" }   /* always add this as the last item ! */
+};
+
+menu SubMenu0[] =
+{
+ { "Exit",     DoExit,     "Terminate program" },
+ { "",         (FUNC)0,  "" }   /* always add this as the last item ! */
+};
+
+menu SubMenu1[] =
+{
+ { "OneBeep",  func1,    "Sound one beep" },
+ { "TwoBeeps", func2,    "Sound two beeps" },
+ { "",         (FUNC)0,  "" }   /* always add this as the last item ! */
+};
+
+menu SubMenu2[] =
+{
+ { "Browse",   subfunc1, "Source file lister" },
+ { "Input",    subfunc2, "Interactive file lister" },
+ { "Address",  address,  "Get address data" },
+ { "",         (FUNC)0,  "" }   /* always add this as the last item ! */
+};
+
+menu SubMenu3[] =
+{
+ { "SubSub",   subsub,   "Go inside sub-submenu" },
+ { "",         (FUNC)0,  "" }   /* always add this as the last item ! */
+};
+
+/***************************** main menu functions ************************/
+
+void sub0 Args((void))
+{
+  domenu (SubMenu0);
+}
+
+void sub1 Args((void))
+{
+  domenu (SubMenu1);
+}
+
+void sub2 Args((void))
+{
+  domenu (SubMenu2);
+}
+
+void sub3 Args((void))
+{
+  domenu (SubMenu3);
+}
+
+/***************************** submenu1 functions *************************/
+
+void func1 Args((void))
+{
+  beep ();
+  bodymsg ("One beep! ");
+}
+
+void func2 Args((void))
+{
+  beep ();
+  bodymsg ("Two beeps! ");
+  beep ();
+}
+
+/***************************** submenu2 functions *************************/
+
+void subfunc1 Args((void))
+{
+  showfile (FNAME);
+}
+
+void subfunc2 Args((void))
+{
+  char fname[MAXSTRLEN];
+
+  strcpy (fname, FNAME);
+  if (getfname ("File to browse:", fname, 50)) showfile (fname);
+}
+
+/***************************** submenu3 functions *************************/
+
+void subsub Args((void))
+{
+  domenu (SubMenu2);
+}
+
+/***************************** start main menu  ***************************/
+
+int main Args((void))
+{
+  startmenu (MainMenu, "TUI - 'textual user interface' demonstration program");
+
+  return 0;
+}
+/********************************* tuidemo.c ********************************/
diff -Naur gdb-6.8/pdcurses/demos/tui.h stsgdb-6.8/pdcurses/demos/tui.h
--- gdb-6.8/pdcurses/demos/tui.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/tui.h	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,108 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+ * File   : tui.h      'textual user interface'
+ * Author : P.J. Kunst  (kunst@prl.philips.nl)
+ * Date   : 25-02-93
+ * Version: 1.02
+ */
+
+#ifndef _TUI_H_
+#define _TUI_H_
+
+#include <curses.h>
+
+#if defined(HAVE_PROTO) && !defined(__STDC__)
+# define __STDC__ 1
+#endif
+
+#ifndef Args
+# if __STDC__
+#  define Args(x) x
+# else
+#  define Args(x) ()
+# endif
+#endif
+
+#ifndef getbegyx
+#define getbegyx(w,y,x)        ( y = (w)->_begy, x = (w)->_begx )
+#endif
+#ifndef getmaxyx
+#define getmaxyx(w,y,x)        ( y = (w)->_maxy, x = (w)->_maxx )
+#endif
+
+#ifdef A_COLOR
+#define A_ATTR  (A_ATTRIBUTES ^ A_COLOR)  /* A_BLINK, A_REVERSE, A_BOLD */
+#else
+#define A_ATTR  (A_ATTRIBUTES)            /* standard UNIX attributes */
+#endif
+
+
+#define MAXSTRLEN  256
+#define KEY_ESC    0x1b     /* Escape */
+
+#if __STDC__
+typedef void (*FUNC)(void);
+#else
+typedef void (*FUNC)();
+#endif
+
+typedef struct 
+{
+  char *name;   /* item label */
+  FUNC  func;   /* (pointer to) function */
+  char *desc;   /* function description */
+} menu;
+
+/* ANSI C function prototypes: */
+
+void    clsbody    Args((void));
+int     bodylen    Args((void));
+WINDOW *bodywin    Args((void));
+
+void    rmerror    Args((void));
+void    rmstatus   Args((void));
+
+void    titlemsg   Args((char *msg));
+void    bodymsg    Args((char *msg));
+void    errormsg   Args((char *msg));
+void    statusmsg  Args((char *msg));
+
+bool    keypressed Args((void));
+int     getkey     Args((void));
+int     waitforkey Args((void));
+
+void    DoExit     Args((void));
+void    startmenu  Args((menu *mp, char *title));
+void    domenu     Args((menu *mp));
+
+int     weditstr   Args((WINDOW *win, char *buf, int field));
+WINDOW *winputbox  Args((WINDOW *win, int nlines, int ncols));
+int     getstrings Args((char *desc[], char *buf[], int field));
+
+#define editstr(s,f)           (weditstr(stdscr,s,f))
+#define mveditstr(y,x,s,f)     (move(y,x)==ERR?ERR:editstr(s,f))
+#define mvweditstr(w,y,x,s,f)  (wmove(w,y,x)==ERR?ERR:weditstr(w,s,f))
+
+#define inputbox(l,c)          (winputbox(stdscr,l,c))
+#define mvinputbox(y,x,l,c)    (move(y,x)==ERR?w:inputbox(l,c))
+#define mvwinputbox(w,y,x,l,c) (wmove(w,y,x)==ERR?w:winputbox(w,l,c))
+
+#endif
diff -Naur gdb-6.8/pdcurses/demos/xmas.c stsgdb-6.8/pdcurses/demos/xmas.c
--- gdb-6.8/pdcurses/demos/xmas.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/demos/xmas.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,1375 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/******************************************************************************/
+/* asciixmas                                                                  */
+/* December 1989             Larry Bartz           Indianapolis, IN           */
+/*                                                                            */
+/*                                                                            */
+/* I'm dreaming of an ascii character-based monochrome Christmas,             */
+/* Just like the one's I used to know!                                        */
+/* Via a full duplex communications channel,                                  */
+/* At 9600 bits per second,                                                   */
+/* Even though it's kinda slow.                                               */
+/*                                                                            */
+/* I'm dreaming of an ascii character-based monochrome Christmas,             */
+/* With ev'ry C program I write!                                              */
+/* May your screen be merry and bright!                                       */
+/* And may all your Christmases be amber or green,                            */
+/* (for reduced eyestrain and improved visibility)!                           */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* IMPLEMENTATION                                                             */
+/*                                                                            */
+/* Feel free to modify the defined string FROMWHO to reflect you, your        */
+/* organization, your site, whatever.                                         */
+/*                                                                            */
+/* This really looks a lot better if you can turn off your cursor before      */
+/* execution. I wanted to do that here but very few termcap entries or        */
+/* terminfo definitions have the appropriate string defined. If you know      */
+/* the string(s) for the terminal(s) you use or which your site supports,     */
+/* you could call asciixmas from within a shell in which you issue the        */
+/* string to the terminal. The cursor is distracting but it doesn't really    */
+/* ruin the show.                                                             */
+/*                                                                            */
+/* At our site, we invoke this for our users just after login and the         */
+/* determination of terminal type.                                            */
+/*                                                                            */
+/*                                                                            */
+/* PORTABILITY                                                                */
+/*                                                                            */
+/* I wrote this using only the very simplest curses functions so that it      */
+/* might be the most portable. I was personally able to test on five          */
+/* different cpu/UNIX combinations.                                           */
+/*                                                                            */
+/*                                                                            */
+/* COMPILE                                                                    */
+/*                                                                            */
+/* usually this:                                                              */
+/*                                                                            */
+/* cc -O asciixmas.c -lcurses -o asciixmas -s                                 */
+/*                                                                            */
+/*                                                                            */
+/* Zilog S8000 models 11, 21, 31, etc with ZEUS variant of SYSTEM III         */
+/* maybe other SYSTEM III also:                                               */
+/*                                                                            */
+/* cc asciixmas.c -lcurses -ltermlib -o asciixmas -s                          */
+/*                                                                            */
+/* as above with optional "peephole optimizer" installed:                     */
+/*                                                                            */
+/* cc -O asciixmas.c -lcurses -ltermlib -o asciixmas -s                       */
+/*                                                                            */
+/*                                                                            */
+/* Zilog S8000 models 32, 130 with WE32100 chip and SYS V, REL2               */
+/* maybe 3B2 also?                                                            */
+/*                                                                            */
+/* cc -f -O -K sd asciixmas.c -lcurses -o asciixmas -s                        */
+/*                                                                            */
+/*                                                                            */
+/* Pyramid, Sequent, any other "dual universe" types compile and execute      */
+/* under either universe. The compile line for the ucb universe (as you       */
+/* might expect) is the same as for SYS III UNIX:                             */
+/*                                                                            */
+/* cc -O asciixmas.c -lcurses -ltermlib -o asciixmas -s                       */
+/*                                                                            */
+/* The above compile will also hold true for other BSD systems. (I hope)      */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* For the Scrooges out there among you who don't want this thing to loop     */
+/* forever (or until the user hits a key), insert this into your compile        */
+/* line just after "cc" :                                                     */
+/*                                                                            */
+/* -DNOLOOP                                                                   */
+/*                                                                            */
+/* like so:                                                                   */
+/*                                                                            */
+/* cc -DNOLOOP -O asciixmas.c -lcurses -o asciixmas -s                        */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/******************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_xmas  = "$Id: xmas.c,v 1.7 2005/12/07 01:37:43 wmcbrine Exp $";
+#endif
+
+#include <curses.h>
+#include <signal.h>
+
+#if defined(HAVE_PROTO) && !defined(__STDC__)
+# define __STDC__ 1
+#endif
+
+#ifndef Args
+# if __STDC__
+#  define Args(x) x
+# else
+#  define Args(x) ()
+# endif
+#endif
+
+int boxit Args((void));
+int seas Args((void));
+int greet Args((void));
+int fromwho Args((void));
+int del_msg Args((void));
+int tree Args((void));
+int balls Args((void));
+int star Args((void));
+int strng1 Args((void));
+int strng2 Args((void));
+int strng3 Args((void));
+int strng4 Args((void));
+int strng5 Args((void));
+int blinkit Args((void));
+int reindeer Args((void));
+void done Args((void));
+
+#define FROMWHO "Mark Hessling - (M.Hessling@qut.edu.au)"
+
+int y_pos, x_pos;
+
+WINDOW
+       *treescrn, *treescrn2,*treescrn3, *treescrn4,*treescrn5, *treescrn6,
+       *treescrn7, *treescrn8,
+       *dotdeer0,
+       *stardeer0,
+       *lildeer0, *lildeer1, *lildeer2, *lildeer3,
+       *middeer0, *middeer1, *middeer2, *middeer3,
+       *bigdeer0, *bigdeer1, *bigdeer2, *bigdeer3, *bigdeer4,
+       *lookdeer0, *lookdeer1, *lookdeer2, *lookdeer3, *lookdeer4,
+       *w_holiday,
+       *w_del_msg;
+
+#if __STDC__
+int main(int argc, char **argv)
+#else
+int main(argc, argv)
+int argc;
+char **argv;
+#endif
+{
+ int loopy;
+ chtype noseattr;
+
+#ifdef XCURSES
+  Xinitscr(argc, argv);
+#else
+  initscr();
+#endif
+  nodelay(stdscr, TRUE);
+  noecho();
+  nonl();
+  refresh();
+/*  signal(SIGINT,done);
+  signal(SIGTERM,done);
+#if !defined	DOS && !defined OS2
+  signal(SIGHUP,done);
+  signal(SIGQUIT,done);
+#endif
+*/
+
+#ifdef A_COLOR
+  if ( has_colors() )
+    {
+  	start_color();
+  	init_pair(31, COLOR_RED, COLOR_BLACK);
+  	noseattr = COLOR_PAIR(31);
+    }
+  else
+  	noseattr = A_NORMAL;
+#else
+  	noseattr = A_NORMAL;
+#endif
+
+#ifdef PDCURSES
+  curs_set(0);
+#endif
+
+  treescrn = newwin(16,27,3,53);
+  treescrn2 = newwin(16,27,3,53);
+  treescrn3 = newwin(16,27,3,53);
+  treescrn4 = newwin(16,27,3,53);
+  treescrn5 = newwin(16,27,3,53);
+  treescrn6 = newwin(16,27,3,53);
+  treescrn7 = newwin(16,27,3,53);
+  treescrn8 = newwin(16,27,3,53);
+
+  dotdeer0 = newwin(3,71,0,8);
+
+  stardeer0 = newwin(4,56,0,8);
+
+  lildeer0 = newwin(7,53,0,8);
+  lildeer1 = newwin(2,4,0,0);
+  lildeer2 = newwin(2,4,0,0);
+  lildeer3 = newwin(2,4,0,0);
+
+  middeer0 = newwin(15,42,0,8);
+  middeer1 = newwin(3,7,0,0);
+  middeer2 = newwin(3,7,0,0);
+  middeer3 = newwin(3,7,0,0);
+
+  bigdeer0 = newwin(10,23,0,0);
+  bigdeer1 = newwin(10,23,0,0);
+  bigdeer2 = newwin(10,23,0,0);
+  bigdeer3 = newwin(10,23,0,0);
+  bigdeer4 = newwin(10,23,0,0);
+
+  lookdeer0 = newwin(10,25,0,0);
+  lookdeer1 = newwin(10,25,0,0);
+  lookdeer2 = newwin(10,25,0,0);
+  lookdeer3 = newwin(10,25,0,0);
+  lookdeer4 = newwin(10,25,0,0);
+
+  w_holiday = newwin(1,26,3,27);
+
+  w_del_msg = newwin(1,12,23,60);
+
+#if 0
+  mvwaddstr(w_del_msg,0,0,"Hit any key to quit");
+#endif
+
+  mvwaddstr(w_holiday,0,0,"H A P P Y  H O L I D A Y S");
+
+  /* set up the windows for our various reindeer */
+
+  /* lildeer1 */
+  mvwaddch(lildeer1,0,0,(chtype)'V');
+  mvwaddch(lildeer1,1,0,(chtype)'@');
+  mvwaddch(lildeer1,1,1,(chtype)'<');
+  mvwaddch(lildeer1,1,2,(chtype)'>');
+  mvwaddch(lildeer1,1,3,(chtype)'~');
+
+  /* lildeer2 */
+  mvwaddch(lildeer2,0,0,(chtype)'V');
+  mvwaddch(lildeer2,1,0,(chtype)'@');
+  mvwaddch(lildeer2,1,1,(chtype)'|');
+  mvwaddch(lildeer2,1,2,(chtype)'|');
+  mvwaddch(lildeer2,1,3,(chtype)'~');
+
+  /* lildeer3 */
+  mvwaddch(lildeer3,0,0,(chtype)'V');
+  mvwaddch(lildeer3,1,0,(chtype)'@');
+  mvwaddch(lildeer3,1,1,(chtype)'>');
+  mvwaddch(lildeer3,1,2,(chtype)'<');
+  mvwaddch(lildeer2,1,3,(chtype)'~');
+
+
+  /* middeer1 */
+  mvwaddch(middeer1,0,2,(chtype)'y');
+  mvwaddch(middeer1,0,3,(chtype)'y');
+  mvwaddch(middeer1,1,2,(chtype)'0');
+  mvwaddch(middeer1,1,3,(chtype)'(');
+  mvwaddch(middeer1,1,4,(chtype)'=');
+  mvwaddch(middeer1,1,5,(chtype)')');
+  mvwaddch(middeer1,1,6,(chtype)'~');
+  mvwaddch(middeer1,2,3,(chtype)'\\');
+  mvwaddch(middeer1,2,4,(chtype)'/');
+
+  /* middeer2 */
+  mvwaddch(middeer2,0,2,(chtype)'y');
+  mvwaddch(middeer2,0,3,(chtype)'y');
+  mvwaddch(middeer2,1,2,(chtype)'0');
+  mvwaddch(middeer2,1,3,(chtype)'(');
+  mvwaddch(middeer2,1,4,(chtype)'=');
+  mvwaddch(middeer2,1,5,(chtype)')');
+  mvwaddch(middeer2,1,6,(chtype)'~');
+  mvwaddch(middeer2,2,3,(chtype)'|');
+  mvwaddch(middeer2,2,5,(chtype)'|');
+
+  /* middeer3 */
+  mvwaddch(middeer3,0,2,(chtype)'y');
+  mvwaddch(middeer3,0,3,(chtype)'y');
+  mvwaddch(middeer3,1,2,(chtype)'0');
+  mvwaddch(middeer3,1,3,(chtype)'(');
+  mvwaddch(middeer3,1,4,(chtype)'=');
+  mvwaddch(middeer3,1,5,(chtype)')');
+  mvwaddch(middeer3,1,6,(chtype)'~');
+  mvwaddch(middeer3,2,2,(chtype)'/');
+  mvwaddch(middeer3,2,6,(chtype)'\\');
+
+
+  /* bigdeer1 */
+  mvwaddch(bigdeer1,0,17,(chtype)'\\');
+  mvwaddch(bigdeer1,0,18,(chtype)'/');
+  mvwaddch(bigdeer1,0,20,(chtype)'\\');
+  mvwaddch(bigdeer1,0,21,(chtype)'/');
+  mvwaddch(bigdeer1,1,18,(chtype)'\\');
+  mvwaddch(bigdeer1,1,20,(chtype)'/');
+  mvwaddch(bigdeer1,2,19,(chtype)'|');
+  mvwaddch(bigdeer1,2,20,(chtype)'_');
+  mvwaddch(bigdeer1,3,18,(chtype)'/');
+  mvwaddch(bigdeer1,3,19,(chtype)'^');
+  mvwaddch(bigdeer1,3,20,(chtype)'0');
+  mvwaddch(bigdeer1,3,21,(chtype)'\\');
+  mvwaddch(bigdeer1,4,17,(chtype)'/');
+  mvwaddch(bigdeer1,4,18,(chtype)'/');
+  mvwaddch(bigdeer1,4,19,(chtype)'\\');
+  mvwaddch(bigdeer1,4,22,(chtype)'\\');
+  mvwaddstr(bigdeer1,5,7,"^~~~~~~~~//  ~~U");
+  mvwaddstr(bigdeer1,6,7,"( \\_____( /");
+  mvwaddstr(bigdeer1,7,8,"( )    /");
+  mvwaddstr(bigdeer1,8,9,"\\\\   /");
+  mvwaddstr(bigdeer1,9,11,"\\>/>");
+
+  /* bigdeer2 */
+  mvwaddch(bigdeer2,0,17,(chtype)'\\');
+  mvwaddch(bigdeer2,0,18,(chtype)'/');
+  mvwaddch(bigdeer2,0,20,(chtype)'\\');
+  mvwaddch(bigdeer2,0,21,(chtype)'/');
+  mvwaddch(bigdeer2,1,18,(chtype)'\\');
+  mvwaddch(bigdeer2,1,20,(chtype)'/');
+  mvwaddch(bigdeer2,2,19,(chtype)'|');
+  mvwaddch(bigdeer2,2,20,(chtype)'_');
+  mvwaddch(bigdeer2,3,18,(chtype)'/');
+  mvwaddch(bigdeer2,3,19,(chtype)'^');
+  mvwaddch(bigdeer2,3,20,(chtype)'0');
+  mvwaddch(bigdeer2,3,21,(chtype)'\\');
+  mvwaddch(bigdeer2,4,17,(chtype)'/');
+  mvwaddch(bigdeer2,4,18,(chtype)'/');
+  mvwaddch(bigdeer2,4,19,(chtype)'\\');
+  mvwaddch(bigdeer2,4,22,(chtype)'\\');
+  mvwaddstr(bigdeer2,5,7,"^~~~~~~~~//  ~~U");
+  mvwaddstr(bigdeer2,6,7,"(( )____( /");
+  mvwaddstr(bigdeer2,7,7,"( /      |");
+  mvwaddstr(bigdeer2,8,8,"\\/      |");
+  mvwaddstr(bigdeer2,9,9,"|>     |>");
+
+  /* bigdeer3 */
+  mvwaddch(bigdeer3,0,17,(chtype)'\\');
+  mvwaddch(bigdeer3,0,18,(chtype)'/');
+  mvwaddch(bigdeer3,0,20,(chtype)'\\');
+  mvwaddch(bigdeer3,0,21,(chtype)'/');
+  mvwaddch(bigdeer3,1,18,(chtype)'\\');
+  mvwaddch(bigdeer3,1,20,(chtype)'/');
+  mvwaddch(bigdeer3,2,19,(chtype)'|');
+  mvwaddch(bigdeer3,2,20,(chtype)'_');
+  mvwaddch(bigdeer3,3,18,(chtype)'/');
+  mvwaddch(bigdeer3,3,19,(chtype)'^');
+  mvwaddch(bigdeer3,3,20,(chtype)'0');
+  mvwaddch(bigdeer3,3,21,(chtype)'\\');
+  mvwaddch(bigdeer3,4,17,(chtype)'/');
+  mvwaddch(bigdeer3,4,18,(chtype)'/');
+  mvwaddch(bigdeer3,4,19,(chtype)'\\');
+  mvwaddch(bigdeer3,4,22,(chtype)'\\');
+  mvwaddstr(bigdeer3,5,7,"^~~~~~~~~//  ~~U");
+  mvwaddstr(bigdeer3,6,6,"( ()_____( /");
+  mvwaddstr(bigdeer3,7,6,"/ /       /");
+  mvwaddstr(bigdeer3,8,5,"|/          \\");
+  mvwaddstr(bigdeer3,9,5,"/>           \\>");
+
+  /* bigdeer4 */
+  mvwaddch(bigdeer4,0,17,(chtype)'\\');
+  mvwaddch(bigdeer4,0,18,(chtype)'/');
+  mvwaddch(bigdeer4,0,20,(chtype)'\\');
+  mvwaddch(bigdeer4,0,21,(chtype)'/');
+  mvwaddch(bigdeer4,1,18,(chtype)'\\');
+  mvwaddch(bigdeer4,1,20,(chtype)'/');
+  mvwaddch(bigdeer4,2,19,(chtype)'|');
+  mvwaddch(bigdeer4,2,20,(chtype)'_');
+  mvwaddch(bigdeer4,3,18,(chtype)'/');
+  mvwaddch(bigdeer4,3,19,(chtype)'^');
+  mvwaddch(bigdeer4,3,20,(chtype)'0');
+  mvwaddch(bigdeer4,3,21,(chtype)'\\');
+  mvwaddch(bigdeer4,4,17,(chtype)'/');
+  mvwaddch(bigdeer4,4,18,(chtype)'/');
+  mvwaddch(bigdeer4,4,19,(chtype)'\\');
+  mvwaddch(bigdeer4,4,22,(chtype)'\\');
+  mvwaddstr(bigdeer4,5,7,"^~~~~~~~~//  ~~U");
+  mvwaddstr(bigdeer4,6,6,"( )______( /");
+  mvwaddstr(bigdeer4,7,5,"(/          \\");
+  mvwaddstr(bigdeer4,8,0,"v___=             ----^");
+
+  /* lookdeer1 */
+  mvwaddstr(lookdeer1,0,16,"\\/     \\/");
+  mvwaddstr(lookdeer1,1,17,"\\Y/ \\Y/");
+  mvwaddstr(lookdeer1,2,19,"\\=/");
+  mvwaddstr(lookdeer1,3,17,"^\\o o/^");
+  mvwaddstr(lookdeer1,4,17,"//( )");
+  mvwaddstr(lookdeer1,5,7,"^~~~~~~~~// \\");
+  waddch(lookdeer1,'O' | noseattr);
+  waddstr(lookdeer1,"/");
+  mvwaddstr(lookdeer1,6,7,"( \\_____( /");
+  mvwaddstr(lookdeer1,7,8,"( )    /");
+  mvwaddstr(lookdeer1,8,9,"\\\\   /");
+  mvwaddstr(lookdeer1,9,11,"\\>/>");
+
+  /* lookdeer2 */
+  mvwaddstr(lookdeer2,0,16,"\\/     \\/");
+  mvwaddstr(lookdeer2,1,17,"\\Y/ \\Y/");
+  mvwaddstr(lookdeer2,2,19,"\\=/");
+  mvwaddstr(lookdeer2,3,17,"^\\o o/^");
+  mvwaddstr(lookdeer2,4,17,"//( )");
+  mvwaddstr(lookdeer2,5,7,"^~~~~~~~~// \\");
+  waddch(lookdeer2,'O' | noseattr);
+  waddstr(lookdeer2,"/");
+  mvwaddstr(lookdeer2,6,7,"(( )____( /");
+  mvwaddstr(lookdeer2,7,7,"( /      |");
+  mvwaddstr(lookdeer2,8,8,"\\/      |");
+  mvwaddstr(lookdeer2,9,9,"|>     |>");
+
+  /* lookdeer3 */
+  mvwaddstr(lookdeer3,0,16,"\\/     \\/");
+  mvwaddstr(lookdeer3,1,17,"\\Y/ \\Y/");
+  mvwaddstr(lookdeer3,2,19,"\\=/");
+  mvwaddstr(lookdeer3,3,17,"^\\o o/^");
+  mvwaddstr(lookdeer3,4,17,"//( )");
+  mvwaddstr(lookdeer3,5,7,"^~~~~~~~~// \\");
+  waddch(lookdeer3,'O' | noseattr);
+  waddstr(lookdeer3,"/");
+  mvwaddstr(lookdeer3,6,6,"( ()_____( /");
+  mvwaddstr(lookdeer3,7,6,"/ /       /");
+  mvwaddstr(lookdeer3,8,5,"|/          \\");
+  mvwaddstr(lookdeer3,9,5,"/>           \\>");
+
+  /* lookdeer4 */
+  mvwaddstr(lookdeer4,0,16,"\\/     \\/");
+  mvwaddstr(lookdeer4,1,17,"\\Y/ \\Y/");
+  mvwaddstr(lookdeer4,2,19,"\\=/");
+  mvwaddstr(lookdeer4,3,17,"^\\o o/^");
+  mvwaddstr(lookdeer4,4,17,"//( )");
+  mvwaddstr(lookdeer4,5,7,"^~~~~~~~~// \\");
+  waddch(lookdeer4,'O' | noseattr);
+  waddstr(lookdeer4,"/");
+  mvwaddstr(lookdeer4,6,6,"( )______( /");
+  mvwaddstr(lookdeer4,7,5,"(/          \\");
+  mvwaddstr(lookdeer4,8,0,"v___=             ----^");
+
+
+
+  /***********************************************/
+#if 0
+  do
+  {
+#endif
+    clear();
+    werase(treescrn);
+    touchwin(treescrn);
+    werase(treescrn2);
+    touchwin(treescrn2);
+    werase(treescrn8);
+    touchwin(treescrn8);
+    refresh();
+    delay_output(1000);
+    boxit();
+    del_msg();
+    delay_output(1000);
+    seas();
+    del_msg();
+    delay_output(1000);
+    greet();
+    del_msg();
+    delay_output(1000);
+    fromwho();
+    del_msg();
+    delay_output(1000);
+    tree();
+    delay_output(1000);
+    balls();
+    delay_output(1000);
+    star();
+    delay_output(1000);
+    strng1();
+    strng2();
+    strng3();
+    strng4();
+    strng5();
+
+
+  /* set up the windows for our blinking trees */
+  /* **************************************** */
+  /* treescrn3 */
+
+               overlay(treescrn, treescrn3);
+
+             /*balls*/
+               mvwaddch(treescrn3, 4, 18, ' ');
+               mvwaddch(treescrn3, 7, 6, ' ');
+               mvwaddch(treescrn3, 8, 19, ' ');
+               mvwaddch(treescrn3, 11, 22, ' ');
+
+             /*star*/
+               mvwaddch(treescrn3, 0, 12, '*');
+
+             /*strng1*/
+               mvwaddch(treescrn3, 3, 11, ' ');
+
+             /*strng2*/
+               mvwaddch(treescrn3, 5, 13, ' ');
+               mvwaddch(treescrn3, 6, 10, ' ');
+
+             /*strng3*/
+               mvwaddch(treescrn3, 7, 16, ' ');
+               mvwaddch(treescrn3, 7, 14, ' ');
+
+             /*strng4*/
+               mvwaddch(treescrn3, 10, 13, ' ');
+               mvwaddch(treescrn3, 10, 10, ' ');
+               mvwaddch(treescrn3, 11, 8, ' ');
+
+             /*strng5*/
+               mvwaddch(treescrn3, 11, 18, ' ');
+               mvwaddch(treescrn3, 12, 13, ' ');
+
+
+  /* treescrn4 */
+
+               overlay(treescrn, treescrn4);
+
+             /*balls*/
+               mvwaddch(treescrn4, 3, 9, ' ');
+               mvwaddch(treescrn4, 4, 16, ' ');
+               mvwaddch(treescrn4, 7, 6, ' ');
+               mvwaddch(treescrn4, 8, 19, ' ');
+               mvwaddch(treescrn4, 11, 2, ' ');
+               mvwaddch(treescrn4, 12, 23, ' ');
+
+             /*star*/
+               mvwaddch(treescrn4, 0, 12, '*' | A_STANDOUT );
+
+             /*strng1*/
+               mvwaddch(treescrn4, 3, 13, ' ');
+
+             /*strng2*/
+
+	     /*strng3*/
+               mvwaddch(treescrn4, 7, 15, ' ');
+               mvwaddch(treescrn4, 8, 11, ' ');
+
+             /*strng4*/
+               mvwaddch(treescrn4, 9, 16, ' ');
+               mvwaddch(treescrn4, 10, 12, ' ');
+               mvwaddch(treescrn4, 11, 8, ' ');
+
+             /*strng5*/
+               mvwaddch(treescrn4, 11, 18, ' ');
+	       mvwaddch(treescrn4, 12, 14, ' ');
+
+
+  /* treescrn5 */
+
+               overlay(treescrn, treescrn5);
+
+             /*balls*/
+               mvwaddch(treescrn5, 3, 15, ' ');
+               mvwaddch(treescrn5, 10, 20, ' ');
+               mvwaddch(treescrn5, 12, 1, ' ');
+
+             /*star*/
+               mvwaddch(treescrn5, 0, 12, '*');
+
+             /*strng1*/
+               mvwaddch(treescrn5, 3, 11, ' ');
+
+             /*strng2*/
+               mvwaddch(treescrn5, 5, 12, ' ');
+
+             /*strng3*/
+	       mvwaddch(treescrn5, 7, 14, ' ');
+               mvwaddch(treescrn5, 8, 10, ' ');
+
+             /*strng4*/
+               mvwaddch(treescrn5, 9, 15, ' ');
+               mvwaddch(treescrn5, 10, 11, ' ');
+               mvwaddch(treescrn5, 11, 7, ' ');
+
+             /*strng5*/
+               mvwaddch(treescrn5, 11, 17, ' ');
+               mvwaddch(treescrn5, 12, 13, ' ');
+
+  /* treescrn6 */
+
+               overlay(treescrn, treescrn6);
+
+             /*balls*/
+               mvwaddch(treescrn6, 6, 7, ' ');
+               mvwaddch(treescrn6, 7, 18, ' ');
+               mvwaddch(treescrn6, 10, 4, ' ');
+               mvwaddch(treescrn6, 11, 23, ' ');
+
+	     /*star*/
+               mvwaddch(treescrn6, 0, 12, '*' | A_STANDOUT );
+
+             /*strng1*/
+
+             /*strng2*/
+               mvwaddch(treescrn6, 5, 11, ' ');
+
+             /*strng3*/
+	       mvwaddch(treescrn6, 7, 13, ' ');
+               mvwaddch(treescrn6, 8, 9, ' ');
+
+             /*strng4*/
+               mvwaddch(treescrn6, 9, 14, ' ');
+               mvwaddch(treescrn6, 10, 10, ' ');
+               mvwaddch(treescrn6, 11, 6, ' ');
+
+             /*strng5*/
+               mvwaddch(treescrn6, 11, 16, ' ');
+               mvwaddch(treescrn6, 12, 12, ' ');
+
+  /* treescrn7 */
+
+               overlay(treescrn, treescrn7);
+
+             /*balls*/
+               mvwaddch(treescrn7, 3, 15, ' ');
+               mvwaddch(treescrn7, 6, 7, ' ');
+               mvwaddch(treescrn7, 7, 18, ' ');
+               mvwaddch(treescrn7, 10, 4, ' ');
+               mvwaddch(treescrn7, 11, 22, ' ');
+
+             /*star*/
+               mvwaddch(treescrn7, 0, 12, '*');
+
+             /*strng1*/
+               mvwaddch(treescrn7, 3, 12, ' ');
+
+             /*strng2*/
+               mvwaddch(treescrn7, 5, 13, ' ');
+               mvwaddch(treescrn7, 6, 9, ' ');
+
+	     /*strng3*/
+               mvwaddch(treescrn7, 7, 15, ' ');
+               mvwaddch(treescrn7, 8, 11, ' ');
+
+             /*strng4*/
+               mvwaddch(treescrn7, 9, 16, ' ');
+               mvwaddch(treescrn7, 10, 12, ' ');
+               mvwaddch(treescrn7, 11, 8, ' ');
+
+             /*strng5*/
+               mvwaddch(treescrn7, 11, 18, ' ');
+	       mvwaddch(treescrn7, 12, 14, ' ');
+
+
+    delay_output(1000);
+    reindeer();
+
+    touchwin(w_holiday);
+    wrefresh(w_holiday);
+    wrefresh(w_del_msg);
+
+    delay_output(1000);
+    for(loopy = 0;loopy < 50;loopy++)
+    {
+      blinkit();
+    }
+
+    done();
+
+#if 0
+  }
+  while(getch() == (ERR));
+/*  while(!typeahead(stdin));*/
+#endif
+      return 0;
+}
+
+int boxit Args((void))
+{
+ int x = 0;
+
+  while(x < 20)
+  {
+    mvaddch(x, 7, '|');
+    ++x;
+  }
+
+  x = 8;
+
+  while(x < 80)
+  {
+    mvaddch(19, x, '_');
+    ++x;
+  }
+
+  x = 0;
+
+  while(x < 80)
+  {
+    mvaddch(22, x, '_');
+    ++x;
+  }
+
+  return( 0 );
+}
+
+int seas Args((void))
+{
+  mvaddch(4, 1, 'S');
+  mvaddch(6, 1, 'E');
+  mvaddch(8, 1, 'A');
+  mvaddch(10, 1, 'S');
+  mvaddch(12, 1, 'O');
+  mvaddch(14, 1, 'N');
+  mvaddch(16, 1, '`');
+  mvaddch(18, 1, 'S');
+
+  return( 0 );
+}
+
+int greet Args((void))
+{
+  mvaddch(3, 5, 'G');
+  mvaddch(5, 5, 'R');
+  mvaddch(7, 5, 'E');
+  mvaddch(9, 5, 'E');
+  mvaddch(11, 5, 'T');
+  mvaddch(13, 5, 'I');
+  mvaddch(15, 5, 'N');
+  mvaddch(17, 5, 'G');
+  mvaddch(19, 5, 'S');
+
+  return( 0 );
+}
+
+int fromwho Args((void))
+{
+  mvaddstr(21, 13, FROMWHO);
+  return( 0 );
+}
+
+int del_msg Args((void))
+{
+#if 0
+  mvaddstr(23, 60, "Hit any key to quit");
+#endif
+
+  refresh();
+
+  return( 0 );
+}
+
+int tree Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(30,COLOR_GREEN,COLOR_BLACK);
+     wattrset(treescrn,COLOR_PAIR(30));
+    }
+#endif
+  mvwaddch(treescrn, 1, 11, (chtype)'/');
+  mvwaddch(treescrn, 2, 11, (chtype)'/');
+  mvwaddch(treescrn, 3, 10, (chtype)'/');
+  mvwaddch(treescrn, 4, 9, (chtype)'/');
+  mvwaddch(treescrn, 5, 9, (chtype)'/');
+  mvwaddch(treescrn, 6, 8, (chtype)'/');
+  mvwaddch(treescrn, 7, 7, (chtype)'/');
+  mvwaddch(treescrn, 8, 6, (chtype)'/');
+  mvwaddch(treescrn, 9, 6, (chtype)'/');
+  mvwaddch(treescrn, 10, 5, (chtype)'/');
+  mvwaddch(treescrn, 11, 3, (chtype)'/');
+  mvwaddch(treescrn, 12, 2, (chtype)'/');
+
+  mvwaddch(treescrn, 1, 13, (chtype)'\\');
+  mvwaddch(treescrn, 2, 13, (chtype)'\\');
+  mvwaddch(treescrn, 3, 14, (chtype)'\\');
+  mvwaddch(treescrn, 4, 15, (chtype)'\\');
+  mvwaddch(treescrn, 5, 15, (chtype)'\\');
+  mvwaddch(treescrn, 6, 16, (chtype)'\\');
+  mvwaddch(treescrn, 7, 17, (chtype)'\\');
+  mvwaddch(treescrn, 8, 18, (chtype)'\\');
+  mvwaddch(treescrn, 9, 18, (chtype)'\\');
+  mvwaddch(treescrn, 10, 19, (chtype)'\\');
+  mvwaddch(treescrn, 11, 21, (chtype)'\\');
+  mvwaddch(treescrn, 12, 22, (chtype)'\\');
+
+  mvwaddch(treescrn, 4, 10, (chtype)'_');
+  mvwaddch(treescrn, 4, 14, (chtype)'_');
+  mvwaddch(treescrn, 8, 7, (chtype)'_');
+  mvwaddch(treescrn, 8, 17, (chtype)'_');
+
+  mvwaddstr(treescrn, 13, 0, "//////////// \\\\\\\\\\\\\\\\\\\\\\\\");
+
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(20,COLOR_YELLOW,COLOR_BLACK);
+     wattrset(treescrn,COLOR_PAIR(20));
+    }
+#endif
+  mvwaddstr(treescrn, 14, 11, "| |");
+  mvwaddstr(treescrn, 15, 11, "|_|");
+
+  wrefresh(treescrn);
+  wrefresh(w_del_msg);
+
+  return( 0 );
+}
+
+int balls Args((void))
+{
+  chtype ball1,ball2,ball3,ball4,ball5,ball6;
+  overlay(treescrn, treescrn2);
+
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(1, COLOR_BLUE,COLOR_BLACK);
+     init_pair(2, COLOR_RED,COLOR_BLACK);
+     init_pair(3, COLOR_MAGENTA,COLOR_BLACK);
+     init_pair(4, COLOR_CYAN,COLOR_BLACK);
+     init_pair(5, COLOR_YELLOW,COLOR_BLACK);
+     init_pair(6, COLOR_WHITE,COLOR_BLACK);
+     ball1 = COLOR_PAIR(1);
+     ball2 = COLOR_PAIR(2);
+     ball3 = COLOR_PAIR(3);
+     ball4 = COLOR_PAIR(4);
+     ball5 = COLOR_PAIR(5);
+     ball6 = COLOR_PAIR(6);
+    }
+  else
+     ball1 = ball2 = ball3 = ball4 = ball5 = ball6 = 0;
+#else
+  ball1 = ball2 = ball3 = ball4 = ball5 = ball6 = 0;
+#endif
+
+  mvwaddch(treescrn2, 3, 9, (chtype)'@'|ball1);
+  mvwaddch(treescrn2, 3, 15, (chtype)'@'|ball2);
+  mvwaddch(treescrn2, 4, 8, (chtype)'@'|ball3);
+  mvwaddch(treescrn2, 4, 16, (chtype)'@'|ball4);
+  mvwaddch(treescrn2, 5, 7, (chtype)'@'|ball5);
+  mvwaddch(treescrn2, 5, 17, (chtype)'@'|ball6);
+  mvwaddch(treescrn2, 7, 6, (chtype)'@'|ball1|A_BOLD);
+  mvwaddch(treescrn2, 7, 18, (chtype)'@'|ball2|A_BOLD);
+  mvwaddch(treescrn2, 8, 5, (chtype)'@'|ball3|A_BOLD);
+  mvwaddch(treescrn2, 8, 19, (chtype)'@'|ball4|A_BOLD);
+  mvwaddch(treescrn2, 10, 4, (chtype)'@'|ball5|A_BOLD);
+  mvwaddch(treescrn2, 10, 20, (chtype)'@'|ball6|A_BOLD);
+  mvwaddch(treescrn2, 11, 2, (chtype)'@'|ball1);
+  mvwaddch(treescrn2, 11, 22, (chtype)'@'|ball2);
+  mvwaddch(treescrn2, 12, 1, (chtype)'@'|ball3);
+  mvwaddch(treescrn2, 12, 23, (chtype)'@'|ball4);
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int star Args((void))
+{
+  mvwaddch(treescrn2, 0, 12, (chtype)'*' | A_STANDOUT );
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int strng1 Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(10, COLOR_YELLOW,COLOR_BLACK);
+     wattrset(treescrn2,COLOR_PAIR(10)|A_BOLD);
+    }
+#endif
+  mvwaddch(treescrn2, 3, 13, (chtype)'\'');
+  mvwaddch(treescrn2, 3, 12, (chtype)':');
+  mvwaddch(treescrn2, 3, 11, (chtype)'.');
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int strng2 Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(11, COLOR_RED,COLOR_BLACK);
+     wattrset(treescrn2,COLOR_PAIR(11)|A_BOLD);
+    }
+#endif
+  mvwaddch(treescrn2, 5, 14, (chtype)'\'');
+  mvwaddch(treescrn2, 5, 13, (chtype)':');
+  mvwaddch(treescrn2, 5, 12, (chtype)'.');
+  mvwaddch(treescrn2, 5, 11, (chtype)',');
+  mvwaddch(treescrn2, 6, 10, (chtype)'\'');
+  mvwaddch(treescrn2, 6, 9, (chtype)':');
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int strng3 Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(12, COLOR_GREEN,COLOR_BLACK);
+     wattrset(treescrn2,COLOR_PAIR(12)|A_BOLD);
+    }
+#endif
+  mvwaddch(treescrn2, 7, 16, (chtype)'\'');
+  mvwaddch(treescrn2, 7, 15, (chtype)':');
+  mvwaddch(treescrn2, 7, 14, (chtype)'.');
+  mvwaddch(treescrn2, 7, 13, (chtype)',');
+  mvwaddch(treescrn2, 8, 12, (chtype)'\'');
+  mvwaddch(treescrn2, 8, 11, (chtype)':');
+  mvwaddch(treescrn2, 8, 10, (chtype)'.');
+  mvwaddch(treescrn2, 8, 9, (chtype)',');
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int strng4 Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(13, COLOR_WHITE,COLOR_BLACK);
+     wattrset(treescrn2,COLOR_PAIR(13)|A_BOLD);
+    }
+#endif
+  mvwaddch(treescrn2, 9, 17, (chtype)'\'');
+  mvwaddch(treescrn2, 9, 16, (chtype)':');
+  mvwaddch(treescrn2, 9, 15, (chtype)'.');
+  mvwaddch(treescrn2, 9, 14, (chtype)',');
+  mvwaddch(treescrn2, 10, 13, (chtype)'\'');
+  mvwaddch(treescrn2, 10, 12, (chtype)':');
+  mvwaddch(treescrn2, 10, 11, (chtype)'.');
+  mvwaddch(treescrn2, 10, 10, (chtype)',');
+  mvwaddch(treescrn2, 11, 9, (chtype)'\'');
+  mvwaddch(treescrn2, 11, 8, (chtype)':');
+  mvwaddch(treescrn2, 11, 7, (chtype)'.');
+  mvwaddch(treescrn2, 11, 6, (chtype)',');
+  mvwaddch(treescrn2, 12, 5, (chtype)'\'');
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int strng5 Args((void))
+{
+#ifdef A_COLOR
+  if (has_colors() )
+    {
+     init_pair(14, COLOR_CYAN,COLOR_BLACK);
+     wattrset(treescrn2,COLOR_PAIR(14)|A_BOLD);
+    }
+#endif
+  mvwaddch(treescrn2, 11, 19, (chtype)'\'');
+  mvwaddch(treescrn2, 11, 18, (chtype)':');
+  mvwaddch(treescrn2, 11, 17, (chtype)'.');
+  mvwaddch(treescrn2, 11, 16, (chtype)',');
+  mvwaddch(treescrn2, 12, 15, (chtype)'\'');
+  mvwaddch(treescrn2, 12, 14, (chtype)':');
+  mvwaddch(treescrn2, 12, 13, (chtype)'.');
+  mvwaddch(treescrn2, 12, 12, (chtype)',');
+
+  /* save a fully lit tree */
+  overlay(treescrn2, treescrn);
+
+  wrefresh(treescrn2);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+int blinkit Args((void))
+{
+ static int cycle;
+
+  if(cycle > 4)
+  {
+    cycle = 0;
+  }
+
+
+  touchwin(treescrn8);
+
+  switch(cycle)
+  {
+
+    case 0:
+               overlay(treescrn3, treescrn8);
+               wrefresh(treescrn8);
+               wrefresh(w_del_msg);
+
+               break;
+    case 1:
+               overlay(treescrn4, treescrn8);
+               wrefresh(treescrn8);
+               wrefresh(w_del_msg);
+
+               break;
+    case 2:
+               overlay(treescrn5, treescrn8);
+               wrefresh(treescrn8);
+               wrefresh(w_del_msg);
+
+               break;
+    case 3:
+               overlay(treescrn6, treescrn8);
+               wrefresh(treescrn8);
+               wrefresh(w_del_msg);
+
+               break;
+    case 4:
+               overlay(treescrn7, treescrn8);
+               wrefresh(treescrn8);
+               wrefresh(w_del_msg);
+
+               break;
+  }
+
+   napms(50);
+   touchwin(treescrn8);
+
+
+
+   /*ALL ON***************************************************/
+
+
+   overlay(treescrn, treescrn8);
+   wrefresh(treescrn8);
+   wrefresh(w_del_msg);
+
+
+  ++cycle;
+  return( 0 );
+}
+
+int reindeer Args((void))
+{
+ int looper;
+
+  y_pos = 0;
+
+
+  for(x_pos = 70; x_pos > 62; x_pos--)
+  {
+    if(x_pos < 62)
+    {
+      y_pos = 1;
+    }
+    for(looper = 0; looper < 4; looper++)
+    {
+      mvwaddch(dotdeer0, y_pos, x_pos, (chtype)'.');
+      wrefresh(dotdeer0);
+      wrefresh(w_del_msg);
+      werase(dotdeer0);
+      wrefresh(dotdeer0);
+      wrefresh(w_del_msg);
+    }
+  }
+
+  y_pos = 2;
+
+  for(; x_pos > 50; x_pos--)
+  {
+
+    for(looper = 0; looper < 4; looper++)
+    {
+
+      if(x_pos < 56)
+      {
+        y_pos = 3;
+
+        mvwaddch(stardeer0, y_pos, x_pos, (chtype)'*');
+        wrefresh(stardeer0);
+        wrefresh(w_del_msg);
+        werase(stardeer0);
+        wrefresh(stardeer0);
+        wrefresh(w_del_msg);
+      }
+      else
+      {
+        mvwaddch(dotdeer0, y_pos, x_pos, (chtype)'*');
+        wrefresh(dotdeer0);
+        wrefresh(w_del_msg);
+        werase(dotdeer0);
+        wrefresh(dotdeer0);
+        wrefresh(w_del_msg);
+      }
+    }
+  }
+
+  x_pos = 58;
+
+  for(y_pos = 2; y_pos < 5; y_pos++)
+  {
+
+    touchwin(lildeer0);
+    wrefresh(lildeer0);
+    wrefresh(w_del_msg);
+   napms(50);
+
+    for(looper = 0; looper < 4; looper++)
+    {
+      mvwin(lildeer3, y_pos, x_pos);
+      wrefresh(lildeer3);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(lildeer2, y_pos, x_pos);
+      wrefresh(lildeer2);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(lildeer1, y_pos, x_pos);
+      wrefresh(lildeer1);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(lildeer2, y_pos, x_pos);
+      wrefresh(lildeer2);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(lildeer3, y_pos, x_pos);
+      wrefresh(lildeer3);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      touchwin(lildeer0);
+      wrefresh(lildeer0);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      x_pos -= 2;
+    }
+  }
+
+
+  x_pos = 35;
+
+  for(y_pos = 5; y_pos < 10; y_pos++)
+  {
+
+    touchwin(middeer0);
+    wrefresh(middeer0);
+    wrefresh(w_del_msg);
+
+    for(looper = 0; looper < 2; looper++)
+    {
+      mvwin(middeer3, y_pos, x_pos);
+      wrefresh(middeer3);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(middeer2, y_pos, x_pos);
+      wrefresh(middeer2);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(middeer1, y_pos, x_pos);
+      wrefresh(middeer1);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(middeer2, y_pos, x_pos);
+      wrefresh(middeer2);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      mvwin(middeer3, y_pos, x_pos);
+      wrefresh(middeer3);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      touchwin(middeer0);
+      wrefresh(middeer0);
+      wrefresh(w_del_msg);
+   napms(50);
+
+      x_pos -= 3;
+    }
+  }
+
+  delay_output(2000);
+
+  y_pos = 1;
+
+  for(x_pos = 8; x_pos < 16; x_pos++)
+  {
+
+      mvwin(bigdeer4, y_pos, x_pos);
+      wrefresh(bigdeer4);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer3, y_pos, x_pos);
+      wrefresh(bigdeer3);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer2, y_pos, x_pos);
+      wrefresh(bigdeer2);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer1, y_pos, x_pos);
+      wrefresh(bigdeer1);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer2, y_pos, x_pos);
+      wrefresh(bigdeer2);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer3, y_pos, x_pos);
+      wrefresh(bigdeer3);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer4, y_pos, x_pos);
+      wrefresh(bigdeer4);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer0, y_pos, x_pos);
+      wrefresh(bigdeer0);
+      wrefresh(w_del_msg);
+   napms(30);
+  }
+
+    --x_pos;
+
+    for(looper = 0; looper < 6; looper++)
+    {
+      mvwin(lookdeer4, y_pos, x_pos);
+      wrefresh(lookdeer4);
+      wrefresh(w_del_msg);
+   napms(40);
+
+      mvwin(lookdeer3, y_pos, x_pos);
+      wrefresh(lookdeer3);
+      wrefresh(w_del_msg);
+   napms(40);
+
+      mvwin(lookdeer2, y_pos, x_pos);
+      wrefresh(lookdeer2);
+      wrefresh(w_del_msg);
+   napms(40);
+
+      mvwin(lookdeer1, y_pos, x_pos);
+      wrefresh(lookdeer1);
+      wrefresh(w_del_msg);
+   napms(40);
+
+      mvwin(lookdeer2, y_pos, x_pos);
+      wrefresh(lookdeer2);
+      wrefresh(w_del_msg);
+   napms(40);
+
+      mvwin(lookdeer3, y_pos, x_pos);
+      wrefresh(lookdeer3);
+      wrefresh(w_del_msg);
+   napms(40);
+
+      mvwin(lookdeer4, y_pos, x_pos);
+      wrefresh(lookdeer4);
+      wrefresh(w_del_msg);
+   napms(40);
+
+    }
+
+    mvwin(lookdeer0, y_pos, x_pos);
+    wrefresh(lookdeer0);
+    wrefresh(w_del_msg);
+   napms(40);
+
+  for(; y_pos < 10; y_pos++)
+  {
+
+    for(looper = 0; looper < 2; looper++)
+    {
+      mvwin(bigdeer4, y_pos, x_pos);
+      wrefresh(bigdeer4);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer3, y_pos, x_pos);
+      wrefresh(bigdeer3);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer2, y_pos, x_pos);
+      wrefresh(bigdeer2);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer1, y_pos, x_pos);
+      wrefresh(bigdeer1);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer2, y_pos, x_pos);
+      wrefresh(bigdeer2);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer3, y_pos, x_pos);
+      wrefresh(bigdeer3);
+      wrefresh(w_del_msg);
+   napms(30);
+
+      mvwin(bigdeer4, y_pos, x_pos);
+      wrefresh(bigdeer4);
+      wrefresh(w_del_msg);
+   napms(30);
+    }
+      mvwin(bigdeer0, y_pos, x_pos);
+      wrefresh(bigdeer0);
+      wrefresh(w_del_msg);
+   napms(30);
+  }
+
+  --y_pos;
+
+  mvwin(lookdeer3, y_pos, x_pos);
+  wrefresh(lookdeer3);
+  wrefresh(w_del_msg);
+  return( 0 );
+}
+
+void done Args((void))
+{
+/*  signal(SIGINT,done);
+  signal(SIGTERM,done);
+#if !defined	DOS && !defined OS2
+  signal(SIGHUP,done);
+  signal(SIGQUIT,done);
+#endif*/
+  clear();
+  refresh();
+  endwin();
+#ifdef XCURSES
+  XCursesExit();
+#endif
+  exit(0);
+}
diff -Naur gdb-6.8/pdcurses/doc/intro.man stsgdb-6.8/pdcurses/doc/intro.man
--- gdb-6.8/pdcurses/doc/intro.man	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/doc/intro.man	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,541 @@
+/*man-start*********************************************************************
+
+		Introduction to XSI Curses Interface
+
+The X/Open Group has identified a strong need for a generic terminal
+interface for applications that wish to be independent of terminal
+hardware and connection method.
+
+This interface should allow the attachment of character and
+block-oriented terminals.  Furthermore, it should not put any
+constraints on how the terminals are attached (e.g., Local Area
+Networks, PADs on X.25, etc.). 
+
+The curses library interfaces provides the user with a method of
+updating screens with reasonable optimisation. 
+
+The X/Open group has found it impossible to define a totally portable
+set of curses interface routines that cover asynchronous, networked,
+and synchronous terminals.  The functions are oriented towards locally
+connected asynchronous terminals.  For such terminals, applications
+conforming to this interface are portable.  The interface routines
+curses may, however, also be used with synchronous and networked
+terminals, provided the restrictions below are considered. 
+
+These functions have been included been included in the X/Open
+definition in the "optional" category.  This means that although they
+are likely to appear on many X/Open compliant systems, they are not
+guaranteed to be on all systems.  Where they are supported, they will
+conform to the given definition. 
+
+
+----------------------------------------------------------------------
+
+	    Synchronous and Networked Asynchronous Terminals
+
+These notes indicate to the application writer some considerations to
+be borne in mind when driving synchronous, networked asynchronous
+(NWA) or non-standard directly connected asynchronous terminals.
+
+Such terminals are often used in a mainframe environment and
+communicatie to the host in block mode.  That is, the user types
+characters at the terminal then presses a special key to initiate
+transmission of the characters to the host. 
+
+Frequently, although it may be possible to send arbitrary sized blocks
+to the host, it may not be possible or desireable to cause a character
+to be transmitted with only a single keystroke. 
+
+This can cause severe problems to an application wishing to make use
+of single character input. 
+
+
+
+OUTPUT
+
+The curses package can be used in the normal way for all operations
+pertaining to output to the terminal, with the possible exception that
+on some terminals the refresh() routine may have to redraw the entire
+screen contents in order to perform any update.
+
+If it is additionally necessary to clear the screen before each such
+operation, the result could be unacceptable. 
+
+
+INPUT
+
+Because of the nature of operation of synchronous (block-mode) and NWA
+terminals, it may not be possible to support all or any of the curses
+input functions.  In particular, the following points should be noted:
+
+* Single-character input may not be possible.  It may be necessary to
+  press a special key to cause all characters typed at the terminal to
+  be transmitted to the host. 
+
+* It may not be possibel to disable echo.  Character echo may be performed
+  directly by the terminal.  On terminals that behave this way, any curses
+  application that performs input should be aware that any characters
+  type will appear on the screen wherever the cursor is positioned.
+  This may not necessarily correspond to the position of the cursor in
+  the window.
+
+
+----------------------------------------------------------------------
+
+		Data Types and the <curses.h> Header
+
+The data types supported by curses are described in this section.
+
+As the library supports a procedural interface to the data types,
+actual structure contents are not described.  All curses data are
+manipulated using the routines provided. 
+
+
+THE <curses.h> HEADER
+
+The <curses.h> header defines various constants and declares the data types
+that are available to the application.
+
+
+DATA TYPES
+
+The following data types are declared:
+
+	WINDOW*		pointer to screen representation
+	SCREEN*		pointer to terminal descriptor
+	bool		boolean data type
+	chtype		representation of a character in a window
+
+The actual WINDOW and SCREEN objects used to store information are
+created by the corresponding routines and a pointer to them is
+provided.  All manipulation is through that pointer. 
+
+
+CONSTANTS
+
+The following constants are defined. 
+
+
+GENERAL
+
+	COLS		number of columns on terminal screen
+	ERR		value returned on error condition
+	FALSE		boolean false value
+	LINES		number of lines on terminal screen
+	OK		value returned on successful completion
+	NULL		zero pointer value
+	TRUE		boolean true value
+
+VIDEO ATTRIBUTES
+
+	A_BLINK		blinking
+	A_BOLD		extra bright or bold
+	A_DIM		half bright
+	A_REVERSE	reverse video
+	A_STANDOUT	terminal's best highlighting mode
+	A_UNDERLINE	underlining
+	A_ATTRIBUTES	bit-mask to extract attributes
+	A_CHARTEXT	bit-mask to extract a character
+
+Normally, attributres are a property of the character. 
+
+
+INPUT VALUES
+
+The following constants might be returned by getch() if keypad() has
+been enabled.  Note that not all of these may be supported on a
+particular terminal if the terminal does not transmit a unique code
+when the key is pressed or the definition for the key is not present
+in the underlying table of terminal capabilities. 
+
+	KEY_BREAK	break key
+	KEY_DOWN	the four arrow keys
+	KEY_UP
+	KEY_LEFT
+	KEY_RIGHT
+	KEY_HOME	home key (upward+left arrow)
+	KEY_BACKSPACE	backspace
+	KEY_F0		function keys; space for 64 keys is reserved
+	KEY_F(n)	(KEY_F0+(n))
+	KEY_DL		delete line
+	KEY_IL		insert line
+	KEY_DC		delete character
+	KEY_IC		insert character
+	KEY_EIC		exit insert character mode
+	KEY_CLEAR	clear screen
+	KEY_EOS		clear to end of screen
+	KEY_EOL		clear to end of line
+	KEY_SF		scroll 1 line forwards
+	KEY_SR		scroll 1 line backwards (reverse)
+	KEY_NPAGE	next page
+	KEY_PPAGE	previous page
+	KEY_STAB	set tab
+	KEY_CTAB	clear tab
+	KEY_CATAB	clear all tabs
+	KEY_ENTER	enter or send
+	KEY_SRESET	soft (partial) reset
+	KEY_RESET	reset or hard reset
+	KEY_PRINT	print or copy
+	KEY_LL		home down or bottom (lower left)
+	KEY_A1		upper left of virtual keypad
+	KEY_A3		upper right of virtual keypad
+	KEY_B2		centre of virtual keypad
+	KEY_C1		lower left of virtual keypad
+	KEY_C3		lower right of virtual keypad
+
+The virtual keypad is arranged like this:
+
+	A1	up	A3
+	left	B2	right
+	C1	down	C3
+
+FUNCTIONS
+
+	The following table lists each curses routine and the name of the 
+	manual page on which it is described. This list is based on
+	System V R4 curses:
+
+	   Curses Function        Manual Page Name
+
+		addch                    addch
+		addchnstr                addchstr
+		addchstr                 addchstr
+		addnstr                  addstr
+		addstr                   addstr
+		attroff                  attr
+		attron                   attr
+		baudrate                 termattr
+		beep                     beep
+		bkgd                     bkgd
+		bkgdset                  bkgd
+		border                   border
+		box                      border
+		can_change_color         color
+		cbreak                   inopts
+		clear                    clear
+		clearok                  outopts
+		clrtobot                 clear
+		clrtoeol                 clear
+		color_content            color
+		color_set                attr
+		copywin                  overlay
+		curs_set                 kernel
+		def_prog_mode            kernel
+		def_shell_mode           kernel
+		del_curterm              terminfo
+		delay_output             util
+		delch                    delch
+		deleteln                 deleteln
+		delscreen                initscr
+		delwin                   window
+		derwin                   window
+		doupdate                 refresh
+		draino                   kernel
+		dupwin                   window
+		echo                     inopts
+		echochar                 addch
+		endwin                   initscr
+		erase                    clear
+		erasechar                termattr
+		filter                   util
+		flash                    beep
+		flushinp                 util
+		getbegyx                 getyx
+		getattrs                 attr
+		getch                    getch
+		getmaxyx                 getyx
+		getparyx                 getyx
+		getstr                   getstr
+		getsyx                   kernel
+		getwin                   util
+		getyx                    getyx
+		halfdelay                inopts
+		has_colors               color
+		has_ic                   termattr
+		has_il                   termattr
+		has_key                  util
+		hline                    border
+		idcok                    outopts
+		idlok                    outopts
+		immedok                  outopts
+		inch                     inch
+		inchnstr                 inchstr
+		inchstr                  inchstr
+		init_color               color
+		init_pair                color
+		initscr                  initscr
+		innstr                   instr
+		insch                    insch
+		insdelln                 deleteln
+		insertln                 deleteln
+		insnstr                  innstr
+		insstr                   innstr
+		instr                    instr
+		intrflush                inopts
+		is_linetouched           touch
+		is_wintouched            touch
+		isendwin                 initscr
+		keyname                  util
+		keypad                   inopts
+		killchar                 termattr
+		leaveok                  outopts
+		longname                 termattr
+		meta                     inopts
+		move                     move
+		mvaddch                  addch
+		mvaddchnstr              addchstr
+		mvaddchstr               addchstr
+		mvaddnstr                addstr
+		mvaddstr                 addstr
+		mvcur                    terminfo
+		mvdelch                  delch
+		mvderwin                 window
+		mvgetch                  getch
+		mvgetstr                 getstr
+		mvinch                   inch
+		mvinchnstr               inchstr
+		mvinchstr                inchstr
+		mvinnstr                 instr
+		mvinsch                  insch
+		mvinsnstr                insstr
+		mvinsstr                 insstr
+		mvinstr                  instr
+		mvprintw                 printw
+		mvscanw                  scanw
+		mvwaddch                 addch
+		mvwaddchnstr             addchstr
+		mvwaddchstr              addchstr
+		mvwaddnstr               addstr
+		mvwaddstr                addstr
+		mvwdelch                 delch
+		mvwgetch                 getch
+		mvwgetnstr               getstr
+		wgetnstr                 getstr
+		mvwin                    window
+		mvwinch                  inch
+		mvwinchnstr              inchstr
+		mvwinchstr               inchstr
+		mvwinnstr                instr
+		mvwinsch                 insch
+		mvwinsnstr               insstr
+		mvwinsstr                insstr
+		mvwinstr                 instr
+		mvwprintw                printw
+		mvwscanw                 scanw
+		napms                    kernel
+		newpad                   pad
+		newterm                  initscr
+		newwin                   window
+		nl                       outopts
+		nocbreak                 inopts
+		nodelay                  inopts
+		noecho                   inopts
+		nonl                     outopts
+		noqiflush                inopts
+		noraw                    inopts
+		notimeout                inopts
+		overlay                  overlay
+		overwrite                overlay
+		pair_content             color
+		pechochar                pad
+		pnoutrefresh             pad
+		prefresh                 pad
+		printw                   printw
+		putp                     terminfo
+		putwin                   util
+		qiflush                  inopts
+		raw                      inopts
+		raw_output               outopts
+		redrawwin                refresh
+		refresh                  refresh
+		reset_prog_mode          kernel
+		reset_shell_mode         kernel
+		resetty                  kernel
+		restartterm              terminfo
+		ripoffline               kernel
+		savetty                  kernel
+		scanw                    scanw
+		scr_dump                 scr_dump
+		scr_init                 scr_dump
+		scr_restore              scr_dump
+		scr_set                  scr_dump
+		scrl                     scroll
+		scroll                   scroll
+		scrollok                 outopts
+		set_term                 initscr
+		setscrreg                outopts
+		setsyx                   kernel
+		setterm                  terminfo
+		setupterm                terminfo
+		slk_attroff              slk
+		slk_attron               slk
+		slk_attrset              slk
+		slk_clear                slk
+		slk_color                slk
+		slk_init                 slk
+		slk_label                slk
+		slk_noutrefresh          slk
+		slk_refresh              slk
+		slk_restore              slk
+		slk_set                  slk
+		slk_touch                slk
+		standend                 attr
+		standout                 attr
+		start_color              color
+		subpad                   pad
+		subwin                   window
+		syncok                   window
+		termattrs                termattrs
+		termname                 termattrs
+		tgetent                  termcap
+		tgetflag                 termcap
+		tgetnum                  termcap
+		tgetstr                  termcap
+		tgoto                    termcap
+		tigetflag                terminfo
+		tigetnum                 terminfo
+		tigetstr                 terminfo
+		timeout                  inopts
+		touchline                touch
+		touchwin                 touch
+		tparm                    terminfo
+		tputs                    terminfo
+		trace_on                 pdcdebug
+		typeahead                inopts
+		unctrl                   util
+		ungetch                  getch
+		untouchwin               touch
+		use_env                  util
+		vidattr                  terminfo
+		vidputs                  terminfo
+		vline                    border
+	***	vwprintw                  printw
+	***	vwscanw                   scanw
+		waddch                   addch
+		waddchnstr               addchstr
+		waddchstr                addchstr
+		waddnstr                 addstr
+		waddstr                  addstr
+		wattroff                 attr
+		wattron                  attr
+		wattrset                 attr
+		wbkgd                    bkgd
+		wbkgdset                 bkgd
+		wborder                  border
+		wclear                   clear
+		wclrtobot                clear
+		wclrtoeol                clear
+		wcolor_set               attr
+		wcursyncup               window
+		wdelch                   delch
+		wdeleteln                deleteln
+		wechochar                addch
+		werase                   clear
+		wgetch                   getch
+		wgetnstr                 getstr
+		wgetstr                  getstr
+		whline                   border
+		winch                    inch
+		winchnstr                inchstr
+		winchstr                 inchstr
+		winnstr                  instr
+		winsch                   insch
+		winsdelln                deleteln
+		winsertln                deleteln
+		winsnstr                 insstr
+		winsstr                  insstr
+		winstr                   instr
+		wmove                    move
+		wnoutrefresh             refresh
+		wordchar                 termattr
+		wprintw                  printw
+		wredrawln                refresh
+		wrefresh                 refresh
+		wresize                  window
+		wscanw                   scanw
+		wscrl                    scroll
+		wsetscrreg               outopts
+		wstandend                attr
+		wstandout                attr
+		wsyncdown                window
+		wsyncup                  window
+		wtimeout                 inopts
+		wtouchln                 touch
+		wvline                   border
+
+		mouse_set                mouse
+		mouse_on                 mouse
+		mouse_off                mouse
+		request_mouse_pos        mouse
+		map_button               mouse
+		wmouse_position          mouse
+		getmouse                 mouse
+		getbmap                  mouse
+                           
+		resize_term              initscr
+
+	The following table lists each private curses routine and the name 
+	of the manual page on which it is described. These routines should
+	not be used directly if portability is to be considered.
+
+	   Curses Function        Manual Page Name
+
+		PDC_chadd                pdcdisp
+		PDC_check_bios_key       pdckbd
+		PDC_chg_attrs            pdcdisp
+		PDC_chins                pdcdisp
+		PDC_clr_scrn             pdcdisp
+		PDC_clr_update           pdcdisp
+		PDC_copy_win             pdcwin
+		PDC_cursor_off           pdcdisp
+		PDC_cursor_on            pdcdisp
+		PDC_debug                pdcdebug
+		PDC_fix_cursor           pdcdisp
+		PDC_getch                getch
+		PDC_get_attribute        pdcgetsc
+		PDC_get_bios_key         pdckbd
+		PDC_get_columns          pdcgetsc
+		PDC_get_ctrl_break       pdckbd
+		PDC_get_cursor_mode      pdcgetsc
+		PDC_get_cursor_pos       pdcgetsc
+		PDC_get_cur_col          pdcgetsc
+		PDC_get_cur_row          pdcgetsc
+		PDC_get_font             pdcgetsc
+		PDC_get_input_fd         pdckbd
+		PDC_get_key_modifiers    pdckbd
+		PDC_get_rows             pdcgetsc
+		PDC_get_scrn_mode        pdcgetsc
+		PDC_getclipboard         pdcclip
+		PDC_gotoxy               pdcdisp
+		PDC_makenew              pdcwin
+		PDC_memmove              pdcutil
+		PDC_newline              pdcdisp
+		PDC_print                pdcprint
+		PDC_putc                 pdcdisp
+		PDC_putctty              pdcdisp
+		PDC_query_adapter_type   pdcgetsc
+		PDC_rawgetch             pdckbd
+		PDC_sanity_check         pdcgetsc
+		PDC_scrn_modes_equal     pdcscrn
+		PDC_scroll               pdcdisp
+		PDC_scr_close            pdcscrn
+		PDC_scr_open             pdcscrn
+		PDC_set_80x25            pdcsetsc
+		PDC_set_ctrl_break       pdckbd
+		PDC_set_cursor_mode      pdcsetsc
+		PDC_set_font             pdcsetsc
+		PDC_set_rows             pdcsetsc
+		PDC_set_scrn_mode        pdcsetsc
+		PDC_set_title            pdcsetsc
+		PDC_setclipboard         pdcclip
+		PDC_sysgetch             pdckbd
+		PDC_transform_line       pdcdisp
+		PDC_ungetch              getch
+		PDC_usleep               pdcutil
+		PDC_validchar            pdckbd
+		PDC_vsscanf              pdcutil
+
+	NOTE: Functions prefixed with '***' above and on each manual page are 
+		functions that have not been implemented.
+
+**man-end**********************************************************************/
diff -Naur gdb-6.8/pdcurses/doc/latin-1.man stsgdb-6.8/pdcurses/doc/latin-1.man
--- gdb-6.8/pdcurses/doc/latin-1.man	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/doc/latin-1.man	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,117 @@
+
+                Entering High-Order Characters of the Latin-1 Character Set
+                -----------------------------------------------------------
+
+The following table shows the high-order characters of the Latin-1 character set and how
+to generate these characters using any keyboard and the user-specified "compose" key.
+
+The last column shows all possible key combinations to generate the equivalent Latin-1
+character.  There are up to 7 pairs of keys used per character, and these are listed in
+columns under the "Compose Key Combinations" heading.  To generate a character, press
+the "compose" key followed by one of the pairs of keystrokes.
+
+Where no key is evident, the spacebar is used.  Thus, to generate the NO-BREAK SPACE,
+press the "compose" key followed by the spacebar, followed by the spacebar.
+
+NOTE:  Viewing this file with a character set other than Latin-1, will not show the
+       Chr value correctly.
++----+-----+---+----------------------------------------------+---------------------------+
+|Hex | Dec |Chr| Description ISO/IEC 10646-1:1993(E)          | Compose key combinations  |
++----+-----+---+----------------------------------------------+---------------------------+
+| A0 | 160 |   | NO-BREAK SPACE                               |                           |
+| A1 | 161 |  | INVERTED EXCLAMATION MARK                    | !   !!                    |
+| A2 | 162 |  | CENT SIGN                                    | c|  |c  c/  c$  C$  C|    |
+| A3 | 163 |  | POUND SIGN                                   | L-  L$  L=  l- l$  l=     |
+| A4 | 164 |  | CURRENCY SIGN                                | xo  ox  XO  g$            |
+| A5 | 165 |  | YEN SIGN                                     | =y  y=  =Y  Y=  Y-  y$  y-|
+| A6 | 166 |  | BROKEN BAR                                   | |   ||  vb  VB  |^        |
+| A7 | 167 |  | SECTION SIGN                                 | SO  SS  s!  S!  so        |
+| A8 | 168 |  | DIAERESIS                                    | "   ""                    |
+| A9 | 169 |  | COPYRIGHT SIGN                               | CO  co  OC                |
+| AA | 170 |  | FEMININE ORDINAL INDICATOR                   | sa  SA  a_  A_            |
+| AB | 171 |  | LEFT-POINTING DOUBLE ANGLE QUOTATION MARK    | <<                        |
+| AC | 172 |  | NOT SIGN                                     | -,  no  NO                |
+| AD | 173 |  | SOFT HYPHEN                                  | -   --                    |
+| AE | 174 |  | REGISTERED SIGN                              | RO  ro  OR                |
+| AF | 175 |  | MACRON                                       | -^  _^  __                |
+| B0 | 176 |  | DEGREE SIGN                                  | o   0^  0*  de  DE        |
+| B1 | 177 |  | PLUS-MINUS SIGN                              | -+  +-                    |
+| B2 | 178 |  | SUPERSCRIPT TWO                              | 2   2^  s2                |
+| B3 | 179 |  | SUPERSCRIPT THREE                            | 3   3^  s3                |
+| B4 | 180 |  | ACUTE ACCENT                                 | '   ''                    |
+| B5 | 181 |  | MICRO SIGN                                   | u   /u  /U  *m  *M        |
+| B6 | 182 |  | PILCROW SIGN                                 | p!  P!  pg  PG            |
+| B7 | 183 |  | MIDDLE DOT                                   | .   .^  ..                |
+| B8 | 184 |  | CEDILLA                                      | ,   ,,                    |
+| B9 | 185 |  | SUPERSCRIPT ONE                              | 1   1^  s1                |
+| BA | 186 |  | MASCULINE ORDINAL INDICATOR                  | o_  s0  S0                |
+| BB | 187 |  | RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK   | >>                        |
+| BC | 188 |  | VULGAR FRACTION ONE QUARTER                  | 14                        |
+| BD | 189 |  | VULGAR FRACTION ONE HALF                     | 12                        |
+| BE | 190 |  | VULGAR FRACTION THREE QUARTERS               | 34                        |
+| BF | 191 |  | INVERTED QUESTION MARK                       | ?   ??                    |
+| C0 | 192 |  | LATIN CAPITAL LETTER A WITH GRAVE ACCENT     | `A  A`                    |
+| C1 | 193 |  | LATIN CAPITAL LETTER A WITH ACUTE ACCENT     | 'A  A'                    |
+| C2 | 194 |  | LATIN CAPITAL LETTER A WITH CIRCUMFLEX ACCENT| ^A  A^  A>                |
+| C3 | 195 |  | LATIN CAPITAL LETTER A WITH TILDE            | ~A  A~  A-                |
+| C4 | 196 |  | LATIN CAPITAL LETTER A WITH DIAERESIS        | "A  A"                    |
+| C5 | 197 |  | LATIN CAPITAL LETTER A WITH RING ABOVE       | oA  Ao  A*  OA            |
+| C6 | 198 |  | LATIN CAPITAL LIGATURE AE                    | AE                        |
+| C7 | 199 |  | LATIN CAPITAL LETTER C WITH CEDILLA          | ,C  C,                    |
+| C8 | 200 |  | LATIN CAPITAL LETTER E WITH GRAVE ACCENT     | `E  E`                    |
+| C9 | 201 |  | LATIN CAPITAL LETTER E WITH ACUTE ACCENT     | 'E  E'                    |
+| CA | 202 |  | LATIN CAPITAL LETTER E WITH CIRCUMFLEX ACCENT| ^E  E^  E>                |
+| CB | 203 |  | LATIN CAPITAL LETTER E WITH DIAERESIS        | "E  E"                    |
+| CC | 204 |  | LATIN CAPITAL LETTER I WITH GRAVE ACCENT     | `I  I`                    |
+| CD | 205 |  | LATIN CAPITAL LETTER I WITH ACUTE ACCENT     | 'I  I'                    |
+| CE | 206 |  | LATIN CAPITAL LETTER I WITH CIRCUMFLEX ACCENT| ^I  I^  I>                |
+| CF | 207 |  | LATIN CAPITAL LETTER I WITH DIAERESIS        | "I  I"                    |
+| D0 | 208 |  | LATIN CAPITAL LETTER ETH                     | D-                        |
+| D1 | 209 |  | LATIN CAPITAL LETTER N WITH TILDE            | ~N  N~  N-                |
+| D2 | 210 |  | LATIN CAPITAL LETTER O WITH GRAVE ACCENT     | `O  O`                    |
+| D3 | 211 |  | LATIN CAPITAL LETTER O WITH ACUTE ACCENT     | 'O  O'                    |
+| D4 | 212 |  | LATIN CAPITAL LETTER O WITH CIRCUMFLEX ACCENT| ^O  O^  O>                |
+| D5 | 213 |  | LATIN CAPITAL LETTER O WITH TILDE            | ~O  O~  O-                |
+| D6 | 214 |  | LATIN CAPITAL LETTER O WITH DIAERESIS        | "O  O"                    |
+| D7 | 215 |  | MULTIPLICATION SIGN                          | x   xx  XX  mu  MU        |
+| D8 | 216 |  | LATIN CAPITAL LETTER O WITH STROKE           | /O  O/                    |
+| D9 | 217 |  | LATIN CAPITAL LETTER U WITH GRAVE ACCENT     | `U  U`                    |
+| DA | 218 |  | LATIN CAPITAL LETTER U WITH ACUTE ACCENT     | 'U  U'                    |
+| DB | 219 |  | LATIN CAPITAL LETTER U WITH CIRCUMFLEX ACCENT| ^U  U^  U>                |
+| DC | 220 |  | LATIN CAPITAL LETTER U WITH DIAERESIS        | "U  U"                    |
+| DD | 221 |  | LATIN CAPITAL LETTER Y WITH ACUTE ACCENT     | 'Y  Y'                    |
+| DE | 222 |  | LATIN CAPITAL LETTER THORN                   | P   TH  |P                |
+| DF | 223 |  | LATIN SMALL LETTER SHARP S                   | ss                        |
+| E0 | 224 |  | LATIN SMALL LETTER A WITH GRAVE ACCENT       | `a  a`                    |
+| E1 | 225 |  | LATIN SMALL LETTER A WITH ACUTE ACCENT       | 'a  a'                    |
+| E2 | 226 |  | LATIN SMALL LETTER A WITH CIRCUMFLEX ACCENT  | ^a  a^  a>                |
+| E3 | 227 |  | LATIN SMALL LETTER A WITH TILDE              | ~a  a~  a-                |
+| E4 | 228 |  | LATIN SMALL LETTER A WITH DIAERESIS          | "a  a"                    |
+| E5 | 229 |  | LATIN SMALL LETTER A WITH RING ABOVE         | oa  ao  Oa                |
+| E6 | 230 |  | LATIN SMALL LIGATURE AE                      | ae                        |
+| E7 | 231 |  | LATIN SMALL LETTER C WITH CEDILLA            | ,c  c,                    |
+| E8 | 232 |  | LATIN SMALL LETTER E WITH GRAVE ACCENT       | `e  e`                    |
+| E9 | 233 |  | LATIN SMALL LETTER E WITH ACUTE ACCENT       | 'e  e'                    |
+| EA | 234 |  | LATIN SMALL LETTER E WITH CIRCUMFLEX ACCENT  | ^e  e^  e>                |
+| EB | 235 |  | LATIN SMALL LETTER E WITH DIAERESIS          | "e  e"                    |
+| EC | 236 |  | LATIN SMALL LETTER I WITH GRAVE ACCENT       | `i  i`                    |
+| ED | 237 |  | LATIN SMALL LETTER I WITH ACUTE ACCENT       | 'i  i'                    |
+| EE | 238 |  | LATIN SMALL LETTER I WITH CIRCUMFLEX ACCENT  | ^i  i^  i>                |
+| EF | 239 |  | LATIN SMALL LETTER I WITH DIAERESIS          | "i  i"                    |
+| F0 | 240 |  | LATIN SMALL LETTER ETH                       | d-                        |
+| F1 | 241 |  | LATIN SMALL LETTER N WITH TILDE              | ~n  n~  n-                |
+| F2 | 242 |  | LATIN SMALL LETTER O WITH GRAVE ACCENT       | `o  o`                    |
+| F3 | 243 |  | LATIN SMALL LETTER O WITH ACUTE ACCENT       | 'o  o'                    |
+| F4 | 244 |  | LATIN SMALL LETTER O WITH CIRCUMFLEX ACCENT  | ^o  o^  o>                |
+| F5 | 245 |  | LATIN SMALL LETTER O WITH TILDE              | ~o  o~  o-                |
+| F6 | 246 |  | LATIN SMALL LETTER O WITH DIAERESIS          | "o  o"                    |
+| F7 | 247 |  | DIVISION SIGN                                | -:  :-                    |
+| F8 | 248 |  | LATIN SMALL LETTER O WITH OBLIQUE BAR        | /o  o/                    |
+| F9 | 249 |  | LATIN SMALL LETTER U WITH GRAVE ACCENT       | `u  u`                    |
+| FA | 250 |  | LATIN SMALL LETTER U WITH ACUTE ACCENT       | 'u  u'                    |
+| FB | 251 |  | LATIN SMALL LETTER U WITH CIRCUMFLEX ACCENT  | ^u  u^  u>                |
+| FC | 252 |  | LATIN SMALL LETTER U WITH DIAERESIS          | "u  u"                    |
+| FD | 253 |  | LATIN SMALL LETTER Y WITH ACUTE ACCENT       | 'y  y'                    |
+| FE | 254 |  | LATIN SMALL LETTER THORN                     | p   th  |p                |
+| FF | 255 |  | LATIN SMALL LETTER Y WITH DIAERESIS          | "y  y"                    |
++----+-----+---+----------------------------------------------+---------------------------+
diff -Naur gdb-6.8/pdcurses/doc/overview.man stsgdb-6.8/pdcurses/doc/overview.man
--- gdb-6.8/pdcurses/doc/overview.man	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/doc/overview.man	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,60 @@
+/*man-start*********************************************************************
+
+			Curses Overview
+
+The X/Open Curses Interface Definition describes a set of C-Language
+functions that provide screen-handling and updating, which are
+collectively known as the curses library.
+
+The curses library permits manipulation of data structures called
+windows which may be thought of as two-dimensional arrays of
+characters representing all or part of a terminal's screen.  The
+windows are manipulated using a procedural interface described
+elsewhere.  The curses package maintains a record of what characters
+are on the screen.  At the most basic level, manipulation is done with
+the routines move() and addch() which are used to "move" the curses
+around and add characters to the default window, stdscr, which
+represents the whole screen.
+
+An application may use these routines to add data to the window in any
+convenient order.  Once all data have been added, the routine
+refresh() is called.  The package then determines what changes have
+been made which affect the screen.  The screen contents are then
+changed to reflect those characters now in the window. using a
+sequence of operations optimised for the type of terminal in use. 
+
+At a higher level routines combining the actions of move() and addch()
+are defined, as are routines to add whole strings and to perform
+format conversions in the manner of printf(). 
+
+Interfaces are alse defined to erase the entire window and to specify
+the attributes of individual characters in the winodw.  Attributes
+such as inverse video, underline and blink can be used on a
+per-character basis. 
+
+New windows can be created by allowing the application to build
+several images of the screen and display the appropriate one very
+quickly.  New windows are created using the routine newwin().  For
+each routine that manipulates the default window, stdscr, there is a
+corresponding routine prefixed with w to manipulate the contents of a
+specified window; for example, move() and wmove().  In fact, move(...)
+is functionally equivalent to wmove( stdscr, ...).  This is similar to
+the interface offered by printf(...) and fprintf(stdout, ...). 
+
+Windows do not have to correspond to the entire screen.  It is
+possible to create smaller windows, and also to indicate that the
+window is only partially visible on the screen.  Furthermore, large
+windows or pads, which are bigger than the actual screen size, may be
+created. 
+
+The routine newterm() may be called to "open" additional terminals by
+large applications wishing to manipulate several terminals at once.
+The set_term() function is used to select the terminal whose screen is
+to be updated by the next refresh(). 
+
+Interfaces are also defined to allow input character manipulation and
+to disable and enable many input attributes: character echo, single
+character input with or without signal processing (cbreak or raw
+modes), carriage returns mapping to newlines, screen scrolling, etc. 
+
+**man-end**********************************************************************/
diff -Naur gdb-6.8/pdcurses/doc/x11.man stsgdb-6.8/pdcurses/doc/x11.man
--- gdb-6.8/pdcurses/doc/x11.man	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/doc/x11.man	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,298 @@
+/*man-start*********************************************************************
+
+Introduction:
+------------
+
+ XCurses uses the System V IPC shared memory facility for sharing data
+ between the curses program and the child process created to manage the
+ X stuff. XCurses also uses sockets for communication between the
+ processes.
+
+ To use XCurses with an existing curses program, you need to make one
+ change to your code:
+
+ Call XCursesExit() just before exiting from your program. eg.
+
+#ifdef XCURSES
+ XCursesExit();
+#endif
+ exit(0);
+
+ This call is required to enable the child X process to shut down cleanly
+ and free up the shared memory it used.
+
+ When compiling your curses application, you need to add -DXCURSES, and
+ include the <curses.h> or <xcurses.h> that comes with XCurses. You also
+ need to link your code with the XCurses library.
+
+ XCurses programs use the X Toolkit Intrinsics libraries.  You will need
+ to link your code with the following libraries under X11R5:
+    Xaw Xmu Xt X11
+
+ and under X11R6:
+    Xaw Xmu Xt X11 SM ICE Xext
+
+ The best method of determining which libraries you need, is to
+ compile one of the demo programs and take note of the libraries
+ it uses.
+
+ To get the most out of XCurses in your curses application you need
+ to call Xinitscr() rather than initscr(). This allows you to pass
+ your program name and resource overrides to XCurses.
+
+ The program name is used as the title of the X window, and for defining X
+ resources specific to your program.
+
+Here be Dragons!
+----------------
+
+ Be aware that curses programs that expect to have a normal tty underneath
+ them will be very disappointed! Output directed to stdout after a call
+ to system() (maybe even exec()) will go to the xterm that invoked the
+ XCurses application, or to the console if not invoked directly from an
+ xterm. Similarly, stdin will expect its input from the same place as
+ stdout.
+
+ This situation is not desirable, but I know of no simple way to get
+ around this.
+
+
+X Resources:
+-----------
+
+XCurses recognises the following resources:
+
+    lines
+    cols
+    normalFont
+    italicFont
+    pointer
+    pointerForeColor
+    pointerBackColor
+    cursorColor
+    textCursor
+    colorBlack
+    colorRed
+    colorGreen
+    colorYellow
+    colorBlue
+    colorMagenta
+    colorCyan
+    colorWhite
+    colorBoldBlack
+    colorBoldRed
+    colorBoldGreen
+    colorBoldYellow
+    colorBoldBlue
+    colorBoldMagenta
+    colorBoldCyan
+    colorBoldWhite
+    bitmap
+    pixmap
+    translations
+    shmmin
+    borderWidth
+    borderColor
+    clickPeriod
+    doubleClickPeriod
+    composeKey
+
+lines:             specifies the number of lines the "screen" will have
+                   Directly equates to LINES
+                   There is no theoretical maximum.
+                   The minimum value must be 2.
+                   Default:        24
+
+cols:              specifies the number of columns the "screen" will have
+                   Directly equates to COLS
+                   There is no theoretical maximum.
+                   The minimum value must be 2.
+                   Default:        80
+
+normalFont:        the name of a fixed width font
+                   Default:        7x13
+
+italicFont:        the name of a fixed width font to be used for
+                   characters with A_ITALIC attributes. Must have the same
+                   cell size as normalFont
+                   Default:        7x13 (obviously not an italic font)
+
+pointer:           the name of a valid pointer cursor
+                   Default:        xterm
+
+pointerForeColor:  the foreground colour of the pointer
+                   Default:        black
+
+pointerBackColor:  the background colour of the pointer
+                   Default:        white
+
+cursorColor:       the colour of the text cursor
+                   Default:        Red
+                   *** This resource is now obsolete and is ignored ***
+
+textCursor:        the alignment of the text cursor; horizontal or vertical
+                   Default:        horizontal
+
+colorBlack:        the color of the COLOR_BLACK attribute
+                   Default: Black
+colorRed           the color of the COLOR_RED attribute
+                   Default: red3
+colorGreen         the color of the COLOR_GREEN attribute
+                   Default: green3
+colorYellow        the color of the COLOR_YELLOW attribute
+                   Default: yellow3
+colorBlue          the color of the COLOR_BLUE attribute
+                   Default: blue3
+colorMagenta       the color of the COLOR_MAGENTA attribute
+                   Default: magenta3
+colorCyan          the color of the COLOR_CYAN attribute
+                   Default: cyan3
+colorWhite         the color of the COLOR_WHITE attribute
+                   Default: Grey
+colorBoldBlack:    the color of the COLOR_BLACK attribute combined with A_BOLD
+                   Default: grey40
+colorBoldRed       the color of the COLOR_RED attribute combined with A_BOLD
+                   Default: red1
+colorBoldGreen     the color of the COLOR_GREEN attribute combined with A_BOLD
+                   Default: green1
+colorBoldYellow    the color of the COLOR_YELLOW attribute combined with A_BOLD
+                   Default: yellow1
+colorBoldBlue      the color of the COLOR_BLUE attribute combined with A_BOLD
+                   Default: blue1
+colorBoldMagenta   the color of the COLOR_MAGENTA attribute combined with A_BOLD
+                   Default: magenta1
+colorBoldCyan      the color of the COLOR_CYAN attribute combined with A_BOLD
+                   Default: cyan1
+colorBoldWhite     the color of the COLOR_WHITE attribute combined with A_BOLD
+                   Default: White
+
+bitmap:            the name of a valid bitmap file of depth 1 (black and white)
+                   used for the application's icon. The file is an X bitmap
+                   Default:        a 32x32 or 64x64 pixmap depending on the 
+                                   window manager
+
+pixmap:            the name of a valid pixmap file of any depth supported by the
+                   window manager 9color) for the application's icon, The file
+                   is an X11 pixmap. This resource is only available if the
+                   libXpm package has been installed (most systems have this by
+                   default). This resource overrides the "bitmap" resource
+                   Default:        none, uses default bitmap above
+
+translations:      Translations enable the user to customise the
+                   action that occurs when a key, combination of keys, or a
+                   button is pressed.  The translations in XCurses are similar
+                   in function and definition to translations used by xterm.
+                   Defaults:
+                        <Key>:                    XCursesKeyPress()
+                        <Btn1Down>:               XCursesButton()
+                        !Ctrl <Btn2Down>:         XCursesButton()
+                        <Btn2Down>,<Btn2Up>:      XCursesPasteSelection()
+                        <Btn3Down>:               XCursesButton()
+                        <Btn1Up>:                 XCursesButton()
+                        <Btn3Up>:                 XCursesButton()
+                        <BtnMotion>:              XCursesButton()
+
+                   The most useful action for KeyPress translations is string().
+                   The argument to the string() action can be either a string or
+                   a hex representation of a character. eg. string(0x1b) will
+                   result in the ASCII escape character to be sent to the 
+                   XCurses application. string("[11~") will result in [ 1 1 ~ 
+                   being sent, as seperate keystokes to the XCurses application.
+
+shmmin:            On most systems, there are two Unix kernel parameters that 
+                   determine the allowable size of a shared memory segment. These
+                   parameters are usually something like SHMMIN and SHMMAX. To use
+                   shared memory, a program must allocate a segment of shared memory
+                   that is between these two values.  Usually these values are
+                   like 1 for SHMMIN and some large number for SHMMAX. Sometimes
+                   the Unix kernel is configured to have a value of SHMMIN that is
+                   bigger than the size of one of the shared memory segments that
+                   XCurses uses. On these systems an error message like:
+
+                     Cannot allocate shared memory for SCREEN: Invalid argument
+
+                   will result. To overcome this problem, this XCurses resource
+                   should be set to the kernel value for SHMMIN. This ensures that
+                   a shared memory segment will always be bigger than the kernel
+                   value for SHMMIN (and hopefully less than SHMMAX!)
+
+                   Default:        0
+
+borderColor:       the colour of the border around the screen
+                   Default:        Black
+
+borderWidth:       the width in pixels of the border around the screen
+                   Default:        0
+
+clickPeriod:       the period (in milliseconds) between a button press
+                   and a button release that determines if a click
+                   of a button has occurred.
+                   Default:        100
+
+doubleClickPeriod: the period (in milliseconds) between two button
+                   press events that determines if a double click
+                   of a button has occurred.
+                   Default:        200
+
+composeKey:        the name of the X key that defines the "compose key" which
+                   is used to enter characters in the Latin-1 character set above
+                   0xA0.
+                   Generally this key will be one of the X "modifier" keys, like
+                   Alt_L, Meta_R etc. but can be a "normal" key like F1.  Try to 
+                   While in "compose key" mode, the text cursor will appear as
+                   a hollow rectangle.
+                   See the file latin-1.man for details on compose key usage.
+                   Default:        No key is defined
+
+Using Resources:
+---------------
+
+ All XCurses applications have a top-level class name of "XCurses".
+ The top-level widget name for each XCurses application is the
+ same as that defined by the XCursesProgram name in the application's
+ main source module.
+
+ An example of an XCurses app-defaults or .Xdefaults file might be:
+
+!
+! resources for XCurses class of programs
+!
+XCurses*lines:  30
+XCurses*cols:   80
+XCurses*normalFont:     9x13
+XCurses*bitmap: /tmp/xcurses.xbm
+XCurses*pointer: top_left_arrow
+!
+! resources for testcurs - XCurses
+!
+testcurs.colorRed:      orange
+testcurs.colorBlack:    midnightblue
+testcurs.lines: 25
+*testcurs.Translations: #override \n \
+  <Key>F12:  string(0x1b) string("[11~") \n
+!
+! resources for THE - XCurses
+!
+! resources with the * wildcard can be overridden by a parameter passed
+! to initscr()
+!
+the*normalFont: 9x15
+the*lines:      40
+the*cols:       86
+the*pointer:    xterm
+the*pointerForeColor: white
+the*pointerBackColor: black
+!
+! resources with the . format can not be overridden by a parameter passed
+! to Xinitscr()
+!
+the.bitmap:     /home/mark/the/the64.xbm
+the.pixmap:     /home/mark/the/the64.xpm
+
+Resources may also be passed as a parameter to the Xinitscr() function.
+The parameter is a string in the form of switches. eg. to set the color
+"red" to "indianred", and the number of lines to 30, the string passed to 
+Xinitscr would be:
+"-colorRed indianred -lines 30"
+
+**man-end**********************************************************************/
diff -Naur gdb-6.8/pdcurses/dos/bccdos.lrf stsgdb-6.8/pdcurses/dos/bccdos.lrf
--- gdb-6.8/pdcurses/dos/bccdos.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/bccdos.lrf	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,49 @@
+-+addch.obj &
+-+addchstr.obj &
+-+addstr.obj &
+-+attr.obj &
+-+beep.obj &
+-+bkgd.obj &
+-+border.obj &
+-+clear.obj &
+-+color.obj &
+-+delch.obj &
+-+deleteln.obj &
+-+getch.obj &
+-+getstr.obj &
+-+getyx.obj &
+-+inch.obj & 
+-+inchstr.obj &
+-+initscr.obj &
+-+inopts.obj &
+-+insch.obj &
+-+insstr.obj &
+-+instr.obj &
+-+kernel.obj &
+-+mouse.obj &
+-+move.obj & 
+-+outopts.obj &
+-+overlay.obj &
+-+pad.obj &  
+-+printw.obj &
+-+refresh.obj &
+-+scanw.obj &
+-+scr_dump.obj &
+-+scroll.obj &
+-+slk.obj &  
+-+termattr.obj &
+-+terminfo.obj &
+-+touch.obj &
+-+util.obj & 
+-+window.obj &
+-+pdcclip.obj &
+-+pdcdebug.obj &
+-+pdcdisp.obj &
+-+pdcgetsc.obj &
+-+pdckbd.obj &
+-+pdcprint.obj &
+-+pdcscrn.obj &
+-+pdcsetsc.obj &
+-+pdcutil.obj &
+-+pdcwin.obj &
+,lib.map
diff -Naur gdb-6.8/pdcurses/dos/bccdos.mak stsgdb-6.8/pdcurses/dos/bccdos.mak
--- gdb-6.8/pdcurses/dos/bccdos.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/bccdos.mak	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,342 @@
+################################################################################
+#
+# Borland MAKE Makefile for PDCurses library - DOS BC++ 3.0+
+#
+# Usage: make -f [path\]bccdos.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, and/or edit the 
+# lines below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+MODEL		=l
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\dos
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+#CC		= bcc
+
+!if $d(DEBUG)
+CFLAGS  = -N -v -y -DPDCDEBUG 
+!else
+CFLAGS  = -O 
+!endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= -c @$(osdir)\bccdos.rsp -m$(MODEL) $(CFLAGS) $(CPPFLAGS)
+
+LINK		= tlink
+
+LIBEXE		= tlib /C /E
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.map
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcdebug.obj  \
+pdcclip.obj   \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\bccdos.lrf
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $@ -+$(PANOBJS)
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\window.c
+
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcdebug.c
+ 
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcclip.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(CC) -e$@ $**
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Borland C++ 3.1 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Borland C/C++ 3.1 for DOS. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_HOME)\README > flist
+	echo $(PDCURSES_HOME)\readme.$(VER) >> flist
+	echo $(PDCURSES_HOME)\maintain.er >> flist
+	echo $(PDCURSES_HOME)\curses.h >> flist
+	echo $(PDCURSES_HOME)\curspriv.h >> flist
+	echo $(PDCURSES_HOME)\panel.h >> flist
+	echo $(PDCURSES_HOME)\term.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo $(LIBPANEL) >> flist
+	echo file_id.diz >> flist
+	zip -jX pdc$(VER)bcc -@ <flist
+	del flist
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/dos/bccdos.rsp stsgdb-6.8/pdcurses/dos/bccdos.rsp
--- gdb-6.8/pdcurses/dos/bccdos.rsp	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/bccdos.rsp	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,11 @@
+-1-
+-K
+-G
+-rd
+-d
+-V
+-w-eff
+-w-par
+-j0
+-c 
+-P-
diff -Naur gdb-6.8/pdcurses/dos/gccdos.lrf stsgdb-6.8/pdcurses/dos/gccdos.lrf
--- gdb-6.8/pdcurses/dos/gccdos.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/gccdos.lrf	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,49 @@
+-+addch.o &
+-+addchstr.o &
+-+addstr.o &
+-+attr.o &
+-+beep.o &
+-+bkgd.o &
+-+border.o &
+-+clear.o &
+-+color.o &
+-+delch.o &
+-+deleteln.o &
+-+getch.o &
+-+getstr.o &
+-+getyx.o &
+-+inch.o & 
+-+inchstr.o &
+-+initscr.o &
+-+inopts.o &
+-+insch.o &
+-+insstr.o &
+-+instr.o &
+-+kernel.o &
+-+mouse.o &
+-+move.o & 
+-+outopts.o &
+-+overlay.o &
+-+pad.o &  
+-+printw.o &
+-+refresh.o &
+-+scanw.o &
+-+scr_dump.o &
+-+scroll.o &
+-+slk.o &  
+-+termattr.o &
+-+terminfo.o &
+-+touch.o &
+-+util.o & 
+-+window.o &
+-+pdcclip.o &
+-+pdcdebug.o &
+-+pdcdisp.o &
+-+pdcgetsc.o &
+-+pdckbd.o &
+-+pdcprint.o &
+-+pdcscrn.o &
+-+pdcsetsc.o &
+-+pdcutil.o &
+-+pdcwin.o &
+,lib.map
diff -Naur gdb-6.8/pdcurses/dos/gccdos.mak stsgdb-6.8/pdcurses/dos/gccdos.mak
--- gdb-6.8/pdcurses/dos/gccdos.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/gccdos.mak	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,363 @@
+################################################################################
+#
+# GNU MAKE (3.79.1) Makefile for PDCurses library - DOS DJGPP V2.0+
+#
+# Usage: make -f [path\]gccdos.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|libs|demos|dist|pdcurses.a|panel.a|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line 
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME	= $(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H	=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H	=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS	=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)/panel.h
+TERM_HEADER		=$(PDCURSES_HOME)/term.h
+
+srcdir		= $(PDCURSES_HOME)/pdcurses
+osdir		= $(PDCURSES_HOME)/dos
+pandir		= $(PDCURSES_HOME)/panel
+demodir		= $(PDCURSES_HOME)/demos
+
+CC		= gcc
+
+ifeq ($(DEBUG),Y)
+	CFLAGS  = -c -g -Wall -DPDCDEBUG
+	LDFLAGS = -g
+else
+	CFLAGS  = -c -O2 -Wall
+	LDFLAGS =
+endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME) -D_NAIVE_DOS_REGS -funsigned-char
+
+CCFLAGS		= $(CFLAGS) $(CPPFLAGS)
+
+LINK		= gcc
+# COFF2EXE	= coff2exe	# deprecated, not required
+
+LIBEXE		= ar
+LIBFLAGS	= rcv
+
+LIBCURSES	= pdcurses.a
+LIBPANEL	= panel.a
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	= testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+.PHONY: all libs clean demos dist
+
+all:	$(PDCLIBS) $(DEMOS)
+
+libs:	$(PDCLIBS)
+
+clean:
+	-del *.o
+	-del $(LIBCURSES)
+	-del $(LIBPANEL)
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.o     \
+addchstr.o  \
+addstr.o    \
+attr.o      \
+beep.o      \
+bkgd.o      \
+border.o    \
+clear.o     \
+color.o     \
+delch.o     \
+deleteln.o  \
+getch.o     \
+getstr.o    \
+getyx.o     \
+inch.o      \
+inchstr.o   \
+initscr.o   \
+inopts.o    \
+insch.o     \
+insstr.o    \
+instr.o     \
+kernel.o    \
+mouse.o     \
+move.o      \
+outopts.o   \
+overlay.o   \
+pad.o       \
+printw.o    \
+refresh.o   \
+scanw.o     \
+scr_dump.o  \
+scroll.o    \
+slk.o       \
+termattr.o  \
+terminfo.o  \
+touch.o     \
+util.o      \
+window.o
+
+PDCOBJS =   \
+pdcclip.o   \
+pdcdebug.o  \
+pdcdisp.o   \
+pdcgetsc.o  \
+pdcgo32.o   \
+pdckbd.o    \
+pdcprint.o  \
+pdcscrn.o   \
+pdcsetsc.o  \
+pdcutil.o   \
+pdcwin.o
+
+PANOBJS =     \
+panel.o
+
+#------------------------------------------------------------------------
+
+pdcurses.a : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ $(LIBOBJS) $(PDCOBJS)
+
+panel.a : $(PANOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ $(PANOBJS)
+
+addch.o: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addch.c
+
+addchstr.o: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addchstr.c
+
+addstr.o: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addstr.c
+
+attr.o: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/attr.c
+
+beep.o: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/beep.c
+
+bkgd.o: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/bkgd.c
+
+border.o: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/border.c
+
+clear.o: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/clear.c
+
+color.o: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/color.c
+
+delch.o: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/delch.c
+
+deleteln.o: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/deleteln.c
+
+getch.o: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getch.c
+
+getstr.o: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getstr.c
+
+getyx.o: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getyx.c
+
+inch.o: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inch.c
+
+inchstr.o: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inchstr.c
+
+initscr.o: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/initscr.c
+
+inopts.o: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inopts.c
+
+insch.o: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insch.c
+
+insstr.o: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insstr.c
+
+instr.o: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/instr.c
+
+kernel.o: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/kernel.c
+
+mouse.o: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/mouse.c
+
+move.o: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/move.c
+
+outopts.o: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/outopts.c
+
+overlay.o: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/overlay.c
+
+pad.o: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pad.c
+
+printw.o: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/printw.c
+
+refresh.o: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/refresh.c
+
+scanw.o: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scanw.c
+
+scr_dump.o: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scr_dump.c
+
+scroll.o: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scroll.c
+
+slk.o: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/slk.c
+
+termattr.o: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/termattr.c
+
+terminfo.o: $(srcdir)/terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/terminfo.c
+
+touch.o: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/touch.c
+
+util.o: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/util.c
+
+window.o: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/window.c
+
+
+pdcclip.o: $(osdir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcclip.c
+
+pdcdebug.o: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcdebug.c
+
+pdcdisp.o: $(osdir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcdisp.c
+
+pdcgetsc.o: $(osdir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcgetsc.c
+
+pdcgo32.o: $(osdir)/pdcgo32.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcgo32.c
+
+pdckbd.o: $(osdir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdckbd.c
+
+pdcprint.o: $(osdir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcprint.c
+
+pdcscrn.o: $(osdir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcscrn.c
+
+pdcsetsc.o: $(osdir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcsetsc.c
+
+pdcutil.o: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcutil.c
+
+pdcwin.o: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.o: $(pandir)/panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)/panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o$@ firework.o $(LIBCURSES)
+	strip $@
+
+newdemo.exe:	newdemo.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o$@ newdemo.o $(LIBCURSES)
+	strip $@
+
+ptest.exe:	ptest.o $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -o$@ ptest.o $(LIBCURSES) $(LIBPANEL)
+	strip $@
+
+testcurs.exe:	testcurs.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o$@ testcurs.o $(LIBCURSES)
+	strip $@
+
+tuidemo.exe:	tuidemo.o tui.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o$@ tuidemo.o tui.o $(LIBCURSES)
+	strip $@
+
+xmas.exe:	xmas.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o$@ xmas.o $(LIBCURSES)
+	strip $@
+
+
+firework.o: $(demodir)/firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/firework.c
+
+newdemo.o: $(demodir)/newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/newdemo.c
+
+ptest.o: $(demodir)/ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/ptest.c
+
+testcurs.o: $(demodir)/testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/testcurs.c
+
+tui.o: $(demodir)/tui.c $(demodir)/tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)/tui.c
+
+tuidemo.o: $(demodir)/tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)/tuidemo.c
+
+xmas.o: $(demodir)/xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/xmas.c
+
+#------------------------------------------------------------------------
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for DJGPP 2.03 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo DJGPP 2.03 for DOS. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_HOME)\README > flist
+	echo $(PDCURSES_HOME)\readme.$(VER) >> flist
+	echo $(PDCURSES_HOME)\maintain.er >> flist
+	echo $(PDCURSES_HOME)\curses.h >> flist
+	echo $(PDCURSES_HOME)\curspriv.h >> flist
+	echo $(PDCURSES_HOME)\panel.h >> flist
+	echo $(PDCURSES_HOME)\term.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo $(LIBPANEL) >> flist
+	echo file_id.diz >> flist
+	zip -jX pdc$(VER)djg -@ <flist
+	del flist
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/dos/mscdos.lrf stsgdb-6.8/pdcurses/dos/mscdos.lrf
--- gdb-6.8/pdcurses/dos/mscdos.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/mscdos.lrf	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,49 @@
+-+addch.obj &
+-+addchstr.obj &
+-+addstr.obj &
+-+attr.obj &
+-+beep.obj &
+-+bkgd.obj &
+-+border.obj &
+-+clear.obj &
+-+color.obj &
+-+delch.obj &
+-+deleteln.obj &
+-+getch.obj &
+-+getstr.obj &
+-+getyx.obj &
+-+inch.obj & 
+-+inchstr.obj &
+-+initscr.obj &
+-+inopts.obj &
+-+insch.obj &
+-+insstr.obj &
+-+instr.obj &
+-+kernel.obj &
+-+mouse.obj &
+-+move.obj & 
+-+outopts.obj &
+-+overlay.obj &
+-+pad.obj &  
+-+printw.obj &
+-+refresh.obj &
+-+scanw.obj &
+-+scr_dump.obj &
+-+scroll.obj &
+-+slk.obj &  
+-+termattr.obj &
+-+terminfo.obj &
+-+touch.obj &
+-+util.obj & 
+-+window.obj &
+-+pdcclip.obj &
+-+pdcdebug.obj &
+-+pdcdisp.obj &
+-+pdcgetsc.obj &
+-+pdckbd.obj &
+-+pdcprint.obj &
+-+pdcscrn.obj &
+-+pdcsetsc.obj &
+-+pdcutil.obj &
+-+pdcwin.obj &
+,lib.map;
diff -Naur gdb-6.8/pdcurses/dos/mscdos.mak stsgdb-6.8/pdcurses/dos/mscdos.mak
--- gdb-6.8/pdcurses/dos/mscdos.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/mscdos.mak	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,349 @@
+################################################################################
+#
+# NMAKE Makefile for PDCurses library - DOS MSC
+#
+# Usage: nmake -f [path\]dosmsc.mak [DEBUG=1] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, and/or edit the
+# lines below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+MODEL		=L       # one of L, S, M, T, H, C
+SIZE		=LARGE    # one of LARGE, SMALL, MEDIUM, TINY, HUGE, COMPACT
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\dos
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= cl
+
+!ifdef DEBUG
+CFLAGS  = /nologo /Od /Zi /DPDCDEBUG
+LDFLAGS = /CO /NOE /SE:160 
+!else
+CFLAGS  = /Ox
+LDFLAGS = /NOE /SE:160
+!endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= /J /nologo /c /EM /D$(SIZE) /A$(MODEL) $(CFLAGS) $(CPPFLAGS)
+
+LINK		= link
+
+CCLIBS		=
+
+LIBEXE		= lib
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+LIBRARIES	=	$(LIBCURSES) $(LIBPANEL)
+DEMOS	= testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(LIBRARIES) $(DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\mscdos.lrf
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $@ -+$(PANOBJS);
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+#            DLFLAGS  = $(LDEBUG) $*$(OBJ),$*,,$(PDCLIB);
+#            PANFLAGS = $(LDEBUG) $*$(OBJ),$*,,$(PDCLIB)+$(PANLIB);
+#	$(LINK) $*.obj,$*.exe,$*.map,$(CCLIBS)+$(LIBCURSES) $(LDFLAGS);
+
+firework.exe: firework.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+newdemo.exe: newdemo.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+ptest.exe: ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBPANEL)+$(LIBCURSES);
+
+testcurs.exe: testcurs.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+tuidemo.exe: tuidemo.obj tui.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj+tui.obj,$*,,$(LIBCURSES);
+
+xmas.exe: xmas.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Microsoft C++ 6.0 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Microsoft C/C++ 6.0 for DOS. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_HOME)\README > flist
+	echo $(PDCURSES_HOME)\readme.$(VER) >> flist
+	echo $(PDCURSES_HOME)\maintain.er >> flist
+	echo $(PDCURSES_HOME)\curses.h >> flist
+	echo $(PDCURSES_HOME)\curspriv.h >> flist
+	echo $(PDCURSES_HOME)\panel.h >> flist
+	echo $(PDCURSES_HOME)\term.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo $(LIBPANEL) >> flist
+	echo file_id.diz >> flist
+	zip -jX pdc$(VER)msc -@ <flist
+	del flist
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/dos/msvcdos.mak stsgdb-6.8/pdcurses/dos/msvcdos.mak
--- gdb-6.8/pdcurses/dos/msvcdos.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/msvcdos.mak	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,349 @@
+################################################################################
+#
+# NMAKE Makefile for PDCurses library - DOS MS Visual C++ 1.0
+#
+# Usage: nmake -f [path\]dosmsc.mak [DEBUG=1] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, and/or edit the
+# lines below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+MODEL		=L       # one of L, S, M, T, H, C
+SIZE		=LARGE    # one of LARGE, SMALL, MEDIUM, TINY, HUGE, COMPACT
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\dos
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= cl
+
+!ifdef DEBUG
+CFLAGS  = /nologo /Od /Zi /DPDCDEBUG
+LDFLAGS = /CO /NOE /SE:160 
+!else
+CFLAGS  = /Ox
+LDFLAGS = /NOE /SE:160
+!endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= /J /nologo /c /D$(SIZE) /A$(MODEL) $(CFLAGS) $(CPPFLAGS)
+
+LINK		= link
+
+CCLIBS		=
+
+LIBEXE		= lib
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+LIBRARIES	=	$(LIBCURSES) $(LIBPANEL)
+DEMOS	= testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(LIBRARIES) $(DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\mscdos.lrf
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $@ -+$(PANOBJS);
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+#            DLFLAGS  = $(LDEBUG) $*$(OBJ),$*,,$(PDCLIB);
+#            PANFLAGS = $(LDEBUG) $*$(OBJ),$*,,$(PDCLIB)+$(PANLIB);
+#	$(LINK) $*.obj,$*.exe,$*.map,$(CCLIBS)+$(LIBCURSES) $(LDFLAGS);
+
+firework.exe: firework.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+newdemo.exe: newdemo.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+ptest.exe: ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBPANEL)+$(LIBCURSES);
+
+testcurs.exe: testcurs.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+tuidemo.exe: tuidemo.obj tui.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj+tui.obj,$*,,$(LIBCURSES);
+
+xmas.exe: xmas.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Microsoft Visual C++ 1.0 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Microsoft Visual C/C++ 1.0 for DOS. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_HOME)\README > flist
+	echo $(PDCURSES_HOME)\readme.$(VER) >> flist
+	echo $(PDCURSES_HOME)\maintain.er >> flist
+	echo $(PDCURSES_HOME)\curses.h >> flist
+	echo $(PDCURSES_HOME)\curspriv.h >> flist
+	echo $(PDCURSES_HOME)\panel.h >> flist
+	echo $(PDCURSES_HOME)\term.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo $(LIBPANEL) >> flist
+	echo file_id.diz >> flist
+	zip -jX pdc$(VER)vcd -@ <flist
+	del flist
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/dos/pdcclip.c stsgdb-6.8/pdcurses/dos/pdcclip.c
--- gdb-6.8/pdcurses/dos/pdcclip.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcclip.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,198 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCclip  = "$Id: pdcclip.c,v 1.6 2003/06/23 07:54:31 mark Exp $";
+#endif
+
+#include <string.h>
+
+/* global clipboard contents, should be NULL if none set */
+static char *pdc_DOS_clipboard = NULL;
+
+/*man-start*********************************************************************
+
+  PDC_getclipboard()	- Gets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Gets the textual contents of the system's clipboard. This
+ 	function returns the contents of the clipboard in the contents
+ 	argument. It is the responsibilitiy of the caller to free the
+ 	memory returned with the PDC_freeclipboard() call.  The length of the
+ 	clipboard contents is returned in the length argument.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_MEMORY_ERROR	unable to allocate sufficient memory for 
+ 		the clipboard contents
+ 	PDC_CLIP_EMPTY	the clipboard contains no text
+ 	PDC_CLIP_ACCESS_ERROR	no clipboard support
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char **contents, long *length );
+
+**man-end**********************************************************************/
+int	PDC_CDECL	PDC_getclipboard(char **contents, long *length)
+{
+  int len;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_getclipboard() - called\n");
+#endif
+
+	if (pdc_DOS_clipboard == NULL) return PDC_CLIP_EMPTY;
+
+	len = strlen(pdc_DOS_clipboard);
+	if ((*contents = (char *)malloc((len+1) * sizeof(char))) == NULL)
+		return PDC_CLIP_MEMORY_ERROR;
+
+	strcpy(*contents, pdc_DOS_clipboard);
+	*length = len;
+
+	return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_setclipboard()	- Sets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Copies the supplied text into the system's clipboard, emptying
+ 	the clipboard prior to the copy.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_MEMORY_ERROR	unable to allocate sufficient memory for 
+ 		the clipboard contents
+ 	PDC_CLIP_ACCESS_ERROR	no clipboard support
+
+  Portability:
+ 	PDCurses	int PDC_setclipboard( char *contents, long length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_setclipboard(char *contents, long length)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_setclipboard() - called\n");
+#endif
+
+	if (pdc_DOS_clipboard != NULL) 
+	{
+		free(pdc_DOS_clipboard);
+		pdc_DOS_clipboard = NULL;
+	}
+
+	if (contents != NULL)
+	{
+		if ((pdc_DOS_clipboard = (char *)malloc((length+1) * sizeof(char))) == NULL)
+			return PDC_CLIP_MEMORY_ERROR;
+
+		strcpy(pdc_DOS_clipboard, contents);
+	}
+
+	return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_freeclipboard()	- Frees the memory associated with the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Frees the memory allocated by PDC_getclipboard().
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_freeclipboard( char *contents );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_freeclipboard(char *contents)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_freeclipboard() - called\n");
+#endif
+
+	/* should we also free empty the system clipboard? probably not */
+
+	if (contents != NULL)
+	{
+		/* NOTE: We free the memory, but we can not set caller's pointer
+		         to NULL, so if caller calls again then will try to
+		         access free'd memory.  We 1st overwrite memory with
+		         a string so if caller tries to use free memory they
+		         won't get what they expect & hopefully notice.
+		*/
+		/* memset(contents, 0xFD, strlen(contents)); */
+		if (strlen(contents) >= strlen("PDCURSES")) strcpy(contents, "PDCURSES");
+		free(contents);
+	}
+
+	return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_clearclipboard()	- Clears the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Clears the internal clipboard.
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_clearclipboard( void );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_clearclipboard( void )
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_clearclipboard() - called\n");
+#endif
+
+	if (pdc_DOS_clipboard != NULL) 
+	{
+		free(pdc_DOS_clipboard);
+		pdc_DOS_clipboard = NULL;
+	}
+	return PDC_CLIP_SUCCESS;
+}
+
+
diff -Naur gdb-6.8/pdcurses/dos/pdcdisp.c stsgdb-6.8/pdcurses/dos/pdcdisp.c
--- gdb-6.8/pdcurses/dos/pdcdisp.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcdisp.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,731 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdisp  = "$Id: pdcdisp.c,v 1.8 2005/12/15 00:48:15 wmcbrine Exp $";
+#endif
+
+#ifdef PC
+void movedata(unsigned sseg, unsigned soff, unsigned dseg, unsigned doff, unsigned n)
+{
+	far char *src = MK_FP(sseg, soff);
+	far char *dst = MK_FP(dseg, doff);
+
+	while (n--) {
+		*dst++ = *src++;
+	}
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_clr_update()	- Updates the screen with a full redraw.
+
+  PDCurses Description:
+ 	Updates the screen by clearing it and then redraw it in its
+ 	entirety. If SP->refrbrk is TRUE, and there is pending
+ 	input characters, the update will be prematurely terminated.
+
+  PDCurses Return Value:
+ 	This routine returns ERR if it is unable to accomplish it's task.
+ 	This return value is ONLY under FLEXOS.
+
+ 	The return value OK is returned if there were no errors.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_clr_update( WINDOW* s );
+
+**man-end**********************************************************************/
+
+	extern unsigned	char atrtab[MAX_ATRTAB];
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_clr_update(WINDOW *s)
+#else
+int	PDC_clr_update(s)
+WINDOW *s;
+#endif
+/***********************************************************************/
+{
+register int	i=0,j=0;
+	WINDOW*	w=NULL;
+	unsigned short*	ch;
+	bool rc=FALSE;
+
+#if SMALL || MEDIUM
+# if !PC
+struct SREGS segregs;
+# endif
+int ds=0;
+#endif
+
+#if defined(NDP)
+	int *VIDPOINT;
+#endif
+
+/* the next two variables have been changed from chtype to unsigned short */
+/* as this is the correct datatype for a physical character/attribute */
+	unsigned short temp_line[256]; /* this should be enough for the maximum width of a screen. MH-920715 */
+	unsigned short chr;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_clr_update() - called\n");
+#endif
+
+	w = curscr;
+	if (w == (WINDOW *)NULL)
+		return( ERR );
+#if 0
+	if (SP->full_redraw)
+		PDC_clr_scrn(s); /* clear physical screen */
+#endif
+
+	s->_clear = FALSE;
+	for (i = 0; i < LINES; i++)	/* update physical screen */
+	{
+		if (s != w)	/* copy s to curscr */
+			memcpy(w->_y[i], s->_y[i], COLS * sizeof(chtype));
+
+		ch = temp_line; /* now have ch pointing to area to contain real attributes. MH-920715 */
+
+
+		for (j=0;j<COLS;j++)          /* for each chtype in the line... */
+		   {
+		    chr = (unsigned short)(s->_y[i][j] & A_CHARTEXT);
+		    temp_line[j] = chtype_attr(s->_y[i][j]) | chr;
+		   }
+
+		if (SP->direct_video)
+		{
+
+#ifdef __DJGPP__
+			dosmemput (ch, COLS * sizeof(unsigned short),
+				(unsigned long)_FAR_POINTER(SP->video_seg,
+				SP->video_ofs + (i * COLS * sizeof(unsigned short))));
+#else
+#  if	(SMALL || MEDIUM)
+#    if PC
+			ds = FP_SEG((void far *) ch);
+#    else
+		segread(&segregs);
+		ds = segregs.ds;
+#    endif
+		movedata(ds, (int)ch,
+				SP->video_seg,
+				SP->video_ofs + (i*COLS*sizeof(unsigned short)),
+			        (COLS * sizeof(unsigned short)));
+#  else
+/*
+#  ifdef	NDP
+			VIDPOINT = (int *) mapdev(MK_FP(SP->video_seg,
+			  SP->video_ofs + (i * COLS * sizeof(unsigned short))),
+			  (COLS * sizeof(unsigned short)));
+			memcpy(VIDPOINT, (int *) ch, (COLS * sizeof(unsigned short)));
+*/
+			memcpy((void *)_FAR_POINTER(SP->video_seg,
+			  SP->video_ofs + (i * COLS * sizeof(unsigned short))),
+			       ch, (COLS * sizeof(unsigned short)));
+#  endif
+#endif
+
+		}
+		else
+		{
+
+			for (j = 0; j < COLS; j++)
+			{
+				PDC_gotoxy(i, j);
+				PDC_putc( (*ch & 0x00FF), (*ch & 0xFF00) >> 8 );
+				ch++;
+			}
+
+		}
+
+		if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+		{
+			rc = PDC_breakout();
+			if(rc) 
+				break;
+		}
+		w->_firstch[i] = _NO_CHANGE;
+		w->_lastch[i] = _NO_CHANGE;
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_on()	- Turns on the hardware cursor.
+
+  PDCurses Description:
+ 	Turns on the hardware curses, it does nothing if it is already on.
+
+  PDCurses Return Value:
+ 	Returns OK upon success, ERR upon failure.
+
+  Portability:
+ 	PDCurses	int PDC_cursor_on( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_cursor_on(void)
+#else
+int	PDC_cursor_on()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_cursor_on() - called\n");
+#endif
+
+	if	(!SP->visible_cursor)
+	{
+		SP->visible_cursor = TRUE;
+/*		PDC_fix_cursor(SP->orig_emulation);*/
+		if (SP->bogus_adapter)
+		{
+			PDC_set_cursor_mode((SP->cursor & 0xff00) >> 8,
+				     (SP->cursor & 0x00ff));
+		}
+		else
+		{
+			switch (SP->adapter) {
+			case _MDA:
+			case _CGA:
+			case _EGACOLOR:
+			case _EGAMONO:
+			case _VGACOLOR:
+			case _VGAMONO:
+			case _MDS_GENIUS:
+/*				PDC_set_cursor_mode(SP->font - 2, SP->font - 1);*/
+				PDC_set_cursor_mode((SP->cursor & 0xff00) >> 8,
+					     (SP->cursor & 0x00ff));
+				break;
+			case _MCGACOLOR:
+			case _MCGAMONO:
+/*				PDC_set_cursor_mode(SP->font - 1, SP->font - 2);*/
+				PDC_set_cursor_mode((SP->cursor & 0xff00) >> 8,
+					     (SP->cursor & 0x00ff));
+				break;
+			case _FLEXOS:
+				PDC_set_cursor_mode(SP->visible_cursor, 0);
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_off()	- Turns off the hardware cursor.
+
+  PDCurses Description:
+ 	Turns off the hardware curses, it does nothing if it is already off.
+
+  PDCurses Return Value:
+ 	Returns OK upon success, ERR upon failure.
+
+  PDCurses Errors:
+ 	ERR will be returned (in the case of FLEXOS) if the hardware cursor
+ 	can not be disabled.
+
+  Portability:
+ 	PDCurses	int PDC_cursor_off( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_cursor_off(void)
+#else
+int	PDC_cursor_off()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_cursor_off() - called\n");
+#endif
+
+	if	(SP->visible_cursor)
+	{
+		SP->visible_cursor = FALSE;
+		switch (SP->adapter)
+		{
+		case _FLEXOS:
+			PDC_set_cursor_mode(SP->visible_cursor, 0);
+			break;
+		default:
+			PDC_set_cursor_mode(32, 33);	/* turn it off */
+			break;
+		}
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_fix_cursor()	- Fix the cursor start and stop scan lines (if necessary)
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will fix the cursor shape for certain video adapters.
+ 	Normally, the values used are correct, but some adapters choke.
+ 	The most noticable choke is on a monochrome adapter.  The "correct"
+ 	scan lines will result in the cursor being set in the middle of the
+ 	character cell, rather than at the bottom.
+
+ 	The passed flag indicates whether the cursor is visible or not.
+
+ 	This only applies to the DOS platform.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_fix_cursor( int flag );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_fix_cursor(int flag)
+#else
+int	PDC_fix_cursor(flag)
+int flag;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_fix_cursor() - called\n");
+#endif
+
+	if (SP->bogus_adapter)
+		return( OK );
+
+	switch (SP->adapter)
+	{
+	case _EGACOLOR:
+	case _EGAMONO:
+	case _MDS_GENIUS:		/* Some clones look like a Genius;-)  */
+		if (flag & 0x01)
+			setdosmembyte (0x487, getdosmembyte (0x487) | 0x01); /* Enable emulation */
+		else
+			setdosmembyte (0x487, getdosmembyte (0x487) & ~0x01); /* Disable emulation */
+		break;
+
+	case _VGACOLOR:
+	case _VGAMONO:
+		if (flag & 0x01)
+#ifdef WATCOMC
+			regs.w.ax = 0x1200;		/* Enable  emulation */
+#else
+			regs.x.ax = 0x1200;		/* Enable  emulation */
+#endif
+		else
+#ifdef WATCOMC
+			regs.w.ax = 0x1201;		/* Disable emulation */
+#else
+			regs.x.ax = 0x1201;		/* Disable emulation */
+#endif
+		regs.h.bl = 0x34;
+		int86(0x10, &regs, &regs);
+
+		break;
+
+	case _MCGACOLOR:
+	case _MCGAMONO:
+	case _MDA:
+	case _CGA:
+	case _NONE:
+	default:
+		break;
+	}
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_gotoxy()	- position hardware cursor at (x, y)
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Moves the physical cursor to the desired address on the
+ 	screen. We don't optimize here -- on a PC, it takes more time
+ 	to optimize than to do things directly.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_gotoxy( int row, int col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_gotoxy(int row, int col)
+#else
+int	PDC_gotoxy(row,col)
+int row;
+int col;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_gotoxy() - called: row %d col %d\n",row,col);
+#endif
+	regs.h.ah = 0x02;
+	regs.h.bh = SP->video_page;
+	regs.h.dh = (unsigned char) row;
+	regs.h.dl = (unsigned char) col;
+	int86(0x10, &regs, &regs);
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_putc()	- Output a character in the current attribute.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Outputs character 'chr' to screen in tty fashion. If a colour
+ 	mode is active, the character is written with colour 'colour'.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_putc( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_putc( chtype character, chtype color )
+#else
+int	PDC_putc(character,color)
+chtype character;
+chtype color;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_putc() - called:char=%c attrib=0x%x color=0x%x\n",character & A_CHARTEXT,character & A_ATTRIBUTES,color);
+#endif
+
+	regs.h.ah = 0x09;	/* Avoid screen wrap.  Don't advance cursor. */
+	regs.h.al = (unsigned char) (character & 0x00FF);
+	regs.h.bh = SP->video_page;
+	regs.h.bl = (unsigned char) (color);
+#ifdef WATCOMC
+	regs.w.cx = 1;
+#else
+	regs.x.cx = 1;
+#endif
+	int86(0x10, &regs, &regs);
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_putctty()	- Output a character and attribute in TTY fashion.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Outputs character 'chr' to screen in tty fashion. If a colour
+ 	mode is active, the character is written with colour 'colour'.
+
+ 	This function moves the physical cursor after writing so the
+ 	screen will scroll if necessary.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_putctty( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_putctty( chtype character, chtype color )
+#else
+int	PDC_putctty(character,color)
+chtype character;
+chtype color;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_putctty() - called\n");
+#endif
+
+	regs.h.ah = 0x0e;	/* Write in TTY fashion, advance cursor. */
+	regs.h.al = (unsigned char) (character & 0x00FF);
+	regs.h.bh = SP->video_page;
+	regs.h.bl = (unsigned char) ((color & 0xFF00) >> 8);
+	int86(0x10, &regs, &regs);
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_scroll()	- low level screen scroll
+
+  PDCurses Description:
+ 	Scrolls a window in the current page up or down. Urow, lcol,
+ 	lrow, rcol are the window coordinates.	Lines is the number of
+ 	lines to scroll. If 0, clears the window, if < 0 scrolls down,
+ 	if > 0 scrolls up.  Blanks areas that are left, and sets
+ 	character attributes to attr. If in a colour graphics mode,
+ 	fills them with the colour 'attr' instead.
+
+  PDCurses Return Value:
+ 	The PDC_scroll() function returns OK on success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	An error will only be returned on the Flexos platform if s_copy()
+ 	fails.
+
+  Portability:
+ 	PDCurses	int PDC_scroll( int urow, int lcol, int rcol,
+ 				     int nlines, chtype attr );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_scroll(int urow, int lcol, int lrow, int rcol, int nlines, chtype attr)
+#else
+int	PDC_scroll(urow,lcol,lrow,rcol,nlines,attr)
+int urow;
+int lcol;
+int lrow;
+int rcol;
+int nlines;
+chtype attr;
+#endif
+/***********************************************************************/
+{
+	int	phys_attr=chtype_attr(attr);
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scroll() - called: urow %d lcol %d lrow %d rcol %d nlines %d\n",urow,lcol,lrow,rcol,nlines);
+#endif
+
+	if (nlines >= 0)
+	{
+		regs.h.ah = 0x06;
+		regs.h.al = (unsigned char) nlines;
+	}
+	else
+	{
+		regs.h.ah = 0x07;
+		regs.h.al = (unsigned char) (-nlines);
+	}
+	regs.h.bh = (unsigned char)(phys_attr >> 8);
+	regs.h.ch = (unsigned char) urow;
+	regs.h.cl = (unsigned char) lcol;
+	regs.h.dh = (unsigned char) lrow;
+	regs.h.dl = (unsigned char) rcol;
+	int86(0x10, &regs, &regs);
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_transform_line()	- display a physical line of the screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Updates the given physical line to look like the corresponding
+ 	line in _curscr.
+
+  PDCurses Return Value:
+ 	This routine returns TRUE if a premature refresh end
+ 	is allowed, and there is an input character pending.  Otherwise,
+ 	FALSE is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	bool	PDC_transform_line( int lineno );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_transform_line(register int lineno)
+#else
+bool	PDC_transform_line(lineno)
+register int lineno;
+#endif
+/***********************************************************************/
+{
+#if defined (MSC)
+chtype *srcp;
+#else
+register chtype *srcp;
+#endif
+
+#if SMALL || MEDIUM
+# if !PC
+struct SREGS segregs;
+# endif
+int ds=0;
+#endif
+
+	int x;
+	int endx;
+	int len;
+
+#if defined(NDP)
+	int *VIDPOINT;
+#endif
+
+	unsigned short temp_line[256]; /* this should be enough for the maximum width of a screen. MH-920715 */
+	unsigned short chr;
+	unsigned short *ch;
+
+	register int j;
+	bool rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_transform_line() - called: line %d\n",lineno);
+#endif
+
+	if (curscr == (WINDOW *)NULL)
+		return( FALSE );
+
+	memset(temp_line,' ',sizeof(temp_line));
+
+	x = curscr->_firstch[lineno];
+	endx = curscr->_lastch[lineno];
+	srcp = curscr->_y[lineno] + x;
+	len = endx-x+1;
+
+	ch = temp_line; /* now have ch pointing to area to contain real attributes. MH-920715 */
+
+/* replace the attribute part of the chtype with the actual colour value */
+/* replacing the number that points to the actual colour value.          */
+
+	for (j=0;j<len;j++)          /* for each chtype in the line... */
+	   {
+	    chr = *(srcp+j) & A_CHARTEXT;
+	    temp_line[j] = chtype_attr(*(srcp+j)) | chr;
+	   }
+
+	if (SP->direct_video)
+	{
+
+#ifdef __DJGPP__
+		dosmemput (ch, len * sizeof(unsigned short),
+			(unsigned long)_FAR_POINTER(SP->video_seg,
+			SP->video_ofs + (((lineno * curscr->_maxx) + x) * sizeof(unsigned short))));
+#else
+#  if	SMALL || MEDIUM
+#    if PC
+		ds = FP_SEG((void far *) ch);
+#    else
+		segread(&segregs);
+		ds = segregs.ds;
+#    endif
+		movedata(ds,(int)ch,
+			SP->video_seg,
+			SP->video_ofs+(((lineno*curscr->_maxx)+x)*sizeof(unsigned short)),
+		        len * sizeof(unsigned short));
+#  else
+		memcpy((void *)_FAR_POINTER(SP->video_seg,
+			     SP->video_ofs + (((lineno * curscr->_maxx) + x) * sizeof(unsigned short))),
+		       ch, len * sizeof(unsigned short));
+#  endif
+#endif
+
+	}
+	else
+	{
+
+		for (; x <= endx; x++)
+		{
+			PDC_gotoxy(lineno, x);
+			PDC_putc( (*ch & 0x00FF),(*ch & 0xFF00) >> 8 );
+			ch++;
+		}
+
+	}
+	curscr->_firstch[lineno] = _NO_CHANGE;
+	curscr->_lastch[lineno] = _NO_CHANGE;
+
+	if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+	{
+		rc = PDC_breakout();
+		if(rc) 
+			return(TRUE);
+	}
+	return(FALSE);
+}
+
+
diff -Naur gdb-6.8/pdcurses/dos/pdcgetsc.c stsgdb-6.8/pdcurses/dos/pdcgetsc.c
--- gdb-6.8/pdcurses/dos/pdcgetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcgetsc.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,859 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCgetsc  = "$Id: pdcgetsc.c,v 1.4 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_pos()	- return current cursor position
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	Gets the cursor position in video page 0.  'row' and 'column'
+ 	are the cursor address.  At this time, there is no support for
+ 	use of multiple screen pages.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cursor_pos( int* row, int* col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_cursor_pos(int *row, int *col)
+#else
+int	PDC_get_cursor_pos(row,col)
+int *row;
+int *col;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cursor_pos() - called\n");
+#endif
+
+	regs.h.ah = 0x03;
+	regs.h.bh = SP->video_page;
+	int86(0x10, &regs, &regs);
+	*row = regs.h.dh;
+	*col = regs.h.dl;
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_col()	- get current column position of cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This routine returns the current column position of the cursor on
+ 	screen.
+
+  PDCurses Return Value:
+ 	This routine returns the current column position of the cursor. No
+ 	error is returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cur_col( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_cur_col(void)
+#else
+int	PDC_get_cur_col()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cur_col() - called\n");
+#endif
+
+#ifdef WATCOMC
+	regs.w.ax = 0x0003;
+#else
+	regs.x.ax = 0x0003;
+#endif
+	regs.h.bh = SP->video_page;
+	int86(0x10, &regs, &regs);
+	return((int) regs.h.dl);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_row()	- get current row position of cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This routine returns the current row position of the cursor on
+ 	screen.
+
+  PDCurses Return Value:
+ 	This routine returns the current row position of the cursor. No
+ 	error is returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cur_row( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_cur_row(void)
+#else
+int	PDC_get_cur_row()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cur_row() - called\n");
+#endif
+
+#ifdef WATCOMC
+	regs.w.ax = 0x0003;
+#else
+	regs.x.ax = 0x0003;
+#endif
+	regs.h.bh = SP->video_page;
+	int86(0x10, &regs, &regs);
+	return ((int) regs.h.dh);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_attribute()	- Get attribute at current cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	Return the current attr at current cursor position on the screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_attribute( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_attribute(void)
+#else
+int	PDC_get_attribute()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_attribute() - called\n");
+#endif
+
+#ifdef WATCOMC
+	regs.w.ax = 0x0800;
+#else
+	regs.x.ax = 0x0800;
+#endif
+	regs.h.bh = SP->video_page;
+	int86(0x10, &regs, &regs);
+	return ((int) regs.h.ah);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_columns()	- return width of screen/viewport.
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This function will return the width of the current screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_columns( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_columns(void)
+#else
+int	PDC_get_columns()
+#endif
+/***********************************************************************/
+{
+	int	cols=0;
+	char *env_cols=NULL;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_columns() - called\n");
+#endif
+
+/* use the value from COLS environment variable, if set. MH 10-Jun-92 */
+/* and use the minimum of COLS and return from int10h    MH 18-Jun-92 */
+	regs.h.ah = 0x0f;
+	int86(0x10, &regs, &regs);
+	cols = (int)regs.h.ah;
+	env_cols = (char *)getenv("COLS");
+	if (env_cols != (char *)NULL)
+	{
+		cols = min(atoi(env_cols),cols);
+	}
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_columns() - returned: cols %d\n",cols);
+#endif
+	return(cols);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_mode()	- Get the cursor start and stop scan lines.
+
+  PDCurses Description:
+ 	Gets the cursor type to begin in scan line startrow and end in
+ 	scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_cursor_mode( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_cursor_mode(void)
+#else
+int	PDC_get_cursor_mode()
+#endif
+/***********************************************************************/
+{
+	short	cmode=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cursor_mode() - called\n");
+#endif
+
+	cmode = getdosmemword (0x460);
+	return (cmode);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_font()	- Get the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This function returns the current font size.  This function only
+ 	works if the #define FAST_VIDEO is true.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	An ERR will be returned if FAST_VIDEO is not true.
+
+  Portability:
+ 	PDCurses	int PDC_get_font( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_font(void)
+#else
+int	PDC_get_font()
+#endif
+/***********************************************************************/
+{
+#if	defined (FAST_VIDEO)
+	int	retval=0;
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_font() - called\n");
+#endif
+
+#if	defined (FAST_VIDEO)
+	retval = getdosmemword (0x485);
+	if ((retval == 0) && (SP->adapter == _MDS_GENIUS))
+	{
+		retval = _FONT15; /* Assume the MDS Genius is in 66 line mode. */
+	}
+	switch (SP->adapter)
+	{
+	case _MDA:
+			retval = 10; /* POINTS is not certain on MDA/Hercules */
+			break;
+	case _EGACOLOR:
+	case _EGAMONO:
+		switch (retval)
+		{
+		case _FONT8:
+		case _FONT14:
+			break;
+		default:
+			retval = _FONT14;
+		}
+		break;
+
+	case _VGACOLOR:
+	case _VGAMONO:
+		switch (retval)
+		{
+		case _FONT8:
+		case _FONT14:
+		case _FONT16:
+			break;
+		default:
+			break;
+		}
+		break;
+	case _CGA:
+			retval = _FONT8;
+		break;
+	default:
+		break;
+	}
+	return( retval );
+#endif
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_rows()	- Return number of screen rows.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the maximum number of rows supported by the display.
+ 	e.g.  25, 28, 43, 50, 60, 66...
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_rows( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_rows(void)
+#else
+int	PDC_get_rows()
+#endif
+/***********************************************************************/
+{
+	char *env_rows=NULL;
+	int	rows=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_rows() - called\n");
+#endif
+
+/* use the value from LINES environment variable, if set. MH 10-Jun-92 */
+/* and use the minimum of LINES and *ROWS.                MH 18-Jun-92 */
+	rows = getdosmembyte(0x484) + 1;
+	env_rows = (char *)getenv("LINES");
+	if (env_rows != (char *)NULL)
+		rows = min(atoi(env_rows),rows);
+
+	if ((rows == 1) && (SP->adapter == _MDS_GENIUS))
+		rows = 66;
+	if ((rows == 1) && (SP->adapter == _MDA))
+		rows = 25;  /* new test MH 10-Jun-92 */
+	if (rows == 1)
+	{
+		rows = _default_lines;	/* Allow pre-setting LINES	 */
+		SP->direct_video = FALSE;
+	}
+	switch (SP->adapter)
+	{
+	case _EGACOLOR:
+	case _EGAMONO:
+		switch (rows)
+		{
+		case 25:
+		case 43:
+			break;
+		default:
+			rows = 25;
+		}
+		break;
+
+	case _VGACOLOR:
+	case _VGAMONO:
+/* lets be reasonably flexible with VGAs - they could be Super VGAs */
+/* capable of displaying any number of lines. MH 10-Jun-92          */
+/*
+		switch (rows)
+		{
+		case 25:
+		case 28:
+		case 50:
+			break;
+		default:
+			rows = 25;
+		}
+*/
+		break;
+
+	default:
+		rows = 25;
+		break;
+	}
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_rows() - returned: rows %d\n",rows);
+#endif
+
+	return (rows);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_scrn_mode()	- Return the current BIOS video mode
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+
+  PDCurses Return Value:
+ 	Returns the current BIOS Video Mode Number.
+
+  PDCurses Errors:
+ 	The FLEXOS version of this routine returns an ERR.
+ 	The UNIX version of this routine returns an ERR.
+ 	The EMXVIDEO version of this routine returns an ERR.
+
+  Portability:
+ 	PDCurses	int PDC_get_scrn_mode( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_scrn_mode(void)
+#else
+int	PDC_get_scrn_mode()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_scrn_mode() - called\n");
+#endif
+
+	regs.h.ah = 0x0f;
+	int86(0x10, &regs, &regs);
+	return ((int) regs.h.al);
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_query_adapter_type()	- Determine PC video adapter type
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Thanks to Jeff Duntemann, K16RA for providing the impetus
+ 	(through the Dr. Dobbs Journal, March 1989 issue) for getting
+ 	the routines below merged into Bjorn Larsson's PDCurses 1.3...
+ 		-- frotz@dri.com	900730
+
+  PDCurses Return Value:
+ 	This function returns a macro identifier indicating the adapter
+ 	type.  See the list of adapter types in CURSPRIV.H.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_query_adapter_type( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_query_adapter_type(void)
+#else
+int	PDC_query_adapter_type()
+#endif
+/***********************************************************************/
+{
+	int	retval = _NONE;
+
+		/* thanks to paganini@ax.apc.org for the GO32 fix */
+#  if defined(__DJGPP__) && defined(NOW_WORKS)
+#    include <dpmi.h>
+	_go32_dpmi_registers dpmi_regs;
+#  endif
+
+	int	equip;
+#if !defined(__DJGPP__) && !defined(WATCOMC)
+	struct SREGS segs;
+#endif
+	short video_base = getdosmemword (0x463);
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_query_adapter_type() - called\n");
+#endif
+
+	/*
+	 * Attempt to call VGA Identify Adapter Function...
+	 */
+	regs.h.ah = 0x1a;
+	regs.h.al = 0;
+	int86(0x10, &regs, &regs);
+	if ((regs.h.al == 0x1a) && (retval == _NONE))
+	{
+		/*
+		 * We know that the PS/2 video BIOS is alive and well.
+		 */
+		switch (regs.h.al)
+		{
+		case 0:
+			retval = _NONE;
+			break;
+		case 1:
+			retval = _MDA;
+			break;
+		case 2:
+			retval = _CGA;
+			break;
+		case 4:
+			retval = _EGACOLOR;
+			SP->sizeable = TRUE;
+			break;
+		case 5:
+			retval = _EGAMONO;
+			break;
+		case 26:
+			retval = _VGACOLOR;	/* ...alt. VGA BIOS... */
+		case 7:
+			retval = _VGACOLOR;
+			SP->sizeable = TRUE;
+			break;
+		case 8:
+			retval = _VGAMONO;
+			break;
+		case 10:
+		case 13:
+			retval = _MCGACOLOR;
+			break;
+		case 12:
+			retval = _MCGAMONO;
+			break;
+		default:
+			retval = _CGA;
+			break;
+		}
+	}
+	else
+	{
+		/*
+		 * No VGA BIOS, check for an EGA BIOS by selecting an
+		 * Alternate Function Service...
+		 *
+		 * bx == 0x0010	 -->  return EGA information
+		 */
+		regs.h.ah = 0x12;
+# ifdef WATCOMC
+		regs.w.bx = 0x10;
+# else
+		regs.x.bx = 0x10;
+# endif
+		int86(0x10, &regs, &regs);
+		if ((regs.h.bl != 0x10) && (retval == _NONE))
+		{
+			/*
+			 * An EGA BIOS exists...
+			 */
+			regs.h.ah = 0x12;
+			regs.h.bl = 0x10;
+			int86(0x10, &regs, &regs);
+			if (regs.h.bh == 0)
+				retval = _EGACOLOR;
+			else
+				retval = _EGAMONO;
+		}
+		else
+		if (retval == _NONE)
+		{
+			/*
+			 * Now we know we only have CGA or MDA...
+			 */
+			int86(0x11, &regs, &regs);
+			equip = (regs.h.al & 0x30) >> 4;
+			switch (equip)
+			{
+			case 1:
+			case 2:
+				retval = _CGA;
+				break;
+			case 3:
+				retval = _MDA;
+				break;
+			default:
+				retval = _NONE;
+				break;
+			}
+		}
+	}
+	if (video_base == 0x3d4)
+	{
+		SP->video_seg = 0xb800;
+		switch (retval)
+		{
+		case _EGAMONO:
+			retval = _EGACOLOR;
+			break;
+		case _VGAMONO:
+			retval = _VGACOLOR;
+			break;
+		default:
+			break;
+		}
+	}
+	if (video_base == 0x3b4)
+	{
+		SP->video_seg = 0xb000;
+		switch (retval)
+		{
+		case _EGACOLOR:
+			retval = _EGAMONO;
+			break;
+		case _VGACOLOR:
+			retval = _VGAMONO;
+			break;
+		default:
+			break;
+		}
+	}
+	if ((retval == _NONE)
+#ifndef CGA_DIRECT
+	||  (retval == _CGA)
+#endif
+	)
+	{
+		SP->direct_video = FALSE;
+	}
+	if ((unsigned int) SP->video_seg == 0xb000)
+		SP->mono = TRUE;
+	else
+		SP->mono = FALSE;
+
+		/* Check for DESQview shadow buffer */
+		/* thanks to paganini@ax.apc.org for the GO32 fix */
+#if defined(__DJGPP__) && defined(NOW_WORKS)
+	dpmi_regs.h.ah = 0xfe;
+	dpmi_regs.h.al = 0;
+	dpmi_regs.x.di = SP->video_ofs;
+	dpmi_regs.x.es = SP->video_seg;
+	_go32_dpmi_simulate_int(0x10, &dpmi_regs);
+	SP->video_ofs = dpmi_regs.x.di;
+	SP->video_seg = dpmi_regs.x.es;
+#endif
+
+#if !defined(__DJGPP__) && !defined(WATCOMC)
+	regs.h.ah = 0xfe;
+	regs.h.al = 0;
+	regs.x.di = SP->video_ofs;
+	segs.es   = SP->video_seg;
+	int86x(0x10, &regs, &regs, &segs);
+	SP->video_ofs = regs.x.di;
+	SP->video_seg = segs.es;
+#endif
+
+	if  (!SP->adapter)
+		SP->adapter = retval;
+	return (PDC_sanity_check(retval));
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_sanity_check() - A video adapter identification sanity check
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will force sane values for various control flags.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_sanity_check( int adapter );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_sanity_check(int adapter)
+#else
+int	PDC_sanity_check(adapter)
+int adapter;
+#endif
+/***********************************************************************/
+{
+	int	fontsize = PDC_get_font();
+	int	rows	 = PDC_get_rows();
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_sanity_check() - called: Adapter %d\n",adapter);
+#endif
+
+	switch (adapter)
+	{
+	case _EGACOLOR:
+	case _EGAMONO:
+		switch (rows)
+		{
+		case 25:	break;
+		case 43:	break;
+		default:
+			SP->bogus_adapter = TRUE;
+			break;
+		}
+
+		switch (fontsize)
+		{
+		case _FONT8:	break;
+		case _FONT14:	break;
+		default:
+			SP->bogus_adapter = TRUE;
+			break;
+		}
+		break;
+
+	case _VGACOLOR:
+	case _VGAMONO:
+
+/*                                                                  */
+/* lets be reasonably flexible with VGAs - they could be Super VGAs */
+/* capable of displaying any number of lines. MH 10-Jun-92          */
+/* This also applies to font size.            MH 16-Jun-92          */
+/*
+		switch (rows)
+		{
+		case 25:	break;
+		case 43:	break;
+		case 50:	break;
+		default:
+			SP->bogus_adapter = TRUE;
+			break;
+		}
+
+		switch (fontsize)
+		{
+		case _FONT8:	break;
+		case _FONT14:	break;
+		case _FONT16:	break;
+		default:
+			SP->bogus_adapter = TRUE;
+			break;
+		}
+*/
+		break;
+
+	case _CGA:
+	case _MDA:
+	case _MCGACOLOR:
+	case _MCGAMONO:
+		switch (rows)
+		{
+		case 25:	break;
+		default:
+			SP->bogus_adapter = TRUE;
+			break;
+		}
+		break;
+
+	default:
+		SP->bogus_adapter = TRUE;
+		break;
+	}
+	if (SP->bogus_adapter)
+	{
+		SP->sizeable	= FALSE;
+		SP->direct_video	= FALSE;
+	}
+	return (adapter);
+}
+
+
diff -Naur gdb-6.8/pdcurses/dos/pdcgo32.c stsgdb-6.8/pdcurses/dos/pdcgo32.c
--- gdb-6.8/pdcurses/dos/pdcgo32.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcgo32.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,59 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define CURSES_LIBRARY  1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCgo32  = "$Id: pdcgo32.c,v 1.2 2001/01/10 08:28:41 mark Exp $";
+#endif
+
+
+
+#include <pc.h>    
+#include <sys/movedata.h> /* prototypes of dosmemget() and dosmemput() */
+
+unsigned char getdosmembyte (int offset)
+{
+ unsigned char b=0;
+
+  dosmemget (offset, sizeof(unsigned char), &b);
+  return b;
+}
+
+unsigned short getdosmemword (int offset)
+{
+  unsigned short w=0;
+
+  dosmemget (offset, sizeof(unsigned short), &w);
+  return w;
+}
+
+void setdosmembyte (int offset, unsigned char b)
+{
+  dosmemput (&b, sizeof(unsigned char), offset);
+}
+
+void setdosmemword (int offset, unsigned short w)
+{
+  dosmemput (&w, sizeof(unsigned short), offset);
+}
diff -Naur gdb-6.8/pdcurses/dos/pdckbd.c stsgdb-6.8/pdcurses/dos/pdckbd.c
--- gdb-6.8/pdcurses/dos/pdckbd.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdckbd.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,668 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+                          
+#ifdef __DJGPP__
+# include <signal.h>
+#else
+# include <conio.h>
+#endif
+
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+
+#ifdef PDCDEBUG
+char *rcsid_PDCkbd  = "$Id: pdckbd.c,v 1.8 2005/12/11 01:07:18 wmcbrine Exp $";
+#endif
+
+/*******************************************************************************
+*	Table for key code translation of function keys in keypad mode
+*	These values are for strict IBM keyboard compatibles only
+*******************************************************************************/
+
+
+static int kptab[] =
+{
+ /* Normal Function Keys	 */
+ 0x3b, KEY_F(1), 0x3c, KEY_F(2), 0x3d, KEY_F(3), 0x3e, KEY_F(4),
+ 0x3f, KEY_F(5), 0x40, KEY_F(6), 0x41, KEY_F(7), 0x42, KEY_F(8),
+ 0x43, KEY_F(9), 0x44, KEY_F(10),
+
+ /* Normal Keypad		 */
+ 0x47, KEY_HOME, 0x48, KEY_UP,   0x49, KEY_PPAGE,
+ 0x4b, KEY_LEFT, 0x4c, KEY_B2,   0x4d, KEY_RIGHT,
+ 0x4f, KEY_END,  0x50, KEY_DOWN, 0x51, KEY_NPAGE,
+ 0x52, KEY_IC,   0x53, KEY_DC,
+
+ /* Shifted Keypad		 */
+ 0xb0, KEY_SHOME, 0xb1, KEY_SUP,   0xb2, KEY_SPREVIOUS,
+ 0xb3, KEY_SLEFT, 0xb4, KEY_SRIGHT,
+ 0xb5, KEY_SEND,  0xb6, KEY_SDOWN, 0xb7, KEY_SNEXT,
+ 0xb8, KEY_SIC,   0xb9, KEY_SDC,
+
+ /* Shft-Function Keys	 */
+ 0x54, KEY_F(13), 0x55, KEY_F(14), 0x56, KEY_F(15), 0x57, KEY_F(16),
+ 0x58, KEY_F(17), 0x59, KEY_F(18), 0x5a, KEY_F(19), 0x5b, KEY_F(20),
+ 0x5c, KEY_F(21), 0x5d, KEY_F(22),
+
+ /* Ctl-Function Keys	 */
+ 0x5e, KEY_F(25), 0x5f, KEY_F(26), 0x60, KEY_F(27), 0x61, KEY_F(28),
+ 0x62, KEY_F(29), 0x63, KEY_F(30), 0x64, KEY_F(31), 0x65, KEY_F(32),
+ 0x66, KEY_F(33), 0x67, KEY_F(34),
+
+ /* Alt-Function Keys	 */
+ 0x68, KEY_F(37), 0x69, KEY_F(38), 0x6a, KEY_F(39), 0x6b, KEY_F(40),
+ 0x6c, KEY_F(41), 0x6d, KEY_F(42), 0x6e, KEY_F(43), 0x6f, KEY_F(44),
+ 0x70, KEY_F(45), 0x71, KEY_F(46),
+
+ /* Control-Keypad		 */
+ 0x77, CTL_HOME, 0x84, CTL_PGUP,
+ 0x73, CTL_LEFT, 0x74, CTL_RIGHT,
+ 0x75, CTL_END, 0x76, CTL_PGDN,
+
+ /* Alt-Numbers		 */
+ 0x78, ALT_1, 0x79, ALT_2, 0x7a, ALT_3, 0x7b, ALT_4,
+ 0x7c, ALT_5, 0x7d, ALT_6, 0x7e, ALT_7, 0x7f, ALT_8,
+ 0x80, ALT_9, 0x81, ALT_0,
+
+ /* Extended codes		 */
+ 0x85, KEY_F(11), 0x86, KEY_F(12), 0x87, KEY_F(23), 0x88, KEY_F(24),
+ 0x89, KEY_F(35), 0x8a, KEY_F(36), 0x8b, KEY_F(47), 0x8c, KEY_F(48),
+ 0x03, 0, /* NULL */
+
+#if defined(NUMKEYPAD)
+ 0xff, (int)'/',     0x0d, (int)'\n',
+ 0xfa, (int)'*',     0xfd, (int)'-',      0xfb, (int)'+',
+#else
+ 0xff, PADSLASH,     0x0d, PADENTER,      
+ 0xfa, PADSTAR,      0xfd, PADMINUS,      0xfb, PADPLUS,
+#endif
+
+ 0x0a, CTL_PADENTER,
+ 0xa6, ALT_PADENTER, 0x53, (int)'.',      0xfc, CTL_ENTER,
+ 0x93, CTL_DEL,      0x8f, CTL_PADCENTER, 0x90, CTL_PADPLUS,
+ 0x8e, CTL_PADMINUS, 0x95, CTL_PADSLASH,  0x96, CTL_PADSTAR,
+ 0x4e, ALT_PADPLUS,  0x4a, ALT_PADMINUS,  0xa4, ALT_PADSLASH,
+ 0x37, ALT_PADSTAR,  0x92, CTL_INS,       0xa2, ALT_INS,
+ 0xa3, ALT_DEL,      0x8d, CTL_UP,        0x91, CTL_DOWN,
+ 0x94, CTL_TAB,      0xa5, ALT_TAB,       0x82, ALT_MINUS,
+ 0x83, ALT_EQUAL,    0x99, ALT_PGUP,      0xa1, ALT_PGDN,
+ 0x9f, ALT_END,      0x98, ALT_UP,        0xa0, ALT_DOWN,
+ 0x9d, ALT_RIGHT,    0x9b, ALT_LEFT,      0x1c, ALT_ENTER,
+ 0x97, ALT_HOME,     0x01, ALT_ESC,       0x0e, ALT_BKSP,
+ 0x29, ALT_BQUOTE,   0x1a, ALT_LBRACKET,  0x1b, ALT_RBRACKET,
+ 0x27, ALT_SEMICOLON,0x28, ALT_FQUOTE,    0x33, ALT_COMMA,
+ 0x34, ALT_STOP,     0x35, ALT_FSLASH,    0x2b, ALT_BSLASH,
+
+ /* Alt-Alphabet		 */
+ 0x1e, ALT_A, 0x30, ALT_B, 0x2e, ALT_C, 0x20, ALT_D,
+ 0x12, ALT_E, 0x21, ALT_F, 0x22, ALT_G, 0x23, ALT_H,
+ 0x17, ALT_I, 0x24, ALT_J, 0x25, ALT_K, 0x26, ALT_L,
+ 0x32, ALT_M, 0x31, ALT_N, 0x18, ALT_O, 0x19, ALT_P,
+ 0x10, ALT_Q, 0x13, ALT_R, 0x1f, ALT_S, 0x14, ALT_T,
+ 0x16, ALT_U, 0x2f, ALT_V, 0x11, ALT_W, 0x2d, ALT_X,
+ 0x15, ALT_Y, 0x2c, ALT_Z,
+ 0x0f, KEY_BTAB,
+ 0x100, (-1)
+};
+ /* End of kptab[]		 */
+
+static unsigned long pdc_key_modifiers=0L;
+MOUSE_STATUS Trapped_Mouse_status;
+
+/*man-start*********************************************************************
+
+  PDC_get_input_fd()	- Get file descriptor used for PDCurses input
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will return the file descriptor that PDCurses reads
+ 	its input from. It can be used for select().
+
+  PDCurses Return Value:
+ 	Returns a file descriptor.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int	PDC_get_input_fd( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long PDC_get_input_fd(void)
+#else
+unsigned long PDC_get_input_fd()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_input_fd() - called\n");
+#endif
+
+	return (unsigned long)fileno (stdin);
+}
+
+/*man-start*********************************************************************
+
+  PDC_check_bios_key()	- Check BIOS key data area for input
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will check the BIOS for any indication that
+ 	keystrokes are pending.
+
+  PDCurses Return Value:
+ 	Returns 1 if a keyboard character is available, 0 otherwise.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	bool	PDC_check_bios_key( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool PDC_check_bios_key(void)
+#else
+bool PDC_check_bios_key()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_check_bios_key() - called\n");
+#endif
+
+	return(kbhit());
+}         
+
+/*man-start*********************************************************************
+
+  PDC_get_bios_key()	- Returns the next key available from the BIOS.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the next key code struck at the keyboard. If the low 8
+ 	bits are 0, the upper bits contain the extended character
+ 	code. If bit 0-7 are non-zero, the upper bits = 0.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_bios_key( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_bios_key(void)
+#else
+int	PDC_get_bios_key()
+#endif
+/***********************************************************************/
+{
+	int ascii=0,scan=0;
+	static unsigned char keyboard_function=0xFF;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_bios_key() - called\n");
+#endif
+
+	if (keyboard_function == 0xFF)
+		{
+		regs.h.ah = 0x02;             /* get shift status for all keyboards */
+		int86(0x16, &regs, &regs);
+		scan = regs.h.al;
+		regs.h.ah = 0x12;             /* get shift status for enhanced keyboards */
+		int86(0x16, &regs, &regs);
+		if (scan == regs.h.al
+		&&  getdosmembyte(0x496) == 0x10)
+			keyboard_function = 0x10;
+		else
+			keyboard_function = 0x0;
+		}
+	regs.h.ah = keyboard_function;
+	int86(0x16, &regs, &regs);
+	ascii = regs.h.al;
+	scan = regs.h.ah;
+	pdc_key_modifiers = 0;
+	if (SP->save_key_modifiers)
+		{
+		regs.h.ah = 0x02;             /* get shift status for all keyboards */
+		int86(0x16, &regs, &regs);
+		if (regs.h.al & 0x01
+		||  regs.h.al & 0x02)
+			pdc_key_modifiers |= PDC_KEY_MODIFIER_SHIFT;
+		if (regs.h.al & 0x04)
+			pdc_key_modifiers |= PDC_KEY_MODIFIER_CONTROL;
+		if (regs.h.al & 0x08)
+			pdc_key_modifiers |= PDC_KEY_MODIFIER_ALT;
+		if (regs.h.al & 0x20)
+			pdc_key_modifiers |= PDC_KEY_MODIFIER_NUMLOCK;
+		}
+
+	if (scan == 0x1c && ascii == 0x0a)  /* ^Enter */
+		return ((int) (0xfc00));
+	if ((scan == 0x03 && ascii == 0x00)  /* ^@ - Null */
+	||  (scan == 0xe0 && ascii == 0x0d)  /* PadEnter */
+	||  (scan == 0xe0 && ascii == 0x0a)) /* ^PadEnter */
+		return ((int) (ascii << 8));
+	if ((scan == 0x37 && ascii == 0x2a)  /* Star */
+	||  (scan == 0x4a && ascii == 0x2d)  /* Minus */
+	||  (scan == 0x4e && ascii == 0x2b)  /* Plus */
+	||  (scan == 0xe0 && ascii == 0x2f)) /* Slash */
+		return ((int) ((ascii & 0x0f) | 0xf0) << 8);
+	if (ascii == 0xe0 && scan == 0x47 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Home */
+		return ((int) (0xb0 << 8));
+	if (ascii == 0xe0 && scan == 0x48 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Up */
+		return ((int) (0xb1 << 8));
+	if (ascii == 0xe0 && scan == 0x49 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift PgUp */
+		return ((int) (0xb2 << 8));
+	if (ascii == 0xe0 && scan == 0x4b && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Left */
+		return ((int) (0xb3 << 8));
+	if (ascii == 0xe0 && scan == 0x4d && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Right */
+		return ((int) (0xb4 << 8));
+	if (ascii == 0xe0 && scan == 0x4f && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift End */
+		return ((int) (0xb5 << 8));
+	if (ascii == 0xe0 && scan == 0x50 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Down */
+		return ((int) (0xb6 << 8));
+	if (ascii == 0xe0 && scan == 0x51 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift PgDn */
+		return ((int) (0xb7 << 8));
+	if (ascii == 0xe0 && scan == 0x52 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Ins */
+		return ((int) (0xb8 << 8));
+	if (ascii == 0xe0 && scan == 0x53 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Del */
+		return ((int) (0xb9 << 8));
+	if (ascii == 0x00 || (ascii == 0xe0 && scan > 53 && scan != 86)) /* some NLS use 0xe0 as real character - Ruslan Fedyarov */
+		return ((int) (scan << 8));
+	return ((int) (ascii));
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_ctrl_break()	- return OS control break state
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the current OS Control Break Check state.
+
+  PDCurses Return Value:
+ 	DOS:
+ 		This function returns TRUE on if the Control Break
+ 		Check is enabled otherwise FALSE is returned.
+
+ 	FLEXOS:
+ 		This function returns TRUE on if the Keyboard Mode
+ 		allows a break to bre reported otherwise FALSE is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	bool	PDC_get_ctrl_break( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_get_ctrl_break(void)
+#else
+bool	PDC_get_ctrl_break()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_ctrl_break() - called\n");
+#endif
+
+	regs.h.ah = 0x33;
+	regs.h.al = 0x00;
+	int86(0x21, &regs, &regs);
+	return ((bool) regs.h.dl);
+}
+
+/*man-start*********************************************************************
+
+  PDC_rawgetch()	- Returns the next uninterpreted character (if available).
+
+  PDCurses Description:
+ 	Gets a character without any interpretation at all and returns
+ 	it. If keypad mode is active for the designated window,
+ 	function key translation will be performed.  Otherwise,
+ 	function keys are ignored.  If nodelay mode is active in the
+ 	window, then PDC_rawgetch() returns -1 if no character is
+ 	available.
+
+ 	WARNING:  It is unknown whether the FUNCTION key translation
+ 		  is performed at this level. --Frotz 911130 BUG
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int	PDC_rawgetch( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_rawgetch(void)
+#else
+int	PDC_rawgetch()
+#endif
+/***********************************************************************/
+{
+extern	WINDOW*	_getch_win_;
+/* extern	WINDOW*	w;*/   /* w defined in wgetch() as static - _getch_win_ */
+                        /* is the same window - all references to w changed*/
+                        /* to _getch_win_ - marked with @@ */
+
+	int	c=0;
+	int	oldc=0;
+	bool	return_immediately;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_rawgetch() - called\n");
+#endif
+
+	if (_getch_win_ == (WINDOW *)NULL)   /* @@ */
+		return( -1 );
+
+	if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+		return_immediately = TRUE;
+	else
+	return_immediately = FALSE;
+
+	if (return_immediately && !PDC_breakout())
+		return( -1 );
+
+	while (1)		/* loop to get valid char */
+	{
+		c = PDC_get_bios_key();
+		oldc = c;
+		/*
+		 * Return the key if it is not a special key.
+		 */
+		if ((c = PDC_validchar(c)) >= 0)
+		{		/* get & check next char */
+			return( c );
+		}
+		if (_getch_win_->_use_keypad)
+			return( oldc );
+	}
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_ctrl_break()	- Enables/Disables the host OS BREAK key check.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Enables/Disables the host OS BREAK key check. If the supplied setting
+ 	is TRUE, this enables CTRL/C and CTRL/BREAK to abort the process.
+ 	If FALSE, CTRL/C and CTRL/BREAK are ignored.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_ctrl_break( bool setting );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_ctrl_break(bool setting)
+#else
+int	PDC_set_ctrl_break(setting)
+bool setting;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_ctrl_break() - called\n");
+#endif
+
+#ifdef	NDP
+	if( setting )
+		_ignore_breaks();
+	else
+		_watch_breaks();
+#else
+# ifdef __DJGPP__
+	(void*)signal(SIGINT,(setting ? SIG_DFL : SIG_IGN));
+/*	__djgpp_set_ctrl_c(setting);*/
+	setcbrk(setting);
+# else
+	regs.h.ah = 0x33;
+	regs.h.al = 0x00;
+	regs.h.dl = (unsigned char) (setting ? 1 : 0);
+	int86(0x21, &regs, &regs);
+# endif
+#endif
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_sysgetch()	- Return a character using default system routines.
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Gets a character without normal ^S, ^Q, ^P and ^C interpretation
+ 	and returns it.  If keypad mode is active for the designated
+ 	window, function key translation will be performed. Otherwise,
+ 	function keys are ignored. If nodelay mode is active in the
+ 	window, then sysgetch() returns -1 if no character is
+ 	available.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_sysgetch( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_sysgetch(void)
+#else
+int	PDC_sysgetch()
+#endif
+/***********************************************************************/
+{
+extern	WINDOW*	_getch_win_;
+/* extern	WINDOW*	w;*/   /* w defined in wgetch() as static - _getch_win_ */
+                        /* is the same window - all references to w changed*/
+                        /* to _getch_win_ - marked with @@ */
+
+	int c=0;
+	bool	return_immediately;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_sysgetch() - called\n");
+#endif
+
+	if (_getch_win_ == (WINDOW *)NULL)  /* @@ */
+		return (-1);
+
+	if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+		return_immediately = TRUE;
+	else
+	return_immediately = FALSE;
+
+	if (return_immediately && !PDC_breakout())
+		return (-1);
+
+	while (1)
+	{
+		c = PDC_get_bios_key();
+		/*
+		 * Return the key if it is not a special key.
+		 */
+		if ((unsigned int)c < 256)
+			return(c);
+		if ((c = PDC_validchar(c)) >= 0)
+			return (c);		/* get & check next char */
+	}
+}
+
+/*man-start*********************************************************************
+
+  PDC_validchar()	- validate/translate passed character
+  
+  PDCurses Description:
+  	This is a private PDCurses function.
+  
+  	Checks that 'c' is a valid character, and if so returns it,
+  	with function key translation applied if 'w' has keypad mode
+  	set.  If char is invalid, returns -1.
+  
+  PDCurses Return Value:
+  	This function returns -1 if the passed character is invalid, or
+  	the WINDOW* 'w' is NULL, or 'w's keypad is not active.
+  
+  	This function returns 0 under Flexos if the passed character
+  	is 0x0300.  (-:Forget why.  --Frotz	911130:-)
+  
+  	Otherwise, this function returns the PDCurses equivalent of the
+  	passed character.  See the function key and key macros in
+  	<curses.h>
+  
+  PDCurses Errors:
+  	There are no errors defined for this routine.
+  
+  Portability:
+  	PDCurses	int	PDC_validchar( int c );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_validchar(int c)
+#else
+int	PDC_validchar(c)
+int c;
+#endif
+/***********************************************************************/
+{
+extern	WINDOW*	_getch_win_;
+/* extern	WINDOW*	w;*/   /* w defined in wgetch() as static - _getch_win_ */
+                        /* is the same window - all references to w changed*/
+                        /* to _getch_win_ - marked with @@ */
+
+	int *scanp=NULL;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_validchar() - called\n");
+#endif
+
+	if (_getch_win_ == (WINDOW *)NULL)
+		return (-1);	/* bad window pointer	  */
+
+	if ((unsigned int)c < 256)	return (c);  /* normal character */
+	if (!(_getch_win_->_use_keypad))	return (-1); /* skip if keys if !keypad mode */
+
+	/*
+	* Under DOS, extended keys are in the upper byte.  Shift down for a
+	* comparison.
+	*/
+	c = (c >> 8) & 0xFF;
+
+	scanp = kptab;
+	while (*scanp > 0)	/* search for value		 */
+	{			/* (stops on table entry 0x100) */
+		if (*scanp++ == c)
+		{
+			return (*scanp);	/* found, return it */
+		}
+		scanp++;
+	}
+	return( -1 );		/* not found, invalid */
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_key_modifiers()	- Returns the keyboard modifier(s) at time of last getch()
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the keyboard modifiers effective at the time of the last getch()
+ 	call only if PDC_save_key_modifiers(TRUE) has been called before the
+ 	getch();
+ 	Use the macros; PDC_KEY_MODIFIER_* to determine which modifier(s)
+ 	were set.
+
+  PDCurses Return Value:
+ 	This function returns the modifiers.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_key_modifiers( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long	PDC_get_key_modifiers(void)
+#else
+unsigned long	PDC_get_key_modifiers()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_key_modifiers() - called\n");
+#endif
+	return(pdc_key_modifiers);
+}
+
+
diff -Naur gdb-6.8/pdcurses/dos/pdcprint.c stsgdb-6.8/pdcurses/dos/pdcprint.c
--- gdb-6.8/pdcurses/dos/pdcprint.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcprint.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCprint  = "$Id: pdcprint.c,v 1.2 2001/01/10 08:28:45 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_print()	- Provides primitive access to the BIOS printer functions
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Implements write/init/read printer services at the BIOS level.
+
+ 	This provides the basic support that PDCurses needs to dump the
+ 	contents of windows or pads to the printer attached to the BIOS
+ 	printer port.
+
+  PDCurses Return Value:
+ 	See the BIOS INT 0x17 specifications.
+
+  PDCurses Errors:
+ 	See the BIOS INT 0x17 specifications.
+
+  Portability:
+ 	PDCurses	int PDC_print( int cmd, int byte, int port );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_print(int cmd, int byte, int port)
+#else
+int	PDC_print(cmd,byte,port)
+int cmd;
+int byte;
+int port;
+#endif
+/***********************************************************************/
+{
+	int	status = 0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_print() - called\n");
+#endif
+
+	regs.h.ah = (unsigned char)cmd;
+	regs.h.al = (unsigned char)byte;
+# ifdef WATCOMC
+	regs.w.dx = (unsigned int)port;
+# else
+	regs.x.dx = (unsigned int)port;
+# endif
+	int86(0x17, &regs, &regs);
+	status = regs.h.ah;
+	return (status);
+
+}
diff -Naur gdb-6.8/pdcurses/dos/pdcscrn.c stsgdb-6.8/pdcurses/dos/pdcscrn.c
--- gdb-6.8/pdcurses/dos/pdcscrn.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcscrn.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,341 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+#ifdef __DJGPP__
+# include <sys/movedata.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCscrn  = "$Id: pdcscrn.c,v 1.7 2005/12/15 00:56:49 wmcbrine Exp $";
+#endif
+
+	static unsigned short *saved_screen = NULL;
+	static int saved_lines = 0;
+	static int saved_cols = 0;
+
+/*man-start*********************************************************************
+
+  PDC_scr_close()	- Internal low-level binding to close the physical screen
+
+  PDCurses Description:
+ 	This function provides a low-level binding for the Flexos
+ 	platform which must close the screen before writing to it.
+ 	This is a nop for the DOS platform.
+
+ 	This function is provided in order to reset the FlexOS 16 bit
+ 	character set for input rather than the limited input
+ 	character set associated with the VT52.
+
+  PDCurses Return Value:
+ 	This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+ 	The DOS platform will never fail.  The Flexos platform may fail
+ 	depending on the ability to close the current virtual console in
+ 	8 (as opposed to 16) bit mode.
+
+  Portability:
+ 	PDCurses	int	PDC_scr_close( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_scr_close(void)
+#else
+int	PDC_scr_close()
+#endif
+/***********************************************************************/
+{
+#if SMALL || MEDIUM
+# if !PC
+struct SREGS segregs;
+# endif
+int ds=0;
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scr_close() - called\n");
+#endif
+	if (getenv("PDC_RESTORE_SCREEN") != NULL)
+	{
+		if (saved_screen == NULL)
+			return( OK );
+#ifdef __DJGPP__
+		dosmemput(saved_screen,
+			saved_lines * saved_cols * sizeof(unsigned short),
+		(unsigned long)_FAR_POINTER(SP->video_seg,SP->video_ofs));
+#else
+#  if	(SMALL || MEDIUM)
+#    if PC
+		ds = FP_SEG((void far *) saved_screen);
+#    else
+	segread(&segregs);
+	ds = segregs.ds;
+#    endif
+	movedata(ds, (int)saved_screen,
+		SP->video_seg,SP->video_ofs,
+		(saved_lines * saved_cols * sizeof(unsigned short)));
+#  else
+	memcpy((void *)_FAR_POINTER(SP->video_seg,SP->video_ofs),
+		(void*)saved_screen,
+		(saved_lines * saved_cols * sizeof(unsigned short)));
+#  endif
+#endif
+		free(saved_screen);
+		saved_screen = NULL;
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_scrn_modes_equal()	- Decide if two screen modes are equal
+
+  PDCurses Description:
+ 	Mainly required for OS/2. It decides if two screen modes
+        (VIOMODEINFO structure) are equal. Under DOS it just compares
+        two integers
+
+  PDCurses Return Value:
+ 	This function returns TRUE if equal else FALSe.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_scrn_modes_equal( int mode1, int mode2 );
+ 	OS2 PDCurses	int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_scrn_modes_equal(int mode1, int mode2)
+#else
+bool	PDC_scrn_modes_equal(mode1,mode2)
+int mode1;
+int mode2;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scrn_modes_equal() - called\n");
+#endif
+
+	return (mode1 == mode2);
+}
+
+/*man-start*********************************************************************
+
+  PDC_scr_open()	- Internal low-level binding to open the physical screen
+
+  PDCurses Description:
+ 	This function provides a low-level binding for the Flexos
+ 	platform which must open the screen before writing to it.
+
+ 	This function is provided in order to access the FlexOS 16 bit
+ 	character set for input rather than the limited input
+ 	character set associated with the VT52.
+
+  PDCurses Return Value:
+ 	This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+ 	The DOS platform will never fail.  The Flexos platform may fail
+ 	depending on the ability to open the current virtual console in
+ 	8 (as opposed to 16) bit mode.
+
+  Portability:
+ 	PDCurses	int	PDC_scr_open( SCREEN* internal, bool echo );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_scr_open(SCREEN *internal, bool echo)
+#else
+int	PDC_scr_open(internal,echo)
+SCREEN *internal;
+bool echo;
+#endif
+/***********************************************************************/
+{
+#if SMALL || MEDIUM
+# if !PC
+struct SREGS segregs;
+# endif
+int ds=0;
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scr_open() - called\n");
+#endif
+
+	internal->orig_attr	 = 0;
+	internal->orig_emulation = getdosmembyte (0x487);
+
+	PDC_get_cursor_pos(&internal->cursrow, &internal->curscol);
+	internal->direct_video	= TRUE;		/* Assume that we can	      */
+	internal->autocr	= TRUE;		/* lf -> crlf by default      */
+	internal->raw_out	= FALSE;	/* tty I/O modes	      */
+	internal->raw_inp	= FALSE;	/* tty I/O modes	      */
+	internal->cbreak	= TRUE;
+	internal->save_key_modifiers	= FALSE;
+	internal->return_key_modifiers	= FALSE;
+	internal->echo		= echo;
+	internal->refrbrk	= FALSE;	/* no premature end of refresh*/
+	internal->video_seg	= 0xb000;	/* Base screen segment addr   */
+	internal->video_ofs	= 0x0;		/* Base screen segment ofs    */
+	internal->video_page	= 0;		/* Current Video Page	      */
+	internal->visible_cursor= TRUE;		/* Assume that it is visible  */
+	internal->cursor	= PDC_get_cursor_mode();
+
+	internal->adapter	= PDC_query_adapter_type();
+	internal->scrnmode	= PDC_get_scrn_mode();
+
+	internal->orig_font = internal->font	= PDC_get_font();
+	internal->lines		= PDC_get_rows();
+	internal->cols		= PDC_get_columns();
+
+	internal->audible	= TRUE;
+	internal->visibility	= 1;
+	internal->orig_cursor = internal->cursor;
+	internal->orgcbr = PDC_get_ctrl_break();
+	internal->blank = ' ';
+	internal->resized = FALSE;
+	internal->shell = FALSE;
+	internal->_trap_mbe = 0L;
+	internal->_map_mbe_to_key = 0L;
+	internal->linesrippedoff = 0;
+	internal->linesrippedoffontop = 0;
+	internal->delaytenths = 0;
+/*
+ * If the environment variable PDCURSES_BIOS is set, the DOS int10()
+ * BIOS calls are used in place of direct video memory access.
+ */
+	if (getenv("PDCURSES_BIOS") != NULL)
+		internal->direct_video = FALSE;
+/*
+ * This code for preserving the current screen...
+ */
+	if (getenv("PDC_RESTORE_SCREEN") != NULL)
+	{
+		saved_lines = internal->lines;
+		saved_cols = internal->cols;
+		if ((saved_screen = (unsigned short*)malloc(saved_lines*saved_cols*sizeof(unsigned short))) == NULL)
+			return(ERR);
+
+#ifdef __DJGPP__
+		dosmemget ((unsigned long)_FAR_POINTER(SP->video_seg,SP->video_ofs),
+			saved_lines * saved_cols * sizeof(unsigned short),saved_screen);
+#else
+#  if	(SMALL || MEDIUM)
+#    if PC
+		ds = FP_SEG((void far *) saved_screen);
+#    else
+	segread(&segregs);
+	ds = segregs.ds;
+#    endif
+	movedata(SP->video_seg,SP->video_ofs,
+		ds, (int)saved_screen,
+		(saved_lines * saved_cols * sizeof(unsigned short)));
+#  else
+	memcpy((void*)saved_screen,
+		(void *)_FAR_POINTER(SP->video_seg,SP->video_ofs),
+		(saved_lines * saved_cols * sizeof(unsigned short)));
+#  endif
+#endif
+	}
+
+	if (getenv("PDC_PRESERVE_SCREEN") != NULL)
+		internal->_preserve = TRUE;
+	else
+		internal->_preserve = FALSE;
+
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_resize_screen()	- Internal low-level function to resize screen
+
+  PDCurses Description:
+ 	This function provides a means for the application program to
+ 	resize the overall dimensions of the screen.  Under DOS and OS/2
+ 	the application can tell PDCurses what size to make the screen;
+ 	under X11, resizing is done by the user and this function simply
+ 	adjusts its internal structures to fit the new size.
+
+  PDCurses Return Value:
+ 	This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+
+  Portability:
+ 	PDCurses	int	PDC_resize_screen( int, int );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_resize_screen(int nlines, int ncols)
+#else
+int	PDC_resize_screen(nlines, ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+	int rc=OK;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+
+	switch (SP->adapter)
+	{
+	case _EGACOLOR:
+		if (nlines >= 43)		PDC_set_font(_FONT8);
+		else				PDC_set_80x25();
+		break;
+
+	case _VGACOLOR:
+		if	(nlines > 28)		PDC_set_font(_FONT8);
+		else	if (nlines > 25)	PDC_set_font(_FONT14);
+		else				PDC_set_80x25();
+		break;
+
+	default:
+		break;
+	}
+
+	return ( rc );
+}
+
+
diff -Naur gdb-6.8/pdcurses/dos/pdcsetsc.c stsgdb-6.8/pdcurses/dos/pdcsetsc.c
--- gdb-6.8/pdcurses/dos/pdcsetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/pdcsetsc.c	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,461 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCsetsc  = "$Id: pdcsetsc.c,v 1.3 2003/12/28 08:38:16 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_set_80x25()	- force a known screen state: 80x25 text mode.
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Forces the appropriate 80x25 alpha mode given the display adapter.
+
+ 	Since we currently do not support changing the virtual console size,
+ 	this routine is a NOP under Flexos.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_set_80x25( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_80x25(void)
+#else
+int	PDC_set_80x25()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_80x25() - called\n");
+#endif
+
+	switch (SP->adapter)
+	{
+	case _CGA:
+	case _EGACOLOR:
+	case _EGAMONO:
+	case _VGACOLOR:
+	case _VGAMONO:
+	case _MCGACOLOR:
+	case _MCGAMONO:
+		regs.h.ah = 0x00;
+		regs.h.al = 0x03;
+		int86(0x10, &regs, &regs);
+		break;
+	case _MDA:
+		regs.h.ah = 0x00;
+		regs.h.al = 0x07;
+		int86(0x10, &regs, &regs);
+	default:
+		break;
+	}
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_cursor_mode()	- Set the cursor start and stop scan lines.
+
+  PDCurses Description:
+ 	Sets the cursor type to begin in scan line startrow and end in
+ 	scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_cursor_mode( int startrow, int endrow );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_cursor_mode( int startrow, int endrow )
+#else
+int	PDC_set_cursor_mode(startrow,endrow)
+int startrow;
+int endrow;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_cursor_mode() - called: startrow %d endrow %d\n",startrow,endrow);
+#endif
+
+	regs.h.ah = 0x01;
+	regs.h.ch = (unsigned char) startrow;
+	regs.h.cl = (unsigned char) endrow;
+	int86(0x10, &regs, &regs);
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_font()	- sets the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine sets the current font size, if the adapter allows
+ 	such a change.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the font size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_font( int size );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_font(int size)
+#else
+int	PDC_set_font(size)
+int size;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_font() - called\n");
+#endif
+
+	if (SP->bogus_adapter)
+		return( ERR );
+
+	switch (SP->adapter)
+	{
+	case _CGA:
+	case _MDA:
+	case _MCGACOLOR:
+	case _MCGAMONO:
+	case _MDS_GENIUS:
+		break;
+
+	case _EGACOLOR:
+	case _EGAMONO:
+		if (SP->sizeable && (SP->font != size))
+		{
+			switch (size)
+			{
+			case _FONT8:
+				regs.h.ah = 0x11;
+				regs.h.al = 0x12;
+				regs.h.bl = 0x00;
+				int86(0x10, &regs, &regs);
+				break;
+			case _FONT14:
+				regs.h.ah = 0x11;
+				regs.h.al = 0x11;
+				regs.h.bl = 0x00;
+				int86(0x10, &regs, &regs);
+				break;
+			default:
+				break;
+			}
+		}
+		break;
+
+	case _VGACOLOR:
+	case _VGAMONO:
+		if (SP->sizeable && (SP->font != size))
+		{
+			switch (size)
+			{
+			case _FONT8:
+				regs.h.ah = 0x11;
+				regs.h.al = 0x12;
+				regs.h.bl = 0x00;
+				int86(0x10, &regs, &regs);
+				break;
+			case _FONT14:
+				regs.h.ah = 0x11;
+				regs.h.al = 0x11;
+				regs.h.bl = 0x00;
+				int86(0x10, &regs, &regs);
+				break;
+			case _FONT16:
+				regs.h.ah = 0x11;
+				regs.h.al = 0x14;
+				regs.h.bl = 0x00;
+				int86(0x10, &regs, &regs);
+				break;
+			default:
+				break;
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	if (SP->visible_cursor)
+		PDC_cursor_on();
+	else
+		PDC_cursor_off();
+	SP->font = PDC_get_font();
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_rows()	- sets the physical number of rows on screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine attempts to set the number of rows on the physical
+ 	screen to the passed value.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the screen size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_rows( int rows );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_rows(int rows)
+#else
+int	PDC_set_rows(rows)
+int rows;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_rows() - called\n");
+#endif
+
+	if (SP->bogus_adapter)
+		return( ERR );
+
+	switch (SP->adapter)
+	{
+	case _EGACOLOR:
+	case _EGAMONO:
+		if (rows < 43)
+			PDC_set_font(_FONT14);
+		else
+			PDC_set_font(_FONT8);
+		break;
+
+	case _VGACOLOR:
+	case _VGAMONO:
+		if (rows < 28)
+			PDC_set_font(_FONT16);
+		else
+		if (rows < 50)
+			PDC_set_font(_FONT14);
+		else
+			PDC_set_font(_FONT8);
+		break;
+
+	case _MCGACOLOR:
+	case _MCGAMONO:
+	case _MDA:
+	case _CGA:
+	case _MDS_GENIUS:
+	default:
+		break;
+	}
+	SP->font = PDC_get_font();
+	LINES = PDC_get_rows();
+	COLS = PDC_get_columns();
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_scrn_mode()	- Set BIOS Video Mode
+
+  PDCurses Description:
+ 	Sets the BIOS Video Mode Number ONLY if it is different from
+ 	the current video mode.  This routine is for DOS systems only.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_scrn_mode( int new_mode );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_scrn_mode(int new_mode)
+#else
+int	PDC_set_scrn_mode(new_mode)
+int new_mode;
+#endif
+/***********************************************************************/
+{
+
+	int	cur=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_scrn_mode() - called\n");
+#endif
+
+	cur = (int) PDC_get_scrn_mode();
+	if (cur != new_mode)
+	{
+		regs.h.ah = 0x00;
+		regs.h.al = (char) new_mode;
+		int86(0x10, &regs, &regs);
+	}
+	SP->font = PDC_get_font();
+	SP->scrnmode = new_mode;
+	LINES = PDC_get_rows();
+	COLS = PDC_get_columns();
+	return( OK );
+
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_curs_set(int visibility)
+#else
+int	PDC_curs_set(visibility)
+int visibility;
+#endif
+/***********************************************************************/
+{
+ int start=6,end=7;
+ int ret_vis=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+	ret_vis = SP->visibility;
+	SP->visibility = visibility;
+
+	switch(visibility)
+	{
+		case 0:  /* invisible */
+			start = 32;
+			end = 0;  /* was 32 */
+			break;
+		case 2:  /* highly visible */
+#if 0
+			start = 2;   /* almost full-height block */
+			end = SP->font-1;
+#else
+			start = 0;   /* full-height block */
+#endif
+			break;
+		default:  /* normal visibility */
+/* start = 6, end = 7 */
+#if 0
+			start = SP->font - 2;
+			end = SP->font-1;
+#endif
+			break;
+	}
+
+	regs.h.ah = 0x01;
+	regs.h.al = (unsigned char)SP->scrnmode;  /* if not set, some BIOSes hang */
+	regs.h.ch = (unsigned char)start;
+	regs.h.cl = (unsigned char)end;
+	int86(0x10, &regs, &regs);
+	return( ret_vis );
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_title()	- Set window title
+
+  PDCurses Description:
+ 	Sets the title of the window in which the curses program is running.
+ 	This function may not do anything on some platforms.
+
+  PDCurses Return Value:
+ 	N/A
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	void PDC_set_title( char *title );
+
+**man-end**********************************************************************/
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_set_title(char *title)
+#else
+void	PDC_set_title(title)
+char *title;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_title() - called:<%s>\n",title);
+#endif
+
+	return;
+}
diff -Naur gdb-6.8/pdcurses/dos/README stsgdb-6.8/pdcurses/dos/README
--- gdb-6.8/pdcurses/dos/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/README	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,21 @@
+
+                        Welcome to PDCurses
+
+ Contents
+ --------
+ This directory contains core PDCurses source code files specific to
+ the DOS platform.
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory are released to the Public Domain.
+
+
+ Acknowlegements
+ ---------------
+
+ Watcom C port was provided by Pieter Kunst (kunst@prl.philips.nl)
+ DJGPP 1.x port was provided by David Nugent (davidn@csource.oz.au)
+ Microway NDP port was provided by ????
diff -Naur gdb-6.8/pdcurses/dos/wccdos16.mak stsgdb-6.8/pdcurses/dos/wccdos16.mak
--- gdb-6.8/pdcurses/dos/wccdos16.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/wccdos16.mak	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,393 @@
+################################################################################
+#
+# Watcom WMAKE Makefile for PDCurses library - DOS (16 bit) Watcom C/C++ 10.6+
+#
+# Usage: wmake -f [path\]wccdos16.mak [DEBUG=Y] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, and/or edit the 
+# lines below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(%PDCURSES_SRCDIR)
+MODEL		=l
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\dos
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= wcc
+TARGET=dos
+
+!ifeq DEBUG Y
+CFLAGS  = /d2 /DPDCDEBUG
+LDFLAGS = DEBUG WATCOM ALL
+!else
+CFLAGS  = /oneatx
+LDFLAGS =
+!endif
+
+CPPFLAGS	= /i=$(PDCURSES_HOME)
+
+CCFLAGS		= /bt=$(TARGET) /zq /m$(MODEL) $(CFLAGS) $(CPPFLAGS)
+
+LINK		= wlink
+
+LIBEXE		= wlib /q /n
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean
+	-del *.obj
+	-del *.lib
+	-del *.exe
+	-del *.err
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =    &
+addch.obj    &
+addchstr.obj &
+addstr.obj   &
+attr.obj     &
+beep.obj     &
+bkgd.obj     &
+border.obj   &
+clear.obj    &
+color.obj    &
+delch.obj    &
+deleteln.obj &
+getch.obj    &
+getstr.obj   &
+getyx.obj    &
+inch.obj     &
+inchstr.obj  &
+initscr.obj  &
+inopts.obj   &
+insch.obj    &
+insstr.obj   &
+instr.obj    &
+kernel.obj   &
+mouse.obj    &
+move.obj     &
+outopts.obj  &
+overlay.obj  &
+pad.obj      &
+printw.obj   &
+refresh.obj  &
+scanw.obj    &
+scr_dump.obj &
+scroll.obj   &
+slk.obj      &
+termattr.obj &
+terminfo.obj &
+touch.obj    &
+util.obj     &
+window.obj
+
+PDCOBJS =      &
+pdcclip.obj    &
+pdcdebug.obj   &
+pdcdisp.obj    &
+pdcgetsc.obj   &
+pdckbd.obj     &
+pdcprint.obj   &
+pdcscrn.obj    &
+pdcsetsc.obj   &
+pdcutil.obj    &
+pdcwin.obj
+
+PANOBJS =     &
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\wccdos.lrf
+
+panel.lib : $(PANOBJS)
+	@%create lib.rsp
+	@%append lib.rsp +$(PANOBJS)
+	$(LIBEXE) $@ @lib.rsp
+	del lib.rsp
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name firework.exe
+	@%append demos.lnk file firework.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name newdemo.exe
+	@%append demos.lnk file newdemo.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name ptest.exe
+	@%append demos.lnk file ptest.obj
+	@%append demos.lnk library $(LIBCURSES)
+	@%append demos.lnk library $(LIBPANEL)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name testcurs.exe
+	@%append demos.lnk file testcurs.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name tuidemo.exe
+	@%append demos.lnk file tuidemo.obj
+	@%append demos.lnk file tui.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name xmas.exe
+	@%append demos.lnk file xmas.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Watcom C++ 16bit DOS > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Open Watcom 1.3 for 16 bit DOS. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_HOME)\README > flist
+	echo $(PDCURSES_HOME)\readme.$(VER) >> flist
+	echo $(PDCURSES_HOME)\maintain.er >> flist
+	echo $(PDCURSES_HOME)\curses.h >> flist
+	echo $(PDCURSES_HOME)\curspriv.h >> flist
+	echo $(PDCURSES_HOME)\panel.h >> flist
+	echo $(PDCURSES_HOME)\term.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo $(LIBPANEL) >> flist
+	echo file_id.diz >> flist
+	zip -jX pdc$(VER)16w -@ <flist
+	del flist
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/dos/wccdos4g.mak stsgdb-6.8/pdcurses/dos/wccdos4g.mak
--- gdb-6.8/pdcurses/dos/wccdos4g.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/wccdos4g.mak	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,392 @@
+################################################################################
+#
+# Watcom WMAKE Makefile for PDCurses library - DOS/4GW Watcom C/C++ 10.6+
+#
+# Usage: wmake -f [path\]wccdos4g.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(%PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\dos
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= wcc386
+TARGET=dos4g
+
+!ifeq DEBUG Y
+CFLAGS  = /d2 /DPDCDEBUG
+LDFLAGS = DEBUG WATCOM ALL
+!else
+CFLAGS  = /oneatx
+LDFLAGS =
+!endif
+
+CPPFLAGS	= /i=$(PDCURSES_HOME)
+
+CCFLAGS		= /bt=$(TARGET) /zq /mf $(CFLAGS) $(CPPFLAGS)
+
+LINK		= wlink
+
+LIBEXE		= wlib /q /n
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean
+	-del *.obj
+	-del *.lib
+	-del *.exe
+	-del *.err
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =    &
+addch.obj    &
+addchstr.obj &
+addstr.obj   &
+attr.obj     &
+beep.obj     &
+bkgd.obj     &
+border.obj   &
+clear.obj    &
+color.obj    &
+delch.obj    &
+deleteln.obj &
+getch.obj    &
+getstr.obj   &
+getyx.obj    &
+inch.obj     &
+inchstr.obj  &
+initscr.obj  &
+inopts.obj   &
+insch.obj    &
+insstr.obj   &
+instr.obj    &
+kernel.obj   &
+mouse.obj    &
+move.obj     &
+outopts.obj  &
+overlay.obj  &
+pad.obj      &
+printw.obj   &
+refresh.obj  &
+scanw.obj    &
+scr_dump.obj &
+scroll.obj   &
+slk.obj      &
+termattr.obj &
+terminfo.obj &
+touch.obj    &
+util.obj     &
+window.obj
+
+PDCOBJS =      &
+pdcclip.obj    &
+pdcdebug.obj   &
+pdcdisp.obj    &
+pdcgetsc.obj   &
+pdckbd.obj     &
+pdcprint.obj   &
+pdcscrn.obj    &
+pdcsetsc.obj   &
+pdcutil.obj    &
+pdcwin.obj
+
+PANOBJS =     &
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\wccdos.lrf
+
+panel.lib : $(PANOBJS)
+	@%create lib.rsp
+	@%append lib.rsp +$(PANOBJS)
+	$(LIBEXE) $@ @lib.rsp
+	del lib.rsp
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name firework.exe
+	@%append demos.lnk file firework.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name newdemo.exe
+	@%append demos.lnk file newdemo.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name ptest.exe
+	@%append demos.lnk file ptest.obj
+	@%append demos.lnk library $(LIBCURSES)
+	@%append demos.lnk library $(LIBPANEL)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name testcurs.exe
+	@%append demos.lnk file testcurs.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name tuidemo.exe
+	@%append demos.lnk file tuidemo.obj
+	@%append demos.lnk file tui.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	@%create demos.lnk
+	@%append demos.lnk option quiet
+	@%append demos.lnk system $(TARGET)
+	@%append demos.lnk name xmas.exe
+	@%append demos.lnk file xmas.obj
+	@%append demos.lnk library $(LIBCURSES)
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Watcom C++ 32bit DOS > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Open Watcom 1.3 for 32 bit DOS. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	echo $(PDCURSES_HOME)\README > flist
+	echo $(PDCURSES_HOME)\readme.$(VER) >> flist
+	echo $(PDCURSES_HOME)\maintain.er >> flist
+	echo $(PDCURSES_HOME)\curses.h >> flist
+	echo $(PDCURSES_HOME)\curspriv.h >> flist
+	echo $(PDCURSES_HOME)\panel.h >> flist
+	echo $(PDCURSES_HOME)\term.h >> flist
+	echo $(LIBCURSES) >> flist
+	echo $(LIBPANEL) >> flist
+	echo file_id.diz >> flist
+	zip -jX pdc$(VER)32w -@ <flist
+	del flist
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/dos/wccdos.lrf stsgdb-6.8/pdcurses/dos/wccdos.lrf
--- gdb-6.8/pdcurses/dos/wccdos.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/dos/wccdos.lrf	2008-09-11 10:32:58.000000000 +0100
@@ -0,0 +1,48 @@
++addch.obj
++addchstr.obj
++addstr.obj
++attr.obj
++beep.obj
++bkgd.obj
++border.obj
++clear.obj
++color.obj
++delch.obj
++deleteln.obj
++getch.obj
++getstr.obj
++getyx.obj
++inch.obj 
++inchstr.obj
++initscr.obj
++inopts.obj
++insch.obj
++insstr.obj
++instr.obj
++kernel.obj
++mouse.obj
++move.obj 
++outopts.obj
++overlay.obj
++pad.obj  
++printw.obj
++refresh.obj
++scanw.obj
++scr_dump.obj
++scroll.obj
++slk.obj  
++termattr.obj
++terminfo.obj
++touch.obj
++util.obj 
++window.obj
++pdcclip.obj
++pdcdebug.obj
++pdcdisp.obj
++pdcgetsc.obj
++pdckbd.obj
++pdcprint.obj
++pdcscrn.obj
++pdcsetsc.obj
++pdcutil.obj
++pdcwin.obj
diff -Naur gdb-6.8/pdcurses/INSTALL stsgdb-6.8/pdcurses/INSTALL
--- gdb-6.8/pdcurses/INSTALL	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/INSTALL	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,79 @@
+                    Welcome to PDCurses !
+
+ This file provides information on building PDCurses for DOS, OS/2,
+ Windows or X11. After unpacking the archive, go to the section below
+ for the platform you intend to build on.
+
+ DOS, OS/2, or Windows
+ ---------------------
+ . Set the environment variable PDCURSES_SRCDIR to point to the
+   directory where you unpacked PDCurses. (Skip this step if you're
+   using LCC-Win32.) For example:
+
+         set PDCURSES_SRCDIR=c:\pdcurs27
+
+ . In the subdirectory for each OS, you'll find a number of ".mak"
+   files, one for each supported compiler:
+
+   DOS:
+         bccdos.mak    - Borland C++ 3.0+
+         gccdos.mak    - DJGPP V2
+         mscdos.mak    - Microsoft C 6.0
+         msvcdos.mak   - Visual C++ 1.0+
+         wccdos16.mak  - Watcom 10.6+ (16bit)
+         wccdos4g.mak  - Watcom 10.6+ (32bit)
+
+   OS/2:
+         bccos2.mak    - Borland C++ 2.0
+         gccos2.mak    - EMX 0.9b+
+         iccos2.mak    - C Set/2
+         wccos2.mak    - Watcom 10.6+ (32bit)
+
+   Windows:
+         bccwin32.mak  - Borland C++ 4.0.2+
+         gccwin32.mak  - Cygnus GNU Compiler
+         lccwin32.mak  - LCC-Win32
+         mingwin32.mak - MinGW
+         vcwin32.mak   - Visual C++ 2.0+
+         wccwin32.mak  - Watcom 10.6+
+
+ . In some cases, you may have to edit the makefile before proceeding.
+   LCC-Win32 users must point PDCURSES_HOME to the PDCurses directory.
+   For 16-bit compilers, some might want to change the memory MODEL.
+   (Large model is the default, and recommended.) Read the makefile for
+   other options; but generally, you can proceed to...
+
+ . Build it:
+
+         make -f makefilename
+
+   You can build it from the OS subdirectory, or from another location
+   by specifying the full path to the makefile. (For Watcom, use "wmake"
+   instead of "make"; for MSVC or C Set/2, "nmake".) You'll get the libs
+   (pdcurses.lib or .a, depending on your compiler; and panel.lib or .a),
+   the demos (*.exe), and a lot of object files.
+
+
+ X11
+ ---
+ . Run the configure script in the PDCurses-x.x directory. This will
+   check for the dependencies XCurses requires.
+
+   If configure can't find your X include files or X libraries, you can
+   specify the paths with the arguments "--x-includes=inc_path" or
+   "--x-libraries=lib_path".
+
+   configure also recognises the "--with-debug[=yes|no]" switch. By
+   default, the library and demo programs are built with the optimiser
+   switch; -O. You can turn this off, and turn on debugging (-g), by
+   adding "--with-debug" to the configure command.
+
+ . Run "make". This should make the XCurses library, the panels library
+   and all demo programs in the demos directory.
+
+ . Alternately, you can cd to "pdcurses" directory, and run "make" from
+   here. This will build libXCurses only.
+
+ . Optionally, run "make install". curses.h, panel.h and the panel lib
+   will be renamed when installed (xcurses.h, xpanel.h and libXPanel),
+   to avoid conflicts with any existing curses installations.
diff -Naur gdb-6.8/pdcurses/install-sh stsgdb-6.8/pdcurses/install-sh
--- gdb-6.8/pdcurses/install-sh	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/install-sh	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,253 @@
+#! /bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
+#
+# Copyright 1991 by the Massachusetts Institute of Technology
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided "as is"
+# without express or implied warranty.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+#
+# Modified 1 Feb 2000 MHES to cater for mkdir -p
+#
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+transformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+mkdircmd="$mkdirprog -p"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+        -c) instcmd="$cpprog"
+            shift
+            continue;;
+
+        -d) dir_arg=true
+            shift
+            continue;;
+
+        -m) chmodcmd="$chmodprog $2"
+            shift
+            shift
+            continue;;
+
+        -o) chowncmd="$chownprog $2"
+            shift
+            shift
+            continue;;
+
+        -g) chgrpcmd="$chgrpprog $2"
+            shift
+            shift
+            continue;;
+
+        -s) stripcmd="$stripprog"
+            shift
+            continue;;
+
+        -t=*) transformarg=`echo $1 | sed 's/-t=//'`
+            shift
+            continue;;
+
+        -b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+            shift
+            continue;;
+
+        *)  if [ x"$src" = x ]
+            then
+                src=$1
+            else
+                # this colon is to work around a 386BSD /bin/sh bug
+                :
+                dst=$1
+            fi
+            shift
+            continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+        echo "install:  no input file specified"
+        exit 1
+else
+        true
+fi
+
+if [ x"$dir_arg" != x ]; then
+        dst=$src
+        src=""
+
+        if [ -d $dst ]; then
+                instcmd=:
+        else
+                instcmd=mkdir
+        fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad
+# if $src (and thus $dsttmp) contains '*'.
+
+        if [ -f $src -o -d $src ]
+        then
+                true
+        else
+                echo "install:  $src does not exist"
+                exit 1
+        fi
+
+        if [ x"$dst" = x ]
+        then
+                echo "install:  no destination specified"
+                exit 1
+        else
+                true
+        fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+        if [ -d $dst ]
+        then
+                dst="$dst"/`basename $src`
+        else
+                true
+        fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='
+'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+        pathcomp="${pathcomp}${1}"
+        shift
+
+        if [ ! -d "${pathcomp}" ] ;
+        then
+                $mkdircmd "${pathcomp}"
+        else
+                true
+        fi
+
+        pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+        $doit $instcmd $dst &&
+
+        if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
+        if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
+        if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
+        if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+        if [ x"$transformarg" = x ]
+        then
+                dstfile=`basename $dst`
+        else
+                dstfile=`basename $dst $transformbasename |
+                        sed $transformarg`$transformbasename
+        fi
+
+# don't allow the sed command to completely eliminate the filename
+
+        if [ x"$dstfile" = x ]
+        then
+                dstfile=`basename $dst`
+        else
+                true
+        fi
+
+# Make a temp file name in the proper directory.
+
+        dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+        $doit $instcmd $src $dsttmp &&
+
+        trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+        if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
+        if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
+        if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
+        if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+
+# Now rename the file to the real destination.
+
+        $doit $rmcmd -f $dstdir/$dstfile &&
+        $doit $mvcmd $dsttmp $dstdir/$dstfile
+
+fi &&
+
+exit 0
diff -Naur gdb-6.8/pdcurses/maintain.er stsgdb-6.8/pdcurses/maintain.er
--- gdb-6.8/pdcurses/maintain.er	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/maintain.er	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1 @@
+William McBrine <wmcbrine@users.sf.net>
diff -Naur gdb-6.8/pdcurses/Makefile.in stsgdb-6.8/pdcurses/Makefile.in
--- gdb-6.8/pdcurses/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/Makefile.in	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,206 @@
+################################################################################
+# Makefile for pdcurses library adapted STMicroelectronics 
+#   Copyright (C) 2006 STMicroelectronics
+################################################################################
+
+PDCURSES_HOME = @srcdir@
+VPATH = @srcdir@
+
+AR = ar
+ARFLAGS = rcv
+
+
+RM = rm -f
+CP = cp
+MV = mv
+
+
+CCFLAGS = $(LOCAL_CFLAGS) $(CFLAGS) -I$(PDCURSES_HOME) -c
+
+
+srcdir		= $(PDCURSES_HOME)/pdcurses
+osdir		= $(PDCURSES_HOME)/win32
+
+################################################################################
+
+LIBCURSES	= pdcurses.a
+
+PDCLIBS	= $(LIBCURSES)
+
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+
+################################################################################
+all:	$(PDCLIBS) 
+
+clean:
+	$(RM) $(LIBOBJS) $(PDCOBJS)
+	$(RM) $(LIBCURSES)
+
+#------------------------------------------------------------------------
+
+LIBOBJS = addch.o addchstr.o addstr.o attr.o beep.o bkgd.o border.o clear.o \
+color.o delch.o deleteln.o getch.o getstr.o getyx.o inch.o inchstr.o initscr.o \
+inopts.o insch.o insstr.o instr.o kernel.o mouse.o move.o outopts.o overlay.o \
+pad.o printw.o refresh.o scanw.o scr_dump.o scroll.o slk.o termattr.o terminfo.o  \
+touch.o util.o window.o
+
+PDCOBJS = pdcclip.o pdcdebug.o pdcdisp.o pdcgetsc.o pdckbd.o pdcprint.o  \
+pdcscrn.o pdcsetsc.o pdcutil.o pdcwin.o
+
+
+$(PDCLIBS) : $(LIBOBJS) $(PDCOBJS)
+	$(AR) $(ARFLAGS) $@ $(LIBOBJS) $(PDCOBJS)
+
+
+.c.o: 
+	${RM} $@
+	$(CC) -c $(CCFLAGS) $<
+
+
+addch.o: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addch.c
+
+addchstr.o: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addchstr.c
+
+addstr.o: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addstr.c
+
+attr.o: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/attr.c
+
+beep.o: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/beep.c
+
+bkgd.o: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/bkgd.c
+
+border.o: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/border.c
+
+clear.o: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/clear.c
+
+color.o: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/color.c
+
+delch.o: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/delch.c
+
+deleteln.o: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/deleteln.c
+
+getch.o: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getch.c
+
+getstr.o: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getstr.c
+
+getyx.o: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getyx.c
+
+inch.o: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inch.c
+
+inchstr.o: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inchstr.c
+
+initscr.o: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/initscr.c
+
+inopts.o: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inopts.c
+
+insch.o: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insch.c
+
+insstr.o: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insstr.c
+
+instr.o: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/instr.c
+
+kernel.o: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/kernel.c
+
+mouse.o: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/mouse.c
+
+move.o: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/move.c
+
+outopts.o: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/outopts.c
+
+overlay.o: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/overlay.c
+
+pad.o: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pad.c
+
+printw.o: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/printw.c
+
+refresh.o: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/refresh.c
+
+scanw.o: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scanw.c
+
+scr_dump.o: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scr_dump.c
+
+scroll.o: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scroll.c
+
+slk.o: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/slk.c
+
+termattr.o: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/termattr.c
+
+terminfo.o: $(srcdir)/terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/terminfo.c
+
+touch.o: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/touch.c
+
+util.o: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/util.c
+
+window.o: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/window.c
+
+
+pdcclip.o: $(osdir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcclip.c
+
+pdcdebug.o: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcdebug.c
+
+pdcdisp.o: $(osdir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcdisp.c
+
+pdcgetsc.o: $(osdir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcgetsc.c
+
+pdckbd.o: $(osdir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdckbd.c
+
+pdcprint.o: $(osdir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcprint.c
+
+pdcscrn.o: $(osdir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcscrn.c
+
+pdcsetsc.o: $(osdir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcsetsc.c
+
+pdcutil.o: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcutil.c
+
+pdcwin.o: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcwin.c
diff -Naur gdb-6.8/pdcurses/os2/bccos2.lrf stsgdb-6.8/pdcurses/os2/bccos2.lrf
--- gdb-6.8/pdcurses/os2/bccos2.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/bccos2.lrf	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,49 @@
+-+addch.obj &
+-+addchstr.obj &
+-+addstr.obj &
+-+attr.obj &
+-+beep.obj &
+-+bkgd.obj &
+-+border.obj &
+-+clear.obj &
+-+color.obj &
+-+delch.obj &
+-+deleteln.obj &
+-+getch.obj &
+-+getstr.obj &
+-+getyx.obj &
+-+inch.obj & 
+-+inchstr.obj &
+-+initscr.obj &
+-+inopts.obj &
+-+insch.obj &
+-+insstr.obj &
+-+instr.obj &
+-+kernel.obj &
+-+mouse.obj &
+-+move.obj & 
+-+outopts.obj &
+-+overlay.obj &
+-+pad.obj &  
+-+printw.obj &
+-+refresh.obj &
+-+scanw.obj &
+-+scr_dump.obj &
+-+scroll.obj &
+-+slk.obj &  
+-+termattr.obj &
+-+terminfo.obj &
+-+touch.obj &
+-+util.obj & 
+-+window.obj &
+-+pdcclip.obj &
+-+pdcdebug.obj &
+-+pdcdisp.obj &
+-+pdcgetsc.obj &
+-+pdckbd.obj &
+-+pdcprint.obj &
+-+pdcscrn.obj &
+-+pdcsetsc.obj &
+-+pdcutil.obj &
+-+pdcwin.obj &
+,lib.map
diff -Naur gdb-6.8/pdcurses/os2/bccos2.mak stsgdb-6.8/pdcurses/os2/bccos2.mak
--- gdb-6.8/pdcurses/os2/bccos2.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/bccos2.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,334 @@
+################################################################################
+#
+# Borland MAKE Makefile for PDCurses library - OS/2 BC++ 1.0+
+#
+# Usage: make -f [path\]bccos2.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\os2
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= bcc
+
+!if $d(DEBUG)
+CFLAGS  = -N -v -y -DPDCDEBUG 
+!else
+CFLAGS  = -O 
+!endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS)
+
+LINK		= tlink
+
+LIBEXE		= tlib /C /E
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\bccos2.lrf
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $@ -+$(PANOBJS)
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(CC) -e$@ $**
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Borland C++ OS/2 1.0 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Borland C/C++ OS/2 1.0. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)bcos2 \
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) \
+	$(PDCURSES_HOME)\maintain.er \
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h \
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/os2/gccos2.mak stsgdb-6.8/pdcurses/os2/gccos2.mak
--- gdb-6.8/pdcurses/os2/gccos2.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/gccos2.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,586 @@
+################################################################################
+#
+# GNU MAKE Makefile for PDCurses library - OS/2 emx 0.9c+
+#
+# Usage: make -f [path\]gccos2.mak [DEBUG=Y] [EMXVIDEO=Y] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.a|panel.a|testcurs.exe...]
+#
+# The EMXVIDEO option compiles with the emx video library, which
+# enables a PDCurses program to run under OS/2 and DOS.
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)/panel.h
+TERM_HEADER		=$(PDCURSES_HOME)/term.h
+
+srcdir		= $(PDCURSES_HOME)/pdcurses
+osdir		= $(PDCURSES_HOME)/os2
+pandir		= $(PDCURSES_HOME)/panel
+demodir		= $(PDCURSES_HOME)/demos
+
+CC		= gcc
+
+ifeq ($(EMXVIDEO),Y)
+	EMXVID = -DEMXVIDEO
+	VIDLIB = -lvideo
+	BINDFLAGS = -acm
+	DLLTARGET = 
+else
+	EMXVID =
+	VIDLIB =
+	BINDFLAGS = 
+	DLLTARGET = curses.dll
+endif
+
+ifeq ($(DEBUG),Y)
+	CFLAGS  = -c -g -Wall -fomit-frame-pointer -DPDCDEBUG
+	LDFLAGS = -g
+else
+	CFLAGS  = -c -O3 -Wall -fomit-frame-pointer
+	LDFLAGS =
+endif
+
+DLLFLAGS = -Zdll -Zcrtdll -Zomf
+DLLCURSES = curses.lib
+
+CPPFLAGS	= -I$(PDCURSES_HOME) $(EMXVID)
+
+CCFLAGS		= $(CFLAGS) $(CPPFLAGS)
+
+LINK		= gcc
+EMXBIND	=emxbind 
+EMXOMF	=emxomf
+
+CCLIBS		=$(VIDLIB)
+
+LIBEXE		= ar
+LIBFLAGS		=rcv
+
+LIBCURSES	= pdcurses.a
+LIBPANEL	= panel.a
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL) #$(DLLTARGET) pdcurses.lib panel.lib
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean:
+	-del *.o
+	-del *.dlo
+	-del *.a
+	-del *.lib
+	-del *.dll
+	-del *.exe
+	-del testcurs newdemo xmas tuidemo firework ptest
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.o     \
+addchstr.o  \
+addstr.o    \
+attr.o      \
+beep.o      \
+bkgd.o      \
+border.o    \
+clear.o     \
+color.o     \
+delch.o     \
+deleteln.o  \
+getch.o     \
+getstr.o    \
+getyx.o     \
+inch.o      \
+inchstr.o   \
+initscr.o   \
+inopts.o    \
+insch.o     \
+insstr.o    \
+instr.o     \
+kernel.o    \
+mouse.o     \
+move.o      \
+outopts.o   \
+overlay.o   \
+pad.o       \
+printw.o    \
+refresh.o   \
+scanw.o     \
+scr_dump.o  \
+scroll.o    \
+slk.o       \
+termattr.o  \
+terminfo.o  \
+touch.o     \
+util.o      \
+window.o
+
+DLLOBJS =     \
+addch.dlo     \
+addchstr.dlo  \
+addstr.dlo    \
+attr.dlo      \
+beep.dlo      \
+bkgd.dlo      \
+border.dlo    \
+clear.dlo     \
+color.dlo     \
+delch.dlo     \
+deleteln.dlo  \
+getch.dlo     \
+getstr.dlo    \
+getyx.dlo     \
+inch.dlo      \
+inchstr.dlo   \
+initscr.dlo   \
+inopts.dlo    \
+insch.dlo     \
+insstr.dlo    \
+instr.dlo     \
+kernel.dlo    \
+mouse.dlo     \
+move.dlo      \
+outopts.dlo   \
+overlay.dlo   \
+pad.dlo       \
+printw.dlo    \
+refresh.dlo   \
+scanw.dlo     \
+scr_dump.dlo  \
+scroll.dlo    \
+slk.dlo       \
+termattr.dlo  \
+terminfo.dlo  \
+touch.dlo     \
+util.dlo      \
+window.dlo
+
+PDCOBJS =   \
+pdcclip.o   \
+pdcdebug.o  \
+pdcdisp.o   \
+pdcgetsc.o  \
+pdckbd.o    \
+pdcprint.o  \
+pdcscrn.o   \
+pdcsetsc.o  \
+pdcutil.o   \
+pdcwin.o
+
+PDCDLOS =   \
+pdcclip.dlo   \
+pdcdebug.dlo  \
+pdcdisp.dlo   \
+pdcgetsc.dlo  \
+pdckbd.dlo    \
+pdcprint.dlo  \
+pdcscrn.dlo   \
+pdcsetsc.dlo  \
+pdcutil.dlo   \
+pdcwin.dlo
+
+PANOBJS =     \
+panel.o
+
+pdcurses.a : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ $(LIBOBJS) $(PDCOBJS)
+
+pdcurses.lib : pdcurses.a
+	$(EMXOMF) -o pdcurses.lib pdcurses.a
+
+curses.dll : $(DLLOBJS) $(PDCDLOS)
+	$(LINK) $(DLLFLAGS) -o curses.dll $(DLLOBJS) $(PDCDLOS) $(osdir)\pdcurses.def
+#	lxlite curses.dll
+	emximp -o curses.lib $(osdir)\pdcurses.def
+	emximp -o curses.a curses.lib
+
+panel.a : $(PANOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ $(PANOBJS)
+
+panel.lib : panel.a
+	$(EMXOMF) -o panel.lib panel.a
+
+
+addch.o: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addch.c
+
+addchstr.o: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addchstr.c
+
+addstr.o: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addstr.c
+
+attr.o: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\attr.c
+
+beep.o: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\beep.c
+
+bkgd.o: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\bkgd.c
+
+border.o: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\border.c
+
+clear.o: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\clear.c
+
+color.o: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\color.c
+
+delch.o: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\delch.c
+
+deleteln.o: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\deleteln.c
+
+getch.o: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getch.c
+
+getstr.o: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getstr.c
+
+getyx.o: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getyx.c
+
+inch.o: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inch.c
+
+inchstr.o: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inchstr.c
+
+initscr.o: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\initscr.c
+
+inopts.o: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inopts.c
+
+insch.o: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insch.c
+
+insstr.o: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insstr.c
+
+instr.o: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\instr.c
+
+kernel.o: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\kernel.c
+
+mouse.o: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\mouse.c
+
+move.o: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\move.c
+
+outopts.o: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\outopts.c
+
+overlay.o: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\overlay.c
+
+pad.o: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pad.c
+
+printw.o: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\printw.c
+
+refresh.o: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\refresh.c
+
+scanw.o: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scanw.c
+
+scr_dump.o: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scr_dump.c
+
+scroll.o: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scroll.c
+
+slk.o: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\slk.c
+
+termattr.o: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\termattr.c
+
+terminfo.o: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\terminfo.c
+
+touch.o: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\touch.c
+
+util.o: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\util.c
+
+window.o: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\window.c
+
+
+pdcclip.o: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcclip.c
+
+pdcdebug.o: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.o: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.o: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcgetsc.c
+
+pdckbd.o: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdckbd.c
+
+pdcprint.o: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcprint.c
+
+pdcscrn.o: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.o: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcsetsc.c
+
+pdcutil.o: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcutil.c
+
+pdcwin.o: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcwin.c
+
+addch.dlo: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\addch.c
+
+addchstr.dlo: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\addchstr.c
+
+addstr.dlo: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\addstr.c
+
+attr.dlo: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\attr.c
+
+beep.dlo: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\beep.c
+
+bkgd.dlo: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\bkgd.c
+
+border.dlo: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\border.c
+
+clear.dlo: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\clear.c
+
+color.dlo: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\color.c
+
+delch.dlo: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\delch.c
+
+deleteln.dlo: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\deleteln.c
+
+getch.dlo: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\getch.c
+
+getstr.dlo: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\getstr.c
+
+getyx.dlo: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\getyx.c
+
+inch.dlo: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\inch.c
+
+inchstr.dlo: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\inchstr.c
+
+initscr.dlo: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\initscr.c
+
+inopts.dlo: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\inopts.c
+
+insch.dlo: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\insch.c
+
+insstr.dlo: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\insstr.c
+
+instr.dlo: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\instr.c
+
+kernel.dlo: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\kernel.c
+
+mouse.dlo: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\mouse.c
+
+move.dlo: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\move.c
+
+outopts.dlo: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\outopts.c
+
+overlay.dlo: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\overlay.c
+
+pad.dlo: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\pad.c
+
+printw.dlo: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\printw.c
+
+refresh.dlo: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\refresh.c
+
+scanw.dlo: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\scanw.c
+
+scr_dump.dlo: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\scr_dump.c
+
+scroll.dlo: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\scroll.c
+
+slk.dlo: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\slk.c
+
+termattr.dlo: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\termattr.c
+
+terminfo.dlo: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\terminfo.c
+
+touch.dlo: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\touch.c
+
+util.dlo: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\util.c
+
+window.dlo: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\window.c
+
+
+pdcclip.dlo: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdcclip.c
+
+pdcdebug.dlo: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.dlo: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.dlo: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdcgetsc.c
+
+pdckbd.dlo: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdckbd.c
+
+pdcprint.dlo: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdcprint.c
+
+pdcscrn.dlo: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.dlo: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(osdir)\pdcsetsc.c
+
+pdcutil.dlo: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\pdcutil.c
+
+pdcwin.dlo: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) $(DLLFLAGS) -o$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.o: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o firework firework.o $(LIBCURSES) $(CCLIBS)
+	$(EMXBIND) firework $(BINDFLAGS)
+
+newdemo.exe:	newdemo.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o newdemo newdemo.o $(LIBCURSES) $(CCLIBS)
+	$(EMXBIND) newdemo $(BINDFLAGS)
+
+ptest.exe:	ptest.o $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -o ptest ptest.o $(LIBCURSES) $(LIBPANEL) $(CCLIBS)
+	$(EMXBIND) ptest $(BINDFLAGS)
+
+testcurs.exe:	testcurs.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o testcurs testcurs.o $(LIBCURSES) $(CCLIBS)
+	$(EMXBIND) testcurs $(BINDFLAGS)
+
+tuidemo.exe:	tuidemo.o tui.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o tuidemo tuidemo.o tui.o $(LIBCURSES) $(CCLIBS)
+	$(EMXBIND) tuidemo $(BINDFLAGS)
+
+xmas.exe:	xmas.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o xmas xmas.o $(LIBCURSES) $(CCLIBS)
+	$(EMXBIND) xmas $(BINDFLAGS)
+
+
+testcurs_dyn.exe:	testcurs.obj curses.dll
+	$(LINK) $(LDFLAGS) $(DLLFLAGS) -o testcurs_dyn testcurs.obj $(DLLCURSES) $(CCLIBS)
+	$(EMXBIND) testcurs_dyn $(BINDFLAGS)
+
+firework.o: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\firework.c
+
+newdemo.o: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\newdemo.c
+
+ptest.o: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\ptest.c
+
+testcurs.o: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\testcurs.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Zomf -o$@ $(demodir)\testcurs.c
+
+tui.o: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)\tui.c
+                               
+tuidemo.o: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)\tuidemo.c
+
+xmas.o: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for EMX OS/2 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo EMX 0.9d for OS/2. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_emx_os2 \
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) \
+	$(PDCURSES_HOME)\maintain.er \
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h \
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/os2/iccos2.lrf stsgdb-6.8/pdcurses/os2/iccos2.lrf
--- gdb-6.8/pdcurses/os2/iccos2.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/iccos2.lrf	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,49 @@
+-+addch.obj &
+-+addchstr.obj &
+-+addstr.obj &
+-+attr.obj &
+-+beep.obj &
+-+bkgd.obj &
+-+border.obj &
+-+clear.obj &
+-+color.obj &
+-+delch.obj &
+-+deleteln.obj &
+-+getch.obj &
+-+getstr.obj &
+-+getyx.obj &
+-+inch.obj & 
+-+inchstr.obj &
+-+initscr.obj &
+-+inopts.obj &
+-+insch.obj &
+-+insstr.obj &
+-+instr.obj &
+-+kernel.obj &
+-+mouse.obj &
+-+move.obj & 
+-+outopts.obj &
+-+overlay.obj &
+-+pad.obj &  
+-+printw.obj &
+-+refresh.obj &
+-+scanw.obj &
+-+scr_dump.obj &
+-+scroll.obj &
+-+slk.obj &  
+-+termattr.obj &
+-+terminfo.obj &
+-+touch.obj &
+-+util.obj & 
+-+window.obj &
+-+pdcdebug.obj &
+-+pdcclip.obj &
+-+pdcdisp.obj &
+-+pdcgetsc.obj &
+-+pdckbd.obj &
+-+pdcprint.obj &
+-+pdcscrn.obj &
+-+pdcsetsc.obj &
+-+pdcutil.obj &
+-+pdcwin.obj &
+,lib.map;
diff -Naur gdb-6.8/pdcurses/os2/iccos2.mak stsgdb-6.8/pdcurses/os2/iccos2.mak
--- gdb-6.8/pdcurses/os2/iccos2.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/iccos2.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,337 @@
+################################################################################
+#
+# NMAKE Makefile for PDCurses library - OS/2 C Set/2
+#
+# Usage: nmake -f [path\]iccos2.mak [DEBUG=1] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\os2
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= icc
+
+!ifdef DEBUG
+CFLAGS  = /Sm /Ti+ /O- /Q+ /dPDCDEBUG
+LDFLAGS = /NOLOGO /NOE /SE:160 /DEBUG /PMTYPE:VIO
+!else
+CFLAGS  = /Sm /Ti- /O+ /Q+
+LDFLAGS = /NOLOGO /NOE /EXEPACK /PACKCODE /PACKDATA /PMTYPE:VIO
+!endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS)
+
+LINK		= link386
+
+LIBEXE		= lib
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS		= $(LIBCURSES) $(LIBPANEL)
+
+################################################################################
+all:	$(PDCLIBS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.exe
+
+demos:	testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\iccos2.lrf
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $@ -+$(PANOBJS);
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+#            DLFLAGS  = $(LDEBUG) $*$(OBJ),$*,,$(PDCLIB);
+#            PANFLAGS = $(LDEBUG) $*$(OBJ),$*,,$(PDCLIB)+$(PANLIB);
+
+firework.exe: firework.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+newdemo.exe: newdemo.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+ptest.exe: ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES)+$(LIBPANEL);
+
+testcurs.exe: testcurs.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+tuidemo.exe: tuidemo.obj tui.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj+tui.obj,$*,,$(LIBCURSES);
+
+xmas.exe: xmas.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) $*.obj,$*,,$(LIBCURSES);
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for C Set/2 OS/2 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo C Set/2 for OS/2. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_icc_os2 \
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) \
+	$(PDCURSES_HOME)\maintain.er \
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h \
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/os2/pdcclip.c stsgdb-6.8/pdcurses/os2/pdcclip.c
--- gdb-6.8/pdcurses/os2/pdcclip.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcclip.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,264 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#if !defined(EMXVIDEO)
+# define INCL_DOS
+# define INCL_WIN
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCclip  = "$Id: pdcclip.c,v 1.5 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_getclipboard() - Gets the contents of the clipboard
+
+  PDCurses Description:
+   This is a PDCurses only routine.
+
+   Gets the textual contents of the system's clipboard. This
+   function returns the contents of the clipboard in the contents
+   argument. It is the responsibilitiy of the caller to free the
+   memory returned with the PDC_freeclipboard() call.  The length of the
+   clipboard contents is returned in the length argument.
+
+  PDCurses Return Value:
+   indicator of success/failure of call.
+   PDC_CLIP_SUCCESS  the call was successful
+   PDC_CLIP_ACCESS_ERROR   an error occured while accessing the
+      clipboard
+   PDC_CLIP_MEMORY_ERROR   unable to allocate sufficient memory for 
+      the clipboard contents
+   PDC_CLIP_EMPTY the clipboard contains no text
+
+  Portability:
+   PDCurses int PDC_getclipboard( char **contents, long *length );
+
+**man-end**********************************************************************/
+
+int   PDC_CDECL   PDC_getclipboard(char **contents, long *length)
+{
+#if !defined(EMXVIDEO)
+   HMQ hmq;
+   HAB hab;
+   PTIB ptib;
+   PPIB ppib;
+   ULONG ulRet;
+   long len=0;
+   int rc=0;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_getclipboard() - called\n");
+#endif
+
+#if !defined(EMXVIDEO)
+   DosGetInfoBlocks( &ptib, &ppib );
+   ppib->pib_ultype = 3;
+   hab = WinInitialize( 0 );
+   hmq = WinCreateMsgQueue( hab, 0 );
+
+   if ( !WinOpenClipbrd( hab ) )
+   {
+      WinDestroyMsgQueue( hmq );
+      WinTerminate( hab );
+      return PDC_CLIP_ACCESS_ERROR;
+   }
+   ulRet = WinQueryClipbrdData( hab, CF_TEXT );
+   if ( !ulRet )
+      rc = PDC_CLIP_EMPTY;
+   else
+   {
+      len = strlen( (char *)ulRet );
+      *contents = (char *)malloc( len+1 );
+      if ( !*contents )
+      {
+         rc = PDC_CLIP_MEMORY_ERROR;
+      }
+      else
+      {
+         strcpy( (char *)*contents, (char *)ulRet );
+         *length = len;
+         rc = PDC_CLIP_SUCCESS;
+      }
+   }
+   WinCloseClipbrd( hab );
+   WinDestroyMsgQueue( hmq );
+   WinTerminate( hab );
+   return( rc );
+#else
+   return PDC_CLIP_ACCESS_ERROR;
+#endif
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_setclipboard() - Sets the contents of the clipboard
+
+  PDCurses Description:
+   This is a PDCurses only routine.
+
+   Copies the supplied text into the system's clipboard, emptying
+   the clipboard prior to the copy.
+
+  PDCurses Return Value:
+   indicator of success/failure of call.
+   PDC_CLIP_SUCCESS  the call was successful
+   PDC_CLIP_ACCESS_ERROR   an error occured while accessing the
+      clipboard
+
+  Portability:
+   PDCurses int PDC_getclipboard( char *contents, long length );
+
+**man-end**********************************************************************/
+
+int   PDC_CDECL   PDC_setclipboard(char *contents, long length)
+{
+#if !defined(EMXVIDEO)
+   HAB hab;
+   PTIB ptib;
+   PPIB ppib;
+   ULONG ulRC;
+   PSZ szTextOut=NULL;
+   int rc=0;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_setclipboard() - called\n");
+#endif
+
+#if !defined(EMXVIDEO)
+   DosGetInfoBlocks( &ptib, &ppib );
+   ppib->pib_ultype = 3;
+   hab = WinInitialize( 0 );
+
+   if ( !WinOpenClipbrd( hab ) )
+   {
+      WinTerminate( hab );
+      return PDC_CLIP_ACCESS_ERROR;
+   }
+   ulRC = DosAllocSharedMem( (PVOID) &szTextOut, NULL, length+1, PAG_WRITE | PAG_COMMIT | OBJ_GIVEABLE );
+   if (ulRC != 0)
+   {
+      rc = PDC_CLIP_MEMORY_ERROR;
+   }
+   else
+   {
+      strcpy( szTextOut, contents );
+      WinEmptyClipbrd( hab );
+      if ( WinSetClipbrdData( hab, (ULONG)szTextOut, CF_TEXT, CFI_POINTER ) )
+      {
+         rc = PDC_CLIP_SUCCESS;
+      }
+      else
+      {
+         DosFreeMem( szTextOut );
+         rc = PDC_CLIP_ACCESS_ERROR;
+      }
+   }
+   WinCloseClipbrd( hab );
+   WinTerminate( hab );
+   return( rc );
+#else
+   return PDC_CLIP_ACCESS_ERROR;
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_freeclipboard()   - Frees the memory associated with the contents of the clipboard
+
+  PDCurses Description:
+   This is a PDCurses only routine.
+
+   Frees the memory allocated by PDC_getclipboard().
+
+  PDCurses Return Value:
+   Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+   PDCurses int PDC_freeclipboard( char *contents );
+
+**man-end**********************************************************************/
+
+int   PDC_CDECL   PDC_freeclipboard(char *contents)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_freeclipboard() - called\n");
+#endif
+
+   if ( contents) free(contents);
+   return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_clearclipboard()  - Clears the contents of the clipboard
+
+  PDCurses Description:
+   This is a PDCurses only routine.
+
+   Clears the internal clipboard.
+
+  PDCurses Return Value:
+   Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+   PDCurses int PDC_clearclipboard( void );
+
+**man-end**********************************************************************/
+
+int   PDC_CDECL   PDC_clearclipboard( void )
+{
+#if !defined(EMXVIDEO)
+   HAB hab;
+   PTIB ptib;
+   PPIB ppib;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_clearclipboard() - called\n");
+#endif
+
+#if !defined(EMXVIDEO)
+   DosGetInfoBlocks( &ptib, &ppib );
+   ppib->pib_ultype = 3;
+   hab = WinInitialize( 0 );
+
+   WinEmptyClipbrd( hab );
+
+   WinCloseClipbrd( hab );
+   WinTerminate( hab );
+   return PDC_CLIP_SUCCESS;
+#else
+   return PDC_CLIP_ACCESS_ERROR;
+#endif
+}
diff -Naur gdb-6.8/pdcurses/os2/pdcdisp.c stsgdb-6.8/pdcurses/os2/pdcdisp.c
--- gdb-6.8/pdcurses/os2/pdcdisp.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcdisp.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,578 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdisp  = "$Id: pdcdisp.c,v 1.3 2005/12/14 21:37:49 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_clr_update()	- Updates the screen with a full redraw.
+
+  PDCurses Description:
+ 	Updates the screen by clearing it and then redraw it in its
+ 	entirety. If SP->refrbrk is TRUE, and there is pending
+ 	input characters, the update will be prematurely terminated.
+
+  PDCurses Return Value:
+ 	This routine returns ERR if it is unable to accomplish it's task.
+ 	This return value is ONLY under FLEXOS.
+
+ 	The return value OK is returned if there were no errors.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_clr_update( WINDOW* s );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_clr_update(WINDOW *s)
+#else
+int	PDC_clr_update(s)
+WINDOW *s;
+#endif
+/***********************************************************************/
+{
+register int	i=0,j=0;
+	WINDOW*	w=NULL;
+	unsigned short*	ch;
+	bool rc=FALSE;
+
+	extern unsigned	char atrtab[MAX_ATRTAB];
+
+/* the next two variables have been changed from chtype to unsigned short */
+/* as this is the correct datatype for a physical character/attribute */
+	unsigned short temp_line[256]; /* this should be enough for the maximum width of a screen. MH-920715 */
+	unsigned short chr;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_clr_update() - called\n");
+#endif
+
+	w = curscr;
+	if (w == (WINDOW *)NULL)
+		return( ERR );
+/*	if (SP->full_redraw)
+		PDC_clr_scrn(s); *//* clear physical screen */
+
+	s->_clear = FALSE;
+	for (i = 0; i < LINES; i++)	/* update physical screen */
+	{
+		if (s != w)	/* copy s to curscr */
+			memcpy(w->_y[i], s->_y[i], COLS * sizeof(chtype));
+
+		ch = temp_line; /* now have ch pointing to area to contain real attributes. MH-920715 */
+
+		for (j=0;j<COLS;j++)          /* for each chtype in the line... */
+		   {
+		    chr = (unsigned short)(s->_y[i][j] & A_CHARTEXT);
+		    temp_line[j] = chtype_attr(s->_y[i][j]) | chr;
+		   }
+
+		if (SP->direct_video)
+		{
+#ifdef EMXVIDEO
+		v_putline ((char *)ch, 0, i, COLS);
+#else
+		VioWrtCellStr ((PCH)ch, (USHORT)(COLS * sizeof(unsigned short)), (USHORT)i, 0, 0);
+#endif
+		}
+		else
+		{
+			for (j = 0; j < COLS; j++)
+			{
+				PDC_gotoxy(i, j);
+				PDC_putc( (*ch & A_CHARTEXT), (*ch & A_ATTRIBUTES) >> 8 );
+				ch++;
+			}
+		}
+
+		if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+		{
+			rc = PDC_breakout();
+			if(rc) 
+				break;
+		}
+		w->_firstch[i] = _NO_CHANGE;
+		w->_lastch[i] = _NO_CHANGE;
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_on()	- Turns on the hardware cursor.
+
+  PDCurses Description:
+ 	Turns on the hardware curses, it does nothing if it is already on.
+
+  PDCurses Return Value:
+ 	Returns OK upon success, ERR upon failure.
+
+  Portability:
+ 	PDCurses	int PDC_cursor_on( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_cursor_on(void)
+#else
+int	PDC_cursor_on()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_cursor_on() - called\n");
+#endif
+
+	if	(!SP->visible_cursor)
+	{
+		SP->visible_cursor = TRUE;
+		PDC_set_cursor_mode((SP->cursor & 0xff00) >> 8,
+			     (SP->cursor & 0x00ff));
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_off()	- Turns off the hardware cursor.
+
+  PDCurses Description:
+ 	Turns off the hardware curses, it does nothing if it is already off.
+
+  PDCurses Return Value:
+ 	Returns OK upon success, ERR upon failure.
+
+  PDCurses Errors:
+ 	ERR will be returned (in the case of FLEXOS) if the hardware cursor
+ 	can not be disabled.
+
+  Portability:
+ 	PDCurses	int PDC_cursor_off( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_cursor_off(void)
+#else
+int	PDC_cursor_off()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_cursor_off() - called\n");
+#endif
+
+	if	(SP->visible_cursor)
+	{
+		SP->visible_cursor = FALSE;
+		PDC_set_cursor_mode(32, 33);	/* turn it off */
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_fix_cursor()	- Fix the cursor start and stop scan lines (if necessary)
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will fix the cursor shape for certain video adapters.
+ 	Normally, the values used are correct, but some adapters choke.
+ 	The most noticable choke is on a monochrome adapter.  The "correct"
+ 	scan lines will result in the cursor being set in the middle of the
+ 	character cell, rather than at the bottom.
+
+ 	The passed flag indicates whether the cursor is visible or not.
+
+ 	This only applies to the DOS platform.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_fix_cursor( int flag );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_fix_cursor(int flag)
+#else
+int	PDC_fix_cursor(flag)
+int flag;
+#endif
+/***********************************************************************/
+{
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_gotoxy()	- position hardware cursor at (x, y)
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Moves the physical cursor to the desired address on the
+ 	screen. We don't optimize here -- on a PC, it takes more time
+ 	to optimize than to do things directly.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_gotoxy( int row, int col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_gotoxy(int row, int col)
+#else
+int	PDC_gotoxy(row,col)
+int row;
+int col;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_gotoxy() - called: row %d col %d\n",row,col);
+#endif
+
+#ifdef EMXVIDEO
+	v_gotoxy (col, row);
+#else
+	VioSetCurPos (row, col, 0);
+#endif
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_putc()	- Output a character in the current attribute.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Outputs character 'chr' to screen in tty fashion. If a colour
+ 	mode is active, the character is written with colour 'colour'.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_putc( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_putc( chtype character, chtype color )
+#else
+int	PDC_putc(character,color)
+chtype character;
+chtype color;
+#endif
+/***********************************************************************/
+{
+	int curRow=0, curCol=0;
+#ifdef EMXVIDEO
+	char Cell[2];
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_putc() - called:char=%c attrib=0x%x color=0x%x\n",character & A_CHARTEXT,character & A_ATTRIBUTES,color);
+#endif
+
+	PDC_get_cursor_pos (&curRow, &curCol);
+#ifdef EMXVIDEO
+	Cell[0] = (char)character;
+	Cell[1] = (char)color;
+	v_putline (Cell, curCol, curRow, 1);
+#else
+	VioWrtTTY ((PCH)&character, 1, 0);
+	VioWrtNAttr ((PBYTE)&color, 1, (USHORT)curRow, (USHORT)curCol, 0);
+	PDC_gotoxy (curRow, curCol);
+#endif
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_putctty()	- Output a character and attribute in TTY fashion.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Outputs character 'chr' to screen in tty fashion. If a colour
+ 	mode is active, the character is written with colour 'colour'.
+
+ 	This function moves the physical cursor after writing so the
+ 	screen will scroll if necessary.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_putctty( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_putctty( chtype character, chtype color )
+#else
+int	PDC_putctty(character,color)
+chtype character;
+chtype color;
+#endif
+/***********************************************************************/
+{
+	int curRow=0, curCol=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_putctty() - called\n");
+#endif
+
+	PDC_get_cursor_pos (&curRow, &curCol);
+#ifdef EMXVIDEO
+	v_attrib (color);
+	v_putc (character);
+#else
+	VioWrtTTY ((PCH)&character, 1, 0);
+	VioWrtNAttr ((PBYTE)&color, 1, (USHORT)curRow, (USHORT)curCol, 0);
+#endif
+	return( OK );
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_scroll()	- low level screen scroll
+
+  PDCurses Description:
+ 	Scrolls a window in the current page up or down. Urow, lcol,
+ 	lrow, rcol are the window coordinates.	Lines is the number of
+ 	lines to scroll. If 0, clears the window, if < 0 scrolls down,
+ 	if > 0 scrolls up.  Blanks areas that are left, and sets
+ 	character attributes to attr. If in a colour graphics mode,
+ 	fills them with the colour 'attr' instead.
+
+  PDCurses Return Value:
+ 	The PDC_scroll() function returns OK on success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	An error will only be returned on the Flexos platform if s_copy()
+ 	fails.
+
+  Portability:
+ 	PDCurses	int PDC_scroll( int urow, int lcol, int rcol,
+ 				     int nlines, chtype attr );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_scroll(int urow, int lcol, int lrow, int rcol, int nlines, chtype attr)
+#else
+int	PDC_scroll(urow,lcol,lrow,rcol,nlines,attr)
+int urow;
+int lcol;
+int lrow;
+int rcol;
+int nlines;
+chtype attr;
+#endif
+/***********************************************************************/
+{
+	extern unsigned	char atrtab[MAX_ATRTAB];
+	int	phys_attr=chtype_attr(attr);
+#ifdef	FLEXOS
+	int	srow=0;
+	int	scol=0;
+	int	drow=0;
+	int	dcol=0;
+	int	nrows=0;
+	int	ncols=0;
+	char	blank = (char) SP->blank;
+#endif
+
+#ifndef EMXVIDEO
+	USHORT ch=(phys_attr | SP->blank);
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scroll() - called: urow %d lcol %d lrow %d rcol %d nlines %d\n",urow,lcol,lrow,rcol,nlines);
+#endif
+
+#ifdef EMXVIDEO
+	v_attrib (phys_attr);
+	if (nlines > 0)
+		v_scroll (lcol, urow, rcol, lrow, nlines, V_SCROLL_UP);
+	else
+		if (nlines < 0)
+			v_scroll (lcol, urow, rcol, lrow, -nlines, V_SCROLL_DOWN);
+		else	/* this clears the whole screen */
+			v_scroll (lcol, urow, rcol, lrow, -1, V_SCROLL_CLEAR);
+#else
+	if (nlines > 0)
+		VioScrollUp(urow, lcol, lrow, rcol, nlines, (PBYTE)&ch, 0);
+	else
+		if (nlines < 0)
+			VioScrollDn(urow, lcol, lrow, rcol, nlines, (PBYTE)&ch, 0);
+		else
+/* this clears the whole screen ?? */
+			VioScrollUp(0, 0, -1, -1, -1, (PBYTE)&ch, 0);
+#endif
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_transform_line()	- display a physical line of the screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Updates the given physical line to look like the corresponding
+ 	line in _curscr.
+
+  PDCurses Return Value:
+ 	This routine returns TRUE if a premature refresh end
+ 	is allowed, and there is an input character pending.  Otherwise,
+ 	FALSE is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	bool	PDC_transform_line( int lineno );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_transform_line(register int lineno)
+#else
+bool	PDC_transform_line(lineno)
+register int lineno;
+#endif
+/***********************************************************************/
+{
+register chtype*	dstp=NULL;
+register chtype*	srcp=NULL;
+
+	int	x=0;
+	int	endx=0;
+	int	len=0;
+	extern unsigned	char atrtab[MAX_ATRTAB];
+
+	unsigned short temp_line[256]; /* this should be enough for the maximum width of a screen. MH-920715 */
+	unsigned short chr=0;
+	unsigned short*	ch=NULL;
+
+	register int j=0;
+	bool rc=FALSE;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_transform_line() - called: line %d\n",lineno);
+#endif
+
+	if (curscr == (WINDOW *)NULL)
+		return( FALSE );
+
+	x = curscr->_firstch[lineno];
+	endx = curscr->_lastch[lineno];
+	dstp = curscr->_y[lineno] + x;
+	srcp = curscr->_y[lineno] + x;
+	len = endx-x+1;
+
+	ch = temp_line; /* now have ch pointing to area to contain real attributes. MH-920715 */
+
+/* replace the attribute part of the chtype with the actual colour value */
+/* replacing the number that points to the actual colour value.          */
+
+	for (j=0;j<len;j++)          /* for each chtype in the line... */
+	   {
+	    chr = *(srcp+j) & A_CHARTEXT;
+	    temp_line[j] = chtype_attr(*(srcp+j)) | chr;
+	   }
+
+	if (SP->direct_video)
+	{
+#ifdef EMXVIDEO
+		v_putline ((char*)ch, x, lineno, len);
+#else
+		VioWrtCellStr ((PCH)ch, (USHORT)(len*sizeof(unsigned short)), (USHORT)lineno, (USHORT)x, 0);
+#endif
+	}
+	else
+	{
+		for (; x <= endx; x++)
+		{
+			PDC_gotoxy(lineno, x);
+			PDC_putc( (*ch & A_CHARTEXT),(*ch & A_ATTRIBUTES) >> 8 );
+			ch++;
+		}
+	}
+	curscr->_firstch[lineno] = _NO_CHANGE;
+	curscr->_lastch[lineno] = _NO_CHANGE;
+
+	if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+	{
+		rc = PDC_breakout();
+		if(rc) 
+			return(TRUE);
+	}
+	return(FALSE);
+}
diff -Naur gdb-6.8/pdcurses/os2/pdcgetsc.c stsgdb-6.8/pdcurses/os2/pdcgetsc.c
--- gdb-6.8/pdcurses/os2/pdcgetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcgetsc.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,482 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCgetsc  = "$Id: pdcgetsc.c,v 1.5 2005/11/12 14:30:51 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_pos()  - return current cursor position
+
+  PDCurses Description:
+   This is a private PDCurses function
+
+   Gets the cursor position in video page 0.  'row' and 'column'
+   are the cursor address.  At this time, there is no support for
+   use of multiple screen pages.
+
+  PDCurses Return Value:
+   This routine will return OK upon success and otherwise ERR will be
+   returned.
+
+  PDCurses Errors:
+   There are no defined errors for this routine.
+
+  Portability:
+   PDCurses int   PDC_get_cursor_pos( int* row, int* col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_cursor_pos(int *row, int *col)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_cursor_pos() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   v_getxy (col, row);
+#else
+   VioGetCurPos((PUSHORT)row,(PUSHORT)col,0);
+#endif
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_col()  - get current column position of cursor
+
+  PDCurses Description:
+   This is a private PDCurses function
+
+   This routine returns the current column position of the cursor on
+   screen.
+
+  PDCurses Return Value:
+   This routine returns the current column position of the cursor. No
+   error is returned.
+
+  PDCurses Errors:
+   There are no defined errors for this routine.
+
+  Portability:
+   PDCurses int   PDC_get_cur_col( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_cur_col(void)
+/***********************************************************************/
+{
+#ifdef EMXVIDEO
+   int curCol=0, curRow=0;
+#else
+   USHORT curCol=0, curRow=0;
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_cur_col() - called\n");
+#endif
+
+   /* find the current cursor position */
+#ifdef EMXVIDEO
+   v_getxy (&curCol, &curRow);
+#else
+   VioGetCurPos ((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
+#endif
+   return (curCol);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_row()  - get current row position of cursor
+
+  PDCurses Description:
+   This is a private PDCurses function
+
+   This routine returns the current row position of the cursor on
+   screen.
+
+  PDCurses Return Value:
+   This routine returns the current row position of the cursor. No
+   error is returned.
+
+  PDCurses Errors:
+   There are no defined errors for this routine.
+
+  Portability:
+   PDCurses int   PDC_get_cur_row( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_cur_row(void)
+/***********************************************************************/
+{
+#ifdef  EMXVIDEO
+   int curCol=0, curRow=0;
+#else
+   USHORT curCol=0, curRow=0;
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_cur_row() - called\n");
+#endif
+
+   /* find the current cursor position */
+#ifdef EMXVIDEO
+   v_getxy (&curCol, &curRow);
+#else
+   VioGetCurPos ((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
+#endif
+   return (curRow);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_attribute()   - Get attribute at current cursor
+
+  PDCurses Description:
+   This is a private PDCurses function
+
+   Return the current attr at current cursor position on the screen.
+
+  PDCurses Return Value:
+   This routine will return OK upon success and otherwise ERR will be
+   returned.
+
+  PDCurses Errors:
+   There are no defined errors for this routine.
+
+  Portability:
+   PDCurses int   PDC_get_attribute( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_attribute(void)
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+   USHORT cellLen = 2;
+#endif
+   int curRow=0, curCol=0;
+   char Cell[4];
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_attribute() - called\n");
+#endif
+
+   PDC_get_cursor_pos(&curRow, &curCol);
+#ifdef EMXVIDEO
+   v_getline (Cell, curCol, curRow, 1);
+#else
+   VioReadCellStr((PCH)&Cell, (PUSHORT)&cellLen, (USHORT)curRow, (USHORT)curCol, 0);
+#endif
+   return ((int) Cell[1]);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_columns()  - return width of screen/viewport.
+
+  PDCurses Description:
+   This is a private PDCurses function
+
+   This function will return the width of the current screen.
+
+  PDCurses Return Value:
+   This routine will return OK upon success and otherwise ERR will be
+   returned.
+
+  PDCurses Errors:
+   There are no defined errors for this routine.
+
+  Portability:
+   PDCurses int   PDC_get_columns( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_columns(void)
+/***********************************************************************/
+{
+#ifdef EMXVIDEO
+   int rows=0;
+#else
+   VIOMODEINFO modeInfo={0};
+#endif
+   int cols=0;
+   char *env_cols=NULL;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_columns() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   v_dimen (&cols, &rows);
+#else
+   modeInfo.cb = sizeof(modeInfo);
+   VioGetMode(&modeInfo, 0);
+   cols = modeInfo.col;
+#endif
+
+   env_cols = (char *)getenv("COLS");
+   if (env_cols != (char *)NULL)
+   {
+      cols = min(atoi(env_cols),cols);
+   }
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_columns() - returned: cols %d\n",cols);
+#endif
+   return(cols);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_mode() - Get the cursor start and stop scan lines.
+
+  PDCurses Description:
+   Gets the cursor type to begin in scan line startrow and end in
+   scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_cursor_mode( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_cursor_mode(void)
+/***********************************************************************/
+{
+#ifdef EMXVIDEO
+   int curstart=0, curend=0;
+#else
+   VIOCURSORINFO cursorInfo;
+#endif
+   short cmode=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_cursor_mode() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   v_getctype (&curstart, &curend);
+   cmode = ((curstart << 8) | (curend));
+#else
+   VioGetCurType (&cursorInfo, 0);
+/* I am not sure about this JGB */
+   cmode = ((cursorInfo.yStart << 8) | (cursorInfo.cEnd));
+#endif
+   return(cmode);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_font()  - Get the current font size
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This function returns the current font size.  This function only
+   works if the #define FAST_VIDEO is true.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   An ERR will be returned if FAST_VIDEO is not true.
+
+  Portability:
+   PDCurses int PDC_get_font( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_font(void)
+/***********************************************************************/
+{
+#ifdef EMXVIDEO
+   int   retval=0;
+#else
+   VIOMODEINFO modeInfo={0};
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_font() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   retval = v_hardware();
+   return (retval == V_MONOCHROME) ? 14 : (retval == V_COLOR_8) ? 8 : 12;
+#else
+   modeInfo.cb = sizeof(modeInfo);
+         /* set most parameters of modeInfo */
+   VioGetMode(&modeInfo, 0);
+   return ( modeInfo.vres / modeInfo.row);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_rows()  - Return number of screen rows.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the maximum number of rows supported by the display.
+   e.g.  25, 28, 43, 50, 60, 66...
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_rows( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_rows(void)
+/***********************************************************************/
+{
+#ifdef EMXVIDEO
+   int   cols=0;
+#else
+   VIOMODEINFO modeInfo={0};
+#endif
+   int   rows=0;
+   char *env_rows=NULL;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_rows() - called\n");
+#endif
+
+/* use the value from LINES environment variable, if set. MH 10-Jun-92 */
+/* and use the minimum of LINES and *ROWS.                MH 18-Jun-92 */
+#ifdef EMXVIDEO
+   v_dimen (&cols, &rows);
+#else
+   modeInfo.cb = sizeof(modeInfo);
+   VioGetMode(&modeInfo, 0);
+   rows = modeInfo.row;
+#endif
+   env_rows = (char *)getenv("LINES");
+   if (env_rows != (char *)NULL)
+      rows = min(atoi(env_rows),rows);
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_rows() - returned: rows %d\n",rows);
+#endif
+   return(rows);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_scrn_mode()   - Return the current BIOS video mode
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+
+  PDCurses Return Value:
+   Returns the current BIOS Video Mode Number.
+
+  PDCurses Errors:
+   The FLEXOS version of this routine returns an ERR.
+   The UNIX version of this routine returns an ERR.
+   The EMXVIDEO version of this routine returns an ERR.
+
+  Portability:
+   PDCurses int PDC_get_scrn_mode( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#if defined(EMXVIDEO)
+int PDC_get_scrn_mode( void )
+#else
+int PDC_get_scrn_mode( VIOMODEINFO *modeinfo )
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_scrn_mode() - called\n");
+#endif
+#ifdef EMXVIDEO
+   return(ERR);
+#else
+   VioGetMode ( modeinfo, 0 );
+   return(OK);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_query_adapter_type() - Determine PC video adapter type
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Thanks to Jeff Duntemann, K16RA for providing the impetus
+   (through the Dr. Dobbs Journal, March 1989 issue) for getting
+   the routines below merged into Bjorn Larsson's PDCurses 1.3...
+      -- frotz@dri.com  900730
+
+  PDCurses Return Value:
+   This function returns a macro identifier indicating the adapter
+   type.  See the list of adapter types in CURSPRIV.H.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_query_adapter_type( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#if defined(EMXVIDEO)
+int PDC_query_adapter_type( void )
+#else
+int PDC_query_adapter_type( VIOCONFIGINFO *configinfo )
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_query_adapter_type() - called\n");
+#endif
+#ifdef EMXVIDEO
+   return (v_hardware() == V_MONOCHROME) ? _UNIX_MONO : _UNIX_COLOR;
+#else
+   VioGetConfig( 0, configinfo, 0 );
+   return(OK);
+#endif
+}
diff -Naur gdb-6.8/pdcurses/os2/pdckbd.c stsgdb-6.8/pdcurses/os2/pdckbd.c
--- gdb-6.8/pdcurses/os2/pdckbd.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdckbd.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,738 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#if defined (CURSES__32BIT__) || defined(CSET2) || defined(TC)
+# include <signal.h>
+#else
+# define INCL_DOSSIGNALS
+# define INCL_NOCOMMON
+# include <bsedos.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCkbd  = "$Id: pdckbd.c,v 1.7 2005/12/11 01:07:19 wmcbrine Exp $";
+#endif
+
+/*******************************************************************************
+*  Table for key code translation of function keys in keypad mode
+*  These values are for strict IBM keyboard compatibles only
+*******************************************************************************/
+
+static int kptab[] =
+{
+ /* Normal Function Keys    */
+ 0x3b, KEY_F(1), 0x3c, KEY_F(2), 0x3d, KEY_F(3), 0x3e, KEY_F(4),
+ 0x3f, KEY_F(5), 0x40, KEY_F(6), 0x41, KEY_F(7), 0x42, KEY_F(8),
+ 0x43, KEY_F(9), 0x44, KEY_F(10),
+
+ /* Normal Keypad     */
+ 0x47, KEY_HOME, 0x48, KEY_UP,   0x49, KEY_PPAGE,
+ 0x4b, KEY_LEFT, 0x4c, KEY_B2,   0x4d, KEY_RIGHT,
+ 0x4f, KEY_END,  0x50, KEY_DOWN, 0x51, KEY_NPAGE,
+ 0x52, KEY_IC,   0x53, KEY_DC,
+
+ /* Shifted Keypad       */
+ 0xb0, KEY_SHOME, 0xb1, KEY_SUP,   0xb2, KEY_SPREVIOUS,
+ 0xb3, KEY_SLEFT, 0xb4, KEY_SRIGHT,
+ 0xb5, KEY_SEND,  0xb6, KEY_SDOWN, 0xb7, KEY_SNEXT,
+ 0xb8, KEY_SIC,   0xb9, KEY_SDC,
+
+ /* Shft-Function Keys   */
+ 0x54, KEY_F(13), 0x55, KEY_F(14), 0x56, KEY_F(15), 0x57, KEY_F(16),
+ 0x58, KEY_F(17), 0x59, KEY_F(18), 0x5a, KEY_F(19), 0x5b, KEY_F(20),
+ 0x5c, KEY_F(21), 0x5d, KEY_F(22),
+
+ /* Ctl-Function Keys    */
+ 0x5e, KEY_F(25), 0x5f, KEY_F(26), 0x60, KEY_F(27), 0x61, KEY_F(28),
+ 0x62, KEY_F(29), 0x63, KEY_F(30), 0x64, KEY_F(31), 0x65, KEY_F(32),
+ 0x66, KEY_F(33), 0x67, KEY_F(34),
+
+ /* Alt-Function Keys    */
+ 0x68, KEY_F(37), 0x69, KEY_F(38), 0x6a, KEY_F(39), 0x6b, KEY_F(40),
+ 0x6c, KEY_F(41), 0x6d, KEY_F(42), 0x6e, KEY_F(43), 0x6f, KEY_F(44),
+ 0x70, KEY_F(45), 0x71, KEY_F(46),
+
+ /* Control-Keypad       */
+ 0x77, CTL_HOME, 0x84, CTL_PGUP,
+ 0x73, CTL_LEFT, 0x74, CTL_RIGHT,
+ 0x75, CTL_END, 0x76, CTL_PGDN,
+
+ /* Alt-Numbers       */
+ 0x78, ALT_1, 0x79, ALT_2, 0x7a, ALT_3, 0x7b, ALT_4,
+ 0x7c, ALT_5, 0x7d, ALT_6, 0x7e, ALT_7, 0x7f, ALT_8,
+ 0x80, ALT_9, 0x81, ALT_0,
+
+ /* Extended codes       */
+ 0x85, KEY_F(11), 0x86, KEY_F(12), 0x87, KEY_F(23), 0x88, KEY_F(24),
+ 0x89, KEY_F(35), 0x8a, KEY_F(36), 0x8b, KEY_F(47), 0x8c, KEY_F(48),
+ 0x03, 0, /* NULL */
+
+#if defined(NUMKEYPAD)
+ 0xff, (int)'/',     0x0d, (int)'\n',
+ 0xfa, (int)'*',     0xfd, (int)'-',      0xfb, (int)'+',
+#else
+ 0xff, PADSLASH,     0x0d, PADENTER,      
+ 0xfa, PADSTAR,      0xfd, PADMINUS,      0xfb, PADPLUS,
+#endif
+
+ 0x0a, CTL_PADENTER,
+ 0xa6, ALT_PADENTER, 0x53, (int)'.',      0xfc, CTL_ENTER,
+ 0x93, CTL_DEL,      0x8f, CTL_PADCENTER, 0x90, CTL_PADPLUS,
+ 0x8e, CTL_PADMINUS, 0x95, CTL_PADSLASH,  0x96, CTL_PADSTAR,
+ 0x4e, ALT_PADPLUS,  0x4a, ALT_PADMINUS,  0xa4, ALT_PADSLASH,
+ 0x37, ALT_PADSTAR,  0x92, CTL_INS,       0xa2, ALT_INS,
+ 0xa3, ALT_DEL,      0x8d, CTL_UP,        0x91, CTL_DOWN,
+ 0x94, CTL_TAB,      0xa5, ALT_TAB,       0x82, ALT_MINUS,
+ 0x83, ALT_EQUAL,    0x99, ALT_PGUP,      0xa1, ALT_PGDN,
+ 0x9f, ALT_END,      0x98, ALT_UP,        0xa0, ALT_DOWN,
+ 0x9d, ALT_RIGHT,    0x9b, ALT_LEFT,      0x1c, ALT_ENTER,
+ 0x97, ALT_HOME,     0x01, ALT_ESC,       0x0e, ALT_BKSP,
+ 0x29, ALT_BQUOTE,   0x1a, ALT_LBRACKET,  0x1b, ALT_RBRACKET,
+ 0x27, ALT_SEMICOLON,0x28, ALT_FQUOTE,    0x33, ALT_COMMA,
+ 0x34, ALT_STOP,     0x35, ALT_FSLASH,    0x2b, ALT_BSLASH,
+
+ /* Alt-Alphabet      */
+ 0x1e, ALT_A, 0x30, ALT_B, 0x2e, ALT_C, 0x20, ALT_D,
+ 0x12, ALT_E, 0x21, ALT_F, 0x22, ALT_G, 0x23, ALT_H,
+ 0x17, ALT_I, 0x24, ALT_J, 0x25, ALT_K, 0x26, ALT_L,
+ 0x32, ALT_M, 0x31, ALT_N, 0x18, ALT_O, 0x19, ALT_P,
+ 0x10, ALT_Q, 0x13, ALT_R, 0x1f, ALT_S, 0x14, ALT_T,
+ 0x16, ALT_U, 0x2f, ALT_V, 0x11, ALT_W, 0x2d, ALT_X,
+ 0x15, ALT_Y, 0x2c, ALT_Z,
+ 0x0f, KEY_BTAB,
+ 0x100, (-1)
+};
+ /* End of kptab[]       */
+
+static unsigned long pdc_key_modifiers=0L;
+MOUSE_STATUS Trapped_Mouse_status;
+
+/*man-start*********************************************************************
+
+  PDC_get_input_fd() - Get file descriptor used for PDCurses input
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will return the file descriptor that PDCurses reads
+   its input from. It can be used for select().
+
+  PDCurses Return Value:
+   Returns a file descriptor.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int   PDC_get_input_fd( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+unsigned long PDC_get_input_fd(void)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_input_fd() - called\n");
+#endif
+   return (unsigned long)fileno(stdin);
+}
+
+#ifndef EMXVIDEO
+/***********************************************************************/
+int PDC_get_keyboard_info( KBDINFO *kbdinfo )
+/***********************************************************************/
+{
+   KBDINFO akbdinfo;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_keyboard_info() - called\n");
+#endif
+   akbdinfo.cb = sizeof(akbdinfo);
+   KbdGetStatus( &akbdinfo, 0 );
+   *kbdinfo = akbdinfo;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_keyboard_info(). cb: %x, fsMask: %x, chTurnAround: %x, fsInterim: %x, fsState: %x\n",
+      kbdinfo->cb,
+      kbdinfo->fsMask,
+      kbdinfo->chTurnAround,
+      kbdinfo->fsInterim,
+      kbdinfo->fsState);
+#endif
+   return OK;
+}
+
+/***********************************************************************/
+int PDC_set_keyboard_binary( void )
+/***********************************************************************/
+{
+   KBDINFO kbdinfo;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_keyboard_binary() - called\n");
+#endif
+   kbdinfo.cb = sizeof(kbdinfo);
+   KbdGetStatus( &kbdinfo, 0);
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_keyboard_binary() - before. cb: %x, fsMask: %x, chTurnAround: %x, fsInterim: %x, fsState: %x\n",
+      kbdinfo.cb,
+      kbdinfo.fsMask,
+      kbdinfo.chTurnAround,
+      kbdinfo.fsInterim,
+      kbdinfo.fsState);
+#endif
+   kbdinfo.fsMask = (kbdinfo.fsMask & ~KEYBOARD_ASCII_MODE) | KEYBOARD_BINARY_MODE;
+   KbdSetStatus( &kbdinfo, 0 );
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_keyboard_binary() - after. cb: %x, fsMask: %x, chTurnAround: %x, fsInterim: %x, fsState: %x\n",
+      kbdinfo.cb,
+      kbdinfo.fsMask,
+      kbdinfo.chTurnAround,
+      kbdinfo.fsInterim,
+      kbdinfo.fsState);
+#endif
+   return OK;
+}
+
+/***********************************************************************/
+int PDC_set_keyboard_default( void )
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_keyboard_default() - called\n");
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_keyboard_default(). cb: %x, fsMask: %x, chTurnAround: %x, fsInterim: %x, fsState: %x\n",
+      SP->kbdinfo.cb,
+      SP->kbdinfo.fsMask,
+      SP->kbdinfo.chTurnAround,
+      SP->kbdinfo.fsInterim,
+      SP->kbdinfo.fsState);
+#endif
+   KbdSetStatus( &SP->kbdinfo, 0 );
+   return OK;
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_check_bios_key()  - Check BIOS key data area for input
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will check the BIOS for any indication that
+   keystrokes are pending.
+
+  PDCurses Return Value:
+   Returns 1 if a keyboard character is available, 0 otherwise.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses bool  PDC_check_bios_key( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+bool PDC_check_bios_key(void)
+/***********************************************************************/
+{
+#if !defined(MSC) && !defined(EMXVIDEO)
+   KBDKEYINFO keyInfo={0};
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_check_bios_key() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   if (SP->tahead == -1)   /* Nothing typed yet */
+   {                    /* See if there's anything */
+      SP->tahead = _read_kbd (0, 0, 0);
+      if (SP->tahead == 0) /* Read additional */
+         SP->tahead = (_read_kbd (0, 1, 0) << 8);
+   }
+   return(SP->tahead != -1) ? 1 : 0;
+#else
+# if !defined(MSC)
+   KbdPeek(&keyInfo, 0);   /* peek at keyboard  */
+   return (keyInfo.fbStatus != 0);
+# else
+ return(kbhit());
+# endif
+#endif
+
+}         
+
+/*man-start*********************************************************************
+
+  PDC_get_bios_key() - Returns the next key available from the BIOS.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the next key code struck at the keyboard. If the low 8
+   bits are 0, the upper bits contain the extended character
+   code. If bit 0-7 are non-zero, the upper bits = 0.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_bios_key( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_get_bios_key(void)
+/***********************************************************************/
+{
+   int ascii=0,scan=0,key;
+#ifndef EMXVIDEO
+   KBDKEYINFO keyInfo={0};
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_bios_key() - called\n");
+#endif
+#ifdef EMXVIDEO
+   if (SP->tahead == -1)
+   {
+      SP->tahead = _read_kbd (0, 1, 0);
+      if (SP->tahead == 0) /* Read additional */
+         SP->tahead = (_read_kbd (0, 1, 0) << 8);
+   }
+   ascii = SP->tahead & 0xff;
+   scan  = SP->tahead >> 8;
+   pdc_key_modifiers = 0L;
+   SP->tahead = -1;
+#else
+/* PDC_get_keyboard_info( &SP->kbdinfo );
+   PDC_set_keyboard_binary(); */
+   KbdCharIn(&keyInfo, IO_WAIT, 0); /* get a character   */
+/* PDC_set_keyboard_default(); */
+   ascii = keyInfo.chChar;
+   scan = keyInfo.chScan;
+   pdc_key_modifiers = 0L;
+   if (SP->save_key_modifiers)
+   {
+      if (keyInfo.fsState & KBDSTF_ALT)
+         pdc_key_modifiers |= PDC_KEY_MODIFIER_ALT;
+      if (keyInfo.fsState & KBDSTF_CONTROL)
+         pdc_key_modifiers |= PDC_KEY_MODIFIER_CONTROL;
+      if (keyInfo.fsState & KBDSTF_NUMLOCK_ON)
+         pdc_key_modifiers |= PDC_KEY_MODIFIER_NUMLOCK;
+      if (keyInfo.fsState & KBDSTF_LEFTSHIFT
+      ||  keyInfo.fsState & KBDSTF_RIGHTSHIFT)
+         pdc_key_modifiers |= PDC_KEY_MODIFIER_SHIFT;
+   }
+#endif
+   if (scan == 0x1c && ascii == 0x0a)  /* ^Enter */
+      key = ((int) (0xfc00));
+   else if ((scan == 0x03 && ascii == 0x00)  /* ^@ - Null */
+        ||  (scan == 0xe0 && ascii == 0x0d)  /* PadEnter */
+        ||  (scan == 0xe0 && ascii == 0x0a)) /* ^PadEnter */
+           key = ((int) (ascii << 8));
+   else if ((scan == 0x37 && ascii == 0x2a)  /* Star */
+        ||  (scan == 0x4a && ascii == 0x2d)  /* Minus */
+        ||  (scan == 0x4e && ascii == 0x2b)  /* Plus */
+        ||  (scan == 0xe0 && ascii == 0x2f)) /* Slash */
+           key = ((int) ((ascii & 0x0f) | 0xf0) << 8);
+   else if (ascii == 0xe0 && scan == 0x47 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Home */
+           key = ((int) (0xb0 << 8));
+   else if (ascii == 0xe0 && scan == 0x48 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Up */
+           key = ((int) (0xb1 << 8));
+   else if (ascii == 0xe0 && scan == 0x49 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift PgUp */
+           key = ((int) (0xb2 << 8));
+   else if (ascii == 0xe0 && scan == 0x4b && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Left */
+           key = ((int) (0xb3 << 8));
+   else if (ascii == 0xe0 && scan == 0x4d && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Right */
+           key = ((int) (0xb4 << 8));
+   else if (ascii == 0xe0 && scan == 0x4f && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift End */
+           key = ((int) (0xb5 << 8));
+   else if (ascii == 0xe0 && scan == 0x50 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Down */
+           key = ((int) (0xb6 << 8));
+   else if (ascii == 0xe0 && scan == 0x51 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift PgDn */
+           key = ((int) (0xb7 << 8));
+   else if (ascii == 0xe0 && scan == 0x52 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Ins */
+           key = ((int) (0xb8 << 8));
+   else if (ascii == 0xe0 && scan == 0x53 && pdc_key_modifiers & PDC_KEY_MODIFIER_SHIFT) /* Shift Del */
+           key = ((int) (0xb9 << 8));
+   else if (ascii == 0x00 || ascii == 0xe0)
+           key = ((int) (scan << 8));
+   else
+      key = ((int) (ascii));
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_bios_key() - returned: %d(0x%x), ascii: %d(0x%x) scan: %d(0x%x)\n", key, key, ascii, ascii, scan, scan);
+#endif
+   return key;
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_ctrl_break()  - return OS control break state
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the current OS Control Break Check state.
+
+  PDCurses Return Value:
+   DOS:
+      This function returns TRUE on if the Control Break
+      Check is enabled otherwise FALSE is returned.
+
+   FLEXOS:
+      This function returns TRUE on if the Keyboard Mode
+      allows a break to bre reported otherwise FALSE is returned.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses bool  PDC_get_ctrl_break( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+bool  PDC_get_ctrl_break(void)
+/***********************************************************************/
+{
+#if defined(CURSES__32BIT__) || defined(CSET2) || defined(TC)
+#   if defined(TC)
+   void __cdecl (*oldAction) (int);
+#   else
+   void (*oldAction) (int);
+#   endif
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_ctrl_break() - called\n");
+#endif
+
+#if defined(CURSES__32BIT__) || defined(CSET2) || defined(TC)
+   oldAction = signal (SIGINT, SIG_DFL);
+   if (oldAction == SIG_ERR) return FALSE;
+   else signal (SIGINT, oldAction);
+   return (oldAction != SIG_IGN);
+#else
+   PFNSIGHANDLER oldHandler, oldHandler1;
+   USHORT oldAction, oldAction1;
+   /* get the current state, and set to ignore */
+   DosSetSigHandler((PFNSIGHANDLER) NULL, &oldHandler, &oldAction,
+      SIGA_IGNORE, SIG_CTRLBREAK);
+   /* restore the previous state */
+   DosSetSigHandler(oldHandler, &oldHandler1, &oldAction1,
+      oldAction, SIG_CTRLBREAK);
+   return(oldAction != SIGA_IGNORE);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_rawgetch()  - Returns the next uninterpreted character (if available).
+
+  PDCurses Description:
+   Gets a character without any interpretation at all and returns
+   it. If keypad mode is active for the designated window,
+   function key translation will be performed.  Otherwise,
+   function keys are ignored.  If nodelay mode is active in the
+   window, then PDC_rawgetch() returns -1 if no character is
+   available.
+
+   WARNING:  It is unknown whether the FUNCTION key translation
+        is performed at this level. --Frotz 911130 BUG
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int   PDC_rawgetch( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_rawgetch(void)
+/***********************************************************************/
+{
+extern   WINDOW*  _getch_win_;
+/* extern   WINDOW*  w;*/   /* w defined in wgetch() as static - _getch_win_ */
+                        /* is the same window - all references to w changed*/
+                        /* to _getch_win_ - marked with @@ */
+
+   int   c=0;
+   int   oldc=0;
+   bool  return_immediately;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_rawgetch() - called\n");
+#endif
+   if (_getch_win_ == (WINDOW *)NULL)   /* @@ */
+      return( -1 );
+
+   if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+      return_immediately = TRUE;
+   else
+      return_immediately = FALSE;
+
+   if (return_immediately && !PDC_breakout())
+      return( -1 );
+
+   while (1)      /* loop to get valid char */
+   {
+      c = PDC_get_bios_key();
+      oldc = c;
+      /*
+       * Return the key if it is not a special key.
+       */
+      if ((c = PDC_validchar(c)) >= 0)
+      {     /* get & check next char */
+         return( c );
+      }
+      if (_getch_win_->_use_keypad)
+         return( oldc );
+   }
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_ctrl_break()  - Enables/Disables the host OS BREAK key check.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Enables/Disables the host OS BREAK key check. If the supplied setting
+   is TRUE, this enables CTRL/C and CTRL/BREAK to abort the process.
+   If FALSE, CTRL/C and CTRL/BREAK are ignored.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_set_ctrl_break( bool setting );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_set_ctrl_break(bool setting)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_ctrl_break() - called. Setting: %d\n",setting);
+#endif
+#if defined (CURSES__32BIT__) || defined (CSET2) || defined(TC)
+   signal (SIGINT, (setting?SIG_DFL:SIG_IGN));
+   signal (SIGBREAK, (setting?SIG_DFL:SIG_IGN));
+   return( OK );
+#else
+   PFNSIGHANDLER oldHandler;
+   USHORT oldAction, Action;
+
+   /* turn off control C checking */
+   if (setting)
+      Action = SIGA_KILL;
+   else
+      Action = SIGA_IGNORE;
+   DosSetSigHandler((PFNSIGHANDLER) NULL, &oldHandler, &oldAction,
+      Action, SIG_CTRLBREAK);
+   DosSetSigHandler((PFNSIGHANDLER) NULL, &oldHandler, &oldAction,
+      Action, SIG_CTRLC);
+   return( OK );
+#endif
+
+}
+
+/*man-start*********************************************************************
+
+  PDC_sysgetch()  - Return a character using default system routines.
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Gets a character without normal ^S, ^Q, ^P and ^C interpretation
+   and returns it.  If keypad mode is active for the designated
+   window, function key translation will be performed. Otherwise,
+   function keys are ignored. If nodelay mode is active in the
+   window, then sysgetch() returns -1 if no character is
+   available.
+
+  PDCurses Return Value:
+   This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses int   PDC_sysgetch( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_sysgetch(void)
+/***********************************************************************/
+{
+extern   WINDOW*  _getch_win_;
+/* extern   WINDOW*  w;*/   /* w defined in wgetch() as static - _getch_win_ */
+                        /* is the same window - all references to w changed*/
+                        /* to _getch_win_ - marked with @@ */
+
+   int c=0;
+   bool  return_immediately;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_sysgetch() - called\n");
+#endif
+   if (_getch_win_ == (WINDOW *)NULL)  /* @@ */
+      return (-1);
+
+   if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+      return_immediately = TRUE;
+   else
+      return_immediately = FALSE;
+
+   if (return_immediately && !PDC_breakout())
+      return (-1);
+
+   while (1)
+   {
+      c = PDC_get_bios_key();
+      /*
+       * Return the key if it is not a special key.
+       */
+      if ((unsigned int)c < 256)
+         return(c);
+      if ((c = PDC_validchar(c)) >= 0)
+      {
+         return (c);    /* get & check next char */
+      }
+   }
+}
+
+/*man-start*********************************************************************
+
+  PDC_validchar() - validate/translate passed character
+  
+  PDCurses Description:
+   This is a private PDCurses function.
+  
+   Checks that 'c' is a valid character, and if so returns it,
+   with function key translation applied if 'w' has keypad mode
+   set.  If char is invalid, returns -1.
+  
+  PDCurses Return Value:
+   This function returns -1 if the passed character is invalid, or
+   the WINDOW* 'w' is NULL, or 'w's keypad is not active.
+  
+   This function returns 0 under Flexos if the passed character
+   is 0x0300.  (-:Forget why.  --Frotz 911130:-)
+  
+   Otherwise, this function returns the PDCurses equivalent of the
+   passed character.  See the function key and key macros in
+   <curses.h>
+  
+  PDCurses Errors:
+   There are no errors defined for this routine.
+  
+  Portability:
+   PDCurses int   PDC_validchar( int c );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_validchar(int c)
+/***********************************************************************/
+{
+extern   WINDOW*  _getch_win_;
+/* extern   WINDOW*  w;*/   /* w defined in wgetch() as static - _getch_win_ */
+                        /* is the same window - all references to w changed*/
+                        /* to _getch_win_ - marked with @@ */
+
+   int *scanp=NULL;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_validchar() - called. c: %d\n",c);
+#endif
+   if (_getch_win_ == (WINDOW *)NULL)
+      return (-1);   /* bad window pointer     */
+
+   if ((unsigned int)c < 256) return (c);  /* normal character */
+   if (!(_getch_win_->_use_keypad)) return (-1); /* skip if keys if !keypad mode */
+
+   /*
+   * Under DOS, extended keys are in the upper byte.  Shift down for a
+   * comparison.
+   */
+   c = (c >> 8) & 0xFF;
+
+   scanp = kptab;
+   while (*scanp > 0)   /* search for value      */
+   {        /* (stops on table entry 0x100) */
+      if (*scanp++ == c)
+      {
+         return (*scanp);  /* found, return it */
+      }
+      scanp++;
+   }
+   return( -1 );     /* not found, invalid */
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_key_modifiers()  - Returns the keyboard modifier(s) at time of last getch()
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the keyboard modifiers effective at the time of the last getch()
+   call only if PDC_save_key_modifiers(TRUE) has been called before the
+   getch();
+   Use the macros; PDC_KEY_MODIFIER_* to determine which modifier(s)
+   were set.
+
+  PDCurses Return Value:
+   This function returns the modifiers.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_key_modifiers( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+unsigned long  PDC_get_key_modifiers(void)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_key_modifiers() - called\n");
+#endif
+   return(pdc_key_modifiers);
+}
diff -Naur gdb-6.8/pdcurses/os2/pdcprint.c stsgdb-6.8/pdcurses/os2/pdcprint.c
--- gdb-6.8/pdcurses/os2/pdcprint.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcprint.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,91 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCprint  = "$Id: pdcprint.c,v 1.3 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+#if !defined (CURSES__32BIT__) && !defined(CSET2) && !defined(MSC) &&!defined(TC)
+#define INCL_DOS
+#include <bsedos.h>
+#endif
+
+char Printer[]="LPT1:";
+
+/*man-start*********************************************************************
+
+  PDC_print()	- Provides primitive access to the BIOS printer functions
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Implements write/init/read printer services at the BIOS level.
+
+ 	This provides the basic support that PDCurses needs to dump the
+ 	contents of windows or pads to the printer attached to the BIOS
+ 	printer port.
+
+  PDCurses Return Value:
+ 	See the BIOS INT 0x17 specifications.
+
+  PDCurses Errors:
+ 	See the BIOS INT 0x17 specifications.
+
+  Portability:
+ 	PDCurses	int PDC_print( int cmd, int byte, int port );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_print(int cmd, int byte, int port)
+#else
+int	PDC_print(cmd,byte,port)
+int cmd;
+int byte;
+int port;
+#endif
+/***********************************************************************/
+{
+#if !defined (CURSES__32BIT__) && !defined(CSET2) && !defined(TC)
+	HFILE Lpt;
+	USHORT Action=0;
+	USHORT NoWritten=0;
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_print() - called\n");
+#endif
+
+#if !defined (CURSES__32BIT__) && !defined(CSET2) && !defined(TC)
+	if (DosOpen((PSZ)Printer, &Lpt, &Action, 0,0,0,0,0) != 0)
+		return(ERR);
+	DosWrite(Lpt,&byte,1,&NoWritten);
+	DosClose(Lpt);
+	return(NoWritten == 1);
+#else
+	return (OK);
+#endif
+}
diff -Naur gdb-6.8/pdcurses/os2/pdcscrn.c stsgdb-6.8/pdcurses/os2/pdcscrn.c
--- gdb-6.8/pdcurses/os2/pdcscrn.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcscrn.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,343 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#define INCL_DOSMISC
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCscrn  = "$Id: pdcscrn.c,v 1.4 2005/12/11 05:51:24 wmcbrine Exp $";
+#endif
+
+#ifdef EMXVIDEO
+   static unsigned char *saved_screen = NULL;
+   static int saved_lines = 0;
+   static int saved_cols = 0;
+#else
+   static PCH saved_screen = NULL;
+   static USHORT saved_lines = 0;
+   static USHORT saved_cols = 0;
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_scr_close() - Internal low-level binding to close the physical screen
+
+  PDCurses Description:
+   This function provides a low-level binding for the Flexos
+   platform which must close the screen before writing to it.
+   This is a nop for the DOS platform.
+
+   This function is provided in order to reset the FlexOS 16 bit
+   character set for input rather than the limited input
+   character set associated with the VT52.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+   The DOS platform will never fail.  The Flexos platform may fail
+   depending on the ability to close the current virtual console in
+   8 (as opposed to 16) bit mode.
+
+  Portability:
+   PDCurses int   PDC_scr_close( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_scr_close(void)
+/***********************************************************************/
+{
+   char *ptr;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scr_close() - called\n");
+#endif
+#ifdef EMXVIDEO
+   ptr = getenv("PDC_RESTORE_SCREEN");
+#else
+   if ( DosScanEnv( "PDC_RESTORE_SCREEN", (PSZ *)&ptr ) )
+      ptr = NULL;
+#endif
+   if (ptr != NULL)
+   {
+      if (saved_screen == NULL)
+         return( OK );
+#ifdef EMXVIDEO
+      v_putline(saved_screen,0,0,saved_lines*saved_cols);
+#else
+      VioWrtCellStr(saved_screen,saved_lines*saved_cols*2,0,0,(HVIO)NULL);
+#endif
+      free(saved_screen);
+      saved_screen = NULL;
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_scrn_modes_equal()   - Decide if two screen modes are equal
+
+  PDCurses Description:
+   Mainly required for OS/2. It decides if two screen modes
+        (VIOMODEINFO structure) are equal. Under DOS it just compares
+        two integers
+
+  PDCurses Return Value:
+   This function returns TRUE if equal else FALSe.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_scrn_modes_equal( int mode1, int mode2 );
+   OS2 PDCurses   int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#if !defined( EMXVIDEO )
+bool PDC_scrn_modes_equal(VIOMODEINFO mode1, VIOMODEINFO mode2)
+#else
+bool PDC_scrn_modes_equal(int mode1, int mode2)
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scrn_modes_equal() - called\n");
+#endif
+
+#if !defined( EMXVIDEO )
+   return ((mode1.cb == mode2.cb) && (mode1.fbType == mode2.fbType)
+      && (mode1.color == mode2.color) && (mode1.col == mode2.col)
+      && (mode1.row == mode2.row) && (mode1.hres == mode2.vres)
+      && (mode1.vres == mode2.vres) );
+#else
+   return (mode1 == mode2);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_scr_open()  - Internal low-level binding to open the physical screen
+
+  PDCurses Description:
+   This function provides a low-level binding for the Flexos
+   platform which must open the screen before writing to it.
+
+   This function is provided in order to access the FlexOS 16 bit
+   character set for input rather than the limited input
+   character set associated with the VT52.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+   The DOS platform will never fail.  The Flexos platform may fail
+   depending on the ability to open the current virtual console in
+   8 (as opposed to 16) bit mode.
+
+  Portability:
+   PDCurses int   PDC_scr_open( SCREEN* internal, bool echo );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_scr_open(SCREEN *internal, bool echo)
+/***********************************************************************/
+{
+   char *ptr;
+#if !defined( EMXVIDEO )
+   USHORT totchars=0;
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scr_open() - called. internal: %x, echo: %d\n", internal, echo);
+#endif
+   internal->orig_attr   = 0;
+   internal->orig_emulation = 0;
+   PDC_get_cursor_pos(&internal->cursrow, &internal->curscol);
+   internal->direct_video  = TRUE;     /* Assume that we can         */
+   internal->autocr  = TRUE;     /* lf -> crlf by default      */
+   internal->raw_out = FALSE; /* tty I/O modes        */
+   internal->raw_inp = FALSE; /* tty I/O modes        */
+   internal->cbreak  = TRUE;
+   internal->save_key_modifiers  = FALSE;
+   internal->return_key_modifiers   = FALSE;
+   internal->echo    = echo;
+   internal->refrbrk = FALSE;  /* no premature end of refresh*/
+   internal->video_page = 0;     /* Current Video Page         */
+   internal->visible_cursor= TRUE;     /* Assume that it is visible  */
+   internal->cursor  = PDC_get_cursor_mode();
+#if defined(EMXVIDEO)
+   internal->tahead  = -1;
+#endif
+
+#if !defined(EMXVIDEO)
+   (void)PDC_query_adapter_type( &internal->adapter );
+   (void)PDC_get_scrn_mode( &internal->scrnmode );
+   (void)PDC_get_keyboard_info( &internal->kbdinfo );
+# ifdef PDCDEBUG1
+   if (trace_on) PDC_debug("PDC_scr_open() - after PDC_get_keyboard_info(). cb: %x, fsMask: %x, chTurnAround: %x, fsInterim: %x, fsState: %x\n",
+      SP->kbdinfo.cb,
+      SP->kbdinfo.fsMask,
+      SP->kbdinfo.chTurnAround,
+      SP->kbdinfo.fsInterim,
+      SP->kbdinfo.fsState);
+# endif
+   /*
+    * Now set the keyboard into binary mode
+    */
+   (void)PDC_set_keyboard_binary();
+#else
+   internal->adapter = PDC_query_adapter_type();
+   if ( internal->adapter == _UNIX_MONO )
+      internal->mono = TRUE;
+#endif
+
+   internal->orig_font = internal->font   = PDC_get_font();
+   internal->lines      = PDC_get_rows();
+   internal->cols    = PDC_get_columns();
+   internal->audible = TRUE;
+   internal->visibility = 1;
+   internal->orig_cursor = internal->cursor;
+   internal->orgcbr = PDC_get_ctrl_break();
+   internal->blank = ' ';
+   internal->resized = FALSE;
+   internal->shell = FALSE;
+   internal->_trap_mbe = 0L;
+   internal->_map_mbe_to_key = 0L;
+   internal->linesrippedoff = 0;
+   internal->linesrippedoffontop = 0;
+   internal->delaytenths = 0;
+   internal->sizeable = TRUE;
+   /*
+    * This code for preserving the current screen...
+    */
+#ifdef EMXVIDEO
+   ptr = getenv("PDC_RESTORE_SCREEN");
+#else
+   if ( DosScanEnv( "PDC_RESTORE_SCREEN", (PSZ *)&ptr ) )
+      ptr = NULL;
+#endif
+   if (ptr != NULL)
+   {
+      saved_lines = internal->lines;
+      saved_cols = internal->cols;
+#ifdef EMXVIDEO
+      if ((saved_screen = (unsigned char*)malloc(2*saved_lines*saved_cols*sizeof(unsigned char))) == NULL)
+         return(ERR);
+      v_getline(saved_screen,0,0,saved_lines*saved_cols);
+#else
+      if ((saved_screen = (PCH)malloc(2*saved_lines*saved_cols*sizeof(unsigned char))) == NULL)
+         return(ERR);
+      totchars = saved_lines*saved_cols*2;
+      VioReadCellStr((PCH)saved_screen,&totchars,0,0,(HVIO)NULL);
+#endif
+   }
+
+#ifdef EMXVIDEO
+   ptr = getenv("PDC_PRESERVE_SCREEN");
+#else
+   if ( DosScanEnv( "PDC_PRESERVE_SCREEN", (PSZ *)&ptr ) )
+      ptr = NULL;
+#endif
+   if (ptr != NULL)
+      internal->_preserve = TRUE;
+   else
+      internal->_preserve = FALSE;
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_resize_screen()   - Internal low-level function to resize screen
+
+  PDCurses Description:
+   This function provides a means for the application program to
+   resize the overall dimensions of the screen.  Under DOS and OS/2
+   the application can tell PDCurses what size to make the screen;
+   under X11, resizing is done by the user and this function simply
+   adjusts its internal structures to fit the new size.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+
+  Portability:
+   PDCurses int   PDC_resize_screen( int, int );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_resize_screen(int nlines, int ncols)
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+   VIOMODEINFO modeInfo={0};
+   USHORT result=0;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+
+#ifdef EMXVIDEO
+   return (ERR);
+#else
+   modeInfo.cb = sizeof(modeInfo);
+   /* set most parameters of modeInfo */
+   VioGetMode(&modeInfo, 0);
+   modeInfo.fbType = 1;
+   modeInfo.row = nlines;
+   modeInfo.col = ncols;
+   result = VioSetMode(&modeInfo, 0);
+   LINES = PDC_get_rows();
+   COLS = PDC_get_columns();
+   return ((result == 0) ? OK : ERR);
+#endif
+}
+
+#if !defined(EMXVIDEO)
+/***********************************************************************/
+int PDC_reset_shell_mode( void )
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_reset_shell_mode() - called.\n");
+#endif
+   PDC_set_keyboard_default();
+   return OK;
+}
+
+/***********************************************************************/
+int PDC_reset_prog_mode( void )
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_reset_prog_mode() - called.\n");
+#endif
+   PDC_set_keyboard_binary();
+   return OK;
+}
+#endif
diff -Naur gdb-6.8/pdcurses/os2/pdcsetsc.c stsgdb-6.8/pdcurses/os2/pdcsetsc.c
--- gdb-6.8/pdcurses/os2/pdcsetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcsetsc.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,360 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+#  include <string.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCsetsc  = "$Id: pdcsetsc.c,v 1.4 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_set_80x25() - force a known screen state: 80x25 text mode.
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Forces the appropriate 80x25 alpha mode given the display adapter.
+
+   Since we currently do not support changing the virtual console size,
+   this routine is a NOP under Flexos.
+
+  PDCurses Return Value:
+   This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses int   PDC_set_80x25( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_set_80x25(void)
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+   VIOMODEINFO modeInfo={0};
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_80x25() - called\n");
+#endif
+
+#ifndef EMXVIDEO
+   modeInfo.cb = sizeof(modeInfo);
+   /* set most parameters of modeInfo */
+   VioGetMode(&modeInfo, 0);
+   modeInfo.fbType = 1;
+   VioSetMode(&modeInfo, 0);
+#endif
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_cursor_mode() - Set the cursor start and stop scan lines.
+
+  PDCurses Description:
+   Sets the cursor type to begin in scan line startrow and end in
+   scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_set_cursor_mode( int startrow, int endrow );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_set_cursor_mode( int startrow, int endrow )
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+   VIOCURSORINFO cursorInfo={0};
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_cursor_mode() - called: startrow %d endrow %d\n",startrow,endrow);
+#endif
+
+#ifdef EMXVIDEO
+   if (endrow <= startrow)
+      v_hidecursor();
+   else
+      v_ctype (startrow, endrow);
+   return( OK );
+#else
+   cursorInfo.yStart = startrow;
+   cursorInfo.cEnd = endrow;
+   cursorInfo.cx = 1;
+   cursorInfo.attr = 0;
+   return (VioSetCurType (&cursorInfo, 0) == 0);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_font()  - sets the current font size
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   This routine sets the current font size, if the adapter allows
+   such a change.
+
+  PDCurses Return Value:
+   This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+   It is an error to attempt to change the font size on a "bogus"
+   adapter.  The reason for this is that we have a known video
+   adapter identity problem.  e.g. Two adapters report the same
+   identifying characteristics.
+
+   It is also an error to attempt to change the size of the Flexos
+   console (as there is currently no support for that).
+
+  Portability:
+   PDCurses int   PDC_set_font( int size );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_set_font(int size)
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+   VIOMODEINFO modeInfo={0};
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_font() - called\n");
+#endif
+
+#ifndef EMXVIDEO
+   if (SP->sizeable && (SP->font != size))
+   {
+      modeInfo.cb = sizeof(modeInfo);
+      /* set most parameters of modeInfo */
+      VioGetMode(&modeInfo, 0);
+      modeInfo.cb = 8;     /* ignore horiz an vert resolution */
+      modeInfo.row = modeInfo.vres / size;
+      VioSetMode(&modeInfo, 0);
+   }
+   if (SP->visible_cursor)
+      PDC_cursor_on();
+   else
+      PDC_cursor_off();
+   SP->font = PDC_get_font();
+#endif
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_rows()  - sets the physical number of rows on screen
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   This routine attempts to set the number of rows on the physical
+   screen to the passed value.
+
+  PDCurses Return Value:
+   This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+   It is an error to attempt to change the screen size on a "bogus"
+   adapter.  The reason for this is that we have a known video
+   adapter identity problem.  e.g. Two adapters report the same
+   identifying characteristics.
+
+   It is also an error to attempt to change the size of the Flexos
+   console (as there is currently no support for that).
+
+  Portability:
+   PDCurses int   PDC_set_rows( int rows );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int PDC_set_rows(int rows)
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+   VIOMODEINFO modeInfo={0};
+   USHORT result=0;
+#endif
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_rows() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   return (ERR);
+#else
+   modeInfo.cb = sizeof(modeInfo);
+   /* set most parameters of modeInfo */
+   VioGetMode(&modeInfo, 0);
+   modeInfo.fbType = 1;
+   modeInfo.row = rows;
+   result = VioSetMode(&modeInfo, 0);
+   SP->font = PDC_get_font();
+   LINES = PDC_get_rows();
+   COLS = PDC_get_columns();
+   return ((result == 0) ? OK : ERR);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_scrn_mode()   - Set BIOS Video Mode
+
+  PDCurses Description:
+   Sets the BIOS Video Mode Number ONLY if it is different from
+   the current video mode.  This routine is for DOS systems only.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_set_scrn_mode( int new_mode );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#if !defined( EMXVIDEO )
+int PDC_set_scrn_mode(VIOMODEINFO new_mode)
+#else
+int PDC_set_scrn_mode(int new_mode)
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_scrn_mode() - called\n");
+#endif
+
+#ifdef EMXVIDEO
+   return ( OK );
+#else
+   if (VioSetMode (&new_mode, 0) != 0)
+   {
+      SP->font = PDC_get_font();
+      memcpy((char *)&SP->scrnmode,(char *)&new_mode,sizeof(VIOMODEINFO));
+      LINES = PDC_get_rows();
+      COLS = PDC_get_columns();
+      return( OK );
+   }
+   else
+      return (ERR);
+#endif
+}
+/***********************************************************************/
+int PDC_curs_set(int visibility)
+/***********************************************************************/
+{
+#ifndef EMXVIDEO
+ VIOCURSORINFO pvioCursorInfo;
+#endif
+ int start=0,end=0;
+ int ret_vis=0,hidden=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+   ret_vis = SP->visibility;
+   SP->visibility = visibility;
+
+   switch(visibility)
+   {
+      case 0:  /* invisible */
+#ifdef EMXVIDEO
+         start = end = 0;
+#else
+         start = SP->font / 4;
+         end = SP->font;
+#endif
+         hidden = (-1);
+         break;
+      case 2:  /* highly visible */
+         start = 2;   /* almost full-height block */
+         end = SP->font-1;
+         break;
+      default:  /* normal visibility */
+         start = SP->font - (SP->font / 4);
+         end = SP->font-1;
+         break;
+   }
+
+#ifdef EMXVIDEO
+   if (!visibility)
+      v_hidecursor();
+   else
+      v_ctype (start, end);
+#else
+   pvioCursorInfo.yStart = (USHORT)start;
+   pvioCursorInfo.cEnd = (USHORT)end;
+   pvioCursorInfo.cx = (USHORT)1;
+   pvioCursorInfo.attr = hidden;
+   VioSetCurType((PVIOCURSORINFO)&pvioCursorInfo,0);
+#endif
+   return( ret_vis );
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_title() - Set window title
+
+  PDCurses Description:
+   Sets the title of the window in which the curses program is running.
+   This function may not do anything on some platforms.
+
+  PDCurses Return Value:
+   N/A
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses void PDC_set_title( char *title );
+
+**man-end**********************************************************************/
+/***********************************************************************/
+void PDC_set_title(char *title)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_title() - called:<%s>\n",title);
+#endif
+   return;
+}
diff -Naur gdb-6.8/pdcurses/os2/pdcurses.def stsgdb-6.8/pdcurses/os2/pdcurses.def
--- gdb-6.8/pdcurses/os2/pdcurses.def	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/pdcurses.def	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,184 @@
+LIBRARY     CURSES
+
+DESCRIPTION 'PDcurses 2.7 Dynamic Linking library'
+
+PROTMODE
+
+DATA        MULTIPLE READWRITE LOADONCALL
+
+CODE        LOADONCALL
+
+EXPORTS     
+            SP
+            LINES
+            COLS
+            COLORS
+            COLOR_PAIRS
+            PDC_chadd
+            PDC_chins
+            PDC_freeclipboard
+            PDC_getclipboard
+            PDC_setclipboard
+            PDC_clearclipboard
+            PDC_set_title
+            stdscr
+            curscr
+            trace_on
+            baudrate                       
+            beep                           
+            border                         
+            box                            
+            can_change_color               
+            cbreak                         
+            clearok                        
+            color_content                  
+            color_set
+            copywin                        
+            curs_set                       
+            def_prog_mode                  
+            def_shell_mode                 
+            delay_output                   
+            delscreen
+            delwin                         
+            doupdate                       
+            echo                           
+            endwin                         
+            erasechar                      
+            filter
+            flash                          
+            flushinp                       
+            getwin
+            has_colors                     
+            has_ic                         
+            has_il                         
+            idlok                          
+            init_color                     
+            init_pair
+            initscr
+            intrflush                      
+            is_termresized
+            keyname                        
+            keypad                         
+            killchar                       
+            leaveok                        
+            longname                       
+            meta                           
+            mvcur                          
+            mvprintw                       
+            mvscanw                        
+            mvwin                          
+            mvwinsertln                    
+            mvwprintw                      
+            mvwscanw                       
+            newpad                         
+            newwin                         
+            nl                             
+            nocbreak                       
+            nodelay                        
+            noecho                         
+            nonl                           
+            noqiflush
+            noraw                          
+            notimeout
+            overlay                        
+            overwrite                      
+            pair_content                   
+            pnoutrefresh                   
+            prefresh                       
+            printw                         
+            putwin
+            qiflush
+            raw                            
+            raw_output                     
+            refresh                        
+            resetty                        
+            reset_prog_mode                
+            reset_shell_mode               
+            resize_term
+            resize_window
+            savetty                        
+            scanw                          
+            scr_dump
+            scr_init
+            scr_restore
+            scr_set
+            scroll                         
+            scrollok                       
+            setscrreg                      
+            set_term                       
+            slk_attroff
+            slk_attron
+            slk_attrset
+            slk_clear
+            slk_color
+            slk_init
+            slk_label
+            slk_noutrefresh
+            slk_refresh
+            slk_restore
+            slk_set
+            slk_touch
+            standend                       
+            standout                       
+            start_color                    
+            subwin                         
+            timeout
+            touchline                      
+            touchwin                       
+            traceoff                       
+            traceon                        
+            typeahead                      
+            unctrl                         
+            use_env
+            vidattr
+            vidputs
+            waddch                         
+            waddchnstr
+            waddstr                        
+            wattroff                       
+            wattron                        
+            wattrset                       
+            wbkgd
+            wborder                        
+            wclear                         
+            wclrtobot                      
+            wclrtoeol                      
+            wcolor_set
+            wdelch                         
+            wdeleteln                      
+            werase                         
+            wgetch                         
+            wgetstr                        
+            whline
+            winch                          
+            winsch                         
+            winsertln                      
+            wmove                          
+            wnoutrefresh                   
+            wordchar                       
+            wprintw                        
+            wrefresh                       
+            wscanw                         
+            wsetscrreg                     
+            wstandend                      
+            wstandout                      
+            wtimeout
+            wtouchln
+            wvline
+            cur_term
+            del_curterm
+            putp
+            restartterm
+            set_curterm
+            setterm
+            setupterm
+            tgetent
+            tgetflag
+            tgetnum
+            tgetstr
+            tgoto
+            tigetflag
+            tigetnum
+            tigetstr
+            tparm
+            tputs
diff -Naur gdb-6.8/pdcurses/os2/README stsgdb-6.8/pdcurses/os2/README
--- gdb-6.8/pdcurses/os2/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/README	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,19 @@
+
+                        Welcome to PDCurses
+
+ Contents
+ --------
+ This directory contains core PDCurses source code files specific to
+ the OS/2 platform.
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory are released to the Public Domain.
+
+
+ Acknowlegements
+ ---------------
+
+ Generic OS/2 port was provided by ????
diff -Naur gdb-6.8/pdcurses/os2/wccos2.lrf stsgdb-6.8/pdcurses/os2/wccos2.lrf
--- gdb-6.8/pdcurses/os2/wccos2.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/wccos2.lrf	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,48 @@
++addch.obj
++addchstr.obj
++addstr.obj
++attr.obj
++beep.obj
++bkgd.obj
++border.obj
++clear.obj
++color.obj
++delch.obj
++deleteln.obj
++getch.obj
++getstr.obj
++getyx.obj
++inch.obj 
++inchstr.obj
++initscr.obj
++inopts.obj
++insch.obj
++insstr.obj
++instr.obj
++kernel.obj
++mouse.obj
++move.obj 
++outopts.obj
++overlay.obj
++pad.obj  
++printw.obj
++refresh.obj
++scanw.obj
++scr_dump.obj
++scroll.obj
++slk.obj  
++termattr.obj
++terminfo.obj
++touch.obj
++util.obj 
++window.obj
++pdcdebug.obj
++pdcdisp.obj
++pdcgetsc.obj
++pdckbd.obj
++pdcprint.obj
++pdcscrn.obj
++pdcsetsc.obj
++pdcutil.obj
++pdcwin.obj
++pdcclip.obj
diff -Naur gdb-6.8/pdcurses/os2/wccos2.mak stsgdb-6.8/pdcurses/os2/wccos2.mak
--- gdb-6.8/pdcurses/os2/wccos2.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/os2/wccos2.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,380 @@
+################################################################################
+#
+# Watcom WMAKE Makefile for PDCurses library - OS/2 Open Watcom 1.1+
+#
+# Usage: wmake -f [path\]wccos2.mak [DEBUG=Y] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, and/or edit the
+# lines below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(%PDCURSES_SRCDIR)
+CCINCDIR		=k:\h
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\os2
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= wcc386
+TARGET=os2v2
+
+!ifeq DEBUG Y
+CFLAGS  = /d2 /DPDCDEBUG
+LDFLAGS = DEBUG ALL
+!else
+CFLAGS  = /oneatx /wcd=302
+LDFLAGS =
+!endif
+
+CPPFLAGS = /i=$(PDCURSES_HOME) /i=$(CCINCDIR)
+
+CCFLAGS = /bt=$(TARGET) /bm /3s /wx /s /zq /mf $(CFLAGS) $(CPPFLAGS)
+
+LINK		= wlink
+
+LIBEXE = wlib /q /n /b /c
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean
+	-del *.obj
+	-del *.lib
+	-del *.exe
+	-del *.err
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =    &
+addch.obj    &
+addchstr.obj &
+addstr.obj   &
+attr.obj     &
+beep.obj     &
+bkgd.obj     &
+border.obj   &
+clear.obj    &
+color.obj    &
+delch.obj    &
+deleteln.obj &
+getch.obj    &
+getstr.obj   &
+getyx.obj    &
+inch.obj     &
+inchstr.obj  &
+initscr.obj  &
+inopts.obj   &
+insch.obj    &
+insstr.obj   &
+instr.obj    &
+kernel.obj   &
+mouse.obj    &
+move.obj     &
+outopts.obj  &
+overlay.obj  &
+pad.obj      &
+printw.obj   &
+refresh.obj  &
+scanw.obj    &
+scr_dump.obj &
+scroll.obj   &
+slk.obj      &
+termattr.obj &
+terminfo.obj &
+touch.obj    &
+util.obj     &
+window.obj
+
+PDCOBJS =      &
+pdcclip.obj    &
+pdcdebug.obj   &
+pdcdisp.obj    &
+pdcgetsc.obj   &
+pdckbd.obj     &
+pdcprint.obj   &
+pdcscrn.obj    &
+pdcsetsc.obj   &
+pdcutil.obj    &
+pdcwin.obj
+
+PANOBJS =     &
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\wccos2.lrf
+
+panel.lib : $(PANOBJS)
+	echo +$(PANOBJS)   >  lib.rsp
+	$(LIBEXE) $@ @lib.rsp
+	del lib.rsp
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name firework.exe    >> demos.lnk
+	echo file firework.obj    >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name newdemo.exe     >> demos.lnk
+	echo file newdemo.obj     >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name ptest.exe       >> demos.lnk
+	echo file ptest.obj       >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	echo library $(LIBPANEL)  >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name testcurs.exe    >> demos.lnk
+	echo file testcurs.obj    >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name tuidemo.exe     >> demos.lnk
+	echo file tuidemo.obj     >> demos.lnk
+	echo file tui.obj         >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name xmas.exe        >> demos.lnk
+	echo file xmas.obj        >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Watcom C++ OS/2 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Open Watcom 1.3 for OS/2. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_wcc_os2 &
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) &
+	$(PDCURSES_HOME)\maintain.er &
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h &
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h &
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/panel/Makefile.in stsgdb-6.8/pdcurses/panel/Makefile.in
--- gdb-6.8/pdcurses/panel/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/panel/Makefile.in	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,68 @@
+# Makefile for XCurses library
+#
+# The variable 'srcdir' refers to the source-distribution, and can be set with
+# the configure script by "--srcdir=DIR".
+#
+
+SHELL		= /bin/sh
+THIS		= Makefile
+
+@SET_MAKE@
+
+srcdir		= @srcdir@
+VPATH		= @srcdir@
+prefix		= @prefix@
+exec_prefix	= @exec_prefix@
+libdir		= $(exec_prefix)
+includedir	= @includedir@
+
+PDCURSES_HOME		=$(srcdir)/..
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+
+INSTALL		= @INSTALL@
+INSTALL_DATA	= @INSTALL_DATA@
+
+LN_S		= @LN_S@
+
+CC		= @CC@
+CFLAGS		= @CFLAGS@
+
+INCDIR		= $(srcdir)
+CPPFLAGS	= -I$(INCDIR) -I$(srcdir)/.. -I.. @DEFS@ -DXCURSES @SYS_DEFS@
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS) @MH_XINC_DIR@
+
+LINK		= $(CC)
+LDFLAGS		= @LDFLAGS@ @LIBS@
+
+RANLIB		= @RANLIB@
+
+LIBRARIES	= libpanel.a
+
+################################################################################
+all :	$(LIBRARIES)
+
+install : 
+	echo Does nothing at the moment
+
+clean :
+	-rm -rf *.o trace $(LIBRARIES)
+
+distclean: clean
+	-rm -f Makefile
+
+mostlyclean: clean
+
+realclean: distclean
+
+#------------------------------------------------------------------------
+
+OBJS = \
+panel.o
+
+libpanel.a : $(OBJS)
+	ar rv $@ $?
+	-$(RANLIB) $@
+
+panel.o: $(srcdir)/panel.c $(PDCURSES_HOME)/panel.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/panel.c
diff -Naur gdb-6.8/pdcurses/panel/panel.c stsgdb-6.8/pdcurses/panel/panel.c
--- gdb-6.8/pdcurses/panel/panel.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/panel/panel.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,1126 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <panel.h>
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_panel = "$Id: panel.c,v 1.8 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  panels	- panel package for curses
+
+  PDCurses Description:
+ 	The panel library is built using the curses library and any program
+ 	using panels routines must call one of the curses initialization
+ 	routines such as initscr(). A program using these routines must be
+ 	linked with the panels and curses libraries.
+
+ 	The panels package gives the applications programmer a way to have
+ 	depth relationships between curses windows; a curses window is
+ 	associated with every panel. The panels routines allow curses windows
+ 	to overlap without making visible the overlapped portions of 
+ 	underlying windows. The initial curses window, stdscr, lies beneath
+ 	all panels. The set of currently visible panels is the 'deck' of
+ 	panels.
+
+ 	The panels package allows the applications programmer to create
+ 	panels, fetch and set their associated windows, shuffle panels in 
+ 	the deck, and manipulate panels in other ways.
+
+  PDCurses Return Value:
+ 	Each panels routine that returns a pointer to an object returns NULL
+ 	if an error occurs. Each panel routine that returns an integer, 
+ 	returns OK if it executes successfully and ERR if it does not.
+
+  Notes
+ 	The header <panel.h> includes the header <curses.h>.
+
+  Credits
+ 	Original Author - Warren Tucker N4HGF
+ 	{gatech,emory}!n4hgf!wht -or- wht@n4hgf.Mt-Park.GA.US
+
+**man-end**********************************************************************/
+
+
+/*
+  Defined functions:
+	int bottom_panel(PANEL *pan);
+	int del_panel(PANEL *pan);
+	int hide_panel(PANEL *pan);
+	int move_panel(PANEL *pan, int starty, int startx);
+	PANEL *new_panel(WINDOW *win);
+	PANEL *panel_above(const PANEL *pan);
+	PANEL *panel_below(const PANEL *pan);
+	int panel_hidden(const PANEL *pan);
+	const void *panel_userptr(const PANEL *pan);
+	WINDOW *panel_window(const PANEL *pan);
+	int replace_panel(PANEL *pan, WINDOW *win);
+	int set_panel_userptr(PANEL *pan, const void *uptr);
+	int show_panel(PANEL *pan);
+	int top_panel(PANEL *pan);
+	void update_panels(void);
+
+	Touchline(pan,start,count)
+	Touchpan(pan)
+	Wnoutrefresh(pan)
+	__calculate_obscure()
+	__free_obscure(pan)
+	__override(pan,show)
+	__panel_is_linked(pan)
+	__panel_link_bottom(pan)
+	__panel_link_top(pan)
+	__panel_unlink(pan)
+	__panels_overlapped(pan1,pan2)
+	dPanel(text,pan)
+	dStack(fmt,num,pan)
+	open_dfp()
+
+--------------------------------------------------------------------------*/
+PANEL *__bottom_panel = (PANEL *)0;
+PANEL *__top_panel = (PANEL *)0;
+PANEL __stdscr_pseudo_panel = { (WINDOW *)0 };
+
+#define STATIC static
+
+#ifdef HAVE_PROTO
+STATIC void __calculate_obscure(void);
+STATIC void __free_obscure(PANEL *);
+STATIC void __override(PANEL *, int);
+STATIC bool __panel_is_linked(const PANEL *);
+STATIC void __panel_link_bottom(PANEL *);
+STATIC void __panel_link_top(PANEL *);
+STATIC bool __panels_overlapped(PANEL *, PANEL *);
+STATIC void __panel_unlink(PANEL *);
+#endif
+
+/*+-------------------------------------------------------------------------
+	dPanel(text,pan)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+# ifdef HAVE_PROTO
+dPanel(char *text,PANEL *pan)
+# else
+dPanel(text,pan)
+char *text;
+PANEL *pan;
+# endif
+{
+	_tracef("%s id=%s b=%s a=%s y=%d x=%d",
+		text,pan->user,
+		(pan->below) ? pan->below->user : "--",
+		(pan->above) ? pan->above->user : "--",
+		pan->wstarty, pan->wstartx);
+}	/* end of dPanel */
+#else
+#define dPanel(text,pan)
+#endif
+
+/*+-------------------------------------------------------------------------
+	dStack(fmt,num,pan)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+# ifdef HAVE_PROTO
+void dStack(char *fmt,int num,PANEL *pan)
+# else
+void
+dStack(fmt,num,pan)
+char *fmt;
+int num;
+PANEL *pan;
+# endif
+{
+char s80[80];
+
+	sprintf(s80,fmt,num,pan);
+	_tracef("%s b=%s t=%s",s80,
+		(__bottom_panel) ? __bottom_panel->user : "--",
+		(__top_panel)    ? __top_panel->user    : "--");
+	if(pan)
+		_tracef("pan id=%s",pan->user);
+	pan = __bottom_panel;
+	while(pan)
+	{
+		dPanel("stk",pan);
+		pan = pan->above;
+	}
+}	/* end of dStack */
+#else
+#define dStack(fmt,num,pan)
+#endif
+
+/*+-------------------------------------------------------------------------
+	Wnoutrefresh(pan) - debugging hook for wnoutrefresh
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+# ifdef HAVE_PROTO
+STATIC int Wnoutrefresh(PANEL *pan)
+# else
+STATIC int
+Wnoutrefresh(pan)
+PANEL *pan;
+# endif
+{
+	dPanel("wnoutrefresh",pan);
+	wnoutrefresh(pan->win);
+}	/* end of Wnoutrefresh */
+#else
+#define Wnoutrefresh(pan) wnoutrefresh((pan)->win)
+#endif
+
+/*+-------------------------------------------------------------------------
+	Touchpan(pan)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+# ifdef HAVE_PROTO
+STATIC int Touchpan(PANEL *pan)
+# else
+STATIC int
+Touchpan(pan)
+PANEL *pan;
+# endif
+{
+	dPanel("Touchpan",pan);
+	touchwin(pan->win);
+}	/* end of Touchpan */
+#else
+#define Touchpan(pan) touchwin((pan)->win)
+#endif
+
+/*+-------------------------------------------------------------------------
+	Touchline(pan,start,count)
+--------------------------------------------------------------------------*/
+#ifdef PANEL_DEBUG
+# ifdef HAVE_PROTO
+STATIC int Touchline(PANEL *pan,int start,int count)
+# else
+STATIC int
+Touchline(pan,start,count)
+PANEL *pan;
+int start;
+int count;
+# endif
+{
+char s80[80];
+	sprintf(s80,"Touchline s=%d c=%d",start,count);
+	dPanel(s80,pan);
+	touchline(pan->win,start,count);
+}	/* end of Touchline */
+#else
+#define Touchline(pan,start,count) touchline((pan)->win,start,count)
+#endif
+
+/*+-------------------------------------------------------------------------
+	__panels_overlapped(pan1,pan2) - check panel overlapped
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC bool __panels_overlapped(register PANEL *pan1,register PANEL *pan2)
+#else
+STATIC bool
+__panels_overlapped(pan1,pan2)
+register PANEL *pan1;
+register PANEL *pan2;
+#endif
+{
+	if(!pan1 || !pan2)
+		return FALSE;
+	return((pan1->wstarty >= pan2->wstarty && pan1->wstarty < pan2->wendy) ||
+		(pan2->wstarty >= pan1->wstarty && pan2->wstarty < pan1->wendy))
+	&& ((pan1->wstartx >= pan2->wstartx && pan1->wstartx < pan2->wendx) ||
+		(pan2->wstartx >= pan1->wstartx && pan2->wstartx < pan1->wendx));
+}	/* end of __panels_overlapped */
+
+/*+-------------------------------------------------------------------------
+	__free_obscure(pan)
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC void __free_obscure(PANEL *pan)
+#else
+STATIC void
+__free_obscure(pan)
+PANEL *pan;
+#endif
+{
+PANELOBS *tobs = pan->obscure;				/* "this" one */
+PANELOBS *nobs;								/* "next" one */
+
+	while(tobs)
+	{
+		nobs = tobs->above;
+		free((char *)tobs);
+		tobs = nobs;
+	}
+	pan->obscure = (PANELOBS *)0;
+}	/* end of __free_obscure */
+
+/*+-------------------------------------------------------------------------
+	__override(pan,show)
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC void __override(PANEL *pan,int show)
+#else
+STATIC void
+__override(pan,show)
+PANEL *pan;
+int show;
+#endif
+{
+register int y;
+register PANEL *pan2;
+PANELOBS *tobs = pan->obscure;				/* "this" one */
+
+
+	if(show == 1)
+		Touchpan(pan);
+	else if(!show)
+	{
+		Touchpan(pan);
+/*
+		Touchline(&__stdscr_pseudo_panel,pan->wendy,getmaxy(pan->win));
+*/
+		Touchpan(&__stdscr_pseudo_panel);
+	}
+	else if(show == -1)
+	{
+		while(tobs && (tobs->pan != pan))
+			tobs = tobs->above;
+	}
+
+	while(tobs)
+	{
+		if((pan2 = tobs->pan) != pan)
+		{
+			for(y = pan->wstarty; y < pan->wendy; y++)
+			{
+				if( (y >= pan2->wstarty) && (y < pan2->wendy) &&
+					((is_linetouched(pan->win,y - pan->wstarty)) ||
+					(is_linetouched(stdscr,y))))
+				{
+					Touchline(pan2,y - pan2->wstarty,1);
+				}
+			}
+		}
+		tobs = tobs->above;
+	}
+}	/* end of __override */
+
+/*+-------------------------------------------------------------------------
+	__calculate_obscure()
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC void __calculate_obscure(void)
+#else
+STATIC void
+__calculate_obscure()
+#endif
+{
+PANEL *pan;
+register PANEL *pan2;
+register PANELOBS *tobs;			/* "this" one */
+PANELOBS *lobs;
+
+	pan = __bottom_panel;
+	while(pan)
+	{
+		if(pan->obscure)
+			__free_obscure(pan);
+		lobs = (PANELOBS *)0;		/* last one */
+		pan2 = __bottom_panel;
+		while(pan2)
+		{
+			if(__panels_overlapped(pan,pan2))
+			{
+				if(!(tobs = (PANELOBS *)malloc(sizeof(PANELOBS))))
+					return;
+				tobs->pan = pan2;
+				dPanel("obscured",pan2);
+				tobs->above = (PANELOBS *)0;
+				if(lobs)
+					lobs->above = tobs;
+				else
+					pan->obscure = tobs;
+				lobs  = tobs;
+			}
+			pan2 = pan2->above;
+		}
+		__override(pan,1);
+		pan = pan->above;
+	}
+
+}	/* end of __calculate_obscure */
+
+/*+-------------------------------------------------------------------------
+	__panel_is_linked(pan) - check to see if panel is in the stack
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC bool __panel_is_linked(const PANEL *pan)
+#else
+STATIC bool
+__panel_is_linked(pan)
+PANEL *pan;
+#endif
+{
+register PANEL *pan2 = __bottom_panel;
+
+	while(pan2)
+	{
+		if(pan2 == pan)
+			return TRUE;
+		pan2 = pan2->above;
+	}
+	return FALSE;
+}	/* end of __panel_is_linked */
+
+/*+-------------------------------------------------------------------------
+	__panel_link_top(pan) - link panel into stack at top
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC void __panel_link_top(PANEL *pan)
+#else
+STATIC void
+__panel_link_top(pan)
+PANEL *pan;
+#endif
+{
+
+#ifdef PANEL_DEBUG
+	dStack("<lt%d>",1,pan);
+	if(__panel_is_linked(pan))
+		return;
+#endif
+
+	pan->above = (PANEL *)0;
+	pan->below = (PANEL *)0;
+	if(__top_panel)
+	{
+		__top_panel->above = pan;
+		pan->below = __top_panel;
+	}
+	__top_panel = pan;
+	if(!__bottom_panel)
+		__bottom_panel = pan;
+	__calculate_obscure();
+	dStack("<lt%d>",9,pan);
+
+}	/* end of __panel_link_top */
+
+/*+-------------------------------------------------------------------------
+	__panel_link_bottom(pan) - link panel into stack at bottom
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC void __panel_link_bottom(PANEL *pan)
+#else
+STATIC void
+__panel_link_bottom(pan)
+PANEL *pan;
+#endif
+{
+
+#ifdef PANEL_DEBUG
+	dStack("<lb%d>",1,pan);
+	if(__panel_is_linked(pan))
+		return;
+#endif
+
+	pan->above = (PANEL *)0;
+	pan->below = (PANEL *)0;
+	if(__bottom_panel)
+	{
+		__bottom_panel->below = pan;
+		pan->above = __bottom_panel;
+	}
+	__bottom_panel = pan;
+	if(!__top_panel)
+		__top_panel = pan;
+	__calculate_obscure();
+	dStack("<lb%d>",9,pan);
+
+}	/* end of __panel_link_bottom */
+
+/*+-------------------------------------------------------------------------
+	__panel_unlink(pan) - unlink panel from stack
+--------------------------------------------------------------------------*/
+#ifdef HAVE_PROTO
+STATIC void __panel_unlink(PANEL *pan)
+#else
+STATIC void
+__panel_unlink(pan)
+PANEL *pan;
+#endif
+{
+register PANEL *prev;
+register PANEL *next;
+
+#ifdef PANEL_DEBUG
+	dStack("<u%d>",1,pan);
+	if(!__panel_is_linked(pan))
+		return;
+#endif
+
+	__override(pan,0);
+	__free_obscure(pan);
+
+	prev = pan->below;
+	next = pan->above;
+
+	if(prev)		/* if non-zero, we will not update the list head */
+	{
+		prev->above = next;
+		if(next)
+			next->below = prev;
+	}
+	else if(next)
+		next->below = prev;
+	if(pan == __bottom_panel)
+		__bottom_panel = next;
+	if(pan == __top_panel)
+		__top_panel = prev;
+
+	__calculate_obscure();
+
+	pan->above = (PANEL *)0;
+	pan->below = (PANEL *)0;
+	dStack("<u%d>",9,pan);
+
+}	/* end of __panel_unlink */
+
+/**********************************************************************/
+/* The following are the public functions for the panels library.     */
+/**********************************************************************/
+
+/*man-start*********************************************************************
+
+  bottom_panel	- puts panel at bottom of deck
+
+  PDCurses Description:
+ 	This function places pan at the bottom of the deck. The size, location
+ 	and contents of the panel are unchanged.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int bottom_panel( PANEL *pan );
+ 	SYS V Curses	int bottom_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int bottom_panel(register PANEL *pan)
+#else
+int
+bottom_panel(pan)
+register PANEL *pan;
+#endif
+{
+	if(!pan)
+		return(ERR);
+	if(pan == __bottom_panel)
+		return(OK);
+	if(__panel_is_linked(pan))
+		(void)hide_panel(pan);
+	__panel_link_bottom(pan);
+	return(OK);
+}	/* end of bottom_panel */
+
+/*man-start*********************************************************************
+
+  del_panel	- deletes a panel
+
+  PDCurses Description:
+ 	This function deletes pan but not its associated winwow.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int del_panel( PANEL *pan );
+ 	SYS V Curses	int del_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int del_panel(register PANEL *pan)
+#else
+int
+del_panel(pan)
+register PANEL *pan;
+#endif
+{
+	if(pan)
+	{
+		if(__panel_is_linked(pan))
+			(void)hide_panel(pan);
+		free((char *)pan);
+		return(OK);
+	}
+	return(ERR);
+}	/* end of del_panel */
+
+/*man-start*********************************************************************
+
+  hide_panel	- removes a panel from the deck
+
+  PDCurses Description:
+ 	This function removes a panel from the deck and thus hides it from
+ 	view.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int hide_panel( PANEL *pan );
+ 	SYS V Curses	int hide_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int hide_panel(register PANEL *pan)
+#else
+int
+hide_panel(pan)
+register PANEL *pan;
+#endif
+{
+
+	if(!pan)
+		return(ERR);
+
+	if(!__panel_is_linked(pan))
+	{
+		pan->above = (PANEL *)0;
+		pan->below = (PANEL *)0;
+		return(ERR);
+	}
+
+	__panel_unlink(pan);
+
+	return(OK);
+}	/* end of hide_panel */
+
+/*man-start*********************************************************************
+
+  move_panel	- move a window on the virtual screen
+
+  PDCurses Description:
+ 	This function move the curses window associated with pan so that
+ 	its upper lefthand corner is at the supplied coordinates. Do not
+ 	use mvwin() on the window.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL or an error occurs when
+ 	trying to move the curses window.
+
+  Portability:
+ 	PDCurses	int move_panel( PANEL *pan, int starty, int startx);
+ 	SYS V Curses	int move_panel( PANEL *pan, int starty, int startx);
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int move_panel(PANEL *pan,int starty,int startx)
+#else
+int
+move_panel(pan,starty,startx)
+PANEL *pan;
+int starty;
+int startx;
+#endif
+{
+WINDOW *win;
+
+	if(!pan)
+		return(ERR);
+	if(__panel_is_linked(pan))
+		__override(pan,0);
+	win = pan->win;
+	if(mvwin(win,starty,startx) == ERR)
+		return(ERR);
+	pan->wstarty = getbegy(win);
+	pan->wstartx = getbegx(win);
+	pan->wendy = pan->wstarty + getmaxy(win);
+	pan->wendx = pan->wstartx + getmaxx(win);
+	if(__panel_is_linked(pan))
+		__calculate_obscure();
+	return(OK);
+}	/* end of move_panel */
+
+/*man-start*********************************************************************
+
+  new_panel	- create a new panel
+
+  PDCurses Description:
+ 	This function creates a new panel associated with win and returns
+ 	the panel pointer. The new panel is placed at the top of the deck.
+
+  PDCurses Return Value:
+ 	Returns pointer to new panel, or NULL if an error occurs.
+
+  PDCurses Errors:
+ 	Returns NULL if an error occurs.
+
+  Portability:
+ 	PDCurses	PANEL *new_panel( WINDOW *win );
+ 	SYS V Curses	PANEL *new_panel( WINDOW *win );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+PANEL *new_panel(WINDOW *win)
+#else
+PANEL *
+new_panel(win)
+WINDOW *win;
+#endif
+{
+PANEL *pan = (PANEL *)malloc(sizeof(PANEL));
+
+	if(!__stdscr_pseudo_panel.win)
+	{
+		__stdscr_pseudo_panel.win = stdscr;
+		__stdscr_pseudo_panel.wstarty = 0;
+		__stdscr_pseudo_panel.wstartx = 0;
+		__stdscr_pseudo_panel.wendy = LINES;
+		__stdscr_pseudo_panel.wendx = COLS;
+		__stdscr_pseudo_panel.user = "stdscr";
+		__stdscr_pseudo_panel.obscure = (PANELOBS *)0;
+	}
+
+	if(pan)
+	{
+		pan->win = win;
+		pan->above = (PANEL *)0;
+		pan->below = (PANEL *)0;
+		pan->wstarty = getbegy(win);
+		pan->wstartx = getbegx(win);
+		pan->wendy = pan->wstarty + getmaxy(win);
+		pan->wendx = pan->wstartx + getmaxx(win);
+#ifdef PANEL_DEBUG
+		pan->user = "new";
+#else
+		pan->user = (char *)0;
+#endif
+		pan->obscure = (PANELOBS *)0;
+		(void)show_panel(pan);
+	}
+
+	return(pan);
+}	/* end of new_panel */
+
+/*man-start*********************************************************************
+
+  panel_above	- return pointer to panel above
+
+  PDCurses Description:
+ 	This function returns a pointer to the panel in the deck above
+ 	pan. If the value of pan passed is NULL, this function returns
+ 	a pointer to the bottom panel in the deck.
+
+  PDCurses Return Value:
+ 	Returns pointer to panel above pan, or NULL if pan is the top
+ 	panel.
+
+  PDCurses Errors:
+ 	Returns NULL if an error occurs.
+
+  Portability:
+ 	PDCurses	PANEL *panel_above( const PANEL *pan );
+ 	SYS V Curses	PANEL *panel_above( const PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+PANEL *panel_above(const PANEL *pan)
+#else
+PANEL *
+panel_above(pan)
+PANEL *pan;
+#endif
+{
+	if(!pan)
+		return(__bottom_panel);
+	else
+		return(pan->above);
+}	/* end of panel_above */
+
+/*man-start*********************************************************************
+
+  panel_below	- return pointer to panel below
+
+  PDCurses Description:
+ 	This function returns a pointer to the panel in the deck below
+ 	pan. If the value of pan passed is NULL, this function returns
+ 	a pointer to the top panel in the deck.
+
+  PDCurses Return Value:
+ 	Returns pointer to panel below pan, or NULL if pan is the bottom
+ 	panel.
+
+  PDCurses Errors:
+ 	Returns NULL if an error occurs.
+
+  Portability:
+ 	PDCurses	PANEL *panel_below( const PANEL *pan );
+ 	SYS V Curses	PANEL *panel_below( const PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+PANEL *panel_below(const PANEL *pan)
+#else
+PANEL *
+panel_below(pan)
+PANEL *pan;
+#endif
+{
+	if(!pan)
+		return(__top_panel);
+	else
+		return(pan->below);
+}	/* end of panel_below */
+
+/*man-start*********************************************************************
+
+  panel_hidden	- indicates if panel is hidden
+
+  PDCurses Description:
+ 	This function returns OK if pan is hidden and ERR if it is not.
+
+  PDCurses Return Value:
+ 	OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int panel_hidden( const PANEL *pan );
+ 	SYS V Curses	int panel_hidden( const PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int panel_hidden(const PANEL *pan)
+#else
+int
+panel_hidden(pan)
+PANEL *pan;
+#endif
+{
+	if(!pan)
+		return(ERR);
+	return(__panel_is_linked(pan) ? ERR : OK);
+}	/* end of panel_hidden */
+
+/*man-start*********************************************************************
+
+  panel_userptr	- return user information
+
+  PDCurses Description:
+ 	Each panel has a user pointer available for maintaining relevant
+ 	information. This function returns a pointer to that information
+ 	previously set up by set_panel_userptr().
+
+  PDCurses Return Value:
+ 	Returns pointer to user information.
+
+  PDCurses Errors:
+ 	Returns NULL if pan is NULL or no user information exists.
+
+  Portability:
+ 	PDCurses	const void *panel_userptr( const PANEL *pan );
+ 	SYS V Curses	const void *panel_userptr( const PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+const void *panel_userptr(const PANEL *pan)
+#else
+void *
+panel_userptr(pan)
+PANEL *pan;
+#endif
+{
+	if(!pan)
+		return(NULL);
+	return(pan->user);
+}	/* end of panel_userptr */
+
+/*man-start*********************************************************************
+
+  panel_window	- returns pointer to curses window
+
+  PDCurses Description:
+ 	This function returns a pointer to the curses window associated
+ 	with the panel.
+
+  PDCurses Return Value:
+ 	Pointer to panel's window.
+
+  PDCurses Errors:
+ 	Return NULL on error.
+
+  Portability:
+ 	PDCurses	WINDOW *panel_window(const PANEL *);
+ 	SYS V Curses	WINDOW *panel_window(const PANEL *);
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+WINDOW *panel_window(const PANEL *pan)
+#else
+WINDOW *
+panel_window(pan)
+PANEL *pan;
+#endif
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("panel_window() - called\n");
+#endif
+	return(pan->win);
+}	/* end of panel_window */
+
+/*man-start*********************************************************************
+
+  replace_panel	- set curses window contents
+
+  PDCurses Description:
+ 	This function replaces the current window of pan with win.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int replace_panel( PANEL *pan, WINDOW *win );
+ 	SYS V Curses	int replace_panel( PANEL *pan, WINDOW *win );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int replace_panel(PANEL *pan,WINDOW *win)
+#else
+int
+replace_panel(pan,win)
+PANEL *pan;
+WINDOW *win;
+#endif
+{
+	if(!pan)
+		return(ERR);
+	if(__panel_is_linked(pan))
+		__override(pan,0);
+	pan->win = win;
+	pan->wstarty = getbegy(win);
+	pan->wstartx = getbegx(win);
+	pan->wendy = pan->wstarty + getmaxy(win);
+	pan->wendx = pan->wstartx + getmaxx(win);
+	if(__panel_is_linked(pan))
+		__calculate_obscure();
+	return(OK);
+}	/* end of replace_panel */
+
+/*man-start*********************************************************************
+
+  set_panel_userptr	- sets user information for a panel
+
+  PDCurses Description:
+ 	Each panel has a user pointer available for maintaining relevant
+ 	information. This function sets the value of that information.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int set_panel_userptr( PANEL *pan, const void *uptr );
+ 	SYS V Curses	int set_panel_userptr( PANEL *pan, const void *uptr );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int set_panel_userptr(PANEL *pan, const void *uptr)
+#else
+int
+set_panel_userptr(pan,uptr)
+PANEL *pan;
+void *uptr;
+#endif
+{
+	if(!pan)
+		return(ERR);
+	pan->user = uptr;
+	return(OK);
+}	/* end of set_panel_userptr */
+
+/*man-start*********************************************************************
+
+  show_panel	- displays a panel
+
+  PDCurses Description:
+ 	This function makes a previously hidden panel visible and places
+ 	it back in the deck on top.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int show_panel( PANEL *pan );
+ 	SYS V Curses	int show_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int show_panel(register PANEL *pan)
+#else
+int
+show_panel(pan)
+register PANEL *pan;
+#endif
+{
+
+	if(!pan)
+		return(ERR);
+	if(pan == __top_panel)
+		return(OK);
+	if(__panel_is_linked(pan))
+		(void)hide_panel(pan);
+	__panel_link_top(pan);
+	return(OK);
+}	/* end of show_panel */
+
+/*man-start*********************************************************************
+
+  top_panel	- puts panel on top of deck
+
+  PDCurses Description:
+ 	This function places pan on the top of the deck. The size, location
+ 	and contents of the panel are unchanged.
+
+  PDCurses Return Value:
+ 	Returns OK or ERR.
+
+  PDCurses Errors:
+ 	Returns ERR if pan is NULL.
+
+  Portability:
+ 	PDCurses	int top_panel( PANEL *pan );
+ 	SYS V Curses	int top_panel( PANEL *pan );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+int top_panel(register PANEL *pan)
+#else
+int
+top_panel(pan)
+register PANEL *pan;
+#endif
+{
+	return(show_panel(pan));
+}	/* end of top_panel */
+
+/*man-start*********************************************************************
+
+  update_panels	- panels virtual screen refresh routine
+
+  PDCurses Description:
+ 	This function refreshes the virtual screen to reflect the depth
+ 	relationships between the panels in the deck. The user must use
+ 	doupdate() to refresh the physical screen.
+
+  PDCurses Return Value:
+ 	None
+
+  PDCurses Errors:
+ 	None
+
+  Portability:
+ 	PDCurses	void update_panels( void )
+ 	SYS V Curses	void update_panels( void )
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_PROTO
+void update_panels(void)
+#else
+void
+update_panels()
+#endif
+{
+PANEL *pan;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("update_panels() - called\n");
+#endif
+
+	pan = __bottom_panel;
+	while(pan)
+	{
+		__override(pan,-1);
+		pan = pan->above;
+	}
+
+	if(is_wintouched(stdscr))
+		Wnoutrefresh(&__stdscr_pseudo_panel);
+	
+	pan = __bottom_panel;
+	if(pan)
+	{
+		while(pan)
+		{
+			if(is_wintouched(pan->win) || !pan->above)
+				Wnoutrefresh(pan);
+			pan = pan->above;
+		}
+	}
+}	/* end of update_panels */
+
+/* end of panel.c */
diff -Naur gdb-6.8/pdcurses/panel/README stsgdb-6.8/pdcurses/panel/README
--- gdb-6.8/pdcurses/panel/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/panel/README	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,19 @@
+
+                        Welcome to PDCurses
+
+ Contents
+ --------
+ This directory contains source code for a panels library.
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory are released to the Public Domain.
+
+
+ Acknowlegements
+ ---------------
+
+ This panles library was provided by Warren Tucker N4HGF
+ 	{gatech,emory}!n4hgf!wht -or- wht@n4hgf.Mt-Park.GA.US
diff -Naur gdb-6.8/pdcurses/panel.h stsgdb-6.8/pdcurses/panel.h
--- gdb-6.8/pdcurses/panel.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/panel.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,90 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+$Id: panel.h,v 1.8 2005/12/25 06:44:36 wmcbrine Exp $
+*/
+/*
+*----------------------------------------------------------------------
+*				Panels for PDCurses
+*----------------------------------------------------------------------
+*/
+
+#include <curses.h>
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+extern "C"
+{
+#endif
+
+#ifndef __PDCURSES_PANEL_H__
+#define __PDCURSES_PANEL_H__ 1
+
+typedef struct panelobs
+{
+	struct panelobs *above;
+	struct panel *pan;
+} PANELOBS;
+
+typedef struct panel
+{
+	WINDOW *win;
+	int wstarty;
+	int wendy;
+	int wstartx;
+	int wendx;
+	struct panel *below;
+	struct panel *above;
+#ifdef HAVE_PROTO
+	const void *user;
+#else
+	void *user;
+#endif
+	struct panelobs *obscure;
+} PANEL;
+
+#ifdef HAVE_PROTO
+# define Args(x) x
+#else
+# define Args(x) ()
+#endif
+
+WINDOW *panel_window Args((const PANEL *pan));
+void update_panels Args((void));
+int hide_panel Args((PANEL *pan));
+int show_panel Args((PANEL *pan));
+int del_panel Args((PANEL *pan));
+int top_panel Args((PANEL *pan));
+int bottom_panel Args((PANEL *pan));
+PANEL *new_panel Args((WINDOW *win));
+PANEL *panel_above Args((const PANEL *pan));
+PANEL *panel_below Args((const PANEL *pan));
+int panel_hidden Args((const PANEL *pan));
+int set_panel_userptr Args((PANEL *pan, const void *uptr));
+const void *panel_userptr Args((const PANEL *pan));
+int move_panel Args((PANEL *pan, int starty, int startx));
+int replace_panel Args((PANEL *pan, WINDOW *win));
+
+#undef Args
+
+#endif /* __PDCURSES_PANEL_H__ */
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+}
+#endif
diff -Naur gdb-6.8/pdcurses/pdcurses/addch.c stsgdb-6.8/pdcurses/pdcurses/addch.c
--- gdb-6.8/pdcurses/pdcurses/addch.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/addch.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,238 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	addch
+#undef	waddch
+#undef	mvaddch
+#undef	mvwaddch
+#undef	echochar
+#undef	wechochar
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	refresh
+#  undef	wrefresh
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_addch  = "$Id: addch.c,v 1.3 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         addch
+
+  Synopsis:
+  	int addch(const chtype ch);
+  	int waddch(WINDOW *win, const chtype ch);
+  	int mvaddch(int y, int x, const chtype ch);
+  	int mvwaddch(WINDOW *win, int y, int x, const chtype ch);
+  	int echochar(const chtype ch);
+  	int wechochar(WINDOW *win, const chtype ch);
+
+  X/Open Description:
+ 	The routine addch() inserts the character ch into the default
+ 	window at the current cursor position and the window cursor is
+ 	advanced.  The character is of the type chtype as containing
+ 	both data and attributes.
+
+ 	The routine waddch() inserts the character ch into the specified
+ 	window at the current cursor position.  The cursor position is
+ 	advanced.
+
+ 	The routine mvaddch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the default window.
+ 	The cursor position is advanced after the character has been
+ 	inserted.
+
+ 	The routine mvwaddch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the specified
+ 	window.  The cursor position is advanced after the character
+ 	has been inserted.
+
+ 	The routine echochar() inserts the character ch into stdscr
+ 	at the current cursor position and a refresh() is called.  
+ 	The cursor position is advanced.
+
+ 	The routine wechochar() inserts the character ch into the
+ 	specified window at the current cursor position and a wrefresh() 
+ 	is called. The cursor position is advanced.
+
+ 	All these routines are similar to putchar().  The following
+ 	information applies to all the routines.
+
+ 	If the cursor moves on to the right margin, an automatic
+ 	newline is performed.  If scrollok is enabled, and a character
+ 	is added to the bottom right corner of the screen, the
+ 	scrolling region will be scrolled up one line.  If scrolling
+ 	is not allowed, ERR will be returned.
+
+ 	If ch is a tab, newline, or backspace, the cursor will be
+ 	moved appropriately within the window.  If ch is a newline,
+ 	the clrtoeol routine is called before the cursor is moved to
+ 	the beginning of the next line.  If newline mapping is off,
+ 	the cursor will be moved to the next line, but the x
+ 	coordinate will be unchanged.  If ch is a tab the cursor is
+ 	moved to the next tab position within the window.  If ch is
+ 	another control character, it will be drawn in the ^X
+ 	notation.  Calling the inch() routine after adding a control
+ 	character returns the representation of the control character,
+ 	not the control character.
+
+ 	Video attributes can be combined with a character by ORing
+ 	them into the parameter.  This will result in these attributes
+ 	being set.  The intent here is that text, including
+ 	attributes, can be copied from one place to another using inch()
+ 	and addch().
+
+ 	NOTE: All these functions are implemented as macros.
+
+  PDCurses Description:
+ 	Depending upon the state of the raw character output, 7- or
+ 	8-bit characters will be output.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      addch                                 Y        Y       Y
+      waddch                                Y        Y       Y
+      mvaddch                               Y        Y       Y
+      mvwaddch                              Y        Y       Y
+      echochar                              -        -      3.0
+      wechochar                             -        -      3.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	addch(const chtype ch)
+#else
+int	PDC_CDECL	addch(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("addch() - called: ch=%x\n",ch);
+#endif
+
+	return( PDC_chadd( stdscr, ch, (bool)(!(SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	waddch(WINDOW *win, const chtype ch)
+#else
+int	PDC_CDECL	waddch(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddch() - called: win=%x ch=%x\n",win,ch);
+#endif
+
+	return( PDC_chadd( win, ch, (bool)(!(SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvaddch(int y, int x, const chtype ch)
+#else
+int	PDC_CDECL	mvaddch(y,x,ch)
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvaddch() - called: y=%d x=%d ch=%x\n",y,x,ch);
+#endif
+	if (move(y,x) == ERR)
+		return(ERR);
+	return( PDC_chadd( stdscr, ch, (bool)(!(SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwaddch(WINDOW *win, int y, int x, const chtype ch)
+#else
+int	PDC_CDECL	mvwaddch(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwaddch() - called: win=%x y=%d x=%d ch=%d\n",win,y,x,ch);
+#endif
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return( PDC_chadd( win, ch, (bool)(!(SP->raw_out)), TRUE ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	echochar(const chtype ch)
+#else
+int	PDC_CDECL	echochar(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("echochar() - called: ch=%x\n",ch);
+#endif
+
+	if (PDC_chadd( stdscr, ch, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		return(ERR);
+	return(refresh());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wechochar(WINDOW *win, const chtype ch)
+#else
+int	PDC_CDECL	wechochar(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wechochar() - called: win=%x ch=%x\n",win,ch);
+#endif
+
+	if (PDC_chadd( win, ch, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		return(ERR);
+	return(wrefresh(win));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/addchstr.c stsgdb-6.8/pdcurses/pdcurses/addchstr.c
--- gdb-6.8/pdcurses/pdcurses/addchstr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/addchstr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,393 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   addchstr
+#undef   addchnstr
+#undef   waddchstr
+#undef   waddchnstr
+#undef   mvaddchstr
+#undef   mvaddchnstr
+#undef   mvwaddchstr
+#undef   mvwaddchnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef move
+#  undef wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_addchstr  = "$Id: addchstr.c,v 1.6 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        addchstr
+
+  Synopsis:
+   int addchstr(const chtype *ch);
+   int addchnstr(const chtype *ch, int n);
+   int waddchstr(WINDOW *win, const chtype *ch);
+   int waddchnstr(WINDOW *win, const chtype *ch, int n);
+   int mvaddchstr(int y, int x, const chtype *ch);
+   int mvaddchnstr(int y, int x, const chtype *ch, int n);
+   int mvwaddchstr(WINDOW *, int y, int x, const chtype *ch);
+   int mvwaddchnstr(WINDOW *, int y, int x, const chtype *ch, int n);
+
+  X/Open Description:
+   These routines write a chtype directly into the window structure
+   starting at the current position.
+   The four routines with n as the last argument copy at most n
+   elements, but no more than will fit on the line.
+   If n=-1 then the whole string is copied, to the maximum number
+   that will fit on the line.
+
+   The cursor position is not advanced. These routines do not check for
+   newline or other special characters, no does any line wrapping occur.
+
+   NOTE: addchstr(), mvaddchstr(), mvwaddchstr() addchnstr(), 
+      mvaddchnstr(), and mvwaddchnstr() are implemented as macros.
+
+  X/Open Return Value:
+   All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      addchstr                              -        -      4.0
+      waddchstr                             -        -      4.0
+      mvaddchstr                            -        -      4.0
+      mvwaddchstr                           -        -      4.0
+      addchnstr                             -        -      4.0
+      waddchnstr                            -        -      4.0
+      mvaddchnstr                           -        -      4.0
+      mvwaddchnstr                          -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   addchstr(const chtype *ch)
+#else
+int   PDC_CDECL   addchstr(ch)
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("addchstr() - called\n");
+#endif
+
+   return( addchnstr( ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   addchnstr(const chtype *ch, int n)
+#else
+int   PDC_CDECL   addchnstr(ch,n)
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+   int y,x,num,maxx;
+   chtype *ptr;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("addchnstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return( ERR );
+
+   if (n == 0
+   ||  n < (-1))
+      return( ERR );
+
+   x = stdscr->_curx;
+   y = stdscr->_cury;
+   ptr = &(stdscr->_y[y][x]);
+
+
+   if (n == (-1))
+   {
+      for (num = stdscr->_maxx - x; *ch && num--; num++)
+      {
+         *ptr++ = *ch++;
+      }
+      maxx = num;
+   }
+   else
+   {
+      num = min(stdscr->_maxx - x,n);
+      memcpy((char *)ptr, (char *)ch, (int)(num * sizeof(chtype)));
+      maxx = x+num-1;
+   }
+
+   if (stdscr->_firstch[y] == _NO_CHANGE)
+   {
+      stdscr->_firstch[y] = x;
+      stdscr->_lastch[y] = maxx;
+   }
+   else
+   {
+      if (x <  stdscr->_firstch[y])
+      {
+         stdscr->_firstch[y] = x;
+      }
+      if (maxx >  stdscr->_lastch[y])
+      {
+         stdscr->_lastch[y] = maxx;
+      }
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   waddchstr(WINDOW *win, const chtype *ch)
+#else
+int   PDC_CDECL   waddchstr(win,ch)
+WINDOW *win;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("waddchstr() - called: win=%x\n",win);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   return( waddchnstr( win, ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   waddchnstr(WINDOW *win, const chtype *ch, int n)
+#else
+int   PDC_CDECL   waddchnstr(win,ch,n)
+WINDOW *win;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+   register int i,y,x,num,maxx,minx;
+   int first=1;
+   chtype *ptr;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("waddchnstr() - called: win=%x n=%d\n",win,n);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (n == 0
+   ||  n < (-1))
+      return( ERR );
+
+   x = win->_curx;
+   y = win->_cury;
+   ptr = &(win->_y[y][x]);
+
+#if 0
+   if (n == (-1))
+      {
+      for (num = win->_maxx - x; *ch && num--; num++)
+         *ptr++ = *ch++;
+      maxx = num;
+      }
+   else
+      {
+      num = min(win->_maxx - x,n);
+      maxx = x+num-1;
+      memcpy((char *)ptr, (char *)ch, (int)(num * sizeof(chtype)));
+      }
+
+   if (win->_firstch[y] == _NO_CHANGE)
+      {
+      win->_firstch[y] = x;
+      win->_lastch[y] = maxx;
+      }
+   else
+      {
+      if (x <  win->_firstch[y])
+         {
+         win->_firstch[y] = x;
+         }
+      if (maxx >  win->_lastch[y])
+         {
+         win->_lastch[y] = maxx;
+         }
+      }
+
+#else
+
+   if (n == (-1))
+      num = win->_maxx - x;
+   else
+      num = min(win->_maxx - x,n);
+
+   minx = win->_firstch[y];
+   maxx = win->_lastch[y];
+   for (i=x; num && *ch; num--, i++)
+   {
+      if (i < win->_firstch[y]
+      ||  win->_firstch[y] == _NO_CHANGE)
+      {
+         if (*ptr != *ch && first)
+         {
+            minx = i;
+            first = 0;
+         }
+         }
+         if (i > win->_lastch[y])
+         {
+            if (*ptr != *ch)
+               maxx = i;
+         }
+
+#ifdef PDCDEBUG
+      if (trace_on)
+      {
+         PDC_debug("y %d i %d minx %d maxx %d *ptr %x *ch %x firstch: %d lastch: %d\n",
+                   y,i,minx,maxx,
+                   *ptr,*ch,
+                   win->_firstch[y],win->_lastch[y]
+                   );
+      }
+#endif
+
+      *ptr++ = *ch++;
+   }
+
+   win->_firstch[y] = minx;
+   win->_lastch[y] = maxx;
+#endif
+
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvaddchstr(int y, int x, const chtype *ch)
+#else
+int   PDC_CDECL   mvaddchstr(y,x,ch)
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvaddchstr() - called: y %d x %d\n",y,x);
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(stdscr,y,x) == ERR)
+      return( ERR );
+
+   return( addchnstr( ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvaddchnstr(int y, int x, const chtype *ch, int n)
+#else
+int   PDC_CDECL   mvaddchnstr(y,x,ch,n)
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvaddchnstr() - called: y %d x %d n %d\n",y,x,n);
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(stdscr,y,x) == ERR)
+      return( ERR );
+
+   return( addchnstr( ch, n) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvwaddchstr(WINDOW *win, int y, int x, const chtype *ch)
+#else
+int   PDC_CDECL   mvwaddchstr(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("waddchstr() - called:\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(win,y,x) == ERR)
+      return( ERR );
+
+   return( waddchnstr( win, ch, -1) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   mvwaddchnstr(WINDOW *win,int y, int x, const chtype *ch, int n)
+#else
+int   PDC_CDECL   mvwaddchnstr(win,y,x,ch,n)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvwaddchnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (wmove(win,y,x) == ERR)
+      return( ERR );
+
+   return( waddchnstr( win, ch, n) );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/addstr.c stsgdb-6.8/pdcurses/pdcurses/addstr.c
--- gdb-6.8/pdcurses/pdcurses/addstr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/addstr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,352 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	addstr
+#undef	addnstr
+#undef	waddstr
+#undef	waddnstr
+#undef	mvaddstr
+#undef	mvaddnstr
+#undef	mvwaddstr
+#undef	mvwaddnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#  undef	addch
+#  undef	waddch
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_addstr  = "$Id: addstr.c,v 1.3 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        addstr
+
+  Synopsis:
+  	int addstr(const char *str);
+  	int addnstr(const char *str, int n);
+  	int waddstr(WINDOW *win, const char *str);
+  	int waddnstr(WINDOW *win, const char *str, int n);
+  	int mvaddstr(int y, int x, const char *str);
+  	int mvaddnstr(int y, int x, const char *str, int n);
+  	int mvwaddstr(WINDOW *, int y, int x, const char *str);
+  	int mvwaddnstr(WINDOW *, int y, int x, const char *str, int n);
+
+  X/Open Description:
+ 	These routines write all the characters of the null-terminated
+ 	string str on the given window.  The functionality is equivalent
+ 	to calling waddch() once for each character in the string.  The four
+ 	routines with n as the last argument write at most n characters.  If n
+ 	is negative, then the entire string will be added.
+
+ 	NOTE:	addstr(), mvaddstr(), and mvwaddstr() are implemented as macros.
+ 		addnstr(), mvaddnstr(), and mvwaddnstr() are implemented as macros.
+
+  PDCurses Description:
+ 	The *raw*() routines output 8 bit values.  These contrast to their
+ 	normal counterparts which output 7 bit values and convert control
+ 	character to the ^X notation.
+
+ 	str is a standard 8 bit character string WITHOUT embedded attributes.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      addstr                                Y        Y       Y
+      waddstr                               Y        Y       Y
+      mvaddstr                              Y        Y       Y
+      mvwaddstr                             Y        Y       Y
+      addnstr                               -        -      4.0
+      waddnstr                              -        -      4.0
+      mvaddnstr                             -        -      4.0
+      mvwaddnstr                            -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	addstr(const char *str)
+#else
+int	PDC_CDECL	addstr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("addstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	while (*str)
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	addnstr(const char *str, int n)
+#else
+int	PDC_CDECL	addnstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("addnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	waddstr(WINDOW *win, const char *str)
+#else
+int	PDC_CDECL	waddstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	while (*str)
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	waddnstr(WINDOW *win, const char *str, int n)
+#else
+int	PDC_CDECL	waddnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvaddstr(int y, int x, const char *str)
+#else
+int	PDC_CDECL	mvaddstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvaddstr() - called: y %d x %d string=\"%s\"\n",y,x,str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	while (*str)
+	{     
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvaddnstr(int y, int x, const char *str, int n)
+#else
+int	PDC_CDECL	mvaddnstr(y,x,str,n)
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvaddnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{                
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( stdscr, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwaddstr(WINDOW *win, int y, int x, const char *str)
+#else
+int	PDC_CDECL	mvwaddstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+	int i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("waddstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	while (*str)
+	{     
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwaddnstr(WINDOW *win,int y, int x, const char *str, int n)
+#else
+int	PDC_CDECL	mvwaddnstr(win,y,x,str,n)
+WINDOW *win;
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = 0;
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwaddnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	while ( *str && (ic < n || n < 0) )
+	{     
+		if ((i = *str++)<0) i += 256;  /* make negative chars positive - PJK */
+		if (PDC_chadd( win, (chtype)i, (bool)(!(SP->raw_out)), TRUE ) == ERR)
+		{
+			return( ERR );
+		}
+		ic++;
+	}
+	return( OK );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/attr.c stsgdb-6.8/pdcurses/pdcurses/attr.c
--- gdb-6.8/pdcurses/pdcurses/attr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/attr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,337 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	attroff
+#undef	wattroff
+#undef	attron
+#undef	wattron
+#undef	attrset
+#undef	wattrset
+#undef	standend
+#undef	standout
+#undef	wstandend
+#undef	wstandout
+#undef	getattrs
+#undef	color_set
+#undef	wcolor_set
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_attr  = "$Id: attr.c,v 1.4 2005/12/12 06:17:59 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          attr
+
+  Synopsis:
+  	int attroff(attr_t attrs);
+  	int wattroff(WINDOW *win, attr_t attrs);
+  	int attron(attr_t attrs);
+  	int wattron(WINDOW *win, attr_t attrs);
+  	int attrset(attr_t attrs);
+  	int wattrset(WINDOW *win, attr_t attrs);
+  	int standend(void);
+  	int wstandend(WINDOW *win);
+  	int standout(void);
+  	int wstandout(WINDOW *win);
+  	int color_set(short color_pair, void *opts);
+  	int wcolor_set(WINDOW *win, short color_pair, void *opts);
+
+  X/Open Description:
+ 	These functions manipulate the current attributes and/or colors 
+ 	of the named window.  These attributes can be any combination 
+ 	of A_STANDOUT, A_REVERSE, A_BOLD, A_DIM, A_BLINK, A_UNDERLINE.
+
+ 	These constants are defined in <curses.h> and can be combined
+ 	with the bitwise-OR operator (|).
+
+ 	The current attributes of a window are applied to all characters
+ 	that are written into the window with waddch().  Attributes are
+ 	a property of the character, and move with the character
+ 	through any scrolling and insert/delete line/character operations.
+ 	To the extent possible on the particular terminal, they will be
+ 	displayed as the graphic rendition of characters put on the
+ 	screen.
+
+ 	The attrset() function sets the current attributes of the given
+ 	window to attrs.  The attroff() function turns off the named
+ 	attributes without turning on or off any other attributes.  The
+ 	attron() function turns on the named attributes without affecting
+ 	any others.  The color_set() function sets the window color to 
+ 	the value of color_pair.
+
+  The standout() function is the same as
+ 	attron( A_STANDOUT ).  The standend() function is the same as
+ 	attrset( A_NORMAL ); that is it turns off all attributes.
+
+ 	NOTE:	attroff(), attron(), attrset(), standend(), standout(),
+ 		wstandend(), and wstandout() are defined as macros.
+
+  PDCurses Description:
+ 	System V compatible color support is included.
+ 	See <curses.h> for further details.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	It is an error to call this function with a NULL window pointer.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      attroff                               Y        Y       Y
+      wattroff                              Y        Y       Y
+      attron                                Y        Y       Y
+      wattron                               Y        Y       Y
+      attrset                               Y        Y       Y
+      wattrset                              Y        Y       Y
+      standend                              Y        Y       Y
+      wstandend                             Y        Y       Y
+      standout                              Y        Y       Y
+      wstandout                             Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	attroff(attr_t attrs)
+#else
+int	PDC_CDECL	attroff(attrs)
+chtype attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("attroff() - called\n");
+#endif
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	stdscr->_attrs &= (~attrs & A_ATTRIBUTES);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wattroff(WINDOW *win, attr_t attrs)
+#else
+int	PDC_CDECL	wattroff(win,attrs)
+WINDOW *win;
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wattroff() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_attrs &= (~attrs & A_ATTRIBUTES);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	attron(attr_t attrs)
+#else
+int	PDC_CDECL	attron(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("attron() - called\n");
+#endif
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+	return(wattron(stdscr,attrs));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wattron(WINDOW *win, attr_t attrs)
+#else
+int	PDC_CDECL	wattron(win,attrs)
+WINDOW *win;
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+	attr_t newcolr, oldcolr;
+	attr_t newattr, oldattr;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wattron() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	if( (win->_attrs & A_COLOR) && (attrs & A_COLOR) ) 
+		{
+		oldcolr = win->_attrs & A_COLOR;
+		oldattr = win->_attrs ^ oldcolr;
+		newcolr = attrs & A_COLOR;
+		newattr = (attrs & A_ATTRIBUTES) ^ newcolr;
+		newattr |= oldattr;
+		win->_attrs = newattr | newcolr;
+		}
+	else
+		win->_attrs |= (attrs & A_ATTRIBUTES);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	attrset(attr_t attrs)
+#else
+int	PDC_CDECL	attrset(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("attrset() - called\n");
+#endif
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+	stdscr->_attrs = attrs & A_ATTRIBUTES;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wattrset(WINDOW *win, attr_t attrs)
+#else
+int	PDC_CDECL	wattrset(win,attrs)
+WINDOW *win;
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wattrset() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	win->_attrs = attrs & A_ATTRIBUTES;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+attr_t  PDC_CDECL	getattrs(WINDOW* win)
+#else
+attr_t  PDC_CDECL	getattrs(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+  return win ? win->_attrs : 0;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	standend(void)
+#else
+int	PDC_CDECL	standend()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("standend() - called\n");
+#endif
+	return( wattrset( stdscr, A_NORMAL ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	standout(void)
+#else
+int	PDC_CDECL	standout()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("standout() - called\n");
+#endif
+	return( wattrset( stdscr, A_STANDOUT ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wstandend( WINDOW *win )
+#else
+int	PDC_CDECL	wstandend(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wstandend() - called\n");
+#endif
+	return( wattrset( win, A_NORMAL ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wstandout( WINDOW *win )
+#else
+int	PDC_CDECL	wstandout(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wstandout() - called\n");
+#endif
+	return( wattrset( win, A_STANDOUT ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	color_set(short color_pair, void *opts)
+#else
+int	PDC_CDECL	color_set(color_pair, opts)
+short color_pair;
+void *opts;
+#endif
+/***********************************************************************/
+{
+	return( wcolor_set( stdscr, color_pair, opts ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wcolor_set(WINDOW *win, short color_pair, void *opts)
+#else
+int	PDC_CDECL	wcolor_set(win, color_pair, opts)
+WINDOW *win;
+short color_pair;
+void *opts;		/* "opts" not used, but required by the standard */
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wcolor_set() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	win->_attrs = (win->_attrs & ~A_COLOR) | COLOR_PAIR(color_pair);
+	return( OK );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/beep.c stsgdb-6.8/pdcurses/pdcurses/beep.c
--- gdb-6.8/pdcurses/pdcurses/beep.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/beep.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,128 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	beep
+#undef	flash
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	delay_output
+#  undef	wrefresh
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_beep  = "$Id: beep.c,v 1.1 2001/01/10 08:26:49 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          beep
+
+  Synopsis:
+  	int beep(void);
+  	int flash(void);
+
+  X/Open Description:
+ 	These routines are used to signal the terminal user.  The beep()
+ 	function will sound the audible bell on the terminal, if possible
+ 	and if not, will flash the screen (visible bell), if possible.
+ 	The flash() function will flash the screen, and if that is not
+ 	possible, will sound the audible signal.  If neither signal is
+ 	possible, nothing will happen.  Nearly all terminals have an
+ 	audible signal (bell or beep), but only some can flash the screen.
+
+  X/Open Return Value:
+ 	These functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for these functions.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      beep                                  Y        Y       Y
+      flash                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	beep(void)
+#else
+int	PDC_CDECL	beep()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("beep() - called\n");
+#endif
+
+	if (!SP->audible)
+	{
+		flash();
+		return( ERR );		/* We try to flash instead...*/
+	}
+
+	PDC_beep();
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	flash(void)
+#else
+int	PDC_CDECL	flash()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("flash() - called\n");
+#endif
+
+#ifdef UNIX
+	if (flash_screen != NULL)
+		putp(flash_screen);
+	return(OK);
+#endif
+
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, A_NORMAL);
+	delay_output( 50 );
+	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, A_REVERSE);
+	wrefresh(curscr);
+	return( OK );
+#endif
+
+#if defined(XCURSES)
+	XCursesInstructAndWait(CURSES_FLASH);
+	return( OK );
+#endif
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/bkgd.c stsgdb-6.8/pdcurses/pdcurses/bkgd.c
--- gdb-6.8/pdcurses/pdcurses/bkgd.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/bkgd.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,249 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	bkgd
+#undef	bkgdset
+#undef	wbkgd
+#undef	wbkgdset
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_bkgd  = "$Id: bkgd.c,v 1.3 2005/12/09 00:07:31 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          bkgd
+
+  Synopsis:
+  	int bkgd(chtype ch);
+  	void bkgdset(chtype ch);
+  	int wbkgd(WINDOW *win, chtype ch);
+  	void wbkgdset(WINDOW *win, chtype ch);
+
+  UNIX System V (Rel 3.2 or 4) Description:
+ 	The bkgdset() and wbkgdset() routines manipulate the backgound of 
+ 	the named window.  Background is a chtype consisting of any combination 
+ 	of attributes and non-blank characters that are written into the window
+ 	with waddch().  Both the character and attribute parts of the background
+ 	are combined with the blank characters.  The background becomes a 
+ 	property of the character and moves with the character through any 
+ 	scrolling and insert/delete line/character operations.  To the extent
+ 	possible on a particular terminal, the attribute part of the background
+ 	is displayed as the graphic rendition of the character put on the
+ 	screen.
+
+ 	The bkgd() and wbkgd() routines combine the new background with every
+ 	position in the window.  Background is any combination of attributes
+ 	and a character.  Only the attribute part is used to set the background
+ 	of non-blank characters, while both character and attributes are used
+ 	for blank positions.  To the extent possible on a particular terminal,
+ 	the attribute part of the background is displayed as the graphic
+ 	rendition of the character put on the screen.
+
+  PDCurses Description:
+ 	The attributes that are defined with the attrset()/attron() set of
+ 	functions take precedence over the background attributes if there is a
+ 	conflict (e.g., different color pairs).
+
+  System V Return Value:
+ 	bkgd() and wbkgd() return the integer OK, or a non-negative integer, if
+ 	immedok() is set.
+
+  PDCurses Return Value:
+ 	bkgd() and wbkgd() return the integer OK, unless the window is NULL,
+ 	in which case they return ERR.
+
+  System V Notes:
+ 	Note that bkgdset() and bkgd() may be macros.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      bkgd                                  -        -      4.0
+      bkgdset                               -        -      4.0
+      wbkgd                                 -        -      4.0
+      wbkgdset                              -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	bkgd(chtype ch)
+#else
+int	PDC_CDECL	bkgd(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("bkgd() - called\n");
+#endif
+	return(wbkgd(stdscr,ch));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wbkgd(WINDOW *win, chtype ch)
+#else
+int	PDC_CDECL	wbkgd(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+	int x, y;
+	chtype oldcolr, oldch, newcolr, newch, colr, attr;
+	chtype oldattr = 0, newattr = 0;
+	chtype *winptr;
+#ifdef NDP
+	char tmpbuf[60];
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wbkgd() - called\n");
+#endif
+
+	if (win == NULL)
+		return(ERR);
+
+	if( win->_bkgd == ch )
+		return OK;
+
+	oldcolr = (win->_bkgd & A_COLOR);
+	if( oldcolr != 0 )
+		oldattr = ((win->_bkgd & A_ATTRIBUTES) ^ oldcolr);
+	oldch   = (win->_bkgd & A_CHARTEXT);
+
+	wbkgdset( win, ch );
+
+	newcolr = (win->_bkgd & A_COLOR);
+	if( newcolr != 0 )
+		newattr = ((win->_bkgd & A_ATTRIBUTES) ^ newcolr);
+	newch   = (win->_bkgd & A_CHARTEXT);
+
+#ifdef NDP
+/* buggy compiler fix */
+	sprintf( tmpbuf, "%d %d", oldch, newch );
+#endif
+	
+/* what follows is what seems to occur in the System V implementation of */
+/* this routine */
+
+	for ( y = 0; y < win->_maxy; y++ ) {
+		for( x = 0; x < win->_maxx; x++ ) {
+
+			winptr = win->_y[y] + x;
+
+			ch = *winptr;
+
+		/* determine the colors and attributes of the character */
+		/* read from the window */
+
+			colr = (ch & A_COLOR);
+			attr = (ch & A_ATTRIBUTES);
+			if( colr != 0 )
+				attr = (attr ^ colr);
+
+		/* if the color is the same as the old background color, then */
+		/* make it the new background color, otherwise leave it */
+
+			if( colr == oldcolr )
+				colr = newcolr;
+
+		/* remove any attributes (non color) from the character that */
+		/* were part of the old background, then combine the remaining */
+		/* ones with the new background */
+
+			attr = (attr ^ oldattr);
+			attr |= newattr;
+
+		/* change character if it is there because it was the old */
+		/* background character */
+
+			ch = (ch & A_CHARTEXT);
+			if ( ch == oldch )
+				ch = newch;
+
+			ch = ((ch | attr) | colr);
+
+			*winptr = ch;
+
+		}
+	}
+
+	touchwin(win);
+	PDC_sync(win);
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	bkgdset(chtype ch)
+#else
+void	PDC_CDECL	bkgdset(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("bkgdset() - called\n");
+#endif
+	wbkgdset(stdscr,ch);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wbkgdset(WINDOW *win, chtype ch)
+#else
+void	PDC_CDECL	wbkgdset(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+	chtype bkgdattr;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wbkgdset() - called\n");
+#endif
+
+	if (win == NULL)
+		return;
+
+	if( win->_bkgd == ch )
+		return;
+
+	if ( (ch & A_ATTRIBUTES) == 0 )
+		bkgdattr = A_NORMAL;
+	else
+		bkgdattr = (ch & A_ATTRIBUTES);
+
+	ch = (ch & A_CHARTEXT);
+	
+	if( ch == 0 )
+		ch = ' ';
+
+	win->_bkgd = (ch | bkgdattr);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/border.c stsgdb-6.8/pdcurses/pdcurses/border.c
--- gdb-6.8/pdcurses/pdcurses/border.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/border.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,572 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	border
+#undef	wborder
+#undef	box
+#undef	hline
+#undef	whline
+#undef	vline
+#undef	wvline
+#undef	PDC_wunderline
+#undef	PDC_leftline
+#undef	PDC_rightline
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_border  = "$Id: border.c,v 1.4 2005/12/07 09:52:06 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        border
+
+  Synopsis:
+  	int border(chtype ls, chtype rs, chtype ts, chtype bs, chtype tl, 
+  	           chtype tr, chtype bl, chtype br);
+  	int wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, 
+  	            chtype bs, chtype tl, chtype tr, chtype bl, chtype br);
+  	int box(WINDOW *win, chtype verch, chtype horch);
+  	int hline(chtype ch, int n);
+  	int vline(chtype ch, int n);
+  	int whline(WINDOW *win, chtype ch, int n);
+  	int wvline(WINDOW *win, chtype ch, int n);
+  	int PDC_wunderline(WINDOW *win, int n, bool state);
+  	int PDC_wleftline(WINDOW *win, int n, bool state);
+  	int PDC_wrightline(WINDOW *win, int n, bool state);
+
+  X/Open Description:
+ 	The border(), wborder(), and box() routines, a border is drawn
+ 	around the edge of the window. If any of the arguments is zero,
+ 	an appropriate default is used. These default values are specified
+ 	in <curses.h>. The arguments and defaults to these functions are:
+ 		ls	left side of border		ACS_VLINE
+ 		rs	right side of border		ACS_VLINE
+ 		ts	top side of border		ACS_HLINE
+ 		bs	bottom side of border		ACS_HLINE
+ 		tl	top left corner of border	ACS_ULCORNER
+ 		tr	top right corner of border	ACS_URCORNER
+ 		bl	bottom left corner of border	ACS_BLCORNER
+ 		br	bottom right corner of border	ACS_BLCORNER
+
+ 	The hline() and whline() functions draw a left to right line
+ 	using ch starting from the current cursor position. The cursor
+ 	position does not change. The line is at most n characters long
+ 	or as many as will fit in the window.
+
+ 	The vline() and wvline() functions draw a top to bottom line
+ 	using ch starting from the current cursor position. The cursor
+ 	position does not change. The line is at most n characters long
+ 	or as many as will fit in the window.
+
+ 	border(), box(), hline(), and vline() are implemented as macros.
+
+  X/Open Return Value:
+ 	These functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for these functions.
+
+  Portability                             X/Open    BSD    SYS V  PDCurses
+                                          Dec '88
+      border                                -        -      4.0      Y
+      wborder                               -        -      4.0      Y
+      box                                   Y        Y       Y       Y
+      hline                                 -        -      4.0      Y
+      whline                                -        -      4.0      Y
+      vline                                 -        -      4.0      Y
+      wvline                                -        -      4.0      Y
+      PDC_wunderline                        -        -       -       Y
+      PDC_wleftline                         -        -       -       Y
+      PDC_wrightline                        -        -       -       Y
+
+**man-end**********************************************************************/
+
+/*man-start*********************************************************************
+  PDC_attr_passthru()   - Combines chtype with current and/or background 
+                          attributes of a window
+
+  PDCurses Description:
+    This is a private PDCurses function.
+
+    Takes a single chtype 'ch' and checks if the current attribute of 
+    window 'win', as set by wattrset(), and/or the current background 
+    of win, as set by wbkgd(), should by combined with it. Attributes 
+    set explicitly in ch take precedence.
+ 
+  PDCurses Return Value:
+    Returns ch, combined (or not) with existing attributes.
+
+  PDCurses Errors:
+    No errors are defined for this function.
+
+  Portability:
+    PDCurses chtype PDC_attr_passthru( WINDOW *win, chtype ch );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype PDC_attr_passthru(WINDOW *win, chtype ch)
+#else
+chtype PDC_attr_passthru(win, ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+	chtype attr, bktmp;
+
+   /*
+    * If the incoming character doesn't have its own attribute,
+    * then use the current attributes for the window.
+    * If the incoming character has attributes, but not a colour
+    * component, OR the attributes to the current attributes
+    * for the window.
+    * If the incoming character has a colour component, use only
+    * the attributes from the incoming character.
+    */
+
+	if ((ch & A_ATTRIBUTES) == 0)
+		attr = win->_attrs;
+	else
+		if ((ch & A_COLOR) == 0)
+			attr = (ch & A_ATTRIBUTES) | win->_attrs;
+		else
+			attr = (ch & A_ATTRIBUTES);
+
+   /* wrs (4/10/93)
+    * Apply the same sort of logic for the window background, in that it 
+    * only takes precedence if other color attributes are not there.
+    */
+
+	if ((attr & A_COLOR) == 0)
+		attr = (attr | (win->_bkgd & A_ATTRIBUTES));
+	else
+	{
+		bktmp = (win->_bkgd & A_COLOR);
+		attr = (attr | ( (win->_bkgd & A_ATTRIBUTES) ^ bktmp ));
+	}
+
+	ch = (ch & A_CHARTEXT) | attr;
+
+	return ch;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wborder(WINDOW *win, chtype ls, chtype rs, chtype ts, chtype bs,
+            chtype tl, chtype tr, chtype bl, chtype br)
+#else
+int	PDC_CDECL	wborder(win,ls,rs,ts,bs,tl,tr,bl,br)
+WINDOW *win;
+chtype ls;
+chtype rs;
+chtype ts;
+chtype bs;
+chtype tl;
+chtype tr;
+chtype bl;
+chtype br;
+#endif
+/***********************************************************************/
+{
+	int ymax,xmax;
+	int ymin,xmin;
+	int	i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wborder() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+	ymax = win->_maxy - 1;
+	xmax = win->_maxx - 1;
+	ymin = 0;
+	xmin = 0;
+
+	ls = PDC_attr_passthru(win, ls ? ls : ACS_VLINE);
+	rs = PDC_attr_passthru(win, rs ? rs : ACS_VLINE);
+	ts = PDC_attr_passthru(win, ts ? ts : ACS_HLINE);
+	bs = PDC_attr_passthru(win, bs ? bs : ACS_HLINE);
+	tl = PDC_attr_passthru(win, tl ? tl : ACS_ULCORNER);
+	tr = PDC_attr_passthru(win, tr ? tr : ACS_URCORNER);
+	bl = PDC_attr_passthru(win, bl ? bl : ACS_LLCORNER);
+	br = PDC_attr_passthru(win, br ? br : ACS_LRCORNER);
+
+	for (i = xmin + 1; i <= xmax - 1; i++)
+	{
+		win->_y[ymin][i] = ts;
+		win->_y[ymax][i] = bs;
+	}
+
+	for (i = ymin + 1; i <= ymax - 1; i++)
+	{
+		win->_y[i][xmin] = ls;
+		win->_y[i][xmax] = rs;
+	}
+
+	win->_y[ymin][xmin] = tl;
+	win->_y[ymin][xmax] = tr;
+	win->_y[ymax][xmin] = bl;
+	win->_y[ymax][xmax] = br;
+
+	for (i = ymin; i <= ymax; i++)
+	{
+		if (win->_firstch[i] == _NO_CHANGE)
+		{
+			win->_firstch[i] = xmin;
+			win->_lastch[i] = xmax;
+		}
+		else
+		{
+			win->_firstch[i] = min(win->_firstch[i], xmin);
+			win->_lastch[i] = max(win->_lastch[i], xmax);
+		}
+	}
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	border(chtype ls, chtype rs, chtype ts, chtype bs,
+           chtype tl, chtype tr, chtype bl, chtype br)
+#else
+int	PDC_CDECL	border(ls,rs,ts,bs,tl,tr,bl,br)
+chtype ls;
+chtype rs;
+chtype ts;
+chtype bs;
+chtype tl;
+chtype tr;
+chtype bl;
+chtype br;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("border() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(wborder(stdscr,ls,rs,ts,bs,tl,tr,bl,br));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	box(WINDOW *win, chtype verch, chtype horch)
+#else
+int	PDC_CDECL	box(win,verch,horch)
+WINDOW *win;
+chtype verch;
+chtype horch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("box() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(wborder(win,verch,verch,horch,horch,0,0,0,0));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	hline(chtype ch, int n)
+#else
+int	PDC_CDECL	hline(ch,n)
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("hline() - called\n");
+#endif
+
+	return(whline(stdscr,ch,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	whline(WINDOW *win, chtype ch, int n)
+#else
+int	PDC_CDECL	whline(win,ch,n)
+WINDOW *win;
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	int	startpos;
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("whline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_curx + n -1, win->_maxx);
+
+	ch = PDC_attr_passthru(win, ch ? ch : ACS_HLINE);
+
+	startpos = win->_curx;
+
+	for (n = win->_curx; n <= endpos; n++)
+		win->_y[win->_cury][n] = ch;
+
+	n = win->_cury;
+
+	if (win->_firstch[n] == _NO_CHANGE)
+	{
+		win->_firstch[n] = startpos;
+		win->_lastch[n] = endpos;
+	}
+	else
+	{
+		win->_firstch[n] = min(win->_firstch[n], startpos);
+		win->_lastch[n] = max(win->_lastch[n], endpos);
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	vline(chtype ch, int n)
+#else
+int	PDC_CDECL	vline(ch,n)
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("vline() - called\n");
+#endif
+
+	return(wvline(stdscr,ch,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wvline(WINDOW *win, chtype ch, int n)
+#else
+int	PDC_CDECL	wvline(win,ch,n)
+WINDOW *win;
+chtype ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wvline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	ch = PDC_attr_passthru(win, ch ? ch : ACS_VLINE);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		win->_y[n][win->_curx] = ch;
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_wunderline(WINDOW *win, int n, bool state)
+#else
+int	PDC_CDECL	PDC_wunderline(win,n,state)
+WINDOW *win;
+int n;
+bool state;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_wunderline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		if ( state ) 
+			win->_y[n][win->_curx] |= A_UNDERLINE; /* Turn ON A_UNDERLINE */
+		else
+			win->_y[n][win->_curx] |= ~A_UNDERLINE; /* Turn OFF A_UNDERLINE */
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_wleftline(WINDOW *win, int n, bool state)
+#else
+int	PDC_CDECL	PDC_wleftline(win,n,state)
+WINDOW *win;
+int n;
+bool state;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_wleftline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		if ( state ) 
+			win->_y[n][win->_curx] |= A_LEFTLINE; /* Turn ON A_LEFTLINE */
+		else
+			win->_y[n][win->_curx] |= ~A_LEFTLINE; /* Turn OFF A_LEFTLINE */
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_wrightline(WINDOW *win, int n, bool state)
+#else
+int	PDC_CDECL	PDC_wrightline(win,n,state)
+WINDOW *win;
+int n;
+bool state;
+#endif
+/***********************************************************************/
+{
+	int	endpos;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_wrightline() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 1)
+		return( ERR );
+
+	endpos = min(win->_cury + n -1, win->_maxy);
+
+	for (n = win->_cury; n <= endpos; n++)
+	{
+		if ( state ) 
+			win->_y[n][win->_curx] |= A_RIGHTLINE; /* Turn ON A_RIGHTLINE */
+		else
+			win->_y[n][win->_curx] |= ~A_RIGHTLINE; /* Turn OFF A_RIGHTLINE */
+
+		if (win->_firstch[n] == _NO_CHANGE)
+		{
+			win->_firstch[n] = win->_curx;
+			win->_lastch[n] = win->_curx;
+		}
+		else
+		{
+			win->_firstch[n] = min(win->_firstch[n], win->_curx);
+			win->_lastch[n] = max(win->_lastch[n], win->_curx);
+		}
+	}
+
+	PDC_sync(win);
+	return (OK);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/clear.c stsgdb-6.8/pdcurses/pdcurses/clear.c
--- gdb-6.8/pdcurses/pdcurses/clear.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/clear.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,266 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	clear
+#undef	wclear
+#undef	erase
+#undef	werase
+#undef	clrtobot
+#undef	wclrtobot
+#undef	clrtoeol
+#undef	wclrtoeol
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_clear  = "$Id: clear.c,v 1.3 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         clear
+
+  Synopsis:
+  	int clear(void);
+  	int wclear(WINDOW *win);
+  	int erase(void);
+  	int werase(WINDOW *win);
+  	int clrtobot(void);
+  	int wclrtobot(WINDOW *win);
+  	int clrtoeol(void);
+  	int wclrtoeol(WINDOW *win);
+
+  X/Open Description:
+  	The erase() and werase() functions copy blanks to every position
+  	of the window.
+
+  	The clear() and wclear() functions are similar to erase() and
+  	werase() except they also call clearok() to ensure that the
+  	the screen is cleared on the next call to wrefresh() for that
+  	window.
+
+  	The clrtobot() and wclrtobot() functions clear the screen from
+  	the current cursor position to the end of the current line and
+  	all remaining lines in the window.
+
+  	The clrtoeol() and wclrtoeol() functions clear the screen from
+  	the current cursor position to the end of the current line only.
+
+ 	NOTE: clear(), wclear(), erase(), clrtobot(), and clrtoeol()
+ 	are implemented as macros
+
+  PDCurses Description:
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  NOTE:
+ 	The behaviour of Unix curses is to clear the line with a space
+ 	and attributes of A_NORMAL. PDCurses clears the line with the
+ 	window's current attributes (including current colour). To get
+ 	the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
+ 	add -DPDCURSES_WCLR to the compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      clear                                 Y        Y       Y
+      wclear                                Y        Y       Y
+      erase                                 Y        Y       Y
+      werase                                Y        Y       Y
+      clrtobot                              Y        Y       Y
+      wclrtobot                             Y        Y       Y
+      clrtoeol                              Y        Y       Y
+      wclrtoeol                             Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clear(void)
+#else
+int	PDC_CDECL	clear()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("clear() - called\n");
+#endif
+
+	if  (stdscr == (WINDOW *)NULL)
+		return(ERR);
+
+	stdscr->_clear = TRUE;
+	return(erase());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wclear( WINDOW *win )
+#else
+int	PDC_CDECL	wclear(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wclear() - called\n");
+#endif
+
+	if  (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_clear = TRUE;
+	return( werase( win ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	erase(void)
+#else
+int	PDC_CDECL	erase()
+#endif
+/***********************************************************************/
+{
+	return( werase(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	werase(WINDOW *win)
+#else
+int	PDC_CDECL	werase(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("werase() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	(void)wmove(win,0,0);
+	return (wclrtobot(win));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clrtobot(void)
+#else
+int	PDC_CDECL	clrtobot()
+#endif
+/***********************************************************************/
+{
+	return( wclrtobot(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wclrtobot(WINDOW *win)
+#else
+int	PDC_CDECL	wclrtobot(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	int	savey=win->_cury;
+	int	savex=win->_curx;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wclrtobot() - called\n");
+#endif
+
+	if  (win == (WINDOW *)NULL)
+		return( ERR );
+
+/* should this involve scrolling region somehow ? */
+
+	if (win->_cury + 1 < win->_maxy)
+		{
+		win->_curx = 0;
+		win->_cury++;
+		for ( ; win->_maxy > win->_cury; win->_cury++)
+			(void)wclrtoeol(win);
+		win->_cury = savey;
+		win->_curx = savex;
+		}
+	(void)wclrtoeol(win);
+
+	PDC_sync(win);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clrtoeol(void)
+#else
+int	PDC_CDECL	clrtoeol()
+#endif
+/***********************************************************************/
+{
+	return( wclrtoeol(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wclrtoeol(WINDOW *win)
+#else
+int	PDC_CDECL	wclrtoeol(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	int	x, y, minx;
+	chtype	blank, *ptr;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wclrtoeol() - called: Row: %d Col: %d\n",
+		win->_cury, win->_curx);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	y = win->_cury;
+	x = win->_curx;
+
+#if defined(PDCURSES_WCLR)
+	blank = win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank = win->_bkgd;
+#endif
+
+	for (minx = x, ptr = &win->_y[y][x]; minx < win->_maxx; minx++, ptr++)
+		*ptr = blank;
+
+	win->_firstch[y] = (win->_firstch[y] == _NO_CHANGE) ?
+		x : min(x, win->_firstch[y]);
+	win->_lastch[y] = max(win->_lastch[y], win->_maxx - 1);
+
+	PDC_sync(win);
+	return( OK );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/color.c stsgdb-6.8/pdcurses/pdcurses/color.c
--- gdb-6.8/pdcurses/pdcurses/color.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/color.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,451 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	start_color
+#undef	init_pair
+#undef	init_color
+#undef	has_colors
+#undef	can_change_color
+#undef	color_content
+#undef	pair_content
+#undef	PDC_set_line_color
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef HAVE_PROTO
+static int PDC_init_pair(short,short,short);
+#else
+static int PDC_init_pair();
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_color  = "$Id: color.c,v 1.12 2005/12/16 23:27:47 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         color
+
+  Synopsis:
+  	int start_color(void);
+  	int init_pair(short pair, short fg, short bg);
+  	int init_color(short color, short red, short green, short blue);
+  	bool has_colors(void);
+  	bool can_change_color(void);
+  	int color_content(short color, short *redp, short *greenp, short *bluep);
+  	int pair_content(short pair, short *fgp, short *bgp);
+  	int PDC_set_line_color(short color);
+
+  X/Open Description:
+ 	To use these routines, start_color() must be called, usually
+ 	immediately after initscr(). Colors are always used in pairs refered
+ 	to as color-pairs. A color-pair consists of a foreground color and
+ 	a background color. A color-pair is initialized with init_pair().
+ 	After it has been initialized, COLOR_PAIR(n), a macro defined in
+ 	<curses.h>, can be used like any other video attribute.
+
+ 	start_color() initializes eight basic colors (black,red,green,yellow,
+ 	blue,magenta,cyan, and white), and two global variables; COLORS
+ 	and COLOR_PAIRS (respectively defining the maximum number of
+ 	colors and color-pairs the terminal is capable of displaying).
+
+ 	init_pair() changes the definitions of a color-pair.
+ 	The routine takes three arguments: the number of the color-pair
+ 	to be redefined, and the new values of the foreground and
+ 	background colors.
+ 	The value of color-pair must be between 1 and COLOR_PAIRS-1.
+ 	The values of foreground and background must be between 0 and
+ 	COLORS-1 (this is a PDCurses abberation; normally it is 0 and
+ 	COLORS)
+ 	If the color pair was previously initialized, the screen is refreshed
+ 	and all occurrences of that color-pair are changed to the new
+ 	definition.
+
+ 	has_colors() indicates if the terminal supports, and can maniplulate
+ 	color. It returns TRUE or FALSE.
+
+ 	can_change_color() indicates if the terminal has the capability
+ 	to change the definition of its colors. Although this is possible,
+ 	at least with VGA monitors, this function always returns FALSE.
+
+ 	pair_content() is used to determine what the colors of a given
+ 	color-pair consist of.
+
+ 	PDC_set_line_color() is used to set the color, globally, for the
+ 	color of the lines drawn for the attributes: A_UNDERLINE, A_OVERLINE,
+ 	A_LEFTLINE and A_RIGHTLINE.  PDCurses only feature.
+
+ 	NOTE: has_colors() is implemented as a macro.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error except for
+ 	has_colors() and can_change_colors() which return TRUE or FALSE.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V   PDCurses
+                                          Dec '88
+      start_color                           -        -      3.2
+      init_pair                             -        -      3.2
+      init_color                            -        -      3.2
+      has_colors                            -        -      3.2
+      can_change_color                      -        -      3.2
+      color_content                         -        -      3.2
+      pair_content                          -        -      3.2
+      PDC_set_line_color                    -        -       -       Y
+
+**man-end**********************************************************************/
+
+int	COLORS = PDC_COLORS;
+int	COLOR_PAIRS = PDC_COLOR_PAIRS;
+
+#if defined(CHTYPE_LONG)
+#   if defined(XCURSES)
+unsigned char *atrtab=NULL;
+#   else
+unsigned char atrtab[MAX_ATRTAB]; /* COLOR_PAIR to attribute encoding table. */
+#   endif
+#else
+unsigned char  atrtab[MAX_ATRTAB] = /* COLOR_PAIR to attribute encoding table. */
+ {0x07,0x0F,0x70,0x78,0x87,0x8F,0xF0,0xF8, /* A_NORMAL */
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x00,0x08,0x70,0x78,0x80,0x88,0xF0,0xF8,
+  0x70,0x00,0x17,0x00,0x00,0x00,0x00,0x00  /* for flash() */
+  };
+#endif
+
+unsigned char colourset[PDC_COLOR_PAIRS];
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	start_color(void)
+#else
+int	PDC_CDECL	start_color()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("start_color() - called\n");
+#endif
+ if (SP->mono)
+    return(ERR);
+ COLORS = 8;
+#if defined(CHTYPE_LONG)
+ COLOR_PAIRS = PDC_COLOR_PAIRS;
+/* PDC_init_atrtab(); - already done in initscr() */
+#else
+ COLOR_PAIRS = 33;  /* actually only allows 32 */
+#endif
+ memset(colourset,0,PDC_COLOR_PAIRS);
+ return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	init_pair(short colorpair,short foreground,short background)
+#else
+int	PDC_CDECL	init_pair(colorpair,foreground,background)
+short colorpair;
+short foreground;
+short background;
+#endif
+/***********************************************************************/
+{
+ short oldforeground, oldbackground;
+#if defined(CHTYPE_LONG) && !defined(XCURSES)
+# define USE_PDC_INIT
+#else
+ unsigned char norm;
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("init_pair() - called: colorpair %d fore %d back %d\n",colorpair,foreground,background);
+#endif
+
+ if (colorpair >= COLOR_PAIRS || colorpair < 1)
+    return(ERR);
+
+ oldforeground = (short)(atrtab[colorpair*PDC_OFFSET] & 0x0F);
+ oldbackground = (short)((atrtab[colorpair*PDC_OFFSET] & 0xF0)>>4);
+
+#ifdef USE_PDC_INIT
+ PDC_init_pair(colorpair,foreground,background);
+#else
+ norm = (unsigned char)(foreground & 0x0007) + ((background & 0x0007)<<4);
+
+ atrtab[(colorpair*PDC_OFFSET)+0] = norm;                         /* normal */
+# ifndef XCURSES
+ atrtab[(colorpair*PDC_OFFSET)+1] = norm + 8;                       /* bold */
+ atrtab[(colorpair*PDC_OFFSET)+4] = norm + 128;                    /* blink */
+ atrtab[(colorpair*PDC_OFFSET)+5] = norm + 8 + 128;           /* bold-blink */
+# endif
+#endif
+
+/*
+ * To allow the PDC_PRESERVE_SCREEN option to work, we only reset
+ * curscr if this call to init_pair() alters a color pair created
+ * by the user.
+ */
+ if (colourset[colorpair])
+   {
+    if ( oldforeground != foreground || oldbackground != background )
+        curscr->_clear = TRUE;
+   }
+ colourset[colorpair] = TRUE;
+ return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_CDECL	has_colors(void)
+#else
+bool	PDC_CDECL	has_colors()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_colors() - called\n");
+#endif
+	if (SP->mono)
+		return(FALSE);
+	return(TRUE);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	init_color(short color,short red,short green,short blue)
+#else
+int	PDC_CDECL	init_color(color,red,green,blue)
+short color;
+short red;
+short green;
+short blue;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("init_color() - called\n");
+#endif
+/*************** this does nothing at the moment ******************/
+	return(ERR);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	color_content(short color,short *red,short *green,short *blue)
+#else
+int	PDC_CDECL	color_content(color,red,green,blue)
+short color;
+short *red;
+short *green;
+short *blue;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("color_content() - called\n");
+#endif
+	/* A crude implementation. Does not account for intensity. 
+	   ncurses uses 680 for non-A_BOLD, so let's copy that. - WJM3
+	*/
+
+	if ((color >= COLORS || color < 0) || (!red || !green || !blue))
+		return(ERR);
+
+	*red = (color & COLOR_RED) ? 680 : 0;
+	*green = (color & COLOR_GREEN) ? 680 : 0;
+	*blue = (color & COLOR_BLUE) ? 680 : 0;
+
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	can_change_color(void)
+#else
+int	PDC_CDECL	can_change_color()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("can_change_color() - called\n");
+#endif
+
+#ifdef UNIX
+	if (can_change)
+		return(TRUE);
+	else
+		return(FALSE);
+#else
+	return(FALSE);
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	pair_content(int colorpair,short *foreground,short *background)
+#else
+int	PDC_CDECL	pair_content(colorpair,foreground,background)
+int colorpair;
+short *foreground;
+short *background;
+#endif
+/***********************************************************************/
+{
+
+ if ((colorpair >= COLOR_PAIRS || colorpair < 1) ||
+     (!foreground || !background))
+	return(ERR);
+
+ *foreground = (short)(atrtab[colorpair*PDC_OFFSET] & 0x0F);
+ *background = (short)((atrtab[colorpair*PDC_OFFSET] & 0xF0)>>4);
+
+ return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_set_line_color(short color)
+#else
+int	PDC_CDECL	PDC_set_line_color(color)
+short color;
+#endif
+/***********************************************************************/
+{
+   if (color >= COLORS || color < 0)
+      return(ERR);
+   SP->line_color = color;
+   return(OK);
+}
+
+#if defined(CHTYPE_LONG)
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_init_atrtab(void)
+#else
+int	PDC_init_atrtab()
+#endif
+/***********************************************************************/
+{
+   int orig_fore, orig_back;
+   register int i;
+
+   if ( SP->orig_attr == 0 )
+   {
+      orig_fore = COLOR_WHITE;
+      orig_back = COLOR_BLACK;
+   }
+   else
+   {
+      orig_fore = SP->orig_attr & A_CHARTEXT;
+      orig_back = (SP->orig_attr & A_ATTRIBUTES) >> 16;
+   }
+
+   for ( i = 0; i <PDC_COLOR_PAIRS; i++ )
+      PDC_init_pair( i, orig_fore, orig_back );
+   PDC_init_pair( PDC_COLOR_PAIRS, orig_back, orig_fore );
+   return(0);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+static	int PDC_init_pair(short pairnum,short fg,short bg)
+#else
+static	int PDC_init_pair(pairnum,fg,bg)
+short pairnum;
+short fg;
+short bg;
+#endif
+/***********************************************************************/
+{
+   register int i;
+   unsigned char temp_bg;
+   int ttt,uuu;
+
+   for (i=0;i<PDC_OFFSET;i++)
+   {
+      atrtab[(pairnum*PDC_OFFSET)+i] = fg | (bg << 4);
+      ttt = A_REVERSE >> 19;
+      uuu = i&ttt;
+      if (uuu == ttt)
+         atrtab[(pairnum*PDC_OFFSET)+i] = bg | (fg << 4);
+      ttt = A_UNDERLINE >> 19;
+      uuu = i&ttt;
+      if (uuu == ttt)
+         atrtab[(pairnum*PDC_OFFSET)+i] = 1;
+      ttt = A_INVIS >> 19;
+      uuu = i&ttt;
+      if (uuu == ttt)
+      {
+         temp_bg = (atrtab[(pairnum*PDC_OFFSET)+i])>>4;
+         atrtab[(pairnum*PDC_OFFSET)+i] = temp_bg<<4|temp_bg;
+      }
+      ttt = A_BOLD >> 19;
+      uuu = i&ttt;
+      if (uuu == ttt)
+         atrtab[(pairnum*PDC_OFFSET)+i] |= 8;
+      ttt = A_BLINK >> 19;
+      uuu = i&ttt;
+      if (uuu == ttt)
+         atrtab[(pairnum*PDC_OFFSET)+i] |= 128;
+   }
+   return(0);
+}
+#endif
diff -Naur gdb-6.8/pdcurses/pdcurses/delch.c stsgdb-6.8/pdcurses/pdcurses/delch.c
--- gdb-6.8/pdcurses/pdcurses/delch.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/delch.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,190 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	delch
+#undef	wdelch
+#undef	mvdelch
+#undef	mvwdelch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifndef HAVE_MEMMOVE
+#  define memmove PDC_memmove
+#endif
+
+
+#ifdef PDCDEBUG
+char *rcsid_delch  = "$Id: delch.c,v 1.1 2001/01/10 08:26:57 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         delch
+
+  Synopsis:
+  	int delch(void);
+  	int wdelch(WINDOW *win);
+  	int mvdelch(int y, int x);
+  	int mvwdelch(WINDOW *win, int y, int x);
+
+  X/Open Description:
+ 	The character under the cursor in the window is deleted.  All
+ 	characters to the right on the same line are moved to the left
+ 	one position and the last character on the line is filled with
+ 	a blank.  The cursor position does not change (after moving to
+ 	y, x if coordinates are specified).
+
+ 	NOTE: delch(), mvdelch(), and mvwdelch() are implemented as macros.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  NOTE:
+ 	The behaviour of Unix curses is to display a blank in the last
+ 	column of the window with the A_NORMAL attribute. PDCurses
+ 	displays the blank with the window's current attributes 
+ 	(including current colour). To get the behaviour of PDCurses,
+ 	#define PDCURSES_WCLR in curses.h or add -DPDCURSES_WCLR to the 
+ 	compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      delch                                 Y        Y       Y
+      wdelch                                Y        Y       Y
+      mvdelch                               Y        Y       Y
+      mvwdelch                              Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	delch(void)
+#else
+int	PDC_CDECL	delch()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("delch() - called\n");
+#endif
+
+	return (wdelch(stdscr));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wdelch(WINDOW *win)
+#else
+int	PDC_CDECL	wdelch(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	int		y;
+	int		x;
+	int		maxx;
+	chtype*		temp1;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wdelch() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (ERR);
+
+	y	= win->_cury;
+	x	= win->_curx;
+	maxx	= win->_maxx - 1;
+	temp1	= &win->_y[y][x];
+
+	memmove( temp1, temp1 + 1, (maxx - x) * sizeof(chtype) );
+
+#if defined(PDCURSES_WCLR)
+	win->_y[y][maxx]	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	win->_y[y][maxx]	= win->_bkgd;
+#endif
+
+	win->_lastch[y] = maxx;
+
+	if ((win->_firstch[y] == _NO_CHANGE) ||
+	    (win->_firstch[y] > x))
+	{
+		win->_firstch[y] = x;
+	}
+	PDC_sync(win);
+	return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvdelch(int y, int x)
+#else
+int	PDC_CDECL	mvdelch(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvdelch() - called\n");
+#endif
+
+	if (move(y,x) == ERR)
+		return(ERR);
+	return(delch());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwdelch(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwdelch(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwdelch() - called\n");
+#endif
+
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return(wdelch(win));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/deleteln.c stsgdb-6.8/pdcurses/pdcurses/deleteln.c
--- gdb-6.8/pdcurses/pdcurses/deleteln.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/deleteln.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,324 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	deleteln
+#undef	wdeleteln
+#undef	insdelln
+#undef	winsdelln
+#undef	insertln
+#undef	winsertln
+#undef	mvwinsertln
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_deleteln  = "$Id: deleteln.c,v 1.1 2001/01/10 08:26:58 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                      deleteln
+
+  Synopsis:
+  	int deleteln(void);
+  	int wdeleteln(WINDOW *win);
+  	int insdelln(int n);
+  	int winsdelln(WINDOW *win, int n);
+  	int insertln(void);
+  	int winsertln(WINDOW *win);
+  	int mvwinsertln(WINDOW *win, int y, int x);
+
+  X/Open Description:
+ 	With the deleteln() and wdelteln() functions,
+ 	the line under the cursor in the window is deleted.  All
+ 	lines below the current line are moved up one line.  The
+ 	bottom line of the window is cleared.  The cursor position
+ 	does not change.
+
+ 	With the insertln() and winsertn() functions,
+ 	a blank line is inserted above the current line and the bottom
+ 	line is lost.
+
+ 	NOTE: deleteln() and insertln() are implemented as macros.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  NOTE:
+ 	The behaviour of Unix curses is to clear the line with a space
+ 	and attributes of A_NORMAL. PDCurses clears the line with the
+ 	window's current attributes (including current colour). To get
+ 	the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
+ 	add -DPDCURSES_WCLR to the compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      deleteln                              Y        Y       Y
+      wdeleteln                             Y        Y       Y
+      insdelln                              -        -      4.0
+      winsdelln                             -        -      4.0
+      insertln                              Y        Y       Y
+      winsertln                             Y        Y       Y
+      mvwinsertln                           -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	deleteln(void)
+#else
+int	PDC_CDECL	deleteln()
+#endif
+/***********************************************************************/
+{
+	chtype	blank;
+	chtype*	temp;
+	chtype*	ptr;
+	int	y;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("deleteln() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+#if defined(PDCURSES_WCLR)
+	blank	= stdscr->_blank | stdscr->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= stdscr->_bkgd;
+#endif
+	temp	= stdscr->_y[stdscr->_cury];
+
+	for (y = stdscr->_cury; y < stdscr->_bmarg; y++)
+	{
+		stdscr->_y[y]	 = stdscr->_y[y + 1];
+		stdscr->_firstch[y] = 0;
+		stdscr->_lastch[y] = stdscr->_maxx - 1;
+	}
+
+	for (ptr = temp; (ptr - temp < stdscr->_maxx); ptr++)
+		*ptr = blank;			/* make a blank line */
+
+	if( stdscr->_cury <= stdscr->_bmarg ) 
+	{
+		stdscr->_firstch[stdscr->_bmarg]	= 0;
+		stdscr->_lastch[stdscr->_bmarg]	= stdscr->_maxx - 1;
+		stdscr->_y[stdscr->_bmarg]		= temp;
+	}
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wdeleteln(WINDOW *win)
+#else
+int	PDC_CDECL	wdeleteln(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	chtype	blank;
+	chtype*	temp;
+	chtype*	ptr;
+	int	y;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wdeleteln() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+#if defined(PDCURSES_WCLR)
+	blank	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= win->_bkgd;
+#endif
+	temp	= win->_y[win->_cury];
+
+	for (y = win->_cury; y < win->_bmarg; y++)
+	{
+		win->_y[y]	 = win->_y[y + 1];
+		win->_firstch[y] = 0;
+		win->_lastch[y] = win->_maxx - 1;
+	}
+
+	for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+		*ptr = blank;			/* make a blank line */
+
+	if( win->_cury <= win->_bmarg ) 
+	{
+		win->_firstch[win->_bmarg]	= 0;
+		win->_lastch[win->_bmarg]	= win->_maxx - 1;
+		win->_y[win->_bmarg]		= temp;
+	}
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insdelln(int n)
+#else
+int	PDC_CDECL	insdelln(n)
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insdelln() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsdelln(stdscr,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsdelln(WINDOW *win, int n)
+#else
+int	PDC_CDECL	winsdelln(win,n)
+WINDOW *win;
+int n;
+#endif
+/***********************************************************************/
+{
+	int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsdelln() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( n > 0 ) {
+		for(i=0; i<n; i++) {
+			if( winsertln(win) == ERR )
+				return ERR;
+		}
+	}
+	else if( n < 0 ) {
+		n = -n;
+		for(i=0; i<n; i++) {
+			if( wdeleteln(win) == ERR )
+				return ERR;
+		}
+	}
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsertln(WINDOW *win)
+#else
+int	PDC_CDECL	winsertln(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	chtype	blank;
+	chtype*	temp;
+	chtype*	end;
+	short	y;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsertln() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+#if defined(PDCURSES_WCLR)
+	blank	= win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+	blank	= win->_bkgd;
+#endif
+	temp	= win->_y[win->_maxy-1];
+
+	for (y = win->_maxy-1; y > win->_cury; y--)
+	{
+		win->_y[y]	 = win->_y[y - 1];
+		win->_firstch[y] = 0;
+		win->_lastch[y] = win->_maxx - 1;
+	}
+
+	win->_y[win->_cury] = temp;
+
+	for (end = &temp[win->_maxx - 1]; temp <= end; temp++)
+	{
+		*temp = blank;
+	}
+
+	win->_firstch[win->_cury] = 0;
+	win->_lastch[win->_cury] = win->_maxx - 1;
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insertln(void)
+#else
+int	PDC_CDECL	insertln()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insertln() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsertln(stdscr));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsertln(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwinsertln(win, y, x)
+WINDOW *win;
+int y,x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinsertln() - called\n");
+#endif
+
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return(winsertln(win));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/getch.c stsgdb-6.8/pdcurses/pdcurses/getch.c
--- gdb-6.8/pdcurses/pdcurses/getch.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/getch.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,420 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	getch
+#undef	wgetch
+#undef	mvgetch
+#undef	mvwgetch
+#undef	ungetch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	wrefresh
+#  undef	nocbreak
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_getch  = "$Id: getch.c,v 1.10 2005/12/17 09:17:16 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         getch
+
+  Synopsis:
+  	int getch(void);
+  	int wgetch(WINDOW *win);
+  	int mvgetch(int y, int x);
+  	int mvwgetch(WINDOW *win, int y, int x);
+  	int ungetch(int ch);
+
+  X/Open Description:
+ 	With the getch(), wgetch(), mvgetch(), and mvwgetch() functions, 
+ 	a character is read from the terminal associated with the window. 
+ 	In nodelay mode, if there is no input
+ 	waiting, the value ERR is returned. In delay mode, the program will
+ 	hang until the system passes text through to the program.
+ 	Depending on the setting of cbreak(), this will be after one
+ 	character or after the first newline.  Unless noecho() has
+ 	been set, the character will also be echoed into the designated
+ 	window.
+
+ 	If keypad() is TRUE, and a function key is pressed, the token for
+ 	that function key will be returned instead of the raw characters.
+ 	Possible function keys are defined in <curses.h> with integers
+ 	beginning with 0401, whose names begin with KEY_.  If a character
+ 	is received that could be the beginning of a function key (such as
+ 	escape), curses will set a timer.  If the remainder of the sequence
+ 	does not come in within the designated time, the character will be
+ 	passed through, otherwise the function key value will be returned.
+ 	For this reason, on many terminals, there will be a delay after a
+ 	user presses the escape key before the escape is returned to the
+ 	program.  (Use by a programmer of the escape key for a single
+ 	character function is discouraged.)
+
+ 	If nodelay(win,TRUE) has been called on the window and no input is
+ 	waiting, the value ERR is returned.
+
+ 	The ungetch() function places ch back onto the input queue to be
+ 	returned by the next call to wgetch().
+
+ 	NOTE: getch(), mvgetch() and mvwgetch() are implemented as macros.
+
+  PDCurses Description:
+ 	Given the nature of the PC, there is no such timer set for an
+ 	incoming ESCAPE value, because function keys generate unique
+ 	scan codes that are not prefixed with the ESCAPE character.
+
+ 	Also, note that the getch() definition will conflict  with
+ 	many DOS compiler's runtime libraries.
+
+  X/Open Return Value:
+ 	This functions return ERR or the value of the character, meta 
+ 	character or function key token.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      getch                                 Y        Y       Y
+      wgetch                                Y        Y       Y
+      mvgetch                               Y        Y       Y
+      mvwgetch                              Y        Y       Y
+      ungetch                               Y        Y       Y
+
+**man-end**********************************************************************/
+
+static WINDOW *w;			/* to reduce stack usage   */
+
+/* this define to get around DOS libraries conflict */
+#define getch PDC_getch
+#define ungetch PDC_ungetch
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_getch(void)
+#else
+int	PDC_CDECL	PDC_getch()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getch() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(wgetch(stdscr));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wgetch(WINDOW *win)
+#else
+int	PDC_CDECL	wgetch(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+extern	int	c_pindex;		/* putter index		   */
+extern	int	c_gindex;		/* getter index		   */
+extern	int	c_ungind;		/* ungetch() push index   */
+extern	int	c_ungch[NUNGETCH];	/* array of ungotten chars */
+extern  WINDOW*	_getch_win_;
+
+/*	signed	key; MH*/
+	int	key;
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+	bool	cbr;
+#endif
+/*	static	chtype	buffer[_INBUFSIZ];MH*/	/* character buffer */
+	static	int	buffer[_INBUFSIZ];	/* character buffer */
+#ifdef UNIX
+	short display_key = 0400;
+	bool cbreak_set = FALSE;
+#else
+	short display_key = 0x100;
+#endif
+	int waitingtenths = 0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wgetch() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if ( SP->delaytenths )
+		waitingtenths = 2*SP->delaytenths; /* set the number of 1/20th second napms() calls */
+	else if ( win->_delayms )
+	{
+		/*
+		 * As granularity of clocks is not ideal for waiting for individual periods
+		 * of 1 millisecond, we need to determine a reasonably accurate mechanism
+		 * based on the specified delay period. As delaying by 1/20th of a second
+		 * is reasonable, then determine how many 1/20th seconds are in the specified
+		 * delay time, and pause that many times.
+		 */
+		waitingtenths = win->_delayms / 50;
+		if (waitingtenths == 0)
+			waitingtenths = 1;
+	}
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("initial: %d delaytenths %d delayms %d\n", waitingtenths,SP->delaytenths, win->_delayms);
+#endif
+
+/* wrs (7/31/93) -- System V curses refreshes window when wgetch is called */
+/*                  if there have been changes to it and it is not a pad */
+	if( ! (win->_flags & _PAD) )
+	{
+		if( is_wintouched(win) )
+			wrefresh(win);
+	}
+
+	_getch_win_ = win;
+
+	if (c_ungind)	
+	{			/* if ungotten char exists */
+						/* remove and return it */
+		if ((! (win->_flags & _PAD)) && (win->_nodelay))
+		{
+			if ( is_wintouched(win) )
+				wrefresh(win);
+		}
+		return( c_ungch[--c_ungind] );
+	}
+
+	if ((!SP->raw_inp) && (!SP->cbreak))
+	{
+		/*
+		 * if normal
+		 */
+		if (c_gindex < c_pindex)
+		{
+			/*
+			 * and data in buffer
+			 */
+			return( buffer[c_gindex++] );
+		}
+	}
+
+	w = win;		/* static for speed & stack */
+	c_pindex = 0;		/* prepare to buffer data */
+	c_gindex = 0;
+
+/*
+ * to get here, no keys are buffered. go and get one...
+ */
+
+	for(;;)			/* loop for any buffering */
+	{
+
+#ifdef UNIX
+		if (!(SP->raw_inp || SP->cbreak))
+			{
+			cbreak();
+			cbreak_set = TRUE;
+			}
+		if (w->_use_keypad)
+			key = PDC_sysgetch();
+		else
+			key = PDC_rawgetch();
+		if (cbreak_set)
+			nocbreak();
+#endif
+
+#if defined(DOS) || defined(OS2) || defined(WIN32)
+		if (SP->raw_inp)
+		{
+			/*
+			 * get a raw character
+			 */
+			key = PDC_rawgetch();
+		}
+		else
+		{
+			/*
+			 * get a system character
+			 * if break return proper
+			 */
+			cbr = PDC_get_ctrl_break();
+			PDC_set_ctrl_break(SP->orgcbr);
+			key = PDC_sysgetch();
+			PDC_set_ctrl_break(cbr);	/* restore as it was */
+		}
+#endif
+
+#if defined(XCURSES)
+		key = PDC_rawgetch();
+		if (!(_getch_win_->_use_keypad) && (unsigned int)key > 255)
+			key = (-1);
+#endif
+
+/*
+ * Handle timeout() and halfdelay().
+ */
+		if (SP->delaytenths || w->_delayms)
+		{
+#ifdef PDCDEBUG
+			if (trace_on) PDC_debug("waiting: %d delaytenths %d delayms %d\n", waitingtenths,SP->delaytenths, w->_delayms);
+#endif
+			if (waitingtenths == 0 && key == (-1))
+				return(ERR);
+			if (key == (-1))
+			{
+				waitingtenths--;
+					napms(50); /* sleep for 1/20th second */
+				continue;
+			}
+		}
+		else
+		{
+			if (w->_nodelay)
+			{
+				/*
+				 * if nodelay and no char, return ERR
+				 */
+				if (key == -1)
+					return( ERR );
+				else if ( ! SP->echo ) {
+					if ( ! (w->_flags & _PAD) ) {
+						if ( is_wintouched(w) )
+							wrefresh(w);
+					}
+				}
+			}
+		}
+
+		if ((key == '\r') &&
+		    (SP->autocr) &&
+		    (!SP->raw_inp))
+		{
+			/*
+			 * translate CR
+			 */
+			key = '\n';
+		}
+		if ( SP->echo && (key < display_key) )
+		{
+			/*
+			 * if echo is enabled
+			 */
+			waddch(w, key);
+			wrefresh(w);
+		}
+		if ( (SP->raw_inp || SP->cbreak) )
+		{
+			/*
+			 * if no buffering
+			 */
+			return( key );
+		}
+
+		if (c_pindex < _INBUFSIZ - 2)
+		{
+			/*
+			 * if no overflow, put data in buffer
+			 */
+			buffer[c_pindex++] = key;
+		}
+		if ((key == '\n') || (key == '\r'))
+		{
+			/*
+			 * if we got a line
+			 */
+			return( buffer[c_gindex++] );
+		}
+	}
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvgetch(int y, int x)
+#else
+int	PDC_CDECL	mvgetch(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvgetch() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y, x) == ERR)
+		return(ERR);
+	return(getch());
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwgetch(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwgetch(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwgetch() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y, x) == ERR)
+		return(ERR);
+	return(wgetch(win));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	PDC_ungetch(int ch)
+#else
+int	PDC_CDECL	PDC_ungetch(ch)
+int ch;
+#endif
+/***********************************************************************/
+{
+extern	int	c_ungind;		/* ungetch() push index */
+extern	int	c_ungch[NUNGETCH];	/* array of ungotten chars */
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("ungetch() - called\n");
+#endif
+
+	if (c_ungind >= NUNGETCH)	/* pushback stack full */
+		return( ERR );
+
+	c_ungch[c_ungind++] = ch;
+	return( OK );
+}
+
diff -Naur gdb-6.8/pdcurses/pdcurses/getstr.c stsgdb-6.8/pdcurses/pdcurses/getstr.c
--- gdb-6.8/pdcurses/pdcurses/getstr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/getstr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,359 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef getstr
+#undef wgetstr
+#undef mvgetstr
+#undef mvwgetstr
+#undef ungetstr
+#undef getnstr
+#undef wgetnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+# undef wrefresh
+# undef waddch
+# undef wgetch
+# undef cbreak
+# undef move
+# undef wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_getstr  = "$Id: getstr.c,v 1.8 2004/08/07 07:18:46 rexx Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        getstr
+
+  Synopsis:
+    int getstr(char *str);
+    int wgetstr(WINDOW *win, char *str);
+    int mvgetstr(int y, int x, char *str);
+    int mvwgetstr(WINDOW *win, int y, int x, char *str);
+    int getnstr(char *str, int ch);
+    int wgetnstr(WINDOW *win, char *str, int ch);
+    int mvwgetnstr(WINDOW *win, int y, int x, char *str, int ch);
+
+  X/Open Description:
+    The effect of getstr() is as though a series of calls to getch()
+    were made, until a newline or carriage return is received. The
+    resulting value is placed in the area pointed to by *str. The user's
+    erase and kill characters are interpreted, as well as any special
+    keys; such as function keys.
+
+    With wgetnstr(), a series of characters are read until a newline
+    or carriage return is received.  The resulting value is placed
+    in the area pointed to by the character pointer str.  The user's
+    erase and kill characters are interpreted.  This differs from
+    wgetstr() in that the number of characters read is limited by a passed
+    argument.
+
+    NOTE: getstr(), getnstr(), mvgetstr(), mvwgetstr(), mwwgetnstr() are
+    implemented as macros.
+
+    WARNING:  There is no way to know how long the buffer passed to
+       wgetstr() is, so it is possible to overwrite wrong
+       memory or code!! This is the reason for the wgetnstr()
+       function :-)
+
+  X/Open Return Value:
+    This functions return ERR on failure or any other value on success.
+
+  X/Open Errors:
+    No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      getstr                                Y        Y       Y
+      wgetstr                               Y        Y       Y
+      mvgetstr                              Y        Y       Y
+      mvwgetstr                             Y        Y       Y
+      getnstr                               -        -      4.0
+      wgetnstr                              -        -      4.0
+      mvwgetnstr                            -        -     ncurses
+
+**man-end**********************************************************************/
+
+#define MAXLINE 255
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL getstr(char *str)
+#else
+int PDC_CDECL getstr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("getstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return (ERR);
+   return(wgetnstr(stdscr,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL wgetstr(WINDOW *win, char *str)
+#else
+int PDC_CDECL wgetstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wgetstr() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return (ERR);
+
+   return(wgetnstr(win,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL mvgetstr(int y, int x, char *str)
+#else
+int PDC_CDECL mvgetstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvgetstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return (ERR);
+   if (move(y,x) == ERR)
+      return (ERR);
+   return(wgetnstr(stdscr,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL mvwgetstr(WINDOW *win, int y, int x, char *str)
+#else
+int PDC_CDECL mvwgetstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("mvwgetstr() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return (ERR);
+   if (wmove(win,y,x) == ERR)
+      return (ERR);
+   return(wgetnstr(win,str,MAXLINE));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL getnstr(char *str, int n)
+#else
+int PDC_CDECL getnstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("getnstr() - called\n");
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return (ERR);
+   return(wgetnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL wgetnstr(WINDOW *win, char *str, int n)
+#else
+int PDC_CDECL wgetnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+   int   ch, i, num,chars=0;
+   int   t = win->_tabsize;
+   int   x = win->_curx;
+   char* p = str;
+   bool  stop = FALSE;
+   bool  oldecho;
+   bool  oldcbreak;
+   bool  oldnodelay;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wgetnstr() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return (ERR);
+
+#ifdef UNIX
+/*
+ * this code is very dodgy
+ *
+   wrefresh(win);
+
+   while ((*str = wgetch(win)) != ERR && *str != '\n')
+      ;
+   if (*str == ERR) {
+      *str = '\0';
+      waddstr(win,p);
+      return ERR;
+   }
+   *str = '\0';
+   waddstr(win,p);
+   return OK;
+*/
+#else
+   oldcbreak = SP->cbreak; /* remember states    */
+   oldecho = SP->echo;
+   oldnodelay = win->_nodelay;
+
+   SP->echo = FALSE;    /* we do echo ourselves */
+   cbreak();      /* ensure each key is returned immediately */
+   win->_nodelay = FALSE;     /* don't return   -1  */
+
+   wrefresh (win);
+
+   while (!stop)
+   {
+      ch = wgetch (win);
+      /* ignore modifier keys on their own */
+      if ( ch == KEY_SHIFT_L
+      ||   ch == KEY_SHIFT_R
+      ||   ch == KEY_CONTROL_L
+      ||   ch == KEY_CONTROL_R
+      ||   ch == KEY_ALT_L
+      ||   ch == KEY_ALT_R )
+         continue;
+      ch = ch & A_CHARTEXT;
+      switch( ch )
+      {
+         case '\t':
+            ch = ' ';
+            num = t - (win->_curx - x)%t;
+            for (i=0; i<num; i++)
+            {
+               if (chars < n)
+               {
+                  if (oldecho) 
+                     waddch (win, ch);
+                  *p++ = ch;
+                  ++chars;
+               }
+               else
+                  beep();
+            }
+            break;
+
+         case _ECHAR:  /* CTRL-H */  /* Delete character */
+            if (p > str)
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               ch = *--p;
+               if ((ch < ' ') && (oldecho))
+                  waddstr (win, "\b \b");
+               chars--;
+            }
+            break;
+
+         case _DLCHAR:  /* CTRL-U */    /* Delete line   */
+            while (p > str)
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               ch = *--p;
+               if ((ch < ' ') && (oldecho))
+                  waddstr (win, "\b \b");
+            }
+            chars = 0;
+            break;
+
+         case _DWCHAR: /* CTRL-W */ /* Delete word */
+            while ((p > str) && (*(p-1) == ' '))
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               --p; /* remove space */
+               chars--;
+            }
+            while ((p > str) && (*(p-1) != ' '))
+            {
+               if (oldecho) 
+                  waddstr (win, "\b \b");
+               ch = *--p;
+               if ((ch < ' ') && (oldecho))
+                  waddstr (win, "\b \b");
+               chars--;
+            }
+            break;
+
+         case '\n':
+         case '\r':
+            stop = TRUE;
+            if (oldecho) 
+               waddch (win, '\n');
+            break;
+
+         default:
+            if (chars < n)
+            {
+               *p++ = ch;
+               if (oldecho) 
+                  waddch (win, ch);
+               chars ++;
+            }
+            else
+               beep();
+            break;
+      }
+      wrefresh (win);
+   }
+   *p = '\0';
+
+   SP->echo = oldecho;  /* restore old settings */
+   SP->cbreak = oldcbreak;
+   win->_nodelay = oldnodelay;
+
+   return (OK);
+#endif
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/getyx.c stsgdb-6.8/pdcurses/pdcurses/getyx.c
--- gdb-6.8/pdcurses/pdcurses/getyx.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/getyx.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,201 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	getbegy
+#undef	getbegx
+#undef	getmaxy
+#undef	getmaxx
+#undef	getpary
+#undef	getparx
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_getyx  = "$Id: getyx.c,v 1.1 2001/01/10 08:27:03 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         getyx
+
+  Synopsis:
+  	void getyx(WINDOW *win, int y, int x);
+  	void getparyx(WINDOW *win, int y, int x);
+  	void getbegyx(WINDOW *win, int y, int x);
+  	void getmaxyx(WINDOW *win, int y, int x);
+
+  	int getbegy(WINDOW *win);
+  	int getbegx(WINDOW *win);
+  	int getpary(WINDOW *win);
+  	int getparx(WINDOW *win);
+  	int getmaxy(WINDOW *win);
+  	int getmaxx(WINDOW *win);
+
+  X/Open Description:
+ 	With the getyx() macro, the cursor position of the window is placed
+ 	in the two integer variables y and x. getbegyx() and getmaxyx()
+ 	return the current beginning coordinates and size of the specified
+ 	window respectively. getparyx() returns the beginning coordinates 
+ 	of the parent's window if the specified window is a sub-window
+ 	otherwise -1 is returned.
+
+ 	These functions are implemented as macros, so their return values
+ 	are undefined. Also as these functions are implemented as macros,
+ 	no '&' is required before the variables y and x.
+
+ 	The functions getbegy(), getbegx(), getmaxy(), getmaxx() ,
+ 	getpary(), and getparx() do return the beginning coordinate or 
+ 	size values, so they can be specified on the right-hand side of 
+ 	an assignment statement. They are, however, implemented as macros.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      getyx                                 Y        Y       Y
+      getparyx                              -        -      4.0
+      getbegyx                              -        -      3.0
+      getmaxyx                              -        -      3.0
+      getbegy                               -        -       -
+      getbegx                               -        -       -
+      getpary                               -        -       -
+      getparx                               -        -       -
+      getmaxy                               -        -       -
+      getmaxx                               -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getbegy(WINDOW *win)
+#else
+int	PDC_CDECL	getbegy(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getbegy() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_begy);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getbegx(WINDOW *win)
+#else
+int	PDC_CDECL	getbegx(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getbegx() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_begx);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getpary(WINDOW *win)
+#else
+int	PDC_CDECL	getpary(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getpary() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_pary);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getparx(WINDOW *win)
+#else
+int	PDC_CDECL	getparx(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getparx() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_parx);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getmaxy(WINDOW *win)
+#else
+int	PDC_CDECL	getmaxy(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getmaxy() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_maxy);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	getmaxx(WINDOW *win)
+#else
+int	PDC_CDECL	getmaxx(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getmaxx() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(win->_maxx);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/inch.c stsgdb-6.8/pdcurses/pdcurses/inch.c
--- gdb-6.8/pdcurses/pdcurses/inch.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/inch.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,138 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	inch
+#undef	winch
+#undef	mvinch
+#undef	mvwinch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_inch  = "$Id: inch.c,v 1.1 2001/01/10 08:27:04 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          inch
+
+  Synopsis:
+  	chtype inch(void);
+  	chtype winch(WINDOW *win);
+  	chtype mvinch(int y, int x);
+  	chtype mvwinch(WINDOW *win, int y, int x);
+
+  X/Open Description:
+
+ 	NOTE: All these functions are implemented as macros.
+
+  PDCurses Description:
+ 	Depending upon the state of the raw character output, 7- or
+ 	8-bit characters will be output.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      inch                                  Y        Y       Y
+      winch                                 Y        Y       Y
+      mvinch                                Y        Y       Y
+      mvwinch                               Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	inch(void)
+#else
+chtype	PDC_CDECL	inch()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("inch() - called\n");
+#endif
+
+	return( stdscr->_y[stdscr->_cury][stdscr->_curx] );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	winch(WINDOW *win)
+#else
+chtype	PDC_CDECL	winch(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winch() - called\n");
+#endif
+
+	return( win->_y[win->_cury][win->_curx] );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	mvinch(int y, int x)
+#else
+chtype	PDC_CDECL	mvinch(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinch() - called\n");
+#endif
+
+	(void)(move(y,x));
+	return( stdscr->_y[stdscr->_cury][stdscr->_curx] );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+chtype	PDC_CDECL	mvwinch(WINDOW *win, int y, int x)
+#else
+chtype	PDC_CDECL	mvwinch(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinch() - called\n");
+#endif
+
+	(void)(wmove(win,y,x));
+	return( win->_y[win->_cury][win->_curx] );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/inchstr.c stsgdb-6.8/pdcurses/pdcurses/inchstr.c
--- gdb-6.8/pdcurses/pdcurses/inchstr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/inchstr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	inchstr
+#undef	inchnstr
+#undef	winchstr
+#undef	winchnstr
+#undef	mvinchstr
+#undef	mvinchnstr
+#undef	mvwinchstr
+#undef	mvwinchnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_inchstr  = "$Id: inchstr.c,v 1.1 2001/01/10 08:27:05 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        inchstr
+
+  Synopsis:
+  	int inchstr(chtype *ch);
+  	int inchnstr(chtype *ch, int n);
+  	int winchstr(WINDOW *win, chtype *ch);
+  	int winchnstr(WINDOW *win, chtype *ch, int n);
+  	int mvinchstr(int y, int x, chtype *ch);
+  	int mvinchnstr(int y, int x, chtype *ch, int n);
+  	int mvwinchstr(WINDOW *, int y, int x, chtype *ch);
+  	int mvwinchnstr(WINDOW *, int y, int x, chtype *ch, int n);
+
+  X/Open Description:
+ 	These routines read a chtype string directly from the window structure
+ 	starting at the current position and ending at the right margin.
+ 	The four routines with n as the last argument copy at most n
+ 	elements, but no more than will fit on the line.
+
+ 	NOTE:	inchstr(), mvinchstr(), mvwinchstr() inchnstr(), 
+ 		mvinchnstr(), and mvwinchnstr() are implemented as macros.
+
+  X/Open Return Value:
+ 	All functions return ERR on error and an integer value other than
+ 	ERR on success. 
+
+  X/Open Errors:
+ 	Normally the value returned indicates the number of chtypes
+ 	returned.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      inchstr                               -        -      4.0
+      winchstr                              -        -      4.0
+      mvinchstr                             -        -      4.0
+      mvwinchstr                            -        -      4.0
+      inchnstr                              -        -      4.0
+      winchnstr                             -        -      4.0
+      mvinchnstr                            -        -      4.0
+      mvwinchnstr                           -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	inchstr(chtype *ch)
+#else
+int	PDC_CDECL	inchstr(ch)
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("inchstr() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return( inchnstr( ch, stdscr->_maxx - stdscr->_curx ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	inchnstr(chtype *ch, int n)
+#else
+int	PDC_CDECL	inchnstr(ch,n)
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype	*ptr = &(stdscr->_y[stdscr->_cury][stdscr->_curx]);
+	int	i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("inchnstr() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 0)
+		return( ERR );
+
+	if ((stdscr->_curx + n) > stdscr->_maxx)
+		n = stdscr->_maxx - stdscr->_curx;
+
+	for(i=0;i<n;i++)
+		*ch++ = *ptr++;
+
+	*ch = (chtype)0;
+	return(i);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winchstr(WINDOW *win, chtype *ch)
+#else
+int	PDC_CDECL	winchstr(win,ch)
+WINDOW *win;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winchstr() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winchnstr(win,ch,win->_maxx - win->_curx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winchnstr(WINDOW *win, chtype *ch, int n)
+#else
+int	PDC_CDECL	winchnstr(win,ch,n)
+WINDOW *win;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype	*ptr = &(win->_y[win->_cury][win->_curx]);
+	int	i;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winchnstr() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (n < 0)
+		return( ERR );
+
+	if ((win->_curx + n) > win->_maxx)
+		n = win->_maxx - win->_curx;
+
+	for(i=0;i<n;i++)
+		*ch++ = *ptr++;
+
+	*ch = (chtype)0;
+	return(i);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinchstr(int y, int x, chtype *ch)
+#else
+int	PDC_CDECL	mvinchstr(y,x,ch)
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinchstr() - called: y %d x %d\n",y,x);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	return( inchnstr( ch, stdscr->_maxx - stdscr->_curx) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinchnstr(int y, int x, chtype *ch, int n)
+#else
+int	PDC_CDECL	mvinchnstr(y,x,ch,n)
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinchnstr() - called: y %d x %d n %d\n",y,x,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(stdscr,y,x) == ERR)
+		return( ERR );
+
+	return( inchnstr( ch, n) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinchstr(WINDOW *win, int y, int x, chtype *ch)
+#else
+int	PDC_CDECL	mvwinchstr(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winchstr() - called:\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return( winchnstr( win, ch, win->_maxx - win->_curx) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinchnstr(WINDOW *win,int y, int x, chtype *ch, int n)
+#else
+int	PDC_CDECL	mvwinchnstr(win,y,x,ch,n)
+WINDOW *win;
+int y;
+int x;
+chtype *ch;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinchnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return( winchnstr( win, ch, n) );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/initscr.c stsgdb-6.8/pdcurses/pdcurses/initscr.c
--- gdb-6.8/pdcurses/pdcurses/initscr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/initscr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,735 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+
+#ifdef UNIX
+#define NOTLIB
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   initscr
+#undef   endwin
+#undef   isendwin
+#undef   newterm
+#undef   set_term
+#undef   delscreen
+#undef   resize_term
+#undef   is_termresized
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef move
+#  undef wmove
+#  undef resize_term
+#  undef touchwin
+#  undef wnoutrefresh
+#endif
+
+#ifdef UNIX
+#define NOTLIB
+#include <defs.h>
+#include <term.h>
+/* following is to stop compilation problems with #define of lines */
+#undef lines
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_initscr  = "$Id: initscr.c,v 1.10 2005/12/25 04:24:42 wmcbrine Exp $";
+#else
+char* _curses_notice = "PDCurses 2.2 - Public Domain 1994";
+#endif
+
+int   _default_lines = 25; /* default terminal height */
+
+SCREEN *SP = (SCREEN*)NULL;      /* curses variables     */
+WINDOW*  curscr=NULL;         /* the current screen image   */
+WINDOW*  stdscr=NULL;         /* the default screen window  */
+int   LINES=0;       /* current terminal height */
+int   COLS=0;        /* current terminal width  */
+MOUSE_STATUS Mouse_status;
+int    use_emalloc = FALSE;
+
+#if defined DOS
+Regs regs;
+#endif
+
+/*
+ * Global definitions for charget routines
+ */
+int   c_pindex = 0;     /* putter index */
+int   c_gindex = 1;     /* getter index */
+int   c_ungind = 0;     /* wungetch() push index */
+int   c_ungch[NUNGETCH];   /* array of ungotten chars */
+WINDOW*  _getch_win_=NULL;
+
+/*
+ * Global definitions for setmode routines
+ */
+struct cttyset c_sh_tty = {0};   /* tty modes for def_shell_mode */
+struct cttyset c_pr_tty = {0};   /* tty modes for def_prog_mode  */
+struct cttyset c_save_tty = {0};
+struct cttyset c_save_trm = {0};
+
+/*
+ * Global definitions for printscan routines
+ */
+char c_printscanbuf[513];  /* buffer used during I/O */
+
+/*
+ * Global definitions for strget routines
+ */
+char *c_strbeg;
+
+#if   EMALLOC
+# ifdef HAVE_PROTO
+extern   void* emalloc( size_t );
+extern   void* ecalloc( size_t, size_t );
+extern   void  efree( void* );
+# else
+extern   void* emalloc();  /* user's emalloc(size)    */
+extern   void* ecalloc();  /* user's ecalloc(num,size)   */
+extern   void  efree();    /* user's efree(ptr)    */
+# endif
+#endif
+
+#if !defined(UNIX) && !defined(XCURSES)
+# ifdef HAVE_PROTO
+extern   void* malloc( size_t );          /* runtime's malloc(size)     */
+extern   void* calloc( size_t, size_t );  /* runtime's calloc(num,size) */
+extern   void  free( void* );             /* runtime's free(ptr)        */
+# else
+extern   void* malloc();   /* runtime's malloc(size)     */
+extern   void* calloc();   /* runtime's calloc(num,size) */
+extern   void  free();     /* runtime's free(ptr)        */
+# endif
+#endif
+
+#ifdef HAVE_PROTO
+void* (*mallc)( size_t );            /* ptr to some malloc(size)      */
+void* (*callc)( size_t, size_t );    /* ptr to some ecalloc(num,size) */
+void  (*fre)( void* );               /* ptr to some free(ptr)         */
+void* (*reallc)( void*, size_t );    /* ptr to some realloc(ptr,size) */
+#else
+void* (*mallc)();    /* ptr to some malloc(size)      */
+void* (*callc)();    /* ptr to some ecalloc(num,size) */
+void  (*fre)();      /* ptr to some free(ptr)         */
+void* (*reallc)();   /* ptr to some realloc(ptr,size) */
+#endif
+
+#ifdef XCURSES
+chtype *acs_map;
+#endif
+
+extern RIPPEDOFFLINE linesripped[5];
+extern char linesrippedoff;
+
+#ifdef HAVE_PROTO
+extern void (*PDC_initial_slk)(void);
+#else
+extern void (*PDC_initial_slk)();
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       initscr
+
+  Synopsis:
+   WINDOW *initscr(void);
+   WINDOW *Xinitscr(int argc, char *argv[]);
+   int endwin(void);
+   int isendwin(void);
+   SCREEN *newterm(char *type, FILE *outfd, FILE *infd);
+   SCREEN *set_term(SCREEN *new);
+   void delscreen(SCREEN *sp);
+
+   int resize_term(int nlines, int ncols);
+   bool is_termresized(void);
+
+  X/Open Description:
+   The first curses routine called should be initscr().  This will
+   determine the terminal type and initialize all curses data
+   structures.  The initscr() function also arranges that the
+   first call to refresh() will clear the screen.  If errors
+   occur, initscr() will write an appropriate error message to
+   standard error and exit.  If the program wants an indication
+   of error conditions, newterm() should be used instead of
+   initscr().
+
+   A program should always call endwin() before exiting or
+   escaping from curses mode temporarily.  This routine will
+   restore tty modes, move the cursor to the lower left corner
+   of the screen and reset the terminal into the proper non-visual
+   mode.  To resume curses after a temporary escape, refresh() or
+   doupdate() should be called.
+
+   The isendwin() function returns TRUE if endwin() has been called
+   without any subsequent calls to wrefresh(), and FALSE otherwise.
+
+   A program which outputs to more than one terminal should use
+   newterm() for each terminal instead of initscr().  The newterm()
+   function should be called once for each terminal.  It returns a
+   value of type SCREEN* which should be saved as a reference to that
+   terminal. The arguments are the type of of terminal to be used
+   in place of TERM (environment variable), a file pointer for output
+   to the terminal and another file pointer for input from the terminal.
+   The program must also call endwin() for each terminal no longer being
+   used.
+
+   The set_term() function is used to switch between different terminals.
+   The screen reference 'new' becomes the new current terminal.
+   The previous terminal is returned by the routine.  This is the
+   only routine which manipulates SCREEN pointers; all other routines
+   affect only the current terminal.
+
+  PDCurses Description:
+   The resize_term() function is used to have PDCurses change its
+   internal structures to the new, specified size.
+
+   The is_termresized() function returns TRUE if the Curses screen has
+   been resized by external means, and requires a call to resize_term().
+
+   Due to the fact that newterm() does not yet exist in PDCurses,
+   there is no way to recover from an error in initscr().
+
+   By default, curses will set default attributes to white on black. If
+   you want to use the attributes of the current terminal to be the
+   defaults, set the environment variable: PDC_ORIGINAL_COLORS to any
+   value before calling initscr(). (Currently only effective under Win32)
+
+  X/Open Return Value:
+   All functions return NULL on error, except endwin(), which
+   returns ERR on error.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      initscr                               Y        Y       Y
+      endwin                                Y        Y       Y
+      isendwin                              -        -      3.0
+      newterm                               -        -       Y
+      set_term                              -        -       Y
+      delscreen                             -        -      4.0
+      resize_term                           -        -       -
+      is_termresized                        -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*  PDC_CDECL   Xinitscr(int argc, char *argv[])
+#else
+WINDOW*  PDC_CDECL   Xinitscr(argc,argv)
+int argc;
+char *argv[];
+#endif
+/***********************************************************************/
+{
+register int i;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("Xinitscr() - called\n");
+#endif
+
+   if (SP != (SCREEN *)NULL
+   &&  SP->alive)
+      return( NULL);
+
+#ifdef EMXVIDEO
+   v_init();
+#endif
+
+   if  (use_emalloc == EMALLOC_MAGIC)
+   {
+#if   EMALLOC
+      use_emalloc = TRUE;
+      mallc = emalloc;
+      callc = ecalloc;
+      fre   = efree;
+      reallc = erealloc;
+#endif
+   }
+   else
+   {
+      mallc = malloc;
+      callc = calloc;
+      fre   = free;
+      reallc = realloc;
+   }
+
+#ifdef UNIX
+   setupterm((char *)0,1,(int *)0);
+   if (enter_ca_mode != NULL)
+      putp(enter_ca_mode);
+#endif
+
+#if defined (XCURSES)
+   if (XCursesInitscr(NULL,argc,argv) == ERR)
+      exit(7);
+#endif
+
+#if defined (XCURSES)
+   if (SP == (SCREEN*)NULL) /* SP already attached in XCursesInitscr() */
+#else
+   if ((SP = (SCREEN*)callc(1,sizeof(SCREEN))) == (SCREEN*)NULL)
+#endif
+   {
+      fprintf( stderr, "initscr(): Unable to create SP\n" );
+      exit(8);
+   }
+
+   PDC_scr_open(SP, 0);
+
+#ifdef   FLEXOS
+   _flexos_16bitmode();
+#endif
+
+   LINES = SP->lines;
+   COLS = SP->cols;
+
+   if (LINES < 2 || COLS < 2)
+   {
+      fprintf( stderr, "initscr(): LINES=%d COLS=%d: too small.\n",LINES,COLS );
+      exit( 4 );
+   }
+
+   if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) NULL)
+   {
+      fprintf( stderr, "initscr(): Unable to create curscr.\n" );
+      exit( 2 );
+   }
+
+#ifdef XCURSES
+   if ((acs_map = (chtype *)(*mallc)(128*sizeof(chtype))) == (chtype *)NULL)
+   {
+      fprintf( stderr, "initscr(): Unable to create acs_map.\n" );
+      exit( 5 );
+   }
+   for (i=0;i<128;i++)
+   {
+      acs_map[i] = '#' | A_ALTCHARSET;
+   }
+   ACS_BSSB = (chtype)13|A_ALTCHARSET;
+   ACS_SSBB = (chtype)14|A_ALTCHARSET;
+   ACS_BBSS = (chtype)12|A_ALTCHARSET;
+   ACS_SBBS = (chtype)11|A_ALTCHARSET;
+   ACS_SBSS = (chtype)22|A_ALTCHARSET;
+   ACS_SSSB = (chtype)21|A_ALTCHARSET;
+   ACS_SSBS = (chtype)23|A_ALTCHARSET;
+   ACS_BSSS = (chtype)24|A_ALTCHARSET;
+   ACS_BSBS = (chtype)18|A_ALTCHARSET;
+   ACS_SBSB = (chtype)25|A_ALTCHARSET;
+   ACS_SSSS = (chtype)15|A_ALTCHARSET;
+   ACS_S1       = (chtype)16|A_ALTCHARSET;
+   ACS_S9       = (chtype)20|A_ALTCHARSET;
+   ACS_DIAMOND  = (chtype)1|A_ALTCHARSET;
+   ACS_CKBOARD  = (chtype)2|A_ALTCHARSET;
+   ACS_DEGREE   = (chtype)7|A_ALTCHARSET;
+   ACS_PLMINUS  = (chtype)8|A_ALTCHARSET;
+   ACS_BULLET   = (chtype)'*'|A_ALTCHARSET;
+   ACS_LARROW   = (chtype)'<'|A_ALTCHARSET;
+   ACS_RARROW   = (chtype)'>'|A_ALTCHARSET;
+   ACS_DARROW   = (chtype)'v'|A_ALTCHARSET;
+   ACS_UARROW   = (chtype)'^'|A_ALTCHARSET;
+   ACS_BOARD    = (chtype)'#'|A_ALTCHARSET;
+   ACS_LANTERN  = (chtype)'#'|A_ALTCHARSET;
+   ACS_BLOCK    = (chtype)0|A_ALTCHARSET;
+   /* extra, non-standard symbols */
+   ACS_S3      = (chtype)17|A_ALTCHARSET;
+   ACS_S7      = (chtype)19|A_ALTCHARSET;
+   ACS_LEQUAL  = (chtype)26|A_ALTCHARSET;
+   ACS_GEQUAL  = (chtype)27|A_ALTCHARSET;
+   ACS_PI      = (chtype)28|A_ALTCHARSET;
+   ACS_NEQUAL  = (chtype)29|A_ALTCHARSET;
+   ACS_STERLING= (chtype)30|A_ALTCHARSET;
+#endif
+
+   if (PDC_initial_slk)
+   {
+      (*PDC_initial_slk)();
+      LINES -= SP->slklines;
+   }
+
+/*
+ * We have to sort out ripped off lines here and reduce the height
+ * of stdscr by the number of lines ripped off
+ */
+   for (i=0;i<linesrippedoff;i++)
+   {
+      if (linesripped[i].line < 0)
+         (*linesripped[i].init)(newwin(1,COLS,LINES-1,0),COLS);
+      else
+         (*linesripped[i].init)(newwin(1,COLS,SP->linesrippedoffontop++,0),COLS);
+      SP->linesrippedoff++;
+      LINES--;
+   }
+   linesrippedoff = 0;
+
+   if ((stdscr = newwin(LINES, COLS, SP->linesrippedoffontop, 0)) == (WINDOW *) NULL)
+   {
+      fprintf( stderr, "initscr(): Unable to create stdscr.\n" );
+      exit( 1 );
+   }
+
+   wclrtobot(stdscr);
+
+   /*
+    * If preserving the existing screen don't allow a screen clear...
+    */
+   if (SP->_preserve)
+   {
+      untouchwin(curscr);
+      untouchwin(stdscr);
+      stdscr->_clear = FALSE;
+   }
+
+   curscr->_clear = FALSE;
+
+#ifdef   REGISTERWINDOWS
+   SP->refreshall = FALSE;
+   _inswin(stdscr, (WINDOW *)NULL);
+#endif
+
+#if defined(CHTYPE_LONG)
+   PDC_init_atrtab(); /* set up default (BLACK on WHITE colours */
+#endif
+
+#ifdef EMXVIDEO
+   SP->tahead = -1;
+#endif
+
+   MOUSE_X_POS = MOUSE_Y_POS = (-1);
+   BUTTON_STATUS(1) = BUTTON_RELEASED;
+   BUTTON_STATUS(2) = BUTTON_RELEASED;
+   BUTTON_STATUS(3) = BUTTON_RELEASED;
+   Mouse_status.changes = 0;
+
+   SP->alive = TRUE;
+
+#ifdef UNIX
+   PDC_setup_keys();
+#else
+   def_shell_mode(); /* don't do this for UNIX as scropen has already changed things */
+#endif
+
+   return( stdscr );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*  PDC_CDECL   initscr(void)
+#else
+WINDOW*  PDC_CDECL   initscr()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("initscr() - called\n");
+#endif
+   return (Xinitscr( 0, NULL ) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL endwin(void)
+#else
+int PDC_CDECL endwin()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("endwin() - called\n");
+#endif
+
+/*
+ * New endwin() behaviour; to allow temporary exit from curses
+ * using endwin().
+ */
+
+   PDC_scr_close();
+
+# ifdef  FLEXOS
+   _flexos_8bitmode();
+# endif
+
+# if defined(DOS) || defined(OS2)
+   reset_shell_mode();
+# endif
+
+   curs_set(1);
+   /*
+    * Position cursor to the bottom left of the screen.
+    */
+#if defined(WIN32)
+   PDC_gotoxy(PDC_get_buffer_rows() - 2, 0);
+#else
+   PDC_gotoxy(PDC_get_rows() - 2, 0);
+#endif
+
+   SP->alive = FALSE;
+
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   isendwin(void)
+#else
+int   PDC_CDECL   isendwin()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("isendwin() - called\n");
+#endif
+
+   return((SP->alive) ? FALSE : TRUE);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+SCREEN*PDC_CDECL     newterm( char *type, FILE *outfd, FILE *infd )
+#else
+SCREEN*PDC_CDECL     newterm(type,outfd,infd)
+char *type;
+FILE *outfd;
+FILE *infd;
+#endif
+/***********************************************************************/
+{
+#ifdef   TC
+#  pragma argsused
+#endif
+
+#if 0
+extern   void* mallc(); /* malloc(size)      */
+extern   void* callc(); /* calloc(num,size)  */
+extern   void  fre();      /* free(ptr)      */
+
+extern   void* malloc();
+extern   void* calloc();
+extern   void  free();
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("newterm() - called\n");
+#endif
+
+   if  (SP->alive)
+      return( ERR );
+
+   if  (use_emalloc == EMALLOC_MAGIC)
+   {
+#if   EMALLOC
+      memset(SP, 0, sizeof(SCREEN));
+      use_emalloc = TRUE;
+      mallc = emalloc;
+      callc = ecalloc;
+      fre   = efree;
+      reallc = erealloc;
+#endif
+   }
+   else
+   {
+      memset(SP, 0, sizeof(SCREEN));
+      mallc = malloc;
+      callc = calloc;
+      fre   = free;
+      reallc = realloc;
+   }
+   PDC_scr_open(SP, 0);
+   SP->orig_cursor = SP->cursor;
+   SP->orig_font = PDC_get_font();
+   SP->orgcbr = PDC_get_ctrl_break();
+   SP->blank = ' ';
+#ifdef   FLEXOS
+   _flexos_16bitmode();
+#endif
+   savetty();
+   LINES = PDC_get_rows();
+   COLS = PDC_get_columns();
+
+   if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
+   {
+      return( ERR );
+   }
+   if ((stdscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
+   {
+      return( ERR );
+   }
+   curscr->_clear = FALSE;
+#ifdef   REGISTERWINDOWS
+   SP->refreshall = FALSE;
+   _inswin(stdscr, (WINDOW *)NULL);
+#endif
+   SP->alive = TRUE;
+   return( SP );
+#endif
+   return(NULL);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+SCREEN*  PDC_CDECL   set_term( SCREEN *new )
+#else
+SCREEN*  PDC_CDECL   set_term(new)
+SCREEN *new;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("set_term() - called\n");
+#endif
+
+#ifdef   TC
+#  pragma argsused
+#endif
+   return( SP );  /* We only have one screen supported right now */
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void  PDC_CDECL   delscreen( SCREEN *sp )
+#else
+void  PDC_CDECL   delscreen(sp)
+SCREEN *sp;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("delscreen() - called\n");
+#endif
+
+   if (sp != SP)
+      return;
+
+#if 0
+   PDC_scr_close();
+/* resetty();*/
+   if (SP->orig_font != SP->font)  /* screen has not been resized */
+   {
+      PDC_set_font(SP->orig_font);
+      resize_term(PDC_get_rows(),PDC_get_columns());
+   }
+
+   SP->visible_cursor = FALSE;   /* Force the visible cursor */
+   SP->cursor = SP->orig_cursor;
+   PDC_cursor_on();
+   /*
+    * Position cursor so that the screen will not scroll until they hit
+    * a carriage return. Do this BEFORE delwin(curscr) as PDC_gotoxy() uses
+    * curscr.
+    */
+   PDC_gotoxy(PDC_get_rows() - 2, 0);
+#endif
+
+   delwin(stdscr);
+   delwin(curscr);
+   stdscr = (WINDOW *)NULL;
+   curscr = (WINDOW *)NULL;
+   SP->alive = FALSE;
+
+# if !defined (XCURSES)
+   if (SP)
+   {
+      fre(SP);
+      SP = (SCREEN *)NULL;
+   }
+# endif
+
+# if DONOTKILLXFROMHERE
+#  if defined (XCURSES)
+   XCursesInstruct(CURSES_EXIT);
+   XCursesCleanupCursesProcess(0);
+#  endif
+# endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   resize_term(int nlines, int ncols)
+#else
+int   PDC_CDECL   resize_term(nlines,ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("resize_term() - called: nlines %d\n",nlines);
+#endif
+
+   if (stdscr == (WINDOW *)NULL)
+      return(ERR);
+
+   if (PDC_resize_screen(nlines,ncols) == ERR)
+      return ( ERR );
+
+   SP->lines = PDC_get_rows();
+   LINES = SP->lines - SP->linesrippedoff - SP->slklines;
+   SP->cols  = COLS  = PDC_get_columns();
+
+   /*
+    * We need to change the saved prog_mode details...
+    */
+   if ( c_pr_tty.been_set )
+   {
+      c_pr_tty.saved.lines = SP->lines;
+      c_pr_tty.saved.cols = SP->cols;
+   }
+
+   if ((curscr = resize_window(curscr, SP->lines, SP->cols)) == NULL)
+      return (ERR);
+
+   if ((stdscr = resize_window(stdscr, LINES, COLS)) == NULL)
+      return (ERR);
+
+   if (SP->slk_winptr)
+   {
+      if ((SP->slk_winptr = resize_window(SP->slk_winptr,SP->slklines, COLS)) == NULL)
+         return (ERR);
+      wmove(SP->slk_winptr, 0, 0);
+      wclrtobot(SP->slk_winptr);
+      (*PDC_initial_slk)();
+      slk_noutrefresh();
+   }
+
+   touchwin(stdscr);
+   wnoutrefresh(stdscr);
+
+   return (OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool  PDC_CDECL   is_termresized(void)
+#else
+bool  PDC_CDECL   is_termresized()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("is_termresized() - called\n");
+#endif
+   return( SP->resized );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/inopts.c stsgdb-6.8/pdcurses/pdcurses/inopts.c
--- gdb-6.8/pdcurses/pdcurses/inopts.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/inopts.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,637 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef UNIX
+#define NOTLIB
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	cbreak
+#undef	nocbreak
+#undef	echo
+#undef	noecho
+#undef	halfdelay
+#undef	intrflush
+#undef	keypad
+#undef	meta
+#undef	nodelay
+#undef	notimeout
+#undef	raw
+#undef	noraw
+#undef	noqiflush
+#undef	qiflush
+#undef	timeout
+#undef	wtimeout
+#undef	typeahead
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_inopts  = "$Id: inopts.c,v 1.3 2005/12/16 23:27:47 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        inopts
+
+  Synopsis:
+  	int cbreak(void);
+  	int nocbreak(void);
+  	int echo(void);
+  	int noecho(void);
+  	int halfdelay(int tenths);
+  	int intrflush(WINDOW *win, bool bf);
+  	int keypad(WINDOW *win, bool bf);
+  	int meta(WINDOW *win, bool bf);
+  	int nodelay(WINDOW *win, bool bf);
+  	int notimeout(WINDOW *win, bool bf);
+  	int raw(void);
+  	int noraw(void);
+  	void noqiflush(void);
+  	void qiflush(void);
+  	int timeout(int delay);
+  	int wtimeout(WINDOW *win, int delay);
+  	int typeahead(int fildes);
+
+  X/Open Description:
+ 	cbreak() and nocbreak() puts the terminal into and out of cbreak
+ 	mode. In cbreak mode, characters typed by the user are immediately
+ 	available to the program and erase/kill character processing is
+ 	not performed.  When out of cbreak mode, the terminal driver
+ 	will buffer characters typed until a newline or carriage return
+ 	is typed.  Interrupt and flow control characters are unaffected
+ 	by this mode.  Initially the terminal may or may not need be
+ 	in cbreak mode.
+
+ 	echo() and noecho() control whether characters typed by the user
+ 	are echoed by the input routine.  Initially, input characters
+ 	are echoed.  Subsequent calls to echo() and noecho() do not
+ 	flush type-ahead.
+
+ 	halfdelay is similar to cbreak() but allows for a specified time
+ 	limit to be specified (in 1/10thes of a second). This causes getch()
+ 	to block for that period before returning ERR if no key has been
+ 	received.  tenths must be between 1 and 255.
+
+ 	If the intrflush() option is enabled (bf is TRUE), and an interrupt
+ 	is pressed on the keyboard (INTR, BREAK, or QUIT) all output in
+ 	the terminal driver queue will be flushed, giving the effect
+ 	of faster response to the interrupt but causing curses to have
+ 	the wrong idea of what is on the screen.  Disabling the option
+ 	prevents the flush.  The default for the option is inherited
+ 	from the terminal driver settings.  The window argument is
+ 	ignored.
+
+ 	The keypad() function changes the keypad option of the user's terminal.
+ 	If enabled (bf is TRUE), the user can press a function key (such
+ 	as the left arrow key) and getch() will return a single value
+ 	that represents the KEY_LEFT function key.  (See Section 11.3.3,
+ 	Input Values.)  If disabled, curses will not treat function keys
+ 	as special keys and the program has to interpret the escape
+ 	sequences itself.  If the keypad is enabled, the terminal keypad
+ 	is turned on before input begins.
+
+ 	The meta() function forces the user's terminal to return 7 or 8
+ 	significant bits on input.  To force 8 bits to be returned,
+ 	invoke meta() with bf as TRUE.  To force 7 bits to be returned,
+ 	invoke meta() with bf as FALSE.
+ 	The window argument is always ignored, but it must still be a
+ 	valid window to avoid compiler errors.
+
+ 	The nodelay() function controls whether wgetch() is a non-blocking
+ 	call. If the option is enabled, and no input is ready, wgetch()
+ 	will return ERR. If disabled, wgetch() will hang until input
+ 	is ready.
+
+ 	While interpreting an input escape sequence, wgetch sets a timer while
+ 	waiting for the next character.  If notimeout(win,TRUE) is called, then
+ 	wgetch does not set a timer.  The purpose of the timeout is to
+ 	differentiate between sequences received from a function key and those
+ 	typed by a user.
+
+ 	With raw() and noraw(), the terminal in placed into or out of raw 
+ 	mode.  Raw mode is similar to cbreak mode, in that characters typed 
+ 	are immediately passed through to the user program.  The differences
+ 	are that in raw mode, the INTR, QUIT, SUSP, and STOP characters are 
+ 	passed through without being interpreted, and without generating a
+ 	signal.  The behaviour of the BREAK key depends on other
+ 	parameters of the terminal drive that are not set by curses.
+
+ 	The timeout() and wtimeout() functions set blocking or non-blocking
+ 	reads for the specified window. "delay" is measured in milliseconds.
+ 	If "delay" is negative a blocking read is used. If "delay" is zero
+ 	then non-blocking reads are done. If no input is waiting, ERR is
+ 	returned immediately. If "delay" is positive, the read blocks for
+ 	the "delay" period. If the period expires, ERR is returned.
+
+ 	The curses package does the "line-breakout optimisation" by
+ 	looking for type-ahead periodically while updating the screen.
+ 	If input is found, the current update will be postponed until
+ 	refresh() or doupdate() are called again.  This allows faster
+ 	response to commands typed in advance.  Normally, the input FILE
+ 	pointer passed to newterm(), or stdin in the case when initscr()
+ 	was called, will be used to do this type-ahead checking.  The
+ 	typeahead() routine specified that the file descriptor fd is to
+ 	be used to check for type-ahead instead.  If fd is -1, then no
+ 	type-ahead checking will be done.
+
+  PDCurses Description:
+ 	The meta() function is provided for portability.  By default, 8 bits
+ 	are returned.
+
+ 	notimeout(), noqiflush() and qiflush() are no-ops in PDCurses.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      cbreak                                Y        Y       Y
+      nocbreak                              Y        Y       Y
+      echo                                  Y        Y       Y
+      noecho                                Y        Y       Y
+      halfdelay                             -        -       Y
+      intrflush                             Y        -       Y
+      keypad                                Y        -       Y
+      meta                                  -        -       Y
+      nodelay                               Y        -       Y
+      notimeout                             -        -       Y
+      raw                                   Y        Y       Y
+      noraw                                 Y        Y       Y
+      noqiflush                             -        -       Y
+      qiflush                               -        -       Y
+      timeout                               -        -       Y
+      wtimeout                              -        -       Y
+      typeahead                             Y        -       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	cbreak(void)
+#else
+int	PDC_CDECL	cbreak()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("cbreak() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON);
+	_CUR_TERM.prog_mode.c_iflag &= ~(ICRNL);
+/*	_CUR_TERM.prog_mode.c_lflag |= ISIG;*/
+	_CUR_TERM.prog_mode.c_cc[VMIN] = 1;
+	_CUR_TERM.prog_mode.c_cc[VTIME] = 0;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags |= CBREAK;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+
+#endif
+
+	SP->cbreak = TRUE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nocbreak(void)
+#else
+int	PDC_CDECL	nocbreak()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nocbreak() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag |= ICANON;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else 
+	_CUR_TERM->prog_mode.sg_flags &= ~CBREAK;
+	ioctl(_CUR_TERM.fd, TIOCSETP,&_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	SP->cbreak = FALSE;
+	SP->delaytenths = 0;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	echo(void)
+#else
+int	PDC_CDECL	echo()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("echo() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag |= ECHOCTL|ECHOKE;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags |= ECHO;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	SP->echo = TRUE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	noecho(void)
+#else
+int	PDC_CDECL	noecho()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("noecho() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	_CUR_TERM.prog_mode.c_lflag &= ~(ECHO|ECHOPRT);
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags &= ~ECHO;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	SP->echo = FALSE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	halfdelay(int tenths)
+#else
+int	PDC_CDECL	halfdelay(tenths)
+int tenths;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("halfdelay() - called\n");
+#endif
+	if (tenths < 1 || tenths > 255)
+		return (ERR);
+	SP->delaytenths = tenths;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	intrflush( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	intrflush(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef	TC
+#  pragma argsused
+#endif
+	int	y;
+	int	maxy;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("intrflush() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	maxy = win->_maxy - 1;
+
+	for (y = 0; y <= maxy; y++)
+	{
+		win->_firstch[y] = _NO_CHANGE;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	keypad( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	keypad(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("keypad() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_use_keypad = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	meta( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	meta(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("meta() - called\n");
+#endif
+
+#ifdef UNIX
+/* INCOMPLETE */
+#endif
+
+#ifdef	TC
+# pragma argsused;
+#endif
+	SP->raw_inp = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nodelay( WINDOW *win, bool flag )
+#else
+int	PDC_CDECL	nodelay(win,flag)
+WINDOW *win;
+bool flag;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nodelay() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_nodelay = flag;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	notimeout( WINDOW *win, bool flag )
+#else
+int	PDC_CDECL	notimeout(win,flag)
+WINDOW *win;
+bool flag;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("notimeout() - called\n");
+#endif
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	raw(void)
+#else
+int	PDC_CDECL	raw()
+#endif
+/***********************************************************************/
+{
+#ifdef OS2
+# ifndef EMXVIDEO
+	KBDINFO KbdInfo;
+# endif
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("raw() - called\n");
+#endif
+
+#ifdef OS2
+# ifndef EMXVIDEO
+	KbdGetStatus(&KbdInfo,0);
+	KbdInfo.fsMask |= KEYBOARD_BINARY_MODE;
+	KbdInfo.fsMask &= ~KEYBOARD_ASCII_MODE;
+	KbdSetStatus(&KbdInfo,0);
+# endif
+#endif
+
+#if defined( UNIX )	/* || defined( EMXVIDEO )	NOT COMPLETED */
+#ifdef USE_TERMIO
+#if 0
+	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON|ISIG);
+	_CUR_TERM.prog_mode.c_iflag &= ~(INPCK|ISTRIP|IXON);
+	_CUR_TERM.prog_mode.c_oflag &= ~(OPOST);
+	_CUR_TERM.prog_mode.c_cc[VMIN] = 1;
+	_CUR_TERM.prog_mode.c_cc[VTIME] = 0;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#endif
+	_CUR_TERM.prog_mode.c_lflag &= ~(ICANON|ISIG);
+	_CUR_TERM.prog_mode.c_iflag &= ~(IXON);
+	_CUR_TERM.prog_mode.c_iflag |= ICRNL;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags |= RAW;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	SP->raw_inp = TRUE;
+	PDC_set_ctrl_break(FALSE);      /* disallow ^BREAK on disk I/O */
+/*	flushinp(); */
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	noraw(void)
+#else
+int	PDC_CDECL	noraw()
+#endif
+/***********************************************************************/
+{
+#ifdef OS2
+# ifndef EMXVIDEO
+	KBDINFO KbdInfo;
+# endif
+#endif
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("noraw() - called\n");
+#endif
+
+#ifdef OS2
+# ifndef EMXVIDEO
+	KbdGetStatus(&KbdInfo,0);
+	KbdInfo.fsMask |= KEYBOARD_ASCII_MODE;
+	KbdInfo.fsMask &= ~KEYBOARD_BINARY_MODE;
+	KbdSetStatus(&KbdInfo,0);
+# endif
+#endif
+
+#if defined( UNIX ) /* || defined( EMXVIDEO ) NOT COMPLETE */
+#ifdef USE_TERMIO
+#if 0
+	_CUR_TERM.prog_mode.c_lflag |= ISIG|ICANON;
+	_CUR_TERM.prog_mode.c_iflag |= IXON|INPCK|ISTRIP;
+	_CUR_TERM.prog_mode.c_oflag |= OPOST;
+	_CUR_TERM.prog_mode.c_cc[VMIN] = _CUR_TERM.shell_mode.c_cc[VMIN];
+	_CUR_TERM.prog_mode.c_cc[VTIME] = _CUR_TERM.shell_mode.c_cc[VTIME];
+#endif
+	_CUR_TERM.prog_mode.c_lflag |= ICANON;
+	ioctl(_CUR_TERM.fd, TCSETAW, &_CUR_TERM.prog_mode);
+#else
+	_CUR_TERM.prog_mode.sg_flags &= ~RAW;
+	ioctl(_CUR_TERM.fd, TIOCSETP, &_CUR_TERM.prog_mode);
+#endif
+#endif
+
+	SP->raw_inp = FALSE;
+	PDC_set_ctrl_break(TRUE);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	noqiflush(void)
+#else
+void	PDC_CDECL	noqiflush()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("noqiflush() - called\n");
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	qiflush(void)
+#else
+void	PDC_CDECL	qiflush()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("qiflush() - called\n");
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	typeahead( int fildes )
+#else
+int	PDC_CDECL	typeahead(fildes)
+int fildes;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("typeahead() - called\n");
+#endif
+
+	if (fildes < 0)
+		SP->refrbrk = FALSE;
+	else
+		SP->refrbrk = TRUE;
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wtimeout( WINDOW *win, int delay )
+#else
+int	PDC_CDECL	wtimeout(win,delay)
+WINDOW *win;
+int delay;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wtimeout() - called\n");
+#endif
+
+	if (win == NULL)
+		return ERR;
+
+	if (delay < 0)
+	{
+		/*
+		 * This causes a blocking read on the window
+		 * so turn on delay mode
+		 */
+		win->_nodelay = FALSE;
+		win->_delayms = 0;
+	}
+	else if (delay == 0)
+	{
+		/*
+		 * This causes a non-blocking read on the window
+		 * so turn off delay mode
+		 */
+		win->_nodelay = TRUE;
+		win->_delayms = 0;
+	}
+	else
+	{
+		/*
+		 * This causes the read on the window
+		 * to delay for the number of milliseconds.
+		 * Also forces the window into non-blocking read mode
+		 */
+		/*win->_nodelay = TRUE;*/
+		win->_delayms = delay;
+	}
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	timeout( int delay )
+#else
+int	PDC_CDECL	timeout(delay)
+int delay;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("timeout() - called\n");
+#endif
+	return(wtimeout(stdscr,delay));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/insch.c stsgdb-6.8/pdcurses/pdcurses/insch.c
--- gdb-6.8/pdcurses/pdcurses/insch.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/insch.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,197 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	insch
+#undef	winsch
+#undef	mvinsch
+#undef	mvwinsch
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	refresh
+#  undef	wrefresh
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_insch  = "$Id: insch.c,v 1.1 2001/01/10 08:27:10 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         insch
+
+  Synopsis:
+  	int insch(chtype ch);
+  	int winsch(WINDOW *win, chtype ch);
+  	int mvinsch(int y, int x, chtype ch);
+  	int mvwinsch(WINDOW *win, int y, int x, chtype ch);
+
+  X/Open Description:
+ 	The routine insch() inserts the character ch into the default
+ 	window at the current cursor position and the window cursor is
+ 	advanced.  The character is of the type chtype as containing
+ 	both data and attributes.
+
+ 	The routine winsch() inserts the character ch into the specified
+ 	window at the current cursor position.  The cursor position is
+ 	advanced.
+
+ 	The routine mvinsch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the default window.
+ 	The cursor position is advanced after the character has been
+ 	inserted.
+
+ 	The routine mvwinsch() moves the cursor to the specified (y, x)
+ 	position and inserts the character ch into the specified
+ 	window.  The cursor position is advanced after the character
+ 	has been inserted.
+
+ 	The routine echochar() inserts the character ch into stdscr
+ 	at the current cursor position and a refresh() is called.  
+ 	The cursor position is advanced.
+
+ 	The routine wechochar() inserts the character ch into the
+ 	specified window at the current cursor position and a wrefresh() 
+ 	is called. The cursor position is advanced.
+
+ 	All these routines are similar to putchar().  The following
+ 	information applies to all the routines.
+
+ 	If the cursor moves on to the right margin, an automatic
+ 	newline is performed.  If scrollok is enabled, and a character
+ 	is added to the bottom right corner of the screen, the
+ 	scrolling region will be scrolled up one line.  If scrolling
+ 	is not allowed, ERR will be returned.
+
+ 	If ch is a tab, newline, or backspace, the cursor will be
+ 	moved appropriately within the window.  If ch is a newline,
+ 	the clrtoeol routine is called before the cursor is moved to
+ 	the beginning of the next line.  If newline mapping is off,
+ 	the cursor will be moved to the next line, but the x
+ 	coordinate will be unchanged.  If ch is a tab the cursor is
+ 	moved to the next tab position within the window.  If ch is
+ 	another control character, it will be drawn in the ^X
+ 	notation.  Calling the inch() routine after adding a control
+ 	character returns the representation of the control character,
+ 	not the control character.
+
+ 	Video attributes can be combined with a character by ORing
+ 	them into the parameter.  This will result in these attributes
+ 	being set.  The intent here is that text, including
+ 	attributes, can be copied from one place to another using inch()
+ 	and insch().
+
+ 	NOTE: All these functions are implemented as macros.
+
+  PDCurses Description:
+ 	Depending upon the state of the raw character output, 7- or
+ 	8-bit characters will be output.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      insch                                 Y        Y       Y
+      winsch                                Y        Y       Y
+      mvinsch                               Y        Y       Y
+      mvwinsch                              Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insch(chtype ch)
+#else
+int	PDC_CDECL	insch(ch)
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insch() - called\n");
+#endif
+
+	return( PDC_chins( stdscr, ch, (bool)(!(SP->raw_out))) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsch(WINDOW *win, chtype ch)
+#else
+int	PDC_CDECL	winsch(win,ch)
+WINDOW *win;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsch() - called\n");
+#endif
+
+	return( PDC_chins( win, ch, (bool)(!(SP->raw_out))) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinsch(int y, int x, chtype ch)
+#else
+int	PDC_CDECL	mvinsch(y,x,ch)
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinsch() - called\n");
+#endif
+	if (move(y,x) == ERR)
+		return(ERR);
+	return( PDC_chins( stdscr, ch, (bool)(!(SP->raw_out))) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsch(WINDOW *win, int y, int x, chtype ch)
+#else
+int	PDC_CDECL	mvwinsch(win,y,x,ch)
+WINDOW *win;
+int y;
+int x;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinsch() - called\n");
+#endif
+	if (wmove(win,y,x) == ERR)
+		return(ERR);
+	return( PDC_chins( win, ch, (bool)(!(SP->raw_out))) );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/insstr.c stsgdb-6.8/pdcurses/pdcurses/insstr.c
--- gdb-6.8/pdcurses/pdcurses/insstr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/insstr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,290 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	insstr
+#undef	insnstr
+#undef	winsstr
+#undef	winsnstr
+#undef	mvinsstr
+#undef	mvinsnstr
+#undef	mvwinsstr
+#undef	mvwinsnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#  undef	addch
+#  undef	waddch
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_insstr  = "$Id: insstr.c,v 1.4 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        insstr
+
+  Synopsis:
+  	int insstr(const char *str);
+  	int insnstr(const char *str, int n);
+  	int winsstr(WINDOW *win, const char *str);
+  	int winsnstr(WINDOW *win, const char *str, int n);
+  	int mvinsstr(int y, int x, const char *str);
+  	int mvinsnstr(int y, int x, const char *str, int n);
+  	int mvwinsstr(WINDOW *, int y, int x, const char *str);
+  	int mvwinsnstr(WINDOW *, int y, int x, const char *str, int n);
+
+  System V Curses Description:
+  	With these routines, a character string (as many characters as 
+  	will fit on the line) is inserted before the character under 
+  	the cursor.  All characters to the right of the cursor are moved 
+  	to the right, with the possibility of the rightmost characters 
+  	on the line being lost.  The cursor position does not change 
+  	(after moving to y,x if specified).  The four routines with n as 
+  	the last argument insert at most n characters.  If n<=0, then 
+  	the entire string is inserted.
+
+ 	NOTE:	insstr(), mvinsstr(), and mvwinsstr() are implemented as macros.
+ 		insnstr(), mvinsnstr(), and mvwinsnstr() are implemented as macros.
+
+  PDCurses Description:
+ 	The *raw*() routines output 8 bit values.  These contrast to their
+ 	normal counterparts which output 7 bit values and convert control
+ 	character to the ^X notation.
+
+ 	str is a standard 8 bit character string WITHOUT embedded attributes.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      insstr                                -        -      4.0
+      winsstr                               -        -      4.0
+      mvinsstr                              -        -      4.0
+      mvwinsstr                             -        -      4.0
+      insnstr                               -        -      4.0
+      winsnstr                              -        -      4.0
+      mvinsnstr                             -        -      4.0
+      mvwinsnstr                            -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insstr(const char *str)
+#else
+int	PDC_CDECL	insstr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	insnstr(const char *str, int n)
+#else
+int	PDC_CDECL	insnstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("insnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsstr(WINDOW *win, const char *str)
+#else
+int	PDC_CDECL	winsstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winsnstr(win,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winsnstr(WINDOW *win, const char *str, int n)
+#else
+int	PDC_CDECL	winsnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	int ic = strlen(str);
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsnstr() - called: string=\"%s\" n %d \n",str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( n > 0 )
+		ic = ((ic<n)?ic:n) - 1;
+	else
+		ic = ic - 1;
+
+	for ( ; ic >= 0; ic-- )
+	{
+		if (winsch(win, *(str+ic) ) == ERR)
+		{
+			return( ERR );
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinsstr(int y, int x, const char *str)
+#else
+int	PDC_CDECL	mvinsstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinsstr() - called: y %d x %d string=\"%s\"\n",y,x,str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinsnstr(int y, int x, const char *str, int n)
+#else
+int	PDC_CDECL	mvinsnstr(y,x,str,n)
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinsnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsstr(WINDOW *win, int y, int x, const char *str)
+#else
+int	PDC_CDECL	mvwinsstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winsstr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(win,str,(-1)));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinsnstr(WINDOW *win,int y, int x, const char *str, int n)
+#else
+int	PDC_CDECL	mvwinsnstr(win,y,x,str,n)
+WINDOW *win;
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinsnstr() - called: y %d x %d string=\"%s\" n %d \n",y,x,str,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winsnstr(win,str,n));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/instr.c stsgdb-6.8/pdcurses/pdcurses/instr.c
--- gdb-6.8/pdcurses/pdcurses/instr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/instr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,287 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	instr
+#undef	innstr
+#undef	winstr
+#undef	winnstr
+#undef	mvinstr
+#undef	mvinnstr
+#undef	mvwinstr
+#undef	mvwinnstr
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#  undef	inch
+#  undef	winch
+#  undef	mvwinch
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_instr  = "$Id: instr.c,v 1.2 2005/11/19 20:34:25 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        instr
+
+  Synopsis:
+  	int instr(char *str);
+  	int innstr(char *str, int n);
+  	int winstr(WINDOW *win, char *str);
+  	int winnstr(WINDOW *win, char *str, int n);
+  	int mvinstr(int y, int x, char *str);
+  	int mvinnstr(int y, int x, char *str, int n);
+  	int mvwinstr(WINDOW *, int y, int x, char *str);
+  	int mvwinnstr(WINDOW *, int y, int x, char *str, int n);
+
+  System V Curses Description:
+ 	These routines return a string of characters in str, starting at the
+ 	current cursor position in the named window and ending at the right
+ 	margin of the window.  Attributes are stripped from the characters.
+ 	The four functions with n as the last argument return the string at most
+ 	n characters long.
+
+ 	Note:  instr(), innstr(), winstr(), mvinstr(), mvinnstr(),
+ 		mvwinstr() and mvwinnstr() are all macros.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      instr                                 -        -      4.0
+      winstr                                -        -      4.0
+      mvinstr                               -        -      4.0
+      mvwinstr                              -        -      4.0
+      innstr                                -        -      4.0
+      winnstr                               -        -      4.0
+      mvinnstr                              -        -      4.0
+      mvwinnstr                             -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	instr(char *str)
+#else
+int	PDC_CDECL	instr(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("instr() - called: string=\"%s\"\n",str);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winnstr(stdscr,str,stdscr->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	innstr(char *str, int n)
+#else
+int	PDC_CDECL	innstr(str,n)
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("innstr() - called: n %d \n",n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winstr(WINDOW *win, char *str)
+#else
+int	PDC_CDECL	winstr(win,str)
+WINDOW *win;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winstr() - called: \n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	return(winnstr(win,str,win->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	winnstr(WINDOW *win, char *str, int n)
+#else
+int	PDC_CDECL	winnstr(win,str,n)
+WINDOW *win;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+	chtype tmp;
+	int oldy = win->_cury;
+	int oldx = win->_curx;
+	int imax = (win->_maxx - win->_curx);
+	int ic;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("winnstr() - called: n %d \n",n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( n > 0 )
+		imax = ((imax<n)?imax:n);
+
+	for ( ic=0; ic < imax; ic++ )
+	{
+		tmp = mvwinch( win, oldy, oldx+ic );
+		if( tmp == (chtype)ERR ) 
+		{
+			*(str+imax) = '\0';
+			return( ERR );
+		}
+		*(str+ic) = tmp & A_CHARTEXT;
+	}
+
+	*(str+imax) = '\0';
+
+	win->_curx = oldx;
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinstr(int y, int x, char *str)
+#else
+int	PDC_CDECL	mvinstr(y,x,str)
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinstr() - called: y %d x %d \n",y,x);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(stdscr,str,stdscr->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvinnstr(int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvinnstr(y,x,str,n)
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvinnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if (move(y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(stdscr,str,n));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinstr(WINDOW *win, int y, int x, char *str)
+#else
+int	PDC_CDECL	mvwinstr(win,y,x,str)
+WINDOW *win;
+int y;
+int x;
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinstr() - called: y %d x %d \n",y,x);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(win,str,win->_maxx));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwinnstr(WINDOW *win,int y, int x, char *str, int n)
+#else
+int	PDC_CDECL	mvwinnstr(win,y,x,str,n)
+WINDOW *win;
+int y;
+int x;
+char *str;
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwinnstr() - called: y %d x %d n %d \n",y,x,n);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (wmove(win,y,x) == ERR)
+		return( ERR );
+
+	return(winnstr(win,str,n));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/kernel.c stsgdb-6.8/pdcurses/pdcurses/kernel.c
--- gdb-6.8/pdcurses/pdcurses/kernel.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/kernel.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,513 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   def_prog_mode
+#undef   def_shell_mode
+#undef   reset_prog_mode
+#undef   reset_shell_mode
+#undef   resetty
+#undef   savetty
+#undef   ripoffline
+#undef   curs_set
+#undef   napms
+#undef   draino
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef move
+#  undef wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_kernel  = "$Id: kernel.c,v 1.8 2005/12/27 05:46:01 wmcbrine Exp $";
+#endif
+
+RIPPEDOFFLINE linesripped[5];
+char linesrippedoff=0;
+
+/*man-start*********************************************************************
+
+  Name:                                                        kernel
+
+  Synopsis:
+   int def_prog_mode(void);
+   int def_shell_mode(void);
+   int reset_prog_mode(void);
+   int reset_shell_mode(void);
+   int resetty(void);
+   int savetty(void);
+   void getsyx(int y, int x);
+   void setsyx(int y, int x);
+   int ripoffline(int line, int (*init)(WINDOW *,int));
+   int curs_set(int visibility);
+   int napms(int ms);
+   int draino(int ms);
+
+  X/Open Description:
+   The def_prog_mode() and def_shell_mode() functions save the
+   current terminal modes as the "program" (in curses) or
+   "shell" (not in curses) state for use by the reset_prog_mode()
+   and reset_shell_mode() functions.  This is done automatically by
+   initscr().
+
+   The reset_prog_mode() and reset_shell_mode() functions restore
+   the terminal to "program" (in curses) or "shell" (not in curses)
+   state.  These are done automatically by endwin()
+   and doupdate() after an endwin(), so they would normally not
+   be called before these functions.
+
+   The savetty() and resetty() routines save and restore the state of
+   the terminal modes. The savetty() function saves the current state
+   in a buffer and resetty() restores the state to what it was at the
+   last call to savetty().
+
+   The getsyx() routine obtains the coordinates of the virtual screen
+   cursor. If leaveok() is currently TRUE, then -1, -1 is returned. If
+   lines have been removed from the top of the screen with ripoffline()
+   then getsyx() includes those lines, so y and x should only be used
+   by setyx().
+   The setyx() routine sets the cursor position of the virtual screen
+   to the y,x coordinates. If y,x are -1,-1, leaveok() is set TRUE.
+   The getsyx() and setsyx() routines are designed to be used by a
+   library routine that manipulates curses windows, but does not want
+   to change the position of the cursor.
+
+   Note that getsyx() and setsyx() are defined as macros only. System VR4
+   defines these as having a return type of int, but that is misleading as
+   there is no documented sematics for the return value.
+
+   The curs_set() function enables the appearance of the text cursor
+   to be altered. A value of 0 for visibility makes the cursor
+   disappear; a value of 1 makes the cursor appear "normal" (usually
+   an underline) and 2 makes the cursor "highly visible"; a block.
+
+   The ripoffline() function allows the user to reduce the size of
+   stdscr by 1 line.  If the value of line is positive, the line is
+   removed from the top of the screen; negative from the bottom. Up to
+   5 lines can be ripped off stdscr by calling ripoffline()
+   consecutively.
+   The function argument, init, is called from within initscr() or
+   newterm(), so ripoffline() must be called before either of these
+   functions.  The init function is passed a pointer to a 1 line
+   WINDOW and the width of the window. Calling ripoffline() with a
+   NULL initialise function pointer is not advisable!
+
+   The napms() and draino() functions, suspends the program for the
+   specified number of milliseconds.
+
+  PDCurses Description:
+   FYI: It is very unclear whether savetty() and resetty() functions
+   are a duplication of the reset_prog_mode() and reset_shell_mode()
+   functions or whether this is a backing store type of operation.
+   At this time, they are implemented similar to the reset_*_mode()
+   routines.
+
+   The curs_set() routine is used to set the visibility of the cursor.
+   The cursor can be made invisible, normal or highly visible by setting
+   the parameter to 0, 1 or 2 respectively. If an invalid value is passed
+   the function will set the cursor to "normal".
+
+  X/Open Return Value:
+   All functions return OK on success and ERR on error except curs_set()
+   which returns the previous visibility.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      def_prog_mode                         Y        Y       Y
+      def_shell_mode                        Y        Y       Y
+      reset_prog_mode                       Y        Y       Y
+      reset_shell_mode                      Y        Y       Y
+      resetty                               Y        Y       Y
+      savetty                               Y        Y       Y
+      getsyx                                -        -      3.0
+      setsyx                                -        -      3.0
+      ripoffline                            -        -      3.0
+      curs_set                              -        -      3.0
+      napms                                 Y        Y       Y
+      draino                                ?        ?       N
+
+**man-end**********************************************************************/
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   def_prog_mode(void)
+#else
+int   PDC_CDECL   def_prog_mode()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("def_prog_mode() - called\n");
+#endif
+
+#ifdef   FLEXOS
+   _flexos_16bitmode();
+#endif
+   c_pr_tty.been_set = TRUE;
+
+   memcpy(&c_pr_tty.saved, SP, sizeof(SCREEN));
+
+   return( OK );
+}
+#endif
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   def_shell_mode(void)
+#else
+int   PDC_CDECL   def_shell_mode()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("def_shell_mode() - called\n");
+#endif
+
+#ifdef   FLEXOS
+   _flexos_8bitmode();
+#endif
+   c_sh_tty.been_set = TRUE;
+
+   memcpy(&c_sh_tty.saved, SP, sizeof(SCREEN));
+
+   return( OK );
+}
+#endif
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL reset_prog_mode(void)
+#else
+int PDC_CDECL reset_prog_mode()
+#endif
+/***********************************************************************/
+{
+#if defined(OS2) && !defined(EMXVIDEO)
+   VIOMODEINFO modeInfo;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("reset_prog_mode() - called\n");
+#endif
+
+   if (c_pr_tty.been_set == TRUE)
+   {
+      memcpy(SP, &c_pr_tty.saved, sizeof(SCREEN));
+
+      mvcur(0, 0, c_pr_tty.saved.cursrow, c_pr_tty.saved.curscol);
+      if (PDC_get_ctrl_break() != c_pr_tty.saved.orgcbr)
+         PDC_set_ctrl_break(c_pr_tty.saved.orgcbr);
+      if (c_pr_tty.saved.raw_out)
+         raw();
+      if (c_pr_tty.saved.visible_cursor)
+         PDC_cursor_on();
+      SP->font = PDC_get_font();
+      PDC_set_font(c_pr_tty.saved.font);
+#if !defined (XCURSES)
+# if !defined(EMXVIDEO)
+#  if defined(OS2)
+      (void)PDC_get_scrn_mode( &modeInfo );
+      if ( !PDC_scrn_modes_equal( modeInfo, c_pr_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_pr_tty.saved.scrnmode );
+#  else
+      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_pr_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_pr_tty.saved.scrnmode );
+#  endif
+# endif
+#endif
+      PDC_set_rows(c_pr_tty.saved.lines);
+   }
+#ifdef FLEXOS
+   _flexos_16bitmode();
+#endif
+
+#if defined(WIN32) || (defined(OS2) && !defined(EMXVIDEO))
+   PDC_reset_prog_mode();
+#endif
+   return( OK );
+}
+#endif
+
+#ifndef UNIX
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL reset_shell_mode(void)
+#else
+int PDC_CDECL reset_shell_mode()
+#endif
+/***********************************************************************/
+{
+#if defined(OS2) && !defined(EMXVIDEO)
+   VIOMODEINFO modeInfo;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("reset_shell_mode() - called\n");
+#endif
+
+#ifndef WIN32
+   if (c_sh_tty.been_set == TRUE)
+   {
+      memcpy(SP, &c_sh_tty.saved, sizeof(SCREEN));
+
+      mvcur(0, 0, c_sh_tty.saved.cursrow, c_sh_tty.saved.curscol);
+      if (PDC_get_ctrl_break() != c_sh_tty.saved.orgcbr)
+         PDC_set_ctrl_break(c_sh_tty.saved.orgcbr);
+      if (c_sh_tty.saved.raw_out)
+         raw();
+      if (c_sh_tty.saved.visible_cursor)
+         PDC_cursor_on();
+      SP->font = PDC_get_font();
+      PDC_set_font(c_sh_tty.saved.font);
+# if !defined (XCURSES)
+#  if !defined(EMXVIDEO)
+#   if defined(OS2)
+      (void)PDC_get_scrn_mode( &modeInfo );
+      if ( !PDC_scrn_modes_equal( modeInfo, c_sh_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_sh_tty.saved.scrnmode );
+#   else
+      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_sh_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_sh_tty.saved.scrnmode );
+#   endif
+#  endif
+# endif
+# if defined(OS2)
+      PDC_resize_screen(c_sh_tty.saved.lines,c_sh_tty.saved.cols);
+# else
+      PDC_set_rows(c_sh_tty.saved.lines);
+# endif
+   }
+#endif
+
+#ifdef   FLEXOS
+   _flexos_8bitmode();
+#endif
+
+#if defined(WIN32) || (defined(OS2) && !defined(EMXVIDEO))
+   PDC_reset_shell_mode();
+#endif
+
+   return( OK );
+}
+#endif
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL resetty(void)
+#else
+int PDC_CDECL resetty()
+#endif
+/***********************************************************************/
+{
+#if defined(OS2) && !defined(EMXVIDEO)
+   VIOMODEINFO modeInfo;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("resetty() - called\n");
+#endif
+
+#ifndef UNIX
+   if (c_save_tty.been_set == TRUE)
+   {
+      memcpy(SP, &c_save_tty.saved, sizeof(SCREEN));
+      mvcur(0, 0, c_save_tty.saved.cursrow, c_save_tty.saved.curscol);
+      if (PDC_get_ctrl_break() != c_save_tty.saved.orgcbr)
+         PDC_set_ctrl_break(c_save_tty.saved.orgcbr);
+      if (c_save_tty.saved.raw_out)
+         raw();
+      if (c_save_tty.saved.visible_cursor)
+         PDC_cursor_on();
+      SP->font = PDC_get_font();
+      PDC_set_font(c_save_tty.saved.font);
+# if !defined (XCURSES)
+#  if !defined(EMXVIDEO)
+#   if defined(OS2)
+      (void)PDC_get_scrn_mode( &modeInfo );
+      if ( !PDC_scrn_modes_equal( modeInfo, c_save_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_save_tty.saved.scrnmode );
+#   else
+      if ( !PDC_scrn_modes_equal( PDC_get_scrn_mode(), c_save_tty.saved.scrnmode ) )
+         PDC_set_scrn_mode( c_save_tty.saved.scrnmode );
+#   endif
+#  endif
+# endif
+# if defined(OS2) || defined(WIN32) || defined(DOS)
+      PDC_resize_screen(c_save_tty.saved.lines,c_save_tty.saved.cols);
+# else
+      PDC_set_rows(c_save_tty.saved.lines);
+# endif
+   }
+#endif
+   return( c_save_tty.been_set ? OK : ERR );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   savetty(void)
+#else
+int   PDC_CDECL   savetty()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("savetty() - called\n");
+#endif
+
+   c_save_tty.been_set = TRUE;
+   memcpy(&c_save_tty.saved, SP, sizeof(SCREEN));
+   return( OK );
+}
+#if 0
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   getsyx(int *y, int *x)
+#else
+int   PDC_CDECL   getsyx(y,x)
+int *y,*x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("getsyx() - called\n");
+#endif
+
+   if (curscr->_leaveit)
+      *y = *x = (-1);
+   else
+   {
+      *y = curscr->_cury - SP->linesrippedoffontop;
+      *x = curscr->_curx;
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   setsyx(int y, int x)
+#else
+int   PDC_CDECL   setsyx(y,x)
+int y,x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("setsyx() - called\n");
+#endif
+
+   if (y < 0 && x < 0)
+      curscr->_leaveit = TRUE;
+   else
+   {
+      curscr->_cury = y + SP->linesrippedoffontop;
+      curscr->_curx = x;
+      curscr->_leaveit = FALSE;
+   }
+   return( OK );
+}
+#endif
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   curs_set(int visibility)
+#else
+int   PDC_CDECL   curs_set(visibility)
+int visibility;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+   return(PDC_curs_set(visibility));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   ripoffline(int line, int (*init)(WINDOW *,int))
+#else
+int   PDC_CDECL   ripoffline(line, init)
+int line;
+int (*init)();
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("ripoffline() - called: line=%d\n",line);
+#endif
+
+   if (linesrippedoff < 5
+   &&  line != 0)
+   {
+   linesripped[(int)linesrippedoff].line = line;
+   linesripped[(int)linesrippedoff++].init = init;
+   }
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   napms(int ms)
+#else
+int   PDC_CDECL   napms(ms)
+int ms;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("napms() - called: ms=%d\n",ms);
+#endif
+   return(delay_output(ms));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   draino(int ms)
+#else
+int   PDC_CDECL   draino(ms)
+int ms;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("draino() - called: ms=%d\n",ms);
+#endif
+   return(delay_output(ms));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/Makefile.aix.in stsgdb-6.8/pdcurses/pdcurses/Makefile.aix.in
--- gdb-6.8/pdcurses/pdcurses/Makefile.aix.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/Makefile.aix.in	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,306 @@
+# Makefile for XCurses library for AIX
+#
+# The variable 'srcdir' refers to the source-distribution, and can be set with
+# the configure script by "--srcdir=DIR".
+#
+
+SHELL		= /bin/sh
+THIS		= Makefile
+
+@SET_MAKE@
+
+srcdir		= @srcdir@
+x11basedir		= $(srcdir)/../x11
+x11dir		= $(x11basedir)/@x11type@
+
+VPATH		= @srcdir@
+prefix		= @prefix@
+exec_prefix	= @exec_prefix@
+libdir		= $(exec_prefix)
+includedir	= @includedir@
+
+PDCURSES_HOME		=$(srcdir)/..
+PDCURSES_CONFIG_H		=../config.h
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CONFIG_H) $(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PDCURSES_X11_H		=$(x11basedir)/pdcx11.h
+
+INSTALL		= @INSTALL@
+INSTALL_DATA	= @INSTALL_DATA@
+
+SHL_TARGETS =      @SHL_TARGETS@
+DYN_COMP =         @DYN_COMP@
+SHLPRE =           @SHLPRE@
+SHLPST =           @SHLPST@
+LD_RXLIB1  =       @LD_RXLIB1@
+LD_RXLIB2  =       # @MH_XLIBS@ @MH_EXTRA_LIBS@ -lc
+MH_XLIBS =         @MH_XLIBS@
+MH_EXTRA_LIBS =    @MH_EXTRA_LIBS@
+O2SAVE  =          @O2SAVE@
+O2SHO  =           @O2SHO@
+CC2O   =           @CC2O@
+SAVE2O  =          @SAVE2O@
+DYNAMIC_LDFLAGS  = @DYNAMIC_LDFLAGS@ $(EEXTRA)
+
+CC		= @CC@
+CFLAGS		= @CFLAGS@ $(DYN_COMP)
+
+INCDIR		= $(srcdir)
+CPPFLAGS	= -I$(INCDIR) -I$(srcdir)/.. -I.. @DEFS@ -DXCURSES @SYS_DEFS@ -I$(x11basedir) -I$(x11dir)
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS) @MH_XINC_DIR@
+
+LINK		= $(CC)
+LDFLAGS		= 
+
+LIBRARIES	= libXCurses.a
+
+################################################################################
+all :	$(LIBRARIES)
+
+install : 
+	echo Does nothing at the moment
+
+clean :
+	-rm -rf *.o *.sho trace $(LIBRARIES)
+
+distclean: clean
+	-rm -f Makefile
+
+mostlyclean: clean
+
+realclean: distclean
+
+#------------------------------------------------------------------------
+
+LIBOBJS =   \
+addch.o     \
+addchstr.o  \
+addstr.o    \
+attr.o      \
+beep.o      \
+bkgd.o      \
+border.o    \
+clear.o     \
+color.o     \
+delch.o     \
+deleteln.o  \
+getch.o     \
+getstr.o    \
+getyx.o     \
+inch.o      \
+inchstr.o   \
+initscr.o   \
+inopts.o    \
+insch.o     \
+insstr.o    \
+instr.o     \
+kernel.o    \
+mouse.o     \
+move.o      \
+outopts.o   \
+overlay.o   \
+pad.o       \
+printw.o    \
+refresh.o   \
+scanw.o     \
+scr_dump.o  \
+scroll.o    \
+slk.o       \
+termattr.o  \
+terminfo.o  \
+touch.o     \
+util.o      \
+window.o
+
+PDCOBJS =   \
+pdcclip.o   \
+pdcdebug.o  \
+pdcdisp.o   \
+pdcgetsc.o  \
+pdckbd.o    \
+pdcprint.o  \
+pdcscrn.o   \
+pdcsetsc.o   \
+pdcutil.o   \
+pdcwin.o
+
+X11OBJS =   \
+pdcx11.o    \
+x11curses.o \
+x11common.o \
+x11.o       \
+sb.o        \
+ScrollBox.o
+
+libXCurses.a : $(LIBOBJS) $(PDCOBJS) $(X11OBJS) curses.exp ../x11/xcurses.exp
+	ld -bnoentry -bM:SRE -bE:curses.exp $(MH_LIBS) $(MH_EXTRA_LIBS) $(LIBOBJS) $(PDCOBJS) $(X11OBJS) -o $@
+
+curses.exp: ../win32/curses.def ../x11/xcurses.exp
+	cp ../x11/xcurses.exp ./curses.exp
+	grep ^EXPORTS ../win32/curses.def | cut -f 2 -d\ >> curses.exp
+
+addch.o: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/addch.c
+
+addchstr.o: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/addchstr.c
+
+addstr.o: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/addstr.c
+
+attr.o: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/attr.c
+
+beep.o: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/beep.c
+
+bkgd.o: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/bkgd.c
+
+border.o: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/border.c
+
+clear.o: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/clear.c
+
+color.o: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/color.c
+
+delch.o: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/delch.c
+
+deleteln.o: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/deleteln.c
+
+getch.o: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/getch.c
+
+getstr.o: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/getstr.c
+
+getyx.o: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/getyx.c
+
+inch.o: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/inch.c
+
+inchstr.o: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/inchstr.c
+
+initscr.o: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/initscr.c
+
+inopts.o: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/inopts.c
+
+insch.o: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/insch.c
+
+insstr.o: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/insstr.c
+
+instr.o: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/instr.c
+
+kernel.o: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/kernel.c
+
+mouse.o: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/mouse.c
+
+move.o: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/move.c
+
+outopts.o: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/outopts.c
+
+overlay.o: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/overlay.c
+
+pad.o: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pad.c
+
+printw.o: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/printw.c
+
+refresh.o: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/refresh.c
+
+scanw.o: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/scanw.c
+
+scr_dump.o: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/scr_dump.c
+
+scroll.o: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/scroll.c
+
+slk.o: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/slk.c
+
+termattr.o: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/termattr.c
+
+terminfo.o: $(srcdir)/terminfo.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/terminfo.c
+
+touch.o: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/touch.c
+
+util.o: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/util.c
+
+window.o: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/window.c
+
+
+pdcclip.o: $(x11basedir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcclip.c
+
+pdcdebug.o: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pdcdebug.c
+
+pdcdisp.o: $(x11basedir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcdisp.c
+
+pdcgetsc.o: $(x11basedir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcgetsc.c
+
+pdckbd.o: $(x11basedir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdckbd.c
+
+pdcprint.o: $(x11basedir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcprint.c
+
+pdcscrn.o: $(x11basedir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcscrn.c
+
+pdcsetsc.o: $(x11basedir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcsetsc.c
+
+pdcutil.o: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pdcutil.c
+
+pdcwin.o: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pdcwin.c
+
+pdcx11.o: $(x11basedir)/pdcx11.c $(PDCURSES_HEADERS) $(PDCURSES_X11_H)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcx11.c
+
+ScrollBox.o: $(x11basedir)/ScrollBox.c $(PDCURSES_HEADERS) $(PDCURSES_X11_H)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/ScrollBox.c
+
+sb.o: $(x11basedir)/sb.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/sb.c
+
+x11common.o: $(x11dir)/x11common.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11dir)/x11common.c
+
+x11.o: $(x11dir)/x11.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11dir)/x11.c
+
+x11curses.o: $(x11dir)/x11curses.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11dir)/x11curses.c
+
diff -Naur gdb-6.8/pdcurses/pdcurses/Makefile.in stsgdb-6.8/pdcurses/pdcurses/Makefile.in
--- gdb-6.8/pdcurses/pdcurses/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/Makefile.in	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,696 @@
+# Makefile for XCurses library
+#
+# The variable 'srcdir' refers to the source-distribution, and can be set with
+# the configure script by "--srcdir=DIR".
+#
+
+SHELL		= /bin/sh
+THIS		= Makefile
+
+@SET_MAKE@
+
+srcdir		= @srcdir@
+x11basedir		= $(srcdir)/../x11
+x11dir		= $(x11basedir)/@x11type@
+
+VPATH		= @srcdir@
+prefix		= @prefix@
+exec_prefix	= @exec_prefix@
+libdir		= $(exec_prefix)
+includedir	= @includedir@
+
+PDCURSES_HOME		=$(srcdir)/..
+PDCURSES_CONFIG_H		=../config.h
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CONFIG_H) $(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PDCURSES_X11_H		=$(x11basedir)/pdcx11.h
+
+INSTALL		= @INSTALL@
+INSTALL_DATA	= @INSTALL_DATA@
+
+SHL_TARGETS =      @SHL_TARGETS@
+DYN_COMP =         @DYN_COMP@
+SHLPRE =           @SHLPRE@
+SHLPST =           @SHLPST@
+LD_RXLIB1  =       @LD_RXLIB1@
+LD_RXLIB2  =       @MH_XLIBS@ @MH_EXTRA_LIBS@ -lc
+O2SAVE  =          @O2SAVE@
+O2SHO  =           @O2SHO@
+CC2O   =           @CC2O@
+SAVE2O  =          @SAVE2O@
+DYNAMIC_LDFLAGS  = @DYNAMIC_LDFLAGS@ $(EEXTRA)
+
+CC		= @CC@
+CFLAGS		= @CFLAGS@
+
+INCDIR		= $(srcdir)
+CPPFLAGS	= -I$(INCDIR) -I$(srcdir)/.. -I.. @DEFS@ -DXCURSES @SYS_DEFS@ -I$(x11basedir) -I$(x11dir)
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS) @MH_XINC_DIR@
+
+LINK		= $(CC)
+LDFLAGS		=
+
+RANLIB		= @RANLIB@
+
+LIBRARIES	= libXCurses.a
+
+SHLFILE = XCurses
+
+################################################################################
+all :	$(LIBRARIES) $(SHL_TARGETS)
+
+install :
+	echo Does nothing at the moment
+
+clean :
+	-rm -rf *.o *.sho trace $(LIBRARIES) $(SHL_TARGETS)
+
+distclean: clean
+	-rm -f Makefile
+
+mostlyclean: clean
+
+realclean: distclean
+
+#------------------------------------------------------------------------
+
+LIBOBJS =   \
+addch.o     \
+addchstr.o  \
+addstr.o    \
+attr.o      \
+beep.o      \
+bkgd.o      \
+border.o    \
+clear.o     \
+color.o     \
+delch.o     \
+deleteln.o  \
+getch.o     \
+getstr.o    \
+getyx.o     \
+inch.o      \
+inchstr.o   \
+initscr.o   \
+inopts.o    \
+insch.o     \
+insstr.o    \
+instr.o     \
+kernel.o    \
+mouse.o     \
+move.o      \
+outopts.o   \
+overlay.o   \
+pad.o       \
+printw.o    \
+refresh.o   \
+scanw.o     \
+scr_dump.o  \
+scroll.o    \
+slk.o       \
+termattr.o  \
+terminfo.o  \
+touch.o     \
+util.o      \
+window.o
+
+PDCOBJS =   \
+pdcclip.o   \
+pdcdebug.o  \
+pdcdisp.o   \
+pdcgetsc.o  \
+pdckbd.o    \
+pdcprint.o  \
+pdcscrn.o   \
+pdcsetsc.o   \
+pdcutil.o   \
+pdcwin.o
+
+X11OBJS =   \
+pdcx11.o    \
+x11curses.o \
+x11common.o \
+x11.o       \
+sb.o        \
+ScrollBox.o
+
+LIBSHOBJS =   \
+addch.sho     \
+addchstr.sho  \
+addstr.sho    \
+attr.sho      \
+beep.sho      \
+bkgd.sho      \
+border.sho    \
+clear.sho     \
+color.sho     \
+delch.sho     \
+deleteln.sho  \
+getch.sho     \
+getstr.sho    \
+getyx.sho     \
+inch.sho      \
+inchstr.sho   \
+initscr.sho   \
+inopts.sho    \
+insch.sho     \
+insstr.sho    \
+instr.sho     \
+kernel.sho    \
+mouse.sho     \
+move.sho      \
+outopts.sho   \
+overlay.sho   \
+pad.sho       \
+printw.sho    \
+refresh.sho   \
+scanw.sho     \
+scr_dump.sho  \
+scroll.sho    \
+slk.sho       \
+termattr.sho  \
+terminfo.sho  \
+touch.sho     \
+util.sho      \
+window.sho
+
+PDCSHOBJS =   \
+pdcclip.sho   \
+pdcdebug.sho  \
+pdcdisp.sho   \
+pdcgetsc.sho  \
+pdckbd.sho    \
+pdcprint.sho  \
+pdcscrn.sho   \
+pdcsetsc.sho   \
+pdcutil.sho   \
+pdcwin.sho
+
+X11SHOBJS =   \
+pdcx11.sho    \
+x11curses.sho \
+x11common.sho \
+x11.sho       \
+sb.sho        \
+ScrollBox.sho
+
+SHOFILES = $(LIBSHOBJS) $(PDCSHOBJS) $(X11SHOBJS)
+
+libXCurses.a : $(LIBOBJS) $(PDCOBJS) $(X11OBJS)
+	ar rv $@ $?
+	-$(RANLIB) $@
+
+$(SHLPRE)$(SHLFILE)$(SHLPST) : $(SHOFILES)
+	cp $(srcdir)/../win32/curses.def ./cygwin.def
+	$(LD_RXLIB1) $(RXPACKEXPORTS) -o $@ $(SHOFILES) $(LD_RXLIB2)
+
+addch.o: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/addch.c
+
+addchstr.o: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/addchstr.c
+
+addstr.o: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/addstr.c
+
+attr.o: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/attr.c
+
+beep.o: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/beep.c
+
+bkgd.o: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/bkgd.c
+
+border.o: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/border.c
+
+clear.o: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/clear.c
+
+color.o: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/color.c
+
+delch.o: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/delch.c
+
+deleteln.o: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/deleteln.c
+
+getch.o: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/getch.c
+
+getstr.o: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/getstr.c
+
+getyx.o: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/getyx.c
+
+inch.o: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/inch.c
+
+inchstr.o: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/inchstr.c
+
+initscr.o: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/initscr.c
+
+inopts.o: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/inopts.c
+
+insch.o: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/insch.c
+
+insstr.o: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/insstr.c
+
+instr.o: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/instr.c
+
+kernel.o: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/kernel.c
+
+mouse.o: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/mouse.c
+
+move.o: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/move.c
+
+outopts.o: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/outopts.c
+
+overlay.o: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/overlay.c
+
+pad.o: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pad.c
+
+printw.o: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/printw.c
+
+refresh.o: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/refresh.c
+
+scanw.o: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/scanw.c
+
+scr_dump.o: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/scr_dump.c
+
+scroll.o: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/scroll.c
+
+slk.o: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/slk.c
+
+termattr.o: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/termattr.c
+
+terminfo.o: $(srcdir)/terminfo.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/terminfo.c
+
+touch.o: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/touch.c
+
+util.o: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/util.c
+
+window.o: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/window.c
+
+
+pdcclip.o: $(x11basedir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcclip.c
+
+pdcdebug.o: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pdcdebug.c
+
+pdcdisp.o: $(x11basedir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcdisp.c
+
+pdcgetsc.o: $(x11basedir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcgetsc.c
+
+pdckbd.o: $(x11basedir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdckbd.c
+
+pdcprint.o: $(x11basedir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcprint.c
+
+pdcscrn.o: $(x11basedir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcscrn.c
+
+pdcsetsc.o: $(x11basedir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcsetsc.c
+
+pdcutil.o: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pdcutil.c
+
+pdcwin.o: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/pdcwin.c
+
+pdcx11.o: $(x11basedir)/pdcx11.c $(PDCURSES_HEADERS) $(PDCURSES_X11_H)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/pdcx11.c
+
+ScrollBox.o: $(x11basedir)/ScrollBox.c $(PDCURSES_HEADERS) $(PDCURSES_X11_H)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/ScrollBox.c
+
+sb.o: $(x11basedir)/sb.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11basedir)/sb.c
+
+x11common.o: $(x11dir)/x11common.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11dir)/x11common.c
+
+x11.o: $(x11dir)/x11.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11dir)/x11.c
+
+x11curses.o: $(x11dir)/x11curses.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o $@ $(x11dir)/x11curses.c
+
+
+addch.sho: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/addch.c
+	$(O2SHO)
+	$(SAVE2O)
+
+addchstr.sho: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/addchstr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+addstr.sho: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/addstr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+attr.sho: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/attr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+beep.sho: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/beep.c
+	$(O2SHO)
+	$(SAVE2O)
+
+bkgd.sho: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/bkgd.c
+	$(O2SHO)
+	$(SAVE2O)
+
+border.sho: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/border.c
+	$(O2SHO)
+	$(SAVE2O)
+
+clear.sho: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/clear.c
+	$(O2SHO)
+	$(SAVE2O)
+
+color.sho: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/color.c
+	$(O2SHO)
+	$(SAVE2O)
+
+delch.sho: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/delch.c
+	$(O2SHO)
+	$(SAVE2O)
+
+deleteln.sho: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/deleteln.c
+	$(O2SHO)
+	$(SAVE2O)
+
+getch.sho: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/getch.c
+	$(O2SHO)
+	$(SAVE2O)
+
+getstr.sho: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/getstr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+getyx.sho: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/getyx.c
+	$(O2SHO)
+	$(SAVE2O)
+
+inch.sho: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/inch.c
+	$(O2SHO)
+	$(SAVE2O)
+
+inchstr.sho: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/inchstr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+initscr.sho: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/initscr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+inopts.sho: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/inopts.c
+	$(O2SHO)
+	$(SAVE2O)
+
+insch.sho: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/insch.c
+	$(O2SHO)
+	$(SAVE2O)
+
+insstr.sho: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/insstr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+instr.sho: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/instr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+kernel.sho: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/kernel.c
+	$(O2SHO)
+	$(SAVE2O)
+
+mouse.sho: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/mouse.c
+	$(O2SHO)
+	$(SAVE2O)
+
+move.sho: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/move.c
+	$(O2SHO)
+	$(SAVE2O)
+
+outopts.sho: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/outopts.c
+	$(O2SHO)
+	$(SAVE2O)
+
+overlay.sho: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/overlay.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pad.sho: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/pad.c
+	$(O2SHO)
+	$(SAVE2O)
+
+printw.sho: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/printw.c
+	$(O2SHO)
+	$(SAVE2O)
+
+refresh.sho: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/refresh.c
+	$(O2SHO)
+	$(SAVE2O)
+
+scanw.sho: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/scanw.c
+	$(O2SHO)
+	$(SAVE2O)
+
+scr_dump.sho: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/scr_dump.c
+	$(O2SHO)
+	$(SAVE2O)
+
+scroll.sho: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/scroll.c
+	$(O2SHO)
+	$(SAVE2O)
+
+slk.sho: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/slk.c
+	$(O2SHO)
+	$(SAVE2O)
+
+termattr.sho: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/termattr.c
+	$(O2SHO)
+	$(SAVE2O)
+
+terminfo.sho: $(srcdir)/terminfo.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/terminfo.c
+	$(O2SHO)
+	$(SAVE2O)
+
+touch.sho: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/touch.c
+	$(O2SHO)
+	$(SAVE2O)
+
+util.sho: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/util.c
+	$(O2SHO)
+	$(SAVE2O)
+
+window.sho: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/window.c
+	$(O2SHO)
+	$(SAVE2O)
+
+
+pdcclip.sho: $(x11basedir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcclip.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcdebug.sho: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/pdcdebug.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcdisp.sho: $(x11basedir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcdisp.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcgetsc.sho: $(x11basedir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcgetsc.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdckbd.sho: $(x11basedir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdckbd.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcprint.sho: $(x11basedir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcprint.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcscrn.sho: $(x11basedir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcscrn.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcsetsc.sho: $(x11basedir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcsetsc.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcutil.sho: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/pdcutil.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcwin.sho: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(srcdir)/pdcwin.c
+	$(O2SHO)
+	$(SAVE2O)
+
+pdcx11.sho: $(x11basedir)/pdcx11.c $(PDCURSES_HEADERS) $(PDCURSES_X11_H)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/pdcx11.c
+	$(O2SHO)
+	$(SAVE2O)
+
+ScrollBox.sho: $(x11basedir)/ScrollBox.c $(PDCURSES_HEADERS) $(PDCURSES_X11_H)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/ScrollBox.c
+	$(O2SHO)
+	$(SAVE2O)
+
+sb.sho: $(x11basedir)/sb.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11basedir)/sb.c
+	$(O2SHO)
+	$(SAVE2O)
+
+x11common.sho: $(x11dir)/x11common.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11dir)/x11common.c
+	$(O2SHO)
+	$(SAVE2O)
+
+x11.sho: $(x11dir)/x11.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11dir)/x11.c
+	$(O2SHO)
+	$(SAVE2O)
+
+x11curses.sho: $(x11dir)/x11curses.c $(PDCURSES_HEADERS)
+	$(O2SAVE)
+	$(CC) $(CCFLAGS) $(DYN_COMP) $(CC2O) $(x11dir)/x11curses.c
+	$(O2SHO)
+	$(SAVE2O)
diff -Naur gdb-6.8/pdcurses/pdcurses/mouse.c stsgdb-6.8/pdcurses/pdcurses/mouse.c
--- gdb-6.8/pdcurses/pdcurses/mouse.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/mouse.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,246 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	mouse_set
+#undef	mouse_on
+#undef	mouse_off
+#undef	request_mouse_pos
+#undef	map_button
+#undef	wmouse_position
+#undef	getmouse
+#undef	getbmap
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_mouse = "$Id: mouse.c,v 1.2 2002/03/22 22:36:53 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         mouse
+
+  Synopsis:
+
+  	int mouse_set( long );
+  	int mouse_on( long );
+  	int mouse_off( long );
+  	int request_mouse_pos( void );
+  	int map_button( unsigned long );
+  	void wmouse_position( WINDOW *, int *, int * );
+  	unsigned long getmouse( void );
+  	unsigned long getbmap( void );
+
+  PDCurses Description:
+ 	ALL DESCRIPTIONS ARE GUESSES. I DON'T KNOW ANYONE WHO KNOWS
+ 	EXACTLY WHAT THESE FUNCTIONS DO!
+
+ 	The mouse_set(), mouse_on() and mouse_off() functions are analagous to
+ 	the attrset(), attron() and attroff() functions.  These functions
+ 	set the mouse button events to trap.  The button masks used in these
+ 	functions are defined in curses.h and can be or'ed together. They are
+ 	the group of masks starting with BUTTON1_RELEASED.
+
+ 	The request_mouse_pos() function requests curses to fill in the
+ 	Mouse_status structure with the current state of the mouse.
+
+ 	The map_button() function enables the mouse requested mouse action
+ 	to activate the Soft Label Keys if the mouse action occurs over the
+ 	area of the screen where the Soft Label Keys are displayed.  The
+ 	mouse actions are defined in curses.h and are the group that start
+ 	with BUTTON_RELEASED.
+
+ 	The wmouse_position() function determines if the current mouse
+ 	position is within the window passed as an argument.  If the mouse
+ 	is outside the current window, -1 is returned in the y and x arguments
+ 	otherwise the y and x coordinates of the mouse (relative to the top
+ 	left corner of the window) are returned in y and x.
+
+ 	The getmouse() function returns the current status of the trapped
+ 	mouse buttons as set by mouse_set(), mouse_on();
+
+ 	The getbmap() function returns the current status of the button action
+ 	used to map a mouse action to the Soft Label Keys as set by the
+ 	map_button() function.
+
+  PDCurses Errors:
+ 	None.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      mouse_set                             -        -      4.0
+      mouse_on                              -        -      4.0
+      mouse_off                             -        -      4.0
+      request_mouse_pos                     -        -      4.0
+      map_button                            -        -      4.0
+      wmouse_position                       -        -      4.0
+      getmouse                              -        -      4.0
+      getbmap                               -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mouse_set(unsigned long mbe)
+#else
+int	PDC_CDECL	mouse_set(mbe)
+unsigned long mbe;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mouse_set() - called: event %x\n",mbe);
+#endif
+	SP->_trap_mbe = mbe;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mouse_on(unsigned long mbe)
+#else
+int	PDC_CDECL	mouse_on(mbe)
+unsigned long mbe;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mouse_on() - called: event %x\n",mbe);
+#endif
+	SP->_trap_mbe |= mbe;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mouse_off(unsigned long mbe)
+#else
+int	PDC_CDECL	mouse_off(mbe)
+unsigned long mbe;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mouse_off() - called: event %x\n",mbe);
+#endif
+	SP->_trap_mbe &= ~mbe;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	map_button(unsigned long button)
+#else
+int	PDC_CDECL	map_button(button)
+unsigned long button;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("map_button() - called: button %x\n",button);
+#endif
+/****************** this does nothing at the moment ***************/
+	SP->_map_mbe_to_key = button;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	request_mouse_pos(void)
+#else
+int	PDC_CDECL	request_mouse_pos()
+#endif
+/***********************************************************************/
+{
+extern MOUSE_STATUS Trapped_Mouse_status;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("request_mouse_pos() - called\n");
+#endif
+	memcpy((char*)&Mouse_status,(char*)&Trapped_Mouse_status,sizeof(MOUSE_STATUS));
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wmouse_position(WINDOW *win, int *y, int *x)
+#else
+void	PDC_CDECL	wmouse_position(win,y,x)
+WINDOW *win;
+int *y,*x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wmouse_position() - called\n");
+#endif
+/* if the current mouse position is outside the provided window, put  */
+/* -1 in x and y                                                      */
+	if (win == (WINDOW *)NULL)
+	{
+		*y = *x = (-1);
+		return;
+	}
+	if (win->_begy > MOUSE_Y_POS 
+	||  win->_begx > MOUSE_X_POS 
+	||  win->_begy+win->_maxy <= MOUSE_Y_POS
+	||  win->_begx+win->_maxx <= MOUSE_X_POS)
+	{
+		*x = *y = (-1);
+	}
+	else
+	{
+		*x = MOUSE_X_POS - win->_begx;
+		*y = MOUSE_Y_POS - win->_begy;
+	}
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long	PDC_CDECL	getmouse(void)
+#else
+unsigned long	PDC_CDECL	getmouse()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getmouse() - called\n");
+#endif
+	return(SP->_trap_mbe);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long	PDC_CDECL	getbmap(void)
+#else
+unsigned long	PDC_CDECL	getbmap()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getbmap() - called\n");
+#endif
+	return(SP->_map_mbe_to_key);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/move.c stsgdb-6.8/pdcurses/pdcurses/move.c
--- gdb-6.8/pdcurses/pdcurses/move.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/move.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,123 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	move
+#undef	wmove
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_move  = "$Id: move.c,v 1.1 2001/01/10 08:27:16 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          move
+
+  Synopsis:
+  	int move(int y, int x);
+  	int wmove(WINDOW *win, int y, int x);
+
+  X/Open Description:
+ 	The cursor associated with the window is moved to the given
+ 	location.  This does not move the physical cursor of the
+ 	terminal until refresh() is called.  The position specified is
+ 	relative to the upper left corner of the window, which is (0,0).
+
+ 	NOTE: move() is a macro.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      move                                  Y        Y       Y
+      wmove                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	move(int y, int x)
+#else
+int	PDC_CDECL	move(y,x)
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("move() - called: y=%d x=%d\n",y,x);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return( ERR );
+
+	if ((x < 0) ||
+	    (y < 0) ||
+	    (x >= stdscr->_maxx) ||
+	    (y >= stdscr->_maxy))
+	{
+		return( ERR );
+	}
+	stdscr->_curx = x;
+	stdscr->_cury = y;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wmove(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	wmove(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wmove() - called: y=%d x=%d\n",y,x);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if ((x < 0) ||
+	    (y < 0) ||
+	    (x >= win->_maxx) ||
+	    (y >= win->_maxy))
+	{
+		return( ERR );
+	}
+	win->_curx = x;
+	win->_cury = y;
+	return( OK );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/outopts.c stsgdb-6.8/pdcurses/pdcurses/outopts.c
--- gdb-6.8/pdcurses/pdcurses/outopts.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/outopts.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,392 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	clearok
+#undef	idlok
+#undef	idcok
+#undef	immedok
+#undef	leaveok
+#undef	setscrreg
+#undef	wsetscrreg
+#undef	scrollok
+#undef	nl
+#undef	nonl
+#undef	raw_output
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_outopts  = "$Id: outopts.c,v 1.1 2001/01/10 08:27:17 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       outopts
+
+  Synopsis:
+  	int clearok(WINDOW *win, bool bf);
+  	int idlok( WINDOW *win, bool bf );
+  	int idcok( WINDOW *win, bool bf );
+  	int immedok( WINDOW *win, bool bf );
+  	int leaveok( WINDOW *win, bool bf );
+  	int setscrreg(int top, int bot);
+  	int wsetscrreg(WINDOW *win, int top, int bot);
+  	int scrollok(WINDOW *win, bool bf);
+  	int nl(void);
+  	int nonl(void);
+
+  	int raw_output(bool bf);
+
+  X/Open Description:
+ 	With the clearok() routine, if bf is TRUE, the next call to 
+ 	wrefresh() with this window will clear the screen completely 
+ 	and redraw the entire screen.
+
+ 	If idlok() is enabled (bf is TRUE), curses will use the insert/delete
+ 	line feature of terminals so equipped.  If disabled, curses will not
+ 	use this feature.  (The insert/delete character feature is always
+ 	used.)  This option should be enabled only if the application
+ 	needs insert/delete line; for example, for a screen editor.  It
+ 	is disabled by default because insert/delete line tends to be
+ 	visually annoying when used in applications where it isn't really
+ 	needed.  If insert/delete line cannot be used, curses will redraw
+ 	the changed portions of all lines.
+
+ 	With the idcok() routine, if enabled (bf is TRUE), curses considers
+ 	using the hardware insert/delete character feature of terminals so 
+ 	equipped. This is enabled by default.
+
+ 	The immedok() routine, called with a second argument of TRUE, 
+ 	causes an automatic wrefrsh() to be called on the window every time
+ 	a change is made to that window, due to calls like; waddch(),
+ 	wclrtoeol(), etc... Not surprisingly, this causes a severe performance
+ 	overhead.
+
+ 	Normally, the hardware cursor is left at the location of the
+ 	window being refreshed.  leaveok() allows the cursor to be
+ 	left wherever the update happens to leave it.  It is useful
+ 	for applications where the cursor is not used, since it reduces
+ 	the need for cursor motions.  If possible, the cursor is made
+ 	invisible when this option is enabled.
+
+ 	The setscrreg() and wsetscrreg() functions allow the user to set 
+ 	a software scrolling region in a window.  The parameters 'top' 
+ 	and 'bot' are the line numbers of the top and bottom margin of the 
+ 	scrolling region.  (Line 0 is the top line of the window.)  If this 
+ 	option and scrollok() are enabled, an attempt to move off the bottom 
+ 	margin will cause all lines in the scrolling region to scroll up one 
+ 	line.  Only the text of the window is scrolled.
+
+ 	The nl() function enables the translation of newline into a
+ 	carriage return and a line-feed on output, and a carriage return
+ 	is translated into a newline on input.  Initially, the translations
+ 	do occur.  By disabling these translations, curses is able to
+ 	make better use of the line-feed capability, resulting in faster
+ 	cursor motion.
+
+ 	The nonl() function disables the translation of newline into a
+ 	carriage return and a line-feed on output, and a carriage return
+ 	is translated into a newline on input.  Initially, the translations
+ 	do occur.  By disabling these translations, curses is able to
+ 	make better use of the line-feed capability, resulting in faster
+ 	cursor motion.
+
+  PDCurses Description:
+ 	idlok() and idcok() are provided for portability.  
+ 	This may have some value for the FLEXOS platform, but there is 
+ 	no code in PDCurses at this time (910725) that takes advantage 
+ 	of this.
+
+ 	Though not explicitly stated, the cursor will be made visible
+ 	again, if leaveok() is passed a FALSE value.
+ 			(Frotz:911226 Comments?)
+
+ 	The raw_output() routine enables the output of raw characters using 
+ 	the 'standard' *add* and *ins* curses functions.
+ 	To force 8 bit output and no translation of control characters,
+ 	invoke raw_output() with bf as TRUE.  To force 7 bit output and
+ 	translation of control characters, invoke raw_output() with bf
+ 	as FALSE.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      clearok                               Y        Y       Y
+      idlok                                 Y        Y       Y
+      idcok                                 -        -      4.0
+      immedok                               -        -      4.0
+      leaveok                               Y        Y       Y
+      setscrreg                             Y        Y       Y
+      wsetscrreg                            Y        Y       Y
+      scrollok                              Y        Y       Y
+      nl                                    Y        Y       Y
+      nonl                                  Y        Y       Y
+      raw_output                            -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	clearok(WINDOW *win, bool bf)
+#else
+int	PDC_CDECL	clearok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("clearok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_clear = bf;
+#if 0
+	if( bf )
+		touchwin( win );
+#endif
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	idlok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	idlok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("idlok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_use_idl = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	idcok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	idcok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("idcok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_use_idc = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	immedok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	immedok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("immedok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_immed = bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	leaveok( WINDOW *win, bool bf )
+#else
+int	PDC_CDECL	leaveok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("leaveok() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if  ((win->_leaveit = bf) != 0)	PDC_cursor_off();
+	else				PDC_cursor_on();
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	setscrreg(int top, int bottom)
+#else
+int	PDC_CDECL	setscrreg(top,bottom)
+int top;
+int bottom;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("setscrreg() - called: top %d bottom %d\n",top,bottom);
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return (ERR);
+
+	if ((0 <= top) &&
+	    (top <= stdscr->_cury) &&
+	    (stdscr->_cury <= bottom) &&
+	    (bottom < LINES))
+	{
+		stdscr->_tmarg = top;
+		stdscr->_bmarg = bottom;
+		return (OK);
+	}
+	else
+	{
+		return (ERR);
+	}
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wsetscrreg(WINDOW *win, int top, int bottom)
+#else
+int	PDC_CDECL	wsetscrreg(win,top,bottom)
+WINDOW *win;
+int top;
+int bottom;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wsetscrreg() - called: top %d bottom %d\n",top,bottom);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (ERR);
+
+	if ((0 <= top) &&
+	    (top <= win->_cury) &&
+	    (win->_cury <= bottom) &&
+	    (bottom < win->_maxy))
+	{
+		win->_tmarg = top;
+		win->_bmarg = bottom;
+		return (OK);
+	}
+	else
+	{
+		return (ERR);
+	}
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	scrollok(WINDOW *win, bool bf)
+#else
+int	PDC_CDECL	scrollok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scrollok() - called\n");
+#endif
+
+	if  (win == (WINDOW *)NULL)
+		return( ERR );
+
+	win->_scroll	= bf;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nl(void)
+#else
+int	PDC_CDECL	nl()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nl() - called\n");
+#endif
+
+	SP->autocr = TRUE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	nonl(void)
+#else
+int	PDC_CDECL	nonl()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("nonl() - called\n");
+#endif
+
+	SP->autocr = FALSE;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	raw_output(bool bf)
+#else
+int	PDC_CDECL	raw_output(bf)
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("raw_output() - called\n");
+#endif
+
+	SP->raw_out = bf;
+	return( OK );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/overlay.c stsgdb-6.8/pdcurses/pdcurses/overlay.c
--- gdb-6.8/pdcurses/pdcurses/overlay.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/overlay.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,311 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	overlay
+#undef	overwrite
+#undef	copywin
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_overlay  = "$Id: overlay.c,v 1.3 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       overlay
+
+  Synopsis:
+  	int	overlay(const WINDOW *src_w, WINDOW *dst_w)
+  	int	overwrite(const WINDOW *src_w, WINDOW *dst_w)
+  	int	copywin(const WINDOW *src_w, WINDOW *dst_w, int src_tr,
+  			int src_tc, int dst_tr, int dst_tc, int dst_br,
+			int dst_bc, bool overlay)
+
+  X/Open Description:
+ 	The overlay() and overwrite() functions overlay src_w on top of 
+ 	dst_w; that is, all text in src_w is copied into dst_w. The windows
+ 	src_w and dst_w are not required to be the same size. The
+ 	copy starts at (0, 0) on each window. The difference between
+ 	the two functions is that overlay() is non-destructive
+ 	(blanks are not copied) while overwrite() is destructive
+ 	(blanks are copied).
+
+ 	copywin() is similar to overwrite() and overlay() but copywin()
+ 	does not require that the two windows overlap.
+ 	The arguments src_tc and src_tr specify the top left corner of the
+ 	region to be copied to the destination window.
+ 	The arguments dst_tc,dst_tr,dst_br,dst_bc specify the region within
+ 	the destination window to where the copy is made.
+ 	The argument overlay, if TRUE, indicates that the copy is done
+ 	non-destructively (as in overlay()). Blanks in the source window
+ 	are not copied to the destination window. When overlay is FALSE,
+ 	(as in overwrite()), the copy is destructive; blanks are copied
+ 	to the destination window.
+
+  PDCurses Description:
+ 	The above description for overlay() and overwrite() is misleading 
+ 	in the actual behaviour exhibited by both SysV and BSD curses. 
+ 	The above implies that the character in 0,0 of the source window 
+ 	is copied to 0,0 of the destination window. What actually happens 
+ 	is that those characters in the source window that intersect with 
+ 	characters in the destination window RELATIVE TO ABSOLUTE 0,0 ON 
+ 	THE SCREEN, are copied to the destination window so that the 
+ 	characters appear in the same physical position on the screen.
+
+ 	Thanks to Andreas Otte (venn@@uni-paderborn.de) for the correction
+ 	and code changes.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      overlay                               Y        Y       Y
+      overwrite                             Y        Y       Y
+      copywin                               -        -      3.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	overlay(const WINDOW *src_w, WINDOW *dst_w)
+#else
+int	PDC_CDECL	overlay(src_w,dst_w)
+WINDOW *src_w;
+WINDOW *dst_w;
+#endif
+/***********************************************************************/
+{
+	int	last_line;
+	int	last_col;
+	int	first_line;
+	int	first_col;
+	int	src_start_x;
+	int	src_start_y;
+	int	dst_start_x;
+	int	dst_start_y;
+	int	xdiff;
+	int	ydiff;
+	int	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("overlay() - called\n");
+#endif
+
+	if (src_w == (WINDOW *)NULL)	return( ERR );
+	if (dst_w == (WINDOW *)NULL)	return( ERR );
+
+	first_col  = max(dst_w->_begx,src_w->_begx);
+	first_line = max(dst_w->_begy,src_w->_begy);
+	last_col   = min(src_w->_begx+src_w->_maxx, dst_w->_begx+dst_w->_maxx);
+	last_line  = min(src_w->_begy+src_w->_maxy, dst_w->_begy+dst_w->_maxy);
+
+/* determine the overlapping region of the two windows in real coordinates */
+	if ((last_col < first_col) || (last_line < first_line))
+    return(OK);  /* if no overlapping region, do nothing */
+
+/* size of overlapping region */
+	xdiff = last_col - first_col;
+	ydiff = last_line - first_line;
+
+	if (src_w->_begx <= dst_w->_begx)
+		{
+		src_start_x = dst_w->_begx - src_w->_begx;
+		dst_start_x = 0;
+		}
+	else
+		{
+		dst_start_x = src_w->_begx - dst_w->_begx;
+		src_start_x = 0;
+		}
+	if (src_w->_begy <= dst_w->_begy)
+		{
+		src_start_y = dst_w->_begy - src_w->_begy;
+		dst_start_y = 0;
+		}
+	else
+		{
+		dst_start_y = src_w->_begy - dst_w->_begy;
+		src_start_y = 0;
+		}
+
+	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,
+		src_start_y+ydiff,src_start_x+xdiff,dst_start_y,dst_start_x,
+		dst_start_y+ydiff,dst_start_x+xdiff,TRUE);
+
+	return( rc );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	overwrite(const WINDOW *src_w, WINDOW *dst_w)
+#else
+int	PDC_CDECL	overwrite(src_w,dst_w)
+WINDOW *src_w;
+WINDOW *dst_w;
+#endif
+/***********************************************************************/
+{
+	int	last_line;
+	int	last_col;
+	int	first_line;
+	int	first_col;
+	int	src_start_x;
+	int	src_start_y;
+	int	dst_start_x;
+	int	dst_start_y;
+	int	xdiff;
+	int	ydiff;
+	int	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("overwrit() - called\n");
+#endif
+
+	if (src_w == (WINDOW *)NULL)	return( ERR );
+	if (dst_w == (WINDOW *)NULL)	return( ERR );
+
+	first_col  = max(dst_w->_begx,src_w->_begx);
+	first_line = max(dst_w->_begy,src_w->_begy);
+	last_col   = min(src_w->_begx+src_w->_maxx, dst_w->_begx+dst_w->_maxx);
+	last_line  = min(src_w->_begy+src_w->_maxy, dst_w->_begy+dst_w->_maxy);
+
+/* determine the overlapping region of the two windows in real coordinates */
+	if ((last_col < first_col) || (last_line < first_line))
+    return(OK);  /* if no overlapping region, do nothing */
+
+/* size of overlapping region */
+	xdiff = last_col - first_col;
+	ydiff = last_line - first_line;
+
+	if (src_w->_begx <= dst_w->_begx)
+		{
+		src_start_x = dst_w->_begx - src_w->_begx;
+		dst_start_x = 0;
+		}
+	else
+		{
+		dst_start_x = src_w->_begx - dst_w->_begx;
+		src_start_x = 0;
+		}
+	if (src_w->_begy <= dst_w->_begy)
+		{
+		src_start_y = dst_w->_begy - src_w->_begy;
+		dst_start_y = 0;
+		}
+	else
+		{
+		dst_start_y = src_w->_begy - dst_w->_begy;
+		src_start_y = 0;
+		}
+
+	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,
+		src_start_y+ydiff,src_start_x+xdiff,dst_start_y,dst_start_x,
+		dst_start_y+ydiff,dst_start_x+xdiff,FALSE);
+
+	return( rc );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	copywin(const WINDOW *src_w, WINDOW *dst_w, 
+	int src_tr, int src_tc, int dst_tr,
+	int dst_tc, int dst_br, int dst_bc, int overlay)
+#else
+int	PDC_CDECL	copywin(src_w,dst_w,src_tr,src_tc,dst_tr,dst_tc,dst_br,dst_bc,overlay)
+WINDOW *src_w;
+WINDOW *dst_w;
+int src_tr;
+int src_tc;
+int dst_tr;
+int dst_tc;
+int dst_br;
+int dst_bc;
+int overlay;
+#endif
+/***********************************************************************/
+{
+	int	src_start_x = src_tc;
+	int	src_start_y = src_tr;
+	int	dst_start_x = dst_tc;
+	int	dst_start_y = dst_tr;
+	int	src_end_x;
+	int	src_end_y;
+	int	dst_end_x;
+	int	dst_end_y;
+	int	src_rows,src_cols;
+	int	dst_rows,dst_cols;
+	int	min_rows,min_cols;
+	int	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("copywin() - called\n");
+#endif
+
+	if (src_w == (WINDOW *)NULL
+	||  dst_w == (WINDOW *)NULL)
+		return( ERR );
+
+	if (dst_w == curscr)	return( ERR );
+
+#if 0
+	if (dst_br >= dst_w->_maxy
+	||  dst_bc >= dst_w->_maxx
+	||  dst_tr < 0
+	||  dst_tc < 0)
+		return( ERR );
+#else
+	if (dst_br > dst_w->_maxy
+	||  dst_bc > dst_w->_maxx
+	||  dst_tr < 0
+	||  dst_tc < 0)
+		return( ERR );
+#endif
+
+	src_rows = src_w->_maxy - src_tr;
+	src_cols = src_w->_maxx - src_tc;
+	dst_rows = dst_br - dst_tr;
+	dst_cols = dst_bc - dst_tc;
+
+	min_rows = min(src_rows,dst_rows);
+	min_cols = min(src_cols,dst_cols);
+
+	src_end_y = src_tr + min_rows;
+	src_end_x = src_tc + min_cols;
+	dst_end_y = dst_tr + min_rows;
+	dst_end_x = dst_tc + min_cols;
+
+	rc = PDC_copy_win(src_w,dst_w,src_start_y,src_start_x,src_end_y,src_end_x,
+		dst_start_y,dst_start_x,dst_end_y,dst_end_x,overlay);
+
+	return( rc );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/pad.c stsgdb-6.8/pdcurses/pdcurses/pad.c
--- gdb-6.8/pdcurses/pdcurses/pad.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/pad.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,424 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef newpad
+#undef subpad
+#undef prefresh
+#undef pnoutrefresh
+#undef pechochar
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+# undef doupdate
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_pad  = "$Id: pad.c,v 1.4 2005/12/08 08:12:32 wmcbrine Exp $";
+#endif
+
+/*
+ * save values for pechochar()
+ */
+static int save_pminrow;
+static int save_pmincol;
+static int save_sminrow;
+static int save_smincol;
+static int save_smaxrow;
+static int save_smaxcol;
+
+/*man-start*********************************************************************
+
+  Name:                                                           pad
+
+  Synopsis:
+    WINDOW* newpad( int nlines, int ncols );
+    WINDOW* subpad(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x);
+    int prefresh(WINDOW* win,int py,int px,int sy1,int sx1,int sy2,int sx2);
+    int pnoutrefresh(WINDOW* w,int py,int px,int sy1,int sx1,int sy2,int sx2);
+    int pechochar(WINDOW *pad, chtype ch);
+
+  X/Open Description:
+    newpad() creates a new pad data structure.  A pad is a special case
+    of a window, which is not restricted by the screen size, and is not
+    necessarily associated with a particular part of the screen.  A
+    pad can be used when a large window is needed, and only a part
+    of the window will be on the screen at one tme.  Automatic
+    refreshes of pads (e.g., from scrolling or echoing of input) do
+    not occur.  It is not legal to call refresh() with a pad as an
+    argument; the routines prefresh() or pnoutrefresh() should be
+    called instead.  Note that these routines require additional
+    parameters to specify the part of the pad to be displayed and
+    the location on the screen to be used for display.
+
+    The subpad() routine creates a new sub-pad within a pad.  The
+    dimensions of the sub-pad are nlines lines and ncols
+    columns.  The sub-pad is at position (begin_y, begin_x) in the
+    the parent pad.  This position is relative to the pad, and not
+    to the screen like with subwin.
+    The sub-pad is made in the middle of the pad orig, so
+    that changes made to either pad will affect both.  When
+    using this routine, it will often be necessary to call
+    touchwin before calling prefresh.
+
+    The prefresh() routine copies the specified pad to the physical
+    terminal screen.  It takes account of what is already
+    displayed on the screen to optimize cursor movement.
+    The pnoutrefresh() routine copies the named pad to the virtual
+    screen. It then compares the virtual screen with the physical
+    screen and performs the actual update.
+    These routines are analogous to the routines wrefresh() and
+    wnoutrefresh() except that pads, instead of windows, are
+    involved.  Additional parameters are also needed to indicate
+    what part of the pad and screen are involved. The upper left
+    corner of the part of the pad to be displayed is specified by
+    py and px.  The coordinates sy1, sx1, sy2, and sx2 specify the
+    edges of the screen rectangle that will contain the selected
+    part of the pad.
+    The lower right corner of the pad rectangle to be displayed is
+    calculated from the screen co-ordinates.  This ensures that
+    the screen rectangle and the pad rectangle are the same size.
+    Both rectangles must be entirely contained within their
+    respective structures.
+
+    The pechochar() is functionally equivalent to adch() followed
+    by a call to refresh().
+
+  PDCurses Description:
+    PDCurses (as a library) provides the developer with the ability to
+    hook in their own malloc debugging  package.  See the details in
+    INITSCR.C for details on how to accomplish this.
+
+  X/Open Return Value:
+    All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+    No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      newpad                                Y        -       Y
+      subpad                                Y        -       Y
+      prefresh                              Y        -       Y
+      pnoutrefresh                          Y        -       Y
+      pechochar                             -        -      3.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW* PDC_CDECL newpad( int nlines, int ncols )
+#else
+WINDOW* PDC_CDECL newpad(nlines,ncols)
+int nlines;
+int ncols;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+   extern void* (*callc)( size_t, size_t );
+   extern void  (*fre)( void* );
+#else
+   extern void* (*callc)();
+   extern void  (*fre)();
+#endif
+
+   WINDOW* win;
+   chtype* ptr;
+   int   i;
+   int   j;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("newpad() - called: lines=%d cols=%d\n",nlines,ncols);
+#endif
+
+   if ((win = PDC_makenew( nlines, ncols, -1, -1 )) == (WINDOW *)NULL)
+      return( (WINDOW *)NULL );
+
+   for (i = 0; i < nlines; i++)
+   {
+      /*
+       * make and clear the lines
+       */
+      if ((win->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
+      {
+         for (j = 0; j < i; j++)
+         {
+            /*
+             * if error, free all the data
+             */
+            (*fre)(win->_y[j]);
+         }
+         (*fre)(win->_firstch);
+         (*fre)(win->_lastch);
+         (*fre)(win->_y);
+         (*fre)(win);
+         return( (WINDOW *)NULL );
+      }
+      else
+      {
+         for (ptr = win->_y[i];
+              ptr < win->_y[i] + ncols;)
+         {
+            /*
+            * Retain the original screen attributes...
+            */
+
+            *ptr++ = SP->blank;  
+         }
+      }
+   }
+   win->_flags = _PAD;
+   /*
+    * save default values in case pechochar() is the first call
+    * to prefresh().
+    */
+   save_pminrow=0;
+   save_pmincol=0;
+   save_sminrow=0;
+   save_smincol=0;
+   save_smaxrow=min(LINES,nlines)-1;
+   save_smaxcol=min(COLS,ncols)-1;
+   return( win );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW* PDC_CDECL subpad(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
+#else
+WINDOW* PDC_CDECL subpad(orig,nlines,ncols,begin_y,begin_x)
+WINDOW* orig;
+int nlines;
+int ncols;
+int begin_y;
+int begin_x;
+#endif
+/***********************************************************************/
+{
+   WINDOW*  win;
+   int   i;
+   int   j = begin_y;
+   int   k = begin_x;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("subpad() - called: lines=%d cols=%d begy=%d begx=%d\n",nlines,ncols,begin_y,begin_x);
+#endif
+
+   if (!orig)
+      return( (WINDOW *)NULL );
+
+   if (!(orig->_flags & _PAD))
+      return( (WINDOW *)NULL );
+
+   /*
+    * make sure window fits inside the original one
+    */
+   if ((begin_y < orig->_begy) ||
+       (begin_x < orig->_begx) ||
+       (begin_y + nlines) > (orig->_begy + orig->_maxy) ||
+       (begin_x + ncols)  > (orig->_begx + orig->_maxx))
+   {
+      return( (WINDOW *)NULL );
+   }
+   if (!nlines) 
+      nlines = orig->_maxy - 1 - j;
+   if (!ncols) 
+      ncols = orig->_maxx - 1 - k;
+   if ((win = PDC_makenew(nlines, ncols, begin_y, begin_x)) == (WINDOW *) NULL)
+   {
+      return( (WINDOW *)NULL );
+   }
+
+   /*
+    * initialize window variables
+    */
+   win->_attrs = orig->_attrs;
+   win->_leaveit  = orig->_leaveit;
+   win->_scroll   = orig->_scroll;
+   win->_nodelay  = orig->_nodelay;
+   win->_use_keypad  = orig->_use_keypad;
+   win->_parent   = orig;
+
+   for (i = 0; i < nlines; i++)
+   {
+      win->_y[i] = (orig->_y[j++]) + k;
+   }
+
+   win->_flags = _SUBPAD;
+   /*
+    * save default values in case pechochar() is the first call
+    * to prefresh().
+    */
+   save_pminrow=0;
+   save_pmincol=0;
+   save_sminrow=0;
+   save_smincol=0;
+   save_smaxrow=min(LINES,nlines)-1;
+   save_smaxcol=min(COLS,ncols)-1;
+   return (win);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL prefresh(WINDOW* win,int py,int px,int sy1,int sx1,int sy2,int sx2)
+#else
+int PDC_CDECL prefresh(win,py,px,sy1,sx1,sy2,sx2)
+WINDOW* win;
+int py;
+int px;
+int sy1;
+int sx1;
+int sy2;
+int sx2;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("prefresh() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if (pnoutrefresh(win, py, px, sy1, sx1, sy2, sx2) == ERR)
+      return( ERR );
+
+   doupdate();
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL pnoutrefresh(WINDOW* w,int py,int px,int sy1,int sx1,int sy2,int sx2)
+#else
+int PDC_CDECL pnoutrefresh(w,py,px,sy1,sx1,sy2,sx2)
+WINDOW* w;
+int py;
+int px;
+int sy1;
+int sx1;
+int sy2;
+int sx2;
+#endif
+/***********************************************************************/
+{
+   WINDOW*     s = curscr;
+   int      sline = sy1;
+   int      pline = py;
+   int      num_cols = min((sx2-sx1+1),(w->_maxx-px));
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("pnoutrefresh() - called\n");
+#endif
+
+
+   if (w == (WINDOW *)NULL)
+      return( ERR );
+
+   if (sy2 < sy1 || sx2 < sx1) return(ERR);
+
+   if (!(w->_flags == _PAD)
+   &&  !(w->_flags == _SUBPAD))
+      return( ERR );
+
+   while (sline <= sy2)
+   {
+      if (pline < w->_maxy)
+      {
+         memcpy(&(s->_y[sline][sx1]), &(w->_y[pline][px]), (num_cols) * sizeof(chtype));
+
+         if ((s->_firstch[sline] == _NO_CHANGE) 
+         ||  (s->_firstch[sline] > sx1))
+         {
+            s->_firstch[sline] = sx1;
+         }
+
+         if (sx2 > s->_lastch[sline])
+            s->_lastch[sline] = sx2;
+
+         w->_firstch[pline] = _NO_CHANGE;  /* updated now */
+         w->_lastch[pline] = _NO_CHANGE;  /* updated now */
+      }
+      sline++;
+      pline++;
+   }
+
+   w->_lastpy = py;
+   w->_lastpx = px;
+   w->_lastsy1 = sy1;
+   w->_lastsx1 = sx1;
+   w->_lastsy2 = sy2;
+   w->_lastsx2 = sx2;
+
+   if (w->_clear)
+   {
+      w->_clear = FALSE;
+      s->_clear = TRUE;
+   }
+
+   /* position the cursor to the pad's current position if possible */
+   if (!w->_leaveit)
+   {
+      /* is the pad current position going to end up displayed ? if not
+       * then don't move the cursor, if so move it to the correct place 
+       */
+      if (w->_cury >= py
+      &&  w->_curx >= px
+      &&  w->_cury <= py + (sy2 - sy1+1)
+      &&  w->_curx <= px + (sx2 - sx1+1))
+      {
+         s->_cury = (w->_cury - py) + sy1;
+         s->_curx = (w->_curx - px) + sx1;
+      }
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL pechochar(WINDOW *pad, chtype ch)
+#else
+int PDC_CDECL pechochar(pad,ch)
+WINDOW *pad;
+chtype ch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("pechochar() - called\n");
+#endif
+
+   if ( PDC_chadd( pad, ch, !(SP->raw_out), TRUE ) == ERR )
+      return(ERR);
+   return( prefresh( pad,
+                     save_pminrow,
+                     save_pmincol,
+                     save_sminrow,
+                     save_smincol,
+                     save_smaxrow,
+                     save_smaxcol ) );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/pdcdebug.c stsgdb-6.8/pdcurses/pdcurses/pdcdebug.c
--- gdb-6.8/pdcurses/pdcurses/pdcdebug.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/pdcdebug.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+#include <sys/types.h>
+#include <time.h>
+
+
+#undef   PDC_debug
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+# include <stdarg.h>
+# define HAVE_STDARG_H_HAVE_PROTO
+#else
+# include <varargs.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdebug  = "$Id: pdcdebug.c,v 1.5 2005/11/21 19:39:03 wmcbrine Exp $";
+#endif
+
+   bool trace_on = FALSE;
+
+/*man-start*********************************************************************
+
+  PDC_debug()  - Write debugging info to log file.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+  PDCurses Return Value:
+   No return value.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses void PDC_debug( char *,... );
+
+**man-end**********************************************************************/
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+void  PDC_CDECL   PDC_debug( char *fmt, ... )
+#else
+void  PDC_CDECL   PDC_debug(fmt,va_alist)
+char *fmt;
+va_dcl
+#endif
+{
+   va_list args;
+   FILE *dbfp;
+   char buffer[256], hms[9];
+   time_t now;
+
+   /*
+    * open debug log file append
+    */
+   buffer[0] = '\0';
+   if (!trace_on)
+      return; 
+   dbfp = fopen("trace","a");
+   if (dbfp == NULL)
+   {
+      fprintf( stderr, "PDC_debug(): Unable to open debug log file\n" );
+      return;
+   }
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+   va_start(args, fmt);
+#else
+   va_start(args);
+#endif
+
+   time(&now);
+   strftime(hms, 9, "%H:%M:%S", localtime(&now));
+   fprintf(dbfp, "At: %8.8ld - %s ", (long) clock(), hms);
+
+   vsprintf(buffer,fmt,args);
+   fputs(buffer,dbfp);
+   va_end(args);
+   fclose(dbfp);
+   return;
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/pdcutil.c stsgdb-6.8/pdcurses/pdcurses/pdcutil.c
--- gdb-6.8/pdcurses/pdcurses/pdcutil.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/pdcutil.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,788 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#if !defined(XCURSES)
+# define	INCLUDE_WINDOWS_H
+#endif
+#include <curses.h>
+
+#undef PDC_usleep
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+
+#include <stdlib.h>
+#include <ctype.h>
+#include <stdio.h>
+
+#ifdef HAVE_LIMITS_H
+#  include <limits.h>
+#endif
+
+#ifdef HAVE_STRING_H
+#  include <string.h>
+#endif
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCutil  = "$Id: pdcutil.c,v 1.7 2005/12/17 09:17:16 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_memmove()	- Replacement memmove() for lacking compliers.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Move a portion of memory taking consideration of overlapping memory
+ 	areas.
+
+  PDCurses Return Value:
+ 	This function returns NULL if no temporary memory could be allocated.
+
+  Portability:
+ 	PDCurses	int PDC_memmove(void *s1,const void *s2,size_t n);
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void *PDC_memmove (void *s1, const void *s2, size_t n)
+#else
+void *PDC_memmove (s1,s2,n)
+void *s1;
+void *s2;
+size_t n;
+#endif
+/***********************************************************************/
+{
+  char *dd;
+#ifdef HAVE_PROTO
+  const char *ss;
+#else
+  char *ss;
+#endif
+
+  dd = (char *)s1;
+#ifdef HAVE_PROTO
+  ss = (const char *)s2;
+#else
+  ss = (char *)s2;
+#endif
+  if (dd > ss && dd < ss + n)
+    {
+      dd += n;
+      ss += n;
+      while (n--)
+        *--dd = *--ss;
+    }
+  else
+    while (n--)
+      *dd++ = *ss++;
+  return s1;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void PDC_beep (void)
+#else
+void PDC_beep ()
+#endif
+/***********************************************************************/
+{
+#ifdef UNIX
+	if (bell != NULL)
+		putp(bell);
+#endif
+
+#if defined (XCURSES)
+	XCursesInstruct(CURSES_BELL);
+#endif
+
+#if defined(DOS)
+	PDC_putctty( (chtype)'\007', 0 );
+#endif
+
+#if defined(OS2)
+#   if defined(EMXVIDEO)
+	putchar('\007');
+#   else
+	DosBeep( 1380, 100 );
+#   endif
+#endif
+
+#if defined(WIN32)
+/*	MessageBeep(MB_OK); */
+	MessageBeep(0XFFFFFFFF);
+#endif
+
+  return;
+}
+
+/*man-start*********************************************************************
+
+  PDC_usleep()	- waits for specified number of microseconds
+
+  PDCurses Description:
+ 	This routine is intended to provide a mechanism to wait the
+ 	specified number of microseconds. It is provided for those
+ 	platforms that do not have their own usleep() function.
+
+  Portability:
+ 	PDCurses	void PDC_usleep( clock_t );
+
+  Acknowledgement
+ 	PDC_usleep() was written by John Steele  (jsteele@netcom.com)
+ 	and hacked savagely by Mark Hessling
+
+**man-end**********************************************************************/
+
+
+/***********************************************************************/
+#if defined(HAVE_USLEEP)
+# ifdef HAVE_PROTO
+void	PDC_usleep(long wait)
+# else
+void	PDC_usleep(wait)
+long wait;
+# endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_usleep() - called\n");
+#endif
+	usleep(wait);
+	return;
+}
+/***********************************************************************/
+#elif defined(HAVE_POLL)
+#   include <poll.h>
+#   ifdef HAVE_PROTO
+void	PDC_usleep(long wait)
+#   else
+void	PDC_usleep(wait)
+long wait;
+#   endif
+/***********************************************************************/
+{
+	struct pollfd fd;
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_usleep() - called\n");
+#endif
+	poll(&fd,0L,min(1L,wait/1000));
+	return;
+}
+/***********************************************************************/
+#elif defined(PC)
+#  ifdef HAVE_PROTO
+void PDC_usleep(long wait)
+#  else
+void PDC_usleep(wait)
+long wait;
+#  endif
+/***********************************************************************/
+{
+	far long *ticks = MK_FP(0x0040, 0x006c);
+	long t1, t2;
+
+	wait /= 50;
+
+	if (!wait) {
+		wait++;
+	}
+
+	/*
+	 * get number of ticks,
+	 * since startup from
+	 * address 0040:006ch
+	 *
+	 * 1 sec. = 18.2065
+	 */
+
+	while (wait--) {
+		t1 = *ticks;
+
+		do {
+			t2 = *ticks;
+		} while (t1 == t2);
+	}
+}
+/***********************************************************************/
+# else
+#  ifdef HAVE_PROTO
+void	PDC_usleep(long wait)
+#  else
+void	PDC_usleep(wait)
+long wait;
+#  endif
+/***********************************************************************/
+{
+#ifndef WIN32
+	clock_t goal;
+#endif
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_usleep() - called\n");
+# endif
+
+#if defined(WIN32)
+	Sleep(wait);
+#else
+	goal = (clock_t)wait + clock();
+	while (goal > clock())
+	;
+#endif
+	return;
+}
+#endif
+
+#ifndef HAVE_VSSCANF
+/*
+ * Do not compile this module unless required.  This is due to the
+ * requirement of some compilers; at least Borland C++ 3.0, of having
+ * to link with math libraries due to the use of floats in the code.
+ *
+ * This module is based on vsscanf.c and input.c from emx 0.8f library
+ * source which is Copyright (c) 1990-1992 by Eberhard Mattes.
+ * Eberhard Mattes has kindly agreed to allow this module to be incorporated
+ * into PDCurses.
+ */
+
+/*man-start*********************************************************************
+
+  PDC_vsscanf()	- Internal routine to parse and format an input buffer.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Scan a series of input fields. Each field is formatted according to
+ 	a supplied format string and the formatted input is stored in the
+ 	variable number of addresses passed.
+
+  PDCurses Return Value:
+ 	This function returns the number of input fields or EOF on error.
+
+  PDCurses Errors:
+ 	If the supplied data is invalid or an incorrect number of arguments
+ 	are passed, EOF is returned as an error.
+
+  Portability:
+ 	PDCurses	int PDC_vsscanf(char *buf,const char *fmt,va_list arg_ptr);
+
+**man-end**********************************************************************/
+
+#define WHITE(x) ((x) == ' ' || (x) == '\t' || (x) == '\n')
+
+#define NEXT(x) \
+        do { \
+            x = *buf++; \
+            if (x == '\0') \
+               return (count == 0 ? EOF : count); \
+            ++chars; \
+           } while (0)
+
+#define UNGETC(x) \
+        do { \
+            --buf; *buf = x; --chars; \
+           } while (0)
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int PDC_vsscanf ( char *buf, const char *fmt, va_list arg_ptr)
+#else
+int PDC_vsscanf (buf,fmt,va_alist)
+char *buf;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+#if !defined(HAVE_STDARG_H_HAVE_PROTO)
+	va_list arg_ptr;
+#endif
+	int count, chars, c, width, radix, d, i;
+	int *int_ptr;
+	long *long_ptr;
+	short *short_ptr;
+	char *char_ptr;
+	unsigned char f;
+	char neg, assign, ok, size;
+	long n;
+	char map[256], end;
+	double dx, dd, *dbl_ptr;
+	float *flt_ptr;
+	int exp;
+	char eneg;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_vsscanf() - called\n");
+#endif
+
+#if 0
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(arg_ptr, fmt);
+# else
+	va_start(arg_ptr);
+# endif
+#else
+# if !defined(HAVE_STDARG_H_HAVE_PROTO)
+	va_start(arg_ptr);
+# endif
+#endif
+
+  count = 0; chars = 0; c = 0;
+  while ((f = *fmt) != 0)
+    {
+      if (WHITE (f))
+        {
+          do
+            {
+              ++fmt; f = *fmt;
+            } while (WHITE (f));
+          do
+            {
+              c = *buf++;
+              if (c == '\0')
+                {
+                  if (f == 0 || count != 0)
+                    return (count);
+                  else
+                    return (EOF);
+                }
+              else
+                ++chars;
+            } while (WHITE (c));
+          UNGETC (c);
+        }
+      else if (f != '%')
+        {
+          NEXT (c);
+          if (c != f)
+            return (count);
+          ++fmt;
+        }
+      else
+        {
+          assign = TRUE; width = INT_MAX;
+          char_ptr = NULL;
+          ++fmt;
+          if (*fmt == '*')
+            {
+              assign = FALSE;
+              ++fmt;
+            }
+          if (isdigit (*fmt))
+            {
+              width = 0;
+              while (isdigit (*fmt))
+                width = width * 10 + (*fmt++ - '0');
+              if (width == 0) width = INT_MAX;
+            }
+          size = 0;
+          if (*fmt == 'h' || *fmt == 'l')
+            size = *fmt++;
+          f = *fmt;
+          switch (f)
+            {
+            case 'c':
+              if (width == INT_MAX)
+                width = 1;
+              if (assign)
+                char_ptr = va_arg (arg_ptr, char *);
+              while (width > 0)
+                {
+                  --width;
+                  NEXT (c);
+                  if (assign)
+                    {
+                      *char_ptr++ = (char)c;
+                      ++count;
+                    }
+                }
+              break;
+            case '[':
+              (void)memset (map, 0, 256);
+              end = 0;
+              ++fmt;
+              if (*fmt == '^')
+                {
+                  ++fmt; end = 1;
+                }
+              i = 0;
+              for (;;)
+                {
+                  f = (unsigned char)*fmt;
+                  switch (f)
+                    {
+                    case 0:
+                      --fmt;       /* avoid skipping past 0 */
+                      NEXT (c);
+                      goto string;
+                    case ']':
+                      if (i > 0)
+                        {
+                          NEXT (c);
+                          goto string;
+                        }
+                      /* no break */
+                    default:
+                      if (fmt[1] == '-' && fmt[2] != 0 &&
+                          f < (unsigned char)fmt[2])
+                        {
+                          (void)memset (map+f, 1, (unsigned char)fmt[2]-f);
+                          fmt += 2;
+                        }
+                      else
+                        map[f] = 1;
+                      break;
+                    }
+                  ++fmt; ++i;
+                }
+            case 's':
+              (void)memset (map, 0, 256);
+              map[' '] = 1;
+              map['\n'] = 1;
+              map['\r'] = 1;
+              map['\t'] = 1;
+              end = 1;
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+string:
+              if (assign)
+                char_ptr = va_arg (arg_ptr, char *);
+              while (width > 0 && map[(unsigned char)c] != end)
+                {
+                  --width;
+                  if (assign)
+                    *char_ptr++ = (char)c;
+                  c = *buf++;
+                  if (c == '\0')
+                    break;
+                  else
+                    ++chars;
+                }
+              if (assign)
+                {
+                  *char_ptr = 0;
+                  ++count;
+                }
+              if (c == '\0')
+                return (count);
+              else
+                UNGETC (c);
+              break;
+            case 'f':
+            case 'e':
+            case 'E':
+            case 'g':
+            case 'G':
+              neg = ok = FALSE; dx = 0.0;
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+              if (c == '+')
+                {
+                  NEXT (c); --width;
+                }
+              else if (c == '-')
+                {
+                  neg = TRUE; NEXT (c); --width;
+                }
+              while (width > 0 && isdigit (c))
+                {
+                  --width;
+                  dx = dx * 10.0 + (double)(c - '0');
+                  ok = TRUE;
+                  c = *buf++;
+                  if (c == '\0')
+                    break;
+                  else
+                    ++chars;
+                }
+              if (width > 0 && c == '.')
+                {
+                  --width;
+                  dd = 10.0; NEXT (c);
+                  while (width > 0 && isdigit (c))
+                    {
+                      --width;
+                      dx += (double)(c - '0') / dd;
+                      dd *= 10.0;
+                      ok = TRUE;
+                      c = *buf++;
+                      if (c == '\0')
+                        break;
+                      else
+                        ++chars;
+                    }
+                }
+              if (!ok)
+                return (count);
+              if (width > 0 && (c == 'e' || c == 'E'))
+                {
+                  eneg = FALSE; exp = 0; NEXT (c); --width;
+                  if (width > 0 && c == '+')
+                    {
+                      NEXT (c); --width;
+                    }
+                  else if (width > 0 && c == '-')
+                    {
+                      eneg = TRUE; NEXT (c); --width;
+                    }
+                  if (!(width > 0 && isdigit (c)))
+                    {
+                      UNGETC (c);
+                      return (count);
+                    }
+                  while (width > 0 && isdigit (c))
+                    {
+                      --width;
+                      exp = exp * 10 + (c - '0');
+                      c = *buf++;
+                      if (c == '\0')
+                        break;
+                      else
+                        ++chars;
+                    }
+                  if (eneg) exp = -exp;
+                  while (exp > 0)
+                    {
+                      dx *= 10.0;
+                      --exp;
+                    }
+                  while (exp < 0)
+                    {
+                      dx /= 10.0;
+                      ++exp;
+                    }
+                }
+              if (assign)
+                {
+                  if (neg) dx = -dx;
+                  if (size == 'l')
+                    {
+                      dbl_ptr = va_arg (arg_ptr, double *);
+                      *dbl_ptr = dx;
+                    }
+                  else
+                    {
+                      flt_ptr = va_arg (arg_ptr, float *);
+                      *flt_ptr = (float)dx;
+                    }
+                  ++count;
+                }
+              if (c == '\0')
+                return (count);
+              else
+                UNGETC (c);
+              break;
+            case 'i':
+              neg = FALSE; radix = 10;
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+              if (!(width > 0 && c == '0'))
+                goto scan_complete_number;
+              NEXT (c); --width;
+              if (width > 0 && (c == 'x' || c == 'X'))
+                {
+                  NEXT (c); radix = 16; --width;
+                }
+              else if (width > 0 && (c >= '0' && c <= '7'))
+                radix = 8;
+              goto scan_unsigned_number;
+            case 'd':
+            case 'u':
+            case 'o':
+            case 'x':
+            case 'X':
+              do
+                {
+                  NEXT (c);
+                } while (WHITE (c));
+              switch (f)
+                {
+                case 'o':           radix = 8; break;
+                case 'x': case 'X': radix = 16; break;
+                default:            radix = 10; break;
+                }
+scan_complete_number:
+              neg = FALSE;
+              if (width > 0 && c == '+')
+                {
+                  NEXT (c); --width;
+                }
+              else if (width > 0 && c == '-' && radix == 10)
+                {
+                  neg = TRUE; NEXT (c); --width;
+                }
+scan_unsigned_number:
+              n = 0; ok = FALSE;
+              while (width > 0)
+                {
+                  --width;
+                  if (isdigit (c))
+                    d = c - '0';
+                  else if (isupper (c))
+                    d = c - 'A' + 10;
+                  else if (islower (c))
+                    d = c - 'a' + 10;
+                  else
+                    break;
+                  if (d < 0 || d >= radix)
+                    break;
+                  ok = TRUE;
+                  n = n * radix + d;
+                  c = *buf++;
+                  if (c == '\0')
+                    break;
+                  else
+                    ++chars;
+                }
+              if (!ok)
+                return (count);
+              if (assign)
+                {
+                  if (neg) n = -n;
+                  switch(size)
+                     {
+                      case 'h':
+                              short_ptr = va_arg (arg_ptr, short *);
+                              *short_ptr = (short)n;
+                              break;
+                      case 'l':
+                              long_ptr = va_arg (arg_ptr, long *);
+                              *long_ptr = (long)n;
+                              break;
+                      default:
+                              int_ptr = va_arg (arg_ptr, int *);
+                              *int_ptr = (int)n;
+                     }
+                  ++count;
+                }
+              if (c == '\0')
+                return (count);
+              else
+                UNGETC (c);
+              break;
+            case 'n':
+              if (assign)
+                {
+                  int_ptr = va_arg (arg_ptr, int *);
+                  *int_ptr = chars;
+                  ++count;
+                }
+              break;
+            default:
+              if (f == 0)                 /* % at end of string */
+                return (count);
+              NEXT (c);
+              if (c != f)
+                return (count);
+              break;
+            }
+          ++fmt;
+        }
+    }
+  return (count);
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_breakout()	- check for type-ahead
+
+  X/Open Description:
+ 	The curses package does the "line-breakout optimisation" by
+ 	looking for type-ahead periodically while updating the screen.
+ 	If input is found, the current update will be postponed until
+ 	refresh() or doupdate() are called again.  This allows faster
+ 	response to commands typed in advance.  Normally, the input FILE
+ 	pointer passed to newterm(), or stdin in the case when initscr()
+ 	was called, will be used to do this type-ahead checking.  This routine
+ 	will do the actual check for PDcurses to see if input is pending.
+
+  PDCurses Description:
+ 	This routine does what the PDcurses typeahead routine used to do.  But
+ 	to make that routine consistent with its System V counterpart, all it
+ 	does now is set whether or not typeahead checking is performed.
+
+  X/Open Return Value:
+ 	The PDC_breakout() routine returns TRUE if keyboard input is pending
+ 	otherwise FALSE is returned.
+
+  Portability:
+ 	PDCurses	bool PDC_breakout( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_breakout( void )
+#else
+bool	PDC_breakout()
+#endif
+/***********************************************************************/
+{
+extern	int	c_pindex;			/* putter index */
+extern	int	c_gindex;			/* getter index */
+extern	int	c_ungind;			/* wungetch() push index */
+	bool	rc;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_breakout() - called\n");
+#endif
+
+	/* ungotten or buffered char */
+	rc = (c_ungind) || (c_pindex > c_gindex);
+
+	if (!rc)
+		rc = PDC_check_bios_key();
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_breakout() - returned: %d c_ungind: %d c_pindex: %d c_gindex: %d\n",rc,c_ungind,c_pindex,c_gindex);
+#endif
+	return rc;
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/pdcwin.c stsgdb-6.8/pdcurses/pdcurses/pdcwin.c
--- gdb-6.8/pdcurses/pdcurses/pdcwin.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/pdcwin.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,1128 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif
+
+#ifndef HAVE_MEMMOVE
+# define memmove PDC_memmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCwin  = "$Id: pdcwin.c,v 1.8 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_copy_win()  - Common routine for copywin(), overlay() and overwrite()
+    functions.
+
+  PDCurses Description:
+    This function copies the region of the source window specified
+    over the specified region of the destination window. All validation
+    of limits are done by the calling function.
+
+    Thanks to Andreas Otte (venn@uni-paderborn.de) for the code changes.
+
+  PDCurses Errors:
+    ERR is returned if either src or dst windows are NULL;
+
+  Portability:
+    PDCurses int   PDC_copy_win( const WINDOW* src_w, WINDOW* dst_w
+         int src_tr,int src_tc,int src_br,int src_bc,
+         int dst_tr,int dst_tc,int dst_br,int dst_bc,bool overlay);
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_copy_win(const WINDOW *src_w, WINDOW *dst_w,int src_tr,int src_tc,int
+   src_br,int src_bc,int dst_tr,int dst_tc,int dst_br,int dst_bc,bool overlay)
+#else
+int PDC_copy_win(src_w,dst_w,src_tr,src_tc,src_br,src_bc,dst_tr,dst_tc,dst_br,dst_bc,overlay)
+WINDOW *src_w;
+WINDOW *dst_w;
+int src_tr;
+int src_tc;
+int src_br;
+int src_bc;
+int dst_tr;
+int dst_tc;
+int dst_br;
+int dst_bc;
+bool overlay;
+#endif
+/***********************************************************************/
+{
+   register int fc;
+   register int lc=0;
+   int*  minchng;
+   int*  maxchng;
+   chtype*  w1ptr;
+   chtype*  w2ptr;
+   int   col;
+   int   line;
+   int   xdiff = src_bc - src_tc;
+   int   ydiff = src_br - src_tr;
+   int   y1;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_copy_win() - called\n");
+#endif
+
+   if (src_w == (WINDOW *)NULL)  return( ERR );
+   if (dst_w == (WINDOW *)NULL)  return( ERR );
+
+   minchng = dst_w->_firstch;
+   maxchng = dst_w->_lastch;
+
+
+   for (y1 = 0; y1 < dst_tr; y1++)
+   {
+      minchng++;
+      maxchng++;
+   }
+
+   for (line = 0; line < ydiff; line++)
+   {
+
+      w1ptr = src_w->_y[line+src_tr]+src_tc;
+      w2ptr = dst_w->_y[line+dst_tr]+dst_tc;
+      fc    = _NO_CHANGE;
+
+      for (col = 0; col < xdiff; col++)
+      {
+         if ((*w1ptr) != (*w2ptr)
+         &&  !((*w1ptr & A_CHARTEXT) == src_w->_blank && overlay))
+         {
+            *w2ptr = *w1ptr;
+            if (fc == _NO_CHANGE)
+            {
+               fc = col+dst_tc;
+            }
+            lc = col+dst_tc;
+         }
+         w1ptr++;
+         w2ptr++;
+      }
+
+      if (*minchng == _NO_CHANGE)
+      {
+         *minchng = fc;
+         *maxchng = lc;
+      }
+      else  if (fc != _NO_CHANGE)
+      {
+         if (fc < *minchng)   *minchng = fc;
+         if (lc > *maxchng)   *maxchng = lc;
+      }
+      minchng++;
+      maxchng++;
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_makenew()   - Create a WINDOW* (sans line allocation)
+
+  PDCurses Description:
+    This is a private PDCurses routine.
+
+    Allocates all data for a new WINDOW* except the actual lines
+    themselves.
+
+  PDCurses Return Value:
+    This function returns a valid WINDOW* on success and NULL on error.
+
+  PDCurses Errors:
+    If PDC_makenew() is unable to allocate memory for the window
+    structure, it will free all allocated memory and return
+    a NULL pointer.
+
+  Portability:
+    PDCurses WINDOW* PDC_makenew( int num_lines, int num_columns,
+                int begy, int begx );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW* PDC_makenew(int num_lines, int num_columns, int begy, int begx)
+#else
+WINDOW* PDC_makenew(num_lines,num_columns,begy,begx)
+int num_lines;
+int num_columns;
+int begy;
+int begx;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern   void* (*mallc)( size_t );
+extern   void* (*callc)( size_t, size_t );
+extern   void  (*fre)( void* );
+#else
+extern   void* (*mallc)();
+extern   void* (*callc)();
+extern   void  (*fre)();
+#endif
+
+   short i;
+   WINDOW *win=NULL;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_makenew() - called: lines %d cols %d begy %d begx %d\n",num_lines,num_columns,begy,begx);
+#endif
+
+   /*
+   *  Use the standard runtime malloc/calloc package or use
+   *  the user's emalloc/ecalloc package.
+   *
+   *  Allocate the window structure itself
+   */
+   if ((win = (*mallc)(sizeof(WINDOW))) == (WINDOW *)NULL)
+   {
+      return( win );
+   }
+   /*
+    * Set all fields to zero
+    */
+   memset( win, 0, sizeof(WINDOW) );
+
+   /*
+   * allocate the line pointer array
+   */
+   if ((win->_y = (*callc)(num_lines, sizeof(chtype *))) == NULL)
+   {
+      (*fre)(win);
+      return( (WINDOW *)NULL );
+   }
+
+   /*
+   * allocate the minchng and maxchng arrays
+   */
+   if ((win->_firstch = (*callc)(num_lines, sizeof(int))) == NULL)
+   {
+      (*fre)(win->_y);
+      (*fre)(win);
+      return( (WINDOW *)NULL );
+   }
+   if ((win->_lastch = (*callc)(num_lines, sizeof(int))) == NULL)
+   {
+      (*fre)(win->_firstch);
+      (*fre)(win->_y);
+      (*fre)(win);
+      return( (WINDOW *)NULL );
+   }
+
+   /*
+   * initialize window variables
+   */
+#if 0 /* these set to zero/NULL by memset() above */
+   win->_curx = 0;
+   win->_cury = 0;
+   win->_lastpy = 0;
+   win->_lastpx = 0;
+   win->_lastsy1 = 0;
+   win->_lastsx1 = 0;
+   win->_flags = 0;
+   win->_attrs = 0;     /* No attributes */
+   win->_delayms = 0;
+   win->_leaveit = FALSE;
+   win->_scroll = FALSE;
+   win->_nodelay = FALSE;
+   win->_immed = FALSE;
+   win->_sync = FALSE;
+   win->_use_keypad = FALSE;
+   win->_use_idl = FALSE;
+   win->_tmarg = 0;
+   win->_title = NULL;
+   win->_parent = NULL;
+#endif
+   win->_maxy = num_lines;    /* real max screen size */
+   win->_maxx = num_columns;  /* real max screen size */
+   win->_pmaxy = num_lines;   /* real max window size */
+   win->_pmaxx = num_columns; /* real max window size */
+   win->_begy = begy;
+   win->_begx = begx;
+   win->_lastsy2 = LINES-1;
+   win->_lastsx2 = COLS-1;
+   win->_bkgd = ' '; /* wrs 4/10/93 -- initialize background to blank */
+   win->_tabsize = 8;
+   win->_clear = (bool) ((num_lines == LINES) && (num_columns == COLS));
+   win->_use_idc = TRUE;
+   win->_bmarg = num_lines - 1;
+   win->_title_ofs = 1;
+   win->_title_attr = win->_attrs;
+   win->_blank = ' ';
+   win->_parx = win->_pary = -1;
+   /*
+   * init to say window unchanged
+   */
+   for (i = 0; i < num_lines; i++)
+   {
+      win->_firstch[i] = 0;
+      win->_lastch[i] = num_columns - 1;
+   }
+
+   /*
+   * set flags for window properties
+   */
+   if ((begy + num_lines) == LINES)
+   {
+      win->_flags |= _ENDLINE;
+      if ((begx == 0) &&
+          (num_columns == COLS) &&
+          (begy == 0))
+      {
+         win->_flags |= _FULLWIN;
+      }
+   }
+
+   if (((begy + num_lines) == LINES) &&
+       ((begx + num_columns) == COLS))
+   {
+      win->_flags |= _SCROLLWIN;
+   }
+   return( win );
+}
+
+/*man-start*********************************************************************
+
+  PDC_sync()   - Cause window synchronisation to occur
+
+  PDCurses Description:
+    This is a private PDCurses routine, NOT to be called by an application.
+
+    Handles wrefresh() and wsyncup() calls when a window is changed.
+
+  PDCurses Return Value:
+    This function returns void.
+
+  PDCurses Errors:
+
+  Portability:
+    PDCurses WINDOW* PDC_sync( WINDOW *win );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void PDC_sync(WINDOW *win)
+#else
+void PDC_sync(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_sync() - called:\n");
+#endif
+
+   if (win->_immed)
+      wrefresh(win);
+   if (win->_sync)
+      wsyncup(win);
+   return;
+}
+
+/*man-start*********************************************************************
+
+  PDC_backchar()  - Visually erase character in window
+
+  PDCurses Description:
+    This is a private PDCurses function
+
+    This routine will visually erase a character.  It is called by
+    the PDCurses character I/O routines.
+
+  PDCurses Return Value:
+    This routine will return OK upon success and otherwise ERR will be
+    returned.
+
+  PDCurses Errors:
+    It is an error to pass a NULL WINDOW pointer.
+
+  Portability:
+    PDCurses int   PDC_backchar( WINDOW* w, char* ch, int* len );
+
+**man-end**********************************************************************/
+
+#ifdef THESE_FUNCTIONS_ARENT_USED
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_backchar(WINDOW *w, char *ch, int *len)
+#else
+int PDC_backchar(w,ch,len)
+WINDOW *w;
+char *ch;
+int *len;
+#endif
+/***********************************************************************/
+{
+   int   nbs = 0;
+   int   x = w->_curx;
+   int   ts = w->_tabsize;
+   chtype   s = (w->_y[w->_cury][x - 1] & CHR_MSK);
+   char* p = c_strbeg;
+   bool  save_raw_out = SP->raw_out;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_backchar() - called\n");
+#endif
+
+   if (w == (WINDOW *)NULL)
+      return( ERR );
+
+   (*len)--;      /* Now we are zero relative */
+   (*len)--;      /* Now we are looking at the previous
+             * character */
+   if( *len >= 0 )
+   {
+      nbs++;
+      /*
+       * Determine number of characters to erase...
+       */
+      if ((ch[*len] < ' ') || (s == 0x7f))   /* ctrl-char has size 2  */
+      {
+         nbs++;
+         (*len)--;
+      }
+
+      if( *len >= 0 )
+      {
+         if (ch[*len] == '\t')   /* tabs are very special */
+         {
+            for (; p < ch; p++)
+            {
+               if (*p == '\t')
+                  x = ((x / ts) + 1) * ts;
+               else
+               {
+                  if ((*p < ' ') || (*p == 0x7f))
+                     x += 2;
+                  else
+                     x++;
+               }
+               if (x >= w->_maxx)   /* go to next line? */
+                  x = 0;
+            }
+            if (!(w->_curx))
+               nbs = w->_maxx - x;
+            else
+               nbs = w->_curx - x;
+         }
+      }
+   }
+   if( *len < 0 )
+   {
+      beep();
+      *len = 0;
+   }
+   /*
+    * Erase the characters and update...
+    */
+   SP->raw_out = FALSE;  /* ensure backspace handled in xlat mode */
+   while ( nbs-- > 0 )
+   {
+      if (w->_curx > 0)
+      {
+/*       waddstr(w, "\b \b");*/
+         mvwaddch(w, w->_cury, w->_curx-1, ' ');
+         wmove(w, w->_cury, w->_curx-1);
+      }
+      else
+      if (w->_cury)
+      {
+         mvwaddch(w, w->_cury - 1, w->_maxx - 1, ' ');
+         wmove(w, w->_cury - 1, w->_maxx - 1);
+      }
+   }
+   ch[*len] = '\0';
+   SP->raw_out = save_raw_out;
+   wrefresh(w);
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_chg_attr_pair()   - Writes character and attribute to physical screen
+
+  PDCurses Description:
+    This is a private PDCurses function.
+
+    Writes a single character 'chr' with attribute 'attr' to the
+    current cursor location.
+
+    NOTE: Though passed as 16 bit quantities, only the lower 8 bits
+      will be used to create a character/attribute pair.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    No errors are defined for this function under DOS.
+
+    An ERR may be returned under FLEXOS if s_copy() fails.  See the
+    Flexos Programmer's Reference Manual for details on the error.
+
+  Portability:
+    PDCurses int PDC_chg_attr_pair( chtype chr, chtype attr );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_chg_attr_pair(chtype chr, chtype attr)
+#else
+int PDC_chg_attr_pair(chr,attr)
+chtype chr;
+chtype attr;
+#endif
+/***********************************************************************/
+{
+   extern unsigned   char atrtab[MAX_ATRTAB];
+   int   phys_attr=chtype_attr(attr);
+
+#ifdef   OS2
+# ifdef  EMXVIDEO
+   int curCol, curRow,cell;
+# else
+   USHORT curCol, curRow, cell;
+# endif
+#endif
+
+#ifdef   FLEXOS
+   UBYTE c = (UBYTE) chr;
+   UBYTE a = (UBYTE) phys_attr;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chg_attr_pair() - called\n");
+#endif
+
+#ifdef   FLEXOS
+   drect.r_row = PDC_get_cur_row();
+   drect.r_col = PDC_get_cur_col();
+   drect.r_nrow = 1;
+   drect.r_ncol = 1;
+
+   sframe.fr_pl[0] = (UBYTE *) & c;
+   sframe.fr_pl[1] = (UBYTE *) & a;
+   sframe.fr_pl[2] = (UBYTE *) " ";
+   sframe.fr_nrow = 1;
+   sframe.fr_ncol = 1;
+   sframe.fr_use = 0x00;
+
+   srect.r_col = 0;
+   srect.r_row = 0;
+   srect.r_nrow = 1;
+   srect.r_ncol = 1;
+
+   retcode = s_copy(0x03, 0x01L, 0L, (far unsigned short *) &drect, (far unsigned short *) &sframe, (far unsigned short *) &srect);
+   return( (retcode < 0L) ? ERR : OK );
+#endif
+
+#ifdef   DOS
+   regs.h.ah = 0x09;
+   regs.h.al = chr & A_CHARTEXT;
+   regs.h.bh = SP->video_page;
+   regs.h.bl = (char)(phys_attr >> 8);
+# ifdef WATCOMC
+   regs.w.cx = 0x01;
+# else
+   regs.x.cx = 0x01;
+# endif
+   int86(0x10, &regs, &regs);
+   return( OK );
+#endif
+
+#ifdef   OS2
+   /* find the current cursor position */
+# ifdef EMXVIDEO
+   cell = (int)((chr & A_CHARTEXT) | phys_attr);
+   v_getxy (&curCol, &curRow);
+   v_putline ((char*)&cell, curCol, curRow, 1);
+# else
+   cell = (USHORT)((chr & A_CHARTEXT) | phys_attr);
+   VioGetCurPos((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
+   VioWrtNCell((PBYTE)&cell,1,curRow,curCol,0);
+# endif
+   return( OK );
+#endif
+
+#ifdef UNIX
+/* INCOMPLETE - check attribute and output attr and/or color */
+   putchar(chr & A_CHARTEXT);
+   return(OK);
+#endif
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_chadd()      - Low level; Put a character to a window
+
+  PDCurses Description:
+    This is a private PDCurses function.
+
+    This routine will insert the character 'c' at the current cursor
+    position in the passed window.
+
+    If 'xlat' is TRUE, PDC_chadd() will handle things in a cooked
+    manner (tabs, newlines, carriage returns, etc).  If 'xlat' is
+    FALSE, the characters are simply output directly.
+
+    If 'advance' is TRUE, PDC_chadd() will move the current cusor position
+    appropriately. The *addch functions call PDC_chadd() with advance TRUE,
+    while the *insch functions call PDC_chadd() with advance FALSE.
+
+    The normal curses routines (non-raw-output-mode) call PDC_chadd()
+    with 'xlat' TRUE.
+
+    If an alternate character is to be displayed, the character is
+    displayed without translation (minus the A_ALTCHARSET of course).
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    It is an error to call this function with a NULL window pointer.
+
+  Portability:
+    PDCurses        int PDC_chadd( WINDOW* win, chtype ch, bool xlat, bool advance );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL PDC_chadd(register WINDOW *win, chtype ch,bool xlat, bool advance)
+#else
+int PDC_CDECL PDC_chadd(win,ch,xlat,advance)
+register WINDOW *win;
+chtype ch;
+bool xlat;
+bool advance;
+#endif
+/***********************************************************************/
+{
+   int   retval = ERR;
+   int   x;
+   int   y;
+   int   newx;
+   chtype   attr=0, bktmp;
+   int   ts;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chadd() - called: win=%x ch=%x (char=%c attr=0x%x) xlat=%d advance=%d\n",win,ch,ch & A_CHARTEXT,ch & A_ATTRIBUTES,xlat,advance);
+#endif
+
+   if (win  == (WINDOW *)NULL)
+      return(  retval );
+
+   x  = win->_curx;
+   y  = win->_cury;
+   ts = win->_tabsize;
+
+   /*
+    * Remove any A_ALTCHASET attribute from the ch before any further
+    * testing. If the character has A_ALTCHARSET, set xlat to FALSE.
+    */
+   if (ch & A_ALTCHARSET)
+   {
+      xlat = FALSE;
+      ch = ch & (~A_ALTCHARSET);
+   }
+   /*
+    * if the incoming character doesn't have its own attribute
+    * then  use the  current  attributes for the window.
+    * if the incoming character has attributes but not a colour
+    * component, or the attributes  to the current attributes
+    * for the window.
+    * if the incoming character has a colour component use  the
+    * attributes solely from the incoming character
+    */
+
+   if ((ch  & A_ATTRIBUTES)   == 0)
+      attr  = win->_attrs;
+   else
+   {
+      if ((ch & A_COLOR) == 0)
+         attr = (ch & A_ATTRIBUTES) | win->_attrs;
+      else
+         attr = (ch & A_ATTRIBUTES);
+   }
+
+   ch = (ch &  A_CHARTEXT);
+
+   /*  wrs (4/10/93) */
+   /*  apply the same sort of logic for the window background, in that it only */
+   /*  takes precedence if other color attributes are not there and that */
+   /*  the background character will only print if the printing character is */
+   /*  blank. */
+
+   if ((attr & A_COLOR) == 0)
+      attr = (attr | (win->_bkgd & A_ATTRIBUTES));
+   else
+   {
+      bktmp = (win->_bkgd & A_COLOR);
+      attr = (attr | ( (win->_bkgd & A_ATTRIBUTES) ^ bktmp ));
+   }
+
+   if ( ch == ' ' )
+      ch = ((win->_bkgd & A_CHARTEXT));
+
+
+   if ((y > win->_maxy) ||
+       (x > win->_maxx) ||
+       (y < 0) ||
+       (x < 0))
+   {
+      return(  retval );
+   }
+
+   if (xlat)
+   {
+      switch (ch)
+      {
+         case '\t':
+            for (newx = ((x   / ts) +  1) * ts; x < newx; x++)
+            {
+               if (waddch(win,   ' ') ==  ERR)
+               {
+                  PDC_sync(win);
+                  return(  retval );
+               }
+               /*
+                * if tab to next line
+                */
+               if (win->_curx == 0)
+               {
+                  /*
+                   * exit  the loop
+                   */
+                  PDC_sync(win);
+                  return(  OK );
+               }
+            }
+            PDC_sync(win);
+            return(  OK );
+
+         case '\n':
+            if (SP->autocr && !(SP->raw_out))
+            {
+               /*
+                * if lf -> crlf
+                */
+               x = 0;
+            }
+            wclrtoeol( win );
+            if ((y = PDC_newline(win, y)) < 0)
+            {
+               PDC_sync(win);
+               return(  retval );
+            }
+            if (advance)
+            {
+               win->_cury =   y;
+               win->_curx =   x;
+            }
+            PDC_sync(win);
+            return(  OK );
+
+         case '\r':
+            if (advance)
+               win->_curx =   x = 0;
+            PDC_sync(win);
+            return(  OK );
+
+         case '\b':
+            if (--x  < 0)
+            {
+               /*
+                * no back over   left margin
+                */
+               x = 0;
+            }
+            if (advance)
+               win->_curx =   x;
+            PDC_sync(win);
+            return(  OK );
+
+         case 0x7f:
+            if (waddch(win,   '^') ==  ERR)
+            {
+               PDC_sync(win);
+               return(  retval );
+            }
+            retval = waddch(win, '?');
+            PDC_sync(win);
+            return(  retval );
+
+         default:
+            break;
+      }     /* switch */
+
+      if (ch < ' ')
+      {
+         /*
+          * handle control chars
+          */
+         if (waddch(win,   '^') ==  ERR)
+         {
+            PDC_sync(win);
+            return(  retval );
+         }
+
+         retval = (waddch(win, ch + '@'));
+         PDC_sync(win);
+         return(  retval );
+      }
+   }
+
+   /*
+    * Add the  attribute back into the character.
+    */
+   ch |= attr;
+   /*********************************************************************/
+   /* only change _firstch/_lastch if character to be added is different */
+   /* to the character/attribute that is already in that position in the */
+   /* window.                                                            */
+   /* Removing this fixes display problems with different windows in the */
+   /* same physical position. MH 20-03-93                                */
+   /* Restored again.         MH 02-04-93                                */
+   /*********************************************************************/
+   if (win->_y[y][x] != ch)
+   {
+      /*
+       * only  if data  change
+       */
+      if (win->_firstch[y] == _NO_CHANGE)
+      {
+         win->_firstch[y] = win->_lastch[y] = x;
+      }
+      else
+      {
+         if (x <  win->_firstch[y])
+         {
+            win->_firstch[y] = x;
+         }
+         else
+         {
+            if (x >  win->_lastch[y])
+            {
+               win->_lastch[y] = x;
+            }
+         }
+      }
+   }
+   win->_y[y][x++] = ch;
+   if (x >= win->_maxx)
+   {
+      /*
+       * wrap  around test
+       */
+      x = 0;
+      if ((y = PDC_newline(win, y)) < 0)
+      {
+         PDC_sync(win);
+         return(  retval );
+      }
+   }
+   if (advance)
+   {
+      win->_curx =   x;
+      win->_cury =   y;
+   }
+   PDC_sync(win);
+   return(  OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_chg_attrs() - Change attributes in a rectangle
+
+  PDCurses Description:
+    This routine will change the attribute(s) from a starting (y,x)
+    position to an ending (y,x) position to the specified attribute.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    It is an error to call this function with a NULL window pointer.
+    It is also an error to pass rectangular coordinates that lay
+    outside of window.
+
+  Portability:
+    PDCurses int PDC_chg_attrs( WINDOW* w, chtype attr,
+               int sy, int sx,
+               int ey, int ex );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_chg_attrs(WINDOW *win, chtype attr, int sy, int sx, int ey, int ex)
+#else
+int PDC_chg_attrs(win,attr,sy,sx,ey,ex)
+WINDOW *win;
+chtype attr;
+int sy;
+int sx;
+int ey;
+int ex;
+#endif
+/***********************************************************************/
+{
+   chtype   oldattr = win->_attrs;
+   int   c;
+   int   l;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chr_attrs() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)    return( ERR );
+   if (sy > win->_maxy) return( ERR );
+   if (sx > win->_maxx) return( ERR );
+   if (ey >= win->_maxy)   ey = win->_maxy - 1;
+   if (ex >= win->_maxx)   ex = win->_maxx - 1;
+
+   wattrset(win, attr);
+   for (l = sy; l <= ey; l++)
+   {
+      for (c = sx; c <= ex; c++)
+         win->_y[l][c] = (win->_y[l][c] & A_CHARTEXT) | attr;
+
+      if (win->_firstch[l] == _NO_CHANGE)
+      {
+         win->_firstch[l] = sx;
+         win->_lastch[l] = ex;
+      }
+      else if (win->_firstch[l] != _NO_CHANGE)
+      {
+         if (sx < win->_firstch[l])
+            win->_firstch[l] = sx;
+         if (ex > win->_lastch[l])
+            win->_lastch[l] = ex;
+      }
+   }
+   win->_attrs = oldattr;
+   PDC_sync(win);
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_chins()  - Low-level insert character in window
+
+  PDCurses Description:
+    This is a private PDCurses routine.
+
+    This routine provides the basic functionality for the X/Open
+    [mv][w]insch() routines.  The xlat flag indicates that normal
+    character translation is performed or not.  If not, then the
+    character is output as is.
+
+    The 'xlat' flag is TRUE for the normal curses routines.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    It is an error to call this function with a NULL window pointer.
+
+  Portability:
+    PDCurses int PDC_chins( WINDOW* win, chtype c, bool xlat );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_chins(WINDOW *win, chtype c, bool xlat)
+#else
+int PDC_chins(win,c,xlat)
+WINDOW *win;
+chtype c;
+bool xlat;
+#endif
+/***********************************************************************/
+{
+   int   retval = ERR;
+   int   x;
+   int   y;
+   int   maxx;
+   int   offset;
+   chtype *temp1;
+   char  ch = (c & A_CHARTEXT);
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_chins() - called: win=%x ch=%x (char=%c attr=0x%x) xlat=%d\n",win,ch,ch & A_CHARTEXT,ch & A_ATTRIBUTES,xlat);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( retval );
+
+   x  = win->_curx;
+   y  = win->_cury;
+   maxx  = win->_maxx;
+   offset   = 1;
+   temp1 = &win->_y[y][x];
+
+   if ((ch < ' ') && xlat)
+   {
+      offset++;
+   }
+
+   memmove( temp1+offset, temp1, (maxx - x -offset) * sizeof(chtype) );
+
+   win->_lastch[y] = maxx-1;
+
+   if ((win->_firstch[y] == _NO_CHANGE) ||
+       (win->_firstch[y] > x))
+   {
+      win->_firstch[y] = x;
+   }
+   /*
+    * PDC_chadd() fixes CTRL-chars too
+    */
+   retval = (PDC_chadd(win, c, xlat,FALSE));
+   return( retval );
+}
+
+/*man-start*********************************************************************
+
+  PDC_clr_scrn()  - Clears the physical screen and homes the cursor.
+
+  PDCurses Description:
+    This is an internal routine called by the doupdate() routines.
+
+  PDCurses Return Value:
+    This routine always returns OK.
+
+  Portability:
+    PDCurses int PDC_clr_scrn( WINDOW* win );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_clr_scrn(WINDOW *win)
+#else
+int PDC_clr_scrn(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#if !defined(XCURSES)
+# if defined(UNIX_WCLR)
+   chtype   attrs = win->_attrs;
+# else
+   chtype   attrs = win->_bkgd;
+# endif
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_clr_scrn() - called\n");
+#endif
+
+#if defined(XCURSES)
+   XCursesInstruct(CURSES_CLEAR);
+#else
+   PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, attrs);
+   PDC_gotoxy(0, 0);
+#endif
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_newline()   - Advances 1 newline from supplied line number.
+
+  PDCurses Description:
+    This is a private PDCurses routine.
+
+    Does line advance and returns the new cursor line.  If error,
+    return -1.
+
+  PDCurses Return Value:
+    This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+    No errors are defined for this function.
+
+  Portability:
+    PDCurses int PDC_newline( WINDOW* win, int lin );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_newline(WINDOW *win, int lin)
+#else
+int PDC_newline(win,lin)
+WINDOW *win;
+int lin;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_newline() - called: line %d\n",lin);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( -1 );
+
+   if (++lin > win->_bmarg)
+   {
+      lin--;
+      if (win->_scroll)
+      {
+         scroll(win);
+
+         /* wrs -- 7/11/93 ** it seems that System V Curses automatically refreshes
+          *                   a window when scrolling occurs via a newline.  This
+          *                   could be a feature that isn't intended, but I'll
+          *                   implement it here as well for consistency.
+          * fh -- 7/30/99 ** but it causes problems with panels -- a lower panel
+          *                  might be refreshed without updating the obscuring
+          *                  parts of other panels.
+          */
+         /*         wrefresh(win); */
+      }
+      else
+         return( -1 );
+   }
+   return( lin );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/printw.c stsgdb-6.8/pdcurses/pdcurses/printw.c
--- gdb-6.8/pdcurses/pdcurses/printw.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/printw.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,248 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	printw
+#undef	wprintw
+#undef	mvprintw
+#undef	mvwprintw
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	waddstr
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_printw  = "$Id: printw.c,v 1.1 2001/01/10 08:27:24 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        printw
+
+  Synopsis:
+  	int printw(char *fmt, ...);
+  	int wprintw(WINDOW *win, char *fmt, ...);
+  	int mvprintw(int y, int x, char *fmt, ...);
+  	int mvwprintw(WINDOW *win, int y, int x, char *fmt,...);
+  ***	int vwprintw(WINDOW *win, char *fmt, va_list varglist);
+
+  X/Open Description:
+ 	The printw() routine adds a string to the default window
+ 	starting at the current cursor position.  This routine causes
+ 	the string that would normally be output by printf() to be
+ 	output by addstr().
+
+ 	The routine wprintw() adds a string to the specified window
+ 	starting at the current cursor position.  This routine causes
+ 	the string that would normally be output by printf() to be
+ 	output by waddstr().
+
+ 	The routine mvprintw() adds a string to the default window
+ 	starting at the specified cursor position.  This routine
+ 	causes the string that would normally be output by printf() to
+ 	be output by addstr().
+
+ 	The routine mvwprintw() adds a string to the specified window
+ 	starting at the specified cursor position.  This routine
+ 	causes the string that would normally be output by printf() to
+ 	be output by waddstr().
+
+ 	All these routines are analogous to printf().  It is advisable
+ 	to use the field width options of printf() to avoid leaving
+ 	unwanted characters on the screen from earlier calls.
+
+  PDCurses Description:
+ 	The old Bjorn Larssen code for the 68K platform has been removed
+ 	from this module.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      printw                                Y        Y       Y
+      wprintw                               Y        Y       Y
+      mvprintw                              Y        Y       Y
+      mvwprintw                             Y        Y       Y
+      vwprintw                              -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	printw(char *fmt,...)
+#else
+int	PDC_CDECL	printw(fmt,va_alist)
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("printw() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return (retval);
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+	if (waddstr(stdscr, c_printscanbuf) == ERR)
+		return (retval);
+	retval = (strlen(c_printscanbuf));
+	return (retval);
+}
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	wprintw(WINDOW *win,char *fmt,...)
+#else
+int	PDC_CDECL	wprintw(win,fmt,va_alist)
+WINDOW *win;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wprintw() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (retval);
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+	if (waddstr(win, c_printscanbuf) == ERR)
+		return (retval);
+	retval = (strlen(c_printscanbuf));
+	return (retval);
+}
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvprintw(int y, int x,char *fmt,...)
+#else
+int	PDC_CDECL	mvprintw(y,x,fmt,va_alist)
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvprintw() - called\n");
+#endif
+
+	if (stdscr == (WINDOW *)NULL)
+		return (retval);
+
+	if (wmove(stdscr, y, x) == ERR)
+		return( retval );
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+
+	if (waddstr(stdscr, c_printscanbuf) == ERR)
+		return( retval );
+	retval = (strlen(c_printscanbuf));
+	return( retval );
+}
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvwprintw(WINDOW *win,int y, int x,char *fmt,...)
+#else
+int	PDC_CDECL	mvwprintw(win,y,x,fmt,va_alist)
+WINDOW *win;
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	int	retval = ERR;
+	va_list args;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwprintw() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return (retval);
+	if (wmove(win, y, x) == ERR)
+		return( retval );
+
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	vsprintf(c_printscanbuf, fmt, args);
+	va_end(args);
+
+	if (waddstr(win, c_printscanbuf) == ERR)
+		return (retval);
+	retval = (strlen(c_printscanbuf));
+	return (retval);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/README stsgdb-6.8/pdcurses/pdcurses/README
--- gdb-6.8/pdcurses/pdcurses/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/README	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,13 @@
+
+                        Welcome to PDCurses
+
+ Contents
+ --------
+ This directory contains core PDCurses source code files generic to
+ all platforms.
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory are released to the Public Domain.
diff -Naur gdb-6.8/pdcurses/pdcurses/refresh.c stsgdb-6.8/pdcurses/pdcurses/refresh.c
--- gdb-6.8/pdcurses/pdcurses/refresh.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/refresh.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,394 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   refresh
+#undef   wrefresh
+#undef   wnoutrefresh
+#undef   doupdate
+#undef   redrawwin
+#undef   wredrawln
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef wattrset
+#  undef mvwprintw
+#  undef wmove
+#  undef wattrset
+#  undef touchwin
+#  undef reset_prog_mode
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_refresh  = "$Id: refresh.c,v 1.4 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       refresh
+
+  Synopsis:
+   int   refresh(void);
+   int   wrefresh(WINDOW *win);
+   int   wnoutrefresh(register WINDOW *win);
+   int   doupdate(void);
+   int   redrawwin(WINDOW *win);
+   int   wredrawln(WINDOW *win, int beg_line, int num_lines);
+
+  X/Open Description:
+   The routine wrefresh() copies the named window to the physical
+   terminal screen, taking into account what is already there in
+   order to optimize cursor movement.
+   The routine refresh() does the same, using stdscr as a default
+   screen.
+   These routines must be called to get any output on the
+   terminal, as other routines only manipulate data structures.
+   Unless leaveok has been enabled, the physical cursor of the
+   terminal is left at the location of the window's cursor.
+
+   The wnoutrefresh() and doupdate() routines allow multiple updates
+   with more efficiency than wrefresh() alone.  In addition to all 
+   of the window structures representing the terminal screen: a physical
+   screen, describing what is actually on the screen and a virtual screen,
+   describing what the programmer wants to have on the screen.
+
+   The wrefresh() function works by first calling wnoutrefresh(),
+   which copies the named window to the virtual screen.  It then
+   calls doupdate(), which compares the virtual screen to the
+   physical screen and does the actual update.  If the programmer
+   wishes to output several windows at once, a series of cals to
+   wrefresh() will result in alternating calls to wnoutrefresh()
+   and doupdate(), causing several bursts of output to the
+   screen.  By first calling wnoutrefresh() for each window, it
+   is then possible to call doupdate() once.  This results in
+   only one burst of output, with probably fewer total characters
+   transmitted and certainly less CPU time used.
+
+  X/Open Return Value:
+   All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+   No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      refresh                               Y        Y       Y
+      wrefresh                              Y        Y       Y
+      wnoutrefresh                          Y        Y       Y
+      doupdate                              Y        Y       Y
+      redrawwin                             -        -      4.0
+      wredrawln                             -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   refresh( void )
+#else
+int   PDC_CDECL   refresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("refresh() - called\n");
+#endif
+
+   return( wrefresh(stdscr) );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   wrefresh(WINDOW *win)
+#else
+int   PDC_CDECL   wrefresh(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+   bool save_clear;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wrefresh() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL) return( ERR );
+   if (win->_flags & _PAD) return( ERR );
+   if (win->_flags & _SUBPAD) return( ERR );
+
+   save_clear = win->_clear;
+   if (win == curscr)
+      curscr->_clear = TRUE;
+   else  
+      wnoutrefresh(win);
+   if (save_clear
+   &&  win->_maxy == SP->lines
+   &&  win->_maxx == SP->cols)
+      {
+      curscr->_clear = TRUE;
+      }
+   doupdate();
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   wnoutrefresh(WINDOW *win)
+#else
+int   PDC_CDECL   wnoutrefresh(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+register int      first; /* first changed char on line */
+register int      last;  /* last changed char on line  */
+   int      begy, begx;  /* window's place on screen   */
+   int      i, j, x, y;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wnoutrefresh() - called: win=%x\n",win);
+#endif
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if ((win->_flags == _PAD)
+   ||  (win->_flags == _SUBPAD))
+      return( ERR );
+
+   y = win->_cury;
+   x = win->_curx;
+
+   if (win->_title != NULL)
+   {
+      int len = strlen(win->_title);
+      chtype attrs = win->_attrs;
+   /*
+    * There may be a better place to implement window titles, but this
+    * seems to be the best place. -- Frotz
+    */
+      if ((len > 0)
+      && !(win->_flags & _SUBWIN)
+      && !(win->_flags & _SUBPAD))
+      {
+         wattrset(win, win->_title_attr);
+         mvwprintw(win, 0, (win->_title_ofs), "%s", (long) win->_title);
+         wmove(win, y, x); /* restore cursor postion */
+         wattrset(win, attrs);   /* restore attributes     */
+      }
+   }
+
+   if (win->_flags & _PAD)
+      return( ERR );
+
+   begy = win->_begy;
+   begx = win->_begx;
+
+   for (i = 0, j = begy; i < win->_maxy; i++, j++)
+   {
+      if (win->_firstch[i] != _NO_CHANGE)
+      {
+         first = win->_firstch[i];
+         last = win->_lastch[i];
+
+         memcpy(&(curscr->_y[j][begx + first]),
+                &(win->_y[i][first]),
+                (last - first + 1) * sizeof(chtype));
+
+         first += begx; /* s's min/max change positions */
+         last += begx;
+
+         if (curscr->_firstch[j] != _NO_CHANGE)
+            curscr->_firstch[j] = min(curscr->_firstch[j], first);
+         else
+            curscr->_firstch[j] = first;
+
+         curscr->_lastch[j] = max(curscr->_lastch[j], last);
+
+         win->_firstch[i] = _NO_CHANGE;   /* updated now */
+      }
+      win->_lastch[i] = _NO_CHANGE; /* updated now */
+   }
+
+   if (win->_clear)
+      win->_clear = FALSE;
+
+   if (!win->_leaveit)
+   {
+      curscr->_cury = win->_cury + begy;
+      curscr->_curx = win->_curx + begx;
+   }
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   doupdate(void)
+#else
+int   PDC_CDECL   doupdate()
+#endif
+/***********************************************************************/
+{
+register int   i;
+bool rc;
+#ifdef   REGISTERWINDOWS
+   WINDS*   next = SP->visible;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("doupdate() - called\n");
+#endif
+
+   if (isendwin())  /* coming back after endwin() called */
+   {
+      reset_prog_mode();
+      curscr->_clear = TRUE;
+      SP->alive = TRUE; /* so isendwin() result is correct */
+   }
+
+#ifdef   REGISTERWINDOWS
+   if (SP->refreshall)
+   {
+      while (next != NULL)
+      {
+         if (next->w->_parent != NULL)
+         {
+            touchwin(next->w->_parent);
+            wnoutrefresh(next->w->_parent);
+         }
+         touchwin(next->w);
+         wnoutrefresh(next->w);
+         next = next->next;
+      }
+   }
+#endif
+
+   if (SP->shell)
+      reset_prog_mode();
+
+   if (curscr == (WINDOW *)NULL)
+      return( ERR );
+
+/* if checking for typeahead, bail out here if any is found */
+   
+   if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+   {
+      rc = PDC_breakout();
+      if(rc)
+         return( OK );
+   }
+
+   if (curscr->_clear)
+      PDC_clr_update(curscr);
+   else
+   {
+#ifdef WIN32
+      if (!SP->refrbrk
+      &&  getenv("PDC_FULL_DISPLAY") != NULL)
+         PDC_doupdate();
+      else
+      {
+         for (i = 0; i < SP->lines; i++)
+         {
+# ifdef PDCDEBUG
+   if (trace_on) PDC_debug("doupdate() - Transforming line %d of %d: %s\n",i,SP->lines,(curscr->_firstch[i] != _NO_CHANGE)?"Yes" : "No");
+#endif
+            if (curscr->_firstch[i] != _NO_CHANGE)
+               if (PDC_transform_line(i))  /* if test new */
+                  break;
+         }
+      }
+#else
+      for (i = 0; i < SP->lines; i++)
+      {
+         if (curscr->_firstch[i] != _NO_CHANGE)
+            if (PDC_transform_line(i))  /* if test new */
+               break;
+      }
+#endif
+   }
+
+# if defined (XCURSES)
+   XCursesInstructAndWait(CURSES_REFRESH);
+# endif
+
+   if (SP->cursrow != curscr->_cury
+   ||  SP->curscol != curscr->_curx)
+   {
+      PDC_gotoxy(curscr->_cury, curscr->_curx);
+      SP->cursrow = curscr->_cury;
+      SP->curscol = curscr->_curx;
+   }
+
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   redrawwin(WINDOW *win)
+#else
+int   PDC_CDECL   redrawwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("redrawwin() - called: win=%x\n",win);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   return(wredrawln(win,0,win->_maxy));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_CDECL   wredrawln(WINDOW *win, int start, int num)
+#else
+int   PDC_CDECL   wredrawln(win,start,num)
+WINDOW *win;
+int start;
+int num;
+#endif
+/***********************************************************************/
+{
+   register int i;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("wredrawln() - called: win=%x start=%d num=%d\n",win,start,num);
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   if  (start > win->_maxy || start + num > win->_maxy)
+      return( ERR );
+   for(i=start;i<start+num;i++)
+      {
+      win->_firstch[i] = 0;
+      win->_lastch[i] = win->_maxx - 1;
+      }
+   return( OK );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/scanw.c stsgdb-6.8/pdcurses/pdcurses/scanw.c
--- gdb-6.8/pdcurses/pdcurses/scanw.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/scanw.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,276 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+#if defined(HAVE_STDARG_H) && defined(HAVE_PROTO)
+#  include <stdarg.h>
+#  define HAVE_STDARG_H_HAVE_PROTO
+#else
+#  include <varargs.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	scanw
+#undef	wscanw
+#undef	mvscanw
+#undef	mvwscanw
+#undef	vwscanw
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	wgetstr
+#  undef	wrefresh
+#  undef	wmove
+#endif
+
+#ifndef HAVE_VSSCANF
+#  define vsscanf PDC_vsscanf
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_scanw  = "$Id: scanw.c,v 1.1 2001/01/10 08:27:26 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         scanw
+
+  Synopsis:
+  	int scanw(char *fmt, ...);
+  	int wscanw(WINDOW *win, char *fmt, ...);
+  	int mvscanw(int y, int x, char *fmt, ...);
+  	int mvwscanw(WINDOW *win, int y, int x, char *fmt,...);
+  ***	int vwscanw(WINDOW *win, char *fmt, va_list varglist);
+
+  X/Open Description:
+ 	These routines correspond to scanf(). The function scanw() reads
+ 	input from the default window. The function wscanw() reads
+ 	input from the specified window. The function mvscanw() moves
+ 	the cursor to the specified position and then reads input from
+ 	the default window. The function mvwscanw() moves the cursor to
+ 	the specified position and then reads input from the specified
+ 	window.
+
+ 	For all the functions, the routine wgetstr() is called to get a
+ 	string from the window, and the resulting line is used as
+ 	input for the scan.  All character interpretation is carried
+ 	out according to the scanf function rules.
+
+  PDCurses Description:
+ 	The old Bjorn Larssen code for the 68K platform has been removed
+ 	from this module.
+
+  X/Open Return Value:
+ 	Upon successful completion, the scanw, mvscanw, mvwscanw and
+ 	wscanw functions return the number of items successfully
+ 	matched.  On end-of-file, they return EOF.  Otherwise they
+ 	return ERR.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      scanw                                 Y        Y       Y
+      wscanw                                Y        Y       Y
+      mvscanw                               Y        Y       Y
+      mvwscanw                              Y        Y       Y
+      vwscanw                               -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	scanw(char *fmt, ...)
+#else
+int	PDC_CDECL	scanw(fmt,va_alist)
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (stdscr == (WINDOW *)NULL)
+		return( retval );
+
+	wrefresh(stdscr);	/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(stdscr, c_printscanbuf) == ERR)
+		return( retval );
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+#else
+	va_start(args);
+#endif
+
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+
+	return( retval );
+}
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	wscanw(WINDOW *win, char *fmt, ...)
+#else
+int	PDC_CDECL	wscanw(win,fmt,va_alist)
+WINDOW *win;
+char *fmt;
+va_dcl
+# endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wscanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (win == (WINDOW *)NULL)
+		return (retval);
+
+	wrefresh(win);		/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(win, c_printscanbuf) == ERR)
+		return( retval );
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+# else
+	va_start(args);
+# endif
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+
+	return( retval );
+}
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvscanw(int y, int x, char *fmt, ... )
+#else
+int	PDC_CDECL	mvscanw(y,x,fmt,va_alist)
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvscanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (stdscr == (WINDOW *)NULL)
+		return( retval );
+
+	if (wmove(stdscr, y, x) == ERR)
+		return( retval );
+
+	wrefresh(stdscr);			/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(stdscr, c_printscanbuf) == ERR)
+		return( retval );
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+# else
+	va_start(args);
+# endif
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+
+	return( retval );
+}
+
+/***********************************************************************/
+#ifdef HAVE_STDARG_H_HAVE_PROTO
+int	PDC_CDECL	mvwscanw(WINDOW *win, int y, int x, char *fmt,...)
+#else
+int	PDC_CDECL	mvwscanw(win,y,x,fmt,va_alist)
+WINDOW *win;
+int y,x;
+char *fmt;
+va_dcl
+#endif
+/***********************************************************************/
+{
+	va_list args;
+	int	retval = ERR;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvscanw() - called\n");
+#endif
+
+#if	!defined (HC)
+	if (win == (WINDOW *)NULL)
+		return( retval );
+
+	if (wmove(win, y, x) == ERR)
+		return( retval );
+
+	wrefresh(win);		/* set cursor position */
+
+	/*
+	 * get string
+	 */
+	c_printscanbuf[0] = '\0';  /* reset to empty string */
+	if (wgetstr(win, c_printscanbuf) == ERR)
+		return( retval );
+# ifdef HAVE_STDARG_H_HAVE_PROTO
+	va_start(args, fmt);
+# else
+	va_start(args);
+# endif
+	retval = vsscanf(c_printscanbuf, fmt, args);
+	va_end(args);
+#endif
+	return( retval );
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/scr_dump.c stsgdb-6.8/pdcurses/pdcurses/scr_dump.c
--- gdb-6.8/pdcurses/pdcurses/scr_dump.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/scr_dump.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,149 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define CURSES_LIBRARY  1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef scr_dump
+#undef scr_init
+#undef scr_restore
+#undef scr_set
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_terminfo  = "$Id: scr_dump.c,v 1.1 2005/12/17 09:07:23 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                       scr_dump
+
+  Synopsis:
+    int scr_dump(const char *filename);
+    int scr_init(const char *filename);
+    int scr_restore(const char *filename);
+    int scr_set(const char *filename);
+
+  X/Open Description:
+    The scr_dump() function writes the current contents of the virtual 
+    screen to the file named by filename in an unspecified format.
+
+    The scr_restore() function sets the virtual screen to the contents 
+    of the file named by filename, which must have been written using 
+    scr_dump(). The next refresh operation restores the screen to the 
+    way it looked in the dump file.
+
+    The scr_init() function reads the contents of the file named by 
+    filename and uses them to initialise the Curses data structures to 
+    what the terminal currently has on its screen. The next refresh 
+    operation bases any updates on this information, unless either of 
+    the following conditions is true:
+
+        * The terminal has been written to since the virtual screen was 
+          dumped to filename
+
+        * The terminfo capabilities rmcup and nrrmc are defined for the 
+          current terminal.
+
+    The scr_set() function is a combination of scr_restore() and 
+    scr_init(). It tells the program that the information in the file 
+    named by filename is what is currently on the screen, and also what 
+    the program wants on the screen. This can be thought of as a screen 
+    inheritance function.
+
+  PDCurses Description:
+    These functions are not yet meaningfully implemented in PDCurses. 
+    This file is a placeholder.
+
+  X/Open Return Value:
+    On successful completion, these functions return OK. Otherwise, they 
+    return ERR.
+
+  X/Open Errors:
+    No errors are defined. 
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int scr_dump(const char *filename)
+#else
+int scr_dump(filename)
+char *filename;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scr_dump() - called: filename %s\n",
+		filename);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int scr_init(const char *filename)
+#else
+int scr_init(filename)
+char *filename;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scr_init() - called: filename %s\n",
+		filename);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int scr_restore(const char *filename)
+#else
+int scr_restore(filename)
+char *filename;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scr_restore() - called: filename %s\n", 
+		filename);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int scr_set(const char *filename)
+#else
+int scr_set(filename)
+char *filename;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("scr_set() - called: filename %s\n", 
+		filename);
+#endif
+	return ERR;
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/scroll.c stsgdb-6.8/pdcurses/pdcurses/scroll.c
--- gdb-6.8/pdcurses/pdcurses/scroll.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/scroll.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,201 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef   scroll
+#undef   scrl
+#undef   wscrl
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_scroll  = "$Id: scroll.c,v 1.2 2002/05/26 01:14:45 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        scroll
+
+  Synopsis:
+    int scroll(WINDOW *win);
+    int scrl(int n);
+    int wscrl(WINDOW *win, int n);
+
+  X/Open Description:
+    scroll() causes the window to scroll up one line.  This involves 
+    moving the lines in the window data strcture.
+ 
+    With the scrl() and wscrl() routines, for positive n scroll the 
+    window up n lines (line i+n becomes i); otherwise scroll the 
+    window down n lines.
+ 
+    For these functions to work, scrolling must be enabled via 
+    scrollok().
+ 
+    Note that scrl() and scroll() may be macros.
+ 
+    Note also that scrolling is not allowed if the supplied window 
+    is a PAD.
+
+  X/Open Return Value:
+    All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+    No errors are defined for this function.
+
+  NOTE:
+    The behaviour of Unix curses is to clear the line with a space
+    and attributes of A_NORMAL. PDCurses clears the line with the
+    window's current attributes (including current colour). To get
+    the behaviour of PDCurses, #define PDCURSES_WCLR in curses.h or
+    add -DPDCURSES_WCLR to the compile switches.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      scroll                                Y        Y       Y
+      scrl                                  -        -      4.0
+      wscrl                                 -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL scroll(WINDOW *win)
+#else
+int PDC_CDECL scroll(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("scroll() - called\n");
+#endif
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+   return(wscrl(win,1));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int  PDC_CDECL wscrl(WINDOW *win, int n)
+#else
+int  PDC_CDECL wscrl(win,n)
+WINDOW *win;
+int n;
+#endif
+/***********************************************************************/
+{
+   register int   i;
+   register int   l;
+   chtype*  ptr;
+   chtype*  temp;
+   static   chtype   blank;
+
+   if (win == (WINDOW *)NULL)
+      return( ERR );
+
+#if defined(PDCURSES_WCLR)
+   blank = win->_blank | win->_attrs;
+#else
+/* wrs (4/10/93) account for window background */
+   blank = win->_bkgd;
+#endif
+
+   /*
+    * Check if window scrolls. Valid for window AND pad
+    */
+   if ( !win->_scroll )
+   {
+      return( ERR );
+   }
+
+   /* wrs -- 7/11/93 -- quick add to original scroll() routine to implement
+    *                   scrolling for a specified number of lines
+    *                   (not very efficient for more than 1 line)
+    */
+
+   if ( n >= 0 )
+   {
+      for ( l=0; l<n; l++ ) 
+      {
+         temp = win->_y[win->_tmarg];
+         for (i = win->_tmarg; (i < win->_bmarg); i++)
+         {
+            win->_y[i] = win->_y[i + 1];  /* re-arrange line
+                            * pointers */
+            win->_firstch[i] = 0;
+            win->_lastch[i] = win->_maxx - 1;
+         }
+         for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+            *ptr = blank;           /* make a blank line */
+         win->_y[win->_bmarg] = temp;
+         win->_firstch[win->_bmarg] = 0;
+         win->_lastch[win->_bmarg] = win->_maxx - 1;
+      }
+   }
+   else 
+   {
+      for ( l=n; l<0; l++ ) 
+      {
+         temp = win->_y[win->_bmarg];
+         for (i = win->_bmarg; (i > win->_tmarg); i--)
+         {
+            win->_y[i] = win->_y[i - 1];  /* re-arrange line
+                            * pointers */
+            win->_firstch[i] = 0;
+            win->_lastch[i] = win->_maxx - 1;
+         }
+         for (ptr = temp; (ptr - temp < win->_maxx); ptr++)
+            *ptr = blank;           /* make a blank line */
+         win->_y[win->_tmarg] = temp;
+         win->_firstch[win->_tmarg] = 0;
+         win->_lastch[win->_tmarg] = win->_maxx - 1;
+      }
+   }
+   PDC_sync(win);
+   return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL scrl(int n)
+#else
+int PDC_CDECL scrl(n)
+int n;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("scrl() - called\n");
+#endif
+
+   return(wscrl(stdscr,n));
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/slk.c stsgdb-6.8/pdcurses/pdcurses/slk.c
--- gdb-6.8/pdcurses/pdcurses/slk.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/slk.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,786 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+#include <string.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	slk_init
+#undef	slk_set
+#undef	slk_refresh
+#undef	slk_noutrefresh
+#undef	slk_label
+#undef	slk_clear
+#undef	slk_restore
+#undef	slk_touch
+#undef	slk_attron
+#undef	slk_attrset
+#undef	slk_attroff
+#undef	slk_color
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_slk  = "$Id: slk.c,v 1.5 2005/12/14 19:40:29 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          slk
+
+  Synopsis:
+
+  	int slk_init(int fmt);
+  	int slk_set(int labnum, const char *label, int fmt);
+  	int slk_refresh(void);
+  	int slk_noutrefresh(void);
+  	char *slk_label(int labnum);
+  	int slk_clear(void);
+  	int slk_restore(void);
+  	int slk_touch(void);
+  	int slk_attron(attr_t attrs);
+  	int slk_attrset(attr_t attrs);
+  	int slk_attroff(attr_t attrs);
+  	int slk_color(short color_pair);
+
+  X/Open Description:
+ 	These functions manipulate a window that contain Soft Label Keys (SLK).
+ 	TO use the SLK functions, a call to slk_init() must be made BEFORE
+ 	initscr() or newterm(). slk_init() removes 1 or 2 lines from the
+ 	useable screen, depending on the format selected.
+
+ 	The line(s) removed from the screen are used as a separate window, in
+ 	which SLKs are displayed.
+
+ 	slk_init() requires a single parameter which describes the format of
+ 	the SLKs as follows:
+ 
+ 		1	3-2-3 format
+ 		2	4-4 format
+ 		3	4-4-4 format (ncurses extension)
+ 		4	4-4-4 format with index line (ncurses extension) 2 lines used
+ 		55	5-5 format (pdcurses format)
+
+ 	The functions slk_refresh(), slk_noutrefresh() and slk_touch() are
+ 	analagous to refresh(), noutrefresh() and touch() functions.
+
+  PDCurses Description:
+ 	System V compatible color support is included.
+ 	See <curses.h> for further details.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	It is an error to call this function with a NULL window pointer.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      slk_init                              Y        -       Y
+      slk_set                               Y        -       Y
+      slk_refresh                           Y        -       Y
+      slk_noutrefresh                       Y        -       Y
+      slk_label                             Y        -       Y
+      slk_clear                             Y        -       Y
+      slk_restore                           Y        -       Y
+      slk_touch                             Y        -       Y
+      slk_attron                            Y        -       Y
+      slk_attrset                           Y        -       Y
+      slk_attroff
+
+**man-end**********************************************************************/
+
+
+#define LABEL_NORMAL	8
+#define LABEL_EXTENDED	10
+#define LABEL_NCURSES_EXTENDED	12
+
+static int slk_start_col[LABEL_NCURSES_EXTENDED];
+static chtype slk_attributes[LABEL_NCURSES_EXTENDED];
+char slk_temp_string[64];
+static int space_seperator=1;
+static int label_length=0;
+static int labels=0;
+static int label_fmt=0;
+static int label_line=0;
+
+#ifdef HAVE_PROTO
+void (*PDC_initial_slk)(void);
+static void PDC_slk_init(void);
+#else
+void (*PDC_initial_slk)();
+static void PDC_slk_init();
+#endif
+
+static struct {
+	char	label[32];
+	int	format;		
+} slk_save[ LABEL_NCURSES_EXTENDED ];
+
+
+/***********************************************************************/
+/*
+   slk_init()	is the slk initialization routine.
+   This must be called before initscr().
+
+   label_fmt = 0, 1 or 55.
+       0 = 3-2-3 format
+       1 = 4 - 4 format
+       2 = 4-4-4 format	(ncurses extension for PC 12 function keys)
+       3 = 4-4-4 format	(ncurses extension for PC 12 function keys - with index line)
+      55 = 5 - 5 format	(extended for PC, 10 function keys)
+
+ */
+#ifdef HAVE_PROTO
+int PDC_CDECL slk_init(int fmt)
+#else
+int PDC_CDECL slk_init(fmt)
+int fmt;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_init() - called\n");
+#endif
+
+ if (SP)
+   return (ERR);
+
+ switch (fmt) 
+ {
+    case 0:  /* 3 - 2 - 3 */
+       labels = LABEL_NORMAL;
+       break;
+
+    case 1:   /* 4 - 4 */
+       labels = LABEL_NORMAL;
+       break;
+
+    case 2:   /* 4 4 4 */
+       labels = LABEL_NCURSES_EXTENDED;
+       break;
+
+    case 3:   /* 4 4 4  with index */
+       labels = LABEL_NCURSES_EXTENDED;
+       break;
+
+    case 55:  /* 5 - 5 */
+       labels = LABEL_EXTENDED;
+       break;
+
+    default:
+       return (ERR);
+ } /* end switch */
+
+ PDC_initial_slk = PDC_slk_init;
+ label_fmt = fmt;
+ return(OK);
+}
+
+
+
+
+/***********************************************************************/
+/*
+ PDC_slk_set() Used to set a slk label to a string.
+
+   label_num = 1 - 8 (or 10) (number of the label)
+   label_str = string (8 or 7 bytes total), NULL chars or NULL pointer
+   label_fmt =  justification
+      0 = left
+      1 = center
+      2 = right
+   save = 1 yes or 0 no
+ */
+#ifdef HAVE_PROTO
+static int PDC_slk_set(int label_num, const char *label_str, int label_fmt, int save)
+#else
+static int PDC_slk_set(label_num, label_str, label_fmt, save)
+int label_num;
+char *label_str;
+int label_fmt;
+int save;
+#endif
+/***********************************************************************/
+{
+register int i, num;
+int slen;
+int llen;
+int col;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_slk_set() - called\n");
+#endif
+
+ if (label_num < 1 
+ || label_num > labels 
+ || label_fmt < 0 
+ || label_fmt > 2)
+    return (ERR);
+
+
+/*
+    A NULL in either the first byte or pointer
+    indicates a clearing of the label.
+*/
+ num = label_num - 1;
+
+ if (label_str == (char *)0 || *label_str == '\0') 
+ {
+    slk_attributes[num] = SP->slk_winptr->_attrs;
+    wmove(SP->slk_winptr, label_line, slk_start_col[num]);
+
+    for (i = 0; i < label_length; ++i)
+       PDC_chadd( SP->slk_winptr, ' ', (bool)(!(SP->raw_out)), TRUE );
+
+    /* Save the string and attribute */
+    if (save)
+    {
+       *slk_save[num].label = '\0';
+       slk_save[num].format = 0;
+    }
+    wmove(SP->slk_winptr, label_line, 0);   /* park it */
+
+    return (OK);
+ }
+
+ /* Otherwise, format the character and put in position. */
+ memset(slk_temp_string, 0, sizeof (slk_temp_string));
+ strncpy(slk_temp_string, label_str, label_length);
+
+ /* Save the string and attribute */
+ if (save)
+ {
+    strcpy(slk_save[num].label, slk_temp_string);
+    slk_save[num].format = label_fmt;
+ }
+
+ slk_attributes[num] = SP->slk_winptr->_attrs;
+ wmove(SP->slk_winptr, label_line, slk_start_col[num]);
+
+ for (i = 0; i < label_length; ++i)
+    PDC_chadd( SP->slk_winptr, ' ', (bool)(!(SP->raw_out)), TRUE );
+
+ wmove(SP->slk_winptr, label_line, slk_start_col[num]);
+
+ switch (label_fmt)
+ {
+    case 0:  /* LEFT */
+       waddstr(SP->slk_winptr, slk_temp_string);
+       break;
+         
+    case 1:  /* CENTER */
+       slen = strlen(slk_temp_string);
+       col = slen / 2;
+       llen = label_length / 2;
+       col = llen - col;
+       if (col + slen > label_length)
+          --col;
+       mvwaddstr(SP->slk_winptr, label_line, slk_start_col[num] + col, slk_temp_string);
+       break;
+
+    default:  /* RIGHT */
+       slen = strlen(slk_temp_string);
+       col = label_length - slen;
+       mvwaddstr(SP->slk_winptr, label_line, slk_start_col[num] + col, slk_temp_string);
+       break;
+ }
+
+ wmove(SP->slk_winptr, label_line, 0);	/* park it */
+
+ return( OK );
+}
+
+
+/***********************************************************************/
+/*
+ slk_set() Used to set a slk label to a string.
+
+   label_num = 1 - 8 (or 10) (number of the label)
+   label_str = string (8 or 7 bytes total), NULL chars or NULL pointer
+   label_fmt =  justification
+      0 = left
+      1 = center
+      2 = right
+ */
+#ifdef HAVE_PROTO
+int PDC_CDECL slk_set(int label_num, const char *label_str, int label_fmt)
+#else
+int PDC_CDECL slk_set(label_num, label_str, label_fmt)
+int label_num;
+char *label_str;
+int label_fmt;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_set() - called\n");
+#endif
+
+ return( PDC_slk_set( label_num, label_str, label_fmt, 1 ) );
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_refresh(void)
+#else
+int	PDC_CDECL	slk_refresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_refresh() - called\n");
+#endif
+
+ if (SP->slk_winptr == (WINDOW *)NULL)
+    return (ERR);
+
+ slk_noutrefresh();
+ return (doupdate());
+
+}
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_noutrefresh(void)
+#else
+int	PDC_CDECL	slk_noutrefresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_noutrefresh() - called\n");
+#endif
+
+ if (SP->slk_winptr == (WINDOW *)NULL)
+    return (ERR);
+
+ return (wnoutrefresh(SP->slk_winptr));
+}
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	slk_label(int labnum)
+#else
+char*	PDC_CDECL	slk_label(labnum)
+int labnum;   /* 1 - 8 (or 10) */
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_label() - called\n");
+#endif
+
+ if (labnum < 0 || labnum > labels)
+    return ((char *)0);
+
+ memset(slk_temp_string, 0, sizeof (slk_temp_string));
+ strcpy(slk_temp_string, slk_save[labnum - 1].label);
+
+ return (slk_temp_string);	/* only good temporarily */
+
+}
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_clear(void)
+#else
+int	PDC_CDECL	slk_clear()
+#endif
+/***********************************************************************/
+{
+ register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("slk_clear() - called\n");
+#endif
+
+ for (i = 0; i < labels; ++i)
+ {
+    wattrset(SP->slk_winptr, slk_attributes[i]);
+    PDC_slk_set( i + 1, "", 0, 0 );
+ }
+ return wrefresh(SP->slk_winptr);
+}
+
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_restore(void)
+#else
+int	PDC_CDECL	slk_restore()
+#endif
+/***********************************************************************/
+{
+ register int i;
+ chtype attr=SP->slk_winptr->_attrs;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_restore() - called\n");
+#endif
+
+ for (i = 0; i < labels; ++i)
+ {
+    wattrset(SP->slk_winptr, slk_attributes[i]);
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+
+ SP->slk_winptr->_attrs = attr;
+
+ return wrefresh(SP->slk_winptr);
+}
+
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_touch(void)
+#else
+int	PDC_CDECL	slk_touch()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_touch() - called\n");
+#endif
+
+ return touchwin(SP->slk_winptr);
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_attron(attr_t attrs)
+#else
+int	PDC_CDECL	slk_attron(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_attron() - called\n");
+#endif
+ rc = wattron(SP->slk_winptr, attrs);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+ return rc;
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_attroff(attr_t attrs)
+#else
+int	PDC_CDECL	slk_attroff(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_attroff() - called\n");
+#endif
+ rc = wattroff(SP->slk_winptr, attrs);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+ return rc;
+}
+
+
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	slk_attrset(attr_t attrs)
+#else
+int	PDC_CDECL	slk_attrset(attrs)
+attr_t attrs;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_attrset() - called\n");
+#endif
+
+ rc = wattrset(SP->slk_winptr, attrs);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+
+ return rc;
+
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL       slk_color(short color_pair)
+#else
+int     PDC_CDECL       slk_color(color_pair)
+short color_pair;
+#endif
+/***********************************************************************/
+{
+ int i,rc;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("slk_color() - called\n");
+#endif
+
+ rc = wcolor_set(SP->slk_winptr, color_pair, NULL);
+ for (i = 0; i < labels; ++i)
+ {
+    PDC_slk_set(i + 1, slk_save[i].label, slk_save[i].format, 0);
+ }
+
+ return rc;
+
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+static void	PDC_slk_init(void)
+#else
+static void	PDC_slk_init()
+#endif
+/***********************************************************************/
+{
+ register int i;
+ attr_t save_attr;
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_slk_init() - called\n");
+#endif
+
+/*
+ * Don't set this to NULL as resize_term() calls it.
+ PDC_initial_slk = NULL;
+ */
+      
+ if ( label_fmt == 3 )
+ {
+    SP->slklines = 2;
+    label_line = 1;
+ }
+ else
+    SP->slklines = 1;
+
+ if (!SP->slk_winptr)
+ {
+    if ((SP->slk_winptr = newwin(SP->slklines, COLS, LINES-SP->slklines, 0)) == (WINDOW *)0)
+       return;
+    wattrset(SP->slk_winptr,A_REVERSE);
+ }
+ PDC_slk_calc();
+ /* if we have an index line, display it now */
+ if ( label_fmt == 3 )
+ {
+    save_attr = SP->slk_winptr->_attrs;
+    wattrset(SP->slk_winptr,A_NORMAL);
+    wmove( SP->slk_winptr, 0, 0 );
+    whline( SP->slk_winptr, 0, COLS );
+    for ( i = 0; i < labels; i++ )
+    {
+       mvwprintw( SP->slk_winptr, 0, slk_start_col[i], "F%d", i+1 );
+    }
+    SP->slk_winptr->_attrs = save_attr;
+ }
+ touchwin(SP->slk_winptr);
+}
+
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_slk_calc(void)
+#else
+void	PDC_slk_calc()
+#endif
+/***********************************************************************/
+{
+ register int i;
+ register int col=0, center;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_slk_calc() - called\n");
+#endif
+
+ switch (label_fmt) 
+ {
+    case 0:  /* 3 - 2 - 3 */
+       label_length = ( COLS / labels ) - space_seperator - 1;
+       break;
+
+    case 1:   /* 4 - 4 */
+       label_length = ( COLS / labels ) - space_seperator;
+       break;
+
+    case 2:   /* 4 4 4 */
+    case 3:   /* 4 4 4 with index */
+       label_length = ( COLS / labels ) - space_seperator;
+       break;
+
+    case 55:  /* 5 - 5 */
+       label_length = ( COLS / labels ) - space_seperator;
+       break;
+
+    default: /* should never get here!! */
+       return;
+ } /* end switch */
+
+
+ /* set default attribute */
+ for (i = 0; i < labels; ++i)
+ {
+    slk_attributes[i] = A_REVERSE;
+ }
+
+ switch (label_fmt) {
+    case 0:     /* 3 - 2 - 3 F-Key layout */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+
+       center = COLS/2;
+       slk_start_col[3] = center - label_length;
+       slk_start_col[4] = center + space_seperator;
+
+       col = COLS - ((label_length + space_seperator) * 2 + label_length);
+       slk_start_col[5] = col;
+       slk_start_col[6] = (col += label_length + space_seperator);
+       slk_start_col[7] = (col += label_length + space_seperator);
+       break;
+
+    case 1:     /* 4 - 4 F-Key layout */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+       slk_start_col[3] = (col += label_length + space_seperator);
+
+       col = COLS - ((label_length + space_seperator) * 3 + label_length);
+       slk_start_col[4] = col;
+       slk_start_col[5] = (col += label_length + space_seperator);
+       slk_start_col[6] = (col += label_length + space_seperator);
+       slk_start_col[7] = (col += label_length + space_seperator);
+       break;
+
+    case 2:     /* 4 4 4 F-Key layout */
+    case 3:     /* 4 4 4 F-Key layout with index */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+       slk_start_col[3] = (col += label_length + space_seperator);
+
+       center = COLS/2;
+       slk_start_col[4] = center - (2 * label_length) - space_seperator;
+       slk_start_col[5] = center - label_length;
+       slk_start_col[6] = center + space_seperator;
+       slk_start_col[7] = center + label_length + (2 * space_seperator);
+
+       col = COLS - ((label_length + space_seperator) * 3 + label_length);
+       slk_start_col[8] = col;
+       slk_start_col[9] = (col += label_length + space_seperator);
+       slk_start_col[10] = (col += label_length + space_seperator);
+       slk_start_col[11] = (col += label_length + space_seperator);
+       break;
+
+    default:    /* 5 - 5 F-Key layout */
+       slk_start_col[0] = col;
+       slk_start_col[1] = (col += label_length + space_seperator);
+       slk_start_col[2] = (col += label_length + space_seperator);
+       slk_start_col[3] = (col += label_length + space_seperator);
+       slk_start_col[4] = (col += label_length + space_seperator);
+
+       col = COLS - ((label_length + space_seperator) * 4 + label_length);
+       slk_start_col[5] = col;
+       slk_start_col[6] = (col += label_length + space_seperator);
+       slk_start_col[7] = (col += label_length + space_seperator);
+       slk_start_col[8] = (col += label_length + space_seperator);
+       slk_start_col[9] = (col += label_length + space_seperator);
+       break;
+
+ } /* end switch */
+
+ /* make sure labels are all in window */
+ for (i = 0; i < labels; ++i)
+ {
+    slk_set(i + 1, slk_save[i].label, slk_save[i].format);
+ }
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_mouse_in_slk(int y, int x)
+#else
+int	PDC_mouse_in_slk(y,x)
+int y, x;
+#endif
+/***********************************************************************/
+{
+ register int i;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("PDC_mouse_in_slk() - called: y->%d x->%d\n",y,x);
+#endif
+
+/*
+ * If the line on which the mouse was clicked is NOT the last line of
+ * the screen, we are not interested in it...
+ */
+ if ( SP->slk_winptr == NULL )
+    return(0);
+ if ( y != ( SP->slk_winptr->_begy + label_line ) )
+    return(0);
+
+ for (i=0;i<labels;i++)
+ {
+    if (x >= slk_start_col[i]
+    &&  x <= slk_start_col[i] + label_length - 1)
+       return(i+1);
+ }
+
+ return(0);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/termattr.c stsgdb-6.8/pdcurses/pdcurses/termattr.c
--- gdb-6.8/pdcurses/pdcurses/termattr.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/termattr.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,448 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef UNIX
+#include <defs.h>
+#include <term.h>
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <limits.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	baudrate
+#undef	erasechar
+#undef	has_ic
+#undef	has_il
+#undef	killchar
+#undef	longname
+#undef	termattrs
+#undef	termname
+#undef	wordchar
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_termattr  = "$Id: termattr.c,v 1.4 2003/12/28 08:39:48 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                     termattr
+
+  Synopsis:
+  	int baudrate(void);
+  	char erasechar(void);
+  	bool has_ic(void);
+  	bool has_il(void);
+  	char killchar(void);
+  	char *longname(void);
+  	attr_t termattrs(void);
+  	char *termname(void);
+
+  	char	wordchar(void);
+
+  X/Open Description:
+ 	baudrate() returns the output speed of the terminal.  The number 
+ 	returned is bits per second, for example 9600, and is an integer.
+
+ 	The user's current ERASE character is returned from a call to
+ 	erasechar();
+
+ 	The has_ic function will return TRUE if the terminal has insert 
+ 	character and delete character capabilities.
+
+ 	The has_il() function will return TRUE if the terminal has insert
+ 	line and delete line capabilities.
+
+ 	The user's current KILL character is returned from a call to
+ 	killchar();
+
+ 	longname() returns a pointer to a static area containing a
+ 	verbose description of the current terminal.  The maximum length
+ 	of the string is 128 characters.  It is defined only after the
+ 	call to initscr() or newterm().  The area is overwritten by each
+ 	call to newterm() and is not restored by set_term().  The value
+ 	should therefore be saved between calls to newterm(), if
+ 	longname() is going to be used with multiple terminals.
+
+ 	termname() returns a pointer to a static area containing a
+ 	short description of the current terminal (14 characters).
+
+ 	termattrs() returns a logical OR of all video attributes
+ 	supported by the terminal.
+
+  PDCurses Description:
+ 	If FAST_VIDEO is true, then this is the largest possible
+ 	(portable) int value (INT_MAX from limits.h) IF direct
+ 	video is possible, OR the approximate guess at BIOS speeds,
+ 	19200.
+ 	If FAST_VIDEO is false, this is an approximate guess at BIOS
+ 	speeds, 19200.
+
+ 	erasechar(), killchar() and wordchar() all return values that are 
+ 	hardcoded at this time.  There may be future development
+ 	to allow applications an easy way to specify these value.
+
+ 	For DOS, has_ic() and has_il() always return TRUE, as the speed of
+ 	the DIRECT VIDEO or even BIOS writes is quicker than on a
+ 	serial terminal.
+ 	For FLEXOS, this value has meaning and depends on the terminal,
+ 	though at this time, it is a constant TRUE.
+
+ 	In addition to the above definition for longname(), the form of 
+ 	this string is the adapter name (or video card name) and the text 
+ 	resolution. This may also be followed by the notation that the video 
+ 	card may be a clone, which indicates that the card identification
+ 	maps to more than one unique card.
+ 	e.g. The MDS Genius and the Quadram QuadHPG identify themselves
+ 	in the same manner, but are vastly different in maximum resolution.
+
+ 	The user's current WORD character is returned from a call to
+ 	wordchar();
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      baudrate                              Y        Y       Y
+      erasechar                             Y        Y       Y
+      has_ic                                Y        Y       Y
+      has_il                                Y        Y       Y
+      killchar                              Y        Y       Y
+      longname                              Y        Y       Y
+      termattrs                             Y        Y       Y
+      termname                              Y        Y       Y
+      wordchar                              -        -       -
+
+**man-end**********************************************************************/
+
+#ifdef	FLEXOS
+extern	char*	_flexos_gname();
+#endif
+static	char	_display[ 128 ];
+static	char	_shrtnme[ 14 ];
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	baudrate(void)
+#else
+int	PDC_CDECL	baudrate()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("baudrate() - called\n");
+#endif
+
+#ifdef UNIX
+	return (_CUR_TERM.baudrate);
+#else
+#ifdef FAST_VIDEO
+	return (SP->direct_video ? INT_MAX : 19200 );
+#else
+	return (19200);			/* Approx. guess at BIOS speeds.*/
+#endif
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char	PDC_CDECL	erasechar(void)
+#else
+char	PDC_CDECL	erasechar()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("erasechar() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
+	return(_CUR_TERM.prog_mode.c_cc[VERASE]);
+#else
+	ioctl(_CUR_TERM.fd, TIOCGETP, &_CUR_TERM.prog_mode.v6);
+	return(_CUR_TERM.prog_mode.v6.sg_erase);
+#endif
+#else
+	return(	_ECHAR );	/* character delete char (^H) */
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_CDECL	has_ic(void)
+#else
+bool	PDC_CDECL	has_ic()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_ic() - called\n");
+#endif
+
+#ifdef UNIX
+	if (insert_character != NULL && delete_character != NULL)
+		return(TRUE);
+	else
+		return(FALSE);
+#else
+	return( TRUE );
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_CDECL	has_il(void)
+#else
+bool	PDC_CDECL	has_il()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_il() - called\n");
+#endif
+
+#ifdef UNIX
+	if (insert_line != NULL && delete_line != NULL)
+		return(TRUE);
+	else
+		return(FALSE);
+#else
+	return( TRUE );
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char	PDC_CDECL	killchar(void)
+#else
+char	PDC_CDECL	killchar()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("killchar() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
+	return(_CUR_TERM.prog_mode.c_cc[VKILL]);
+#else
+	ioctl(_CUR_TERM.fd, TIOCGETP, &_CUR_TERM.prog_mode.v6);
+	return(_CUR_TERM.prog_mode.v6.sg_kill);
+#endif
+#else
+	return( _DLCHAR );	/* line delete char (^U) */
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	longname(void)
+#else
+char*	PDC_CDECL	longname()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("longname() - called\n");
+#endif
+
+#if defined (XCURSES)
+	if (SP->mono)
+		sprintf(_display,"X11-MONO-%dx%d",LINES,COLS);
+	else
+		sprintf(_display,"X11-COLOR-%dx%d",LINES,COLS);
+#endif
+
+#ifdef OS2
+# ifdef EMXVIDEO
+	switch (SP->mono)
+	{
+	case FALSE:	sprintf(_display,"COLOR-%dx%d", LINES, COLS); break;
+	case TRUE:	sprintf(_display,"MONO-%dx%d", LINES, COLS); break;
+# else
+	switch	(SP->adapter.adapter)
+	{
+	case DISPLAY_CGA:	sprintf(_display, "CGA-%dx%d", LINES, COLS);	  break;
+	case DISPLAY_MONOCHROME:	sprintf(_display, "MDA-%dx%d", LINES, COLS);	  break;
+	case DISPLAY_EGA:	sprintf(_display, "EGA-%dx%d", LINES, COLS); break;
+	case DISPLAY_VGA:	sprintf(_display, "VGA-%dx%d", LINES, COLS); break;
+	case DISPLAY_8514A:     sprintf(_display, "8514-%dx%d", LINES, COLS);  break;
+#  ifdef DISPLAY_XGA
+	case DISPLAY_XGA:	sprintf(_display, "XGA-%dx%d", LINES, COLS); break;
+#  endif
+# endif
+	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
+	}
+#endif
+
+#ifdef DOS
+	switch	(SP->adapter)
+	{
+	case _CGA:	sprintf(_display, "CGA-%dx%d", LINES, COLS);	  break;
+	case _MDA:	sprintf(_display, "MDA-%dx%d", LINES, COLS);	  break;
+	case _EGACOLOR:	sprintf(_display, "EGAColor-%dx%d", LINES, COLS); break;
+	case _EGAMONO:	sprintf(_display, "EGAMono-%dx%d", LINES, COLS);  break;
+	case _VGACOLOR:	sprintf(_display, "VGAColor-%dx%d", LINES, COLS); break;
+	case _VGAMONO:	sprintf(_display, "VGAMono-%dx%d", LINES, COLS);  break;
+	case _MCGACOLOR:sprintf(_display, "MCGAColor-%dx%d", LINES, COLS);break;
+	case _MCGAMONO:	sprintf(_display, "MCGAMono-%dx%d", LINES, COLS); break;
+	case _MDS_GENIUS:sprintf(_display, "Genius-%dx%d", LINES, COLS);  break;
+	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
+	}
+#endif
+
+#ifdef	FLEXOS
+	switch	(SP->adapter)
+	{
+	case _FLEXOS:	sprintf(_display, "%s", _cursesgname());	  break;
+	default:	sprintf(_display, "Unknown-%dx%d", LINES, COLS);  break;
+	}
+#endif
+
+
+	if (SP->bogus_adapter)
+		strcat(_display, " (Clone)");
+
+	return (_display);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+attr_t	PDC_CDECL	termattrs(void)
+#else
+attr_t	PDC_CDECL	termattrs()
+#endif
+/***********************************************************************/
+{
+	attr_t temp =   (A_NORMAL | A_BOLD | A_BLINK | A_REVERSE | A_UNDERLINE | A_ITALIC); /* blink is bold background on some platforms */
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("termattrs() - called\n");
+#endif
+
+	if( ! SP->mono )
+		temp |= A_COLOR;
+
+	return( temp );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	termname(void)
+#else
+char*	PDC_CDECL	termname()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("termname() - called\n");
+#endif
+
+#if defined (XCURSES)
+	if (SP->mono)
+		sprintf(_shrtnme,"X-MONO");
+	else
+		sprintf(_shrtnme,"X-COLOR");
+#endif
+
+#ifdef     OS2
+# ifdef	EMXVIDEO
+	switch (SP->mono)
+	{
+	case FALSE:	sprintf(_shrtnme,"COLOR"); break;
+	case TRUE:	sprintf(_shrtnme,"MONO"); break;
+# else
+	switch	(SP->adapter.adapter)
+	{
+	case DISPLAY_CGA:	sprintf(_shrtnme, "CGA");	  break;
+	case DISPLAY_MONOCHROME:	sprintf(_shrtnme, "MDA");	  break;
+	case DISPLAY_EGA:	sprintf(_shrtnme, "EGA"); break;
+	case DISPLAY_VGA:	sprintf(_shrtnme, "VGA"); break;
+	case DISPLAY_8514A:     sprintf(_shrtnme, "8514");  break;
+# endif
+	default:	sprintf(_shrtnme, "Unknown");  break;
+	}
+#endif
+
+#ifdef DOS
+	switch	(SP->adapter)
+	{
+	case _CGA:	sprintf(_shrtnme, "CGA");	  break;
+	case _MDA:	sprintf(_shrtnme, "MDA");	  break;
+	case _EGACOLOR:	sprintf(_shrtnme, "EGAColor"); break;
+	case _EGAMONO:	sprintf(_shrtnme, "EGAMono");  break;
+	case _VGACOLOR:	sprintf(_shrtnme, "VGAColor"); break;
+	case _VGAMONO:	sprintf(_shrtnme, "VGAMono");  break;
+	case _MCGACOLOR:sprintf(_shrtnme, "MCGAColor");break;
+	case _MCGAMONO:	sprintf(_shrtnme, "MCGAMono"); break;
+	case _MDS_GENIUS:sprintf(_shrtnme, "Genius");  break;
+	default:	sprintf(_shrtnme, "Unknown");  break;
+	}
+#endif
+
+#ifdef	FLEXOS
+	switch	(SP->adapter)
+	{
+	case _FLEXOS:	sprintf(_shrtnme, "%s", _cursesgname());	  break;
+	default:	sprintf(_shrtnme, "Unknown");  break;
+	}
+#endif
+
+	return (_shrtnme);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char	PDC_CDECL	wordchar(void)
+#else
+char	PDC_CDECL	wordchar()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wordchar() - called\n");
+#endif
+
+#ifdef UNIX
+#ifdef USE_TERMIO
+	ioctl(_CUR_TERM.fd, TCGETA, &_CUR_TERM.prog_mode);
+	return(_CUR_TERM.prog_mode.c_cc[VWERASE]);
+#else
+#ifdef TIOCGLTC
+	ioctl(_CUR_TERM.fd, TIOCGLTC, &_CUR_TERM.prog_mode.bsd_new);
+	return(_CUR_TERM.prog_mode.bsd_new.t_werase);
+#else
+	return(0);
+#endif
+#endif
+#else
+	return (_DWCHAR);			/* word delete char */
+#endif
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/terminfo.c stsgdb-6.8/pdcurses/pdcurses/terminfo.c
--- gdb-6.8/pdcurses/pdcurses/terminfo.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/terminfo.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,404 @@
+/*
+***************************************************************************
+* Copyright (c) 2006 STMicroelectronics
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <term.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	mvcur
+#undef  vidattr
+#undef  vidputs
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_terminfo  = "$Id: terminfo.c,v 1.5 2005/12/25 15:07:09 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                      terminfo
+
+  Synopsis:
+  	int mvcur(int oldrow, int oldcol, int newrow, int newcol);
+  	int del_curterm(TERMINAL *);
+  	int putp(const char *);
+  	int restartterm(char *, int, int *);
+  	TERMINAL *set_curterm(TERMINAL *);
+  	int setupterm(char *, int, int *);
+  	int tgetent(char *, const char *);
+  	int tgetflag(char *);
+  	int tgetnum(char *);
+  	char *tgetstr(char *, char **);
+  	char *tgoto(char *, int, int);
+  	int tigetflag(char *);
+  	int tigetnum(char *);
+  	char *tigetstr(char *);
+  	char *tparm(char *,long, long, long, long, long, long, long, 
+  		long, long);
+  	int tputs(const char *, int, int (*)(int));
+  	int vidattr(chtype attr);
+  	int vidputs(chtype attr, int (*putfunc)(int));
+
+  X/Open Description:
+ 	The mvcur() function controls low-level cursor motion with 
+ 	optimization.
+
+ 	NOTE: The remainer of the terminfo functions have not been
+ 			implemented.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      mvcur                                 Y        Y       Y
+
+**man-end**********************************************************************/
+
+TERMINAL *cur_term = NULL;
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvcur(int oldrow, int oldcol, int newrow, int newcol)
+#else
+int	PDC_CDECL	mvcur(oldrow,oldcol,newrow,newcol)
+int oldrow;
+int oldcol;
+int newrow;
+int newcol;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvcur() - called: oldrow %d oldcol %d newrow %d newcol %d\n",oldrow,oldcol,newrow,newcol);
+#endif
+
+#ifdef	TC
+#  pragma argsused
+#endif
+	if ((newrow >= LINES)	||
+	    (newcol >= COLS)	||
+	    (newrow < 0)	||
+	    (newcol < 0))
+	{
+		return( ERR );
+	}
+	PDC_gotoxy( newrow, newcol );
+	SP->cursrow = newrow;
+	SP->curscol = newcol;
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL del_curterm(TERMINAL *oterm)
+#else
+int     PDC_CDECL del_curterm(oterm)
+TERMINAL *oterm;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("del_curterm() - called\n");
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL putp(const char *str)
+#else
+int     PDC_CDECL putp(str)
+char *str;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("putp() - called: str %s\n", str);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL restartterm(char *term, int filedes, int *errret)
+#else
+int     PDC_CDECL restartterm(term, filedes, errret)
+char *term;
+int filedes;
+int *errret;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("restartterm() - called\n");
+#endif
+	if (errret)
+		*errret = -1;
+
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+TERMINAL* PDC_CDECL set_curterm(TERMINAL *nterm)
+#else
+TERMINAL* PDC_CDECL set_curterm(nterm)
+TERMINAL *nterm;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("set_curterm() - called\n");
+#endif
+	return (TERMINAL *)NULL;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL setterm(char *term)
+#else
+int     PDC_CDECL setterm(term)
+char *term;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("setterm() - called\n");
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL setupterm(char *term, int filedes, int *errret)
+#else
+int     PDC_CDECL setupterm(term, filedes, errret)
+char *term;
+int filedes;
+int *errret;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("setupterm() - called\n");
+#endif
+	if (errret)
+		*errret = -1;
+	else
+		fprintf(stderr, "There is no terminfo database\n");
+
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL tgetent(char *bp, const char *name)
+#else
+int     PDC_CDECL tgetent(bp, name)
+char *bp;
+char *name;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tgetent() - called: name %s\n", name);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL tgetflag(char *id)
+#else
+int     PDC_CDECL tgetflag(id)
+char *id;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tgetflag() - called: id %s\n", id);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL tgetnum(char *id)
+#else
+int     PDC_CDECL tgetnum(id)
+char *id;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tgetnum() - called: id %s\n", id);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*   PDC_CDECL tgetstr(char *id, char **area)
+#else
+char*   PDC_CDECL tgetstr(id, area)
+char *id;
+char **area;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tgetstr() - called: id %s\n", id);
+#endif
+	return (char *)NULL;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*   PDC_CDECL tgoto(char *cap, int col, int row)
+#else
+char*   PDC_CDECL tgoto(cap, col, row)
+char *cap;
+int col;
+int row;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tgoto() - called\n");
+#endif
+	return (char *)NULL;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL tigetflag(char *capname)
+#else
+int     PDC_CDECL tigetflag(capname)
+char *capname;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tigetflag() - called: capname %s\n", capname);
+#endif
+	return -1;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL tigetnum(char *capname)
+#else
+int     PDC_CDECL tigetnum(capname)
+char *capname;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tigetnum() - called: capname %s\n", capname);
+#endif
+	return -2;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*   PDC_CDECL tigetstr(char *capname)
+#else
+char*   PDC_CDECL tigetstr(capname)
+char *capname;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tigetstr() - called: capname %s\n", capname);
+#endif
+	return (char *)(-1);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*   PDC_CDECL tparm(char *cap, long p1, long p2, long p3, long p4, 
+			long p5, long p6, long p7, long p8, long p9)
+#else
+char*   PDC_CDECL tparm(cap, p1, p2, p3, p4, p5, p6, p7, p8, p9)
+char *cap;
+long p1;
+long p2;
+long p3;
+long p4; 
+long p5;
+long p6;
+long p7;
+long p8;
+long p9;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tparm() - called: cap %s\n", cap);
+#endif
+	return (char *)NULL;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int     PDC_CDECL tputs(const char *str, int affcnt, int (*putfunc)(int))
+#else
+int     PDC_CDECL tputs(str, affcnt, putfunc)
+char *str;
+int affcnt;
+int (*putfunc)(int);
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("tputs() - called\n");
+#endif
+/* STMicroelectronics add the implementation of this function when 
+compiled for mingw: next 5 lines*/
+#if defined (__MINGW32__)
+	while (*str)
+	  putfunc (*str++);
+	return OK;
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	vidattr(chtype attr)
+#else
+int	PDC_CDECL	vidattr(attr)
+chtype attr;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("vidattr() - called: attr %d\n", attr);
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	vidputs(chtype attr, int (*putfunc)(int))
+#else
+int	PDC_CDECL	vidputs(attr, putfunc)
+chtype attr;
+int (*putfunc)();
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("vidputs() - called: attr %d\n", attr);
+#endif
+	return ERR;
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/touch.c stsgdb-6.8/pdcurses/pdcurses/touch.c
--- gdb-6.8/pdcurses/pdcurses/touch.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/touch.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,262 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	touchwin
+#undef	touchline
+#undef	untouchwin
+#undef	wtouchln
+#undef	is_linetouched
+#undef	is_wintouched
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	move
+#  undef	wmove
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_touch  = "$Id: touch.c,v 1.1 2001/01/10 08:27:32 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                         touch
+
+  Synopsis:
+  	int touchwin(WINDOW *win);
+  	int touchline(WINDOW *win, int start,int count);
+  	int untouchwin(WINDOW *win);
+  	int wtouchln(WINDOW *win, int y, int n, int changed);
+  	int is_linetouched(WINDOW *win,int line);
+  	int is_wintouched(WINDOW *win);
+
+  X/Open Description:
+ 	The touchwin() and touchline() functions throw away all optimisation 
+ 	information about which parts of the window have been touched, 
+ 	by pretending that the entire window has been drawn on.  
+ 	This is sometimes necessary when using overlapping
+ 	windows, since a change to one window will affect the other window,
+ 	but the records of which lines have been changed in the other
+ 	window will not reflect the change.
+
+ 	The untouchwin() routine marks all lines in the window as unchanged
+ 	since the last call to wrefresh().
+
+ 	The wtouchln() routine makes n lines in the window, starting at 
+ 	line y, look as if they have (changed=1) or have not (changed=0) 
+ 	been changed since the last call to wrefresh().
+
+ 	The is_linetouched() routine returns TRUE if the specified line 
+ 	in the specified window has been changed since the last call to 
+ 	wrefresh(). If the line has not changed, FALSE is returned.
+
+ 	The is_wintouched() routine returns TRUE if the specified window 
+ 	has been changed since the last call to wrefresh(). If the window 
+ 	has not changed, FALSE is returned.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error except
+ 	is_wintouched() and is_linetouched().
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      touchwin                              Y        Y       Y
+      touchline                             Y        -      3.0
+      untouchwin                            -        -      4.0
+      wtouchln                              Y        Y       Y
+      is_linetouched                        -        -      4.0
+      is_wintouched                         -        -      4.0
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	touchwin(WINDOW *win)
+#else
+int	PDC_CDECL	touchwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	register int	i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("touchwin() - called: Win=%x\n",win);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	for (i=0;i<win->_maxy;i++)
+	{
+		win->_firstch[i] = 0;
+		win->_lastch[i] = win->_maxx-1;
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	touchline(WINDOW *win, int start,int count)
+#else
+int	PDC_CDECL	touchline(win,start,count)
+WINDOW *win;
+int start;
+int count;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("touchline() - called: win=%x start %d count %d\n",win,start,count);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if  (start > win->_maxy || start + count > win->_maxy)
+		return( ERR );
+	for(i=start;i<start+count;i++)
+	   {
+		win->_firstch[i] = 0;
+		win->_lastch[i] = win->_maxx - 1;
+	   }
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	untouchwin(WINDOW *win)
+#else
+int	PDC_CDECL	untouchwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("untouchwin() - called: win=%x",win);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	for (i=0;i<win->_maxy;i++)
+	{
+		win->_firstch[i] = _NO_CHANGE;
+		win->_lastch[i] = _NO_CHANGE;
+	}
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	wtouchln(WINDOW *win, int y, int n, int changed)
+#else
+int	PDC_CDECL	wtouchln(win,y,n,changed)
+WINDOW *win;
+int y;
+int n;
+int changed;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wtouchln() - called: win=%x y=%d n=%d changed=%d\n",win,y,n,changed);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if  (y > win->_maxy || y + n > win->_maxy)
+		return( ERR );
+
+	for (i=y;i<y+n;i++)
+	{
+		if ( changed ) 
+		{
+			win->_firstch[i] = 0;
+			win->_lastch[i] = win->_maxx - 1;
+		}
+		else 
+		{
+			win->_firstch[i] = _NO_CHANGE;
+			win->_lastch[i] = _NO_CHANGE;
+		}
+	}
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	is_linetouched(WINDOW *win,int line)
+#else
+int	PDC_CDECL	is_linetouched(win,line)
+WINDOW *win;
+int line;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("is_linetouched() - called: win=%x line=%d\n",win,line);
+#endif
+
+	if (win == NULL)
+		return(ERR);
+
+	if (line > win->_maxy || line < 0)
+		return(ERR);
+	if (win->_firstch[line] != _NO_CHANGE) 
+		return(TRUE);
+	return(FALSE);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	is_wintouched(WINDOW *win)
+#else
+int	PDC_CDECL	is_wintouched(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	register int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("is_wintouched() - called: win=%x\n",win);
+#endif
+
+	if (win == NULL)
+		return(ERR);
+
+	for (i=0;i<win->_maxy;i++)
+		if (win->_firstch[i] != _NO_CHANGE)
+			return(TRUE);
+	return(FALSE);
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/util.c stsgdb-6.8/pdcurses/pdcurses/util.c
--- gdb-6.8/pdcurses/pdcurses/util.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/util.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,462 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#if defined(DOS) && defined(MSC)
+#include <time.h>
+#endif
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
+
+#ifdef OS2
+# ifdef EMXVIDEO
+#include <termios.h>
+# else
+	APIRET APIENTRY DosSleep(ULONG ulTime);
+# endif
+#endif
+
+/* undefine any macros for functions defined in this module */
+#undef	unctrl
+#undef	keyname
+#undef	has_key
+#undef	filter
+#undef	use_env
+#undef	putwin
+#undef	getwin
+#undef	delay_output
+#undef	flushinp
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_util  = "$Id: util.c,v 1.9 2005/12/17 01:03:16 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          util
+
+  Synopsis:
+  	char *unctrl(chtype c);
+  	char *keyname(int key);
+  	void filter(void);
+  	void use_env(bool x);
+  	int putwin(WINDOW *win, FILE *filep);
+  	WINDOW *getwin(FILE *filep);
+  	int delay_output( int ms );
+  	int flushinp(void);
+
+  X/Open Description:
+ 	The unctrl() routine expands the character c into a character
+ 	string which is a printable representation of the character.
+ 	Control characters are displayed in the ^X notation.  Printing
+ 	characters are displayed normally.
+
+ 	The keyname() function returns a pointer to a character string 
+ 	containing a symbolic name corresponding to that specified in 
+ 	the argument key. key may be any key returned by wgetch().
+
+ 	The delay_output() function inserts ms millisecond pause in output.
+ 	On some systems, this has no effect.
+
+ 	The flushinp() routine throws away any type-ahead that has been 
+ 	typed by the user and has not yet been read by the program.
+
+  PDCurses Description:
+ 	The conversion from a control character to a two-character
+ 	sequence is done by the unctrl() function. In the BSD version
+ 	of curses it is done by a macro, which uses a publicly
+ 	available translation table. Some ill-behaved application
+ 	programs use the table directly, and since it does not exist
+ 	in this curses version such application will link with an
+ 	error message complaining about undefined symbols.
+
+ 	If the PDCurses library is compiled under DOS with the FAST_VIDEO
+ 	define true, then we will poke the BIOS keyboard buffer head and
+ 	tail pointers, resetting the typeahead to implement flushinp().
+ 	If this is not true, then we will be unable to reliably flush
+ 	the typeahead.
+
+ 	filter() and use_env() are no-ops on PDCurses. getwin() and 
+ 	putwin() also do nothing yet.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      unctrl                                Y        Y       Y
+      keyname                               Y        -      3.0
+      filter                                Y        -      3.0
+      use_env                               -        -      4.0
+      putwin                                -        -      4.0
+      getwin                                -        -      4.0
+      delay_output                          Y        Y       Y
+      flushinp                              Y        Y       Y
+
+**man-end**********************************************************************/
+
+static char strbuf[3] = {0, 0, 0};
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char*	PDC_CDECL	unctrl(chtype c)
+#else
+char*	PDC_CDECL	unctrl(c)
+chtype c;
+#endif
+/***********************************************************************/
+{
+	chtype	ic = c;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("unctrl() - called\n");
+#endif
+
+	ic &= A_CHARTEXT;
+	if (ic >= 0x20 && ic != 0x7f)		/* normal characters */
+	{
+		strbuf[0] = (char) ic;
+		strbuf[1] = '\0';
+		return( strbuf );
+	}
+	strbuf[0] = '^';	/* '^' prefix */
+	if (c == 0x7f)
+	{
+		/*
+		 * 0x7f == DEL
+		 */
+		strbuf[1] = '?';
+	}
+	else
+	{
+		/*
+		 * other control
+		 */
+		strbuf[1] = (char)(ic + '@');
+	}
+	return( strbuf );
+}
+
+/***********************************************************************/
+
+static char *key_name[] = {
+ "KEY_BREAK","KEY_DOWN","KEY_UP","KEY_LEFT","KEY_RIGHT","KEY_HOME","KEY_BACKSPACE",
+ "KEY_F0","KEY_F(1)","KEY_F(2)","KEY_F(3)","KEY_F(4)","KEY_F(5)",
+ "KEY_F(6)","KEY_F(7)","KEY_F(8)","KEY_F(9)","KEY_F(10)",
+ "KEY_F(11)","KEY_F(12)","KEY_F(13)","KEY_F(14)","KEY_F(15)",
+ "KEY_F(16)","KEY_F(17)","KEY_F(18)","KEY_F(19)","KEY_F(20)",
+ "KEY_F(21)","KEY_F(22)","KEY_F(23)","KEY_F(24)","KEY_F(25)",
+ "KEY_F(26)","KEY_F(27)","KEY_F(28)","KEY_F(29)","KEY_F(30)",
+ "KEY_F(31)","KEY_F(32)","KEY_F(33)","KEY_F(34)","KEY_F(35)",
+ "KEY_F(36)","KEY_F(37)","KEY_F(38)","KEY_F(39)","KEY_F(40)",
+ "KEY_F(41)","KEY_F(42)","KEY_F(43)","KEY_F(44)","KEY_F(45)",
+ "KEY_F(46)","KEY_F(47)","KEY_F(48)","KEY_F(49)","KEY_F(50)",
+ "KEY_F(51)","KEY_F(52)","KEY_F(53)","KEY_F(54)","KEY_F(55)",
+ "KEY_F(56)","KEY_F(57)","KEY_F(58)","KEY_F(59)","KEY_F(60)",
+ "KEY_F(61)","KEY_F(62)","KEY_F(63)",
+ "KEY_DL","KEY_IL","KEY_DC","KEY_IC","KEY_EIC","KEY_CLEAR","KEY_EOS","KEY_EOL",
+ "KEY_SF","KEY_SR","KEY_NPAGE","KEY_PPAGE","KEY_STAB","KEY_CTAB","KEY_CATAB",
+ "KEY_ENTER","KEY_SRESET","KEY_RESET","KEY_PRINT","KEY_LL","KEY_ABORT","KEY_SHELP",
+ "KEY_LHELP","KEY_BTAB","KEY_BEG","KEY_CANCEL","KEY_CLOSE","KEY_COMMAND","KEY_COPY",
+ "KEY_CREATE","KEY_END","KEY_EXIT","KEY_FIND","KEY_HELP","KEY_MARK","KEY_MESSAGE",
+ "KEY_MOVE","KEY_NEXT","KEY_OPEN","KEY_OPTIONS","KEY_PREVIOUS","KEY_REDO",
+ "KEY_REFERENCE","KEY_REFRESH","KEY_REPLACE","KEY_RESTART","KEY_RESUME","KEY_SAVE",
+ "KEY_SBEG","KEY_SCANCEL","KEY_SCOMMAND","KEY_SCOPY","KEY_SCREATE","KEY_SDC","KEY_SDL",
+ "KEY_SELECT","KEY_SEND","KEY_SEOL","KEY_SEXIT","KEY_SFIND","KEY_SHOME","KEY_SIC",
+ "NO KEY NAME",
+ "KEY_SLEFT","KEY_SMESSAGE","KEY_SMOVE","KEY_SNEXT","KEY_SOPTIONS","KEY_SPREVIOUS",
+ "KEY_SPRINT","KEY_SREDO","KEY_SREPLACE","KEY_SRIGHT","KEY_SRSUME","KEY_SSAVE",
+ "KEY_SSUSPEND","KEY_SUNDO","KEY_SUSPEND","KEY_UNDO",
+ "ALT_0","ALT_1","ALT_2","ALT_3","ALT_4","ALT_5","ALT_6","ALT_7","ALT_8","ALT_9",
+ "ALT_A","ALT_B","ALT_C","ALT_D","ALT_E","ALT_F","ALT_G","ALT_H","ALT_I","ALT_J",
+ "ALT_K","ALT_L","ALT_M","ALT_N","ALT_O","ALT_P","ALT_Q","ALT_R","ALT_S","ALT_T",
+ "ALT_U","ALT_V","ALT_W","ALT_X","ALT_Y","ALT_Z","CTL_LEFT","CTL_RIGHT","CTL_PGUP",
+ "CTL_PGDN","CTL_HOME","CTL_END","KEY_A1","KEY_A2","KEY_A3","KEY_B1",
+ "KEY_B2","KEY_B3","KEY_C1","KEY_C2","KEY_C3","PADSLASH","PADENTER","CTL_PADENTER",
+ "ALT_PADENTER","PADSTOP","PADSTAR","PADMINUS","PADPLUS","CTL_PADSTOP",
+ "CTL_PADCENTER","CTL_PADPLUS","CTL_PADMINUS","CTL_PADSLASH","CTL_PADSTAR","ALT_PADPLUS",
+ "ALT_PADMINUS","ALT_PADSLASH","ALT_PADSTAR","ALT_PADSTOP","CTL_INS","ALT_DEL","ALT_INS","CTL_UP",
+ "CTL_DOWN","CTL_TAB","ALT_TAB","ALT_MINUS","ALT_EQUAL","ALT_HOME","ALT_PGUP","ALT_PGDN",
+ "ALT_END","ALT_UP","ALT_DOWN","ALT_RIGHT","ALT_LEFT","ALT_ENTER","ALT_ESC","ALT_BQUOTE",
+ "ALT_LBRACKET","ALT_RBRACKET","ALT_SEMICOLON","ALT_FQUOTE","ALT_COMMA","ALT_STOP",
+ "ALT_FSLASH","ALT_BKSP","CTL_BKSP","PAD0",
+ "CTL_PAD0","CTL_PAD1","CTL_PAD2","CTL_PAD3","CTL_PAD4",
+ "CTL_PAD5","CTL_PAD6","CTL_PAD7","CTL_PAD8","CTL_PAD9",
+ "ALT_PAD0","ALT_PAD1","ALT_PAD2","ALT_PAD3","ALT_PAD4",
+ "ALT_PAD5","ALT_PAD6","ALT_PAD7","ALT_PAD8","ALT_PAD9",
+ "CTL_DEL","ALT_BSLASH","CTL_ENTER","SHF_PADENTER","SHF_PADSLASH",
+ "SHF_PADSTAR","SHF_PADPLUS","SHF_PADMINUS","SHF_UP","SHF_DOWN",
+ "SHF_IC","SHF_DC","KEY_MOUSE",
+ "KEY_SHIFT_L","KEY_SHIFT_R",
+ "KEY_CONTROL_L","KEY_CONTROL_R",
+ "KEY_ALT_L","KEY_ALT_R",
+ "KEY_RESIZE", "KEY_SUP", "KEY_SDOWN"
+};
+/***********************************************************************/
+#ifdef HAVE_PROTO
+char *	PDC_CDECL	keyname(int key)
+#else
+char *	PDC_CDECL	keyname(key)
+int key;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("keyname() - called: key %d\n",key);
+#endif
+	key -= KEY_MIN;
+	if (key >= 0
+	&& key <= (int)(sizeof(key_name) / sizeof(key_name[0])) )
+		return( key_name[key] );
+	else
+		return("NO KEY NAME");
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool 	PDC_CDECL 	has_key(int key)
+#else
+bool	PDC_CDECL	has_key(key)
+int key;
+#endif
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("has_key() - called: key %d\n",key);
+#endif
+	key -= KEY_MIN;
+	return key >= 0
+	    && key <= (int)(sizeof(key_name) / sizeof(key_name[0]));
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	filter(void)
+#else
+void	PDC_CDECL	filter()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("filter() - called\n");
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	use_env( bool x )
+#else
+void	PDC_CDECL	use_env(x)
+bool x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("use_env() - called: x %d\n",x);
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	putwin(WINDOW *win, FILE *filep)
+#else
+int	PDC_CDECL	putwin(win, filep)
+WINDOW *win;
+FILE *filep;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("putwin() - called\n");
+#endif
+	return ERR;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	getwin(FILE *filep)
+#else
+WINDOW*	PDC_CDECL	getwin(filep)
+FILE *filep;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("getwin() - called\n");
+#endif
+	return (WINDOW *)NULL;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	delay_output( int ms )
+#else
+int	PDC_CDECL	delay_output(ms)
+int ms;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("delay_output() - called: ms %d\n",ms);
+#endif
+
+#if (defined(TC) || defined(__WATCOMC__)) && defined(DOS)
+	delay( ms );
+	return( OK );
+#endif
+
+#if defined(WIN32) || defined(PC)
+	PDC_usleep( ms );
+	return( OK );
+#endif
+
+#if	defined(OS2)
+# if defined(EMX)
+	_sleep2(ms);
+# else
+	DosSleep(ms);
+# endif
+	return( OK );
+#endif
+
+#if	defined(DOS) && defined(MSC)
+	PDC_usleep((clock_t)ms);
+	return( OK );
+#endif
+
+#if	defined(DOS) && defined(NDP)
+	clock_t goal;
+	goal = ms + (float)( (float)clock()/(float)CLOCKS_PER_SEC )*1000;
+	while (goal > (float)( (float)clock()/(float)CLOCKS_PER_SEC )*1000)
+	;
+	return( OK );
+#endif
+
+#if defined(UNIX) || defined(__DJGPP__)
+	usleep(1000*ms);
+	return( OK );
+#endif
+
+#if defined(XCURSES)
+	PDC_usleep(ms*1000);
+	return( OK );
+#endif
+
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	flushinp(void)
+#else
+int	PDC_CDECL	flushinp()
+#endif
+/***********************************************************************/
+{
+extern int	c_pindex;		/* putter index */
+extern int	c_gindex;		/* getter index */
+extern int	c_ungind;		/* wungetch() push index */
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("flushinp() - called\n");
+#endif
+
+#if defined(DOS) && defined(FAST_VIDEO)
+	setdosmemword (0x41a, getdosmemword (0x41c)); /* Force the BIOS kbd buf       */
+					/* head/tail pointers to be the */
+					/* same...  Real nasty trick... */
+#  if defined(NDP)
+/*
+	int *KB_HEAD = (int *) mapdev( 0x041aL, sizeof(short) );
+	int *KB_TAIL = (int *) mapdev( 0x041cL, sizeof(short) );
+
+	memcpy( KB_HEAD, KB_TAIL, sizeof(short) );
+*/
+#  endif
+#endif
+
+#ifdef OS2
+#  ifdef EMXVIDEO
+	tcflush(0,TCIFLUSH);
+#  else
+	KbdFlushBuffer(0);
+#  endif
+#endif
+
+#ifdef UNIX
+/* INCOMPLETE */
+#endif
+
+#ifdef XCURSES
+	while(XCurses_kbhit())
+		(void)XCurses_rawgetch(0);
+#endif
+
+	c_gindex = 1;			/* set indices to kill buffer	 */
+	c_pindex = 0;
+	c_ungind = 0;			/* clear c_ungch array		 */
+	return( OK );
+}
+
+#undef traceon
+#undef traceoff
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	traceon(void)
+#else
+void	PDC_CDECL	traceon()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("traceon() - called\n");
+#endif
+	trace_on = TRUE;
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	traceoff(void)
+#else
+void	PDC_CDECL	traceoff()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("traceoff() - called\n");
+#endif
+	trace_on = FALSE;
+	return;
+}
diff -Naur gdb-6.8/pdcurses/pdcurses/window.c stsgdb-6.8/pdcurses/pdcurses/window.c
--- gdb-6.8/pdcurses/pdcurses/window.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/pdcurses/window.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,764 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	newwin
+#undef	delwin
+#undef	mvwin
+#undef	subwin
+#undef	derwin
+#undef	mvderwin
+#undef	dupwin
+#undef	wsyncup
+#undef	syncok
+#undef	wcursyncup
+#undef	wsyncdown
+#undef	wresize
+#undef	resize_window
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#  undef	touchwin
+#  undef	wmove
+#  undef	overwrite
+#  undef	wmove
+#  undef	wclrtobot
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_window  = "$Id: window.c,v 1.6 2005/12/25 22:01:30 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                        window
+
+  Synopsis:
+  	WINDOW *newwin(int nlines, int ncols, int begy, int begx);
+  	int delwin(WINDOW *win);
+  	int mvwin(WINDOW *win, int y, int x);
+  	WINDOW *subwin(WINDOW* orig,int nlines,int ncols,
+  			int begin_y,int begin_x);
+  	WINDOW *derwin(WINDOW* orig,int nlines,int ncols,
+  			int begin_y,int begin_x);
+  	int mvderwin(WINDOW *win, int par_y, int par_x);
+  	int dupwin(WINDOW *win);
+  	void wsyncup(WINDOW *win);
+  	int syncok(WINDOW *win, bool bf);
+  	void wcursyncup(WINDOW *win);
+  	void wsyncdown(WINDOW *win);
+
+  	WINDOW *resize_window(WINDOW *w, int lins, int cols);
+
+  X/Open Description:
+ 	newwin() creates a new window with the given number of lines,
+ 	nlines and columns, ncols. The upper left corner of the window is
+ 	at line begy, column begx. If either nlines or ncols is zero,
+ 	they will be defaulted to LINES - begy and COLS - begx. A
+ 	new full-screen window is created by calling newwin(0, 0, 0, 0).
+
+ 	delwin() deletes the named window, freeing all memory associated
+ 	with it. In the case of overlapping windows, subwindows should be
+ 	deleted before the main window.
+
+ 	mvwin() moves the window so that the upper left-hand corner is at
+ 	position (y,x). If the move would cause the window to be off the
+ 	screen, it is an error and the window is not moved. Moving subwindows
+ 	is allowed, but should be avoided. (I don't know why ?).
+
+ 	subwin() creates a new sub-window within a window.  The
+ 	dimensions of the sub-window are nlines lines and ncols
+ 	columns.  The sub-window is at position (begin_y, begin_x) on
+ 	the screen.  This position is relative to the screen, and not
+ 	to the window orig.
+ 	The sub-window is made in the middle of the window orig, so
+ 	that changes made to either window will affect both.  When
+ 	using this routine, it will often be necessary to call
+ 	touchwin() before calling wrefresh().
+
+ 	derwin() is the same as subwin(), except that begin_y and
+ 	begin_x are relative to the origin of the window orig rather than
+ 	the screen.  There is no difference between subwindows and derived
+ 	windows.
+
+ 	mvderwin() moves a derived window (or subwindow) inside its
+ 	parent window.  The screen-relative parameters of the window are not
+ 	changed.  This routine is used to display different parts of the parent
+ 	window at the same physical position on the screen.
+
+ 	dupwin() creates an exact duplicate of the window win.
+
+ 	wsyncup() causes a touchwin() of all of the window's parents.
+
+ 	If wsyncok() is called with a second argument of TRUE, this causes
+ 	a wsyncup() to be called every time the window is changed.
+
+ 	wcursyncup() causes the current cursor position of all of a window's
+ 	ancestors to reflect the current cursor position of the current window.
+
+ 	wsyncdown() causes a touchwin() of the current window if any of
+ 	its parent's windows have been touched.
+
+  PDCurses Description:
+ 	resize_window() allows the usrer to resize an existing window.
+
+  X/Open Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  X/Open Errors:
+ 	No errors are defined for this function.
+
+  PDCurses Errors:
+ 	It is an error to call resize_window() before calling initscr().
+ 	Also, an error will be generated if we fail to create a newly
+ 	sized replacement window for curscr, or stdscr.
+ 	This will typically happen when increasing the window size.
+
+ 	NOTE:  If this happens, the previously successfully allocated
+ 	windows are left alone.  i.e. The resize is NOT cancelled for
+ 	those windows.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      newwin                                Y        Y       Y
+      delwin                                Y        Y       Y
+      mvwin                                 Y        Y       Y
+      subwin                                Y        Y       Y
+      derwin                                Y        -       Y
+      mvderwin                              Y        -       Y
+      dupwin                                -        -      4.0
+      wsyncup                               -        -      4.0
+      syncok                                -        -      4.0
+      wcursyncup                            -        -      4.0
+      wsyncdown                             -        -      4.0
+      resize_window                         -        -       -
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	newwin(int nlines, int ncols, int begy, int begx)
+#else
+WINDOW*	PDC_CDECL	newwin(nlines,ncols,begy,begx)
+int nlines;
+int ncols;
+int begy;
+int begx;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void*	(*callc)( size_t, size_t );
+extern	void	(*fre)( void* );
+#else
+extern	void*	(*callc)();
+extern	void	(*fre)();
+#endif
+
+	WINDOW*	win;
+	chtype*	ptr;
+	int	i;
+	int	j;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("newwin() - called:lines=%d cols=%d begy=%d begx=%d\n",nlines,ncols,begy,begx);
+#endif
+
+	if (nlines == 0)	nlines = LINES - begy;
+	if (ncols  == 0)	ncols  = COLS  - begx;
+
+	if (begy + nlines > SP->lines
+	||  begx + ncols > SP->cols)
+		return( (WINDOW *)NULL );
+
+	if ((win = PDC_makenew(nlines, ncols, begy, begx)) == (WINDOW *) NULL)
+		return( (WINDOW *)NULL );
+
+	for (i = 0; i < nlines; i++)
+	{
+		/*
+		 * make and clear the lines
+		 */
+		if ((win->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
+		{
+			for (j = 0; j < i; j++)
+			{
+				/*
+				 * if error, free all the data
+				 */
+				(*fre)(win->_y[j]);
+			}
+			(*fre)(win->_firstch);
+			(*fre)(win->_lastch);
+			(*fre)(win->_y);
+			(*fre)(win);
+			return( (WINDOW *)NULL );
+		}
+		else
+		{
+			for (ptr = win->_y[i];
+			     ptr < win->_y[i] + ncols;)
+			{
+				/*
+				 * Retain the original screen attributes...
+				 */
+				*ptr++ = SP->blank;
+			}
+		}
+	}
+#ifdef UNIX
+	PDC_gotoxy(begy, begx);
+#endif
+	return( win );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	delwin(WINDOW *win)
+#else
+int	PDC_CDECL	delwin(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void	(*fre)( void* );
+#else
+extern	void	(*fre)();
+#endif
+	int	i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("delwin() - called\n");
+#endif
+
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+#ifdef	REGISTERWINDOWS
+	_rmwin(win);		/* Remove from the visible windows list... */
+#endif
+
+	/*
+	 * FYI:  Subwindow's use 'parent's' lines
+	 */
+	if (!(win->_flags & _SUBWIN)
+	&&  !(win->_flags & _SUBPAD))
+	{
+		for (i = 0; i < win->_pmaxy && win->_y[i]; i++)
+		{
+			if (win->_y[i] != NULL)
+				(*fre)(win->_y[i]);
+		}
+	}
+	(*fre)(win->_firstch);
+	(*fre)(win->_lastch);
+	(*fre)(win->_y);
+	(*fre)(win);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvwin(WINDOW *win, int y, int x)
+#else
+int	PDC_CDECL	mvwin(win,y,x)
+WINDOW *win;
+int y;
+int x;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("mvwin() - called\n");
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if (y + win->_maxy > LINES || y < 0)
+		return( ERR );
+
+	if (x + win->_maxx > COLS || x < 0)
+		return( ERR );
+
+	win->_begy = y;
+	win->_begx = x;
+	touchwin(win);
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	subwin(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
+#else
+WINDOW*	PDC_CDECL	subwin(orig,nlines,ncols,begin_y,begin_x)
+WINDOW* orig;
+int nlines;
+int ncols;
+int begin_y;
+int begin_x;
+#endif
+/***********************************************************************/
+{
+	WINDOW*	win;
+	int	i;
+	int	j = begin_y - orig->_begy;
+	int	k = begin_x - orig->_begx;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("subwin() - called: lines %d cols %d begy %d begx %d\n",nlines,ncols,begin_y,begin_x);
+#endif
+
+	if (!orig)
+		return( (WINDOW *)NULL );
+
+	/*
+	 * make sure window fits inside the original one
+	 */
+	if ((begin_y < orig->_begy) ||
+	    (begin_x < orig->_begx) ||
+	    (begin_y + nlines) > (orig->_begy + orig->_maxy) ||
+	    (begin_x + ncols)  > (orig->_begx + orig->_maxx))
+	{
+		return( (WINDOW *)NULL );
+	}
+	if (!nlines)	nlines = orig->_maxy - 1 - j;
+	if (!ncols)	ncols  = orig->_maxx - 1 - k;
+	if ((win = PDC_makenew(nlines, ncols, begin_y, begin_x)) == (WINDOW *) NULL)
+	{
+		return( (WINDOW *)NULL );
+	}
+
+	/*
+	 * initialize window variables
+	 */
+	win->_attrs	= orig->_attrs;
+/* wrs (4/10/93) -- account for window background */
+	win->_bkgd	= orig->_bkgd;
+	win->_leaveit	= orig->_leaveit;
+	win->_scroll	= orig->_scroll;
+	win->_nodelay	= orig->_nodelay;
+	win->_use_keypad	= orig->_use_keypad;
+	win->_immed	= orig->_immed;
+	win->_sync	= orig->_sync;
+	win->_pary	= j;
+	win->_parx	= k;
+	win->_parent	= orig;
+
+	for (i = 0; i < nlines; i++)
+	{
+		win->_y[i] = (orig->_y[j++]) + k;
+	}
+
+	win->_flags |= _SUBWIN;
+	return (win);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	derwin(WINDOW* orig,int nlines,int ncols,int begin_y,int begin_x)
+#else
+WINDOW*	PDC_CDECL	derwin(orig,nlines,ncols,begin_y,begin_x)
+WINDOW* orig;
+int nlines;
+int ncols;
+int begin_y;
+int begin_x;
+#endif
+/***********************************************************************/
+{
+	if (orig == (WINDOW *)NULL)
+		return( (WINDOW *)ERR );
+
+	return subwin(orig, nlines, ncols, begin_y+orig->_begy, begin_x+orig->_begx);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	mvderwin( WINDOW* win, int par_y, int par_x )
+#else
+int	PDC_CDECL	mvderwin(win,par_y,par_x)
+WINDOW* win;
+int par_y;
+int par_x;
+#endif
+/***********************************************************************/
+{
+	int i, j;
+	WINDOW *mypar;
+
+	if (win == (WINDOW *)NULL)
+		return( ERR );
+
+	if( win->_parent == NULL )
+		return( ERR );
+
+	mypar = win->_parent;
+
+	if( par_y < 0 || par_x < 0 ||
+		(par_y + win->_maxy) > mypar->_maxy ||
+		(par_x + win->_maxx) > mypar->_maxx )
+	{
+		return( ERR );
+	}
+
+	j = par_y;
+	for (i = 0; i < win->_maxy; i++)
+	{
+		win->_y[i] = (mypar->_y[j++]) + par_x;
+	}
+
+	win->_pary	= par_y;
+	win->_parx	= par_x;
+
+	return( OK );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW*	PDC_CDECL	dupwin( WINDOW* win )
+#else
+WINDOW*	PDC_CDECL	dupwin(win)
+WINDOW* win;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void*	(*callc)( size_t, size_t );
+extern	void	(*fre)( void* );
+#else
+extern	void*	(*callc)();
+extern	void	(*fre)();
+#endif
+
+	WINDOW* new;
+	chtype* ptr;
+	chtype* ptr1;
+	int nlines, ncols, begy, begx;
+	int	i;
+	int	j;
+
+	if (!win)
+		return( (WINDOW *)NULL );
+
+	nlines	= win->_maxy;
+	ncols	= win->_maxx;
+	begy	= win->_begy;
+	begx	= win->_begx;
+
+	if ((new = PDC_makenew(nlines, ncols, begy, begx)) == (WINDOW *) NULL)
+		return( (WINDOW *)NULL );
+
+/* copy the contents of win into new */
+
+	for (i = 0; i < nlines; i++)
+	{
+		if ((new->_y[i] = (*callc)(ncols, sizeof(chtype))) == NULL)
+		{
+			for (j = 0; j < i; j++)
+			{
+				/*
+				 * if error, free all the data
+				 */
+				(*fre)(new->_y[j]);
+			}
+			(*fre)(new->_firstch);
+			(*fre)(new->_lastch);
+			(*fre)(new->_y);
+			(*fre)(new);
+			return( (WINDOW *)NULL );
+		}
+		else
+		{
+			for (ptr = new->_y[i], ptr1 = win->_y[i];
+			     ptr < new->_y[i] + ncols;)
+			{
+				*ptr++ = *ptr1++;
+			}
+		}
+	}
+
+	new->_curx = win->_curx;
+	new->_cury = win->_cury;
+	new->_maxy = win->_maxy;
+	new->_maxx = win->_maxx;
+	new->_pmaxy = win->_pmaxy;
+	new->_pmaxx = win->_pmaxx;
+	new->_begy = win->_begy;
+	new->_begx = win->_begx;
+	new->_lastpy = win->_lastpy;
+	new->_lastpx = win->_lastpx;
+	new->_lastsy1 = win->_lastsy1;
+	new->_lastsx1 = win->_lastsx1;
+	new->_lastsy2 = win->_lastsy2;
+	new->_lastsx2 = win->_lastsx2;
+	new->_flags = win->_flags;
+	new->_attrs = win->_attrs;
+	new->_tabsize = win->_tabsize;
+	new->_clear = win->_clear;
+	new->_leaveit = win->_leaveit;
+	new->_scroll = win->_scroll;
+	new->_nodelay = win->_nodelay;
+	new->_use_keypad = win->_use_keypad;
+	new->_use_idl = win->_use_idl;
+	new->_use_idc = win->_use_idc;
+	new->_tmarg = win->_tmarg;
+	new->_bmarg = win->_bmarg;
+	new->_title = win->_title;
+	new->_title_ofs = win->_title_ofs;
+	new->_title_attr = win->_title_attr;
+	new->_blank = win->_blank;
+	new->_parx = win->_parx;
+	new->_pary = win->_pary;
+	new->_parent = win->_parent;
+	new->_bkgd = win->_bkgd;
+
+	for (i = 0; i < nlines; i++)
+	{
+		new->_firstch[i] = 0;
+		new->_lastch[i] = ncols - 1;
+	}
+
+	new->_flags = win->_flags;
+
+	return( new );
+
+}
+#if 0
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int PDC_CDECL wresize(WINDOW **win, int lins, int cols)
+#else
+int PDC_CDECL wresize(win, lins, cols)
+WINDOW **win;
+int lins;
+int cols;
+#endif
+/***********************************************************************/
+{
+  WINDOW* new;
+  new = resize_window(*win, lins ,cols);
+  if (!new)
+    return ERR;
+  *win = new;
+  return OK;
+}
+#endif
+/***********************************************************************/
+#ifdef HAVE_PROTO
+WINDOW *	PDC_CDECL	resize_window(WINDOW *win, int lins, int cols)
+#else
+WINDOW *	PDC_CDECL	resize_window(win,lins,cols)
+WINDOW *win;
+int lins;
+int cols;
+#endif
+/***********************************************************************/
+{
+#ifdef HAVE_PROTO
+extern	void*	(*callc)( size_t, size_t );
+extern	void	(*fre)( void* );
+#else
+extern	void*	(*callc)();
+extern	void	(*fre)();
+#endif
+
+	WINDOW*	new;
+	int	i;
+	int	j;
+	int	save_cury, save_curx;
+	int	new_begy=0,new_begx=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("resize_window() - called: lins %d cols %d\n",lins,cols);
+#endif
+
+	if (win == (WINDOW *)NULL)
+		return( (WINDOW *)NULL );
+
+	if (win == SP->slk_winptr)
+	{
+		new_begy = SP->lines-SP->slklines;
+		new_begx = 0;
+	}
+	else
+	{
+		new_begy = win->_begy;
+		new_begx = win->_begx;
+	}
+
+	if ((new = PDC_makenew(lins, cols, new_begy, new_begx)) == (WINDOW *)NULL)
+		return( (WINDOW *)NULL );
+
+	new->_curx = min(win->_curx,new->_maxx);
+	new->_cury = min(win->_cury,new->_maxy);
+	new->_flags = win->_flags;
+	new->_attrs = win->_attrs;
+	new->_tabsize = win->_tabsize;
+	new->_clear = win->_clear;
+	new->_leaveit = win->_leaveit;
+	new->_scroll = win->_scroll;
+	new->_nodelay = win->_nodelay;
+	new->_use_keypad = win->_use_keypad;
+	new->_tmarg = (win->_tmarg > new->_maxy-1) ? 0 : win->_tmarg;
+	new->_bmarg = (win->_bmarg == win->_maxy-1) ? new->_maxy-1 : min(win->_bmarg,(new->_maxy-1));
+	new->_title = win->_title;
+	new->_title_ofs = win->_title_ofs;
+	new->_title_attr = win->_title_attr;
+	new->_parent = win->_parent;
+	new->_immed = win->_immed;
+	new->_sync = win->_sync;
+
+	for (i = 0; i < lins; i++)
+	{
+		/*
+		 * make and clear the lines
+		 */
+		if ((new->_y[i] = (chtype*)(*callc)(cols, sizeof(chtype))) == NULL)
+		{
+			for (j = 0; j < i; j++)
+			{
+				/*
+				 * if error, free all the data
+				 */
+				(*fre)(new->_y[j]);
+			}
+			(*fre)(new->_firstch);
+			(*fre)(new->_lastch);
+			(*fre)(new->_y);
+			(*fre)(new);
+			return( (WINDOW *)NULL );
+		}
+		new->_firstch[i] = new->_lastch[i] = _NO_CHANGE;
+	}
+
+	if (win != curscr
+	&&  win != SP->slk_winptr)
+	{
+		copywin(win, new, 0, 0, 0, 0, min(win->_maxy,new->_maxy), min(win->_maxx,new->_maxx),FALSE);
+		if (new->_maxy > win->_maxy)
+		{
+			save_cury = new->_cury;
+			save_curx = new->_curx;
+			wmove(new, new->_maxy - 1, 0);
+			wclrtobot(new);
+			new->_cury = save_cury;
+			new->_curx = save_curx;
+		}
+#if 0
+/* JGB box uses defaults if arguments are zero, but we don't want to do
+   this if the window currently has no box */
+		if (win->_borderchars[0] || win->_borderchars[2])
+			box(new, win->_borderchars[0], win->_borderchars[2]);
+#endif
+	}
+
+
+	delwin(win);
+	return(new);
+
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wsyncup(WINDOW *win)
+#else
+void	PDC_CDECL	wsyncup(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	WINDOW *tmp;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wsyncup() - called\n");
+#endif
+
+	for (tmp = win; tmp != (WINDOW *)NULL; tmp = tmp->_parent)
+	{
+		touchwin(tmp);
+	}
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_CDECL	syncok(WINDOW *win, bool bf)
+#else
+int	PDC_CDECL	syncok(win,bf)
+WINDOW *win;
+bool bf;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("syncok() - called\n");
+#endif
+	if (win == (WINDOW *)NULL)
+		return(ERR);
+
+	win->_sync = bf;
+	return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wcursyncup(WINDOW *win)
+#else
+void	PDC_CDECL	wcursyncup(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	WINDOW *tmp;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wcursyncup() - called\n");
+#endif
+
+	for( tmp = win; (tmp != (WINDOW *)NULL) && (tmp->_parent != (WINDOW *)NULL); tmp = tmp->_parent )
+	{
+		wmove( tmp->_parent, tmp->_pary + tmp->_cury, tmp->_parx + tmp->_curx );
+	}
+	return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_CDECL	wsyncdown(WINDOW *win)
+#else
+void	PDC_CDECL	wsyncdown(win)
+WINDOW *win;
+#endif
+/***********************************************************************/
+{
+	WINDOW *tmp;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("wsyncdown() - called\n");
+#endif
+
+	for (tmp = win; tmp != (WINDOW *)NULL; tmp = tmp->_parent)
+	{
+		if (is_wintouched(tmp))
+		{
+			touchwin(win);
+			break;
+		}
+	}
+	return;
+}
diff -Naur gdb-6.8/pdcurses/README stsgdb-6.8/pdcurses/README
--- gdb-6.8/pdcurses/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/README	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,42 @@
+
+                        Welcome to PDCurses
+
+ PDCurses is an independent reimplementation of System VR4 curses for 
+ multiple platforms. The latest version can be found at:
+
+   http://pdcurses.sourceforge.net/
+
+
+ Legal Stuff
+ -----------
+ The core curses package is Public Domain, but small portions of this 
+ package are subject to various copyright conditions.  Each directory 
+ in this package contains a README file. In each of these README files 
+ is a section titled "Distribution Status" which describes the 
+ distribution status of the files within that directory.
+
+ Although the core PDCurses package is Public Domain, mention of PDCurses
+ in the documentation of packages linked with it is greatly appreciated.
+
+
+ Ports
+ -----
+
+ PDCurses has been ported to DOS, OS/2, WIN32 and X11. A directory
+ containing the port-specific source files exists for each of these 
+ platforms.
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory contain core PDCurses functionality;
+ therefore all files are released to the Public Domain.
+
+
+ Maintainer
+ ----------
+
+ The PDCurses package (and its predecessors) have had various 
+ maintainers over the years.  The contact details of the current
+ maintainer of the package are listed in the file; maintain.er
diff -Naur gdb-6.8/pdcurses/readme.20 stsgdb-6.8/pdcurses/readme.20
--- gdb-6.8/pdcurses/readme.20	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.20	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,148 @@
+
+                             PDCurses 2.0
+                  (Public Domain Curses for DOS and OS/2)
+
+
+INTRODUCTION:
+
+	Well, here it finally is; PDCurses v2.0.
+	
+	PDCurses v2.0 is an almost total rewrite of PCCurses 1.4 done by John
+	'Frotz' Fa'atuai, the previous maintainer.
+	
+	This version has been tested with Microsoft C v6.0, QuickC v2.0 and
+	Borland C++ 2.0 under DOS and Microsoft C v6.0 and TopSpeed c v3.02
+	under OS/2 2.0. Also the library has been compiled successfully with
+	emx 0.8e, C Set/2 and Watcom 9.
+	Most testing was done with the large memory model where applicable.
+	The large memory model is probably the best model to use.
+	
+	The amount of testing has not been as extensive as I would have
+	liked, but demands on releasing a product have outweighed the
+	product's quality. Nothing new with that !!
+	Hopefully with wider circulation, more bugs will be fixed more quickly.
+	
+	I have included just 1 makefile which is suitable for dmake 3.8 for
+	both DOS and OS/2. The makefile does not rely on customisation of the
+	dmake.ini file.
+	
+	If you discover bugs, and especially if you have fixes, please let me
+	know ASAP.
+	
+	The source to the library is distributed as a zip file made with zip
+	1.9. You will need Info-ZIP unzip 5.0 to unzip.
+	Follow the directions below to compile the library.
+
+DIRECTIONS:
+
+	1.Create a new directory in which to unzip pdcurs20.zip. This will
+	  create a curses directory and a number of subdirectories containing
+	  source code for the library and utilities and the documentation.
+
+	2.Make changes to the makefile where necessary:
+	  Change the MODEL or model macro to the appropriate value (if it
+	  applies to your compiler). Use model for Borland compilers.
+
+	  Change any paths in the defined macros to be suitable for your
+	  compiler.
+
+	3.Invoke DMAKE [-e environment_options] [target]
+	
+	  where environment_options are:
+
+		OS (host operating system)
+		COMP (compiler)
+		OPT (optimised version or debug version) - optional. default Y
+		TOS (target operating system) - optional. default OS
+
+		see the makefile for valid combinations
+
+		targets: all, demos, lcursesd.lib, manual...
+		
+		NB. dmake is case sensitive with targets, so those environments
+		that use an upper case model value (eg MSC) MUST specify the
+		library target as for eg. Lcursesd.lib
+
+		The makefile is by default set up for Borland C++. The use of
+		-e environment_options override these defaults. Of you prefer
+		you can just change the defaults in the makefile and invoke it
+		without the -e switch.
+
+OTHER NOTES:
+
+	The documentation for the library is built into each source file,
+	a couple of specific doc files and the header files. A program is
+	supplied (manext) to build the manual. This program gets compiled
+	when you build the documentation.
+	
+	To generate the library response file correctly, I had to write a
+	quick and dirty program (buildlrf) to achive this. Originally the
+	makefiles just had statements like: "echo -+$(OBJ)\$* & >> $(LRF)"
+	which appended a suitable line to the response file. Unfortunately
+	under some combinations of makefiles and command processors (eg.
+	nmake and 4DOS) the & would get treated as stderr and the echo
+	command would fail.
+	
+	The original source for PDCurses that I received from the previous
+	maintainer contained support for the FLEXOS operating system. Not
+	having access to it, I could not test the changes I made so its
+	support has fallen by the wayside. If you really need to have PDCurses
+	running under FLEXOS, contact me and I will see what can be arranged.
+	
+	Under DOS, by default, screen writes to a CGA monitor are done via
+	the video BIOS rather than by direct video memory writes. This is
+	due to the CGA "snow" problem. If you have a CGA monitor and do not
+	suffer from snow, you can compile private\_queryad.c with CGA_DIRECT
+	defined. This will then use cause PDCurses to write directly to the
+	CGA video memory.
+
+COMPILER-SPECIFIC NOTES:
+
+	Microsoft C
+	-----------
+	It is possible with MSC 6.0 to build the OS/2 libraries and demo
+	programs from within DOS. This is the only case where it is possible
+	to specifiy the value of TOS on the command line to be OS2 and the
+	value of OS be DOS.
+
+	C Set/2
+	-------
+	I have only tested the library using the migration libraries. I doubt
+	that the demo programs will work without them.
+
+	emx
+	---
+	Testing has been done with 0.8e of emx together with the 16_to_32
+	libraries.
+	The emx\lib directory should include the vio32.lib and kbd32.lib
+	libraries from the 16_to_32 package.
+
+BUGS and UNFINISHED BUSINESS:
+
+	PDC_set_ctrl_break() function does not work under OS/2.
+	win_print() and PDC_print() do not work under OS/2.
+	The file todo.man in the doc directory also lists those functions of
+	System V 3.2 curses not yet implemented. Any volunteers ?
+
+ACKNOWLEGEMENTS:
+
+	John 'Frotz' Fa'atuai, the previous maintainer for providing an
+	excellent base for further development.
+	John Burnell (johnb@kea.am.dsir.govt.nz), for the OS/2 port.
+	John Steele, Jason (finally NOT a John) Shumate....
+	for various fixes and suggestions.
+	Eberhardt Mattes (author of emx) for allowing code based on his
+	C library to be included with PDCurses.
+	Several others for their support, moral and actual.
+
+
+Good luck, Mark
+
+------------------------------------------------------------------------
+Mark Hessling                         Email: M.Hessling@qut.edu.au
+36 David Road                         Phone: +617 849 7731
+Holland Park                          Fax:   
+Brisbane                              ***** PDCurses Maintainer *****
+QLD 4121                              ******** Author of THE ********
+Australia                             ******** Member RexxLA ********
+------------------------------------------------------------------------
diff -Naur gdb-6.8/pdcurses/readme.21 stsgdb-6.8/pdcurses/readme.21
--- gdb-6.8/pdcurses/readme.21	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.21	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,109 @@
+
+                             PDCurses 2.1
+                  (Public Domain Curses for DOS, OS/2 and UNIX)
+
+
+INTRODUCTION:
+
+	The first thing that obviously needs mentioning is the title above.
+	The current code contains bug fixes for the DOS and OS/2 releases
+	and also includes an alpha release for Unix. The Unix release uses
+	another public domain package (mytinfo) to handle the low-level
+	screen writes. mytinfo was posted to comp.sources.unix (or misc) in
+	December 1992 or January 1993. Unless you are a glutton for punishment
+	I would recommend you avoid the Unix port at this stage.
+	
+	The other major addition to PDCurses is the support for DJGPP (the
+	DOS port of GNU C++). Thanks to David Nugent (davidn@csource.oz.au).
+	
+	Other additions are copywin() function, function debugging support
+	and getting the small and medium memory models to work.
+	The testcurs.c demo program has also been changed significantly and
+	a new demo program, tuidemo, has been added.
+	
+	Some people have suggested including information on where to get
+	dmake from. oak.oakland.edu in /pub/msdos/c
+	
+OTHER NOTES:
+	
+	Under DOS, by default, screen writes to a CGA monitor are done via
+	the video BIOS rather than by direct video memory writes. This is
+	due to the CGA "snow" problem. If you have a CGA monitor and do not
+	suffer from snow, you can compile private\_queryad.c with CGA_DIRECT
+	defined. This will then use cause PDCurses to write directly to the
+	CGA video memory.
+
+	Function debugging: Firstly to get function debugging, you have to
+	compile the library with OPT=N in the makefile. This also turns on
+	compiler debugging. You can control when you want PDCurses to write
+	to the debug file (called trace in the current directory) by using
+	the functions traceon() and traceoff() in your program.
+
+	Microsoft C 6.00 Users note:
+	----------------------------
+	With the addition of several new functions, using dmake to compile 
+	PDCurses now causes the compiler to run "out of heap space in pass 2".
+	Using the 6.00AX version (DOS-Extended) to compile PDCurses fixes
+	this problem; hence the -EM switch.
+
+	Functional changes
+	------------------
+	A few curses functions have been fixed to exhibit their correct 
+	behaviour and make them more functionally portable with System V
+	curses.
+	The functions that have changed are overlay(), overwrite() and
+	typeahead.
+
+	overlay() and overwrite()
+	Both of theses functions in PDCurses 2.0 allowed for one window to
+	be effectively placed on top of another, and the characters in the
+	first window were overlayed or overwritten starting at 0,0 in both
+	windows. This behaviour of these functions was not correct. These
+	functions only operate on windows that physically overlap with
+	respect to the displayed screen. To achieve the same functionality
+	as before, use the new function copywin(). See the manual page for
+	further details.
+
+	typeahead()
+	This function in PDCurses 2.0 effectively checked to see if there
+	were any characters remaining in the keyboard buffer. This is not
+	the behaviour exhibited by System V curses. This function is intended
+	purely to set a flag so that curses can check while updating the
+	physical screen if any keyboard input is pending. To achieve the
+	same effect with typeahead() under PDCurses 2.1 the following code 
+	should be used.
+
+	In place of...
+
+		while(!typeahead(stdin))
+		 {
+			/* do something until any key is pressed... */
+		 }
+
+	use...
+
+		nodelay(stdscr,TRUE); /* getch() to return ERR if no key pending */
+		while(getch() == (ERR))
+		 {
+			/* do something until any key is pressed... */
+		 }
+
+
+ACKNOWLEGEMENTS: (in no particlar order)
+
+	Jason Shumate,Pieter Kunst,David Nugent,Andreas Otte,
+	Pasi Hamalainen,James McLennan,Duane Paulson,Ib Hojme
+	
+	Apologies to anyone I may have left out.
+
+
+Cheers, Mark
+
+------------------------------------------------------------------------
+Mark Hessling                         Email: M.Hessling@qut.edu.au
+36 David Road                         Phone: +617 849 7731
+Holland Park                          Fax:   
+Brisbane                              ***** PDCurses Maintainer *****
+QLD 4121                              ******** Author of THE ********
+Australia                             ******** Member RexxLA ********
+------------------------------------------------------------------------
diff -Naur gdb-6.8/pdcurses/readme.22 stsgdb-6.8/pdcurses/readme.22
--- gdb-6.8/pdcurses/readme.22	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.22	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,82 @@
+
+                             PDCurses 2.2
+            (Public Domain Curses for DOS, OS/2 and Xwindows)
+
+
+INTRODUCTION:
+
+	This release of PDCurses has includes a number of major changes:
+		- the portable library functions are now grouped together into
+		  single files with the same arrangement as System V R4 curses.
+		- a panels library has been included. This panels library was
+		  written by Warren Tucker.
+		- quite a few more functions have been supplied by Wade Schauer
+		  and incorporated into release 2.2. Wade also supplied the
+		  support for the Microway NDP C/C++ 32 bit DOS compiler.
+		- the curses datatype has been changed from an unsigned in to
+		  a long. This allows more attributes to be stored as well as
+		  increasing the number of color-pairs from 32 to 64.
+
+BUGS FIXED:
+
+	mvwin() checked the wrong coordinates
+	removed DESQview shadow memory buffer checking
+	bug in curses.h in #define for wstandout()
+	lots of others I can't remember
+
+NEW FUNCTIONS:
+
+	Too many to mention. See intro.man for a complete list of the
+	functions PDCurses now supports.
+
+COMPILER SUPPORT:
+
+	DJGPP 1.12 is now supported. The run-time error that caused
+	programs to crash has been removed.
+
+	emx 0.9a is supported. A program compiled for OS/2 should also
+	work under DOS if you use the VID=EMX switch when compiling. See
+	the makefile for details.
+
+	The Microway NDP C/C++ DOS compiler is now supported. Thanks to 
+	Wade Schauer for this port.
+
+	The Watcom C++ 10.0 DOS compiler is now supported. Thanks to
+	Pieter Kunst for this port.
+
+	The library now has many functions grouped together to reduce the
+	size of the library and to improve the speed of compilation.
+
+	The "names" of a couple of the compilers in the makefile has 
+	changed; CSET2 is now ICC and GO32 is now GCC.
+
+	The Xwindows port is experimental at the moment.
+
+EXTRA OPTIONS:
+
+	One difference between the behaviour of PDCurses and Unix curses
+	is the attributes that are displayed when a character is cleared.
+	Under Unix curses, no attributes are displayed, so 
+	the result is always black. Under PDCurses, these functions clear
+	with the current attributes in effect at the time. With the
+	introduction of the bkgd functions, by default, PDCurses clears
+	using the value set by (w)bkgd(). To have PDCurses behave the
+	same way as it did before release 2.2, compile with -DPDCURSES_WCLR
+
+ACKNOWLEGEMENTS: (for this release)
+
+	Pieter Kunst,David Nugent,Warren Tucker,Darin Haugen,Stefan Strack,
+	Wade Schauer and others who either allerted me to bugs or supplied
+	fixes.
+
+
+Cheers, Mark
+
+------------------------------------------------------------------------
+Mark Hessling                         Email: M.Hessling@qut.edu.au
+36 David Road                         Phone: +617 849 7731
+Holland Park                          Fax:   
+Brisbane                              ***** PDCurses Maintainer *****
+QLD 4121                              ******** Author of THE ********
+Australia                             ******** Member RexxLA ********
+------------------------------------------------------------------------
diff -Naur gdb-6.8/pdcurses/readme.23 stsgdb-6.8/pdcurses/readme.23
--- gdb-6.8/pdcurses/readme.23	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.23	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,75 @@
+
+                             PDCurses 2.3
+            (Public Domain Curses for DOS, OS/2, X11 and Win32)
+
+
+INTRODUCTION:
+
+This release of PDCurses includes the following changes:
+
+- the X11 port is now fully functional
+- the MS Visual C++ Win32 port now includes a DLL
+- both the X11 and Win32 ports support the mouse
+- the slk..() functions are now functional
+- support for scrollbars under X11 are experimental at this stage
+
+The name of the statically built library is pdcurses.lib (or pdcurses.a).  
+The name of the DLL import library (where applicable) is curses.lib.
+
+BUGS FIXED:
+
+some minor bugs were corrected in this release
+
+NEW FUNCTIONS:
+
+slk..() functions
+
+
+NEW COMPILER SUPPORT:
+
+- MS Visual C++ under Win95/NT
+- Watcom C++ under OS/2, Win32 and DOS
+- two EMX ports have been provided:
+  - OS/2 only using OS/2 APIs
+  - OS/2 and DOS using EMX video support routines
+
+Makefiles for each platform/compiler option reside in the platform
+directory.  These all have an extension of .mak.
+
+
+EXTRA OPTIONS:
+
+PDCurses recognises two environment variables which determines the
+initialisation and finalisation behaviour.  These environment variables
+do not apply to the X11 port.
+
+ PDC_PRESERVE_SCREEN
+If this environment variable is set, PDCurses will not clear the screen
+to the default white on black on startup.  This allows you to overlay
+a window over the top of the existing screen background.
+
+ PDC_RESTORE_SCREEN
+If this environment variable is set, PDCurses will take a copy of the
+contents of the screen at the time that PDCurses is started; initscr(),
+and when endwin() is called, the screen will be restored.
+
+
+ACKNOWLEGEMENTS: (for this release)
+
+Chris Szurgot for original Win32 port.
+Gurusamy Sarathy for some updates to the Win32 port.
+Kim Huron for the slk..() functions.
+Florian Grosse Coosmann for some bug fixes.
+Esa Peuha for reducing compiler warnings.
+Augustin Martin Domingo for patches to X11 port to enable accented 
+ characters.
+
+Cheers, Mark
+------------------------------------------------------------------------
+ Mark Hessling                       Email:       M.Hessling@qut.edu.au
+ PO Box 203                          http://www.lightlink.com/hessling/
+ Bellara                                AUTHOR of  |  MAINTAINER of
+ QLD 4507                                 THE      |    PDCurses
+ Australia                              Rexx/SQL   |     Regina
+                Member of RexxLA: http://www.rexxla.org/
+------------------------------------------------------------------------
diff -Naur gdb-6.8/pdcurses/readme.24 stsgdb-6.8/pdcurses/readme.24
--- gdb-6.8/pdcurses/readme.24	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.24	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,71 @@
+
+                             PDCurses 2.4
+            (Public Domain Curses for DOS, OS/2, X11 and Win32)
+
+
+INTRODUCTION:
+
+This release of PDCurses includes the following changes:
+
+- full support of X11 selection handling
+- removed the need for the cursos2.h file
+- enabled the "shifted" key on the numeric keypad
+- added native clipboard support for X11, Win32 and OS/2
+- added extra functions for obtaining internal PDCUrses status
+- added clipboard and key modifier tests in testcurs.c
+- fixes for panel library
+- key modifiers pressed by themselves are now returned as keys
+- Added X11 shared library support
+- Added extra slk formats supported by ncurses
+- Fixed bug with resizing the terminal when slk were on.
+- Changed behaviour of slk_attrset(), slk_attron() alk_attroff()
+  functions to work more like ncurses.
+
+BUGS FIXED:
+
+some minor bug and portability fixes were included in this release
+
+NEW FUNCTIONS:
+
+PDC_getclipboard() and PDC_setclipboard() for accessing the native
+clipboard.
+PDC_set_title() for setting the title of the window (X11 and Win32 only)
+PDC_get_input_fd() for getting the file handle of the PDCurses input
+PDC_get_key_modifiers() for getting the keyboard modifier settings at the
+time of the last (w)getch()
+initscrX() (only for X11 port) which allows standard X11 switches to 
+be passed to the application
+
+
+NEW COMPILER SUPPORT:
+
+- MingW32 GNU compiler under Win95/NT
+- Cygnus Win32 GNU compiler under Win95/NT
+- Borland C++ for OS/2 1.0+
+- lcc-win32 compiler under Win95/NT
+
+Makefiles for each platform/compiler option reside in the platform
+directory.  These all have an extension of .mak.
+
+
+ACKNOWLEGEMENTS: (for this release)
+
+Georg Fuchs for various changes.
+Juan David Palomar for pointing out getnstr() was not implemented.
+William McBrine for fix to allow black/black as valid color pair.
+Peter Preus for pointing out the missing bccos2.mak file.
+Laura Michaels for a couple of bug fixes and changes required to support
+   Mingw32 compiler.
+Frank Heckenbach for PDC_get_input_fd() and some portability fixes and
+   the fixes for panel library.
+Matthias Burian for the lcc-win32 compiler support.
+
+Cheers, Mark
+------------------------------------------------------------------------
+ Mark Hessling                       Email:       M.Hessling@qut.edu.au
+ PO Box 203                          http://www.lightlink.com/hessling/
+ Bellara                                AUTHOR of  |  MAINTAINER of
+ QLD 4507                                 THE      |    PDCurses
+ Australia                              Rexx/SQL   |     Regina
+                Member of RexxLA: http://www.rexxla.org/
+------------------------------------------------------------------------
diff -Naur gdb-6.8/pdcurses/readme.25 stsgdb-6.8/pdcurses/readme.25
--- gdb-6.8/pdcurses/readme.25	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.25	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,54 @@
+
+                             PDCurses 2.5
+            (Public Domain Curses for DOS, OS/2, X11 and Win32)
+
+
+INTRODUCTION:
+
+This release of PDCurses includes the following changes:
+
+Set BASE address for Win32 DLL
+Add KEY_SUP and KEY_SDOWN.
+Add PDC_set_line_color()
+Add blink support as bold background
+Add bold colors
+Add getbkgd() macro
+Add new PDC functions for adding underline, overline, leftline and rightline
+Add support for shifted keypad keys.
+Allow more keypad keys to work under Win32
+Change Win32 and OS/2 DLL name to curses.dll
+Change example resources to allow overriding from the cpmmand line
+Changes for building cleanly on OS/2
+Changes to handle building XCurses under AIX
+Check if prefresh() and pnoutrefresh() parameters are valid.
+Ensure build/install works from any directory
+Handle platforms where X11 headers do not typedef XPointer.
+Mention that Flexos is likely out-of-date.
+Pass delaytenths to XCurses_rawgetch()
+Remove boldFont
+Updates for cursor blinking and italic.
+
+BUGS FIXED:
+
+Fix bug with getting Win32 clipboard contents. Added new PDC_freeclipboard() function.
+Fix bug with halfdelay()
+Fix bug with mouse interrupting programs that are not trapping mouse events under Win32.
+Fix return value from curs_set()
+Reverse the left and right pointing bars in ALT_CHARSET
+
+
+NEW COMPILER SUPPORT:
+
+Add QNX-RTP port
+
+Makefiles for each platform/compiler option reside in the platform
+directory.  These all have an extension of .mak.
+
+Cheers, Mark
+------------------------------------------------------------------------
+ Mark Hessling,  M.Hessling@qut.edu.au  http://www.lightlink.com/hessling/
+ Author of THE, a Free XEDIT/KEDIT editor and, Rexx/SQL
+ Maintainer of PDCurses: Public Domain Curses and, Regina Rexx interpreter
+ Use Rexx ? join the Rexx Language Association: http://www.rexxla.org
+------------------------------------------------------------------------
+
diff -Naur gdb-6.8/pdcurses/readme.26 stsgdb-6.8/pdcurses/readme.26
--- gdb-6.8/pdcurses/readme.26	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.26	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,55 @@
+
+                             PDCurses 2.6
+            (Public Domain Curses for DOS, OS/2, X11 and Win32)
+
+
+INTRODUCTION:
+
+This release of PDCurses includes the following changes:
+
+BUGS FIXED:
+- Allow accented characters on Win32 platform when run on non-English keyboards.
+- Allow "special" characters like Ctrl-S, Ctrl-Q under OS/2 to be returned.
+- Some bugs with halfdelay() fixed by William McBrine.
+- pechochar() should now work correctly.
+- redrawwin() macro in curses.h was incorrect - fixed by Alberto Ornaghi
+- Don't include "special" characters like KEY_SHIFT_L to be returned in getnstr()
+  family. Bug 542913
+- Entering TAB in wgetnstr() no longer exceeds requested buffer size.
+  Bug 489233
+- Fixed bug 550066, scrollok() and pads.
+  Also beep() called when buffer exceeded. Bug 562041.
+- Reverse video of X11 selection reinstated. Pablo Garcia Abio??
+- Right Alt modifier now works like left Alt modifier under Win32
+- Add support for all libXaw replacement libraries with Scrollbar bug. Note
+  that for this to work, you still have to change the libXaw replacement
+  libraries to fix the bug :-(
+- Don't trap signals in XCurses if calling application has ignored them. Change
+  by Frank Heckenbach.
+- Bug reports from Warren W. Gay:
+  - Fix termattrs() to return A_REVERSE and A_BLINK on all platforms.
+  - Fix definition of getsyx() and setsyx() to be consistent with ncurses. Bug 624424.
+  - Fix definition of echo() and noecho(). Bug 625001.
+  - Fix definition of keypad() and leaveok(). Bug 632653.
+  - Missing panel_hidden() prottype. Bug 649320.
+- Fixed bug with calling def_prog_mode(), resize_term(), reset_prog_mode(); the resize
+  details were being lost.
+
+NEW FEATURES:
+- Clipboard support now available on DOS platform, but handled internally to the
+  currently running process.
+- new X11 resource; textCursor, allows the text cursor to be specified as a vertical
+  bar, or in the standard horizontal bar. Thanks to Frank Heckenbach for the
+  suggestion.
+
+NEW COMPILER SUPPORT:
+- lcc-win32 now works correctly
+
+Cheers, Mark
+------------------------------------------------------------------------
+ Mark Hessling,  M.Hessling@qut.edu.au  http://www.lightlink.com/hessling/
+ Author of THE, a Free XEDIT/KEDIT editor and, Rexx/SQL
+ Maintainer of PDCurses: Public Domain Curses and, Regina Rexx interpreter
+ Use Rexx ? join the Rexx Language Association: http://www.rexxla.org
+------------------------------------------------------------------------
+
diff -Naur gdb-6.8/pdcurses/readme.27 stsgdb-6.8/pdcurses/readme.27
--- gdb-6.8/pdcurses/readme.27	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/readme.27	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,140 @@
+
+                             PDCurses 2.7
+            (Public Domain Curses for DOS, OS/2, X11 and Win32)
+                    http://pdcurses.sourceforge.net/
+
+
+INTRODUCTION:
+
+ Hello all. As of a few weeks ago, I'm the new maintainer for PDCurses.
+ Here's a brief summary of changes in this release. (More details are
+ available in the CVS log and trackers on SourceForge.)
+
+NEW FEATURES:
+
+- Functions: delscreen(), getattrs(), has_key(), slk_color(),
+  wcolor_set(), wtimeout().
+
+- Macros: color_set(), mvhline(), mvvline(), mvwgetnstr(), mvwhline(),
+  mvwvline(), timeout(), wresize().
+
+- Stub implementations of terminfo functions (including a term.h).
+
+- More stubs for compatibility: filter(), getwin(), putwin(),
+  noqiflush(), qiflush(), scr_dump(), scr_init(), scr_restore(),
+  scr_set(), use_env(), vidattr(), vidputs().
+
+- The terminal's default colors are used as curses' default colors when
+  the environment variable "PDC_ORIGINAL_COLORS" is set to any value
+  (Win32 only at the moment).
+
+- Simplified build system.
+
+- Replaced PDC_STATIC_BUILD with its opposite, PDC_DLL_BUILD (see .mak
+  files for more info).
+
+- Minimal implementation of color_content() -- no longer a stub.
+
+- Added the remaining ACS defines (ACS_S3, ACS_BBSS, etc.) for
+  DOS/OS2/Win; "enhanced" versions of existing ACS characters used.
+
+- Support for scroll wheels.
+
+- Support for Pacific C.
+
+BUGS FIXED:
+
+- Builds correctly (including demos) on all tested platforms (see
+  below); nearly all compiler warnings have been cleaned up; the ptest
+  demo is built on all platforms; "clean" targets are improved.
+
+- The ability to build ncurses_tests has been restored (see demos dir).
+
+- Line-breakout optimization now defaults to off (equivalent to
+  "typeahead(-1)"), so output is not interrupted by keystrokes (it's
+  supposed to resume on the next refresh(), which wasn't working).
+
+- Implicit wrefresh() in wgetch() was not being invoked in nodelay mode.
+
+- subpad() was erroneously offsetting from the origin coordinates of the
+  parent pad (which are always -1,-1).
+
+- In wborder(), whline(), and wvline(), the current (wattrset) attribute
+  was being used, but not the current background (wbkgd).
+
+- Allow Russian 'r' character ASCII 0xe0 to be returned.
+
+- termattrs() now also returns A_UNDERLINE, A_REVERSE.
+
+- In Win32, with large scrollback buffers set, there was an unwanted
+  "scrollup" effect on startup.
+
+- Revamped keyboard handling for Win32.
+
+- New screen resize method for Win32.
+
+- napms(), delay_output(), etc. now work with Cygwin.
+
+- curs_set(0) wasn't working in Win32 in full-screen (ALT-ENTER) mode --
+  the cursor stayed on.
+
+- The A_REVERSE attribute was broken in XCurses.
+
+- On 64-bit systems, XCurses was ignoring every other keystroke.
+
+- Added focus hints for XCurses.
+
+- Demos (except for tuidemo) once again have their proper titles in
+  XCurses (using Xinitscr() instead of the obsolete XCursesProgramName).
+
+- The 16-bit chtype is a working option again (by removing #define
+  CHTYPE_LONG from curses.h), except in XCurses. It's not recommended;
+  but if your needs are limited, it still works.
+
+- Reset screen size in resetty() under DOS, as in Win32 and OS/2.
+
+- Changes for cursor size under DOS.
+
+- Automatic setting of BIOS mode for CGA under DOS now works.
+
+- The cursor is now always updated in PDC_gotoxy(); this fixes the
+  problem of missing characters in BIOS mode.
+
+- Macros nocbreak(), cbreak(), nocrmode(), crmode(), nodelay(),
+  nl() and nonl() now return OK.
+
+- ERR and OK are now defined as -1 and 0, respectively, for
+  compatibility with other curses implementations -- note that this
+  change is not binary compatible; you'll have to rebuild programs that
+  use shared/dynamic libraries.
+
+- Added "const" to prototypes where appropriate.
+
+- Miscellaneous code cleanup.
+
+ACKNOWLEDGEMENTS:
+
+ Walter Briscoe
+ Jean-Pierre Demailly
+ Ruslan Fedyarov
+ Warren Gay
+ Florian Grosse-Coosmann
+ Vladimir Kokovic
+ Matt Maloy
+ K.H. Man
+ Michael Ryazanov
+ Ron Thibodeau
+ Alexandr Zamaraev
+
+ and of course, MARK HESSLING, for his over 13 years of service as the
+ maintainer of PDCurses. Plus, thanks to all who've reported bugs or
+ requested features. Apologies to anyone I've forgotten.
+
+ I've tested this version on Turbo C++ 3.0 and Borland C++ 3.1 for DOS;
+ DJGPP 2.X; Open Watcom 1.3 for DOS (16 and 32-bit), Windows and OS/2;
+ EMX 0.9d and the "newgcc" version of EMX; Borland C++ 5.5 for Windows;
+ recent versions of MinGW, Cygwin, LCC-Win32 and Microsoft Visual C++;
+ and gcc under several flavors of Linux, Mac OS X, *BSD and Solaris.
+
+-- William McBrine
+   December 30, 2005
diff -Naur gdb-6.8/pdcurses/term.h stsgdb-6.8/pdcurses/term.h
--- gdb-6.8/pdcurses/term.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/term.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,81 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+/*
+$Id: term.h,v 1.2 2005/12/25 15:07:09 wmcbrine Exp $
+*/
+
+/* PDCurses doesn't operate with terminfo, but we need these functions for 
+   compatibility, to allow some things (notably, interface libraries for 
+   other languages) to be compiled. Anyone who tries to actually _use_ 
+   them will be disappointed, since they only return ERR.
+*/
+
+#include <curses.h>
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+extern "C"
+{
+#endif
+
+#ifndef __PDCURSES_TERM_H__
+#define __PDCURSES_TERM_H__ 1
+
+typedef void TERMINAL;
+
+#if defined(PDC_DLL_BUILD)
+# if !defined(CURSES_LIBRARY)
+__declspec(dllimport)  TERMINAL *cur_term;
+# else
+__declspec(dllexport) extern TERMINAL *cur_term;
+# endif
+#else
+extern TERMINAL *cur_term;
+#endif
+
+#ifdef HAVE_PROTO
+# define Args(x) x
+#else
+# define Args(x) ()
+#endif
+
+int     PDC_CDECL del_curterm Args((TERMINAL *));
+int     PDC_CDECL putp Args((const char *));
+int     PDC_CDECL restartterm Args((char *, int, int *));
+TERMINAL* PDC_CDECL set_curterm Args((TERMINAL *));
+int     PDC_CDECL setterm Args((char *));
+int     PDC_CDECL setupterm Args((char *, int, int *));
+int     PDC_CDECL tgetent Args((char *, const char *));
+int     PDC_CDECL tgetflag Args((char *));
+int     PDC_CDECL tgetnum Args((char *));
+char*   PDC_CDECL tgetstr Args((char *, char **));
+char*   PDC_CDECL tgoto Args((char *, int, int));
+int     PDC_CDECL tigetflag Args((char *));
+int     PDC_CDECL tigetnum Args((char *));
+char*   PDC_CDECL tigetstr Args((char *));
+char*   PDC_CDECL tparm Args((char *,long, long, long, long, long, long, long, long, long));
+int     PDC_CDECL tputs Args((const char *, int, int (*)(int)));
+
+#undef Args
+
+#endif /* __PDCURSES_TERM_H__ */
+
+#if defined(__cplusplus) || defined(__cplusplus__) || defined(__CPLUSPLUS)
+}
+#endif
diff -Naur gdb-6.8/pdcurses/TODO stsgdb-6.8/pdcurses/TODO
--- gdb-6.8/pdcurses/TODO	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/TODO	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,8 @@
+This file describes the features of PDCurses that are still to
+be completed.
+
+- provide for all outstanding curses functions
+
+- document how resizing works
+
+- document how to use mouse functions that do exist
diff -Naur gdb-6.8/pdcurses/tools/Makefile.in stsgdb-6.8/pdcurses/tools/Makefile.in
--- gdb-6.8/pdcurses/tools/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/tools/Makefile.in	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,74 @@
+# Makefile for XCurses manext program.
+
+SHELL		= /bin/sh
+
+srcdir		= @srcdir@
+pdcdir		= $(srcdir)/../x11
+
+VPATH		= @srcdir@
+prefix		= @prefix@
+exec_prefix	= @exec_prefix@
+libdir		= $(exec_prefix)
+
+CC		= @CC@
+CFLAGS		= @CFLAGS@
+
+INCDIR		= $(srcdir)
+CPPFLAGS	= @DEFS@ @SYS_DEFS@
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS) 
+
+LINK		= $(CC)
+LDFLAGS		= @LDFLAGS@ @LIBS@ 
+
+DOC_DIR=$(srcdir)/../doc
+INC_DIR=$(srcdir)/..
+PDCURSES_DIR=$(srcdir)/../pdcurses
+PANEL_DIR=$(srcdir)/../panel
+
+all: manual
+
+manual: manext PDCurses.man
+
+PDCurses.man:
+	./manext $(DOC_DIR)/intro.man 			> PDCurses.man
+	./manext $(DOC_DIR)/overview.man 			>> PDCurses.man
+	echo .......=================================== >> PDCurses.man
+	echo .......PDCurses Definitions and Variables:	>> PDCurses.man
+	echo .......=================================== >> PDCurses.man
+	./manext $(INC_DIR)/curses.h 	>> PDCurses.man
+	echo .......============================ >> PDCurses.man
+	echo .......PDCurses Functions:		>> PDCurses.man
+	echo .......============================ >> PDCurses.man
+	./manext $(PDCURSES_DIR)/*.c >> PDCurses.man
+	echo .......============================ >> PDCurses.man
+	echo .......PDCurses Private Functions:		>> PDCurses.man
+	echo .......============================ >> PDCurses.man
+	./manext $(pdcdir)/*.c >> PDCurses.man
+	echo .......========================== >> PDCurses.man
+	echo .......PDCurses Panel Functions:		>> PDCurses.man
+	echo .......========================== >> PDCurses.man
+	./manext $(PANEL_DIR)/*.c >> PDCurses.man
+	echo .......======================== >> PDCurses.man
+	echo .......X11 considerations:		>> PDCurses.man
+	echo .......======================== >> PDCurses.man
+	./manext $(DOC_DIR)/x11.man 			>> PDCurses.man
+
+manext: manext.o 
+	$(LINK) manext.o -o $@ $(LDFLAGS)
+
+manext.o: $(srcdir)/manext.c
+	$(CC) $(CCFLAGS) -o $@ $(srcdir)/manext.c
+
+install:
+	echo Does nothing at the moment
+
+clean:
+	-rm -rf *.o manext PDCurses.man
+
+distclean: clean
+	-rm -f Makefile
+
+mostlyclean: clean
+
+realclean: distclean
diff -Naur gdb-6.8/pdcurses/tools/manext.c stsgdb-6.8/pdcurses/tools/manext.c
--- gdb-6.8/pdcurses/tools/manext.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/tools/manext.c	2008-09-11 10:32:57.000000000 +0100
@@ -0,0 +1,133 @@
+/***********************************************************************/
+/* MANEXT - Extract manual pages from C source code.                   */
+/***********************************************************************/
+/*
+ * MANEXT - A program to extract manual pages from C source code.
+ * Copyright (C) 1991-1996 Mark Hessling
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to:
+ *
+ *    The Free Software Foundation, Inc.
+ *    675 Mass Ave,
+ *    Cambridge, MA 02139 USA.
+ *
+ *
+ * If you make modifications to this software that you feel increases
+ * it usefulness for the rest of the community, please email the
+ * changes, enhancements, bug fixes as well as any and all ideas to me.
+ * This software is going to be maintained and enhanced as deemed
+ * necessary by the community.
+ *
+ * Mark Hessling                 Email:             M.Hessling@qut.edu.au
+ * PO Box 203                    Phone:                    +617 3849 7731
+ * Bellara
+ * QLD 4507                      **** Maintainer PDCurses & REXX/SQL ****
+ * Australia                     ************* Author of THE ************
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+void display_info();
+
+#define MAX_LINE 255
+
+/***********************************************************************/
+int main(argc,argv)
+int argc;
+char *argv[];
+/***********************************************************************/
+{
+ char    s[MAX_LINE + 1];        /* input line */
+ register int     i;
+ FILE *fp;
+
+#ifdef __EMX__
+ _wildcard(&argc, &argv);
+#endif
+ if (strcmp(argv[1],"-h") == 0)
+   {
+    display_info();
+    exit(1);
+   }
+ for(i=1;i<argc;i++)
+    {
+     if ((fp = fopen(argv[i],"r")) == NULL)
+       {
+        fprintf(stderr,"\nCould not open %s\n",argv[i]);
+        continue;
+       }
+     while(1)
+       {
+        if (fgets(s, (int)sizeof(s), fp) == NULL)
+          {
+	   if (ferror(fp) != 0)
+             {
+              fprintf(stderr, "*** Error reading %s.  Exiting.\n",argv[i]);
+              exit(1);
+             }
+	   break;
+          }
+
+        /* check for manual entry marker at beginning of line */
+        if (strncmp(s, "/*man-start*", 12) != 0)
+            continue;
+
+        /* inner loop */
+        for (;;)
+           {
+            /* read next line of manual entry */
+	    if (fgets(s, (int)sizeof(s), fp) == NULL)
+              {
+	       if (ferror(fp) != 0)
+		 {
+		  fprintf(stderr, "*** Error reading %s.  Exiting.\n",argv[i]);
+		  exit(1);
+		 }
+		break;
+	      }
+	    /* check for end of entry marker */
+	    if (strncmp(s, "**man-end", 9) == 0)
+	       break;
+
+	    printf("     %s",s);
+            }
+	printf("\n\n\n     --------------------------------------------------------------------------\n");
+
+        /* check if end of file */
+        if (feof(fp) != 0)
+            break;
+       }
+     fclose(fp);
+    }
+ printf("\n\n\n\n\n");
+ return(0);
+}
+/***********************************************************************/
+void display_info()
+/***********************************************************************/
+{
+/*--------------------------- local data ------------------------------*/
+/*--------------------------- processing ------------------------------*/
+
+ fprintf(stderr,"\nMANEXT 1.00 Copyright (C) 1991-1996 Mark Hessling\n");
+ fprintf(stderr,"All rights reserved.\n");
+ fprintf(stderr,"MANEXT is distributed under the terms of the GNU\n");
+ fprintf(stderr,"General Public License and comes with NO WARRANTY.\n");
+ fprintf(stderr,"See the file COPYING for details.\n");
+ fprintf(stderr,"\nUsage: manext sourcefile [...]\n\n");
+ fflush(stderr);
+ return;
+}
diff -Naur gdb-6.8/pdcurses/win32/bccwin32.lrf stsgdb-6.8/pdcurses/win32/bccwin32.lrf
--- gdb-6.8/pdcurses/win32/bccwin32.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/bccwin32.lrf	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,49 @@
+-+addch.obj &
+-+addchstr.obj &
+-+addstr.obj &
+-+attr.obj &
+-+beep.obj &
+-+bkgd.obj &
+-+border.obj &
+-+clear.obj &
+-+color.obj &
+-+delch.obj &
+-+deleteln.obj &
+-+getch.obj &
+-+getstr.obj &
+-+getyx.obj &
+-+inch.obj & 
+-+inchstr.obj &
+-+initscr.obj &
+-+inopts.obj &
+-+insch.obj &
+-+insstr.obj &
+-+instr.obj &
+-+kernel.obj &
+-+mouse.obj &
+-+move.obj & 
+-+outopts.obj &
+-+overlay.obj &
+-+pad.obj &  
+-+printw.obj &
+-+refresh.obj &
+-+scanw.obj &
+-+scr_dump.obj &
+-+scroll.obj &
+-+slk.obj &  
+-+termattr.obj &
+-+terminfo.obj &
+-+touch.obj &
+-+util.obj & 
+-+window.obj &
+-+pdcdebug.obj &
+-+pdcclip.obj &
+-+pdcdisp.obj &
+-+pdcgetsc.obj &
+-+pdckbd.obj &
+-+pdcprint.obj &
+-+pdcscrn.obj &
+-+pdcsetsc.obj &
+-+pdcutil.obj &
+-+pdcwin.obj &
+,lib.map
diff -Naur gdb-6.8/pdcurses/win32/bccwin32.mak stsgdb-6.8/pdcurses/win32/bccwin32.mak
--- gdb-6.8/pdcurses/win32/bccwin32.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/bccwin32.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,337 @@
+################################################################################
+#
+# Borland MAKE Makefile for PDCurses library - Win32 BC++ 4.0+
+#
+# Usage: make -f [path\]bccwin32.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\win32
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= bcc32 -q
+
+!if $d(DEBUG)
+CFLAGS  = -N -v -y -DPDCDEBUG
+!else
+CFLAGS  =  -O -w-eff -w-par
+!endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= -c -Tpe -w32 $(CFLAGS) $(CPPFLAGS)
+
+LIBEXE		= tlib /C /E
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.map
+	-del *.tds
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+first:
+	@echo $(srcdir)\addch.c
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\bccwin32.lrf
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $@ -+$(PANOBJS)
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(CC) -e$@ $**
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	$(CC) -e$@ $**
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Borland C++ Win32 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Borland C/C++ 5.5 for Win32. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_bcc_w32 \
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) \
+	$(PDCURSES_HOME)\maintain.er \
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h \
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/win32/curses.def stsgdb-6.8/pdcurses/win32/curses.def
--- gdb-6.8/pdcurses/win32/curses.def	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/curses.def	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,325 @@
+;
+; curses.def
+; used for Win32 port as well as AIX port
+; each entry point MUST be on a seperate line prefixed
+; by EXPORTS in column 1
+;
+LIBRARY curses INITINSTANCE BASE=0x01000000
+HEAPSIZE 40960
+STACKSIZE 10240
+EXPORTS addch
+EXPORTS addchnstr
+EXPORTS addchstr
+EXPORTS addnstr
+EXPORTS addstr
+EXPORTS attroff
+EXPORTS attron
+EXPORTS baudrate
+EXPORTS beep
+EXPORTS bkgd
+EXPORTS bkgdset
+EXPORTS border
+EXPORTS box
+EXPORTS can_change_color
+EXPORTS cbreak
+EXPORTS clear
+EXPORTS clearok
+EXPORTS clrtobot
+EXPORTS clrtoeol
+EXPORTS color_set
+EXPORTS copywin
+EXPORTS curs_set
+EXPORTS def_prog_mode
+EXPORTS def_shell_mode
+EXPORTS delay_output
+EXPORTS delch
+EXPORTS deleteln
+EXPORTS delscreen
+EXPORTS delwin
+EXPORTS derwin
+EXPORTS doupdate
+EXPORTS draino
+EXPORTS dupwin
+EXPORTS echo
+EXPORTS echochar
+EXPORTS endwin
+EXPORTS erase
+EXPORTS erasechar
+EXPORTS filter
+EXPORTS flash
+EXPORTS flushinp
+EXPORTS getstr
+EXPORTS getwin
+EXPORTS halfdelay
+EXPORTS has_colors
+EXPORTS has_ic
+EXPORTS has_il
+EXPORTS hline
+EXPORTS idcok
+EXPORTS idlok
+EXPORTS immedok
+EXPORTS inch
+EXPORTS inchnstr
+EXPORTS inchstr
+EXPORTS init_color
+EXPORTS init_pair
+EXPORTS initscr
+EXPORTS innstr
+EXPORTS insch
+EXPORTS insdelln
+EXPORTS insertln
+EXPORTS insnstr
+EXPORTS insstr
+EXPORTS instr
+EXPORTS intrflush
+EXPORTS is_linetouched
+EXPORTS is_wintouched
+EXPORTS isendwin
+EXPORTS keyname
+EXPORTS keypad
+EXPORTS killchar
+EXPORTS leaveok
+EXPORTS longname
+EXPORTS meta
+EXPORTS move
+EXPORTS mvaddch
+EXPORTS mvaddchnstr
+EXPORTS mvaddchstr
+EXPORTS mvaddnstr
+EXPORTS mvaddstr
+EXPORTS mvcur
+EXPORTS mvdelch
+EXPORTS mvderwin
+EXPORTS mvgetch
+EXPORTS mvgetstr
+EXPORTS mvinch
+EXPORTS mvinchnstr
+EXPORTS mvinchstr
+EXPORTS mvinnstr
+EXPORTS mvinsch
+EXPORTS mvinsnstr
+EXPORTS mvinsstr
+EXPORTS mvinstr
+EXPORTS mvprintw
+EXPORTS mvscanw
+EXPORTS mvwaddch
+EXPORTS mvwaddchnstr
+EXPORTS mvwaddchstr
+EXPORTS mvwaddnstr
+EXPORTS mvwaddstr
+EXPORTS mvwdelch
+EXPORTS mvwgetch
+EXPORTS mvwgetstr
+EXPORTS mvwin
+EXPORTS mvwinch
+EXPORTS mvwinchnstr
+EXPORTS mvwinchstr
+EXPORTS mvwinnstr
+EXPORTS mvwinsch
+EXPORTS mvwinsnstr
+EXPORTS mvwinsstr
+EXPORTS mvwinstr
+EXPORTS mvwprintw
+EXPORTS mvwscanw
+EXPORTS napms
+EXPORTS newpad
+EXPORTS newwin
+EXPORTS nl
+EXPORTS nocbreak
+EXPORTS nodelay
+EXPORTS noecho
+EXPORTS nonl
+EXPORTS noqiflush
+EXPORTS noraw
+EXPORTS notimeout
+EXPORTS overlay
+EXPORTS overwrite
+EXPORTS pair_content
+EXPORTS pechochar
+EXPORTS pnoutrefresh
+EXPORTS prefresh
+EXPORTS printw
+EXPORTS putwin
+EXPORTS qiflush
+EXPORTS raw
+EXPORTS raw_output
+EXPORTS redrawwin
+EXPORTS refresh
+EXPORTS reset_prog_mode
+EXPORTS reset_shell_mode
+EXPORTS resetty
+EXPORTS ripoffline
+EXPORTS savetty
+EXPORTS scanw
+EXPORTS scr_dump
+EXPORTS scr_init
+EXPORTS scr_restore
+EXPORTS scr_set
+EXPORTS scrl
+EXPORTS scroll
+EXPORTS scrollok
+EXPORTS set_term
+EXPORTS setscrreg
+EXPORTS slk_attroff
+EXPORTS slk_attron
+EXPORTS slk_attrset
+EXPORTS slk_clear
+EXPORTS slk_color
+EXPORTS slk_init
+EXPORTS slk_label
+EXPORTS slk_noutrefresh
+EXPORTS slk_refresh
+EXPORTS slk_restore
+EXPORTS slk_set
+EXPORTS slk_touch
+EXPORTS standend
+EXPORTS standout
+EXPORTS start_color
+EXPORTS subpad
+EXPORTS subwin
+EXPORTS syncok
+EXPORTS termattrs
+EXPORTS termname
+EXPORTS timeout
+EXPORTS touchline
+EXPORTS touchwin
+EXPORTS traceon
+EXPORTS traceoff
+EXPORTS typeahead
+EXPORTS unctrl
+EXPORTS untouchwin
+EXPORTS use_env
+EXPORTS vidattr
+EXPORTS vidputs
+EXPORTS vline
+EXPORTS waddch
+EXPORTS waddchnstr
+EXPORTS waddchstr
+EXPORTS waddnstr
+EXPORTS waddstr
+EXPORTS wattroff
+EXPORTS wattron
+EXPORTS wattrset
+EXPORTS wbkgd
+EXPORTS wbkgdset
+EXPORTS wborder
+EXPORTS wclear
+EXPORTS wclrtobot
+EXPORTS wclrtoeol
+EXPORTS wcolor_set
+EXPORTS wcursyncup
+EXPORTS wdelch
+EXPORTS wdeleteln
+EXPORTS wechochar
+EXPORTS werase
+EXPORTS wgetch
+EXPORTS wgetnstr
+EXPORTS wgetstr
+EXPORTS whline
+EXPORTS winch
+EXPORTS winchnstr
+EXPORTS winchstr
+EXPORTS winnstr
+EXPORTS winsch
+EXPORTS winsdelln
+EXPORTS winsertln
+EXPORTS winsnstr
+EXPORTS winsstr
+EXPORTS winstr
+EXPORTS wmove
+EXPORTS wnoutrefresh
+EXPORTS wordchar
+EXPORTS wprintw
+EXPORTS wredrawln
+EXPORTS wrefresh
+EXPORTS wscanw
+EXPORTS wscrl
+EXPORTS wsetscrreg
+EXPORTS wstandend
+EXPORTS wstandout
+EXPORTS wsyncdown
+EXPORTS wsyncup
+EXPORTS wtimeout
+EXPORTS wtouchln
+EXPORTS wvline
+EXPORTS mouse_set
+EXPORTS mouse_on
+EXPORTS mouse_off
+EXPORTS request_mouse_pos
+EXPORTS map_button
+EXPORTS wmouse_position
+EXPORTS getmouse
+EXPORTS getbmap
+EXPORTS resize_term
+EXPORTS del_curterm
+EXPORTS putp
+EXPORTS restartterm
+EXPORTS set_curterm
+EXPORTS setterm
+EXPORTS setupterm
+EXPORTS tgetent
+EXPORTS tgetflag
+EXPORTS tgetnum
+EXPORTS tgetstr
+EXPORTS tgoto
+EXPORTS tigetflag
+EXPORTS tigetnum
+EXPORTS tigetstr
+EXPORTS tparm
+EXPORTS tputs
+EXPORTS PDC_chadd
+EXPORTS PDC_check_bios_key
+EXPORTS PDC_chg_attrs
+EXPORTS PDC_chins
+EXPORTS PDC_clr_scrn
+EXPORTS PDC_clr_update
+EXPORTS PDC_copy_win
+EXPORTS PDC_cursor_off
+EXPORTS PDC_cursor_on
+EXPORTS PDC_debug
+EXPORTS PDC_fix_cursor
+EXPORTS PDC_getch
+EXPORTS PDC_getclipboard
+EXPORTS PDC_get_attribute
+EXPORTS PDC_get_bios_key
+EXPORTS PDC_get_columns
+EXPORTS PDC_get_ctrl_break
+EXPORTS PDC_get_cursor_mode
+EXPORTS PDC_get_cursor_pos
+EXPORTS PDC_get_cur_col
+EXPORTS PDC_get_cur_row
+EXPORTS PDC_get_input_fd
+EXPORTS PDC_get_key_modifiers
+EXPORTS PDC_get_font
+EXPORTS PDC_get_rows
+EXPORTS PDC_get_scrn_mode
+EXPORTS PDC_gotoxy
+EXPORTS PDC_makenew
+EXPORTS PDC_memmove
+EXPORTS PDC_newline
+EXPORTS PDC_print
+EXPORTS PDC_putc
+EXPORTS PDC_putctty
+EXPORTS PDC_query_adapter_type
+EXPORTS PDC_rawgetch
+EXPORTS PDC_sanity_check
+EXPORTS PDC_scrn_modes_equal
+EXPORTS PDC_scroll
+EXPORTS PDC_scr_close
+EXPORTS PDC_scr_open
+EXPORTS PDC_setclipboard
+EXPORTS PDC_set_80x25
+EXPORTS PDC_set_ctrl_break
+EXPORTS PDC_set_cursor_mode
+EXPORTS PDC_set_font
+EXPORTS PDC_set_title
+EXPORTS PDC_set_rows
+EXPORTS PDC_set_scrn_mode
+EXPORTS PDC_sysgetch
+EXPORTS PDC_transform_line
+EXPORTS PDC_ungetch
+EXPORTS PDC_usleep
+EXPORTS PDC_validchar
+EXPORTS PDC_vsscanf
+EXPORTS PDC_freeclipboard
+EXPORTS PDC_clearclipboard
diff -Naur gdb-6.8/pdcurses/win32/curses_lcc.def stsgdb-6.8/pdcurses/win32/curses_lcc.def
--- gdb-6.8/pdcurses/win32/curses_lcc.def	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/curses_lcc.def	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,326 @@
+LIBRARY curses
+EXPORTS
+addch
+addchnstr
+addchstr
+addnstr
+addstr
+attroff
+attron
+baudrate
+beep
+bkgd
+bkgdset
+border
+box
+can_change_color
+cbreak
+clear
+clearok
+clrtobot
+clrtoeol
+color_set
+copywin
+curs_set
+def_prog_mode
+def_shell_mode
+delay_output
+delch
+deleteln
+delscreen
+delwin
+derwin
+doupdate
+draino
+dupwin
+echo
+echochar
+endwin
+erase
+erasechar
+filter
+flash
+flushinp
+getstr
+getwin
+halfdelay
+has_colors
+has_ic
+has_il
+hline
+idcok
+idlok
+immedok
+inch
+inchnstr
+inchstr
+init_color
+init_pair
+initscr
+innstr
+insch
+insdelln
+insertln
+insnstr
+insstr
+instr
+intrflush
+is_linetouched
+is_wintouched
+isendwin
+keyname
+keypad
+killchar
+leaveok
+longname
+meta
+move
+mvaddch
+mvaddchnstr
+mvaddchstr
+mvaddnstr
+mvaddstr
+mvcur
+mvdelch
+mvderwin
+mvgetch
+mvgetstr
+mvinch
+mvinchnstr
+mvinchstr
+mvinnstr
+mvinsch
+mvinsnstr
+mvinsstr
+mvinstr
+mvprintw
+mvscanw
+mvwaddch
+mvwaddchnstr
+mvwaddchstr
+mvwaddnstr
+mvwaddstr
+mvwdelch
+mvwgetch
+mvwgetstr
+mvwin
+mvwinch
+mvwinchnstr
+mvwinchstr
+mvwinnstr
+mvwinsch
+mvwinsnstr
+mvwinsstr
+mvwinstr
+mvwprintw
+mvwscanw
+napms
+newpad
+newwin
+nl
+nocbreak
+nodelay
+noecho
+nonl
+noqiflush
+noraw
+notimeout
+overlay
+overwrite
+pair_content
+pechochar
+pnoutrefresh
+prefresh
+printw
+putwin
+qiflush
+raw
+raw_output
+redrawwin
+refresh
+reset_prog_mode
+reset_shell_mode
+resetty
+ripoffline
+savetty
+scanw
+scr_dump
+scr_init
+scr_restore
+scr_set
+scrl
+scroll
+scrollok
+set_term
+setscrreg
+slk_attroff
+slk_attron
+slk_attrset
+slk_clear
+slk_color
+slk_init
+slk_label
+slk_noutrefresh
+slk_refresh
+slk_restore
+slk_set
+slk_touch
+standend
+standout
+start_color
+subpad
+subwin
+syncok
+termattrs
+termname
+timeout
+touchline
+touchwin
+traceon
+traceoff
+typeahead
+unctrl
+untouchwin
+use_env
+vidattr
+vidputs
+vline
+waddch
+waddchnstr
+waddchstr
+waddnstr
+waddstr
+wattroff
+wattron
+wattrset
+wbkgd
+wbkgdset
+wborder
+wclear
+wclrtobot
+wclrtoeol
+wcolor_set
+wcursyncup
+wdelch
+wdeleteln
+wechochar
+werase
+wgetch
+wgetnstr
+wgetstr
+whline
+winch
+winchnstr
+winchstr
+winnstr
+winsch
+winsdelln
+winsertln
+winsnstr
+winsstr
+winstr
+wmove
+wnoutrefresh
+wordchar
+wprintw
+wredrawln
+wrefresh
+wscanw
+wscrl
+wsetscrreg
+wstandend
+wstandout
+wsyncdown
+wsyncup
+wtimeout
+wtouchln
+wvline
+mouse_set
+mouse_on
+mouse_off
+request_mouse_pos
+map_button
+wmouse_position
+getmouse
+getbmap
+resize_term
+del_curterm
+putp
+restartterm
+set_curterm
+setterm
+setupterm
+tgetent
+tgetflag
+tgetnum
+tgetstr
+tgoto
+tigetflag
+tigetnum
+tigetstr
+tparm
+tputs
+PDC_chadd
+PDC_check_bios_key
+PDC_chg_attrs
+PDC_chins
+PDC_clr_scrn
+PDC_clr_update
+PDC_copy_win
+PDC_cursor_off
+PDC_cursor_on
+PDC_debug
+PDC_fix_cursor
+PDC_getch
+PDC_getclipboard
+PDC_get_attribute
+PDC_get_bios_key
+PDC_get_columns
+PDC_get_ctrl_break
+PDC_get_cursor_mode
+PDC_get_cursor_pos
+PDC_get_cur_col
+PDC_get_cur_row
+PDC_get_input_fd
+PDC_get_key_modifiers
+PDC_get_font
+PDC_get_rows
+PDC_get_scrn_mode
+PDC_gotoxy
+PDC_makenew
+PDC_memmove
+PDC_newline
+PDC_print
+PDC_putc
+PDC_putctty
+PDC_query_adapter_type
+PDC_rawgetch
+PDC_sanity_check
+PDC_scrn_modes_equal
+PDC_scroll
+PDC_scr_close
+PDC_scr_open
+PDC_setclipboard
+PDC_set_80x25
+PDC_set_ctrl_break
+PDC_set_cursor_mode
+PDC_set_font
+PDC_set_title
+PDC_set_rows
+PDC_set_scrn_mode
+PDC_sysgetch
+PDC_transform_line
+PDC_ungetch
+PDC_usleep
+PDC_validchar
+PDC_vsscanf
+PDC_freeclipboard
+PDC_clearclipboard
+SP
+stdscr
+COLS
+LINES
+cur_term
+Mouse_status
+SECTION
+DATA SHARED
diff -Naur gdb-6.8/pdcurses/win32/gccwin32.mak stsgdb-6.8/pdcurses/win32/gccwin32.mak
--- gdb-6.8/pdcurses/win32/gccwin32.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/gccwin32.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,343 @@
+################################################################################
+#
+# GNU MAKE Makefile for PDCurses library - WIN32 Cygnus GCC
+#
+# Usage: make -f [path\]gccwin32.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.a|panel.a|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "export PDCURSES_SRCDIR=c:/pdcurses".
+#
+################################################################################
+PDCURSES_HOME		= $(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)/panel.h
+TERM_HEADER		=$(PDCURSES_HOME)/term.h
+
+srcdir		= $(PDCURSES_HOME)/pdcurses
+osdir		= $(PDCURSES_HOME)/win32
+pandir		= $(PDCURSES_HOME)/panel
+demodir		= $(PDCURSES_HOME)/demos
+
+CC		= gcc
+
+ifeq ($(DEBUG),Y)
+	CFLAGS  = -c -g -Wall -DPDCDEBUG
+	LDFLAGS = -g
+else
+	CFLAGS  = -c -O -Wall
+	LDFLAGS =
+endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= $(CFLAGS) $(CPPFLAGS)
+
+LINK		= gcc
+COFF2EXE	=coff2exe $*
+
+CCLIBS		= -lkernel32 -luser32
+
+LIBEXE		= ar
+LIBFLAGS		=rcv
+
+LIBCURSES	= pdcurses.a
+LIBPANEL	= panel.a
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+SHELL = /bin/bash
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean:
+	-rm -f *.o
+	-rm -f *.a
+	-rm -f *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.o     \
+addchstr.o  \
+addstr.o    \
+attr.o      \
+beep.o      \
+bkgd.o      \
+border.o    \
+clear.o     \
+color.o     \
+delch.o     \
+deleteln.o  \
+getch.o     \
+getstr.o    \
+getyx.o     \
+inch.o      \
+inchstr.o   \
+initscr.o   \
+inopts.o    \
+insch.o     \
+insstr.o    \
+instr.o     \
+kernel.o    \
+mouse.o     \
+move.o      \
+outopts.o   \
+overlay.o   \
+pad.o       \
+printw.o    \
+refresh.o   \
+scanw.o     \
+scr_dump.o  \
+scroll.o    \
+slk.o       \
+termattr.o  \
+terminfo.o  \
+touch.o     \
+util.o      \
+window.o
+
+PDCOBJS =   \
+pdcclip.o   \
+pdcdebug.o  \
+pdcdisp.o   \
+pdcgetsc.o  \
+pdckbd.o    \
+pdcprint.o  \
+pdcscrn.o   \
+pdcsetsc.o  \
+pdcutil.o   \
+pdcwin.o
+
+PANOBJS =     \
+panel.o
+
+pdcurses.a : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ *.o
+	$(LIBEXE) d $@ $(PANOBJS) firework.o newdemo.o ptest.o testcurs.o tui.o tuidemo.o xmas.o
+
+panel.a : $(PANOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ $(PANOBJS)
+
+addch.o: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addch.c
+
+addchstr.o: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addchstr.c
+
+addstr.o: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addstr.c
+
+attr.o: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/attr.c
+
+beep.o: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/beep.c
+
+bkgd.o: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/bkgd.c
+
+border.o: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/border.c
+
+clear.o: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/clear.c
+
+color.o: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/color.c
+
+delch.o: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/delch.c
+
+deleteln.o: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/deleteln.c
+
+getch.o: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getch.c
+
+getstr.o: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getstr.c
+
+getyx.o: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getyx.c
+
+inch.o: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inch.c
+
+inchstr.o: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inchstr.c
+
+initscr.o: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/initscr.c
+
+inopts.o: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inopts.c
+
+insch.o: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insch.c
+
+insstr.o: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insstr.c
+
+instr.o: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/instr.c
+
+kernel.o: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/kernel.c
+
+mouse.o: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/mouse.c
+
+move.o: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/move.c
+
+outopts.o: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/outopts.c
+
+overlay.o: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/overlay.c
+
+pad.o: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pad.c
+
+printw.o: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/printw.c
+
+refresh.o: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/refresh.c
+
+scanw.o: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scanw.c
+
+scr_dump.o: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scr_dump.c
+
+scroll.o: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scroll.c
+
+slk.o: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/slk.c
+
+termattr.o: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/termattr.c
+
+terminfo.o: $(srcdir)/terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/terminfo.c
+
+touch.o: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/touch.c
+
+util.o: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/util.c
+
+window.o: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/window.c
+
+
+pdcclip.o: $(osdir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcclip.c
+
+pdcdebug.o: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcdebug.c
+
+pdcdisp.o: $(osdir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcdisp.c
+
+pdcgetsc.o: $(osdir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcgetsc.c
+
+pdckbd.o: $(osdir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdckbd.c
+
+pdcprint.o: $(osdir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcprint.c
+
+pdcscrn.o: $(osdir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcscrn.c
+
+pdcsetsc.o: $(osdir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcsetsc.c
+
+pdcutil.o: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcutil.c
+
+pdcwin.o: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.o: $(pandir)/panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)/panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o firework.exe firework.o $(LIBCURSES) $(CCLIBS)
+
+newdemo.exe:	newdemo.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o newdemo.exe newdemo.o $(LIBCURSES) $(CCLIBS)
+
+ptest.exe:	ptest.o $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -o ptest.exe ptest.o $(LIBCURSES) $(LIBPANEL) $(CCLIBS)
+
+testcurs.exe:	testcurs.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o testcurs.exe testcurs.o $(LIBCURSES) $(CCLIBS)
+
+tuidemo.exe:	tuidemo.o tui.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o tuidemo.exe tuidemo.o tui.o $(LIBCURSES) $(CCLIBS)
+
+xmas.exe:	xmas.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o xmas.exe xmas.o $(LIBCURSES) $(CCLIBS)
+
+
+firework.o: $(demodir)/firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/firework.c
+
+newdemo.o: $(demodir)/newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/newdemo.c
+
+ptest.o: $(demodir)/ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/ptest.c
+
+testcurs.o: $(demodir)/testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/testcurs.c
+
+tui.o: $(demodir)/tui.c $(demodir)/tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)/tui.c
+
+tuidemo.o: $(demodir)/tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)/tuidemo.c
+
+xmas.o: $(demodir)/xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Cygnus Win32 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Cygnus GCC for Win32. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_cyg_w32 \
+	$(PDCURSES_HOME)/README $(PDCURSES_HOME)/readme.$(VER) \
+	$(PDCURSES_HOME)/maintain.er \
+	$(PDCURSES_HOME)/curses.h $(PDCURSES_HOME)/curspriv.h \
+	$(PDCURSES_HOME)/panel.h $(PDCURSES_HOME)/term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	rm file_id.diz
diff -Naur gdb-6.8/pdcurses/win32/lccwin32.mak stsgdb-6.8/pdcurses/win32/lccwin32.mak
--- gdb-6.8/pdcurses/win32/lccwin32.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/lccwin32.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,581 @@
+###############################################################################
+#
+# Makefile for PDCurses library - WIN32 LCC-Win32
+#
+# Usage: make -f lccwin32.mak [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+###############################################################################
+#
+# Edit the line below for your environment.
+#
+###############################################################################
+PDCURSES_HOME		=\pdcurses
+###############################################################################
+# Nothing below here should require changing.
+###############################################################################
+PDCURSES_CURSES_H      =$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H    =$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS       =$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+
+PANEL_HEADER    =$(PDCURSES_HOME)\panel.h
+TERM_HEADER     =$(PDCURSES_HOME)\term.h
+
+srcdir          = $(PDCURSES_HOME)\pdcurses
+osdir           = $(PDCURSES_HOME)\win32
+pandir          = $(PDCURSES_HOME)\panel
+demodir         = $(PDCURSES_HOME)\demos
+
+CC              = lcc
+
+#CFLAGS  = -c -g3 -A -ansic -D__LCC__
+CFLAGS          = -c -O -A -ansic -D__LCC__
+LDFLAGS         =
+
+CPPFLAGS        = -I$(PDCURSES_HOME)
+
+CCFLAGS         = $(CFLAGS) $(CPPFLAGS)
+DLL_CCFLAGS     = $(CFLAGS) $(CPPFLAGS) -DPDC_DLL_BUILD #-DPDC_THREAD_BUILD
+
+LINK            = lcclnk
+
+DEFFILE         = $(osdir)\curses_lcc.def
+SHL_LD          = lcclnk $(LDFLAGS) -DLL $(DEFFILE)
+
+LIBEXE          = lcclib
+LIBFLAGS        =
+
+LIBCURSES       = pdcurses.lib
+DLLCURSES       = curses.lib
+CURSESDLL       = curses.dll
+LIBPANEL        = panel.lib
+
+PDCLIBS         = $(LIBCURSES) $(LIBPANEL) #$(CURSESDLL)
+DEMOS           = testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+DLL_DEMOS       = testcurs_dll.exe newdemo_dll.exe xmas_dll.exe tuidemo_dll.exe firework_dll.exe
+
+###############################################################################
+
+all:    $(PDCLIBS) $(DEMOS) #$(DLL_DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.dll
+	-del *.exp
+	-del *.exe
+
+demos:  $(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =   \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+LIBDLLS =     \
+addch.dll.obj     \
+addchstr.dll.obj  \
+addstr.dll.obj    \
+attr.dll.obj      \
+beep.dll.obj      \
+bkgd.dll.obj      \
+border.dll.obj    \
+clear.dll.obj     \
+color.dll.obj     \
+delch.dll.obj     \
+deleteln.dll.obj  \
+getch.dll.obj     \
+getstr.dll.obj    \
+getyx.dll.obj     \
+inch.dll.obj      \
+inchstr.dll.obj   \
+initscr.dll.obj   \
+inopts.dll.obj    \
+insch.dll.obj     \
+insstr.dll.obj    \
+instr.dll.obj     \
+kernel.dll.obj    \
+mouse.dll.obj     \
+move.dll.obj      \
+outopts.dll.obj   \
+overlay.dll.obj   \
+pad.dll.obj       \
+printw.dll.obj    \
+refresh.dll.obj   \
+scanw.dll.obj     \
+scr_dump.dll.obj  \
+scroll.dll.obj    \
+slk.dll.obj       \
+termattr.dll.obj  \
+terminfo.dll.obj  \
+touch.dll.obj     \
+util.dll.obj      \
+window.dll.obj
+
+PDCDLLS =     \
+pdcclip.dll.obj   \
+pdcdebug.dll.obj  \
+pdcdisp.dll.obj   \
+pdcgetsc.dll.obj  \
+pdckbd.dll.obj    \
+pdcprint.dll.obj  \
+pdcscrn.dll.obj   \
+pdcsetsc.dll.obj  \
+pdcutil.dll.obj   \
+pdcwin.dll.obj
+
+PANDLLS =     \
+panel.dll.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $(LIBFLAGS) /out:$@ $(LIBOBJS) $(PDCOBJS)
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) $(LIBFLAGS) /out:$@ $(PANOBJS)
+
+curses.dll : $(DLL_DIR) $(LIBDLLS) $(PDCDLLS) $(DEFFILE)
+	$(SHL_LD) -o $(CURSESDLL) $(LIBDLLS) $(PDCDLLS)
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+addch.dll.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.dll.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.dll.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.dll.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.dll.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.dll.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.dll.obj: $(srcdir)\border.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.dll.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.dll.obj: $(srcdir)\color.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.dll.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.dll.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.dll.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.dll.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.dll.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.dll.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.dll.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.dll.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.dll.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.dll.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.dll.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.dll.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.dll.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.dll.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.dll.obj: $(srcdir)\move.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.dll.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.dll.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.dll.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.dll.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.dll.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.dll.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.dll.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.dll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.dll.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.dll.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.dll.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.dll.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.dll.obj: $(srcdir)\util.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.dll.obj: $(srcdir)\window.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+
+pdcclip.dll.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.dll.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.dll.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.dll.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.dll.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.dll.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.dll.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.dll.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.dll.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.dll.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+panel.dll.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER) $(DLL_DIR)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:   firework.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o firework.exe firework.obj $(LIBCURSES)
+
+newdemo.exe:    newdemo.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o newdemo.exe newdemo.obj $(LIBCURSES)
+
+ptest.exe:      ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -o ptest.exe ptest.obj $(LIBCURSES) $(LIBPANEL)
+
+testcurs.exe:   testcurs.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o testcurs.exe testcurs.obj $(LIBCURSES)
+
+tuidemo.exe:    tuidemo.obj tui.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o tuidemo.exe tuidemo.obj tui.obj $(LIBCURSES)
+
+xmas.exe:       xmas.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o xmas.exe xmas.obj $(LIBCURSES)
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+#--- Targets for dynamically linked demo programs -----------------------
+
+firework_dll.exe:	firework.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ firework.dll.obj $(DLLCURSES)
+
+newdemo_dll.exe:	newdemo.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ newdemo.dll.obj $(DLLCURSES)
+
+ptest_dll.exe:	ptest.dll.obj $(CURSESDLL) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -out:$@ ptest.dll.obj $(LIBPANEL) $(DLLCURSES)
+
+testcurs_dll.exe:	testcurs.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ testcurs.dll.obj $(DLLCURSES)
+
+tuidemo_dll.exe:	tuidemo.dll.obj tui.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ tui.dll.obj tuidemo.dll.obj $(DLLCURSES)
+
+xmas_dll.exe:	xmas.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ xmas.dll.obj $(DLLCURSES)
+
+test_dll.exe:	test.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ test.dll.obj $(DLLCURSES)
+
+#--- Targets for dynamically linked demo objects ------------------------
+
+firework.dll.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.dll.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.dll.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.dll.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.dll.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -I$(demodir) -Fo$@ $(demodir)\tui.c
+
+tuidemo.dll.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -I$(demodir) -Fo$@ $(demodir)\tuidemo.c
+
+xmas.dll.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+test.dll.obj: test.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ test.c
diff -Naur gdb-6.8/pdcurses/win32/mingwin32.mak stsgdb-6.8/pdcurses/win32/mingwin32.mak
--- gdb-6.8/pdcurses/win32/mingwin32.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/mingwin32.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,341 @@
+################################################################################
+#
+# GNU MAKE Makefile for PDCurses library - WIN32 MinGW GCC
+#
+# Usage: make -f [path\]gccwin32.mak [-DDEBUG] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.a|panel.a|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H		=$(PDCURSES_HOME)/curses.h
+PDCURSES_CURSPRIV_H		=$(PDCURSES_HOME)/curspriv.h
+PDCURSES_HEADERS		=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)/panel.h
+TERM_HEADER		=$(PDCURSES_HOME)/term.h
+
+srcdir		= $(PDCURSES_HOME)/pdcurses
+osdir		= $(PDCURSES_HOME)/win32
+pandir		= $(PDCURSES_HOME)/panel
+demodir		= $(PDCURSES_HOME)/demos
+
+CC		= gcc
+
+ifeq ($(DEBUG),Y)
+	CFLAGS  = -c -g -Wall -DPDCDEBUG -D_NO_OLDNAMES
+	LDFLAGS = -g
+else
+	CFLAGS  = -c -O -Wall -D_NO_OLDNAMES
+	LDFLAGS =
+endif
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= $(CFLAGS) $(CPPFLAGS)
+
+LINK		= gcc
+COFF2EXE	=coff2exe $*
+
+CCLIBS		= -lkernel32 -luser32
+
+LIBEXE		= ar
+LIBFLAGS		=rcv
+
+LIBCURSES	= pdcurses.a
+LIBPANEL	= panel.a
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean:
+	-del *.o
+	-del *.a
+	-del *.exe
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.o     \
+addchstr.o  \
+addstr.o    \
+attr.o      \
+beep.o      \
+bkgd.o      \
+border.o    \
+clear.o     \
+color.o     \
+delch.o     \
+deleteln.o  \
+getch.o     \
+getstr.o    \
+getyx.o     \
+inch.o      \
+inchstr.o   \
+initscr.o   \
+inopts.o    \
+insch.o     \
+insstr.o    \
+instr.o     \
+kernel.o    \
+mouse.o     \
+move.o      \
+outopts.o   \
+overlay.o   \
+pad.o       \
+printw.o    \
+refresh.o   \
+scanw.o     \
+scr_dump.o  \
+scroll.o    \
+slk.o       \
+termattr.o  \
+terminfo.o  \
+touch.o     \
+util.o      \
+window.o
+
+PDCOBJS =   \
+pdcclip.o   \
+pdcdebug.o  \
+pdcdisp.o   \
+pdcgetsc.o  \
+pdckbd.o    \
+pdcprint.o  \
+pdcscrn.o   \
+pdcsetsc.o  \
+pdcutil.o   \
+pdcwin.o
+
+PANOBJS =     \
+panel.o
+
+pdcurses.a : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ *.o
+	$(LIBEXE) d $@ $(PANOBJS) firework.o newdemo.o ptest.o testcurs.o tui.o tuidemo.o xmas.o
+
+panel.a : $(PANOBJS)
+	$(LIBEXE) $(LIBFLAGS) $@ $(PANOBJS)
+
+addch.o: $(srcdir)/addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addch.c
+
+addchstr.o: $(srcdir)/addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addchstr.c
+
+addstr.o: $(srcdir)/addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/addstr.c
+
+attr.o: $(srcdir)/attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/attr.c
+
+beep.o: $(srcdir)/beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/beep.c
+
+bkgd.o: $(srcdir)/bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/bkgd.c
+
+border.o: $(srcdir)/border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/border.c
+
+clear.o: $(srcdir)/clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/clear.c
+
+color.o: $(srcdir)/color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/color.c
+
+delch.o: $(srcdir)/delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/delch.c
+
+deleteln.o: $(srcdir)/deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/deleteln.c
+
+getch.o: $(srcdir)/getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getch.c
+
+getstr.o: $(srcdir)/getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getstr.c
+
+getyx.o: $(srcdir)/getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/getyx.c
+
+inch.o: $(srcdir)/inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inch.c
+
+inchstr.o: $(srcdir)/inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inchstr.c
+
+initscr.o: $(srcdir)/initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/initscr.c
+
+inopts.o: $(srcdir)/inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/inopts.c
+
+insch.o: $(srcdir)/insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insch.c
+
+insstr.o: $(srcdir)/insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/insstr.c
+
+instr.o: $(srcdir)/instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/instr.c
+
+kernel.o: $(srcdir)/kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/kernel.c
+
+mouse.o: $(srcdir)/mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/mouse.c
+
+move.o: $(srcdir)/move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/move.c
+
+outopts.o: $(srcdir)/outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/outopts.c
+
+overlay.o: $(srcdir)/overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/overlay.c
+
+pad.o: $(srcdir)/pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pad.c
+
+printw.o: $(srcdir)/printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/printw.c
+
+refresh.o: $(srcdir)/refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/refresh.c
+
+scanw.o: $(srcdir)/scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scanw.c
+
+scr_dump.o: $(srcdir)/scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scr_dump.c
+
+scroll.o: $(srcdir)/scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/scroll.c
+
+slk.o: $(srcdir)/slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/slk.c
+
+termattr.o: $(srcdir)/termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/termattr.c
+
+terminfo.o: $(srcdir)/terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/terminfo.c
+
+touch.o: $(srcdir)/touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/touch.c
+
+util.o: $(srcdir)/util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/util.c
+
+window.o: $(srcdir)/window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/window.c
+
+
+pdcclip.o: $(osdir)/pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcclip.c
+
+pdcdebug.o: $(srcdir)/pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcdebug.c
+
+pdcdisp.o: $(osdir)/pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcdisp.c
+
+pdcgetsc.o: $(osdir)/pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcgetsc.c
+
+pdckbd.o: $(osdir)/pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdckbd.c
+
+pdcprint.o: $(osdir)/pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcprint.c
+
+pdcscrn.o: $(osdir)/pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcscrn.c
+
+pdcsetsc.o: $(osdir)/pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(osdir)/pdcsetsc.c
+
+pdcutil.o: $(srcdir)/pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcutil.c
+
+pdcwin.o: $(srcdir)/pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -o$@ $(srcdir)/pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.o: $(pandir)/panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -o$@ $(pandir)/panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o firework.exe firework.o $(LIBCURSES) $(CCLIBS)
+
+newdemo.exe:	newdemo.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o newdemo.exe newdemo.o $(LIBCURSES) $(CCLIBS)
+
+ptest.exe:	ptest.o $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -o ptest.exe ptest.o $(LIBCURSES) $(LIBPANEL) $(CCLIBS)
+
+testcurs.exe:	testcurs.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o testcurs.exe testcurs.o $(LIBCURSES) $(CCLIBS)
+
+tuidemo.exe:	tuidemo.o tui.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o tuidemo.exe tuidemo.o tui.o $(LIBCURSES) $(CCLIBS)
+
+xmas.exe:	xmas.o $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -o xmas.exe xmas.o $(LIBCURSES) $(CCLIBS)
+
+
+firework.o: $(demodir)/firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/firework.c
+
+newdemo.o: $(demodir)/newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/newdemo.c
+
+ptest.o: $(demodir)/ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/ptest.c
+
+testcurs.o: $(demodir)/testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/testcurs.c
+
+tui.o: $(demodir)/tui.c $(demodir)/tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)/tui.c
+
+tuidemo.o: $(demodir)/tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -o $@ $(demodir)/tuidemo.c
+
+xmas.o: $(demodir)/xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -o$@ $(demodir)/xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for MinGW Win32 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo MinGW for Win32. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_ming_w32 \
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) \
+	$(PDCURSES_HOME)\maintain.er \
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h \
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/win32/pdcclip.c stsgdb-6.8/pdcurses/win32/pdcclip.c
--- gdb-6.8/pdcurses/win32/pdcclip.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcclip.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,200 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	INCLUDE_WINDOWS_H
+#define	CURSES_LIBRARY	1
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCclip  = "$Id: pdcclip.c,v 1.4 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_getclipboard()	- Gets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Gets the textual contents of the system's clipboard. This
+ 	function returns the contents of the clipboard in the contents
+ 	argument. It is the responsibilitiy of the caller to free the
+ 	memory returned with the PDC_freeclipboard() call.  The length of the
+ 	clipboard contents is returned in the length argument.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
+ 		clipboard
+ 	PDC_CLIP_MEMORY_ERROR	unable to allocate sufficient memory for 
+ 		the clipboard contents
+ 	PDC_CLIP_EMPTY	the clipboard contains no text
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char **contents, long *length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_getclipboard(char **contents, long *length)
+{
+ HANDLE handle;
+ long len;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_getclipboard() - called\n");
+#endif
+
+ if (OpenClipboard(NULL) == 0)
+ {
+    return PDC_CLIP_ACCESS_ERROR;
+ }
+ handle = GetClipboardData( CF_TEXT );
+ if (handle == NULL)
+ {
+    CloseClipboard();
+    return PDC_CLIP_EMPTY;
+ }
+
+ len = strlen((char *)handle);
+ *contents = (char *)GlobalAlloc(GMEM_FIXED,len+1);
+ if (!*contents)
+ {
+    CloseClipboard();
+    return PDC_CLIP_MEMORY_ERROR;
+ }
+ strcpy((char *)*contents,(char *)handle);
+ *length = len;
+ CloseClipboard();
+
+	return( PDC_CLIP_SUCCESS );
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_setclipboard()	- Sets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Copies the supplied text into the system's clipboard, emptying
+ 	the clipboard prior to the copy.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
+ 		clipboard
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char *contents, long length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_setclipboard(char *contents, long length)
+{
+ HGLOBAL ptr1;
+ LPTSTR ptr2;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_setclipboard() - called\n");
+#endif
+
+
+ if (OpenClipboard(NULL) == 0)
+ {
+    return PDC_CLIP_ACCESS_ERROR;
+ }
+ ptr1 = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, (length+1)*sizeof(TCHAR) );
+ if (!ptr1)
+ {
+    return PDC_CLIP_MEMORY_ERROR;
+ }
+
+ ptr2 = GlobalLock(ptr1);
+ memcpy((char *)ptr2, (char *)contents, length+1 );
+ GlobalUnlock(ptr1);
+ EmptyClipboard();
+ if (SetClipboardData(CF_TEXT, ptr1) == NULL)
+ {
+    GlobalFree(ptr1);
+    return PDC_CLIP_ACCESS_ERROR;
+ }
+ CloseClipboard();
+ GlobalFree(ptr1);
+ return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_freeclipboard()	- Frees the memory associated with the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Frees the memory allocated by PDC_getclipboard().
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_freeclipboard( char *contents );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_freeclipboard(char *contents)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_freeclipboard() - called\n");
+#endif
+
+ GlobalFree(contents);
+ return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_clearclipboard()	- Clears the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Clears the internal clipboard.
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_clearclipboard( void );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_clearclipboard( void )
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_clearclipboard() - called\n");
+#endif
+
+ EmptyClipboard();
+
+ return PDC_CLIP_SUCCESS;
+}
+
diff -Naur gdb-6.8/pdcurses/win32/pdcdisp.c stsgdb-6.8/pdcurses/win32/pdcdisp.c
--- gdb-6.8/pdcurses/win32/pdcdisp.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcdisp.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,581 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#include <string.h>
+#define  CURSES_LIBRARY 1
+#define  INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef HAVE_MEMORY_H
+# include <memory.h>
+#endif
+
+extern HANDLE hConOut;
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdisp  = "$Id: pdcdisp.c,v 1.3 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+static CHAR_INFO ci[512];
+/*man-start*********************************************************************
+
+  PDC_clr_update()   - Updates the screen with a full redraw.
+
+  PDCurses Description:
+   Updates the screen by clearing it and then redraw it in its
+   entirety. If SP->refrbrk is TRUE, and there is pending
+   input characters, the update will be prematurely terminated.
+
+  PDCurses Return Value:
+   This routine returns ERR if it is unable to accomplish it's task.
+   This return value is ONLY under FLEXOS.
+
+   The return value OK is returned if there were no errors.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_clr_update( WINDOW* s );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_clr_update(WINDOW *s)
+/***********************************************************************/
+{
+   extern unsigned char atrtab[MAX_ATRTAB];
+
+   register int i, j;
+   register chtype *srcp;
+   WINDOW *w;
+   bool rc;
+   COORD bufSize, bufPos;
+   SMALL_RECT sr;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_clr_update() - called\n");
+#endif
+
+   w = curscr;
+   if (w == (WINDOW *)NULL)
+      return( ERR );
+#if 0
+   if (SP->full_redraw)
+      PDC_clr_scrn(s); /* clear physical screen */
+#endif
+
+   s->_clear = FALSE;
+   bufPos.X = bufPos.Y = 0;
+   bufSize.X = COLS;
+   bufSize.Y = 1;
+   sr.Left = 0;
+   sr.Right = COLS - 1;
+   for (i = 0; i < LINES; i++)   /* update physical screen */
+   {
+      if (s != w)
+         memcpy(w->_y[i], s->_y[i], COLS * sizeof(chtype));
+
+      srcp = s->_y[i];
+
+      sr.Top = i;
+      sr.Bottom = i;
+
+      for (j = 0; j < COLS; j++)
+      {
+         ci[j].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
+         ci[j].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
+#ifdef HIDE_ATTR
+         ci[j].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+#endif
+      }
+      WriteConsoleOutput(hConOut, ci, bufSize, bufPos, &sr);
+
+      if (SP->refrbrk && (SP->cbreak || SP->raw_inp))
+      {
+         rc = PDC_breakout();
+         if (rc)
+            break;
+      }
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_on() - Turns on the hardware cursor.
+
+  PDCurses Description:
+   Turns on the hardware curses, it does nothing if it is already on.
+
+  PDCurses Return Value:
+   Returns OK upon success, ERR upon failure.
+
+  Portability:
+   PDCurses int PDC_cursor_on( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_cursor_on(void)
+/***********************************************************************/
+{
+CONSOLE_CURSOR_INFO cci;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_cursor_on() - called\n");
+#endif
+
+   if (!SP->visible_cursor)
+   {
+      SP->visible_cursor = TRUE;
+      GetConsoleCursorInfo(hConOut,&cci);
+      cci.bVisible = TRUE;
+      SetConsoleCursorInfo(hConOut,&cci);
+   }
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_off()   - Turns off the hardware cursor.
+
+  PDCurses Description:
+   Turns off the hardware curses, it does nothing if it is already off.
+
+  PDCurses Return Value:
+   Returns OK upon success, ERR upon failure.
+
+  PDCurses Errors:
+   ERR will be returned (in the case of FLEXOS) if the hardware cursor
+   can not be disabled.
+
+  Portability:
+   PDCurses int PDC_cursor_off( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_cursor_off(void)
+/***********************************************************************/
+{
+CONSOLE_CURSOR_INFO cci;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_cursor_off() - called\n");
+#endif
+
+   if (SP->visible_cursor)
+   {
+      SP->visible_cursor = FALSE;
+      GetConsoleCursorInfo(hConOut,&cci);
+      cci.bVisible = FALSE;
+      SetConsoleCursorInfo(hConOut,&cci);
+   }
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_fix_cursor()   - Fix the cursor start and stop scan lines (if necessary)
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will fix the cursor shape for certain video adapters.
+   Normally, the values used are correct, but some adapters choke.
+   The most noticable choke is on a monochrome adapter.  The "correct"
+   scan lines will result in the cursor being set in the middle of the
+   character cell, rather than at the bottom.
+
+   The passed flag indicates whether the cursor is visible or not.
+
+   This only applies to the DOS platform.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_fix_cursor( int flag );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_fix_cursor(int flag)
+/***********************************************************************/
+{
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_gotoxy() - position hardware cursor at (x, y)
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Moves the physical cursor to the desired address on the
+   screen. We don't optimize here -- on a PC, it takes more time
+   to optimize than to do things directly.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_gotoxy( int row, int col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_gotoxy(int row, int col)
+/***********************************************************************/
+{
+   COORD coord;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_gotoxy() - called: row %d col %d from row %d col %d\n", row, col, SP->cursrow, SP->curscol );
+#endif
+
+   coord.X = col;
+   coord.Y = row;
+
+   SetConsoleCursorPosition(hConOut, coord);
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_putc()   - Output a character in the current attribute.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Outputs character 'chr' to screen in tty fashion. If a colour
+   mode is active, the character is written with colour 'colour'.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_putc( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_putc( chtype character, chtype color )
+/***********************************************************************/
+{
+   int curRow, curCol;
+   WORD buffer[2];
+   COORD coord;
+   DWORD written;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_putc() - called:char=%c attrib=0x%x color=0x%x\n",character & A_CHARTEXT,character & A_ATTRIBUTES,color);
+#endif
+
+   buffer[0] = color;
+   PDC_get_cursor_pos (&curRow, &curCol);
+
+   coord.X = curCol;
+   coord.Y = curRow;
+//   WriteConsoleOutputAttribute(hConOut, &buffer, 1, coord, &written);
+
+   buffer[0] = character;
+   WriteConsoleOutputCharacter(hConOut, (char*)&buffer[0], 1, coord, &written);
+
+   return (OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_putctty()   - Output a character and attribute in TTY fashion.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Outputs character 'chr' to screen in tty fashion. If a colour
+   mode is active, the character is written with colour 'colour'.
+
+   This function moves the physical cursor after writing so the
+   screen will scroll if necessary.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_putctty( chtype character, chtype color );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_putctty( chtype character, chtype color )
+/***********************************************************************/
+{
+   int curRow=0, curCol=0;
+   WORD buffer;
+   COORD coord;
+   DWORD written;
+
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_putctty() - called\n");
+#endif
+
+   buffer = color;
+   PDC_get_cursor_pos (&curRow, &curCol);
+   coord.X = curCol;
+   coord.Y = curRow;
+//   WriteConsoleOutputAttribute(hConOut, &buffer, 1, coord, &written);
+
+   buffer = character;
+   WriteConsoleOutputCharacter(hConOut, (char*)&buffer, 1, coord, &written);
+
+   return (OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_scroll() - low level screen scroll
+
+  PDCurses Description:
+   Scrolls a window in the current page up or down. Urow, lcol,
+   lrow, rcol are the window coordinates. Lines is the number of
+   lines to scroll. If 0, clears the window, if < 0 scrolls down,
+   if > 0 scrolls up.  Blanks areas that are left, and sets
+   character attributes to attr. If in a colour graphics mode,
+   fills them with the colour 'attr' instead.
+
+  PDCurses Return Value:
+   The PDC_scroll() function returns OK on success otherwise ERR is returned.
+
+  PDCurses Errors:
+   An error will only be returned on the Flexos platform if s_copy()
+   fails.
+
+  Portability:
+   PDCurses int PDC_scroll( int urow, int lcol, int rcol,
+                 int nlines, chtype attr );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+int   PDC_scroll(int urow, int lcol, int lrow, int rcol, int nlines, chtype attr)
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scroll() - called: urow %d lcol %d lrow %d rcol %d nlines %d\n",urow,lcol,lrow,rcol,nlines);
+#endif
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_transform_line()  - display a physical line of the screen
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Updates the given physical line to look like the corresponding
+   line in _curscr.
+
+  PDCurses Return Value:
+   This routine returns TRUE if a premature refresh end
+   is allowed, and there is an input character pending.  Otherwise,
+   FALSE is returned.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses bool  PDC_transform_line( int lineno );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+bool  PDC_transform_line(register int lineno)
+/***********************************************************************/
+{
+   extern unsigned   char atrtab[MAX_ATRTAB];
+
+   register int j;
+   register chtype *srcp;
+   int x;
+   int endx;
+   int len;
+   bool rc;
+   COORD bufSize, bufPos;
+   SMALL_RECT sr;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_transform_line() - called: lineno=%d\n",lineno);
+#endif
+
+   if (curscr == (WINDOW *)NULL)
+      return( FALSE );
+
+   x = curscr->_firstch[lineno];
+   endx = curscr->_lastch[lineno];
+   srcp = curscr->_y[lineno] + x;
+   len = endx-x+1;
+
+   bufPos.X = bufPos.Y = 0;
+
+   bufSize.X = len;
+   bufSize.Y = 1;
+
+   sr.Top = lineno;
+   sr.Bottom = lineno;
+   sr.Left = x;
+   sr.Right = endx;
+
+   for (j = 0; j < len; j++)
+   {
+      ci[j].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
+      ci[j].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
+#ifdef HIDE_ATTR
+      ci[j].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+#endif
+   }
+
+   WriteConsoleOutput(hConOut, ci, bufSize, bufPos, &sr);
+
+   curscr->_firstch[lineno] = _NO_CHANGE;
+   curscr->_lastch[lineno] = _NO_CHANGE;
+
+   if (SP->refrbrk && (SP->cbreak || SP->raw_inp))
+   {
+      rc = PDC_breakout();
+      if (rc)
+         return(TRUE);
+   }
+   return(FALSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_doupdate()  - display updated data in one call (Win32 only)
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Updates the given physical screen to look like _curscr.
+
+  PDCurses Return Value:
+   This routine returns nothing.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses void  PDC_doupdate( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+void PDC_doupdate(void)
+/***********************************************************************/
+{
+   extern unsigned char atrtab[MAX_ATRTAB];
+
+   register int i, j, k;
+   int starty = _NO_CHANGE, startx = _NO_CHANGE;
+   int size;
+   int endy = _NO_CHANGE, endx = _NO_CHANGE;
+   register chtype *srcp;
+   CHAR_INFO *ptr;
+   COORD bufSize, bufPos;
+   SMALL_RECT sr;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_doupdate() - called:\n");
+#endif
+
+   if (curscr == (WINDOW *)NULL)
+      return;
+
+   for (i = 0; i < LINES; i++ )
+   {
+      if (curscr->_firstch[i] != _NO_CHANGE)
+      {
+         if (starty == _NO_CHANGE)
+            starty = i;
+         endy = i;
+         if (startx == _NO_CHANGE
+         &&  curscr->_firstch[i] != _NO_CHANGE)
+            startx = curscr->_firstch[i];
+         if (curscr->_firstch[i] < startx)
+            startx = curscr->_firstch[i];
+         if (curscr->_lastch[i] > endx)
+            endx = curscr->_lastch[i];
+      }
+   }
+   if (starty == _NO_CHANGE) /* nothing to do... */
+      return;
+
+   size = ((endy - starty) + 1) * ((endx - startx) + 1);
+   ptr = (CHAR_INFO*)malloc(size*sizeof(CHAR_INFO));
+   if (ptr == NULL)
+      return;
+
+   bufPos.X = bufPos.Y = 0;
+   bufSize.X = endx - startx + 1;
+   bufSize.Y = endy - starty + 1;
+
+   sr.Top = starty;
+   sr.Bottom = endy;
+   sr.Left = startx;
+   sr.Right = endx;
+
+   k = 0;
+   for (i = starty; i <= endy; i++ )
+   {
+      srcp = curscr->_y[i];
+      for (j = startx; j <= endx; j++)
+      {
+         ptr[k].Char.AsciiChar = *(srcp+j) & A_CHARTEXT;
+         ptr[k].Attributes = (chtype_attr(*(srcp+j)) & 0xFF00) >> 8 ;
+#ifdef HIDE_ATTR
+         ptr[k].Attributes =  FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+#endif
+         k++;
+      }
+      curscr->_firstch[i] = _NO_CHANGE;
+      curscr->_lastch[i] = _NO_CHANGE;
+   }
+
+   WriteConsoleOutput(hConOut, ptr, bufSize, bufPos, &sr);
+   free(ptr);
+   return;
+}
+
diff -Naur gdb-6.8/pdcurses/win32/pdcgetsc.c stsgdb-6.8/pdcurses/win32/pdcgetsc.c
--- gdb-6.8/pdcurses/win32/pdcgetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcgetsc.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,421 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#define	INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCgetsc  = "$Id: pdcgetsc.c,v 1.2 2005/11/12 20:54:58 wmcbrine Exp $";
+#endif
+
+extern HANDLE hConOut, hConIn;
+extern CONSOLE_SCREEN_BUFFER_INFO scr;
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_pos()	- return current cursor position
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	Gets the cursor position in video page 0.  'row' and 'column'
+ 	are the cursor address.  At this time, there is no support for
+ 	use of multiple screen pages.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cursor_pos( int* row, int* col );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cursor_pos(int *row, int *col)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cursor_pos() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+   *col = scr.dwCursorPosition.X;
+   *row = scr.dwCursorPosition.Y;
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_col()	- get current column position of cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This routine returns the current column position of the cursor on
+ 	screen.
+
+  PDCurses Return Value:
+ 	This routine returns the current column position of the cursor. No
+ 	error is returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cur_col( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cur_col(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cur_col() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+   return (scr.dwCursorPosition.X);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cur_row()	- get current row position of cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This routine returns the current row position of the cursor on
+ 	screen.
+
+  PDCurses Return Value:
+ 	This routine returns the current row position of the cursor. No
+ 	error is returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_cur_row( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cur_row(void)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cur_row() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+   return (scr.dwCursorPosition.Y);
+}
+
+// Stopped Here...
+
+/*man-start*********************************************************************
+
+  PDC_get_attribute()	- Get attribute at current cursor
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	Return the current attr at current cursor position on the screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_attribute( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_attribute(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_attribute() - called\n");
+#endif
+/* doesnt do anything !! */
+	return(0);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_cursor_mode()	- Get the cursor start and stop scan lines.
+
+  PDCurses Description:
+ 	Gets the cursor type to begin in scan line startrow and end in
+ 	scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_cursor_mode( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_cursor_mode(void)
+{
+ CONSOLE_CURSOR_INFO ci;
+    
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_cursor_mode() - called\n");
+#endif
+
+ GetConsoleCursorInfo(hConOut, &ci);
+/* size is between 1 and 100, so convert it */
+ return ((ci.dwSize * 32 / 100) - 1);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_font()	- Get the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This function returns the current font size.  This function only
+ 	works if the #define FAST_VIDEO is true.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	An ERR will be returned if FAST_VIDEO is not true.
+
+  Portability:
+ 	PDCurses	int PDC_get_font( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_font(void)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_font() - called\n");
+#endif
+
+	return(0); /* this is N/A */
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_rows()	- Return number of screen rows.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the maximum number of rows supported by the display.
+ 	e.g.  25, 28, 43, 50, 60, 66...
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_rows( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_rows(void)
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_rows() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+#if FGC0
+   return ( scr.dwSize.Y ); /* Allow the whole screen to be accessed */
+#else
+   return (scr.srWindow.Bottom - scr.srWindow.Top + 1);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_buffer_rows()	- Return number of screen buffer rows.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+  PDCurses Return Value:
+ 	Returns the maximum number of rows in the screen buffer.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_buffer_rows( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_buffer_rows(void)
+{
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_buffer_rows() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo( hConOut, &scr );
+   return ( scr.dwSize.Y );
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_columns()	- return width of screen/viewport.
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This function will return the width of the current screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_columns( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_columns(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_columns() - called\n");
+#endif
+
+   GetConsoleScreenBufferInfo(hConOut, &scr);
+#if FGC0
+   return ( scr.dwSize.X ); /* Allow the whole screen to be accessed */
+#else
+   return (scr.srWindow.Right - scr.srWindow.Left + 1);
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_scrn_mode()	- Return the current BIOS video mode
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+
+  PDCurses Return Value:
+ 	Returns the current BIOS Video Mode Number.
+
+  PDCurses Errors:
+ 	The FLEXOS version of this routine returns an ERR.
+ 	The UNIX version of this routine returns an ERR.
+ 	The EMXVIDEO version of this routine returns an ERR.
+
+  Portability:
+ 	PDCurses	int PDC_get_scrn_mode( void );
+
+**man-end**********************************************************************/
+
+int	PDC_get_scrn_mode(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_scrn_mode() - called\n");
+#endif
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_query_adapter_type()	- Determine PC video adapter type
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Thanks to Jeff Duntemann, K16RA for providing the impetus
+ 	(through the Dr. Dobbs Journal, March 1989 issue) for getting
+ 	the routines below merged into Bjorn Larsson's PDCurses 1.3...
+ 		-- frotz@dri.com	900730
+
+  PDCurses Return Value:
+ 	This function returns a macro identifier indicating the adapter
+ 	type.  See the list of adapter types in CURSPRIV.H.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_query_adapter_type( void );
+
+**man-end**********************************************************************/
+
+int	PDC_query_adapter_type(void)
+{
+	int retval;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_query_adapter_type() - called\n");
+#endif
+
+	SP->mono = FALSE;
+	retval = _VGACOLOR;
+
+	return (retval);
+}
+
+/*man-start*********************************************************************
+
+  PDC_sanity_check() - A video adapter identification sanity check
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will force sane values for various control flags.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_sanity_check( int adapter );
+
+**man-end**********************************************************************/
+
+int	PDC_sanity_check(int adapter)
+{
+#ifdef PDCDEBUG
+   if (trace_on) 
+      PDC_debug("PDC_sanity_check() - called: Adapter %d\n",adapter);
+#endif
+
+   return (adapter);
+}
diff -Naur gdb-6.8/pdcurses/win32/pdckbd.c stsgdb-6.8/pdcurses/win32/pdckbd.c
--- gdb-6.8/pdcurses/win32/pdckbd.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdckbd.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,1477 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+#define  CURSES_LIBRARY 1
+#define  INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#include <stdio.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCkbd  = "$Id: pdckbd.c,v 1.19 2005/12/11 01:07:19 wmcbrine Exp $";
+#endif
+
+#define KEY_STATE TRUE
+
+/*
+ * MingW32 header files are missing the following in some versions
+ * of the compiler
+ */
+#ifndef DOUBLE_CLICK
+# define DOUBLE_CLICK 0x0002
+#endif
+
+#ifndef MOUSE_WHEELED
+# define MOUSE_WHEELED 0x0004
+#endif
+
+#ifndef FROM_LEFT_1ST_BUTTON_PRESSED
+# define FROM_LEFT_1ST_BUTTON_PRESSED 0x0001
+#endif
+
+#ifndef FROM_LEFT_2ND_BUTTON_PRESSED
+# define FROM_LEFT_2ND_BUTTON_PRESSED 0x0004
+#endif
+
+#ifndef RIGHTMOST_BUTTON_PRESSED
+# define RIGHTMOST_BUTTON_PRESSED 0x0002
+#endif
+/*
+ * These variables are used to store information about the next
+ * Input Event.
+ */
+INPUT_RECORD save_ip;
+static unsigned long pdc_key_modifiers=0L;
+
+extern HANDLE hConIn;
+
+#if defined(PDC_THREAD_BUILD)
+extern HANDLE hPipeRead;
+extern HANDLE hPipeWrite;
+extern HANDLE hSemKeyCount;
+#else
+static int keyCount = 0;
+#endif
+
+static void win32_getch(void);
+static int win32_kbhit(int);
+
+/*******************************************************************************
+*  Table for key code translation of function keys in keypad mode
+*  These values are for strict IBM keyboard compatibles only
+*******************************************************************************/
+
+typedef struct
+{
+   int normal;
+   int shift;
+   int control;
+   int alt;
+   int extended;
+} KPTAB;
+
+static KPTAB kptab[] =
+{
+   {0,          0,          0,           0,          0           }, /* 0  */
+   {0,          0,          0,           0,          0           }, /* 1   VK_LBUTTON       */
+   {0,          0,          0,           0,          0           }, /* 2   VK_RBUTTON       */
+   {0,          0,          0,           0,          0           }, /* 3   VK_CANCEL        */
+   {0,          0,          0,           0,          0           }, /* 4   VK_MBUTTON       */
+   {0,          0,          0,           0,          0           }, /* 5   */
+   {0,          0,          0,           0,          0           }, /* 6   */
+   {0,          0,          0,           0,          0           }, /* 7   */
+   {0x08,       0x08,       0x7F,        ALT_BKSP,   0           }, /* 8   VK_BACK          */
+   {0x09,       KEY_BTAB,   CTL_TAB,     ALT_TAB,    999         }, /* 9   VK_TAB           */
+   {0,          0,          0,           0,          0           }, /* 10  */
+   {0,          0,          0,           0,          0           }, /* 11  */
+   {KEY_B2,     0x35,       CTL_PAD5,    ALT_PAD5,   0           }, /* 12  VK_CLEAR         */
+   {0x0D,       0x0D,       CTL_ENTER,   ALT_ENTER,  1           }, /* 13  VK_RETURN        */
+   {0,          0,          0,           0,          0           }, /* 14  */
+   {0,          0,          0,           0,          0           }, /* 15  */
+   {0,          0,          0,           0,          0           }, /* 16  VK_SHIFT    HANDLED SEPARATELY */
+   {0,          0,          0,           0,          0           }, /* 17  VK_CONTROL  HANDLED SEPARATELY */
+   {0,          0,          0,           0,          0           }, /* 18  VK_MENU     HANDLED SEPARATELY */
+   {0,          0,          0,           0,          0           }, /* 19  VK_PAUSE         */
+   {0,          0,          0,           0,          0           }, /* 20  VK_CAPITAL  HANDLED SEPARATELY */
+   {0,          0,          0,           0,          0           }, /* 21  VK_HANGUL        */
+   {0,          0,          0,           0,          0           }, /* 22  */
+   {0,          0,          0,           0,          0           }, /* 23  VK_JUNJA         */
+   {0,          0,          0,           0,          0           }, /* 24  VK_FINAL         */
+   {0,          0,          0,           0,          0           }, /* 25  VK_HANJA         */
+   {0,          0,          0,           0,          0           }, /* 26  */
+   {0x1B,       0x1B,       0x1B,        ALT_ESC,    0           }, /* 27  VK_ESCAPE        */
+   {0,          0,          0,           0,          0           }, /* 28  VK_CONVERT       */
+   {0,          0,          0,           0,          0           }, /* 29  VK_NONCONVERT    */
+   {0,          0,          0,           0,          0           }, /* 30  VK_ACCEPT        */
+   {0,          0,          0,           0,          0           }, /* 31  VK_MODECHANGE    */
+   {0x20,       0x20,       0x20,        0x20,       0           }, /* 32  VK_SPACE         */
+   {KEY_A3,     0x39,       CTL_PAD9,    ALT_PAD9,   3           }, /* 33  VK_PRIOR         */
+   {KEY_C3,     0x33,       CTL_PAD3,    ALT_PAD3,   4           }, /* 34  VK_NEXT          */
+   {KEY_C1,     0x31,       CTL_PAD1,    ALT_PAD1,   5           }, /* 35  VK_END           */
+   {KEY_A1,     0x37,       CTL_PAD7,    ALT_PAD7,   6           }, /* 36  VK_HOME          */
+   {KEY_B1,     0x34,       CTL_PAD4,    ALT_PAD4,   7           }, /* 37  VK_LEFT          */
+   {KEY_A2,     0x38,       CTL_PAD8,    ALT_PAD8,   8           }, /* 38  VK_UP            */
+   {KEY_B3,     0x36,       CTL_PAD6,    ALT_PAD6,   9           }, /* 39  VK_RIGHT         */
+   {KEY_C2,     0x32,       CTL_PAD2,    ALT_PAD2,   10          }, /* 40  VK_DOWN          */
+   {0,          0,          0,           0,          0           }, /* 41  VK_SELECT        */
+   {0,          0,          0,           0,          0           }, /* 42  VK_PRINT         */
+   {0,          0,          0,           0,          0           }, /* 43  VK_EXECUTE       */
+   {0,          0,          0,           0,          0           }, /* 44  VK_SNAPSHOT      */
+   {PAD0,       0x30,       CTL_PAD0,    ALT_PAD0,   11          }, /* 45  VK_INSERT        */
+   {PADSTOP,    0x2E,       CTL_PADSTOP, ALT_PADSTOP,12          }, /* 46  VK_DELETE        */
+   {0,          0,          0,           0,          0           }, /* 47  VK_HELP          */
+   {0x30,       0x29,       0,           ALT_0,      0           }, /* 48  */
+   {0x31,       0x21,       0,           ALT_1,      0           }, /* 49  */
+   {0x32,       0x40,       0,           ALT_2,      0           }, /* 50  */
+   {0x33,       0x23,       0,           ALT_3,      0           }, /* 51  */
+   {0x34,       0x24,       0,           ALT_4,      0           }, /* 52  */
+   {0x35,       0x25,       0,           ALT_5,      0           }, /* 53  */
+   {0x36,       0x5E,       0,           ALT_6,      0           }, /* 54  */
+   {0x37,       0x26,       0,           ALT_7,      0           }, /* 55  */
+   {0x38,       0x2A,       0,           ALT_8,      0           }, /* 56  */
+   {0x39,       0x28,       0,           ALT_9,      0           }, /* 57  */
+   {0,          0,          0,           0,          0           }, /* 58  */
+   {0,          0,          0,           0,          0           }, /* 59  */
+   {0,          0,          0,           0,          0           }, /* 60  */
+   {0,          0,          0,           0,          0           }, /* 61  */
+   {0,          0,          0,           0,          0           }, /* 62  */
+   {0,          0,          0,           0,          0           }, /* 63  */
+   {0,          0,          0,           0,          0           }, /* 64  */
+   {0x61,       0x41,       0x01,        ALT_A,      0           }, /* 65  */
+   {0x62,       0x42,       0x02,        ALT_B,      0           }, /* 66  */
+   {0x63,       0x43,       0x03,        ALT_C,      0           }, /* 67  */
+   {0x64,       0x44,       0x04,        ALT_D,      0           }, /* 68  */
+   {0x65,       0x45,       0x05,        ALT_E,      0           }, /* 69  */
+   {0x66,       0x46,       0x06,        ALT_F,      0           }, /* 70  */
+   {0x67,       0x47,       0x07,        ALT_G,      0           }, /* 71  */
+   {0x68,       0x48,       0x08,        ALT_H,      0           }, /* 72  */
+   {0x69,       0x49,       0x09,        ALT_I,      0           }, /* 73  */
+   {0x6A,       0x4A,       0x0A,        ALT_J,      0           }, /* 74  */
+   {0x6B,       0x4B,       0x0B,        ALT_K,      0           }, /* 75  */
+   {0x6C,       0x4C,       0x0C,        ALT_L,      0           }, /* 76  */
+   {0x6D,       0x4D,       0x0D,        ALT_M,      0           }, /* 77  */
+   {0x6E,       0x4E,       0x0E,        ALT_N,      0           }, /* 78  */
+   {0x6F,       0x4F,       0x0F,        ALT_O,      0           }, /* 79  */
+   {0x70,       0x50,       0x10,        ALT_P,      0           }, /* 80  */
+   {0x71,       0x51,       0x11,        ALT_Q,      0           }, /* 81  */
+   {0x72,       0x52,       0x12,        ALT_R,      0           }, /* 82  */
+   {0x73,       0x53,       0x13,        ALT_S,      0           }, /* 83  */
+   {0x74,       0x54,       0x14,        ALT_T,      0           }, /* 84  */
+   {0x75,       0x55,       0x15,        ALT_U,      0           }, /* 85  */
+   {0x76,       0x56,       0x16,        ALT_V,      0           }, /* 86  */
+   {0x77,       0x57,       0x17,        ALT_W,      0           }, /* 87  */
+   {0x78,       0x58,       0x18,        ALT_X,      0           }, /* 88  */
+   {0x79,       0x59,       0x19,        ALT_Y,      0           }, /* 89  */
+   {0x7A,       0x5A,       0x1A,        ALT_Z,      0           }, /* 90  */
+   {0,          0,          0,           0,          0           }, /* 91  VK_LWIN          */
+   {0,          0,          0,           0,          0           }, /* 92  VK_RWIN          */
+   {0,          0,          0,           0,          0           }, /* 93  VK_APPS          */
+   {0,          0,          0,           0,          0           }, /* 94  */
+   {0,          0,          0,           0,          0           }, /* 95  */
+   {0x30,       0,          CTL_PAD0,    ALT_PAD0,   0           }, /* 96  VK_NUMPAD0       */
+   {0x31,       0,          CTL_PAD1,    ALT_PAD1,   0           }, /* 97  VK_NUMPAD1       */
+   {0x32,       0,          CTL_PAD2,    ALT_PAD2,   0           }, /* 98  VK_NUMPAD2       */
+   {0x33,       0,          CTL_PAD3,    ALT_PAD3,   0           }, /* 99  VK_NUMPAD3       */
+   {0x34,       0,          CTL_PAD4,    ALT_PAD4,   0           }, /* 100 VK_NUMPAD4       */
+   {0x35,       0,          CTL_PAD5,    ALT_PAD5,   0           }, /* 101 VK_NUMPAD5       */
+   {0x36,       0,          CTL_PAD6,    ALT_PAD6,   0           }, /* 102 VK_NUMPAD6       */
+   {0x37,       0,          CTL_PAD7,    ALT_PAD7,   0           }, /* 103 VK_NUMPAD7       */
+   {0x38,       0,          CTL_PAD8,    ALT_PAD8,   0           }, /* 104 VK_NUMPAD8       */
+   {0x39,       0,          CTL_PAD9,    ALT_PAD9,   0           }, /* 105 VK_NUMPAD9       */
+   {PADSTAR,    SHF_PADSTAR,CTL_PADSTAR, ALT_PADSTAR,999         }, /* 106 VK_MULTIPLY      */
+   {PADPLUS,    SHF_PADPLUS,CTL_PADPLUS, ALT_PADPLUS,999         }, /* 107 VK_ADD           */
+   {0,          0,          0,           0,          0           }, /* 108 VK_SEPARATOR     */
+   {PADMINUS,   SHF_PADMINUS,CTL_PADMINUS,ALT_PADMINUS,999       }, /* 109 VK_SUBTRACT      */
+   {0x2E,       0,          CTL_PADSTOP, ALT_PADSTOP,0           }, /* 110 VK_DECIMAL       */
+   {PADSLASH,   SHF_PADSLASH,CTL_PADSLASH,ALT_PADSLASH,2         }, /* 111 VK_DIVIDE        */
+   {KEY_F(1),   KEY_F(13),  KEY_F(25),   KEY_F(37),  0           }, /* 112 VK_F1            */
+   {KEY_F(2),   KEY_F(14),  KEY_F(26),   KEY_F(38),  0           }, /* 113 VK_F2            */
+   {KEY_F(3),   KEY_F(15),  KEY_F(27),   KEY_F(39),  0           }, /* 114 VK_F3            */
+   {KEY_F(4),   KEY_F(16),  KEY_F(28),   KEY_F(40),  0           }, /* 115 VK_F4            */
+   {KEY_F(5),   KEY_F(17),  KEY_F(29),   KEY_F(41),  0           }, /* 116 VK_F5            */
+   {KEY_F(6),   KEY_F(18),  KEY_F(30),   KEY_F(42),  0           }, /* 117 VK_F6            */
+   {KEY_F(7),   KEY_F(19),  KEY_F(31),   KEY_F(43),  0           }, /* 118 VK_F7            */
+   {KEY_F(8),   KEY_F(20),  KEY_F(32),   KEY_F(44),  0           }, /* 119 VK_F8            */
+   {KEY_F(9),   KEY_F(21),  KEY_F(33),   KEY_F(45),  0           }, /* 120 VK_F9            */
+   {KEY_F(10),  KEY_F(22),  KEY_F(34),   KEY_F(46),  0           }, /* 121 VK_F10           */
+   {KEY_F(11),  KEY_F(23),  KEY_F(35),   KEY_F(47),  0           }, /* 122 VK_F11           */
+   {KEY_F(12),  KEY_F(24),  KEY_F(36),   KEY_F(48),  0           }, /* 123 VK_F12           */
+   {0,          0,          0,           0,          0           }, /* 124 VK_F13           */
+   {0,          0,          0,           0,          0           }, /* 125 VK_F14           */
+   {0,          0,          0,           0,          0           }, /* 126 VK_F15           */
+   {0,          0,          0,           0,          0           }, /* 127 VK_F16           */
+   {0,          0,          0,           0,          0           }, /* 128 VK_F17           */
+   {0,          0,          0,           0,          0           }, /* 129 VK_F18           */
+   {0,          0,          0,           0,          0           }, /* 130 VK_F19           */
+   {0,          0,          0,           0,          0           }, /* 131 VK_F20           */
+   {0,          0,          0,           0,          0           }, /* 132 VK_F21           */
+   {0,          0,          0,           0,          0           }, /* 133 VK_F22           */
+   {0,          0,          0,           0,          0           }, /* 134 VK_F23           */
+   {0,          0,          0,           0,          0           }, /* 135 VK_F24           */
+   {0,          0,          0,           0,          0           }, /* 136 */
+   {0,          0,          0,           0,          0           }, /* 137 */
+   {0,          0,          0,           0,          0           }, /* 138 */
+   {0,          0,          0,           0,          0           }, /* 139 */
+   {0,          0,          0,           0,          0           }, /* 140 */
+   {0,          0,          0,           0,          0           }, /* 141 */
+   {0,          0,          0,           0,          0           }, /* 142 */
+   {0,          0,          0,           0,          0           }, /* 143 */
+   {0,          0,          0,           0,          0           }, /* 144 VK_NUMLOCK  HANDLED SEPARATELY */
+   {0,          0,          0,           0,          0           }, /* 145 VK_SCROLL   HANDLED SEPARATELY */
+   {0,          0,          0,           0,          0           }, /* 146 */
+   {0,          0,          0,           0,          0           }, /* 147 */
+   {0,          0,          0,           0,          0           }, /* 148 */
+   {0,          0,          0,           0,          0           }, /* 149 */
+   {0,          0,          0,           0,          0           }, /* 150 */
+   {0,          0,          0,           0,          0           }, /* 151 */
+   {0,          0,          0,           0,          0           }, /* 152 */
+   {0,          0,          0,           0,          0           }, /* 153 */
+   {0,          0,          0,           0,          0           }, /* 154 */
+   {0,          0,          0,           0,          0           }, /* 155 */
+   {0,          0,          0,           0,          0           }, /* 156 */
+   {0,          0,          0,           0,          0           }, /* 157 */
+   {0,          0,          0,           0,          0           }, /* 158 */
+   {0,          0,          0,           0,          0           }, /* 159 */
+   {0,          0,          0,           0,          0           }, /* 160 VK_LSHIFT        */
+   {0,          0,          0,           0,          0           }, /* 161 VK_RSHIFT        */
+   {0,          0,          0,           0,          0           }, /* 162 VK_LCONTROL      */
+   {0,          0,          0,           0,          0           }, /* 163 VK_RCONTROL      */
+   {0,          0,          0,           0,          0           }, /* 164 VK_LMENU         */
+   {0,          0,          0,           0,          0           }, /* 165 VK_RMENU         */
+   {0,          0,          0,           0,          0           }, /* 166 */
+   {0,          0,          0,           0,          0           }, /* 167 */
+   {0,          0,          0,           0,          0           }, /* 168 */
+   {0,          0,          0,           0,          0           }, /* 169 */
+   {0,          0,          0,           0,          0           }, /* 170 */
+   {0,          0,          0,           0,          0           }, /* 171 */
+   {0,          0,          0,           0,          0           }, /* 172 */
+   {0,          0,          0,           0,          0           }, /* 173 */
+   {0,          0,          0,           0,          0           }, /* 174 */
+   {0,          0,          0,           0,          0           }, /* 175 */
+   {0,          0,          0,           0,          0           }, /* 176 */
+   {0,          0,          0,           0,          0           }, /* 177 */
+   {0,          0,          0,           0,          0           }, /* 178 */
+   {0,          0,          0,           0,          0           }, /* 179 */
+   {0,          0,          0,           0,          0           }, /* 180 */
+   {0,          0,          0,           0,          0           }, /* 181 */
+   {0,          0,          0,           0,          0           }, /* 182 */
+   {0,          0,          0,           0,          0           }, /* 183 */
+   {0,          0,          0,           0,          0           }, /* 184 */
+   {0,          0,          0,           0,          0           }, /* 185 */
+   {0,          0,          0,           0,          0           }, /* 186 */
+   {0,          0,          0,           0,          0           }, /* 187 */
+   {0,          0,          0,           0,          0           }, /* 188 */
+   {0,          0,          0,           0,          0           }, /* 189 */
+   {0,          0,          0,           0,          0           }, /* 190 */
+   {0,          0,          0,           0,          0           }, /* 191 */
+   {0,          0,          0,           0,          0           }, /* 192 */
+   {0,          0,          0,           0,          0           }, /* 193 */
+   {0,          0,          0,           0,          0           }, /* 194 */
+   {0,          0,          0,           0,          0           }, /* 195 */
+   {0,          0,          0,           0,          0           }, /* 196 */
+   {0,          0,          0,           0,          0           }, /* 197 */
+   {0,          0,          0,           0,          0           }, /* 198 */
+   {0,          0,          0,           0,          0           }, /* 199 */
+   {0,          0,          0,           0,          0           }, /* 200 */
+   {0,          0,          0,           0,          0           }, /* 201 */
+   {0,          0,          0,           0,          0           }, /* 202 */
+   {0,          0,          0,           0,          0           }, /* 203 */
+   {0,          0,          0,           0,          0           }, /* 204 */
+   {0,          0,          0,           0,          0           }, /* 205 */
+   {0,          0,          0,           0,          0           }, /* 206 */
+   {0,          0,          0,           0,          0           }, /* 207 */
+   {0,          0,          0,           0,          0           }, /* 208 */
+   {0,          0,          0,           0,          0           }, /* 209 */
+   {0,          0,          0,           0,          0           }, /* 210 */
+   {0,          0,          0,           0,          0           }, /* 211 */
+   {0,          0,          0,           0,          0           }, /* 212 */
+   {0,          0,          0,           0,          0           }, /* 213 */
+   {0,          0,          0,           0,          0           }, /* 214 */
+   {0,          0,          0,           0,          0           }, /* 215 */
+   {0,          0,          0,           0,          0           }, /* 216 */
+   {0,          0,          0,           0,          0           }, /* 217 */
+   {0,          0,          0,           0,          0           }, /* 218 */
+   {0x5B,       0x7B,       0x1B,        ALT_LBRACKET,0          }, /* 219 */
+   {0x5C,       0x7C,       0x1C,        ALT_BSLASH, 0           }, /* 220 */
+   {0x5D,       0x7D,       0x1D,        ALT_RBRACKET,0          }, /* 221 */
+   {0,          0,          0x27,        ALT_FQUOTE, 0           }, /* 222 */
+   {0,          0,          0,           0,          0           }, /* 223 */
+   {0,          0,          0,           0,          0           }, /* 224 */
+   {0,          0,          0,           0,          0           }  /* 225 */
+};
+
+static KPTAB ext_kptab[] =
+{
+   {0,          0,          0,           0,          }, /* MUST BE EMPTY */
+   {PADENTER,   SHF_PADENTER,   CTL_PADENTER,ALT_PADENTER}, /* 13 */
+   {PADSLASH,   SHF_PADSLASH,   CTL_PADSLASH,ALT_PADSLASH}, /* 111 */
+   {KEY_PPAGE,  KEY_SPREVIOUS,  CTL_PGUP,    ALT_PGUP    }, /* 33 */
+   {KEY_NPAGE,  KEY_SNEXT,      CTL_PGDN,    ALT_PGDN    }, /* 34 */
+   {KEY_END,    KEY_SEND,       CTL_END,     ALT_END     }, /* 35 */
+   {KEY_HOME,   KEY_SHOME,      CTL_HOME,    ALT_HOME    }, /* 36 */
+   {KEY_LEFT,   KEY_SLEFT,      CTL_LEFT,    ALT_LEFT    }, /* 37 */
+   {KEY_UP,     KEY_SUP,        CTL_UP,      ALT_UP      }, /* 38 */
+   {KEY_RIGHT,  KEY_SRIGHT,     CTL_RIGHT,   ALT_RIGHT   }, /* 39 */
+   {KEY_DOWN,   KEY_SDOWN,      CTL_DOWN,    ALT_DOWN    }, /* 40 */
+   {KEY_IC,     KEY_SIC,        CTL_INS,     ALT_INS     }, /* 45 */
+   {KEY_DC,     KEY_SDC,        CTL_DEL,     ALT_DEL     }, /* 46 */
+   {PADSLASH,   SHF_PADSLASH,   CTL_PADSLASH,ALT_PADSLASH}, /* 191 */
+};
+ /* End of kptab[]       */
+
+MOUSE_STATUS Trapped_Mouse_status;
+
+/*man-start*********************************************************************
+
+  PDC_get_input_fd() - Get file descriptor used for PDCurses input
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will return the file descriptor that PDCurses reads
+   its input from. It can be used for WaitForMulitpleObjects()
+
+  PDCurses Return Value:
+   Returns a HANDLE.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int   PDC_get_input_fd( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long PDC_get_input_fd(void)
+#else
+unsigned long PDC_get_input_fd()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_input_fd() - called\n");
+#endif
+
+#if defined(PDC_THREAD_BUILD)
+   return (unsigned long)hSemKeyCount;
+#else
+   return 0L;
+#endif
+}
+
+/*man-start*********************************************************************
+
+  PDC_check_bios_key()  - Check BIOS key data area for input
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   This routine will check the BIOS for any indication that
+   keystrokes are pending.
+
+  PDCurses Return Value:
+   Returns 1 if a keyboard character is available, 0 otherwise.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses bool  PDC_check_bios_key( void );
+
+**man-end**********************************************************************/
+
+bool PDC_check_bios_key(void)
+{
+   return(win32_kbhit(0));
+}
+
+/*
+ * processKeyEvent returns -1 if the key in save_ip should be ignored for some
+ * reasons. Otherwise the keycode is returned which should be returned by
+ * PDC_get_bios_code.
+ * save_ip MUST BE A KEY_EVENT!
+ *
+ * The Unicode support has been disabled. See below for the reason.
+ * CTRL-ALT support has been disabled, when is it emitted plainly?
+ */
+int processKeyEvent(void)
+{
+   CHAR ascii = save_ip.Event.KeyEvent.uChar.AsciiChar;
+#if 0
+   WCHAR unicode = save_ip.Event.KeyEvent.uChar.UnicodeChar;
+#endif
+   WORD vk = save_ip.Event.KeyEvent.wVirtualKeyCode;
+   DWORD state = save_ip.Event.KeyEvent.dwControlKeyState;
+   unsigned long local_key_modifiers = 0L;
+   int idx;
+   BOOL enhanced;
+
+#if 0
+   {
+      char buf[KL_NAMELENGTH];
+      GetKeyboardLayoutName( buf );
+      fprintf(stderr,"OS=%X, AsciiChar: %u=%02X Unicode: %u=%02X KeyCode: %d ScanCode: %d State: %x Name: %s\n",
+                     SP->os_version,
+                     (unsigned char) ascii,
+                     (unsigned char) ascii,
+                     unicode,
+                     unicode,
+                     vk,
+                     save_ip.Event.KeyEvent.wVirtualScanCode,
+                     state,
+                     buf);
+   }
+#endif
+
+   pdc_key_modifiers = 0L;
+
+   /*
+    * Must calculate the key modifiers so that Alt keys work!
+    * Save the key modifiers if required.
+    * Do this first to allow to detect e.g. a pressed CTRL key
+    * after a hit of NUMLOCK.
+    */
+   if (state & LEFT_ALT_PRESSED || state & RIGHT_ALT_PRESSED)
+      local_key_modifiers |= PDC_KEY_MODIFIER_ALT;
+   if (state & SHIFT_PRESSED)
+      local_key_modifiers |= PDC_KEY_MODIFIER_SHIFT;
+   if (state & LEFT_CTRL_PRESSED || state & RIGHT_CTRL_PRESSED)
+      local_key_modifiers |= PDC_KEY_MODIFIER_CONTROL;
+   if (state & NUMLOCK_ON)
+      local_key_modifiers |= PDC_KEY_MODIFIER_NUMLOCK;
+   pdc_key_modifiers = SP->save_key_modifiers ? local_key_modifiers : 0;
+
+
+   /*
+    * Handle modifier keys hit by themselves
+    */
+
+   switch (vk)
+   {
+      case VK_SHIFT: /* shift */
+         if ( !SP->return_key_modifiers )
+            return -1;
+         return KEY_SHIFT_R;
+
+      case VK_CONTROL: /* control */
+         if ( !SP->return_key_modifiers )
+            return -1;
+         return (state & LEFT_CTRL_PRESSED) ? KEY_CONTROL_L : KEY_CONTROL_R;
+
+      case VK_MENU: /* alt */
+         if ( !SP->return_key_modifiers )
+            return -1;
+         return (state & LEFT_ALT_PRESSED) ? KEY_ALT_L : KEY_ALT_R;
+
+      default:
+         break;
+   }
+
+   /*
+    * The system may emit Ascii or Unicode characters depending on whether
+    * ReadConsoleInputA or ReadConsoleInputW is used. We use ReadConsoleInputA
+    * in all cases currently, so we just check Ascii. Unicode characters
+    * are very hard to implement, because our "special keys" like KEY_F(1)
+    * is one of the unicode range.
+    *
+    * Now the ridiculous part of the processing. Normally, if ascii != 0
+    * then the system did the translation successfully. But this is not true
+    * for LEFT_ALT (different to RIGHT_ALT)  in case of LEFT_ALT we get
+    * we get ascii != 0. So check for this first.
+    */
+   if ((ascii != 0)
+    && (((state & LEFT_ALT_PRESSED) == 0) || (state & RIGHT_ALT_PRESSED)))
+   {
+      /*
+       * This code should catch all keys returning a printable character.
+       * Characters above 0x7F should be returned as positive codes.
+       * But if'ndef NUMKEYPAD we have to return extended keycodes for
+       * keypad codes. Test for it and don't return an ascii code in case.
+       */
+#ifndef NUMKEYPAD
+      if (kptab[vk].extended == 0)
+#endif
+         return (unsigned char) ascii;
+   }
+
+
+   /*
+    * This case happens if a functional key has been entered.
+    */
+   if ((state & ENHANCED_KEY) && (kptab[vk].extended != 999))
+   {
+      enhanced = TRUE;
+      idx = kptab[vk].extended;
+   }
+   else
+   {
+      enhanced = FALSE;
+      idx = vk;
+   }
+   if (state & SHIFT_PRESSED)
+      return((enhanced)?ext_kptab[idx].shift:kptab[idx].shift);
+   if (state & LEFT_CTRL_PRESSED || state & RIGHT_CTRL_PRESSED)
+      return((enhanced)?ext_kptab[idx].control:kptab[idx].control);
+   if (state & LEFT_ALT_PRESSED || state & RIGHT_ALT_PRESSED)
+      return((enhanced)?ext_kptab[idx].alt:kptab[idx].alt);
+   return((enhanced)?ext_kptab[idx].normal:kptab[idx].normal);
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_get_bios_key() - Returns the next key available from the BIOS.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the next key code struck at the keyboard. If the low 8
+   bits are 0, the upper bits contain the extended character
+   code. If bit 0-7 are non-zero, the upper bits = 0.
+
+  PDCurses Return Value:
+   See above.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_bios_key( void );
+
+**man-end**********************************************************************/
+
+int   PDC_get_bios_key(void)
+{
+   MOUSE_STATUS Temp_Mouse_status;
+   static int last_button_no=0;
+   static MOUSE_STATUS Actual_Mouse_status;
+   int button_no=0;
+   bool trap_mouse=FALSE;
+   int key=0;
+   int retval;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_bios_key() - called\n");
+#endif
+
+   while(1)
+   {
+      win32_getch();
+
+      switch (save_ip.EventType)
+      {
+         case KEY_EVENT:
+            retval = processKeyEvent();
+            if (retval == -1) /* ignore key? */
+               continue;
+#if 0
+            fprintf(stderr,"KEY_EVENT returns 0x%X\n",retval);
+#endif
+            return retval;
+
+         case MOUSE_EVENT:
+            memset((char*)&Temp_Mouse_status,0,sizeof(MOUSE_STATUS));
+            /*
+             * Wheel has been scrolled
+             */
+/*fprintf(stderr,"%s %d: %x\n",__FILE__,__LINE__,save_ip.Event.MouseEvent.dwButtonState);*/
+            if ( save_ip.Event.MouseEvent.dwEventFlags == MOUSE_WHEELED )
+            {
+               if (save_ip.Event.MouseEvent.dwButtonState & 0xFF000000)
+                  Temp_Mouse_status.changes = PDC_MOUSE_WHEEL_DOWN;
+               else
+                  Temp_Mouse_status.changes = PDC_MOUSE_WHEEL_UP;
+            }
+            /*
+             * button press, release or double click ...
+             */
+            else if (save_ip.Event.MouseEvent.dwEventFlags == 0
+                 ||  save_ip.Event.MouseEvent.dwEventFlags == DOUBLE_CLICK)
+            {
+               /*
+                * Check for Left-most button - always button 1
+                */
+               if (save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED
+               && !(ACTUAL_BUTTON_STATUS(1) & BUTTON_RELEASED))
+               {
+                  button_no = 1;
+                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
+                  && (SP->_trap_mbe) & BUTTON1_PRESSED)
+                     trap_mouse = TRUE;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
+                  && (SP->_trap_mbe) & BUTTON1_DOUBLE_CLICKED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * Check for Right-most button - always button 3
+                */
+               if (save_ip.Event.MouseEvent.dwButtonState & RIGHTMOST_BUTTON_PRESSED
+               && !(ACTUAL_BUTTON_STATUS(3) & BUTTON_RELEASED))
+               {
+                  button_no = 3;
+                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
+                  && (SP->_trap_mbe) & BUTTON3_PRESSED)
+                     trap_mouse = TRUE;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
+                  && (SP->_trap_mbe) & BUTTON3_DOUBLE_CLICKED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * To get here we have a button release event or another button press
+                * while a current button is pressed. The latter, we throw away.
+                * We have to use the information from the previous mouse event to
+                * determine which button was released.
+                */
+               if (last_button_no == 1
+               && (ACTUAL_BUTTON_STATUS(1) & BUTTON_PRESSED
+                   || ACTUAL_BUTTON_STATUS(1) & BUTTON_DOUBLE_CLICKED
+                   || ACTUAL_MOUSE_MOVED)
+               && !(save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_1ST_BUTTON_PRESSED))
+               {
+                  button_no = 1;
+                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+                  if ((SP->_trap_mbe) & BUTTON1_RELEASED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * Check for Right-most button - always button 3
+                */
+               if (last_button_no == 3
+               && (ACTUAL_BUTTON_STATUS(3) & BUTTON_PRESSED
+                  || ACTUAL_BUTTON_STATUS(3) & BUTTON_DOUBLE_CLICKED
+                   || ACTUAL_MOUSE_MOVED)
+               && !(save_ip.Event.MouseEvent.dwButtonState & RIGHTMOST_BUTTON_PRESSED))
+               {
+                  button_no = 3;
+                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+                  if ((SP->_trap_mbe) & BUTTON3_RELEASED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * Check for Middle button - button 2 only for 3 button mice
+                */
+               if (save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED
+               && !(ACTUAL_BUTTON_STATUS(2) & BUTTON_RELEASED))
+               {
+                  button_no = 2;
+                  TEMP_BUTTON_STATUS(button_no) = (save_ip.Event.MouseEvent.dwEventFlags)?BUTTON_DOUBLE_CLICKED:BUTTON_PRESSED;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_PRESSED
+                  && (SP->_trap_mbe) & BUTTON2_PRESSED)
+                     trap_mouse = TRUE;
+                  if (TEMP_BUTTON_STATUS(button_no) == BUTTON_DOUBLE_CLICKED
+                  && (SP->_trap_mbe) & BUTTON2_DOUBLE_CLICKED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               if (last_button_no == 2
+               && (ACTUAL_BUTTON_STATUS(2) & BUTTON_PRESSED
+                  || ACTUAL_BUTTON_STATUS(2) & BUTTON_DOUBLE_CLICKED
+                  || ACTUAL_MOUSE_MOVED)
+               && !(save_ip.Event.MouseEvent.dwButtonState & FROM_LEFT_2ND_BUTTON_PRESSED))
+               {
+                  button_no = 2;
+                  TEMP_BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+                  if ((SP->_trap_mbe) & BUTTON2_RELEASED)
+                     trap_mouse = TRUE;
+                  break;
+               }
+               /*
+                * If we get here, then we don't know how to handle the event, so
+                * dispose of it
+                */
+               break;
+            }
+            else /* button motion event */
+            {
+               Temp_Mouse_status.changes |= PDC_MOUSE_MOVED;
+               button_no = last_button_no;
+               if (button_no == 1
+               &&  (SP->_trap_mbe) & BUTTON1_MOVED)
+                  trap_mouse = TRUE;
+               if (button_no == 2
+               &&  (SP->_trap_mbe) & BUTTON2_MOVED)
+                  trap_mouse = TRUE;
+               if (button_no == 3
+               &&  (SP->_trap_mbe) & BUTTON3_MOVED)
+                  trap_mouse = TRUE;
+               break;
+            }
+            break;
+         case WINDOW_BUFFER_SIZE_EVENT:
+            return(-1);
+         default:
+            break;
+      }
+      if (button_no != 0)
+      {
+         /*
+          * We have a button action, rather than a mouse movement or wheel action
+          */
+         TEMP_MOUSE_X_POS = save_ip.Event.MouseEvent.dwMousePosition.X;
+         TEMP_MOUSE_Y_POS = save_ip.Event.MouseEvent.dwMousePosition.Y;
+         /*
+          * First thing is to check if the mouse has been clicked
+          * on a slk area. If the return value is > 0 (indicating the
+          * label number, return with the KEY_F(key) value.
+          * Only call this if we have set trap_mouse to TRUE above.
+          */
+         if (trap_mouse
+         && (key = PDC_mouse_in_slk(TEMP_MOUSE_Y_POS,TEMP_MOUSE_X_POS)))
+            return(KEY_F(key));
+
+         Temp_Mouse_status.changes |= (1 << (button_no-1));
+         if (save_ip.Event.MouseEvent.dwControlKeyState & SHIFT_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_SHIFT;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & LEFT_CTRL_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & RIGHT_CTRL_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & RIGHT_ALT_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_ALT;
+         if (save_ip.Event.MouseEvent.dwControlKeyState & LEFT_ALT_PRESSED)
+            TEMP_BUTTON_STATUS(button_no) |= BUTTON_ALT;
+         last_button_no = button_no;
+         /*
+          * We now have the current mouse status information for the last
+          * Mouse event.  We need to save this in Actual_Mouse_status so
+          * we can use that when comparing against the next mouse event.
+          * We also need to determine if we need to set Trapped_Mouse_status
+          * based on the settings in SP->_trap_mbe.
+          */
+         memcpy((char*)&Actual_Mouse_status,(char*)&Temp_Mouse_status,sizeof(MOUSE_STATUS));
+         if (trap_mouse)
+            break;
+      }
+      if ( ( Temp_Mouse_status.changes & PDC_MOUSE_WHEEL_DOWN
+        ||   Temp_Mouse_status.changes & PDC_MOUSE_WHEEL_UP )
+      &&  SP->_trap_mbe & MOUSE_WHEEL_SCROLL )
+      {
+         TEMP_MOUSE_X_POS = -1;
+         TEMP_MOUSE_Y_POS = -1;
+         break;
+      }
+   }
+   /*
+    * To get here we have a mouse event that has been trapped by the
+    * user. Save it in the Trapped_Mouse_status structure.
+    */
+   memcpy((char*)&Trapped_Mouse_status,(char*)&Temp_Mouse_status,sizeof(MOUSE_STATUS));
+   return(KEY_MOUSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_ctrl_break()  - return OS control break state
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the current OS Control Break Check state.
+
+  PDCurses Return Value:
+   DOS:
+      This function returns TRUE if the Control Break
+      Check is enabled otherwise FALSE is returned.
+
+   FLEXOS:
+      This function returns TRUE on if the Keyboard Mode
+      allows a break to bre reported otherwise FALSE is returned.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses bool  PDC_get_ctrl_break( void );
+
+**man-end**********************************************************************/
+
+bool  PDC_get_ctrl_break(void)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_ctrl_break() - called\n");
+#endif
+   return FALSE;
+}
+
+/*man-start*********************************************************************
+
+  PDC_rawgetch()  - Returns the next uninterpreted character (if available).
+
+  PDCurses Description:
+   Gets a character without any interpretation at all and returns
+   it. If keypad mode is active for the designated window,
+   function key translation will be performed.  Otherwise,
+   function keys are ignored.  If nodelay mode is active in the
+   window, then PDC_rawgetch() returns -1 if no character is
+   available.
+
+   WARNING:  It is unknown whether the FUNCTION key translation
+        is performed at this level. --Frotz 911130 BUG
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int   PDC_rawgetch( void );
+
+**man-end**********************************************************************/
+
+int   PDC_rawgetch(void)
+{
+   extern   WINDOW*  _getch_win_;
+
+   int   c;
+   int   oldc;
+   bool  return_immediately;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_rawgetch() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)   /* @@ */
+      return( -1 );
+
+   if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+      return_immediately = TRUE;
+   else
+      return_immediately = FALSE;
+
+   if (return_immediately && !PDC_breakout())
+      return( -1 );
+
+   while (1)      /* loop to get valid char */
+   {
+      c = PDC_get_bios_key();
+      oldc = c;
+      /*
+       * Return the key if it is not a special key.
+       */
+      if (c != KEY_MOUSE
+      && (c = PDC_validchar(c)) >= 0)
+      {     /* get & check next char */
+         return( c );
+      }
+      if (_getch_win_->_use_keypad)
+         return( oldc );
+   }
+   return( -1 );
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_ctrl_break()  - Enables/Disables the host OS BREAK key check.
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Enables/Disables the host OS BREAK key check. If the supplied setting
+   is TRUE, this enables CTRL/C and CTRL/BREAK to abort the process.
+   If FALSE, CTRL/C and CTRL/BREAK are ignored.
+
+  PDCurses Return Value:
+   This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_set_ctrl_break( bool setting );
+
+**man-end**********************************************************************/
+
+int   PDC_set_ctrl_break(bool setting)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_set_ctrl_break() - called\n");
+#endif
+
+   return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_sysgetch()  - Return a character using default system routines.
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Gets a character without normal ^S, ^Q, ^P and ^C interpretation
+   and returns it.  If keypad mode is active for the designated
+   window, function key translation will be performed. Otherwise,
+   function keys are ignored. If nodelay mode is active in the
+   window, then sysgetch() returns -1 if no character is
+   available.
+
+  PDCurses Return Value:
+   This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+   No errors are defined for this routine.
+
+  Portability:
+   PDCurses int   PDC_sysgetch( void );
+
+**man-end**********************************************************************/
+
+int   PDC_sysgetch(void)
+{
+   extern   WINDOW*  _getch_win_;
+
+   int  c;
+   bool return_immediately;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_sysgetch() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)  /* @@ */
+      return (-1);
+
+   if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+      return_immediately = TRUE;
+   else
+      return_immediately = FALSE;
+
+   if (return_immediately && !PDC_breakout())
+      return (-1);
+
+   while (1)
+   {
+      c = PDC_get_bios_key();
+      /*
+       * Return the key if it is not a special key.
+       */
+      if ((unsigned int)c < 256)
+         return(c);
+      if ((c = PDC_validchar(c)) >= 0)
+      {
+         return (c);      /* get & check next char */
+      }
+   }
+   return( -1 );
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_validchar() - validate/translate passed character
+
+  PDCurses Description:
+   This is a private PDCurses function.
+
+   Checks that 'c' is a valid character, and if so returns it,
+   with function key translation applied if 'w' has keypad mode
+   set.  If char is invalid, returns -1.
+
+  PDCurses Return Value:
+   This function returns -1 if the passed character is invalid, or
+   the WINDOW* 'w' is NULL, or 'w's keypad is not active.
+
+   This function returns 0 under Flexos if the passed character
+   is 0x0300.  (-:Forget why.  --Frotz 911130:-)
+
+   Otherwise, this function returns the PDCurses equivalent of the
+   passed character.  See the function key and key macros in
+   <curses.h>
+
+  PDCurses Errors:
+   There are no errors defined for this routine.
+
+  Portability:
+   PDCurses int   PDC_validchar( int c );
+
+**man-end**********************************************************************/
+
+int   PDC_validchar(int c)
+{
+   extern   WINDOW*  _getch_win_;
+   int ch=c;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_validchar() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)
+      ch = (-1);   /* bad window pointer     */
+   else if ((unsigned int)c < 256)
+      ch = c;      /* normal character */
+   else if (!(_getch_win_->_use_keypad))
+      ch = (-1);   /* skip if keys if !keypad mode */
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_validchar() - returned: %x\n",ch);
+#endif
+   return(ch);
+}
+
+/***********************************************************************/
+static int GetInterestingEvent( INPUT_RECORD *ip )
+/***********************************************************************/
+{
+   /*
+    * GetInterestingEvent returns 0 if *ip doesn't contain an event which
+    * should be passed back to the user. This function filters "useless"
+    * events.
+    * The function returns the number of events waiting. This may be > 1
+    * if the repeation of real keys pressed so far are > 1.
+    *
+    * Keyboard: Returns 0 on NUMLOCK, CAPSLOCK, SCROLLLOCK.
+    *
+    *           Returns 1 for SHIFT, ALT, CTRL only if no other key has been
+    *           pressed in between; these are returned on keyup in opposite to
+    *           normal keys. The overall flags for processing of SHIFT, ALT,
+    *           CTRL (SP->return_key_modifiers) must have been set.
+    *           FGC: CHANGED BEHAVIOUR: In previous version SHIFT etc had a
+    *                chance to be returned on the first keydown, too. This
+    *                was a bug, because return_key_modifiers were 0.
+    *
+    *           Normal keys are returned on keydown only. The number of
+    *           repeations are returned. Dead keys (diacritics) are omitted.
+    *           See below for a description.
+    *
+    *           The keypad entering of special keys is not supported. This
+    *           feature can be built in by replacing "#ifdef NUMPAD_CHARS"
+    *           with an intelligent code.
+    *
+    * Mouse:    Returns > 0 only if SP->_trap_mbe is set. MOUSE_MOVE without
+    *           a pressed mouse key are ignored.
+    *
+    * Window:   Everything is ignored, including resize requests. In case
+    *           of resize requests the global flag SP->resized is set.
+    *
+    * PLEASE DOCUMENT YOUR WORK!
+    *
+    * THIS FUNCTION IS NOT THREAD-SAFE. NEVER USE MORE THREADS THAN TO
+    * USE THIS FUNCTION. STATIC VARIABLES ARE USED HERE.
+    */
+   int numKeys = 0, vk;
+   static int save_press;
+   static unsigned numpadChar = 0;
+#ifdef PDCDEBUG
+#if defined(PDC_THREAD_BUILD)
+#  define PDC_DEBUG_THREADING1 "-->"
+#  define PDC_DEBUG_THREADING2 "THREADING"
+# else
+#  define PDC_DEBUG_THREADING1 ""
+#  define PDC_DEBUG_THREADING2 ""
+# endif
+   char *ptr="";
+   if (trace_on) PDC_debug("%sGetInterestingEvent(%s) - called\n",PDC_DEBUG_THREADING1,PDC_DEBUG_THREADING2);
+#endif
+
+   switch(ip->EventType)
+   {
+      case KEY_EVENT:
+         vk = ip->Event.KeyEvent.wVirtualKeyCode;
+         if (vk == VK_CAPITAL || vk == VK_NUMLOCK || vk == VK_SCROLL)
+         {
+#ifdef PDCDEBUG
+            ptr = "KEY MODIFIERS";
+#endif
+            numpadChar = 0;
+            save_press = 0;
+            break;  /* throw away some modifiers */
+         }
+         if (ip->Event.KeyEvent.bKeyDown == FALSE)
+         {
+            /* key up, the following check for VK_??? is paranoid hopefully */
+            if ((vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU)
+             && vk == save_press
+             && SP->return_key_modifiers)
+            {
+#ifdef PDCDEBUG
+               ptr = "KEYUP WANTED";
+#else
+               ;
+#endif
+               /*
+                * Fall through and return this key. Still have to check the
+                * dead key condition.
+                */
+               ip->Event.KeyEvent.wRepeatCount = 1; /* always limited */
+            }
+            else if (vk == VK_MENU && numpadChar)
+            {
+               ip->Event.KeyEvent.uChar.AsciiChar = (CHAR) (unsigned char) numpadChar;
+               ip->Event.KeyEvent.dwControlKeyState &= ~LEFT_ALT_PRESSED;
+               ip->Event.KeyEvent.wRepeatCount = 1; /* always limited */
+               ip->Event.KeyEvent.wVirtualKeyCode = VK_NUMPAD0; /* change ALT to something else */
+               numpadChar = 0;
+            }
+            else
+            {
+#ifdef PDCDEBUG
+               ptr = "KEYUP IGNORED";
+#endif
+               break;                    /* throw away other KeyUp events */
+            }
+         }
+         else
+         {
+            if (vk == VK_SHIFT || vk == VK_CONTROL || vk == VK_MENU)
+            {
+               /*
+                * These keys are returned on keyup only.
+                */
+               save_press = (SP->return_key_modifiers) ? vk : 0;
+               numpadChar = 0;
+#ifdef PDCDEBUG
+               ptr = "KEYDOWN SAVED";
+#endif
+               break; /* throw away key press */
+            }
+
+#ifdef NUMPAD_CHARS
+            {
+               if ((ip->Event.KeyEvent.dwControlKeyState & (LEFT_ALT_PRESSED | ENHANCED_KEY)) == LEFT_ALT_PRESSED)
+               {
+                  switch (vk)
+                  {
+                     case VK_CLEAR:  vk = VK_NUMPAD5; break;
+                     case VK_PRIOR:  vk = VK_NUMPAD9; break;
+                     case VK_NEXT:   vk = VK_NUMPAD3; break;
+                     case VK_END:    vk = VK_NUMPAD1; break;
+                     case VK_HOME:   vk = VK_NUMPAD7; break;
+                     case VK_LEFT:   vk = VK_NUMPAD4; break;
+                     case VK_UP:     vk = VK_NUMPAD8; break;
+                     case VK_RIGHT:  vk = VK_NUMPAD6; break;
+                     case VK_DOWN:   vk = VK_NUMPAD2; break;
+                     case VK_INSERT: vk = VK_NUMPAD0; break;
+                     default:
+                        break;
+                  }
+               }
+               if ((vk >= VK_NUMPAD0 && vk <= VK_NUMPAD9)
+                && ip->Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED)
+               {
+#ifdef PDCDEBUG
+                  ptr = "NUMPAD ALTERNATE INPUT";
+#endif
+                  numpadChar *= 10;
+                  numpadChar += vk - VK_NUMPAD0;
+                  break;
+               }
+               else
+                  numpadChar = 0;
+            }
+#else /* NUMPAD_CHARS */
+            {
+               numpadChar = 0;
+            }
+#endif
+         }
+         save_press = 0;
+         /*
+          * Check for diacritics. These are dead keys. Some locale have
+          * modified characters like umlaut-a, which is an "a" with two dots
+          * on it. In some locales you have to press a special key (the dead
+          * key) immediately followed by the "a" to get a composed umlaut-a.
+          * The special key may have a normal meaning with different modifiers.
+          */
+         if (ip->Event.KeyEvent.uChar.AsciiChar == 0 &&
+             (MapVirtualKey(ip->Event.KeyEvent.wVirtualKeyCode,2) & 0x80000000))
+         {
+#ifdef PDCDEBUG
+            ptr = "DIACRITIC IGNORED";
+#endif
+            break;              /* Diacritic characters, ignore them */
+         }
+#ifdef PDCDEBUG
+         ptr = "KEY WANTED";
+#endif
+         numKeys = ip->Event.KeyEvent.wRepeatCount;
+         break;
+
+      case MOUSE_EVENT:
+         /*
+          * If we aren't trapping mouse events, then the "keyboard" hasn't
+          * been hit. Fix from stepheng@clearspeed.com
+          */
+         if (!SP->_trap_mbe)
+         {
+#ifdef PDCDEBUG
+            ptr = "MOUSE - NOT TRAPPED";
+#endif
+            break;
+         }
+         if (ip->Event.MouseEvent.dwEventFlags == MS_MOUSE_MOVED
+         &&  ip->Event.MouseEvent.dwButtonState == 0)
+         {
+#ifdef PDCDEBUG
+            ptr = "MOUSE MOVE IGNORED";
+#endif
+            break;               /* throw away plain MOUSE_MOVE events */
+         }
+#ifdef PDCDEBUG
+         ptr = "MOUSE MOVE WANTED";
+#endif
+         numKeys = 1;
+         break;
+
+      case WINDOW_BUFFER_SIZE_EVENT:
+         SP->resized = TRUE;
+#ifdef PDCDEBUG
+         ptr = "BUFFER SIZE";
+#endif
+         break;
+
+      default:
+#ifdef PDCDEBUG
+         ptr = "UNKNOWN";
+#endif
+         break;
+   }
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%sGetInterestingEvent(%s) - returning: numKeys %d type %d: %s\n",PDC_DEBUG_THREADING1,PDC_DEBUG_THREADING2,numKeys,ip->EventType,ptr);
+#endif
+   return numKeys;
+}
+
+#if defined(PDC_THREAD_BUILD)
+/***********************************************************************/
+static int win32_kbhit(int timeout)
+/***********************************************************************/
+{
+   DWORD read=0,avail=0,unread=0;
+   INPUT_RECORD ip;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("win32_kbhit(THREADING) - called: timeout %d\n", timeout);
+#endif
+
+
+#if 0
+   if ( timeout == INFINITE )
+   {
+      ReadFile( hPipeRead, &save_ip, sizeof(INPUT_RECORD), &read, NULL );
+      return TRUE;
+   }
+   else
+   {
+      if ( WaitForSingleObject( hSemKeyCount, timeout ) != WAIT_OBJECT_0 )
+      {
+         return FALSE;
+      }
+      if ( PeekNamedPipe( hPipeRead, &ip, sizeof(INPUT_RECORD), &read, &avail, &unread ) )
+      {
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("win32_kbhit(THREADING) - maybe key on pipe. read %d avail %d unread %d\n",read,avail,unread);
+#endif
+         if ( read == sizeof(INPUT_RECORD) )
+            return TRUE;
+      }
+   }
+#else
+   if ( WaitForSingleObject( hSemKeyCount, timeout ) != WAIT_OBJECT_0 )
+   {
+      return FALSE;
+   }
+   if ( timeout == INFINITE )
+   {
+      ReadFile( hPipeRead, &save_ip, sizeof(INPUT_RECORD), &read, NULL );
+      return TRUE;
+   }
+   else
+   {
+      if ( PeekNamedPipe( hPipeRead, &ip, sizeof(INPUT_RECORD), &read, &avail, &unread ) )
+      {
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("win32_kbhit(THREADING) - maybe key on pipe. read %d avail %d unread %d\n",read,avail,unread);
+#endif
+         if ( read == sizeof(INPUT_RECORD) )
+            return TRUE;
+      }
+   }
+#endif
+   return FALSE;
+}
+
+
+/***********************************************************************/
+static void win32_getch(void)
+/***********************************************************************/
+{
+   while (win32_kbhit(INFINITE) == FALSE)
+      ;
+
+   return;
+}
+#else
+
+/***********************************************************************/
+static int win32_kbhit(int timeout)
+/***********************************************************************/
+{
+   INPUT_RECORD ip;
+   DWORD read;
+   int rc=FALSE;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("win32_kbhit() - called: timeout %d keyCount %d\n", timeout, keyCount);
+#endif
+
+   if (keyCount > 0)
+      return TRUE;
+
+   if (WaitForSingleObject(hConIn, timeout) != WAIT_OBJECT_0)
+   {
+      return FALSE;
+   }
+
+   PeekConsoleInput(hConIn, &ip, 1, &read);
+   if (read == 0)
+      return(FALSE);
+   ReadConsoleInput(hConIn, &ip, 1, &read);
+
+   keyCount = GetInterestingEvent( &ip );
+   if ( keyCount )
+   {
+      /*
+       * To get here a recognised event has occurred; save it and return TRUE
+       */
+      memcpy( (char*)&save_ip, (char*)&ip, sizeof(INPUT_RECORD) );
+      rc = TRUE;
+   }
+   return(rc);
+}
+
+/***********************************************************************/
+static void win32_getch(void)
+/***********************************************************************/
+{
+   while (win32_kbhit(INFINITE) == FALSE)
+      ;
+
+   keyCount --;
+
+   return;
+}
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_get_key_modifiers()  - Returns the keyboard modifier(s) at time of last getch()
+
+  PDCurses Description:
+   This is a private PDCurses routine.
+
+   Returns the keyboard modifiers effective at the time of the last getch()
+   call only if PDC_save_key_modifiers(TRUE) has been called before the
+   getch();
+   Use the macros; PDC_KEY_MODIFIER_* to determine which modifier(s)
+   were set.
+
+  PDCurses Return Value:
+   This function returns the modifiers.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_get_key_modifiers( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long  PDC_get_key_modifiers(void)
+#else
+unsigned long  PDC_get_key_modifiers()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_get_key_modifiers() - called\n");
+#endif
+   return(pdc_key_modifiers);
+}
+
+
+#if defined(PDC_THREAD_BUILD)
+/***********************************************************************/
+LONG InputThread( LPVOID lpThreadData )
+/***********************************************************************/
+{
+   INPUT_RECORD ip;
+   DWORD read;
+   LONG prev;
+   int num_keys,i;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("-->InputThread() - called\n");
+#endif
+   /*
+    * Create a semaphore on which the parent thread will wait...
+    */
+   hSemKeyCount = CreateSemaphore( NULL, 0, 1024, NULL );
+   if ( hSemKeyCount != NULL )
+   {
+      for ( ; ; )
+      {
+         ReadConsoleInput(hConIn, &ip, 1, &read);
+         /*
+          * Now that this thread has woken up we need to check if the
+          * key/mouse event is relevant to us. If so, write it to the
+          * anonymous pipe.
+          */
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("-->InputThread() - read %d character(s)\n",read);
+#endif
+         num_keys = GetInterestingEvent( &ip );
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("-->InputThread() - got %d interesting keys\n",num_keys);
+#endif
+         for ( i = 0; i < num_keys; i++ )
+         {
+            /*
+             * For each key written to the pipe, increment the semaphore...
+             */
+            if ( ReleaseSemaphore( hSemKeyCount, 1, &prev ) )
+            {
+#ifdef PDCDEBUG
+               if (trace_on) PDC_debug("-->InputThread() - writing to pipe; sem incremented from %d\n",prev);
+#endif
+               if ( !WriteFile( hPipeWrite, &ip, sizeof(INPUT_RECORD), &read, NULL ) )
+               {
+                  /*
+                   * An error occured, we assume it is because the pipe broke;
+                   * therefore the parent thread is shutting down; so will we.
+                   */
+                  break;
+               }
+            }
+         }
+      }
+   }
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("-->InputThread() - finished\n");
+#endif
+   return 0;
+}
+#endif
diff -Naur gdb-6.8/pdcurses/win32/pdcprint.c stsgdb-6.8/pdcurses/win32/pdcprint.c
--- gdb-6.8/pdcurses/win32/pdcprint.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcprint.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,60 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCprint  = "$Id: pdcprint.c,v 1.1 2001/01/10 08:30:50 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_print()	- Provides primitive access to the BIOS printer functions
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Implements write/init/read printer services at the BIOS level.
+
+ 	This provides the basic support that PDCurses needs to dump the
+ 	contents of windows or pads to the printer attached to the BIOS
+ 	printer port.
+
+  PDCurses Return Value:
+ 	See the BIOS INT 0x17 specifications.
+
+  PDCurses Errors:
+ 	See the BIOS INT 0x17 specifications.
+
+  Portability:
+ 	PDCurses	int PDC_print( int cmd, int byte, int port );
+
+**man-end**********************************************************************/
+
+int	PDC_print(int cmd, int byte, int port)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_print() - called\n");
+#endif
+
+	return( OK );
+}
diff -Naur gdb-6.8/pdcurses/win32/pdcscrn.c stsgdb-6.8/pdcurses/win32/pdcscrn.c
--- gdb-6.8/pdcurses/win32/pdcscrn.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcscrn.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,639 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define  CURSES_LIBRARY 1
+#define  INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCscrn  = "$Id: pdcscrn.c,v 1.12 2005/12/11 05:51:24 wmcbrine Exp $";
+#endif
+
+#define PDC_RESTORE_NONE     0
+#define PDC_RESTORE_BUFFER   1
+#define PDC_RESTORE_WINDOW   2
+
+HANDLE hConOut = INVALID_HANDLE_VALUE;
+HANDLE hConIn = INVALID_HANDLE_VALUE;
+#if defined(PDC_THREAD_BUILD)
+HANDLE hPipeRead = INVALID_HANDLE_VALUE;
+HANDLE hPipeWrite = INVALID_HANDLE_VALUE;
+HANDLE hSemKeyCount = INVALID_HANDLE_VALUE;
+extern LONG InputThread( LPVOID lpThreadData );
+#endif
+
+CONSOLE_SCREEN_BUFFER_INFO scr;
+CONSOLE_SCREEN_BUFFER_INFO orig_scr;
+
+static CHAR_INFO *ciSaveBuffer=NULL;
+static CHAR_INFO *save_ci=NULL;
+static DWORD dwConsoleMode=0;
+
+/*man-start*********************************************************************
+
+  PDC_scr_close() - Internal low-level binding to close the physical screen
+
+  PDCurses Description:
+   This function provides a low-level binding for the Flexos
+   platform which must close the screen before writing to it.
+   This is a nop for the DOS platform.
+
+   This function is provided in order to reset the FlexOS 16 bit
+   character set for input rather than the limited input
+   character set associated with the VT52.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+   The DOS platform will never fail.  The Flexos platform may fail
+   depending on the ability to close the current virtual console in
+   8 (as opposed to 16) bit mode.
+
+  Portability:
+   PDCurses int   PDC_scr_close( void );
+
+**man-end**********************************************************************/
+
+int   PDC_scr_close(void)
+{
+ COORD origin;
+ SMALL_RECT rect;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scr_close() - called\n");
+#endif
+   /*
+    * All of this code should probably go into DllMain() at DLL_PROCESS_DETACH
+    */
+   SetConsoleScreenBufferSize(hConOut, orig_scr.dwSize);
+   SetConsoleWindowInfo(hConOut,TRUE,&orig_scr.srWindow);
+   SetConsoleScreenBufferSize(hConOut, orig_scr.dwSize);
+   SetConsoleWindowInfo(hConOut,TRUE,&orig_scr.srWindow);
+
+   if (SP->_restore == PDC_RESTORE_WINDOW)
+   {
+      rect.Top = orig_scr.srWindow.Top;
+      rect.Left = orig_scr.srWindow.Left;
+      rect.Bottom = orig_scr.srWindow.Bottom;
+      rect.Right = orig_scr.srWindow.Right;
+      origin.X = origin.Y = 0;
+      if (!WriteConsoleOutput(hConOut,ciSaveBuffer,orig_scr.dwSize,origin,&rect))
+         return(ERR);
+   }
+   else if (SP->_restore == PDC_RESTORE_BUFFER)
+   {
+      rect.Top = rect.Left = 0;
+      rect.Bottom = orig_scr.dwSize.Y  - 1;
+      rect.Right = orig_scr.dwSize.X - 1;
+      origin.X = origin.Y = 0;
+      if (!WriteConsoleOutput(hConOut,ciSaveBuffer,orig_scr.dwSize,origin,&rect))
+         return(ERR);
+   }
+
+   SetConsoleActiveScreenBuffer(hConOut);
+   SetConsoleMode(hConIn, dwConsoleMode);
+#if defined(PDC_THREAD_BUILD)
+   if ( hPipeRead != INVALID_HANDLE_VALUE )
+      CloseHandle( hPipeRead );
+   if ( hPipeWrite != INVALID_HANDLE_VALUE )
+      CloseHandle( hPipeWrite );
+#endif
+
+   return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_scrn_modes_equal()   - Decide if two screen modes are equal
+
+  PDCurses Description:
+   Mainly required for OS/2. It decides if two screen modes
+        (VIOMODEINFO structure) are equal. Under DOS it just compares
+        two integers
+
+  PDCurses Return Value:
+   This function returns TRUE if equal else FALSe.
+
+  PDCurses Errors:
+   No errors are defined for this function.
+
+  Portability:
+   PDCurses int PDC_scrn_modes_equal( int mode1, int mode2 );
+   OS2 PDCurses   int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
+
+**man-end**********************************************************************/
+
+bool  PDC_scrn_modes_equal(int mode1, int mode2)
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scrn_modes_equal() - called\n");
+#endif
+   return (mode1 == mode2);
+}
+
+/*man-start*********************************************************************
+
+  PDC_scr_open()  - Internal low-level binding to open the physical screen
+
+  PDCurses Description:
+   This function provides a low-level binding for the Flexos
+   platform which must open the screen before writing to it.
+
+   This function is provided in order to access the FlexOS 16 bit
+   character set for input rather than the limited input
+   character set associated with the VT52.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+   The DOS platform will never fail.  The Flexos platform may fail
+   depending on the ability to open the current virtual console in
+   8 (as opposed to 16) bit mode.
+
+  Portability:
+   PDCurses int   PDC_scr_open( SCREEN* internal, bool echo );
+
+**man-end**********************************************************************/
+
+int   PDC_scr_open(SCREEN *internal, bool echo)
+{
+   COORD bufsize,origin;
+   SMALL_RECT rect;
+   char *str;
+   CONSOLE_SCREEN_BUFFER_INFO csbi;
+#if defined(PDC_THREAD_BUILD)
+   HANDLE hThread;
+   DWORD dwThreadID;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_scr_open() - called\n");
+#endif
+
+   hConOut = GetStdHandle(STD_OUTPUT_HANDLE);
+   hConIn = GetStdHandle(STD_INPUT_HANDLE);
+
+   GetConsoleScreenBufferInfo(hConOut, &csbi);
+   GetConsoleScreenBufferInfo(hConOut, &orig_scr);
+   GetConsoleMode(hConIn, &dwConsoleMode);
+
+   if ((str = getenv("LINES")) != NULL)
+      internal->lines = atoi(str);
+   else
+      internal->lines   = PDC_get_rows();
+
+   if ((str = getenv("COLS")) != NULL)
+      internal->cols = atoi(str);
+   else
+      internal->cols = PDC_get_columns();
+
+   if (internal->lines < 2
+   ||  internal->lines > csbi.dwMaximumWindowSize.Y)
+   {
+      fprintf(stderr,"LINES value must be >= 2 and <= %d: got %d\n",
+            csbi.dwMaximumWindowSize.Y,
+            internal->lines);
+      return(ERR);
+   }
+
+   if (internal->cols < 2
+   ||  internal->cols > csbi.dwMaximumWindowSize.X)
+   {
+      fprintf(stderr,"COLS value must be >= 2 and <= %d: got %d\n",
+            csbi.dwMaximumWindowSize.X,
+            internal->cols);
+      return(ERR);
+   }
+   if ( getenv( "PDC_ORIGINAL_COLORS" ) != NULL )
+   {
+      chtype orig_back, orig_fore;
+      orig_fore = csbi.wAttributes & FOREGROUND_MASK;
+      orig_back = (csbi.wAttributes & BACKGROUND_MASK) >> 4;
+      internal->orig_attr = (orig_back << 16) | orig_fore;
+   }
+   else
+   {
+      internal->orig_attr = 0;
+   }
+
+   internal->_restore = PDC_RESTORE_NONE;
+   if (getenv("PDC_RESTORE_SCREEN") != NULL)
+   {
+      /*
+       * Attempt to save the complete console buffer...
+       */
+      if ((ciSaveBuffer = (CHAR_INFO*)malloc(orig_scr.dwSize.X*orig_scr.dwSize.Y*sizeof(CHAR_INFO))) == NULL)
+      {
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("PDC_scr_open() - exiting at line %d\n",__LINE__);
+#endif
+         return(ERR);
+      }
+      bufsize.X = orig_scr.dwSize.X;
+      bufsize.Y = orig_scr.dwSize.Y;
+
+      origin.X = origin.Y = 0;
+
+      rect.Top = rect.Left = 0;
+      rect.Bottom = orig_scr.dwSize.Y  - 1;
+      rect.Right = orig_scr.dwSize.X - 1;
+      if (!ReadConsoleOutput(hConOut,ciSaveBuffer,bufsize,origin,&rect))
+      {
+         /*
+          * We can't save the complete buffer, so try and save just the displayed window...
+          */
+         free(ciSaveBuffer);
+         ciSaveBuffer = NULL;
+
+         bufsize.X = orig_scr.srWindow.Right - orig_scr.srWindow.Left + 1;
+         bufsize.Y = orig_scr.srWindow.Bottom - orig_scr.srWindow.Top + 1;
+         if ((ciSaveBuffer = (CHAR_INFO*)malloc(bufsize.X*bufsize.Y*sizeof(CHAR_INFO))) == NULL)
+         {
+            CHAR LastError[256];
+            ULONG last_error = GetLastError();
+            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, last_error, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT), LastError, 256, NULL ) ;
+#ifdef PDCDEBUG
+            if (trace_on) PDC_debug("PDC_scr_open() - exiting at line %d: %s\n",__LINE__,LastError);
+#endif
+            return(ERR);
+         }
+
+         origin.X = origin.Y = 0;
+
+         rect.Top = orig_scr.srWindow.Top;
+         rect.Left = orig_scr.srWindow.Left;
+         rect.Bottom = orig_scr.srWindow.Bottom;
+         rect.Right = orig_scr.srWindow.Right;
+         if (!ReadConsoleOutput(hConOut,ciSaveBuffer,bufsize,origin,&rect))
+         {
+            CHAR LastError[256];
+            ULONG last_error = GetLastError();
+            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, last_error, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT), LastError, 256, NULL ) ;
+            free(ciSaveBuffer);
+            ciSaveBuffer = NULL;
+#ifdef PDCDEBUG
+            if (trace_on) PDC_debug("PDC_scr_open() - exiting at line %d: %s\n",__LINE__,LastError);
+#endif
+            return(ERR);
+         }
+         internal->_restore = PDC_RESTORE_WINDOW;
+      }
+      else
+         internal->_restore = PDC_RESTORE_BUFFER;
+   }
+
+   if (getenv("PDC_PRESERVE_SCREEN") != NULL)
+   {
+      bufsize.X = csbi.srWindow.Right - csbi.srWindow.Left + 1;
+      bufsize.Y = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
+      if ((save_ci = (CHAR_INFO*)malloc(bufsize.X*bufsize.Y*sizeof(CHAR_INFO))) == NULL)
+      {
+         CHAR LastError[256];
+         ULONG last_error = GetLastError();
+         FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, last_error, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT), LastError, 256, NULL ) ;
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("PDC_scr_open() - exiting at line %d: %s\n",__LINE__,LastError);
+#endif
+         return(ERR);
+      }
+
+      origin.X = origin.Y = 0;
+
+      rect.Top = csbi.srWindow.Top;
+      rect.Left = csbi.srWindow.Left;
+      rect.Bottom = csbi.srWindow.Bottom;
+      rect.Right = csbi.srWindow.Right;
+      if (!ReadConsoleOutput(hConOut,save_ci,bufsize,origin,&rect))
+      {
+         CHAR LastError[256];
+         ULONG last_error = GetLastError();
+         FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM, NULL, last_error, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT), LastError, 256, NULL ) ;
+         free(save_ci);
+         save_ci = NULL;
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("PDC_scr_open() - exiting at line %d: %s\n",__LINE__,LastError);
+#endif
+         return(ERR);
+      }
+      internal->_preserve = TRUE;
+   }
+   else
+      internal->_preserve = FALSE;
+
+   bufsize.X = orig_scr.srWindow.Right - orig_scr.srWindow.Left + 1;
+   bufsize.Y = orig_scr.srWindow.Bottom - orig_scr.srWindow.Top + 1;
+   rect.Top = rect.Left = 0;
+   rect.Bottom = bufsize.Y - 1;
+   rect.Right = bufsize.X - 1;
+
+   SetConsoleScreenBufferSize(hConOut, bufsize);
+   SetConsoleWindowInfo(hConOut,TRUE,&rect);
+   SetConsoleScreenBufferSize(hConOut, bufsize);
+   SetConsoleActiveScreenBuffer(hConOut);
+
+   PDC_reset_prog_mode();
+
+   PDC_get_cursor_pos(&internal->cursrow, &internal->curscol);
+   internal->direct_video  = TRUE; /* Assume that we can      */
+   internal->autocr  = TRUE;     /* lf -> crlf by default     */
+   internal->raw_out = FALSE; /* tty I/O modes       */
+   internal->raw_inp = FALSE; /* tty I/O modes       */
+   internal->cbreak  = TRUE;
+   internal->save_key_modifiers  = FALSE;
+   internal->return_key_modifiers   = FALSE;
+   internal->echo = echo;
+   internal->refrbrk = FALSE;  /* no premature end of refresh*/
+   internal->video_seg  = 0xb000;   /* Base screen segment addr   */
+   internal->video_ofs  = 0x0;      /* Base screen segment ofs    */
+   internal->video_page = 0;     /* Current Video Page         */
+   internal->visible_cursor= TRUE;  /* Assume that it is visible  */
+   internal->cursor  = PDC_get_cursor_mode();
+
+   internal->adapter = PDC_query_adapter_type();
+   internal->scrnmode   = PDC_get_scrn_mode();
+
+   internal->audible = TRUE;
+   internal->visibility = 1;
+   internal->orig_cursor = internal->cursor;
+   internal->orgcbr = PDC_get_ctrl_break();
+   internal->blank = ' ';
+   internal->resized = FALSE;
+   internal->shell = FALSE;
+   internal->_trap_mbe = 0L;
+   internal->_map_mbe_to_key = 0L;
+   internal->linesrippedoff = 0;
+   internal->linesrippedoffontop = 0;
+   internal->delaytenths = 0;
+
+   internal->os_version = GetVersion();
+#if defined(PDC_THREAD_BUILD)
+   /*
+    * Create the anonymous pipe and thread for handling input
+    */
+   if ( !CreatePipe( &hPipeRead,     // reading handle
+                     &hPipeWrite,    // writing handle
+                     NULL,           // handles not inherited
+                     0 ) )           // default buffer size
+   {
+      // error during pipe creation
+      fprintf( stderr, "Cannot create input pipe\n" );
+      return( ERR );
+   }
+   hThread = CreateThread( NULL,              // security attributes
+                           0,                 // initial stack size
+                           (LPTHREAD_START_ROUTINE) InputThread,
+                           NULL,              // argument
+                           CREATE_SUSPENDED,  // creation flag
+                           &dwThreadID );     // new thread ID
+   if ( ! hThread )
+   {
+      fprintf( stderr, "Cannot create input thread\n" );
+      return( ERR );
+   }
+   ResumeThread( hThread );
+#endif
+
+   return( OK );
+}
+
+static BOOL FitConsoleWindow(HANDLE hConOut, CONST SMALL_RECT *rect)
+/* Calls SetConsoleWindowInfo with the given parameters but fits them if a
+ * scoll bar shrinks the maximum possible value. The rectangle must at least
+ * fit in a half-sized window.
+ */
+{
+ SMALL_RECT run;
+ SHORT mx, my;
+
+   if (SetConsoleWindowInfo(hConOut, TRUE, rect))
+      return(TRUE);
+
+   run = *rect;
+   run.Right /= 2;
+   run.Bottom /= 2;
+   mx = run.Right;
+   my = run.Bottom;
+
+   if (!SetConsoleWindowInfo(hConOut, TRUE, &run))
+      return(FALSE);
+   for (run.Right = rect->Right;run.Right >= mx;run.Right--)
+   {
+      if (SetConsoleWindowInfo(hConOut, TRUE, &run))
+         break;
+   }
+   if (run.Right < mx)
+      return(FALSE);
+   for (run.Bottom = rect->Bottom;run.Bottom >= my;run.Bottom--)
+   {
+      if (SetConsoleWindowInfo(hConOut, TRUE, &run))
+         return(TRUE);
+   }
+   return(FALSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_resize_screen()   - Internal low-level function to resize screen
+
+  PDCurses Description:
+   This function provides a means for the application program to
+   resize the overall dimensions of the screen.  Under DOS and OS/2
+   the application can tell PDCurses what size to make the screen;
+   under X11, resizing is done by the user and this function simply
+   adjusts its internal structures to fit the new size.
+   This function doesn't set LINES, COLS, SP->lines or SP->cols. This
+   must be done by resize_term.
+   If both arguments are 0 the function returns sucessfully. This
+   allows the calling routine to reset the SP->resized flag.
+   The functions fails if one of the arguments is less then 2.
+
+  PDCurses Return Value:
+   This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+
+  Portability:
+   PDCurses int   PDC_resize_screen( int, int );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_resize_screen(int nlines, int ncols)
+#else
+int   PDC_resize_screen(nlines, ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+#ifdef MHES
+   COORD size, max;
+   SMALL_RECT rect,displayarea = {0,0,0,0};
+   CONSOLE_SCREEN_BUFFER_INFO csbi;
+   int external_resized = SP->resized;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+   SP->resized = FALSE; /* prevent endless loops in case of errors */
+
+   if (nlines == 0
+   && ncols == 0)
+      return(OK); /* undocumented feature: let assign LINES and COLS
+                          to current values by the calling
+                          resize_term-function */
+
+   if (nlines < 2 || ncols < 2)
+      return(ERR);
+
+   if (!GetConsoleScreenBufferInfo(hConOut,&csbi)) /*needed for recovery*/
+      return(ERR);
+   max = GetLargestConsoleWindowSize(hConOut);
+
+   size.X = ncols;
+   size.Y = nlines;
+
+   /* Fit window into allowed values */
+   rect.Left = rect.Top = 0;
+   rect.Right = ncols - 1;
+   if (rect.Right >= max.X)
+      rect.Right = max.X;
+   rect.Bottom = rect.Top + nlines - 1;
+   if (rect.Bottom >= max.Y)
+      rect.Bottom = max.Y;
+   FitConsoleWindow(hConOut, &rect); /* helps to allow the BufferSize */
+   displayarea.Right = rect.Right;
+   displayarea.Bottom = rect.Bottom;
+   if (!SetConsoleScreenBufferSize(hConOut, size) ||
+       !FitConsoleWindow(hConOut, &rect) ||
+       !SetConsoleWindowInfo(hConOut, TRUE, &displayarea))
+   {
+      SetConsoleScreenBufferSize(hConOut, csbi.dwSize);
+      SetConsoleWindowInfo(hConOut, TRUE, &csbi.srWindow);
+      return( (external_resized) ? OK : ERR );
+   }
+
+   SetConsoleActiveScreenBuffer(hConOut);
+   return ( OK );
+#elif defined(FGC)
+   int rc=OK;
+   COORD size;
+   SMALL_RECT rect;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+
+   if (nlines < 2)
+      return(ERR);
+   SP->lines = LINES = nlines;
+
+   if (ncols < 2)
+      return(ERR);
+   SP->cols = COLS = ncols;
+
+   size.X = SP->cols;
+   size.Y = SP->lines;
+   rect.Top = rect.Left = 0;
+   rect.Bottom = SP->lines - 1;
+   rect.Right = SP->cols - 1;
+   SetConsoleScreenBufferSize(hConOut, size);
+   SetConsoleWindowInfo(hConOut,TRUE,&rect);
+   SetConsoleScreenBufferSize(hConOut, size);
+   SetConsoleWindowInfo(hConOut,TRUE,&rect);
+   SetConsoleActiveScreenBuffer(hConOut);
+   SP->resized = FALSE;
+   return ( rc );
+#else
+   int rc=OK;
+   SMALL_RECT rect;
+   COORD size, max;
+
+   if (nlines < 2 || ncols < 2)
+      return(ERR);
+   max = GetLargestConsoleWindowSize(hConOut);
+
+   rect.Left = rect.Top = 0;
+   rect.Right = ncols - 1;
+   if (rect.Right >= max.X)
+      rect.Right = max.X;
+   rect.Bottom = nlines - 1;
+   if (rect.Bottom >= max.Y)
+      rect.Bottom = max.Y;
+   size.X = rect.Right + 1;
+   size.Y = rect.Bottom + 1;
+   FitConsoleWindow(hConOut, &rect);
+   SetConsoleScreenBufferSize(hConOut, size);
+   FitConsoleWindow(hConOut, &rect);
+   SetConsoleScreenBufferSize(hConOut, size);
+
+
+   SetConsoleActiveScreenBuffer(hConOut);
+   SP->resized = FALSE;
+   return ( rc );
+#endif
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_reset_prog_mode(void)
+#else
+int   PDC_reset_prog_mode()
+#endif
+/***********************************************************************/
+{
+   SetConsoleMode(hConIn, ENABLE_MOUSE_INPUT | ENABLE_WINDOW_INPUT);
+   return(OK);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int   PDC_reset_shell_mode(void)
+#else
+int   PDC_reset_shell_mode()
+#endif
+/***********************************************************************/
+{
+   SetConsoleMode(hConIn, dwConsoleMode);
+   return(OK);
+}
+
+#if defined(PDC_DLL_BUILD)
+BOOL WINAPI DllMain( HINSTANCE hDLL, DWORD dwReason, LPVOID pReserved)
+{
+   switch( dwReason)
+   {
+      case DLL_PROCESS_ATTACH:
+/*         fprintf(stderr,"DLL_PROCESS_ATTACH\n"); */
+         break;
+      case DLL_PROCESS_DETACH:
+/*         fprintf(stderr,"DLL_PROCESS_DETACH\n"); */
+         break;
+      case DLL_THREAD_ATTACH:
+/*         fprintf(stderr,"DLL_THREAD_ATTACH\n"); */
+         break;
+      case DLL_THREAD_DETACH:
+/*         fprintf(stderr,"DLL_THREAD_DETACH\n"); */
+         break;
+   }
+   return(TRUE);
+}
+#endif
diff -Naur gdb-6.8/pdcurses/win32/pdcsetsc.c stsgdb-6.8/pdcurses/win32/pdcsetsc.c
--- gdb-6.8/pdcurses/win32/pdcsetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcsetsc.c	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,270 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#define	INCLUDE_WINDOWS_H
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCsetsc  = "$Id: pdcsetsc.c,v 1.3 2005/12/09 16:38:36 wmcbrine Exp $";
+#endif
+
+extern HANDLE hConOut;
+
+/*man-start*********************************************************************
+
+  PDC_set_80x25()	- force a known screen state: 80x25 text mode.
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Forces the appropriate 80x25 alpha mode given the display adapter.
+
+ 	Since we currently do not support changing the virtual console size,
+ 	this routine is a NOP under Flexos.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_set_80x25( void );
+
+**man-end**********************************************************************/
+
+int	PDC_set_80x25(void)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_80x25() - called\n");
+#endif
+
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_cursor_mode()	- Set the cursor start and stop scan lines.
+
+  PDCurses Description:
+ 	Sets the cursor type to begin in scan line startrow and end in
+ 	scan line endrow.  Both values should be 0-31.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_cursor_mode( int startrow, int endrow );
+
+**man-end**********************************************************************/
+
+int	PDC_set_cursor_mode( int startrow, int endrow )
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_cursor_mode() - called: startrow %d endrow %d\n",startrow,endrow);
+#endif
+
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_font()	- sets the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine sets the current font size, if the adapter allows
+ 	such a change.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the font size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_font( int size );
+
+**man-end**********************************************************************/
+
+int	PDC_set_font(int size)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_font() - called\n");
+#endif
+
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_rows()	- sets the physical number of rows on screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine attempts to set the number of rows on the physical
+ 	screen to the passed value.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the screen size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_rows( int rows );
+
+**man-end**********************************************************************/
+
+int	PDC_set_rows(int rows)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_rows() - called\n");
+#endif
+
+	return(0);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_scrn_mode()	- Set BIOS Video Mode
+
+  PDCurses Description:
+ 	Sets the BIOS Video Mode Number ONLY if it is different from
+ 	the current video mode.  This routine is for DOS systems only.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_scrn_mode( int new_mode );
+
+**man-end**********************************************************************/
+
+int	PDC_set_scrn_mode(int new_mode)
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_scrn_mode() - called\n");
+#endif
+
+	return(OK); /* this is N/A */
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_curs_set(int visibility)
+#else
+int	PDC_curs_set(visibility)
+int visibility;
+#endif
+/***********************************************************************/
+{
+ CONSOLE_CURSOR_INFO cci;
+ int ret_vis;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+	ret_vis = SP->visibility;
+
+	if (GetConsoleCursorInfo(hConOut,&cci) == FALSE)
+		return ERR;
+
+	switch(visibility)
+	{
+		case 0:                 /* invisible */
+			cci.bVisible = FALSE;
+			break;
+		case 2:                 /* highly visible */
+			cci.bVisible = TRUE;
+			cci.dwSize = 95;
+			break;
+		default:                /* normal visibility */
+			cci.bVisible = TRUE;
+			cci.dwSize = 25;
+			break;
+	}
+
+	if (SetConsoleCursorInfo(hConOut,&cci) == FALSE)
+		return ERR;
+
+	SP->visibility = visibility;
+	return(ret_vis);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_title()	- Set window title
+
+  PDCurses Description:
+ 	Sets the title of the window in which the curses program is running.
+ 	This function may not do anything on some platforms.
+
+  PDCurses Return Value:
+ 	N/A
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	void PDC_set_title( char *title );
+
+**man-end**********************************************************************/
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_set_title(char *title)
+#else
+void	PDC_set_title(title)
+char *title;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_title() - called:<%s>\n",title);
+#endif
+
+	SetConsoleTitle(title);
+	return;
+}
diff -Naur gdb-6.8/pdcurses/win32/pdcurses.ico stsgdb-6.8/pdcurses/win32/pdcurses.ico
--- gdb-6.8/pdcurses/win32/pdcurses.ico	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcurses.ico	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1 @@
+             &        (    (       @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ok[{_k[ss3c3333s(                                                                                                                                                                                                           k  j   j             _      _  _      
\ No newline at end of file
diff -Naur gdb-6.8/pdcurses/win32/pdcurses.rc stsgdb-6.8/pdcurses/win32/pdcurses.rc
--- gdb-6.8/pdcurses/win32/pdcurses.rc	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/pdcurses.rc	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,28 @@
+#include "winver.h"
+
+1 VERSIONINFO
+ FILEVERSION 2,7,0,0
+ PRODUCTVERSION 2,7,0,0
+ FILEFLAGSMASK 0x3fL
+ FILEFLAGS 0x0L
+ FILEOS VOS_UNKNOWN
+ FILETYPE VFT_DLL
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "Maintainer", "William McBrine\0"
+            VALUE "FileDescription", "Public Domain Curses\0"
+            VALUE "FileVersion", "2.7.0\0"
+            VALUE "InternalName", "PDCurses\0"
+            VALUE "LegalCopyright", "Public Domain\0"
+            VALUE "OriginalFilename", "CURSES.DLL\0"
+            VALUE "ProductName", "Public Domain Curses Library\0"
+            VALUE "ProductVersion", "2.7.0\0"
+        END
+    END
+END
+
+1 ICON    DISCARDABLE     "PDCURSES.ico"
diff -Naur gdb-6.8/pdcurses/win32/README stsgdb-6.8/pdcurses/win32/README
--- gdb-6.8/pdcurses/win32/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/README	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,19 @@
+
+                        Welcome to PDCurses
+
+ Contents
+ --------
+ This directory contains core PDCurses source code files specific to
+ the Win32 platform - console mode (Win9x/Me/NT/2k/XP).
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory are released to the Public Domain.
+
+
+ Acknowlegements
+ ---------------
+
+ Generic Win32 port was provided by Chris Szurgot (szurgot@itribe.net)
diff -Naur gdb-6.8/pdcurses/win32/vcwin32.mak stsgdb-6.8/pdcurses/win32/vcwin32.mak
--- gdb-6.8/pdcurses/win32/vcwin32.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/vcwin32.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,618 @@
+################################################################################
+#
+# Visual C++ NMakefile for PDCurses library - Win32 VC++ 2.0+
+#
+# Usage: nmake -f [path\]vcwin32.mak [DEBUG=] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line 
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H	=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H	=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS	=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\win32
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= cl.exe -nologo
+
+!ifdef DEBUG
+CFLAGS  = -Z7 -DPDCDEBUG
+LDFLAGS = -debug -pdb:none
+!else
+CFLAGS  =  -Ox
+LDFLAGS =
+!endif
+
+SHL_LD=link $(LDFLAGS) /NOLOGO /DLL /OUT:curses.dll /DEF:$(osdir)\curses.def
+
+CPPFLAGS	= -I$(PDCURSES_HOME)
+
+CCFLAGS		= -c $(CFLAGS) $(CPPFLAGS)
+DLL_CCFLAGS	= -c $(CFLAGS) $(CPPFLAGS) -DPDC_DLL_BUILD #-MT -DPDC_THREAD_BUILD
+
+LINK		= link.exe -nologo
+
+CCLIBS		= user32.lib
+# may need to add msvcrt.lib for VC 2.x, VC 5.0 doesn't want it
+#CCLIBS		= msvcrt.lib user32.lib
+
+LIBEXE		= lib -nologo
+
+LIBCURSES	= pdcurses.lib
+DLLCURSES	= curses.lib
+CURSESDLL = curses.dll
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL) #$(CURSESDLL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+DLL_DEMOS	=testcurs_dll.exe newdemo_dll.exe xmas_dll.exe tuidemo_dll.exe firework_dll.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS) #$(DLL_DEMOS)
+
+clean:
+	-del *.obj
+	-del *.lib
+	-del *.dll
+	-del *.exp
+	-del *.res
+	-del *.exe
+
+demos:	$(DEMOS)
+#------------------------------------------------------------------------
+
+LIBOBJS =     \
+addch.obj     \
+addchstr.obj  \
+addstr.obj    \
+attr.obj      \
+beep.obj      \
+bkgd.obj      \
+border.obj    \
+clear.obj     \
+color.obj     \
+delch.obj     \
+deleteln.obj  \
+getch.obj     \
+getstr.obj    \
+getyx.obj     \
+inch.obj      \
+inchstr.obj   \
+initscr.obj   \
+inopts.obj    \
+insch.obj     \
+insstr.obj    \
+instr.obj     \
+kernel.obj    \
+mouse.obj     \
+move.obj      \
+outopts.obj   \
+overlay.obj   \
+pad.obj       \
+printw.obj    \
+refresh.obj   \
+scanw.obj     \
+scr_dump.obj  \
+scroll.obj    \
+slk.obj       \
+termattr.obj  \
+terminfo.obj  \
+touch.obj     \
+util.obj      \
+window.obj
+
+PDCOBJS =     \
+pdcclip.obj   \
+pdcdebug.obj  \
+pdcdisp.obj   \
+pdcgetsc.obj  \
+pdckbd.obj    \
+pdcprint.obj  \
+pdcscrn.obj   \
+pdcsetsc.obj  \
+pdcutil.obj   \
+pdcwin.obj
+
+PANOBJS =     \
+panel.obj
+
+LIBDLLS =     \
+addch.dll.obj     \
+addchstr.dll.obj  \
+addstr.dll.obj    \
+attr.dll.obj      \
+beep.dll.obj      \
+bkgd.dll.obj      \
+border.dll.obj    \
+clear.dll.obj     \
+color.dll.obj     \
+delch.dll.obj     \
+deleteln.dll.obj  \
+getch.dll.obj     \
+getstr.dll.obj    \
+getyx.dll.obj     \
+inch.dll.obj      \
+inchstr.dll.obj   \
+initscr.dll.obj   \
+inopts.dll.obj    \
+insch.dll.obj     \
+insstr.dll.obj    \
+instr.dll.obj     \
+kernel.dll.obj    \
+mouse.dll.obj     \
+move.dll.obj      \
+outopts.dll.obj   \
+overlay.dll.obj   \
+pad.dll.obj       \
+printw.dll.obj    \
+refresh.dll.obj   \
+scanw.dll.obj     \
+scr_dump.dll.obj  \
+scroll.dll.obj    \
+slk.dll.obj       \
+termattr.dll.obj  \
+terminfo.dll.obj  \
+touch.dll.obj     \
+util.dll.obj      \
+window.dll.obj
+
+PDCDLLS =     \
+pdcclip.dll.obj   \
+pdcdebug.dll.obj  \
+pdcdisp.dll.obj   \
+pdcgetsc.dll.obj  \
+pdckbd.dll.obj    \
+pdcprint.dll.obj  \
+pdcscrn.dll.obj   \
+pdcsetsc.dll.obj  \
+pdcutil.dll.obj   \
+pdcwin.dll.obj
+
+PANDLLS =     \
+panel.dll.obj
+
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) -out:$@ $(LIBOBJS) $(PDCOBJS)
+
+curses.dll : $(LIBDLLS) $(PDCDLLS) $(osdir)\curses.def pdcurses.obj
+	$(SHL_LD) $(LIBDLLS) $(PDCDLLS) pdcurses.obj $(CCLIBS)
+
+pdcurses.res pdcurses.obj: $(osdir)\pdcurses.rc $(osdir)\pdcurses.ico
+	rc /r /fopdcurses.res $(osdir)\pdcurses.rc
+	cvtres /MACHINE:IX86 /NOLOGO /OUT:pdcurses.obj pdcurses.res
+
+panel.lib : $(PANOBJS)
+	$(LIBEXE) -out:$@ $(PANOBJS)
+
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+
+
+addch.dll.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\addch.c
+
+addchstr.dll.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\addchstr.c
+
+addstr.dll.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\addstr.c
+
+attr.dll.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\attr.c
+
+beep.dll.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\beep.c
+
+bkgd.dll.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\bkgd.c
+
+border.dll.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\border.c
+
+clear.dll.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\clear.c
+
+color.dll.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\color.c
+
+delch.dll.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\delch.c
+
+deleteln.dll.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\deleteln.c
+
+getch.dll.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\getch.c
+
+getstr.dll.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\getstr.c
+
+getyx.dll.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\getyx.c
+
+inch.dll.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\inch.c
+
+inchstr.dll.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\inchstr.c
+
+initscr.dll.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\initscr.c
+
+inopts.dll.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\inopts.c
+
+insch.dll.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\insch.c
+
+insstr.dll.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\insstr.c
+
+instr.dll.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\instr.c
+
+kernel.dll.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\kernel.c
+
+mouse.dll.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\mouse.c
+
+move.dll.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\move.c
+
+outopts.dll.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\outopts.c
+
+overlay.dll.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\overlay.c
+
+pad.dll.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pad.c
+
+printw.dll.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\printw.c
+
+refresh.dll.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\refresh.c
+
+scanw.dll.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\scanw.c
+
+scr_dump.dll.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\scr_dump.c
+
+scroll.dll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\scroll.c
+
+slk.dll.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\slk.c
+
+termattr.dll.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\termattr.c
+
+terminfo.dll.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\terminfo.c
+
+touch.dll.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\touch.c
+
+util.dll.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\util.c
+
+window.dll.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\window.c
+
+
+pdcclip.dll.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcclip.c
+
+pdcdebug.dll.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.dll.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.dll.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcgetsc.c
+
+pdckbd.dll.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdckbd.c
+
+pdcprint.dll.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcprint.c
+
+pdcscrn.dll.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.dll.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(osdir)\pdcsetsc.c
+
+pdcutil.dll.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pdcutil.c
+
+pdcwin.dll.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) -LD $(DLL_CCFLAGS) -Fo$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+panel.dll.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(pandir)\panel.c
+
+#--- Targets for statically linked demo programs ------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -out:$@ $*.obj $(LIBCURSES) $(CCLIBS)
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -out:$@ $*.obj $(LIBCURSES) $(CCLIBS)
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -out:$@ $*.obj $(LIBPANEL) $(LIBCURSES) $(CCLIBS)
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -out:$@ $*.obj $(LIBCURSES) $(CCLIBS)
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -out:$@ tui.obj $*.obj $(LIBCURSES) $(CCLIBS)
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -out:$@ $*.obj $(LIBCURSES) $(CCLIBS)
+
+test.exe:	test.obj $(LIBCURSES)
+	$(LINK) $(LDFLAGS) -out:$@ $*.obj $(LIBCURSES) $(CCLIBS)
+
+#--- Targets for statically linked demo objects -------------------------
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -Fo$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) -Fo$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+test.obj: test.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -Fo$@ test.c
+
+#--- Targets for dynamically linked demo programs -----------------------
+
+firework_dll.exe:	firework.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ firework.dll.obj $(DLLCURSES) $(CCLIBS)
+
+newdemo_dll.exe:	newdemo.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ newdemo.dll.obj $(DLLCURSES) $(CCLIBS)
+
+ptest_dll.exe:	ptest.dll.obj $(CURSESDLL) $(LIBPANEL)
+	$(LINK) $(LDFLAGS) -out:$@ ptest.dll.obj $(LIBPANEL) $(DLLCURSES) $(CCLIBS)
+
+testcurs_dll.exe:	testcurs.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ testcurs.dll.obj $(DLLCURSES) $(CCLIBS)
+
+tuidemo_dll.exe:	tuidemo.dll.obj tui.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ tui.dll.obj tuidemo.dll.obj $(DLLCURSES) $(CCLIBS)
+
+xmas_dll.exe:	xmas.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ xmas.dll.obj $(DLLCURSES) $(CCLIBS)
+
+test_dll.exe:	test.dll.obj $(CURSESDLL)
+	$(LINK) $(LDFLAGS) -out:$@ test.dll.obj $(DLLCURSES) $(CCLIBS)
+
+#--- Targets for dynamically linked demo objects ------------------------
+
+firework.dll.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\firework.c
+
+newdemo.dll.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\newdemo.c
+
+ptest.dll.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\ptest.c
+
+testcurs.dll.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\testcurs.c
+
+tui.dll.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -I$(demodir) -Fo$@ $(demodir)\tui.c
+
+tuidemo.dll.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -I$(demodir) -Fo$@ $(demodir)\tuidemo.c
+
+xmas.dll.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ $(demodir)\xmas.c
+
+test.dll.obj: test.c $(PDCURSES_CURSES_H)
+	$(CC) $(DLL_CCFLAGS) -Fo$@ test.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Visual C++ > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Microsoft Visual C/C++ for Win32. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_vc_w32 \
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) \
+	$(PDCURSES_HOME)\maintain.er \
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h \
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h \
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/win32/wccwin32.lrf stsgdb-6.8/pdcurses/win32/wccwin32.lrf
--- gdb-6.8/pdcurses/win32/wccwin32.lrf	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/wccwin32.lrf	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,48 @@
++addch.obj
++addchstr.obj
++addstr.obj
++attr.obj
++beep.obj
++bkgd.obj
++border.obj
++clear.obj
++color.obj
++delch.obj
++deleteln.obj
++getch.obj
++getstr.obj
++getyx.obj
++inch.obj 
++inchstr.obj
++initscr.obj
++inopts.obj
++insch.obj
++insstr.obj
++instr.obj
++kernel.obj
++mouse.obj
++move.obj 
++outopts.obj
++overlay.obj
++pad.obj  
++printw.obj
++refresh.obj
++scanw.obj
++scr_dump.obj
++scroll.obj
++slk.obj  
++termattr.obj
++terminfo.obj
++touch.obj
++util.obj 
++window.obj
++pdcclip.obj
++pdcdebug.obj
++pdcdisp.obj
++pdcgetsc.obj
++pdckbd.obj
++pdcprint.obj
++pdcscrn.obj
++pdcsetsc.obj
++pdcutil.obj
++pdcwin.obj
diff -Naur gdb-6.8/pdcurses/win32/wccwin32.mak stsgdb-6.8/pdcurses/win32/wccwin32.mak
--- gdb-6.8/pdcurses/win32/wccwin32.mak	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/win32/wccwin32.mak	2008-09-11 10:32:59.000000000 +0100
@@ -0,0 +1,378 @@
+################################################################################
+#
+# Watcom WMAKE Makefile for PDCurses library - Win32 Watcom C/C++ 10.6+
+#
+# Usage: wmake -f [win32\]wccwin32.mak [DEBUG=Y] [target]
+#
+# where target can be any of:
+# [all|demos|pdcurses.lib|panel.lib|testcurs.exe...]
+#
+################################################################################
+#
+# First, set the environment variable PDCURSES_SRCDIR, or edit the line
+# below; for example, "set PDCURSES_SRCDIR=c:\pdcurses".
+#
+################################################################################
+PDCURSES_HOME		=$(%PDCURSES_SRCDIR)
+################################################################################
+# Nothing below here should require changing.
+################################################################################
+VER=27
+VERDOT=2.7
+
+PDCURSES_CURSES_H	=$(PDCURSES_HOME)\curses.h
+PDCURSES_CURSPRIV_H	=$(PDCURSES_HOME)\curspriv.h
+PDCURSES_HEADERS	=$(PDCURSES_CURSES_H) $(PDCURSES_CURSPRIV_H)
+PANEL_HEADER		=$(PDCURSES_HOME)\panel.h
+TERM_HEADER		=$(PDCURSES_HOME)\term.h
+
+srcdir		= $(PDCURSES_HOME)\pdcurses
+osdir		= $(PDCURSES_HOME)\win32
+pandir		= $(PDCURSES_HOME)\panel
+demodir		= $(PDCURSES_HOME)\demos
+
+CC		= wcc386
+TARGET=nt
+
+!ifeq DEBUG Y
+CFLAGS  = /d2 /DPDCDEBUG
+LDFLAGS = DEBUG WATCOM ALL
+!else
+CFLAGS  = /oneatx /wcd=302
+LDFLAGS =
+!endif
+
+CPPFLAGS	= /i=$(PDCURSES_HOME)
+
+CCFLAGS		= /ei /zq /mf /wx $(CFLAGS) $(CPPFLAGS)
+
+LINK		= wlink
+
+LIBEXE		= wlib /q /n
+
+LIBCURSES	= pdcurses.lib
+LIBPANEL	= panel.lib
+
+PDCLIBS	= $(LIBCURSES) $(LIBPANEL)
+DEMOS	=testcurs.exe newdemo.exe xmas.exe tuidemo.exe firework.exe ptest.exe
+
+################################################################################
+all:	$(PDCLIBS) $(DEMOS)
+
+clean
+	-del *.obj
+	-del *.lib
+	-del *.exe
+	-del *.err
+
+demos:	$(DEMOS)
+
+#------------------------------------------------------------------------
+
+LIBOBJS =    &
+addch.obj    &
+addchstr.obj &
+addstr.obj   &
+attr.obj     &
+beep.obj     &
+bkgd.obj     &
+border.obj   &
+clear.obj    &
+color.obj    &
+delch.obj    &
+deleteln.obj &
+getch.obj    &
+getstr.obj   &
+getyx.obj    &
+inch.obj     &
+inchstr.obj  &
+initscr.obj  &
+inopts.obj   &
+insch.obj    &
+insstr.obj   &
+instr.obj    &
+kernel.obj   &
+mouse.obj    &
+move.obj     &
+outopts.obj  &
+overlay.obj  &
+pad.obj      &
+printw.obj   &
+refresh.obj  &
+scanw.obj    &
+scr_dump.obj &
+scroll.obj   &
+slk.obj      &
+termattr.obj &
+terminfo.obj &
+touch.obj    &
+util.obj     &
+window.obj
+
+PDCOBJS =      &
+pdcclip.obj    &
+pdcdebug.obj   &
+pdcdisp.obj    &
+pdcgetsc.obj   &
+pdckbd.obj     &
+pdcprint.obj   &
+pdcscrn.obj    &
+pdcsetsc.obj   &
+pdcutil.obj    &
+pdcwin.obj
+
+PANOBJS =     &
+panel.obj
+
+pdcurses.lib : $(LIBOBJS) $(PDCOBJS)
+	$(LIBEXE) $@ @$(osdir)\wccwin32.lrf
+
+panel.lib : $(PANOBJS)
+	echo +$(PANOBJS)   >  lib.rsp
+	$(LIBEXE) $@ @lib.rsp
+	del lib.rsp
+
+addch.obj: $(srcdir)\addch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addch.c
+
+addchstr.obj: $(srcdir)\addchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addchstr.c
+
+addstr.obj: $(srcdir)\addstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\addstr.c
+
+attr.obj: $(srcdir)\attr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\attr.c
+
+beep.obj: $(srcdir)\beep.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\beep.c
+
+bkgd.obj: $(srcdir)\bkgd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\bkgd.c
+
+border.obj: $(srcdir)\border.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\border.c
+
+clear.obj: $(srcdir)\clear.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\clear.c
+
+color.obj: $(srcdir)\color.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\color.c
+
+delch.obj: $(srcdir)\delch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\delch.c
+
+deleteln.obj: $(srcdir)\deleteln.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\deleteln.c
+
+getch.obj: $(srcdir)\getch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getch.c
+
+getstr.obj: $(srcdir)\getstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getstr.c
+
+getyx.obj: $(srcdir)\getyx.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\getyx.c
+
+inch.obj: $(srcdir)\inch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inch.c
+
+inchstr.obj: $(srcdir)\inchstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inchstr.c
+
+initscr.obj: $(srcdir)\initscr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\initscr.c
+
+inopts.obj: $(srcdir)\inopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\inopts.c
+
+insch.obj: $(srcdir)\insch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insch.c
+
+insstr.obj: $(srcdir)\insstr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\insstr.c
+
+instr.obj: $(srcdir)\instr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\instr.c
+
+kernel.obj: $(srcdir)\kernel.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\kernel.c
+
+mouse.obj: $(srcdir)\mouse.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\mouse.c
+
+move.obj: $(srcdir)\move.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\move.c
+
+outopts.obj: $(srcdir)\outopts.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\outopts.c
+
+overlay.obj: $(srcdir)\overlay.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\overlay.c
+
+pad.obj: $(srcdir)\pad.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pad.c
+
+printw.obj: $(srcdir)\printw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\printw.c
+
+refresh.obj: $(srcdir)\refresh.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\refresh.c
+
+scanw.obj: $(srcdir)\scanw.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scanw.c
+
+scr_dump.obj: $(srcdir)\scr_dump.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scr_dump.c
+
+scroll.obj: $(srcdir)\scroll.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\scroll.c
+
+slk.obj: $(srcdir)\slk.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\slk.c
+
+termattr.obj: $(srcdir)\termattr.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\termattr.c
+
+terminfo.obj: $(srcdir)\terminfo.c $(PDCURSES_HEADERS) $(TERM_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\terminfo.c
+
+touch.obj: $(srcdir)\touch.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\touch.c
+
+util.obj: $(srcdir)\util.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\util.c
+
+window.obj: $(srcdir)\window.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\window.c
+
+
+pdcclip.obj: $(osdir)\pdcclip.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcclip.c
+
+pdcdebug.obj: $(srcdir)\pdcdebug.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcdebug.c
+
+pdcdisp.obj: $(osdir)\pdcdisp.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcdisp.c
+
+pdcgetsc.obj: $(osdir)\pdcgetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcgetsc.c
+
+pdckbd.obj: $(osdir)\pdckbd.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdckbd.c
+
+pdcprint.obj: $(osdir)\pdcprint.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcprint.c
+
+pdcscrn.obj: $(osdir)\pdcscrn.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcscrn.c
+
+pdcsetsc.obj: $(osdir)\pdcsetsc.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(osdir)\pdcsetsc.c
+
+pdcutil.obj: $(srcdir)\pdcutil.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcutil.c
+
+pdcwin.obj: $(srcdir)\pdcwin.c $(PDCURSES_HEADERS)
+	$(CC) $(CCFLAGS) /fo=$@ $(srcdir)\pdcwin.c
+
+#------------------------------------------------------------------------
+
+panel.obj: $(pandir)\panel.c $(PDCURSES_HEADERS) $(PANEL_HEADER)
+	$(CC) $(CCFLAGS) /fo=$@ $(pandir)\panel.c
+
+#------------------------------------------------------------------------
+
+firework.exe:	firework.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name firework.exe    >> demos.lnk
+	echo file firework.obj    >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+newdemo.exe:	newdemo.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name newdemo.exe     >> demos.lnk
+	echo file newdemo.obj     >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+ptest.exe:	ptest.obj $(LIBCURSES) $(LIBPANEL)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name ptest.exe       >> demos.lnk
+	echo file ptest.obj       >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	echo library $(LIBPANEL)  >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+testcurs.exe:	testcurs.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name testcurs.exe    >> demos.lnk
+	echo file testcurs.obj    >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+tuidemo.exe:	tuidemo.obj tui.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name tuidemo.exe     >> demos.lnk
+	echo file tuidemo.obj     >> demos.lnk
+	echo file tui.obj         >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+xmas.exe:	xmas.obj $(LIBCURSES)
+	echo option quiet         >  demos.lnk
+	echo system $(TARGET)     >> demos.lnk
+	echo name xmas.exe        >> demos.lnk
+	echo file xmas.obj        >> demos.lnk
+	echo library $(LIBCURSES) >> demos.lnk
+	$(LINK) $(LDFLAGS) @demos.lnk
+	del demos.lnk
+
+
+firework.obj: $(demodir)\firework.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\firework.c
+
+newdemo.obj: $(demodir)\newdemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\newdemo.c
+
+ptest.obj: $(demodir)\ptest.c $(PANEL_HEADER) $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\ptest.c
+
+testcurs.obj: $(demodir)\testcurs.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\testcurs.c
+
+tui.obj: $(demodir)\tui.c $(demodir)\tui.h $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tui.c
+
+tuidemo.obj: $(demodir)\tuidemo.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) -I$(demodir) /fo=$@ $(demodir)\tuidemo.c
+
+xmas.obj: $(demodir)\xmas.c $(PDCURSES_CURSES_H)
+	$(CC) $(CCFLAGS) /fo=$@ $(demodir)\xmas.c
+
+dist: $(PDCLIBS)
+	echo PDCurses $(VERDOT) for Watcom C++ Win32 > file_id.diz
+	echo ------------------------------------------ >> file_id.diz
+	echo Public Domain Curses library for >> file_id.diz
+	echo Open Watcom 1.3 for Win32. >> file_id.diz
+	echo Source available in PDCURS$(VER).ZIP >> file_id.diz
+	echo Public Domain. >> file_id.diz
+	zip -jX pdc$(VER)_wcc_w32 &
+	$(PDCURSES_HOME)\README $(PDCURSES_HOME)\readme.$(VER) &
+	$(PDCURSES_HOME)\maintain.er &
+	$(PDCURSES_HOME)\curses.h $(PDCURSES_HOME)\curspriv.h &
+	$(PDCURSES_HOME)\panel.h $(PDCURSES_HOME)\term.h &
+	$(LIBCURSES) $(LIBPANEL) file_id.diz
+	del file_id.diz
diff -Naur gdb-6.8/pdcurses/x11/latin1kbd.h stsgdb-6.8/pdcurses/x11/latin1kbd.h
--- gdb-6.8/pdcurses/x11/latin1kbd.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/latin1kbd.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,127 @@
+
+/* Definitions of latin1 character set for XCurses */
+
+/*
+ *  Latin 1
+ *  Byte 3 = 0
+*/
+#ifdef XK_LATIN1       
+
+/* keycode              keypad ?        normal         shifted  control alt */
+/* ------------------------------------------------------------------------ */
+ {XK_nobreakspace,      FALSE,          0x0A0,          0x0A0,  0,      0},
+ {XK_exclamdown,        FALSE,          0x0A1,          0x0A1,  0,      0},
+ {XK_cent,              FALSE,          0x0A2,          0x0A2,  0,      0},
+ {XK_sterling,          FALSE,          0x0A3,          0x0A3,  0,      0},
+ {XK_currency,          FALSE,          0x0A4,          0x0A4,  0,      0},
+ {XK_yen,               FALSE,          0x0A5,          0x0A5,  0,      0},
+ {XK_brokenbar,         FALSE,          0x0A6,          0x0A6,  0,      0},
+ {XK_section,           FALSE,          0x0A7,          0x0A7,  0,      0},
+ {XK_diaeresis,         FALSE,          0x0A8,          0x0A8,  0,      0},
+ {XK_copyright,         FALSE,          0x0A9,          0x0A9,  0,      0},
+ {XK_ordfeminine,       FALSE,          0x0AA,          0x0AA,  0,      0},
+ {XK_guillemotleft,     FALSE,          0x0AB,          0x0AB,  0,      0},
+ {XK_notsign,           FALSE,          0x0AC,          0x0AC,  0,      0},
+ {XK_hyphen,            FALSE,          0x0AD,          0x0AD,  0,      0},
+ {XK_registered,        FALSE,          0x0AE,          0x0AE,  0,      0},
+ {XK_macron,            FALSE,          0x0AF,          0x0AF,  0,      0},
+ {XK_degree,            FALSE,          0x0B0,          0x0B0,  0,      0},
+ {XK_plusminus,         FALSE,          0x0B1,          0x0B1,  0,      0},
+ {XK_twosuperior,       FALSE,          0x0B2,          0x0B2,  0,      0},
+ {XK_threesuperior,     FALSE,          0x0B3,          0x0B3,  0,      0},
+ {XK_acute,             FALSE,          0x0B4,          0x0B4,  0,      0},
+ {XK_mu,                FALSE,          0x0B5,          0x0B5,  0,      0},
+ {XK_paragraph,         FALSE,          0x0B6,          0x0B6,  0,      0},
+ {XK_periodcentered,    FALSE,          0x0B7,          0x0B7,  0,      0},
+ {XK_cedilla,           FALSE,          0x0B8,          0x0B8,  0,      0},
+ {XK_onesuperior,       FALSE,          0x0B9,          0x0B9,  0,      0},
+ {XK_masculine,         FALSE,          0x0BA,          0x0BA,  0,      0},
+ {XK_guillemotright,    FALSE,          0x0BB,          0x0BB,  0,      0},
+ {XK_onequarter,        FALSE,          0x0BC,          0x0BC,  0,      0},
+ {XK_onehalf,           FALSE,          0x0BD,          0x0BD,  0,      0},
+ {XK_threequarters,     FALSE,          0x0BE,          0x0BE,  0,      0},
+ {XK_questiondown,      FALSE,          0x0BF,          0x0BF,  0,      0},
+/*  -- Uppercases -- */
+ {XK_Agrave,            FALSE,          0x0C0,          0x0C0,  0,      0},
+ {XK_Aacute,            FALSE,          0x0C1,          0x0C1,  0,      0},
+ {XK_Acircumflex,       FALSE,          0x0C2,          0x0C2,  0,      0},
+ {XK_Atilde,            FALSE,          0x0C3,          0x0C3,  0,      0},
+ {XK_Adiaeresis,        FALSE,          0x0C4,          0x0C4,  0,      0},
+ {XK_Aring,             FALSE,          0x0C5,          0x0C5,  0,      0},
+ {XK_AE,                FALSE,          0x0C6,          0x0C6,  0,      0},
+ /* */
+ {XK_Ccedilla,          FALSE,          0x0C7,          0x0C7,  0,      0},
+ /* */
+ {XK_Egrave,            FALSE,          0x0C8,          0x0C8,  0,      0},
+ {XK_Eacute,            FALSE,          0x0C9,          0x0C9,  0,      0},
+ {XK_Ecircumflex,       FALSE,          0x0CA,          0x0CA,  0,      0},
+ {XK_Ediaeresis,        FALSE,          0x0CB,          0x0CB,  0,      0},
+ /* */
+ {XK_Igrave,            FALSE,          0x0CC,          0x0CC,  0,      0},
+ {XK_Iacute,            FALSE,          0x0CD,          0x0CD,  0,      0},
+ {XK_Icircumflex,       FALSE,          0x0CE,          0x0CE,  0,      0},
+ {XK_Idiaeresis,        FALSE,          0x0CF,          0x0CF,  0,      0},
+ /* */
+ {XK_ETH,               FALSE,          0x0D0,          0x0D0,  0,      0},
+ {XK_Eth,               FALSE,          0x0D0,          0x0D0,  0,      0},
+ {XK_Ntilde,            FALSE,          0x0D1,          0x0D1,  0,      0},
+ /* */
+ {XK_Ograve,            FALSE,          0x0D2,          0x0D2,  0,      0},
+ {XK_Oacute,            FALSE,          0x0D3,          0x0D3,  0,      0},
+ {XK_Ocircumflex,       FALSE,          0x0D4,          0x0D4,  0,      0},
+ {XK_Otilde,            FALSE,          0x0D5,          0x0D5,  0,      0},
+ {XK_Odiaeresis,        FALSE,          0x0D6,          0x0D6,  0,      0},
+ {XK_multiply,          FALSE,          0x0D7,          0x0D7,  0,      0},
+ {XK_Ooblique,          FALSE,          0x0D8,          0x0D8,  0,      0},
+ /* */
+ {XK_Ugrave,            FALSE,          0x0D9,          0x0D9,  0,      0},
+ {XK_Uacute,            FALSE,          0x0DA,          0x0DA,  0,      0},
+ {XK_Ucircumflex,       FALSE,          0x0DB,          0x0DB,  0,      0},
+ {XK_Udiaeresis,        FALSE,          0x0DC,          0x0DC,  0,      0},
+ /* */
+ {XK_Yacute,            FALSE,          0x0DD,          0x0DD,  0,      0},
+ {XK_THORN,             FALSE,          0x0DE,          0x0DE,  0,      0},
+ {XK_Thorn,             FALSE,          0x0DE,          0x0DE,  0,      0},
+ {XK_ssharp,            FALSE,          0x0DF,          0x0DF,  0,      0},
+/*  -- Lowercases -- */
+ {XK_agrave,            FALSE,          0x0E0,          0x0E0,  0,      0},
+ {XK_aacute,            FALSE,          0x0E1,          0x0E1,  0,      0},
+ {XK_acircumflex,       FALSE,          0x0E2,          0x0E2,  0,      0},
+ {XK_atilde,            FALSE,          0x0E3,          0x0E3,  0,      0},
+ {XK_adiaeresis,        FALSE,          0x0E4,          0x0E4,  0,      0},
+ {XK_aring,             FALSE,          0x0E5,          0x0E5,  0,      0},
+ {XK_ae,                FALSE,          0x0E6,          0x0E6,  0,      0},
+ /* */
+ {XK_ccedilla,          FALSE,          0x0E7,          0x0E7,  0,      0},
+ /* */
+ {XK_egrave,            FALSE,          0x0E8,          0x0E8,  0,      0},
+ {XK_eacute,            FALSE,          0x0E9,          0x0E9,  0,      0},
+ {XK_ecircumflex,       FALSE,          0x0EA,          0x0EA,  0,      0},
+ {XK_ediaeresis,        FALSE,          0x0EB,          0x0EB,  0,      0},
+ /* */
+ {XK_igrave,            FALSE,          0x0EC,          0x0EC,  0,      0},
+ {XK_iacute,            FALSE,          0x0ED,          0x0ED,  0,      0},
+ {XK_icircumflex,       FALSE,          0x0EE,          0x0EE,  0,      0},
+ {XK_idiaeresis,        FALSE,          0x0EF,          0x0EF,  0,      0},
+ /* */
+ {XK_eth,               FALSE,          0x0F0,          0x0F0,  0,      0},
+ {XK_ntilde,            FALSE,          0x0F1,          0x0F1,  0,      0},
+ /* */
+ {XK_ograve,            FALSE,          0x0F2,          0x0F2,  0,      0},
+ {XK_oacute,            FALSE,          0x0F3,          0x0F3,  0,      0},
+ {XK_ocircumflex,       FALSE,          0x0F4,          0x0F4,  0,      0},
+ {XK_otilde,            FALSE,          0x0F5,          0x0F5,  0,      0},
+ {XK_odiaeresis,        FALSE,          0x0F6,          0x0F6,  0,      0},
+ {XK_division,          FALSE,          0x0F7,          0x0F7,  0,      0},
+ {XK_oslash,            FALSE,          0x0F8,          0x0F8,  0,      0},
+ /* */
+ {XK_ugrave,            FALSE,          0x0F9,          0x0F9,  0,      0},
+ {XK_uacute,            FALSE,          0x0FA,          0x0FA,  0,      0},
+ {XK_ucircumflex,       FALSE,          0x0FB,          0x0FB,  0,      0},
+ {XK_udiaeresis,        FALSE,          0x0FC,          0x0FC,  0,      0},
+ /* */
+ {XK_yacute,            FALSE,          0x0FD,          0x0FD,  0,      0},
+ {XK_thorn,             FALSE,          0x0FE,          0x0FE,  0,      0},
+ {XK_ydiaeresis,        FALSE,          0x0FF,          0x0FF,  0,      0},
+
+#endif /* XK_LATIN1 */                    
diff -Naur gdb-6.8/pdcurses/x11/pdcclip.c stsgdb-6.8/pdcurses/x11/pdcclip.c
--- gdb-6.8/pdcurses/x11/pdcclip.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcclip.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,145 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCclip  = "$Id: pdcclip.c,v 1.3 2002/11/27 11:16:48 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_getclipboard()	- Gets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Gets the textual contents of the system's clipboard. This
+ 	function returns the contents of the clipboard in the contents
+ 	argument. It is the responsibilitiy of the caller to free the
+ 	memory returned with the PDC_freeclipboard() call.  The length of the
+ 	clipboard contents is returned in the length argument.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
+ 		clipboard
+ 	PDC_CLIP_MEMORY_ERROR	unable to allocate sufficient memory for 
+ 		the clipboard contents
+ 	PDC_CLIP_EMPTY	the clipboard contains no text
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char **contents, long *length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_getclipboard(char **contents, long *length)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_getclipboard() - called\n");
+#endif
+
+ return XCurses_getclipboard( contents, length );
+}
+
+
+/*man-start*********************************************************************
+
+  PDC_setclipboard()	- Sets the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Copies the supplied text into the system's clipboard, emptying
+ 	the clipboard prior to the copy.
+
+  PDCurses Return Value:
+ 	indicator of success/failure of call.
+ 	PDC_CLIP_SUCCESS	the call was successful
+ 	PDC_CLIP_ACCESS_ERROR	an error occured while accessing the
+ 		clipboard
+
+  Portability:
+ 	PDCurses	int PDC_getclipboard( char *contents, long length );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_setclipboard(char *contents, long length)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_setclipboard() - called\n");
+#endif
+
+ return XCurses_setclipboard( contents, length );
+}
+
+/*man-start*********************************************************************
+
+  PDC_freeclipboard()	- Frees the memory associated with the contents of the clipboard
+
+  PDCurses Description:
+ 	This is a PDCurses only routine.
+
+ 	Frees the memory allocated by PDC_getclipboard().
+
+  PDCurses Return Value:
+ 	Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+ 	PDCurses	int PDC_freeclipboard( char *contents );
+
+**man-end**********************************************************************/
+
+int	PDC_CDECL	PDC_freeclipboard(char *contents)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_freeclipboard() - called\n");
+#endif
+
+ free(contents);
+ return PDC_CLIP_SUCCESS;
+}
+
+/*man-start*********************************************************************
+
+  PDC_clearclipboard()  - Clears the contents of the clipboard
+
+  PDCurses Description:
+   This is a PDCurses only routine.
+
+   Clears the internal clipboard.
+
+  PDCurses Return Value:
+   Always returns PDC_CLIP_SUCCESS
+
+  Portability:
+   PDCurses int PDC_clearclipboard( void );
+
+**man-end**********************************************************************/
+
+int PDC_CDECL PDC_clearclipboard( void )
+{
+ return XCurses_clearclipboard( );
+}
diff -Naur gdb-6.8/pdcurses/x11/pdcdisp.c stsgdb-6.8/pdcurses/x11/pdcdisp.c
--- gdb-6.8/pdcurses/x11/pdcdisp.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcdisp.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,263 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#include <string.h>
+
+#ifdef HAVE_MEMORY_H
+#  include <memory.h>
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_PDCdisp  = "$Id: pdcdisp.c,v 1.3 2005/12/14 21:06:15 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_clr_update()	- Updates the screen with a full redraw.
+
+  PDCurses Description:
+ 	Updates the screen by clearing it and then redraw it in its
+ 	entirety. If SP->refrbrk is TRUE, and there is pending
+ 	input characters, the update will be prematurely terminated.
+
+  PDCurses Return Value:
+ 	This routine returns ERR if it is unable to accomplish it's task.
+ 	This return value is ONLY under FLEXOS.
+
+ 	The return value OK is returned if there were no errors.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_clr_update( WINDOW* s );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_clr_update(WINDOW *s)
+#else
+int	PDC_clr_update(s)
+WINDOW *s;
+#endif
+/***********************************************************************/
+{
+register int	i=0;
+	WINDOW*	w=NULL;
+	bool rc=FALSE;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_clr_update() - called\n");
+#endif
+
+	w = curscr;
+	if (w == (WINDOW *)NULL)
+		return( ERR );
+
+	s->_clear = FALSE;
+	for (i = 0; i < LINES; i++)	/* update physical screen */
+	{
+		if (s != w)	/* copy s to curscr */
+			memcpy(w->_y[i], s->_y[i], COLS * sizeof(chtype));
+		XCurses_transform_line(w->_y[i],i,0,COLS);
+
+		if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+		{
+			rc = PDC_breakout();
+			if(rc) 
+				break;
+		}
+		w->_firstch[i] = _NO_CHANGE;
+		w->_lastch[i] = _NO_CHANGE;
+	}
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_on()	- Turns on the hardware cursor.
+
+  PDCurses Description:
+ 	Turns on the hardware curses, it does nothing if it is already on.
+
+  PDCurses Return Value:
+ 	Returns OK upon success, ERR upon failure.
+
+  Portability:
+ 	PDCurses	int PDC_cursor_on( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_cursor_on(void)
+#else
+int	PDC_cursor_on()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_cursor_on() - called\n");
+#endif
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_cursor_off()	- Turns off the hardware cursor.
+
+  PDCurses Description:
+ 	Turns off the hardware curses, it does nothing if it is already off.
+
+  PDCurses Return Value:
+ 	Returns OK upon success, ERR upon failure.
+
+  PDCurses Errors:
+ 	ERR will be returned (in the case of FLEXOS) if the hardware cursor
+ 	can not be disabled.
+
+  Portability:
+ 	PDCurses	int PDC_cursor_off( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_cursor_off(void)
+#else
+int	PDC_cursor_off()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_cursor_off() - called\n");
+#endif
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_gotoxy()	- position hardware cursor at (x, y)
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Moves the physical cursor to the desired address on the
+ 	screen. We don't optimize here -- on a PC, it takes more time
+ 	to optimize than to do things directly.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_gotoxy( int row, int col );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_gotoxy(int row, int col)
+#else
+int	PDC_gotoxy(row,col)
+int row;
+int col;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_gotoxy() - called: row %d col %d\n",row,col);
+#endif
+
+	XCurses_display_cursor(SP->cursrow,SP->curscol,row,col,SP->visibility);
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_transform_line()	- display a physical line of the screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	Updates the given physical line to look like the corresponding
+ 	line in _curscr.
+
+  PDCurses Return Value:
+ 	This routine returns TRUE if a premature refresh end
+ 	is allowed, and there is an input character pending.  Otherwise,
+ 	FALSE is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this routine.
+
+  Portability:
+ 	PDCurses	bool	PDC_transform_line( int lineno );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_transform_line(register int lineno)
+#else
+bool	PDC_transform_line(lineno)
+register int lineno;
+#endif
+/***********************************************************************/
+{
+	register chtype*	dstp=NULL;
+	int	x=0;
+	int	endx=0;
+	int	len=0;
+	bool rc=FALSE;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_transform_line() - called: line %d\n",lineno);
+#endif
+
+	if (curscr == (WINDOW *)NULL)
+		return( FALSE );
+
+	x = curscr->_firstch[lineno];
+	endx = curscr->_lastch[lineno];
+	dstp = curscr->_y[lineno] + x;
+	len = endx-x+1;
+
+		XCurses_transform_line(dstp,lineno,x,len);
+
+	curscr->_firstch[lineno] = _NO_CHANGE;
+	curscr->_lastch[lineno] = _NO_CHANGE;
+
+	if (SP->refrbrk && (SP->cbreak || SP->raw_inp)) 
+	{
+		rc = PDC_breakout();
+		if(rc) 
+			return(TRUE);
+	}
+	return(FALSE);
+}
diff -Naur gdb-6.8/pdcurses/x11/pdcgetsc.c stsgdb-6.8/pdcurses/x11/pdcgetsc.c
--- gdb-6.8/pdcurses/x11/pdcgetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcgetsc.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCgetsc  = "$Id: pdcgetsc.c,v 1.1 2001/01/10 08:30:08 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_get_columns()	- return width of screen/viewport.
+
+  PDCurses Description:
+ 	This is a private PDCurses function
+
+ 	This function will return the width of the current screen.
+
+  PDCurses Return Value:
+ 	This routine will return OK upon success and otherwise ERR will be
+ 	returned.
+
+  PDCurses Errors:
+ 	There are no defined errors for this routine.
+
+  Portability:
+ 	PDCurses	int	PDC_get_columns( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_columns(void)
+#else
+int	PDC_get_columns()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_columns() - called\n");
+#endif
+	return(XCurses_get_cols());
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_rows()	- Return number of screen rows.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the maximum number of rows supported by the display.
+ 	e.g.  25, 28, 43, 50, 60, 66...
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_rows( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_rows(void)
+#else
+int	PDC_get_rows()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_rows() - called\n");
+#endif
+	return(XCurses_get_rows());
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_font()	- Get the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This function returns the current font size.  This function only
+ 	works if the #define FAST_VIDEO is true.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	An ERR will be returned if FAST_VIDEO is not true.
+
+  Portability:
+ 	PDCurses	int PDC_get_font( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_get_font(void)
+#else
+int	PDC_get_font()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_font() - called\n");
+#endif
+	return(OK);
+}
diff -Naur gdb-6.8/pdcurses/x11/pdckbd.c stsgdb-6.8/pdcurses/x11/pdckbd.c
--- gdb-6.8/pdcurses/x11/pdckbd.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdckbd.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,274 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCkbd  = "$Id: pdckbd.c,v 1.7 2005/12/11 01:07:19 wmcbrine Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  PDC_get_input_fd()	- Get file descriptor used for PDCurses input
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will return the file descriptor that PDCurses reads
+ 	its input from. It can be used for select().
+
+  PDCurses Return Value:
+ 	Returns a file descriptor.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int	PDC_get_input_fd( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long PDC_get_input_fd(void)
+#else
+unsigned long PDC_get_input_fd()
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_input_fd() - called\n");
+#endif
+
+	return XCurses_get_input_fd();
+}
+
+/*man-start*********************************************************************
+
+  PDC_check_bios_key()	- Check BIOS key data area for input
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	This routine will check the BIOS for any indication that
+ 	keystrokes are pending.
+
+  PDCurses Return Value:
+ 	Returns 1 if a keyboard character is available, 0 otherwise.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	bool	PDC_check_bios_key( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool PDC_check_bios_key(void)
+#else
+bool PDC_check_bios_key()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_check_bios_key() - called\n");
+#endif
+	return(XCurses_kbhit());
+}         
+
+/*man-start*********************************************************************
+
+  PDC_get_ctrl_break()	- return OS control break state
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the current OS Control Break Check state.
+
+  PDCurses Return Value:
+ 	DOS:
+ 		This function returns TRUE if the Control Break
+ 		Check is enabled otherwise FALSE is returned.
+
+ 	FLEXOS:
+ 		This function returns TRUE on if the Keyboard Mode
+ 		allows a break to bre reported otherwise FALSE is returned.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	bool	PDC_get_ctrl_break( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_get_ctrl_break(void)
+#else
+bool	PDC_get_ctrl_break()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_ctrl_break() - called\n");
+#endif
+	return(FALSE);
+}
+
+/*man-start*********************************************************************
+
+  PDC_rawgetch()	- Returns the next uninterpreted character (if available).
+
+  PDCurses Description:
+ 	Gets a character without any interpretation at all and returns
+ 	it. If keypad mode is active for the designated window,
+ 	function key translation will be performed.  Otherwise,
+ 	function keys are ignored.  If nodelay mode is active in the
+ 	window, then PDC_rawgetch() returns -1 if no character is
+ 	available.
+
+ 	WARNING:  It is unknown whether the FUNCTION key translation
+ 		  is performed at this level. --Frotz 911130 BUG
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int	PDC_rawgetch( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_rawgetch(void)
+#else
+int	PDC_rawgetch()
+#endif
+/***********************************************************************/
+{
+   extern WINDOW* _getch_win_;
+
+   int c;
+   bool return_immediately;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_rawgetch() - called\n");
+#endif
+
+   if (_getch_win_ == (WINDOW *)NULL)   /* @@ */
+      return( -1 );
+
+   if (SP->delaytenths || _getch_win_->_delayms || _getch_win_->_nodelay)
+      return_immediately = TRUE;
+   else
+      return_immediately = FALSE;
+
+   if (return_immediately && !PDC_breakout())
+      return( -1 );
+
+   c = XCurses_rawgetch( 0 );
+   return(c);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_ctrl_break()	- Enables/Disables the host OS BREAK key check.
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Enables/Disables the host OS BREAK key check. If the supplied setting
+ 	is TRUE, this enables CTRL/C and CTRL/BREAK to abort the process.
+ 	If FALSE, CTRL/C and CTRL/BREAK are ignored.
+
+  PDCurses Return Value:
+ 	This function returns OK on success and ERR on error.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_set_ctrl_break( bool setting );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_ctrl_break(bool setting)
+#else
+int	PDC_set_ctrl_break(setting)
+bool setting;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_ctrl_break() - called\n");
+#endif
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_get_key_modifiers()	- Returns the keyboard modifier(s) at time of last getch()
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Returns the keyboard modifiers effective at the time of the last getch()
+ 	call only if PDC_save_key_modifiers(TRUE) has been called before the
+ 	getch();
+ 	Use the macros; PDC_KEY_MODIFIER_* to determine which modifier(s)
+ 	were set.
+
+  PDCurses Return Value:
+ 	This function returns the modifiers.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_get_key_modifiers( void );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long	PDC_get_key_modifiers(void)
+#else
+unsigned long	PDC_get_key_modifiers()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_get_key_modifiers() - called\n");
+#endif
+	return(XCurses_get_key_modifiers());
+}
diff -Naur gdb-6.8/pdcurses/x11/pdcprint.c stsgdb-6.8/pdcurses/x11/pdcprint.c
--- gdb-6.8/pdcurses/x11/pdcprint.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcprint.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,73 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCprint  = "$Id: pdcprint.c,v 1.1 2001/01/10 08:30:11 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_print()	- Provides primitive access to the BIOS printer functions
+
+  PDCurses Description:
+ 	This is a private PDCurses routine.
+
+ 	Implements write/init/read printer services at the BIOS level.
+
+ 	This provides the basic support that PDCurses needs to dump the
+ 	contents of windows or pads to the printer attached to the BIOS
+ 	printer port.
+
+  PDCurses Return Value:
+ 	See the BIOS INT 0x17 specifications.
+
+  PDCurses Errors:
+ 	See the BIOS INT 0x17 specifications.
+
+  Portability:
+ 	PDCurses	int PDC_print( int cmd, int byte, int port );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_print(int cmd, int byte, int port)
+#else
+int	PDC_print(cmd,byte,port)
+int cmd;
+int byte;
+int port;
+#endif
+/***********************************************************************/
+{
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_print() - called\n");
+#endif
+
+/* to be done */
+return(OK);
+}
diff -Naur gdb-6.8/pdcurses/x11/pdcscrn.c stsgdb-6.8/pdcurses/x11/pdcscrn.c
--- gdb-6.8/pdcurses/x11/pdcscrn.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcscrn.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,223 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCscrn  = "$Id: pdcscrn.c,v 1.4 2005/12/11 05:51:24 wmcbrine Exp $";
+#endif
+
+bool GLOBAL_sb_on=FALSE;
+bool GLOBAL_slk_on=FALSE;
+
+/*man-start*********************************************************************
+
+  PDC_scr_close()	- Internal low-level binding to close the physical screen
+
+  PDCurses Description:
+ 	This function provides a low-level binding for the Flexos
+ 	platform which must close the screen before writing to it.
+ 	This is a nop for the DOS platform.
+
+ 	This function is provided in order to reset the FlexOS 16 bit
+ 	character set for input rather than the limited input
+ 	character set associated with the VT52.
+
+  PDCurses Return Value:
+ 	This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+ 	The DOS platform will never fail.  The Flexos platform may fail
+ 	depending on the ability to close the current virtual console in
+ 	8 (as opposed to 16) bit mode.
+
+  Portability:
+ 	PDCurses	int	PDC_scr_close( void );
+
+**man-end**********************************************************************/
+
+int	PDC_scr_close(void)
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scr_close() - called\n");
+#endif
+
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_scrn_modes_equal()	- Decide if two screen modes are equal
+
+  PDCurses Description:
+ 	Mainly required for OS/2. It decides if two screen modes
+        (VIOMODEINFO structure) are equal. Under DOS it just compares
+        two integers
+
+  PDCurses Return Value:
+ 	This function returns TRUE if equal else FALSe.
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	int PDC_scrn_modes_equal( int mode1, int mode2 );
+ 	OS2 PDCurses	int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool	PDC_scrn_modes_equal(int mode1, int mode2)
+#else
+bool	PDC_scrn_modes_equal(mode1,mode2)
+int mode1;
+int mode2;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scrn_modes_equal() - called\n");
+#endif
+	return (mode1 == mode2);
+}
+
+/*man-start*********************************************************************
+
+  PDC_scr_open()	- Internal low-level binding to open the physical screen
+
+  PDCurses Description:
+ 	This function provides a low-level binding for the Flexos
+ 	platform which must open the screen before writing to it.
+
+ 	This function is provided in order to access the FlexOS 16 bit
+ 	character set for input rather than the limited input
+ 	character set associated with the VT52.
+
+  PDCurses Return Value:
+ 	This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+ 	The DOS platform will never fail.  The Flexos platform may fail
+ 	depending on the ability to open the current virtual console in
+ 	8 (as opposed to 16) bit mode.
+
+  Portability:
+ 	PDCurses	int	PDC_scr_open( SCREEN* internal, bool echo );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_scr_open(SCREEN *internal, bool echo)
+#else
+int	PDC_scr_open(internal,echo)
+SCREEN *internal;
+bool echo;
+#endif
+/***********************************************************************/
+{
+extern bool sb_started;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_scr_open() - called\n");
+#endif
+
+	internal->cursrow = internal->curscol = 0;
+	internal->direct_video	= FALSE;		/* Assume that we can't	      */
+	internal->autocr	= TRUE;		/* lf -> crlf by default      */
+	internal->raw_out	= FALSE;	/* tty I/O modes	      */
+	internal->raw_inp	= FALSE;	/* tty I/O modes	      */
+	internal->cbreak	= TRUE;
+	internal->save_key_modifiers	= FALSE;
+	internal->return_key_modifiers	= FALSE;
+	internal->echo		= echo;
+	internal->refrbrk	= FALSE;	/* no premature end of refresh*/
+	internal->video_page	= 0;		/* Current Video Page	      */
+	internal->visible_cursor= TRUE;		/* Assume that it is visible  */
+	internal->cursor	= 0;
+	internal->adapter	= 0;
+	internal->audible	= TRUE;
+	internal->visibility	= 1;
+	internal->orig_cursor = internal->cursor;
+	internal->orig_attr = 0;
+	internal->orgcbr = 0;
+	internal->blank = ' ';
+	internal->resized = FALSE;
+	internal->shell = FALSE;
+	internal->_trap_mbe = 0L;
+	internal->_map_mbe_to_key = 0L;
+	internal->linesrippedoff = 0;
+	internal->linesrippedoffontop = 0;
+	internal->delaytenths = 0;
+	internal->sb_on = sb_started;
+	internal->sb_total_y = 0;
+	internal->sb_viewport_y = 0;
+	internal->sb_cur_y = 0;
+	internal->sb_total_x = 0;
+	internal->sb_viewport_x = 0;
+	internal->sb_cur_x = 0;
+	internal->line_color = COLOR_WHITE;
+
+	return( OK );
+}
+
+/*man-start*********************************************************************
+
+  PDC_resize_screen()	- Internal low-level function to resize screen
+
+  PDCurses Description:
+ 	This function provides a means for the application program to
+ 	resize the overall dimensions of the screen.  Under DOS and OS/2
+ 	the application can tell PDCurses what size to make the screen;
+ 	under X11, resizing is done by the user and this function simply
+ 	adjusts its internal structures to fit the new size.
+
+  PDCurses Return Value:
+ 	This function returns OK on success, otherwise an ERR is returned.
+
+  PDCurses Errors:
+
+  Portability:
+ 	PDCurses	int	PDC_resize_screen( int, int );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_resize_screen(int nlines, int ncols)
+#else
+int	PDC_resize_screen(nlines, ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+	int rc=OK;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_resize_screen() - called. Lines: %d Cols: %d\n",nlines,ncols);
+#endif
+
+	rc = XCursesResizeScreen(nlines,ncols);
+	return (rc);
+}
diff -Naur gdb-6.8/pdcurses/x11/pdcsetsc.c stsgdb-6.8/pdcurses/x11/pdcsetsc.c
--- gdb-6.8/pdcurses/x11/pdcsetsc.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcsetsc.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,169 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+#ifdef PDCDEBUG
+char *rcsid_PDCsetsc  = "$Id: pdcsetsc.c,v 1.2 2001/01/10 08:30:16 mark Exp $";
+#endif
+
+
+/*man-start*********************************************************************
+
+  PDC_set_font()	- sets the current font size
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine sets the current font size, if the adapter allows
+ 	such a change.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the font size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_font( int size );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_font(int size)
+#else
+int	PDC_set_font(size)
+int size;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_font() - called\n");
+#endif
+	return(OK);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_rows()	- sets the physical number of rows on screen
+
+  PDCurses Description:
+ 	This is a private PDCurses function.
+
+ 	This routine attempts to set the number of rows on the physical
+ 	screen to the passed value.
+
+  PDCurses Return Value:
+ 	This function returns OK upon success otherwise ERR is returned.
+
+  PDCurses Errors:
+ 	It is an error to attempt to change the screen size on a "bogus"
+ 	adapter.  The reason for this is that we have a known video
+ 	adapter identity problem.  e.g. Two adapters report the same
+ 	identifying characteristics.
+
+ 	It is also an error to attempt to change the size of the Flexos
+ 	console (as there is currently no support for that).
+
+  Portability:
+ 	PDCurses	int	PDC_set_rows( int rows );
+
+**man-end**********************************************************************/
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_set_rows(int rows)
+#else
+int	PDC_set_rows(rows)
+int rows;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_rows() - called\n");
+#endif
+	return(0);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int	PDC_curs_set(int visibility)
+#else
+int	PDC_curs_set(visibility)
+int visibility;
+#endif
+/***********************************************************************/
+{
+   int ret_vis = SP->visibility;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("PDC_curs_set() - called: visibility=%d\n",visibility);
+#endif
+
+   if ( visibility != -1 )
+   {
+      SP->visibility = visibility;
+   }
+   XCurses_display_cursor(SP->cursrow,SP->curscol,SP->cursrow,SP->curscol,visibility);
+   return(ret_vis);
+}
+
+/*man-start*********************************************************************
+
+  PDC_set_title()	- Set window title
+
+  PDCurses Description:
+ 	Sets the title of the window in which the curses program is running.
+ 	This function may not do anything on some platforms.
+
+  PDCurses Return Value:
+ 	N/A
+
+  PDCurses Errors:
+ 	No errors are defined for this function.
+
+  Portability:
+ 	PDCurses	void PDC_set_title( char *title );
+
+**man-end**********************************************************************/
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void	PDC_set_title(char *title)
+#else
+void	PDC_set_title(title)
+char *title;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("PDC_set_title() - called:<%s>\n",title);
+#endif
+	XCurses_set_title(title);
+	return;
+}
diff -Naur gdb-6.8/pdcurses/x11/pdcx11.c stsgdb-6.8/pdcurses/x11/pdcx11.c
--- gdb-6.8/pdcurses/x11/pdcx11.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcx11.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,3295 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+*
+* See the file maintain.er for details of the current maintainer.
+*
+* This file is NOT public domain software.  It is Copyright, Mark Hessling
+* 1994,1995.
+***************************************************************************
+*/
+
+#if defined(XCURSES)
+#include "pdcx11.h"
+
+AppData app_data;
+
+#if NeedWidePrototypes
+# define PDC_SCROLLBAR_TYPE double
+#else
+# define PDC_SCROLLBAR_TYPE float
+#endif
+
+/***************************************************************************/
+/* Default icons for XCurses applications.                                 */
+/***************************************************************************/
+#define BIG_ICON_WIDTH 64
+#define BIG_ICON_HEIGHT 64
+static unsigned char big_icon_bitmap_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
+   0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x00, 0xc0, 0x00, 0x00,
+   0x00, 0x00, 0xfc, 0x03, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07,
+   0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x18, 0x00, 0x00,
+   0x00, 0x00, 0xf0, 0x0f, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f,
+   0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x06, 0x00, 0x00,
+   0x00, 0x00, 0xc0, 0x3f, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f,
+   0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xfe, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
+   0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x33, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xf8, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
+   0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x0e, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0,
+   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x7f, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x98, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
+   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xfe, 0x01, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x03, 0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01,
+   0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0xf8, 0x07, 0x00, 0x00,
+   0x00, 0x00, 0xc0, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
+   0xe0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xe0, 0x1f, 0x00, 0x00,
+   0x00, 0x00, 0x18, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
+   0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xff, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x23, 0x50, 0x1e,
+   0x7c, 0xf0, 0xe0, 0x03, 0x60, 0x26, 0x50, 0x33, 0xc6, 0x98, 0x31, 0x06,
+   0x30, 0x2c, 0xd0, 0x61, 0x83, 0x0d, 0x1b, 0x0c, 0x10, 0x28, 0xd0, 0x40,
+   0x01, 0x05, 0x0a, 0x08, 0x10, 0x20, 0x50, 0x00, 0x01, 0x05, 0x0a, 0x08,
+   0x10, 0x20, 0x50, 0x00, 0x03, 0x04, 0x1a, 0x00, 0x10, 0x20, 0x50, 0x00,
+   0x06, 0x04, 0x32, 0x00, 0x10, 0x20, 0x50, 0x00, 0x7c, 0xfc, 0xe3, 0x03,
+   0x10, 0x20, 0x50, 0x00, 0xc0, 0x04, 0x00, 0x06, 0x10, 0x20, 0x50, 0x00,
+   0x80, 0x05, 0x00, 0x0c, 0x10, 0x20, 0x50, 0x00, 0x01, 0x05, 0x0a, 0x08,
+   0x10, 0x28, 0x50, 0x00, 0x01, 0x05, 0x0a, 0x08, 0x30, 0x6c, 0x58, 0x00,
+   0x83, 0x0d, 0x1b, 0x0c, 0x60, 0xc6, 0x4c, 0x00, 0xc6, 0x98, 0x31, 0x06,
+   0xc0, 0x83, 0x47, 0x00, 0x7c, 0xf0, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+#define LITTLE_ICON_WIDTH 32
+#define LITTLE_ICON_HEIGHT 32
+static unsigned char little_icon_bitmap_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x80, 0x07, 0x00, 0x01, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x1e, 0x40, 0x00,
+   0x00, 0x3c, 0x20, 0x00, 0x00, 0x78, 0x10, 0x00, 0x00, 0xf0, 0x08, 0x00,
+   0x00, 0xe0, 0x05, 0x00, 0x00, 0xc0, 0x06, 0x00, 0x00, 0x40, 0x07, 0x00,
+   0x00, 0x20, 0x0f, 0x00, 0x00, 0x10, 0x1e, 0x00, 0x00, 0x08, 0x3c, 0x00,
+   0x00, 0x04, 0x78, 0x00, 0x00, 0x02, 0xf0, 0x00, 0x00, 0x01, 0xe0, 0x01,
+   0x80, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x4c, 0x2a, 0xc6, 0x18, 0x52, 0x5a, 0x29, 0x25, 0x42, 0x0a, 0x29, 0x25,
+   0x42, 0x0a, 0xe2, 0x09, 0x42, 0x0a, 0x24, 0x10, 0x42, 0x0a, 0x29, 0x20,
+   0x52, 0x0a, 0x29, 0x25, 0x8c, 0x09, 0xc6, 0x18, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+
+
+
+
+struct XCursesKey
+{
+ int keycode;
+ int numkeypad;
+ int normal;
+ int shifted;
+ int control;
+ int alt;
+};
+typedef struct XCursesKey XCURSESKEY;
+
+XCURSESKEY XCursesKeys[] =
+{
+/* keycode        keypad ?       normal         shifted         control         alt*/
+ {XK_Left,        FALSE,         KEY_LEFT,      KEY_SLEFT,      CTL_LEFT,       ALT_LEFT},
+ {XK_Right,       FALSE,         KEY_RIGHT,     KEY_SRIGHT,     CTL_RIGHT,      ALT_RIGHT},
+ {XK_Up,          FALSE,         KEY_UP,        KEY_SUP,        CTL_UP,         ALT_UP},
+ {XK_Down,        FALSE,         KEY_DOWN,      KEY_SDOWN,      CTL_DOWN,       ALT_DOWN},
+ {XK_Home,        FALSE,         KEY_HOME,      KEY_SHOME,      CTL_HOME,       ALT_HOME},
+ {XK_R7,          FALSE,         KEY_HOME,      KEY_SHOME,      CTL_HOME,       ALT_HOME}, /* Sun Type 4 keyboard */
+ {XK_End,         FALSE,         KEY_END,       KEY_SEND,       CTL_END,        ALT_END},
+ {XK_R13,         FALSE,         KEY_END,       KEY_SEND,       CTL_END,        ALT_END},  /* Sun Type 4 keyboard */
+ {XK_Prior,       FALSE,         KEY_PPAGE,     KEY_SPREVIOUS,  CTL_PGUP,       ALT_PGUP},
+ {XK_R9,          FALSE,         KEY_PPAGE,     KEY_SPREVIOUS,  CTL_PGUP,       ALT_PGUP}, /* Sun Type 4 keyboard */
+ {XK_Next,        FALSE,         KEY_NPAGE,     KEY_SNEXT,      CTL_PGDN,       ALT_PGDN},
+ {XK_R15,         FALSE,         KEY_NPAGE,     KEY_SNEXT,      CTL_PGDN,       ALT_PGDN}, /* Sun Type 4 keyboard */
+ {XK_Insert,      FALSE,         KEY_IC,        KEY_SIC,        CTL_INS,        ALT_INS},
+ {XK_Delete,      FALSE,         KEY_DC,        KEY_SDC,        CTL_DEL,        ALT_DEL},
+ {XK_F1,          FALSE,         KEY_F(1),      KEY_F(13),      KEY_F(25),      KEY_F(37)},
+ {XK_F2,          FALSE,         KEY_F(2),      KEY_F(14),      KEY_F(26),      KEY_F(38)},
+ {XK_F3,          FALSE,         KEY_F(3),      KEY_F(15),      KEY_F(27),      KEY_F(39)},
+ {XK_F4,          FALSE,         KEY_F(4),      KEY_F(16),      KEY_F(28),      KEY_F(40)},
+ {XK_F5,          FALSE,         KEY_F(5),      KEY_F(17),      KEY_F(29),      KEY_F(41)},
+ {XK_F6,          FALSE,         KEY_F(6),      KEY_F(18),      KEY_F(30),      KEY_F(42)},
+ {XK_F7,          FALSE,         KEY_F(7),      KEY_F(19),      KEY_F(31),      KEY_F(43)},
+ {XK_F8,          FALSE,         KEY_F(8),      KEY_F(20),      KEY_F(32),      KEY_F(44)},
+ {XK_F9,          FALSE,         KEY_F(9),      KEY_F(21),      KEY_F(33),      KEY_F(45)},
+ {XK_F10,         FALSE,         KEY_F(10),     KEY_F(22),      KEY_F(34),      KEY_F(46)},
+ {XK_F11,         FALSE,         KEY_F(11),     KEY_F(23),      KEY_F(35),      KEY_F(47)},
+ {XK_F12,         FALSE,         KEY_F(12),     KEY_F(24),      KEY_F(36),      KEY_F(48)},
+ {XK_F13,         FALSE,         KEY_F(13),     KEY_F(25),      KEY_F(37),      KEY_F(49)},
+ {XK_F14,         FALSE,         KEY_F(14),     KEY_F(26),      KEY_F(38),      KEY_F(50)},
+ {XK_F15,         FALSE,         KEY_F(15),     KEY_F(27),      KEY_F(39),      KEY_F(51)},
+ {XK_F16,         FALSE,         KEY_F(16),     KEY_F(28),      KEY_F(40),      KEY_F(52)},
+ {XK_F17,         FALSE,         KEY_F(17),     KEY_F(29),      KEY_F(41),      KEY_F(53)},
+ {XK_F18,         FALSE,         KEY_F(18),     KEY_F(30),      KEY_F(42),      KEY_F(54)},
+ {XK_F19,         FALSE,         KEY_F(19),     KEY_F(31),      KEY_F(43),      KEY_F(55)},
+ {XK_F20,         FALSE,         KEY_F(20),     KEY_F(32),      KEY_F(44),      KEY_F(56)},
+ {XK_BackSpace,   FALSE,         0x08,          0x08,           CTL_BKSP,       ALT_BKSP},
+ {XK_Tab,         FALSE,         0x09,          KEY_BTAB,       CTL_TAB,        ALT_TAB},
+ {XK_Select,      FALSE,         KEY_SELECT,    KEY_SELECT,     KEY_SELECT,     KEY_SELECT},
+ {XK_Print,       FALSE,         KEY_PRINT,     KEY_SPRINT,     KEY_PRINT,      KEY_PRINT},
+ {XK_Find,        FALSE,         KEY_FIND,      KEY_SFIND,      KEY_FIND,       KEY_FIND},
+ {XK_Pause,       FALSE,         KEY_SUSPEND,   KEY_SSUSPEND,   KEY_SUSPEND,    KEY_SUSPEND},
+ {XK_Clear,       FALSE,         KEY_CLEAR,     KEY_CLEAR,      KEY_CLEAR,      KEY_CLEAR},
+ {XK_Cancel,      FALSE,         KEY_CANCEL,    KEY_SCANCEL,    KEY_CANCEL,     KEY_CANCEL},
+ {XK_Break,       FALSE,         KEY_BREAK,     KEY_BREAK,      KEY_BREAK,      KEY_BREAK},
+ {XK_Help,        FALSE,         KEY_HELP,      KEY_SHELP,      KEY_LHELP,      KEY_HELP},
+ {XK_L4,          FALSE,         KEY_UNDO,      KEY_SUNDO,      KEY_UNDO,       KEY_UNDO},
+ {XK_L6,          FALSE,         KEY_COPY,      KEY_SCOPY,      KEY_COPY,       KEY_COPY},
+ {XK_L9,          FALSE,         KEY_FIND,      KEY_SFIND,      KEY_FIND,       KEY_FIND},
+ {XK_Menu,        FALSE,         KEY_OPTIONS,   KEY_SOPTIONS,   KEY_OPTIONS,    KEY_OPTIONS},
+#ifdef HAVE_SUNKEYSYM_H
+ {SunXK_F36,      FALSE,         KEY_F(41),     KEY_F(43),      KEY_F(45),      KEY_F(47)},
+ {SunXK_F37,      FALSE,         KEY_F(42),     KEY_F(44),      KEY_F(46),      KEY_F(48)},
+#endif
+#ifdef HAVE_DECKEYSYM_H
+ {DXK_Remove,     FALSE,         KEY_DC,        KEY_SDC,        CTL_DEL,        ALT_DEL},
+#endif
+ {XK_Escape,      FALSE,         0x1B,          0x1B,           0x1B,           ALT_ESC},
+ {XK_KP_Enter,    TRUE,          PADENTER,      PADENTER,       CTL_PADENTER,   ALT_PADENTER},
+ {XK_KP_Add,      TRUE,          PADPLUS,       (int)'+',       CTL_PADPLUS,    ALT_PADPLUS},
+ {XK_KP_Subtract, TRUE,          PADMINUS,      (int)'-',       CTL_PADMINUS,   ALT_PADMINUS},
+ {XK_KP_Multiply, TRUE,          PADSTAR,       (int)'*',       CTL_PADSTAR,    ALT_PADSTAR},
+ {XK_R6,          TRUE,          PADSTAR,       (int)'*',       CTL_PADSTAR,    ALT_PADSTAR}, /* Sun Type 4 keyboard */
+ {XK_KP_Divide,   TRUE,          PADSLASH,      (int)'/',       CTL_PADSLASH,   ALT_PADSLASH},
+ {XK_R5,          TRUE,          PADSLASH,      (int)'/',       CTL_PADSLASH,   ALT_PADSLASH},/* Sun Type 4 keyboard */
+ {XK_KP_Decimal,  TRUE,          PADSTOP,       (int)'.',       CTL_PADSTOP,    ALT_PADSTOP},
+ {XK_KP_0,        TRUE,          PAD0,          (int)'0',       CTL_PAD0,       ALT_PAD0},
+ {XK_KP_1,        TRUE,          KEY_C1,        (int)'1',       CTL_PAD1,       ALT_PAD1},
+ {XK_KP_2,        TRUE,          KEY_C2,        (int)'2',       CTL_PAD2,       ALT_PAD2},
+ {XK_KP_3,        TRUE,          KEY_C3,        (int)'3',       CTL_PAD3,       ALT_PAD3},
+ {XK_KP_4,        TRUE,          KEY_B1,        (int)'4',       CTL_PAD4,       ALT_PAD4},
+ {XK_KP_5,        TRUE,          KEY_B2,        (int)'5',       CTL_PAD5,       ALT_PAD5},
+ {XK_R11,         TRUE,          KEY_B2,        (int)'5',       CTL_PAD5,       ALT_PAD5}, /* Sun Type 4 keyboard */
+ {XK_KP_6,        TRUE,          KEY_B3,        (int)'6',       CTL_PAD6,       ALT_PAD6},
+ {XK_KP_7,        TRUE,          KEY_A1,        (int)'7',       CTL_PAD7,       ALT_PAD7},
+ {XK_KP_8,        TRUE,          KEY_A2,        (int)'8',       CTL_PAD8,       ALT_PAD8},
+ {XK_KP_9,        TRUE,          KEY_A3,        (int)'9',       CTL_PAD9,       ALT_PAD9},
+/* the following added to support Sun Type 5 keyboards */
+ {XK_F21,         FALSE,         KEY_SUSPEND,   KEY_SSUSPEND,   KEY_SUSPEND,    KEY_SUSPEND},
+ {XK_F22,         FALSE,         KEY_PRINT,     KEY_SPRINT,     KEY_PRINT,      KEY_PRINT},
+ {XK_F24,         TRUE,          PADMINUS,      (int)'-',       CTL_PADMINUS,   ALT_PADMINUS},
+ {XK_F25,         TRUE,          PADSLASH,      (int)'/',       CTL_PADSLASH,   ALT_PADSLASH},/* Sun Type 4 keyboard */
+ {XK_F26,         TRUE,          PADSTAR,       (int)'*',       CTL_PADSTAR,    ALT_PADSTAR}, /* Sun Type 4 keyboard */
+ {XK_F27,         TRUE,          KEY_A1,        (int)'7',       CTL_PAD7,       ALT_PAD7},
+ {XK_F29,         TRUE,          KEY_A3,        (int)'9',       CTL_PAD9,       ALT_PAD9},
+ {XK_F31,         TRUE,          KEY_B2,        (int)'5',       CTL_PAD5,       ALT_PAD5},
+ {XK_F35,         TRUE,          KEY_C3,        (int)'3',       CTL_PAD3,       ALT_PAD3},
+#ifdef HAVE_XK_KP_DELETE
+ {XK_KP_Delete,   TRUE,          PADSTOP,       (int)'.',       CTL_PADSTOP,    ALT_PADSTOP},
+#endif
+#ifdef HAVE_XK_KP_INSERT
+ {XK_KP_Insert,   TRUE,          PAD0,          (int)'0',       CTL_PAD0,       ALT_PAD0},
+#endif
+#ifdef HAVE_XK_KP_END
+ {XK_KP_End,      TRUE,          KEY_C1,        (int)'1',       CTL_PAD1,       ALT_PAD1},
+#endif
+#ifdef HAVE_XK_KP_DOWN
+ {XK_KP_Down,     TRUE,          KEY_C2,        (int)'2',       CTL_PAD2,       ALT_PAD2},
+#endif
+#ifdef HAVE_XK_KP_NEXT
+ {XK_KP_Next,     TRUE,          KEY_C3,        (int)'3',       CTL_PAD3,       ALT_PAD3},
+#endif
+#ifdef HAVE_XK_KP_LEFT
+ {XK_KP_Left,     TRUE,          KEY_B1,        (int)'4',       CTL_PAD4,       ALT_PAD4},
+#endif
+#ifdef HAVE_XK_KP_BEGIN
+ {XK_KP_Begin,    TRUE,          KEY_B2,        (int)'5',       CTL_PAD5,       ALT_PAD5},
+#endif
+#ifdef HAVE_XK_KP_RIGHT
+ {XK_KP_Right,    TRUE,          KEY_B3,        (int)'6',       CTL_PAD6,       ALT_PAD6},
+#endif
+#ifdef HAVE_XK_KP_HOME
+ {XK_KP_Home,     TRUE,          KEY_A1,        (int)'7',       CTL_PAD7,       ALT_PAD7},
+#endif
+#ifdef HAVE_XK_KP_UP
+ {XK_KP_Up,       TRUE,          KEY_A2,        (int)'8',       CTL_PAD8,       ALT_PAD8},
+#endif
+#ifdef HAVE_XK_KP_PRIOR
+ {XK_KP_Prior,    TRUE,          KEY_A3,        (int)'9',       CTL_PAD9,       ALT_PAD9},
+#endif
+
+#ifdef INCLUDE_LATIN1
+# include "latin1kbd.h"
+#endif
+
+ {0,              0,             0,             0,              0,              0},
+};
+
+#define MAX_COMPOSE_CHARS 14
+#define MAX_COMPOSE_PRE 60
+char *compose_chars = "`'~^,/\"AaPpSs!?0123CcRr-_<>Xx.=Yy |EeIiOoUu+NnLlgDd:*TtMmVv";
+/*
+   ` :                               
+   ' :                                           
+   ~ :                   
+   ^ :                               
+   , :             
+   / :             
+   " :                                        
+   A :                               
+   a :                               
+   P :          
+   p :          
+   S :                
+   s :                         
+   ! :       
+   ? :       
+   1 :             
+   0 :       
+   2 :       
+   3 :          
+   C :             
+   c :                
+   R :    
+   r :    
+   - :                   
+   _ :       
+   < :    
+   > :    
+   X :       
+   x :          
+   . :          
+   = :       
+   Y :          
+   y :                
+     :
+   | :                   
+   E :                
+   e :                
+   I :                
+   i :                
+   O :                                     
+   o :                                        
+   U :                
+   u :                   
+   + :    
+   N :          
+   n :          
+   L :          
+   l :          
+   g :    
+   D :       
+   d :       
+   : :    
+   * :       
+   T :    
+   t :    
+   M :    
+   m :    
+   V :    
+   v :    
+*/
+char compose_lookups[MAX_COMPOSE_PRE][MAX_COMPOSE_CHARS] =
+{
+/* ` */ {'A','E','I','O','U','a','e','i','o','u',000,000,000,000},
+/* ' */ {' ','A','E','I','O','U','Y','a','e','i','o','u','y', 39},
+/* ~ */ {'A','N','O','a','n','o',000,000,000,000,000,000,000,000},
+/* ^ */ {'A','E','I','O','U','a','e','i','o','u',000,000,000,000},
+/* , */ {' ','C','c',',',000,000,000,000,000,000,000,000,000,000},
+/* / */ {'O','o','u','U',000,000,000,000,000,000,000,000,000,000},
+/* " */ {' ','A','E','I','O','U','a','e','i','o','u','y','\"',000},
+/* A */ {'E','`', 39,'~','^','"','o','*','-','>','_',000,000,000},
+/* a */ {'e','`', 39,'~','^','"','o','-','_','>',000,000,000,000},
+/* P */ {' ','G','!',000,000,000,000,000,000,000,000,000,000,000},
+/* p */ {' ','g','!',000,000,000,000,000,000,000,000,000,000,000},
+/* S */ {'S','!','O','0','A',000,000,000,000,000,000,000,000,000},
+/* s */ {'s','!','a','1','2','3','0','o',000,000,000,000,000,000},
+/* ! */ {' ','!',000,000,000,000,000,000,000,000,000,000,000,000},
+/* ? */ {' ','?',000,000,000,000,000,000,000,000,000,000,000,000},
+/* 0 */ {'^','*',000,000,000,000,000,000,000,000,000,000,000,000},
+/* 1 */ {' ','2','4','^',000,000,000,000,000,000,000,000,000,000},
+/* 2 */ {' ','^',000,000,000,000,000,000,000,000,000,000,000,000},
+/* 3 */ {' ','4','^',000,000,000,000,000,000,000,000,000,000,000},
+/* C */ {'O',',','$','|',000,000,000,000,000,000,000,000,000,000},
+/* c */ {'|','o',',','/','$',000,000,000,000,000,000,000,000,000},
+/* R */ {'O',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* r */ {'o',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* - */ {' ','+',',','-','^',':',000,000,000,000,000,000,000,000},
+/* _ */ {'_','^',000,000,000,000,000,000,000,000,000,000,000,000},
+/* < */ {'<',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* > */ {'>',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* X */ {'O','X',000,000,000,000,000,000,000,000,000,000,000,000},
+/* x */ {' ','o','x',000,000,000,000,000,000,000,000,000,000,000},
+/* . */ {' ','^','.',000,000,000,000,000,000,000,000,000,000,000},
+/* = */ {'Y','y',000,000,000,000,000,000,000,000,000,000,000,000},
+/* Y */ {'=', 39,'-',000,000,000,000,000,000,000,000,000,000,000},
+/* y */ {'=', 39,'"','$','-',000,000,000,000,000,000,000,000,000},
+/*   */ {' ',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* | */ {' ','c','|','P','p','^',000,000,000,000,000,000,000,000},
+/* E */ {'`', 39,'^','"','>',000,000,000,000,000,000,000,000,000},
+/* e */ {'`', 39,'^','"','>',000,000,000,000,000,000,000,000,000},
+/* I */ {'`', 39,'^','"','>',000,000,000,000,000,000,000,000,000},
+/* i */ {'`', 39,'^','"','>',000,000,000,000,000,000,000,000,000},
+/* O */ {'`', 39,'^','~','"','/','C','R','-','>','A','a',000,000},
+/* o */ {' ','A','a','x','-','`', 39,'^','~','"','/','>','_',000},
+/* U */ {'`', 39,'^','"','>',000,000,000,000,000,000,000,000,000},
+/* u */ {'`', 39,'^','"',' ','>',000,000,000,000,000,000,000,000},
+/* + */ {'-',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* N */ {'~','-','O',000,000,000,000,000,000,000,000,000,000,000},
+/* n */ {'~','-','o',000,000,000,000,000,000,000,000,000,000,000},
+/* L */ {'$','=','-',000,000,000,000,000,000,000,000,000,000,000},
+/* l */ {'$','=','-',000,000,000,000,000,000,000,000,000,000,000},
+/* g */ {'$',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* D */ {'E','-',000,000,000,000,000,000,000,000,000,000,000,000},
+/* d */ {'e','-',000,000,000,000,000,000,000,000,000,000,000,000},
+/* : */ {'-',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* * */ {'m','M',000,000,000,000,000,000,000,000,000,000,000,000},
+/* T */ {'H',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* t */ {'h',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* M */ {'U',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* m */ {'u',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* V */ {'B',000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* v */ {'b',000,000,000,000,000,000,000,000,000,000,000,000,000},
+};
+
+int compose_keys[MAX_COMPOSE_PRE][MAX_COMPOSE_CHARS] =
+{
+/* ` */ {192,200,204,210,217,224,232,236,242,249,000,000,000,000},
+/* ' */ {180,193,201,205,211,218,221,225,233,237,243,250,253,180},
+/* ~ */ {195,209,213,227,241,245,000,000,000,000,000,000,000,000},
+/* ^ */ {194,202,206,212,219,226,234,238,244,251,000,000,000,000},
+/* , */ {184,199,231,184,000,000,000,000,000,000,000,000,000,000},
+/* / */ {216,248,181,181,000,000,000,000,000,000,000,000,000,000},
+/* " */ {168,196,203,207,214,220,228,235,239,246,252,255,168,000},
+/* A */ {198,192,193,195,194,196,197,197,195,194,170,000,000,000},
+/* a */ {230,224,225,227,226,228,229,227,170,226,000,000,000,000},
+/* P */ {222,182,182,000,000,000,000,000,000,000,000,000,000,000},
+/* p */ {254,182,182,000,000,000,000,000,000,000,000,000,000,000},
+/* S */ {167,167,167,186,170,000,000,000,000,000,000,000,000,000},
+/* s */ {223,167,170,185,178,179,186,167,000,000,000,000,000,000},
+/* ! */ {161,161,000,000,000,000,000,000,000,000,000,000,000,000},
+/* ? */ {191,191,000,000,000,000,000,000,000,000,000,000,000,000},
+/* 0 */ {176,176,000,000,000,000,000,000,000,000,000,000,000,000},
+/* 1 */ {185,189,188,185,000,000,000,000,000,000,000,000,000,000},
+/* 2 */ {178,178,000,000,000,000,000,000,000,000,000,000,000,000},
+/* 3 */ {179,190,179,000,000,000,000,000,000,000,000,000,000,000},
+/* C */ {169,199,162,162,000,000,000,000,000,000,000,000,000,000},
+/* c */ {162,169,231,162,162,000,000,000,000,000,000,000,000,000},
+/* R */ {174,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* r */ {174,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* - */ {173,177,172,173,175,247,000,000,000,000,000,000,000,000},
+/* _ */ {175,175,000,000,000,000,000,000,000,000,000,000,000,000},
+/* < */ {171,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* > */ {187,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* X */ {164,215,000,000,000,000,000,000,000,000,000,000,000,000},
+/* x */ {215,164,215,000,000,000,000,000,000,000,000,000,000,000},
+/* . */ {183,183,183,000,000,000,000,000,000,000,000,000,000,000},
+/* = */ {165,165,000,000,000,000,000,000,000,000,000,000,000,000},
+/* Y */ {165,221,165,000,000,000,000,000,000,000,000,000,000,000},
+/* y */ {165,253,255,165,165,000,000,000,000,000,000,000,000,000},
+/*   */ {160,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* | */ {166,162,166,222,254,166,000,000,000,000,000,000,000,000},
+/* E */ {200,201,202,203,202,000,000,000,000,000,000,000,000,000},
+/* e */ {232,233,234,235,234,000,000,000,000,000,000,000,000,000},
+/* I */ {204,205,206,207,206,000,000,000,000,000,000,000,000,000},
+/* i */ {236,237,238,239,238,000,000,000,000,000,000,000,000,000},
+/* O */ {210,211,212,213,214,216,169,174,213,212,197,229,000,000},
+/* o */ {176,197,229,164,245,242,243,244,245,246,248,244,186,000},
+/* U */ {217,218,219,220,219,000,000,000,000,000,000,000,000,000},
+/* u */ {249,250,251,252,181,251,000,000,000,000,000,000,000,000},
+/* + */ {177,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* N */ {209,209,172,000,000,000,000,000,000,000,000,000,000,000},
+/* n */ {241,241,172,000,000,000,000,000,000,000,000,000,000,000},
+/* L */ {163,163,163,000,000,000,000,000,000,000,000,000,000,000},
+/* l */ {163,163,163,000,000,000,000,000,000,000,000,000,000,000},
+/* g */ {164,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* D */ {176,208,000,000,000,000,000,000,000,000,000,000,000,000},
+/* d */ {176,240,000,000,000,000,000,000,000,000,000,000,000,000},
+/* : */ {247,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* * */ {181,181,000,000,000,000,000,000,000,000,000,000,000,000},
+/* T */ {222,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* t */ {254,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* M */ {215,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* u */ {215,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* V */ {166,000,000,000,000,000,000,000,000,000,000,000,000,000},
+/* v */ {166,000,000,000,000,000,000,000,000,000,000,000,000,000},
+};
+
+
+
+#define BITMAPDEPTH 1
+
+/*
+ * X11 Variables common to both process and thread ports
+ */
+MOUSE_STATUS Trapped_Mouse_status;
+unsigned long pdc_key_modifier=0L;
+GC normal_gc,block_cursor_gc,rect_cursor_gc,italic_gc,border_gc;
+int XCursesFontHeight,XCursesFontWidth;
+int XCursesFontAscent,XCursesFontDescent;
+int XCursesWindowWidth,XCursesWindowHeight;
+int resizeXCursesWindowWidth=0,resizeXCursesWindowHeight=0;
+char *bitmap_file=NULL;
+#ifdef HAVE_XPM_H
+char *pixmap_file=NULL;
+#endif
+KeySym compose_key=0;
+int compose_mask=0;
+int state_mask[8] =
+{
+ ShiftMask,
+ LockMask,
+ ControlMask,
+ Mod1Mask,
+ Mod2Mask,
+ Mod3Mask,
+ Mod4Mask,
+ Mod5Mask
+};
+Atom wm_atom[2];
+char *XCursesClassName="XCurses";
+XtAppContext app_context;
+Widget  topLevel,drawing,d1,scrollBox,scrollVert,scrollHoriz;
+int ReceivedMapNotify=0;
+Boolean mouse_selection=False;
+char *tmpsel=NULL;
+unsigned long tmpsel_length=0;
+int selection_start_x=0;
+int selection_start_y=0;
+int selection_end_x=0;
+int selection_end_y=0;
+Pixmap icon_bitmap;
+#ifdef HAVE_XPM_H
+Pixmap icon_pixmap;
+Pixmap icon_pixmap_mask;
+#endif
+XtResource app_resources[PDC_NUMBER_APP_RESOURCES] =
+{
+ {
+  XtNlines,
+  XtCLines,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,lines),
+  XtRImmediate,
+  (XtPointer)24,
+ },
+ {
+  XtNcols,
+  XtCCols,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,cols),
+  XtRImmediate,
+  (XtPointer)80,
+ },
+ {
+  XtNcursorColor,
+  XtCCursorColor,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,cursorColor),
+  XtRString,
+  (XtPointer)"Red",
+ },
+ {
+  XtNcolorBlack,
+  XtCColorBlack,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBlack),
+  XtRString,
+  (XtPointer)"Black",
+ },
+ {
+  XtNcolorRed,
+  XtCColorRed,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorRed),
+  XtRString,
+  (XtPointer)"red3",
+ },
+ {
+  XtNcolorGreen,
+  XtCColorGreen,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorGreen),
+  XtRString,
+  (XtPointer)"green3",
+ },
+ {
+  XtNcolorYellow,
+  XtCColorYellow,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorYellow),
+  XtRString,
+  (XtPointer)"yellow3",
+ },
+ {
+  XtNcolorBlue,
+  XtCColorBlue,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBlue),
+  XtRString,
+  (XtPointer)"blue3",
+ },
+ {
+  XtNcolorMagenta,
+  XtCColorMagenta,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorMagenta),
+  XtRString,
+  (XtPointer)"magenta3",
+ },
+ {
+  XtNcolorCyan,
+  XtCColorCyan,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorCyan),
+  XtRString,
+  (XtPointer)"cyan3",
+ },
+ {
+  XtNcolorWhite,
+  XtCColorWhite,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorWhite),
+  XtRString,
+  (XtPointer)"Grey",
+ },
+ {
+  XtNcolorBoldBlack,
+  XtCColorBoldBlack,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldBlack),
+  XtRString,
+  (XtPointer)"grey40",
+ },
+ {
+  XtNcolorBoldRed,
+  XtCColorBoldRed,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldRed),
+  XtRString,
+  (XtPointer)"red1",
+ },
+ {
+  XtNcolorBoldGreen,
+  XtCColorBoldGreen,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldGreen),
+  XtRString,
+  (XtPointer)"green1",
+ },
+ {
+  XtNcolorBoldYellow,
+  XtCColorBoldYellow,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldYellow),
+  XtRString,
+  (XtPointer)"yellow1",
+ },
+ {
+  XtNcolorBoldBlue,
+  XtCColorBoldBlue,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldBlue),
+  XtRString,
+  (XtPointer)"blue1",
+ },
+ {
+  XtNcolorBoldMagenta,
+  XtCColorBoldMagenta,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldMagenta),
+  XtRString,
+  (XtPointer)"magenta1",
+ },
+ {
+  XtNcolorBoldCyan,
+  XtCColorBoldCyan,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldCyan),
+  XtRString,
+  (XtPointer)"cyan1",
+ },
+ {
+  XtNcolorBoldWhite,
+  XtCColorBoldWhite,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,colorBoldWhite),
+  XtRString,
+  (XtPointer)"White",
+ },
+ {
+  XtNnormalFont,
+  XtCNormalFont,
+  XtRFontStruct,
+  sizeof(XFontStruct),
+  XtOffsetOf(AppData,normalfont),
+  XtRString,
+  (XtPointer)"7x13",
+ },
+ {
+  XtNitalicFont,
+  XtCItalicFont,
+  XtRFontStruct,
+  sizeof(XFontStruct),
+  XtOffsetOf(AppData,italicfont),
+  XtRString,
+  (XtPointer)"7x13",
+ },
+ {
+  XtNbitmap,
+  XtCBitmap,
+  XtRString,
+  MAX_PATH,
+  XtOffsetOf(AppData,bitmapFile),
+  XtRString,
+  (XtPointer)"",
+ },
+#ifdef HAVE_XPM_H
+ {
+  XtNpixmap,
+  XtCPixmap,
+  XtRString,
+  MAX_PATH,
+  XtOffsetOf(AppData,pixmapFile),
+  XtRString,
+  (XtPointer)"",
+ },
+#endif
+ {
+  XtNcomposeKey,
+  XtCComposeKey,
+  XtRString,
+  MAX_PATH,
+  XtOffsetOf(AppData,composeKey),
+  XtRString,
+  (XtPointer)"",
+ },
+ {
+  XtNpointer,
+  XtCPointer,
+  XtRCursor,
+  sizeof(Cursor),
+  XtOffsetOf(AppData,pointer),
+  XtRString,
+  (XtPointer)"xterm",
+ },
+ {
+  XtNpointerForeColor,
+  XtCPointerForeColor,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,pointerForeColor),
+  XtRString,
+  (XtPointer)"Black",
+ },
+ {
+  XtNpointerBackColor,
+  XtCPointerBackColor,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,pointerBackColor),
+  XtRString,
+  (XtPointer)"White",
+ },
+ {
+  XtNshmmin,
+  XtCShmmin,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,shmmin),
+  XtRImmediate,
+  (XtPointer)0,
+ },
+ {
+  XtNborderWidth,
+  XtCBorderWidth,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,borderWidth),
+  XtRImmediate,
+  (XtPointer)0,
+ },
+ {
+  XtNborderColor,
+  XtCBorderColor,
+  XtRPixel,
+  sizeof(Pixel),
+  XtOffsetOf(AppData,borderColor),
+  XtRString,
+  (XtPointer)"Black",
+ },
+ {
+  XtNdoubleClickPeriod,
+  XtCDoubleClickPeriod,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,doubleClickPeriod),
+  XtRImmediate,
+  (XtPointer)200,
+ },
+ {
+  XtNclickPeriod,
+  XtCClickPeriod,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,clickPeriod),
+  XtRImmediate,
+  (XtPointer)100,
+ },
+ {
+  XtNscrollbarWidth,
+  XtCScrollbarWidth,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,scrollbarWidth),
+  XtRImmediate,
+  (XtPointer)15,
+ },
+ {
+  XtNcursorBlinkRate,
+  XtCCursorBlinkRate,
+  XtRInt,
+  sizeof(int),
+  XtOffsetOf(AppData,cursorBlinkRate),
+  XtRImmediate,
+  (XtPointer)0,
+ },
+ {
+  XtNtextCursor,
+  XtCTextCursor,
+  XtRString,
+  MAX_PATH,
+  XtOffsetOf(AppData,textCursor),
+  XtRString,
+  (XtPointer)"",
+ },
+#if 0
+ {
+  XtNgeometry,
+  XtCGeometry,
+  XtRGeometry,
+  sizeof(XtWidgetGeometry),
+  XtOffsetOf(AppData,geometry),
+  XtRString,
+  (XtPointer)"80x25",
+ },
+#endif
+};
+XrmOptionDescRec options[PDC_NUMBER_OPTIONS] =
+{
+   {"-lines",               "*lines",             XrmoptionSepArg,   NULL },
+   {"-cols",                "*cols",              XrmoptionSepArg,   NULL },
+   {"-normalFont",          "*normalFont",        XrmoptionSepArg,   NULL },
+   {"-italicFont",          "*italicFont",        XrmoptionSepArg,   NULL },
+   {"-bitmap",              "*bitmap",            XrmoptionSepArg,   NULL },
+#ifdef HAVE_XPM_H
+   {"-pixmap",              "*pixmap",            XrmoptionSepArg,   NULL },
+#endif
+   {"-pointer",             "*pointer",           XrmoptionSepArg,   NULL },
+   {"-shmmin",              "*shmmin",            XrmoptionSepArg,   NULL },
+   {"-composeKey",          "*composeKey",        XrmoptionSepArg,   NULL },
+   {"-clickPeriod",         "*clickPeriod",       XrmoptionSepArg,   NULL },
+   {"-doubleClickPeriod",   "*doubleClickPeriod", XrmoptionSepArg,   NULL },
+   {"-scrollbarWidth",      "*scrollbarWidth",    XrmoptionSepArg,   NULL },
+   {"-pointerForeColor",    "*pointerForeColor",  XrmoptionSepArg,   NULL },
+   {"-pointerBackColor",    "*pointerBackColor",  XrmoptionSepArg,   NULL },
+   {"-cursorBlinkRate",     "*cursorBlinkRate",   XrmoptionSepArg,   NULL },
+   {"-cursorColor",         "*cursorColor",       XrmoptionSepArg,   NULL },
+   {"-textCursor",          "*textCursor",        XrmoptionSepArg,   NULL },
+   {"-colorBlack",          "*colorBlack",        XrmoptionSepArg,   NULL },
+   {"-colorRed",            "*colorRed",          XrmoptionSepArg,   NULL },
+   {"-colorGreen",          "*colorGreen",        XrmoptionSepArg,   NULL },
+   {"-colorYellow",         "*colorYellow",       XrmoptionSepArg,   NULL },
+   {"-colorBlue",           "*colorBlue",         XrmoptionSepArg,   NULL },
+   {"-colorMagenta",        "*colorMagenta",      XrmoptionSepArg,   NULL },
+   {"-colorCyan",           "*colorCyan",         XrmoptionSepArg,   NULL },
+   {"-colorWhite",          "*colorWhite",        XrmoptionSepArg,   NULL },
+   {"-colorBoldBlack",      "*colorBoldBlack",    XrmoptionSepArg,   NULL },
+   {"-colorBoldRed",        "*colorBoldRed",      XrmoptionSepArg,   NULL },
+   {"-colorBoldGreen",      "*colorBoldGreen",    XrmoptionSepArg,   NULL },
+   {"-colorBoldYellow",     "*colorBoldYellow",   XrmoptionSepArg,   NULL },
+   {"-colorBoldBlue",       "*colorBoldBlue",     XrmoptionSepArg,   NULL },
+   {"-colorBoldMagenta",    "*colorBoldMagenta",  XrmoptionSepArg,   NULL },
+   {"-colorBoldCyan",       "*colorBoldCyan",     XrmoptionSepArg,   NULL },
+   {"-colorBoldWhite",      "*colorBoldWhite",    XrmoptionSepArg,   NULL },
+};
+XtActionsRec XCursesActions[PDC_NUMBER_XCURSES_ACTIONS] =
+{
+   {"XCursesButton",                  (XtActionProc)XCursesButton},
+   {"XCursesKeyPress",                (XtActionProc)XCursesKeyPress},
+   {"XCursesModifierPress",           (XtActionProc)XCursesModifierPress},
+   {"XCursesPasteSelection",          (XtActionProc)XCursesPasteSelection},
+   {"string",                         (XtActionProc)XCursesHandleString},
+};
+char global_display_name[100]; /* large enough for DISPLAY=machine */
+Bool after_first_curses_request = False;
+int colors[(2*MAX_COLORS)+2];
+Bool vertical_cursor = False;
+/*
+ * End X11 Variables common to both process and thread ports
+ */
+
+#if NOT_USED
+#define SHM_CURSVAR         0
+#define SHM_CURSCR          1
+#define SHM_CURSCR_Y        2
+#define SHM_CURSCR_YY       3
+#define SHM_CURSCR_FIRSTCH  4
+#define SHM_CURSCR_LASTCH   5
+SCREEN *XSP;
+#endif
+
+
+#ifdef FOREIGN
+ XIM Xim;
+ XIC Xic;
+ long im_event_mask;
+ XIMStyles *im_supported_styles=NULL;
+ XIMStyle my_style=0;
+#endif
+
+
+
+#if 0
+   "<KeyDown>Shift_L,<Key>: XCursesKeyPress() \n" \
+   "<KeyDown>Shift_R,<Key>: XCursesKeyPress() \n" \
+   "<KeyDown>Control_L,<Key>: XCursesKeyPress() \n" \
+   "<KeyDown>Control_R,<Key>: XCursesKeyPress() \n" \
+   "<KeyDown>Alt_L,<Key>: XCursesKeyPress() \n" \
+   "<KeyDown>Alt_R,<Key>: XCursesKeyPress() \n" \
+   "<KeyDown>Shift_L: XCursesModifierPress() \n" \
+   "<KeyDown>Shift_R: XCursesModifierPress() \n" \
+   "<KeyDown>Control_L: XCursesModifierPress() \n" \
+   "<KeyDown>Control_R: XCursesModifierPress() \n" \
+   "<KeyDown>Alt_L: XCursesModifierPress() \n" \
+   "<KeyDown>Alt_R: XCursesModifierPress() \n"
+#endif
+
+XtTranslations XCursesTranslations;
+char *defaultTranslations =
+{
+   "<Key>: XCursesKeyPress() \n" \
+   "<Btn1Down>: XCursesButton() \n" \
+   "!Ctrl <Btn2Down>: XCursesButton() \n" \
+   "!Shift <Btn2Down>: XCursesButton() \n" \
+   "!Ctrl <Btn2Up>: XCursesButton() \n" \
+   "!Shift <Btn2Up>: XCursesButton() \n" \
+   "<Btn1Up>: XCursesButton() \n" \
+   "<Btn2Down>,<Btn2Up>: XCursesPasteSelection() \n" \
+   "<Btn3Up>: XCursesButton() \n" \
+   "<Btn3Down>: XCursesButton() \n" \
+   "<Btn4Up>: XCursesButton() \n" \
+   "<Btn4Down>: XCursesButton() \n" \
+   "<Btn5Up>: XCursesButton() \n" \
+   "<Btn5Down>: XCursesButton() \n" \
+   "<BtnMotion>: XCursesButton()"
+};
+
+
+static int opposite[8]={7,6,5,4,3,2,1,0};
+
+#ifdef USE_THREADS
+pthread_mutex_t key_queue_mutex = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
+int xerror();
+
+#ifdef HAVE_PROTO
+void say(const char *msg)
+#else
+void say(msg)
+char *msg;
+#endif
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:%s",(XCursesProcess)?"     X":"CURSES",msg);
+#endif
+}
+
+#ifdef HAVE_PROTO
+void dummy_function( void )
+#else
+void dummy_function()
+#endif
+{
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+signal_handler XCursesSetSignal(int signo,signal_handler action)
+#else
+signal_handler XCursesSetSignal(signo,action)
+int signo;
+signal_handler action;
+#endif
+/***********************************************************************/
+{
+#if defined(SA_INTERRUPT) || defined(SA_RESTART)
+   struct sigaction sigact,osigact;
+
+   sigact.sa_handler = action;
+# ifdef SA_INTERRUPT
+#  ifdef SA_RESTART
+   sigact.sa_flags = SA_INTERRUPT | SA_RESTART;
+#  else
+   sigact.sa_flags = SA_INTERRUPT;
+#  endif
+# else /* must be SA_RESTART */
+   sigact.sa_flags = SA_RESTART;
+# endif
+   sigemptyset(&sigact.sa_mask);
+   if (sigaction(signo,&sigact,&osigact) != 0)
+      return(SIG_ERR);
+   return(osigact.sa_handler);
+#else /* not SA_INTERRUPT or SA_RESTART, use plain signal */
+   return(signal(signo,action));
+#endif
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+RETSIGTYPE XCursesSigwinchHandler(int signo)
+#else
+RETSIGTYPE XCursesSigwinchHandler(signo)
+int signo;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesSigwinchHandler() - called: SIGNO: %d\n",(XCursesProcess)?"     X":"CURSES",signo);
+#endif
+#ifdef BEFORE_CHANGE_BY_G_FUCHS
+   /*
+    * Patch by:
+    * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+    */
+   SP->resized=TRUE;
+#else
+   SP->resized += 1;
+#endif
+/*---------------------------------------------------------------------*/
+/* Always trap SIGWINCH if the C library supports SIGWINCH...          */
+/*---------------------------------------------------------------------*/
+#ifdef SIGWINCH
+   XCursesSetSignal(SIGWINCH, XCursesSigwinchHandler );
+#endif
+}
+/***********************************************************************/
+/* NOT USED */
+#ifdef HAVE_PROTO
+int XCurses_redraw_curscr(void)
+#else
+int XCurses_redraw_curscr()
+#endif
+/***********************************************************************/
+{
+ int i;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:XCurses_redraw_curscr() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+ for (i=0;i<curscr->_maxy;i++)
+    XCurses_transform_line(curscr->_y[i],i,0,curscr->_maxx);
+ return(OK);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesDisplayText(chtype *ch, int row, int x, int num_cols, bool highlight)
+#else
+int XCursesDisplayText(ch, row, x, num_cols, highlight)
+chtype *ch;
+int row,x,num_cols;
+bool highlight;
+#endif
+/***********************************************************************/
+{
+   char text[300];
+   bool new_packet=FALSE;
+   short fore,back;
+   int original_x,pair_num,i,j,k,asc=XCursesFontAscent,desc=XCursesFontDescent;  /* 11 and 1 */
+   chtype old_attr,save_ch,attr;
+   int xpos,ypos;
+   int fore_offset=0, back_offset=0;
+   GC gc;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesDisplayText() - called: Row: %d X: %d NumCols: %d\n",(XCursesProcess)?"     X":"CURSES", row,x,num_cols);
+#endif
+   if (num_cols == 0)
+      return(OK);
+
+#if 0
+ fprintf(stderr,"%2.2d ",x);
+   for (idx=0;idx<num_cols;idx++)
+   {
+    save_ch = *(ch+idx);
+    attr =  save_ch & A_CHARTEXT;
+    old_attr = save_ch & A_ATTRIBUTES;
+    fprintf(stderr,"<%c> %8.8x ",attr,old_attr);
+   }
+ fprintf(stderr,"\n");
+#endif
+
+   old_attr = *ch & A_ATTRIBUTES;
+   save_ch = *ch;
+   original_x = x;
+   for (i=0,j=0; j<num_cols; x++,j++)
+   {
+      attr = *(ch+j) & A_ATTRIBUTES;
+      if (attr != old_attr)
+         new_packet = TRUE;
+      if (new_packet)
+      {
+         if ((pair_num = PAIR_NUMBER(save_ch)) != 0)
+         {
+            if (pair_content(pair_num,&fore,&back) == ERR)
+               return(ERR);
+         }
+         else
+         {
+            fore = COLOR_WHITE;
+            back = COLOR_BLACK;
+         }
+         text[i] = '\0';
+         /*
+          * Specify the colour table offsets
+          */
+         if ( old_attr & A_BOLD )
+            fore_offset = 8;
+         else
+            fore_offset = 0;
+         if ( old_attr & A_BLINK )
+            back_offset = 8;
+         else
+            back_offset = 0;
+         /*
+          * Determine which GC to use - normal or italic
+          */
+         if ( old_attr & A_ITALIC )
+            gc = italic_gc;
+         else
+            gc = normal_gc;
+
+         if ( !!(old_attr & A_REVERSE) ^ highlight )
+         {
+            XSetForeground(XCURSESDISPLAY, gc, colors[back+back_offset]);
+            XSetBackground(XCURSESDISPLAY, gc, colors[fore+fore_offset]);
+         }
+         else
+         {
+            XSetForeground(XCURSESDISPLAY, gc, colors[fore+fore_offset]);
+            XSetBackground(XCURSESDISPLAY, gc, colors[back+back_offset]);
+         }
+
+         makeXY(original_x,row,XCursesFontWidth,XCursesFontHeight,&xpos,&ypos);
+         XDrawImageString(XCURSESDISPLAY,XCURSESWIN,gc,xpos,ypos,text,i);
+
+         for (k=0;k<i;k++)
+         {
+            if ( old_attr & A_LEFTLINE ) /* LEFT */
+            {
+               XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+               XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos+(XCursesFontWidth*(k))-1,ypos-asc,xpos+(XCursesFontWidth*(k))-1,ypos+desc);
+            }
+            if ( old_attr & A_RIGHTLINE ) /* RIGHT */
+            {
+               XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+               XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos+(XCursesFontWidth*(k+1))-1,ypos-asc,xpos+(XCursesFontWidth*(k+1))-1,ypos+desc);
+            }
+         }
+#if 0
+         if ( old_attr & A_OVERLINE ) /* ABOVE */
+         {
+            XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+            XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos,ypos-asc,xpos+(XCursesFontWidth*i),ypos-asc);
+         }
+#endif
+         if (old_attr & A_UNDERLINE)  /* UNDER */
+         {
+            XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+            XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos,ypos+1,xpos+(XCursesFontWidth*i),ypos+1);
+         }
+
+#ifdef PDCDEBUG
+         if (trace_on)
+            PDC_debug("%s:XCursesDisplayText() - row: %d col: %d num_cols: %d fore: %d back: %d text:<%s>\n",(XCursesProcess)?"     X":"CURSES",row,original_x,i,fore,back,text);
+#endif
+
+         new_packet = FALSE;
+         old_attr = attr;
+         original_x = x;
+         i = 0;
+      }
+      text[i++] = *(ch+j) & A_CHARTEXT;
+      save_ch = *(ch+j);
+   }
+
+   if ((pair_num = PAIR_NUMBER(save_ch)) != 0)
+   {
+      if (pair_content(pair_num,&fore,&back) == ERR)
+         return(ERR);
+   }
+   else
+   {
+      fore = COLOR_WHITE;
+      back = COLOR_BLACK;
+   }
+   /*
+    * Specify the colour table offsets
+    */
+   text[i] = '\0';
+   if ( old_attr & A_BOLD )
+      fore_offset = 8;
+   else
+      fore_offset = 0;
+   if ( old_attr & A_BLINK )
+      back_offset = 8;
+   else
+      back_offset = 0;
+   /*
+    * Determine which GC to use - normal or italic
+    */
+   if ( old_attr & A_ITALIC )
+      gc = italic_gc;
+   else
+      gc = normal_gc;
+
+   if ( !!(old_attr & A_REVERSE) ^ highlight )
+   {
+      XSetForeground(XCURSESDISPLAY, gc, colors[back+back_offset]);
+      XSetBackground(XCURSESDISPLAY, gc, colors[fore+fore_offset]);
+   }
+   else
+   {
+      XSetForeground(XCURSESDISPLAY, gc, colors[fore+fore_offset]);
+      XSetBackground(XCURSESDISPLAY, gc, colors[back+back_offset]);
+   }
+
+   makeXY(original_x,row,XCursesFontWidth,XCursesFontHeight,&xpos,&ypos);
+   XDrawImageString(XCURSESDISPLAY,XCURSESWIN,gc,xpos,ypos,text,i);
+
+   for (k=0;k<i;k++)
+   {
+      if ( old_attr & A_LEFTLINE ) /* LEFT */
+      {
+         XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+         XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos+(XCursesFontWidth*(k))-1,ypos-asc,xpos+(XCursesFontWidth*(k))-1,ypos+desc);
+      }
+      if ( old_attr & A_RIGHTLINE ) /* RIGHT */
+      {
+         XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+         XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos+(XCursesFontWidth*(k+1))-1,ypos-asc,xpos+(XCursesFontWidth*(k+1))-1,ypos+desc);
+      }
+    }
+#if 0
+   if ( old_attr & A_OVERLINE ) /* ABOVE */
+   {
+      XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+      XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos,ypos-asc,xpos+(XCursesFontWidth*i),ypos-asc);
+   }
+#endif
+   if (old_attr & A_UNDERLINE)  /* UNDER */
+   {
+      XSetForeground(XCURSESDISPLAY, gc, colors[(SP->line_color)]);
+      XDrawLine(XCURSESDISPLAY,XCURSESWIN,gc,xpos,ypos+1,xpos+(XCursesFontWidth*i),ypos+1);
+   }
+
+#ifdef PDCDEBUG
+   if (trace_on)
+      PDC_debug("%s:XCursesDisplayText() (end) row: %d col: %d num_cols: %d fore: %d back: %d text:<%s>\n",(XCursesProcess)?"     X":"CURSES",row,original_x,i,fore,back,text);
+#endif
+
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void get_GC(Display *display, Window win, GC *gc, XFontStruct *font_info, int fore, int back,bool highlight)
+#else
+void get_GC(display,win, gc, font_info,fore,back,highlight)
+Display *display;
+Window win;
+GC *gc;
+XFontStruct *font_info;
+int fore,back;
+bool highlight;
+#endif
+/***********************************************************************/
+{
+ XGCValues values;
+
+        /* Create default Graphics Context */
+ *gc = XCreateGC(display,win, 0L, &values);
+
+        /* specify font */
+ XSetFont(display, *gc, font_info->fid);
+
+        /* specify black foreground since default may be white on white */
+ XSetForeground(display, *gc, colors[fore]);
+ XSetBackground(display, *gc, colors[back]);
+ if (highlight)
+    XSetFunction(display, *gc, GXxor);
+ return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void makeXY(int x,int y,int fontwidth,int fontheight,int *xpos,int *ypos)
+#else
+void makeXY(x,y,fontwidth,fontheight,xpos,ypos)
+int x,y,fontwidth,fontheight,*xpos,*ypos;
+#endif
+/***********************************************************************/
+{
+ *xpos = (x * fontwidth)+XCURSESBORDERWIDTH;
+ *ypos = XCURSESNORMALFONTINFO->ascent + (y * fontheight) + XCURSESBORDERWIDTH;
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int get_colors(void)
+#else
+int get_colors()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+ say("in get_colors\n");
+#endif
+
+ colors[0]  = app_data.colorBlack;
+ colors[1]  = app_data.colorRed;
+ colors[2]  = app_data.colorGreen;
+ colors[3]  = app_data.colorYellow;
+ colors[4]  = app_data.colorBlue;
+ colors[5]  = app_data.colorMagenta;
+ colors[6]  = app_data.colorCyan;
+ colors[7]  = app_data.colorWhite;
+ colors[8]  = app_data.colorBoldBlack;
+ colors[9]  = app_data.colorBoldRed;
+ colors[10] = app_data.colorBoldGreen;
+ colors[11] = app_data.colorBoldYellow;
+ colors[12] = app_data.colorBoldBlue;
+ colors[13] = app_data.colorBoldMagenta;
+ colors[14] = app_data.colorBoldCyan;
+ colors[15] = app_data.colorBoldWhite;
+ colors[COLOR_CURSOR] = XCURSESCURSORCOLOR;
+ colors[COLOR_BORDER] = XCURSESBORDERCOLOR;
+#ifdef PDCDEBUG
+ say("out of get_colors\n");
+#endif
+ return(OK);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesEndwin(void)
+#else
+int XCursesEndwin()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesEndwin() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   if (bitmap_file != NULL)
+   {
+      XFreePixmap(XCURSESDISPLAY,icon_bitmap);
+      free(bitmap_file);
+   }
+#ifdef HAVE_XPM_H
+   if (pixmap_file != NULL)
+   {
+      XFreePixmap(XCURSESDISPLAY,icon_pixmap);
+      XFreePixmap(XCURSESDISPLAY,icon_pixmap_mask);
+      free(pixmap_file);
+   }
+#endif
+   XFreeGC(XCURSESDISPLAY, normal_gc);
+   XFreeGC(XCURSESDISPLAY, italic_gc);
+   XFreeGC(XCURSESDISPLAY, block_cursor_gc);
+   XFreeGC(XCURSESDISPLAY, rect_cursor_gc);
+   XFreeGC(XCURSESDISPLAY, border_gc);
+#ifdef FOREIGN
+   XDestroyIC(Xic);
+#endif
+#if 0
+   XCloseDisplay(XCURSESDISPLAY);
+#endif
+   return(0);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesRefreshScrollbar(void)
+#else
+int XCursesRefreshScrollbar()
+#endif
+/***********************************************************************/
+{
+   PDC_SCROLLBAR_TYPE total_y=(PDC_SCROLLBAR_TYPE)(SP->sb_total_y*XCursesFontHeight);
+   PDC_SCROLLBAR_TYPE viewport_y=(PDC_SCROLLBAR_TYPE)(SP->sb_viewport_y*XCursesFontHeight);
+   PDC_SCROLLBAR_TYPE cur_y=(PDC_SCROLLBAR_TYPE)(SP->sb_cur_y*XCursesFontHeight);
+   PDC_SCROLLBAR_TYPE total_x=(PDC_SCROLLBAR_TYPE)(SP->sb_total_x*XCursesFontWidth);
+   PDC_SCROLLBAR_TYPE viewport_x=(PDC_SCROLLBAR_TYPE)(SP->sb_viewport_x*XCursesFontWidth);
+   PDC_SCROLLBAR_TYPE cur_x=(PDC_SCROLLBAR_TYPE)(SP->sb_cur_x*XCursesFontWidth);
+   PDC_SCROLLBAR_TYPE vtop=(PDC_SCROLLBAR_TYPE)(cur_y/total_y);
+   PDC_SCROLLBAR_TYPE vlength=(PDC_SCROLLBAR_TYPE)(viewport_y/total_y);
+   PDC_SCROLLBAR_TYPE htop=(PDC_SCROLLBAR_TYPE)(cur_x/total_x);
+   PDC_SCROLLBAR_TYPE hlength=(PDC_SCROLLBAR_TYPE)(viewport_x/total_x);
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesRefreshScrollbar() - called: \n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   if (!SP->sb_on)
+      return(ERR);
+#if 0
+fprintf(stderr,"%s:XCursesRefreshScrollbar() - vert: %d %f %f %f %f %f\n",(XCursesProcess)?"     X":"CURSES",
+                        SP->sb_total_y,total_y,viewport_y,cur_y,
+                        vtop,vlength);
+fprintf(stderr,"%s:XCursesRefreshScrollbar() - horz: %d %f %f %f %f %f\n",(XCursesProcess)?"     X":"CURSES",
+                        SP->sb_total_x,total_x,viewport_x,cur_x,
+                        htop,hlength);
+#endif
+   if (SP->sb_total_y != (PDC_SCROLLBAR_TYPE)0)
+      XawScrollbarSetThumb( scrollVert, (PDC_SCROLLBAR_TYPE)vtop, (PDC_SCROLLBAR_TYPE)vlength );
+   if (SP->sb_total_x != (PDC_SCROLLBAR_TYPE)0)
+      XawScrollbarSetThumb( scrollHoriz, (PDC_SCROLLBAR_TYPE)htop, (PDC_SCROLLBAR_TYPE)hlength );
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void SetCursorColor(chtype *ch,short *fore, short *back)
+#else
+void SetCursorColor(ch,fore,back)
+chtype *ch;
+short *fore;
+short *back;
+#endif
+/***********************************************************************/
+{
+ chtype attr=0;
+ short f=0,b=0;
+
+ attr = (chtype)((*ch & A_COLOR)>>24);
+ if (attr)
+   {
+    pair_content(attr,&f,&b);
+    *fore = opposite[f];
+    *back = opposite[b];
+   }
+ else
+   {
+    if (*ch & A_REVERSE)
+      {
+       *back = COLOR_BLACK;
+       *fore = COLOR_WHITE;
+      }
+    else
+      {
+       *back = COLOR_WHITE;
+       *fore = COLOR_BLACK;
+      }
+   }
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesGetIcon(void)
+#else
+void XCursesGetIcon()
+#endif
+/***********************************************************************/
+{
+   XIconSize *icon_size;
+   int size_count=0;
+   Status rc=0;
+   unsigned char *bitmap_bits=NULL;
+   unsigned int icon_bitmap_width=0,icon_bitmap_height=0;
+   unsigned int file_bitmap_width=0,file_bitmap_height=0;
+   int max_height=0,max_width=0;
+   int x_hot=0,y_hot=0;
+   int i;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesGetIcon\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   icon_size = XAllocIconSize();
+   rc = XGetIconSizes(XtDisplay(topLevel),
+                    RootWindowOfScreen(XtScreen(topLevel)),
+                    &icon_size,
+                    &size_count);
+   if (rc  /* if the WM can advise on icon sizes... */
+   &&  size_count)
+   {
+#ifdef PDCDEBUG
+      if (trace_on) PDC_debug("%s:size_count: %d rc: %d\n",(XCursesProcess)?"     X":"CURSES",size_count,rc);
+#endif
+      for (i=0;i<size_count;i++)
+      {
+         if (icon_size[i].max_width > max_width)
+            max_width = icon_size[i].max_width;
+         if (icon_size[i].max_height > max_height)
+            max_height = icon_size[i].max_height;
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("%s:min: %d %d\n",(XCursesProcess)?"     X":"CURSES",icon_size[i].min_width,icon_size[i].min_height);
+         if (trace_on) PDC_debug("%s:max: %d %d\n",(XCursesProcess)?"     X":"CURSES",icon_size[i].max_width,icon_size[i].max_height);
+         if (trace_on) PDC_debug("%s:inc: %d %d\n",(XCursesProcess)?"     X":"CURSES",icon_size[i].width_inc,icon_size[i].height_inc);
+#endif
+      }
+      if (max_width >= BIG_ICON_WIDTH
+      &&  max_height >= BIG_ICON_HEIGHT)
+      {
+         icon_bitmap_width = BIG_ICON_WIDTH;
+         icon_bitmap_height = BIG_ICON_HEIGHT;
+         bitmap_bits = (unsigned char *)big_icon_bitmap_bits;
+      }
+      else
+      {
+         icon_bitmap_width = LITTLE_ICON_WIDTH;
+         icon_bitmap_height = LITTLE_ICON_HEIGHT;
+         bitmap_bits = (unsigned char *)little_icon_bitmap_bits;
+      }
+   }
+   else  /* WM won't tell us what icon size to use, so use small icon :-( */
+   {
+      icon_bitmap_width = LITTLE_ICON_WIDTH;
+      icon_bitmap_height = LITTLE_ICON_HEIGHT;
+      bitmap_bits = (unsigned char *)little_icon_bitmap_bits;
+   }
+   XFree((char *)icon_size);
+
+#ifdef HAVE_XPM_H
+   if (strcmp(XCURSESPIXMAPFILE,"") != 0) /* supplied pixmap */
+   {
+      rc = XpmReadFileToPixmap( XtDisplay(topLevel),
+                                RootWindowOfScreen(XtScreen(topLevel)),
+                                (char *)XCURSESPIXMAPFILE,
+                                &icon_pixmap,
+                                &icon_pixmap_mask,
+                                NULL );
+      return;
+   }
+#endif
+   if (strcmp(XCURSESBITMAPFILE,"") != 0) /* supplied bitmap */
+   {
+      rc = XReadBitmapFile(XtDisplay(topLevel),
+                         RootWindowOfScreen(XtScreen(topLevel)),
+                         (char *)XCURSESBITMAPFILE,
+                         &file_bitmap_width,
+                         &file_bitmap_height,
+                         &icon_bitmap,
+                         &x_hot,
+                         &y_hot);
+      switch(rc)
+      {
+         case BitmapOpenFailed:
+            fprintf(stderr,"bitmap file %s: not found\n",XCURSESBITMAPFILE);
+            break;
+         case BitmapFileInvalid:
+            fprintf(stderr,"bitmap file %s: contents invalid\n",XCURSESBITMAPFILE);
+            break;
+         default:
+            return;
+            break;
+      }
+   }
+   icon_bitmap = XCreateBitmapFromData(XtDisplay(topLevel),
+                                     RootWindowOfScreen(XtScreen(topLevel)),
+                                     (char *)bitmap_bits,
+                                     icon_bitmap_width,
+                                     icon_bitmap_height);
+   return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesExpose(Widget w,XtPointer client_data,XEvent *event,Boolean *continue_to_dispatch)
+#else
+void XCursesExpose(w,client_data,event,continue_to_dispatch)
+Widget w;
+XtPointer client_data;
+XEvent *event;
+Boolean *continue_to_dispatch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:XCursesExpose called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+#if 0
+/* get all other Expose events on the queue */
+  while (XCheckTypedEvent(display, Expose, &event))
+#endif
+ if (event->xexpose.count != 0) /* ignore all Exposes except last */
+    return;
+
+#if 0
+ XCursesDisplayScreen(FALSE);
+/*
+ * Can we here determine largest rectangle to refresh based on all outstanding
+ * expose events?
+ */
+/*
+ * should refresh that portion of the screen now exposed - in XCursesProcess
+ * using event.x, event.y, event.width, event.height to determine row/col
+ * to refresh. Call XCursesDisplayText() to do the refresh.
+ */
+ if (after_first_curses_request
+ &&  after_first_expose_event)
+   {
+    XCursesRefreshScreen();
+    XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                        SP->cursrow,SP->curscol);
+   }
+ after_first_expose_event = True;
+#else
+ if (after_first_curses_request
+ &&  ReceivedMapNotify)
+     XCursesDisplayScreen(FALSE);
+#endif
+ return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesNonmaskable(Widget w,XtPointer client_data,XEvent *event,Boolean *continue_to_dispatch)
+#else
+void XCursesNonmaskable(w,client_data,event,continue_to_dispatch)
+Widget w;
+XtPointer client_data;
+XEvent *event;
+Boolean *continue_to_dispatch;
+#endif
+/***********************************************************************/
+{
+ XClientMessageEvent *client_event=(XClientMessageEvent *)event;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:XCursesNonmaskable called: otherpid %d\n",(XCursesProcess)?"     X":"CURSES",otherpid);
+#endif
+ switch(event->type)
+   {
+    case ClientMessage:
+#ifdef PDCDEBUG
+         say("ClientMessage received\n");
+#endif
+         /*
+          * This code used to include handling of WM_SAVE_YOURSELF, but
+          * it resulted in continual failure of THE on my Toshiba laptop.
+          * Removed on 3-3-2001. Now only exits on WM_DELETE_WINDOW
+          */
+         if ( (Atom)client_event->data.s[0] == wm_atom[0] )
+            XCursesExitXCursesProcess(0,SIGKILL,"");
+         break;
+    default:
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("%s:XCursesNonmaskable - unknown event %d\n",(XCursesProcess)?"     X":"CURSES",event->type);
+#endif
+         break;
+   }
+ return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesModifierPress(Widget w,XEvent *event, String *params, Cardinal *nparams)
+#else
+void XCursesModifierPress(w,event,params,nparams)
+Widget w;
+XEvent *event;
+String *params;
+Cardinal *nparams;
+#endif
+/***********************************************************************/
+{
+#define STATE_NORMAL   0
+#define STATE_COMPOSE  1
+#define STATE_CHAR     2
+#ifdef FOREIGN
+   wchar_t buffer[120];
+#else
+   char buffer[120];
+#endif
+   int buflen=40;
+   int count,key;
+   KeySym keysym;
+   XComposeStatus compose;
+#ifdef FOREIGN
+   Status status;
+#endif
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesModifierPress called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   buffer[0] = '\0';
+   count = XLookupString(&(event->xkey),buffer,buflen,&keysym, &compose);
+   /*
+    * Handle modifier keys first.
+    */
+
+   SP->return_key_modifiers = True;
+
+#ifdef PDCDEBUG
+   printf("%d: %ld %s %d %d %d\n",__LINE__,keysym,
+      (event->type == KeyPress) ? "Press" : "Release",
+      (keysym != compose_key),
+      (IsModifierKey(keysym)),
+      (SP->return_key_modifiers));
+#endif
+
+   if (SP->return_key_modifiers)
+   {
+      key = 0;
+      if (keysym == XK_Shift_L) { key = KEY_SHIFT_L; }
+      else if (keysym == XK_Shift_R) { key = KEY_SHIFT_R; }
+      else if (keysym == XK_Control_L) { key = KEY_CONTROL_L; }
+      else if (keysym == XK_Control_R) { key = KEY_CONTROL_R; }
+      else if (keysym == XK_Alt_L) { key = KEY_ALT_L; }
+      else if (keysym == XK_Alt_R) { key = KEY_ALT_R; }
+      if (key)
+         XCursesSendKeyToCurses( (unsigned long)key, NULL );
+      return;
+   }
+   return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesKeyPress(Widget w,XEvent *event, String *params, Cardinal *nparams)
+#else
+void XCursesKeyPress(w,event,params,nparams)
+Widget w;
+XEvent *event;
+String *params;
+Cardinal *nparams;
+#endif
+/***********************************************************************/
+{
+#define STATE_NORMAL   0
+#define STATE_COMPOSE  1
+#define STATE_CHAR     2
+#ifdef FOREIGN
+ wchar_t buffer[120];
+#else
+ char buffer[120];
+#endif
+ int buflen=40;
+ int count,key,i;
+ KeySym keysym;
+ XComposeStatus compose;
+ static int compose_state=STATE_NORMAL;
+ static int compose_index=0;
+ int save_visibility=0;
+ int char_idx=0;
+ int xpos,ypos;
+#ifdef FOREIGN
+ Status status;
+#endif
+ chtype *ch;
+ short fore=0,back=0;
+ unsigned long modifier=0;
+
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:XCursesKeyPress called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+ if (event->type == KeyRelease)
+    return; /* ignore KeyReleases */
+
+ buffer[0] = '\0';
+#ifdef FOREIGN
+ count = XwcLookupString(Xic,&(event->xkey),buffer,buflen,&keysym, &status);
+ switch(status)
+   {
+    case XLookupNone:
+         fprintf(stderr,"XLookupNone status\n");
+         break;
+    case XLookupKeySym:
+         fprintf(stderr,"XLookupKeySym status\n");
+         break;
+    case XLookupBoth:
+         fprintf(stderr,"XLookupBoth status\n");
+         break;
+    case XLookupChars:
+         fprintf(stderr,"XLookupChars status\n");
+         break;
+   }
+#else
+ count = XLookupString(&(event->xkey),buffer,buflen,&keysym, &compose);
+#endif
+ /*
+  * Handle modifier keys first.
+  */
+
+#if 0
+printf("Keypress\n");
+SP->return_key_modifiers = True;
+
+printf("%d: %ld %d %d %d %d\n",__LINE__,keysym,
+ (event->type == KeyPress),
+ (keysym != compose_key),
+ (IsModifierKey(keysym)),
+ (SP->return_key_modifiers));
+
+ if (event->type == KeyPress
+ &&  keysym != compose_key
+ &&  IsModifierKey(keysym)
+ &&  SP->return_key_modifiers)
+ {
+    save_keysym = keysym;
+    return;
+ }
+
+printf("%d: %ld %d %d %d %d %d\n",__LINE__,keysym,
+ (event->type == KeyRelease),
+ (keysym != compose_key),
+ (IsModifierKey(keysym)),
+ (SP->return_key_modifiers),
+ (keysym == save_keysym)
+ );
+#endif
+
+ if (event->type == KeyPress
+ &&  keysym != compose_key
+ &&  IsModifierKey(keysym)
+ &&  SP->return_key_modifiers)
+ {
+    key = 0;
+    if (keysym == XK_Shift_L) { key = KEY_SHIFT_L; }
+    else if (keysym == XK_Shift_R) { key = KEY_SHIFT_R; }
+    else if (keysym == XK_Control_L) { key = KEY_CONTROL_L; }
+    else if (keysym == XK_Control_R) { key = KEY_CONTROL_R; }
+    else if (keysym == XK_Alt_L) { key = KEY_ALT_L; }
+    else if (keysym == XK_Alt_R) { key = KEY_ALT_R; }
+    if (key)
+       XCursesSendKeyToCurses( (unsigned long)key, NULL );
+    return;
+ }
+
+/* translate keysym into curses key code */
+#ifdef PDCDEBUG
+ PDC_debug("%s:Key mask: %x\n",(XCursesProcess)?"     X":"CURSES",event->xkey.state);
+ key = 0;
+ for (key=0;key<4;key++)
+   PDC_debug("%s:Keysym %x %d\n",(XCursesProcess)?"     X":"CURSES",XKeycodeToKeysym(XCURSESDISPLAY,event->xkey.keycode,key),key);
+#endif
+
+/* fprintf(stderr,"KEY: %d %s\n",keysym,XKeysymToString(keysym));*/
+ key = 0;
+ /*
+  * Check if the key just pressed is the user-specified compose key
+  * If it is, set the compose state and exit.
+  */
+ if (keysym == compose_key)
+   {
+/*    fprintf(stderr,"Compose key pressed\n");*/
+    /*
+     * Change the shape of the cursor to an outline rectangle
+     * to indicate we are in "compose" status
+     */
+    save_visibility = SP->visibility;
+    SP->visibility = 0;
+    XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                         SP->cursrow,SP->curscol);
+    SP->visibility = save_visibility;;
+    makeXY(SP->curscol,SP->cursrow,XCursesFontWidth,XCursesFontHeight,&xpos,&ypos);
+    ch = (chtype *)(Xcurscr+XCURSCR_Y_OFF(SP->cursrow)+((SP->curscol)*sizeof(chtype)));
+    SetCursorColor(ch,&fore,&back);
+    XSetForeground(XCURSESDISPLAY, rect_cursor_gc, colors[back]);
+    XDrawRectangle(XCURSESDISPLAY,XCURSESWIN,rect_cursor_gc,(xpos+1),(ypos-XCursesFontHeight+(XCURSESNORMALFONTINFO->descent)+1),(XCursesFontWidth-2),(XCursesFontHeight-2));
+/*    fprintf(stderr,"Descent:%d Ascent:%d\n",XCURSESNORMALFONTINFO->descent,XCURSESNORMALFONTINFO->ascent);*/
+    compose_state = STATE_COMPOSE;
+    return;
+   }
+#if 0
+ /*
+  * If the key just pressed is just a modifier, ignore it.
+  */
+ if (IsModifierKey(keysym))
+ {
+    return;
+ }
+#endif
+ switch(compose_state)
+   {
+    case STATE_COMPOSE:
+         if (event->xkey.state & compose_mask)
+           {
+/* fprintf(stderr,"STATE_COMPOSE: char has compose_mask\n");*/
+            compose_state = STATE_NORMAL;
+            XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                                 SP->cursrow,SP->curscol);
+            break;
+           }
+         if (buffer[0] != 0
+         && count == 1)
+             key = (int)buffer[0];
+/*         fprintf(stderr,"STATE_COMPOSE: state %x %x\n",event->xkey.state,compose_mask);*/
+         compose_index = (-1);
+         for (i=0;i<(int)strlen(compose_chars);i++)
+           {
+            if ((int)compose_chars[i] == key)
+              {
+               compose_index = i;
+               break;
+              }
+           }
+/*         fprintf(stderr,"STATE_COMPOSE: %d - compose_index\n",compose_index);*/
+         if (compose_index == (-1))
+           {
+            compose_state = STATE_NORMAL;
+            compose_index = 0;
+            XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                                 SP->cursrow,SP->curscol);
+            break;
+           }
+         compose_state = STATE_CHAR;
+         return;
+         break;
+    case STATE_CHAR:
+         if (event->xkey.state & compose_mask)
+           {
+/* fprintf(stderr,"STATE_COMPOSE: char has compose_state\n");*/
+            compose_state = STATE_NORMAL;
+            XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                                 SP->cursrow,SP->curscol);
+            break;
+           }
+         if (buffer[0] != 0
+         && count == 1)
+             key = (int)buffer[0];
+         char_idx = (-1);
+/*         fprintf(stderr,"STATE_CHAR: %d - compose_index\n",compose_index);*/
+         for (i=0;i<MAX_COMPOSE_CHARS;i++)
+           {
+            if (compose_lookups[compose_index][i] == key)
+              {
+               char_idx = i;
+               break;
+              }
+           }
+  /*       fprintf(stderr,"STATE_CHAR: compose_index: %d char_idx: %d\n",compose_index,char_idx);*/
+         if (char_idx == (-1))
+           {
+            compose_state = STATE_NORMAL;
+            compose_index = 0;
+            XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                                 SP->cursrow,SP->curscol);
+            break;
+           }
+/*         fprintf(stderr,"STATE_CHAR: %d %c - key\n",compose_keys[compose_index][char_idx],compose_keys[compose_index][char_idx]);*/
+         XCursesSendKeyToCurses( (unsigned long)compose_keys[compose_index][char_idx], NULL );
+         compose_state = STATE_NORMAL;
+         compose_index = 0;
+         XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                              SP->cursrow,SP->curscol);
+         return;
+         break;
+    default:
+         break;
+   }
+ /*
+  * To get here we are procesing "normal" keys
+  */
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("%s:Keysym %x %d\n",(XCursesProcess)?"     X":"CURSES",XKeycodeToKeysym(XCURSESDISPLAY,event->xkey.keycode,key),key);
+#endif
+ if (SP->save_key_modifiers)
+ {
+    if (event->xkey.state & Mod2Mask)  /* 0x10: usually, numlock modifier */
+    {
+       modifier |= PDC_KEY_MODIFIER_NUMLOCK;
+    }
+    if (event->xkey.state & ShiftMask)  /* 0x01: shift modifier */
+    {
+       modifier |= PDC_KEY_MODIFIER_SHIFT;
+    }
+    if (event->xkey.state & ControlMask)  /* 0x04: control modifier */
+    {
+       modifier |= PDC_KEY_MODIFIER_CONTROL;
+    }
+    if (event->xkey.state & Mod1Mask)  /* 0x08: usually, alt modifier */
+    {
+       modifier |= PDC_KEY_MODIFIER_ALT;
+    }
+ }
+ for (i=0;XCursesKeys[i].keycode != 0;i++)
+   {
+    if (XCursesKeys[i].keycode == keysym)
+      {
+#ifdef PDCDEBUG
+       if (trace_on) PDC_debug("%s:State %x\n",(XCursesProcess)?"     X":"CURSES",event->xkey.state);
+#endif
+       if (XCursesKeys[i].numkeypad)
+         {
+          if (event->xkey.state & Mod2Mask  /* 0x10: usually, numlock modifier */
+          ||  event->xkey.state & ShiftMask) /* or 0x01: shift modifier */
+            {
+             key = XCursesKeys[i].shifted;
+             break;
+            }
+         }
+       if (event->xkey.state & ShiftMask)  /* 0x01: shift modifier */
+         {
+          key = XCursesKeys[i].shifted;
+          break;
+         }
+       if (event->xkey.state & ControlMask)  /* 0x04: control modifier */
+         {
+          key = XCursesKeys[i].control;
+          break;
+         }
+       if (event->xkey.state & Mod1Mask)  /* 0x08: usually, alt modifier */
+         {
+          key = XCursesKeys[i].alt;
+          break;
+         }
+/*---------------------------------------------------------------------*/
+/* To get here, we ignore all other modifiers.                         */
+/*---------------------------------------------------------------------*/
+       key = XCursesKeys[i].normal;
+       break;
+      }
+   }
+ if (key == 0
+ && buffer[0] != 0
+ && count == 1)
+    key = (int)buffer[0];
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("%s:Key: %s pressed - %x Mod: %x\n",(XCursesProcess)?"     X":"CURSES",XKeysymToString(keysym),key,event->xkey.state);
+#endif
+/*---------------------------------------------------------------------*/
+/* Handle ALT letters and numbers...                                   */
+/*---------------------------------------------------------------------*/
+ if (event->xkey.state == Mod1Mask)
+   {
+    if (key >= (int)'A'
+    &&  key <= (int)'Z')
+       key = ALT_A + (key - (int)('A'));
+    if (key >= (int)'a'
+    &&  key <= (int)'z')
+       key = ALT_A + (key - (int)('a'));
+    if (key >= (int)'0'
+    &&  key <= (int)'9')
+       key = ALT_0 + (key - (int)('0'));
+   }
+/*---------------------------------------------------------------------*/
+/* After all that, send the key back to the application if is NOT zero.*/
+/*---------------------------------------------------------------------*/
+ if (key)
+ {
+    key = key | modifier << 24; /* (sizeof(unsigned long) - sizeof(unsigned char)); */
+    XCursesSendKeyToCurses( (unsigned long)key, NULL );
+ }
+ return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesHandleString(Widget w, XEvent *event, String *params, Cardinal *nparams)
+#else
+void XCursesHandleString(w, event, params, nparams)
+Widget w;
+XEvent *event;
+String *params;
+Cardinal *nparams;
+#endif
+/***********************************************************************/
+{
+   register int i=0;
+   unsigned char *ptr=NULL;
+
+   if (*nparams != 1)
+      return;
+
+   if ((*params)[0] == '0'
+   && (*params)[1] == 'x'
+   && (*params)[2] != '\0')
+   {
+      unsigned char c;
+      int total=0;
+      char *p;
+      for (p = *params+2; (c = *p); p++)
+      {
+         total *= 16;
+         if (isupper(c)) c = tolower(c);
+         if (c >= '0' && c <= '9')
+            total += c - '0';
+         else
+         {
+            if (c >= 'a' && c <= 'f')
+               total += c - 'a' + 10;
+            else
+               break;
+         }
+      }
+      if (c == '\0')
+         XCursesSendKeyToCurses( (unsigned long)total, NULL );
+   }
+   else
+   {
+      ptr = (unsigned char *)*params;
+      for (i=0;i<(int)strlen((char *)ptr);i++)
+      {
+         XCursesSendKeyToCurses( (unsigned long)*(ptr+i), NULL );
+      }
+   }
+   return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesPasteSelection(Widget w,XButtonEvent *button_event)
+#else
+void XCursesPasteSelection(w,button_event)
+Widget w;
+XButtonEvent *button_event;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:XCursesPasteSelection() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+ XtGetSelectionValue(w,XA_PRIMARY,XA_STRING,XCursesRequestorCallbackForPaste,(XtPointer)button_event,button_event->time);
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesRequestorCallbackForPaste(Widget w,XtPointer data, Atom *selection,
+                                     Atom *type, XtPointer value,
+                                     unsigned long *length, int *format)
+#else
+void XCursesRequestorCallbackForPaste(w,data,selection,type,value,length,format)
+Widget w;
+XtPointer data;
+Atom *selection;
+Atom *type;
+XtPointer value;
+unsigned long *length;
+int *format;
+#endif
+/***********************************************************************/
+{
+   unsigned long i=0,key=0;
+   char *string=(char *)value;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesRequestorCallbackForPaste() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   if ((value == NULL) && (*length == 0))
+      return;
+
+   for (i=0;i<(*length);i++)
+   {
+      key = (unsigned long)(*(string+i));
+      if (key == 10) /* new line - convert to ^M */
+         key = 13;
+      XCursesSendKeyToCurses( key, NULL );
+   }
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+Boolean XCursesConvertProc(Widget w,Atom *selection, Atom *target,
+                            Atom *type_return, XtPointer *value_return,
+                            unsigned long *length_return, int *format_return)
+#else
+Boolean XCursesConvertProc(w,selection,target,type_return,value_return,
+                            length_return,format_return)
+Widget w;
+Atom *selection;
+Atom *target;
+Atom *type_return;
+XtPointer *value_return;
+unsigned long *length_return;
+int *format_return;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesConvertProc() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   if (*target == XA_TARGETS(XtDisplay(topLevel)))
+   {
+      XSelectionRequestEvent *req = XtGetSelectionRequest(w, *selection, (XtRequestId)NULL);
+      Atom *targetP;
+      XPointer std_targets;
+      unsigned long std_length;
+      XmuConvertStandardSelection(topLevel, req->time, selection,
+          target, type_return, &std_targets, &std_length,
+          format_return);
+      *value_return = XtMalloc(sizeof(Atom)*(std_length + 1));
+      targetP = *(Atom**)value_return;
+      *length_return = std_length + 1;
+      *targetP++ = XA_STRING;
+      bcopy((char *)std_targets, (char *)targetP, sizeof(Atom)*std_length);
+      XtFree((char *)std_targets);
+      *type_return = XA_ATOM;
+      *format_return = sizeof(Atom) * 8;
+      return True;
+   }
+   else if (*target == XA_STRING)
+   {
+      char *data = XtMalloc(tmpsel_length+1);
+      memcpy(data,tmpsel,tmpsel_length);
+      *value_return = data;
+      *length_return = tmpsel_length;
+      *format_return = 8;
+      *type_return = XA_STRING;
+      return True;
+   }
+   else
+   {
+      if (XmuConvertStandardSelection(topLevel, CurrentTime, selection, target, type_return,
+            (XPointer*)value_return, length_return, format_return))
+         return True;
+      else
+         return False;
+   }
+   return False;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesLoseOwnership(Widget w, Atom *type)
+#else
+void XCursesLoseOwnership(w,type)
+Widget w;
+Atom *type;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesLoseOwnership() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   if (tmpsel) free(tmpsel);
+   tmpsel = NULL;
+   tmpsel_length = 0;
+   SelectionOff();
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void ShowSelection( int start_x, int start_y, int end_x, int end_y, bool highlight )
+#else
+void ShowSelection( start_x, start_y, end_x, end_y, highlight )
+int start_x, start_y, end_x, end_y;
+bool highlight;
+#endif
+/***********************************************************************/
+{
+ int i,num_cols,start_col,row;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("%s:ShowSelection() - called StartX: %d StartY: %d EndX: %d EndY: %d Highlight: %d\n",(XCursesProcess)?"     X":"CURSES", start_x, start_y, end_x, end_y, highlight );
+#endif
+
+ for (i=0; i< (end_y-start_y)+1; i++)
+ {
+    if (start_y == end_y) /* all one one line */
+    {
+       start_col = start_x;
+       num_cols = end_x - start_x + 1;
+       row = start_y;
+    }
+    else if (i == 0) /* first line of multi-line stream */
+    {
+       start_col = start_x;
+       num_cols = COLS - start_x;
+       row = start_y;
+    }
+    else if (start_y+i == end_y) /* last line of multi-line stream */
+    {
+       start_col = 0;
+       num_cols = end_x + 1;
+       row = end_y;
+    }
+    else /* full line */
+    {
+       start_col = 0;
+       num_cols = COLS;
+       row = start_y+i;
+    }
+    while(*(Xcurscr+XCURSCR_FLAG_OFF+row))
+       /*
+        * Patch by:
+        * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+        */
+      dummy_function(); /* loop until we can write to the line */
+      /*
+       * End of patch by:
+       * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+       */
+
+    *(Xcurscr+XCURSCR_FLAG_OFF+row) = 1;
+    XCursesDisplayText((chtype *)(Xcurscr+XCURSCR_Y_OFF(row)+(start_col*sizeof(chtype))),row,start_col,num_cols,highlight);
+    *(Xcurscr+XCURSCR_FLAG_OFF+row) = 0;
+ }
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void SelectionOff(void)
+#else
+void SelectionOff()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:SelectionOff() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   XCursesDisplayScreen(FALSE);
+   selection_start_x = selection_start_y = selection_end_x = selection_end_y = 0;
+   mouse_selection = False;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void SelectionOn(int x,int y)
+#else
+void SelectionOn(x,y)
+int x,y;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:SelectionOn() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   selection_start_x = selection_end_x = x;
+   selection_start_y = selection_end_y = y;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void SelectionExtend(int x,int y)
+#else
+void SelectionExtend(x,y)
+int x,y;
+#endif
+/***********************************************************************/
+{
+   int temp;
+   int current_start,current_end,current_start_x,current_end_x,current_start_y,current_end_y;
+   int new_start,new_end,new_start_x,new_end_x,new_start_y,new_end_y;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:SelectionExtend() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   mouse_selection = True;
+
+   /* convert x/y coordinates into start/stop */
+   current_start = (selection_start_y * COLS) + selection_start_x;
+   current_end = (selection_end_y * COLS) + selection_end_x;
+   if (current_start > current_end)
+   {
+      current_start_x = selection_end_x;
+      current_start_y = selection_end_y;
+      current_end_x = selection_start_x;
+      current_end_y = selection_start_y;
+      temp = current_start;
+      current_start = current_end;
+      current_end = temp;
+   }
+   else
+   {
+      current_end_x = selection_end_x;
+      current_end_y = selection_end_y;
+      current_start_x = selection_start_x;
+      current_start_y = selection_start_y;
+   }
+   /*
+    * Now we have the current selection as a linear expression.
+    * Convert the new position to a linear expression.
+    */
+   selection_end_x = x;
+   selection_end_y = y;
+
+   /* convert x/y coordinates into start/stop */
+   new_start = (selection_start_y * COLS) + selection_start_x;
+   new_end = (selection_end_y * COLS) + selection_end_x;
+   if (new_start > new_end)
+   {
+      new_start_x = selection_end_x;
+      new_start_y = selection_end_y;
+      new_end_x = selection_start_x;
+      new_end_y = selection_start_y;
+      temp = new_start;
+      new_start = new_end;
+      new_end = temp;
+   }
+   else
+   {
+      new_end_x = selection_end_x;
+      new_end_y = selection_end_y;
+      new_start_x = selection_start_x;
+      new_start_y = selection_start_y;
+   }
+   if (new_end > current_end)
+      ShowSelection(current_end_x, current_end_y, new_end_x, new_end_y, TRUE );
+   else if (new_end < current_end)
+      ShowSelection(new_end_x, new_end_y, current_end_x, current_end_y, FALSE );
+   else if (new_start < current_start)
+      ShowSelection(new_start_x, new_start_y, current_start_x, current_start_y, TRUE );
+   else if (new_start > current_start)
+      ShowSelection(current_start_x, current_start_y, new_start_x, new_start_y, FALSE );
+   else
+      ShowSelection(current_start_x, current_start_y, new_start_x, new_start_y, TRUE );
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void SelectionSet( void )
+#else
+void SelectionSet()
+#endif
+/***********************************************************************/
+{
+ int i,j,start,end,start_x,end_x,start_y,end_y,num_cols,start_col,row,num_chars;
+ int ch,last_nonblank,length;
+ chtype *ptr=NULL;
+
+#ifdef PDCDEBUG
+ if (trace_on) PDC_debug("%s:SelectionSet() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+/* convert x/y coordinates into start/stop */
+ start = (selection_start_y * COLS) + selection_start_x;
+ end = (selection_end_y * COLS) + selection_end_x;
+ if (start == end)
+ {
+    if (tmpsel) free(tmpsel);
+    tmpsel = NULL;
+    tmpsel_length = 0;
+    return;
+ }
+ if (start > end)
+ {
+    start_x = selection_end_x;
+    start_y = selection_end_y;
+    end_x = selection_start_x;
+    end_y = selection_start_y;
+    length = start - end +1;
+ }
+ else
+ {
+    end_x = selection_end_x;
+    end_y = selection_end_y;
+    start_x = selection_start_x;
+    start_y = selection_start_y;
+    length = end - start +1;
+ }
+ if (length > tmpsel_length)
+ {
+    if (tmpsel_length == 0)
+       tmpsel = (char *)malloc(length+1+end_y-start_y+1);
+    else
+       tmpsel = (char *)realloc(tmpsel,length+1+end_y-start_y+1);
+ }
+ if (!tmpsel)
+ {
+    tmpsel_length = 0;
+    return;
+ }
+ tmpsel_length = length;
+ num_chars = 0;
+ for (i=0; i< (end_y-start_y)+1; i++)
+ {
+    if (start_y == end_y) /* all one one line */
+    {
+       start_col = start_x;
+       num_cols = end_x - start_x + 1;
+       row = start_y;
+    }
+    else if (i == 0) /* first line of multi-line stream */
+    {
+       start_col = start_x;
+       num_cols = COLS - start_x;
+       row = start_y;
+    }
+    else if (start_y+i == end_y) /* last line of multi-line stream */
+    {
+       start_col = 0;
+       num_cols = end_x + 1;
+       row = end_y;
+    }
+    else /* full line */
+    {
+       start_col = 0;
+       num_cols = COLS;
+       row = start_y+i;
+    }
+    while(*(Xcurscr+XCURSCR_FLAG_OFF+row))
+       /*
+        * Patch by:
+        * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+        */
+      dummy_function(); /* loop until we can write to the line */
+      /*
+       * End of patch by:
+       * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+       */
+
+    *(Xcurscr+XCURSCR_FLAG_OFF+row) = 1;
+    ptr = (chtype *)(Xcurscr+XCURSCR_Y_OFF(row)+(start_col*sizeof(chtype)));
+    if ( i < end_y-start_y )
+    {
+       last_nonblank = 0;
+       for (j=0; j<num_cols; j++)
+       {
+          ch = (int)(*(ptr+j) & A_CHARTEXT);
+          if (ch != (int)' ')
+             last_nonblank = j;
+       }
+    }
+    else last_nonblank = num_cols-1;
+    for (j=0; j<=last_nonblank; j++)
+    {
+       *(tmpsel+num_chars++) = (int)(*(ptr+j) & A_CHARTEXT);
+    }
+    *(Xcurscr+XCURSCR_FLAG_OFF+row) = 0;
+    if ( i < end_y-start_y ) *(tmpsel+num_chars++) = '\n';
+ }
+ *(tmpsel+num_chars) = '\0';
+ tmpsel_length = num_chars;
+ return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesDisplayCursor(int old_row,int old_x,int new_row,int new_x)
+#else
+void XCursesDisplayCursor(old_row,old_x,new_row,new_x)
+int old_row,old_x,new_row,new_x;
+#endif
+/***********************************************************************/
+{
+   int xpos,ypos,i;
+   char buf[2];
+   chtype *ch;
+   short fore=0,back=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesDisplayCursor() - draw char at row: %d col %d\n",(XCursesProcess)?"     X":"CURSES",old_row,old_x);
+#endif
+
+   /*
+    * If the cursor position is outside the boundary of the screen, ignore
+    * request.
+    */
+   if (old_row >= XCursesLINES
+   ||  old_x >= COLS
+   ||  new_row >= XCursesLINES
+   ||  new_x >= COLS)
+      return;
+
+   /* display the character at the current cursor position */
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesDisplayCursor() - draw char at row: %d col %d\n",(XCursesProcess)?"     X":"CURSES",old_row,old_x);
+#endif
+   XCursesDisplayText( (chtype *)(Xcurscr+(XCURSCR_Y_OFF(old_row)+(old_x*sizeof(chtype)))), old_row, old_x, 1, FALSE );
+   /* display the cursor at the new cursor position */
+
+   switch( SP->visibility )
+   {
+      case 0: /* cursor not displayed, no more to do */
+         break;
+      case 1: /* cursor visibility normal */
+         makeXY( new_x, new_row, XCursesFontWidth, XCursesFontHeight, &xpos, &ypos );
+         ch = (chtype *)(Xcurscr+XCURSCR_Y_OFF(new_row)+(new_x*sizeof(chtype)));
+         SetCursorColor( ch, &fore, &back );
+         XSetForeground( XCURSESDISPLAY, rect_cursor_gc, colors[back] );
+         if ( vertical_cursor )
+         {
+            XDrawLine( XCURSESDISPLAY, XCURSESWIN, rect_cursor_gc,
+                      xpos+1, ypos-XCURSESNORMALFONTINFO->ascent, xpos+1, ypos-XCURSESNORMALFONTINFO->ascent+XCursesFontHeight-1 );
+         }
+         else
+         {
+            for ( i = 0; i < XCURSESNORMALFONTINFO->descent + 2; i++ )
+               XDrawLine( XCURSESDISPLAY, XCURSESWIN, rect_cursor_gc, (xpos), (ypos-2+i), (xpos+XCursesFontWidth), (ypos-2+i) );
+         }
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("%s:XCursesDisplayCursor() - draw line at row %d col %d\n",(XCursesProcess)?"     X":"CURSES",new_row,new_x);
+#endif
+         break;
+      default: /* cursor visibility high */
+         makeXY( new_x, new_row, XCursesFontWidth, XCursesFontHeight, &xpos, &ypos );
+         ch = (chtype *)(Xcurscr+XCURSCR_Y_OFF(new_row)+(new_x*sizeof(chtype)));
+         SetCursorColor( ch, &fore, &back );
+         if ( vertical_cursor )
+         {
+            XSetForeground( XCURSESDISPLAY, rect_cursor_gc, colors[back] );
+            XDrawLine( XCURSESDISPLAY, XCURSESWIN, rect_cursor_gc,
+                      xpos+1, ypos-XCURSESNORMALFONTINFO->ascent, xpos+1, ypos-XCURSESNORMALFONTINFO->ascent+XCursesFontHeight-1 );
+            XDrawLine( XCURSESDISPLAY, XCURSESWIN, rect_cursor_gc,
+                      xpos+2, ypos-XCURSESNORMALFONTINFO->ascent, xpos+2, ypos-XCURSESNORMALFONTINFO->ascent+XCursesFontHeight-1 );
+         }
+         else
+         {
+            buf[0] =  (char)(*ch & A_CHARTEXT);
+            buf[1] = '\0';
+            XSetForeground( XCURSESDISPLAY, block_cursor_gc, colors[fore] );
+            XSetBackground( XCURSESDISPLAY, block_cursor_gc, colors[back] );
+            XDrawImageString( XCURSESDISPLAY, XCURSESWIN, block_cursor_gc, xpos, ypos, buf, 1 );
+         }
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("%s:XCursesDisplayCursor() - draw cursor at row: %d col %d char <%s>\n",(XCursesProcess)?"     X":"CURSES",new_row,new_x,buf);
+#endif
+         break;
+   }
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesEnterLeaveWindow(Widget w,XtPointer client_data,XEvent *event,Boolean *continue_to_dispatch)
+#else
+void XCursesEnterLeaveWindow(w,client_data,event,continue_to_dispatch)
+Widget w;
+XtPointer client_data;
+XEvent *event;
+Boolean *continue_to_dispatch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesEnterLeaveWindow called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   switch(event->type)
+   {
+      case EnterNotify:
+#ifdef PDCDEBUG
+         say("EnterNotify received\n");
+#endif
+         windowEntered = TRUE;
+         break;
+      case LeaveNotify:
+#ifdef PDCDEBUG
+         say("LeaveNotify received\n");
+#endif
+         windowEntered = FALSE;
+         /*
+          * Display the cursor so it stays on while the window
+          * is not current
+          */
+         XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                              SP->cursrow,SP->curscol);
+         break;
+      default:
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("%s:XCursesEnterleaveWindow - unknown event %d\n",(XCursesProcess)?"     X":"CURSES",event->type);
+#endif
+         break;
+   }
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_get_rows(void)
+#else
+int XCurses_get_rows()
+#endif
+/***********************************************************************/
+{
+   return(XCursesLINES);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_get_cols(void)
+#else
+int XCurses_get_cols()
+#endif
+/***********************************************************************/
+{
+   return(XCursesCOLS);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+unsigned long XCurses_get_key_modifiers(void)
+#else
+unsigned long XCurses_get_key_modifiers()
+#endif
+/***********************************************************************/
+{
+   return(pdc_key_modifier);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesSendKeyToCurses(unsigned long key, MOUSE_STATUS *ms)
+#else
+int XCursesSendKeyToCurses(key, ms)
+unsigned long key;
+MOUSE_STATUS *ms;
+#endif
+/***********************************************************************/
+{
+   char buf[100]; /* enough for MOUSE_STATUS */
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesSendKeyToCurses() - called: sending %d\n",(XCursesProcess)?"     X":"CURSES",key);
+#endif
+   memcpy(buf,(char *)&key,sizeof(unsigned long));
+   if (write_socket(key_sock,buf,sizeof(unsigned long)) < 0)
+      XCursesExitXCursesProcess(1,SIGKILL,"exiting from XCursesSendKeyToCurses");
+   if ( ms != NULL )
+   {
+      memcpy(buf,(char *)&Mouse_status,sizeof(MOUSE_STATUS));
+# ifdef MOUSE_DEBUG1
+   printf("%s:writing mouse stuff\n",(XCursesProcess)?"     X":"CURSES");
+# endif
+      if ( write_socket(key_sock,buf,sizeof(MOUSE_STATUS) ) < 0 )
+         XCursesExitXCursesProcess(1,SIGKILL,"exiting from XCursesSendKeyToCurses");
+   }
+   return(0);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesCursorBlink(XtPointer unused, XtIntervalId *id)
+#else
+void XCursesCursorBlink(unused, id)
+XtPointer unused;
+XtIntervalId *id;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesCursorBlink() - called:\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   if ( windowEntered )
+   {
+      if ( visible_cursor )
+      {
+         /*
+          * Cursor currently ON, turn it off
+          */
+         int save_visibility = SP->visibility;
+         SP->visibility = 0;
+         XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                              SP->cursrow,SP->curscol);
+         SP->visibility = save_visibility;
+         visible_cursor = 0;
+      }
+      else
+      {
+         /*
+          * Cursor currently OFF, turn it on
+          */
+         XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                              SP->cursrow,SP->curscol);
+         visible_cursor = 1;
+      }
+   }
+
+   XtAppAddTimeOut( app_context, XCURSESCURSORBLINKRATE, XCursesCursorBlink, NULL );
+   return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesButton(Widget w,XEvent *event, String *params, Cardinal *nparams)
+#else
+void XCursesButton(w,event,params,nparams)
+Widget w;
+XEvent *event;
+String *params;
+Cardinal *nparams;
+#endif
+/***********************************************************************/
+{
+   int button_no=0;
+   static int last_button_no;
+   static Time last_button_press_time=0;
+   MOUSE_STATUS save_mouse_status;
+   bool send_key=TRUE;
+   static bool remove_release;
+   static bool handle_real_release;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesButton called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   save_mouse_status=Mouse_status;
+   button_no = event->xbutton.button;
+   /*---------------------------------------------------------------------*/
+   /* It appears that under X11R6 (at least on Linux), that an event_type */
+   /* of ButtonMotion does not include the mouse button in the event. The */
+   /* following code is designed to cater for this situation.             */
+   /*---------------------------------------------------------------------*/
+   if (button_no == 0)
+      button_no = last_button_no;
+   last_button_no = button_no;
+
+   Mouse_status.changes = 0;
+   switch(event->type)
+   {
+      /*
+       * ButtonPress
+       */
+      case ButtonPress:
+         /*
+          * Handle button 4 and 5, which are normally mapped to the wheel mouse
+          * scroll up and down
+          */
+         if ( (SP->_trap_mbe & MOUSE_WHEEL_SCROLL )
+         && ( button_no == 4 || button_no == 5 ) )
+         {
+            /*
+             * Send the KEY_MOUSE to curses program...
+             */
+            memset( &Mouse_status, 0, sizeof(Mouse_status) );
+            Mouse_status.changes = (button_no == 5) ? PDC_MOUSE_WHEEL_DOWN : PDC_MOUSE_WHEEL_UP ;
+            MOUSE_X_POS = MOUSE_Y_POS = -1;
+            XCursesSendKeyToCurses( (unsigned long)KEY_MOUSE, &Mouse_status );
+            return;
+         }
+         remove_release = False;
+         handle_real_release = False;
+#ifdef MOUSE_DEBUG
+         printf("\nButtonPress\n");
+#endif
+         if ((event->xbutton.time - last_button_press_time) < XCURSESDOUBLECLICKPERIOD)
+         {
+            MOUSE_X_POS = save_mouse_status.x;
+            MOUSE_Y_POS = save_mouse_status.y;
+            BUTTON_STATUS(button_no) = BUTTON_DOUBLE_CLICKED;
+            SelectionOff();
+            if (!(SP->_trap_mbe & BUTTON1_DOUBLE_CLICKED)
+            &&  button_no == 1)
+               send_key = FALSE;
+            if (!(SP->_trap_mbe & BUTTON2_DOUBLE_CLICKED)
+            &&  button_no == 2)
+               send_key = FALSE;
+            if (!(SP->_trap_mbe & BUTTON3_DOUBLE_CLICKED)
+            &&  button_no == 3)
+               send_key = FALSE;
+            if (send_key)
+               remove_release = True;
+         }
+         else
+         {
+#if 0
+            MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+            MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+            BUTTON_STATUS(button_no) = BUTTON_PRESSED;
+            if (!(SP->_trap_mbe & BUTTON1_PRESSED)
+            &&  button_no == 1)
+               send_key = FALSE;
+            if (!(SP->_trap_mbe & BUTTON2_PRESSED)
+            &&  button_no == 2)
+               send_key = FALSE;
+            if (!(SP->_trap_mbe & BUTTON3_PRESSED)
+            &&  button_no == 3)
+               send_key = FALSE;
+            if (button_no == 1
+            &&  !(event->xbutton.state & ShiftMask)
+            &&  !(event->xbutton.state & ControlMask)
+            &&  !(event->xbutton.state & Mod1Mask))
+            {
+               SelectionOff();
+               SelectionOn(MOUSE_X_POS,MOUSE_Y_POS);
+            }
+#else
+            PDC_usleep( XCURSESCLICKPERIOD * 1000 ); /* microseconds to milliseconds */
+            event->type = ButtonRelease;
+            XSendEvent(event->xbutton.display, event->xbutton.window, True,
+                       0, event);
+            last_button_press_time = event->xbutton.time;
+#ifdef PDCDEBUG
+printf("Pressed at: %ld\n",last_button_press_time);
+#endif
+            return;
+#endif
+         }
+         last_button_press_time = event->xbutton.time;
+#ifdef PDCDEBUG
+printf("Pressed at: %ld\n",last_button_press_time);
+#endif
+         break;
+      /*
+       * MotionNotify
+       */
+      case MotionNotify:
+#ifdef MOUSE_DEBUG
+         printf("\nMotionNotify: y: %d x: %d Width: %d Height: %d\n",event->xbutton.y,
+                event->xbutton.x,
+                XCursesFontWidth,
+                XCursesFontHeight);
+#endif
+         if (button_no == 1
+         &&  !(event->xbutton.state & ShiftMask)
+         &&  !(event->xbutton.state & ControlMask)
+         &&  !(event->xbutton.state & Mod1Mask))
+         {
+            MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+            MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+            SelectionExtend(MOUSE_X_POS,MOUSE_Y_POS);
+            send_key = FALSE;
+         }
+         else
+            SelectionOff();
+         /*
+          * Throw away mouse movements if they are in the same character position
+          * as the last mouse event, or if we are currently in the middle of
+          * a double click event.
+          */
+         MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+         MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+         if ((MOUSE_X_POS == save_mouse_status.x
+           &&  MOUSE_Y_POS == save_mouse_status.y)
+         ||  save_mouse_status.button[button_no-1] == BUTTON_DOUBLE_CLICKED)
+         {
+            send_key = FALSE;
+            break;
+         }
+         MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+         MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+         Mouse_status.changes |= 8;
+         if (!(SP->_trap_mbe & BUTTON1_MOVED)
+         &&  button_no == 1)
+            send_key = FALSE;
+         if (!(SP->_trap_mbe & BUTTON2_MOVED)
+         &&  button_no == 2)
+            send_key = FALSE;
+         if (!(SP->_trap_mbe & BUTTON3_MOVED)
+         &&  button_no == 3)
+            send_key = FALSE;
+#if 0
+         if (button_no == 1
+         &&  !(event->xbutton.state & ShiftMask)
+         &&  !(event->xbutton.state & ControlMask)
+         &&  !(event->xbutton.state & Mod1Mask))
+         {
+            SelectionExtend(MOUSE_X_POS,MOUSE_Y_POS);
+            send_key = FALSE;
+         }
+         else
+            SelectionOff();
+#endif
+         break;
+      /*
+       * ButtonRelease
+       */
+      case ButtonRelease:
+#if 0
+         MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+         MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+         BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+         if (!(SP->_trap_mbe & BUTTON1_RELEASED)
+         &&  button_no == 1)
+            send_key = FALSE;
+         if (!(SP->_trap_mbe & BUTTON2_RELEASED)
+         &&  button_no == 2)
+            send_key = FALSE;
+         if (!(SP->_trap_mbe & BUTTON3_RELEASED)
+         &&  button_no == 3)
+            send_key = FALSE;
+         if (button_no == 1
+         &&  !(event->xbutton.state & ShiftMask)
+         &&  !(event->xbutton.state & ControlMask)
+         &&  !(event->xbutton.state & Mod1Mask)
+         &&  mouse_selection)
+         {
+            send_key = FALSE;
+            if (XtOwnSelection(topLevel,
+                               XA_PRIMARY,
+                               event->xbutton.time,
+                               XCursesConvertProc,
+                               XCursesLoseOwnership,
+                               NULL) == False)
+            {
+               SelectionOff();
+            }
+            SelectionSet();
+         }
+         else
+            SelectionOff();
+         break;
+#else
+         if (remove_release)
+         {
+#ifdef PDCDEBUG
+   printf("Release at: %ld - removed\n",event->xbutton.time);
+#endif
+            return;
+         }
+         else
+         {
+            if (!handle_real_release)
+            {
+               if ((event->xbutton.time - last_button_press_time) < 100
+               && (event->xbutton.time != last_button_press_time))
+               {
+                  /*
+                   * The "real" release was shorter than usleep() time
+                   * therefore generate a click event
+                   */
+#ifdef PDCDEBUG
+   printf("Release at: %ld - click\n",event->xbutton.time);
+#endif
+                  MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+                  MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+                  BUTTON_STATUS(button_no) = BUTTON_CLICKED;
+                  if (!(SP->_trap_mbe & BUTTON1_RELEASED)
+                  &&  button_no == 1)
+                     send_key = FALSE;
+                  if (!(SP->_trap_mbe & BUTTON2_RELEASED)
+                  &&  button_no == 2)
+                     send_key = FALSE;
+                  if (!(SP->_trap_mbe & BUTTON3_RELEASED)
+                  &&  button_no == 3)
+                     send_key = FALSE;
+                  if (button_no == 1
+                  &&  !(event->xbutton.state & ShiftMask)
+                  &&  !(event->xbutton.state & ControlMask)
+                  &&  !(event->xbutton.state & Mod1Mask)
+                  &&  mouse_selection)
+                  {
+                     send_key = FALSE;
+                     if (XtOwnSelection(topLevel,
+                                  XA_PRIMARY,
+                                  event->xbutton.time,
+                                  XCursesConvertProc,
+                                  XCursesLoseOwnership,
+                                  NULL) == False)
+                     {
+                        SelectionOff();
+                     }
+                  }
+                  else
+                     SelectionOff();
+                  /*
+                   * Ensure the "pseudo" release event is ignored
+                   */
+                  remove_release = True;
+                  handle_real_release = False;
+                  break;
+               }
+               else
+               {
+                  /*
+                   * Button release longer than usleep() time
+                   * therefore generate a press and wait for the
+                   * real release to occur later.
+                   */
+#ifdef PDCDEBUG
+   printf("Generated Release at: %ld - press & release\n",event->xbutton.time);
+#endif
+                  MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+                  MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+                  BUTTON_STATUS(button_no) = BUTTON_PRESSED;
+                  if (!(SP->_trap_mbe & BUTTON1_PRESSED)
+                  &&  button_no == 1)
+                     send_key = FALSE;
+                  if (!(SP->_trap_mbe & BUTTON2_PRESSED)
+                  &&  button_no == 2)
+                     send_key = FALSE;
+                  if (!(SP->_trap_mbe & BUTTON3_PRESSED)
+                  &&  button_no == 3)
+                     send_key = FALSE;
+                  if (button_no == 1
+                  &&  !(event->xbutton.state & ShiftMask)
+                  &&  !(event->xbutton.state & ControlMask)
+                  &&  !(event->xbutton.state & Mod1Mask))
+                  {
+                     SelectionOff();
+                     SelectionOn(MOUSE_X_POS,MOUSE_Y_POS);
+                  }
+                  handle_real_release = True;
+                  break;
+               }
+            }
+            else
+            {
+#ifdef PDCDEBUG
+   printf("Release at: %ld - released\n",event->xbutton.time);
+#endif
+            }
+         }
+#ifdef PDCDEBUG
+printf("\nButtonRelease\n");
+#endif
+         MOUSE_X_POS = (event->xbutton.x-XCURSESBORDERWIDTH) / XCursesFontWidth;
+         MOUSE_Y_POS = (event->xbutton.y-XCURSESBORDERWIDTH) / XCursesFontHeight;
+         BUTTON_STATUS(button_no) = BUTTON_RELEASED;
+         if (!(SP->_trap_mbe & BUTTON1_RELEASED)
+         &&  button_no == 1)
+            send_key = FALSE;
+         if (!(SP->_trap_mbe & BUTTON2_RELEASED)
+         &&  button_no == 2)
+            send_key = FALSE;
+         if (!(SP->_trap_mbe & BUTTON3_RELEASED)
+         &&  button_no == 3)
+            send_key = FALSE;
+         if (button_no == 1
+         &&  !(event->xbutton.state & ShiftMask)
+         &&  !(event->xbutton.state & ControlMask)
+         &&  !(event->xbutton.state & Mod1Mask)
+         &&  mouse_selection)
+         {
+            send_key = FALSE;
+            if (XtOwnSelection(topLevel,
+                               XA_PRIMARY,
+                               event->xbutton.time,
+                               XCursesConvertProc,
+                               XCursesLoseOwnership,
+                               NULL) == False)
+            {
+               SelectionOff();
+            }
+            SelectionSet();
+         }
+         else
+            SelectionOff();
+         break;
+#endif
+   }
+   /*
+    * Set up the mouse status fields in preparation for sending...
+    */
+   Mouse_status.changes |= (1 << (button_no-1));
+   if (event->xbutton.state & ShiftMask)
+      BUTTON_STATUS(button_no) |= BUTTON_SHIFT;
+   if (event->xbutton.state & ControlMask)
+      BUTTON_STATUS(button_no) |= BUTTON_CONTROL;
+   if (event->xbutton.state & Mod1Mask)
+      BUTTON_STATUS(button_no) |= BUTTON_ALT;
+   /*
+    * If we are ignoring the event, or the mouse position is outside the
+    * bounds of the screen (because of the border), return here...
+    */
+#ifdef PDCDEBUG
+   printf("Button: %d x: %d y: %d Button status: %x Mouse status: %x\n",button_no,
+                                    MOUSE_X_POS,
+                                    MOUSE_Y_POS,
+                                    BUTTON_STATUS(button_no),
+                                    Mouse_status.changes);
+   printf("Send: %d Button1: %x Button2: %x Button3: %x %d %d\n",
+                                    send_key,
+                                    BUTTON_STATUS(1),
+                                    BUTTON_STATUS(2),
+                                    BUTTON_STATUS(3),
+                                    XCursesLINES,XCursesCOLS);
+#endif
+
+   if (!send_key
+   ||  MOUSE_X_POS < 0
+   ||  MOUSE_X_POS >= XCursesCOLS
+   ||  MOUSE_Y_POS < 0
+   ||  MOUSE_Y_POS >= XCursesLINES)
+      return;
+
+#ifdef MOUSE_DEBUG
+   printf("Button: %d x: %d y: %d Button status: %x Mouse status: %x\n",button_no,
+                                    MOUSE_X_POS,
+                                    MOUSE_Y_POS,
+                                    BUTTON_STATUS(button_no),
+                                    Mouse_status.changes);
+   printf("Send: %d Button1: %x Button2: %x Button3: %x\n",send_key,
+                                    BUTTON_STATUS(1),
+                                    BUTTON_STATUS(2),
+                                    BUTTON_STATUS(3));
+#endif
+   /*
+    * Send the KEY_MOUSE to curses program...
+    */
+   XCursesSendKeyToCurses( (unsigned long)KEY_MOUSE, &Mouse_status );
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void Scroll_up_down(Widget w, XtPointer client_data, XtPointer call_data)
+#else
+void Scroll_up_down(w, client_data, call_data)
+Widget w;
+XtPointer client_data;
+XtPointer call_data;
+#endif
+/***********************************************************************/
+{
+   int pixels = (long) call_data;
+   int total_y=(SP->sb_total_y*XCursesFontHeight);
+   int viewport_y=(SP->sb_viewport_y*XCursesFontHeight);
+   int cur_y=(SP->sb_cur_y*XCursesFontHeight);
+
+   /*
+    * When pixels is negative, right button pressed, move data down,
+    * thumb moves up.  Otherwise, left button pressed, pixels
+    * positive, move data up, thumb down.
+    */
+   cur_y += pixels;
+
+   /* limit panning to size of overall */
+   if (cur_y < 0)
+      cur_y = 0;
+   else
+   {
+      if (cur_y > (total_y - viewport_y))
+         cur_y = (total_y - viewport_y);
+   }
+   SP->sb_cur_y = cur_y / XCursesFontHeight;
+   XawScrollbarSetThumb(w,(double)((double)cur_y/(double)total_y),(double)((double)viewport_y/(double)total_y));
+   /*
+    * Send a key: if pixels negative, send KEY_SCROLL_DOWN
+    */
+   XCursesSendKeyToCurses( (unsigned long)KEY_SF, NULL );
+#if 0
+fprintf(stderr,"Scroll_up_down: pixels %d cur_y %d\n",pixels,SP->sb_cur_y);
+#endif
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void Scroll_left_right(Widget w, XtPointer client_data, XtPointer call_data)
+#else
+void Scroll_left_right(w, client_data, call_data)
+Widget w;
+XtPointer client_data;
+XtPointer call_data;
+#endif
+/***********************************************************************/
+{
+   int pixels = (long) call_data;
+   int total_x=(SP->sb_total_x*XCursesFontWidth);
+   int viewport_x=(SP->sb_viewport_x*XCursesFontWidth);
+   int cur_x=(SP->sb_cur_x*XCursesFontWidth);
+
+   /*
+    * When pixels is negative, right button pressed, move data down,
+    * thumb moves up.  Otherwise, left button pressed, pixels
+    * positive, move data up, thumb down.
+    */
+   cur_x += pixels;
+
+   /* limit panning to size of overall */
+   if (cur_x < 0)
+      cur_x = 0;
+   else
+   {
+      if (cur_x > (total_x - viewport_x))
+         cur_x = (total_x - viewport_x);
+   }
+   SP->sb_cur_x = cur_x / XCursesFontWidth;
+   XawScrollbarSetThumb(w,(double)((double)cur_x/(double)total_x),(double)((double)viewport_x/(double)total_x));
+   /*
+    * Send a key: if pixels negative, send KEY_SCROLL_DOWN
+    */
+   XCursesSendKeyToCurses( (unsigned long)KEY_SR, NULL );
+#if 0
+fprintf(stderr,"Scroll_left_right: pixels %d cur_x %d\n",pixels,SP->sb_cur_x);
+#endif
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void Thumb_up_down(Widget w, XtPointer client_data, XtPointer call_data)
+#else
+void Thumb_up_down(w, client_data, call_data)
+Widget w;
+XtPointer client_data;
+XtPointer call_data;
+#endif
+/***********************************************************************/
+{
+   double percent = *(double *) call_data;
+   double total_y=(double)(SP->sb_total_y);
+   double viewport_y=(double)(SP->sb_viewport_y);
+   int cur_y=SP->sb_cur_y;
+
+#if 0
+fprintf(stderr,"Thumb_up_down: percent %f\n",percent);
+#endif
+   /*
+    * If the size of the viewport is > overall area
+    * simply return, as no scrolling is permitted.
+    */
+   if (SP->sb_viewport_y >= SP->sb_total_y)
+      return;
+   if ((SP->sb_cur_y = (int)((double)total_y * percent)) >= (total_y - viewport_y))
+      SP->sb_cur_y = total_y - viewport_y;
+
+   /* SP->sb_cur_y = cur_y;*/
+   XawScrollbarSetThumb(w,(double)(cur_y/total_y),(double)(viewport_y/total_y));
+   /*
+    * Send a key: if pixels negative, send KEY_SCROLL_DOWN
+    */
+#if 0
+fprintf(stderr,"Thumb_up_down: percent %f cur_y %d\n",percent,SP->sb_cur_y);
+#endif
+   XCursesSendKeyToCurses( (unsigned long)KEY_SF, NULL );
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void Thumb_left_right(Widget w, XtPointer client_data, XtPointer call_data)
+#else
+void Thumb_left_right(w, client_data, call_data)
+Widget w;
+XtPointer client_data;
+XtPointer call_data;
+#endif
+/***********************************************************************/
+{
+   double percent = *(double *) call_data;
+   double total_x=(double)(SP->sb_total_x);
+   double viewport_x=(double)(SP->sb_viewport_x);
+   int cur_x=SP->sb_cur_x;
+
+#if 0
+fprintf(stderr,"Thumb_up_down: percent %f\n",percent);
+#endif
+   /*
+    * If the size of the viewport is > overall area
+    * simply return, as no scrolling is permitted.
+    */
+   if (SP->sb_viewport_x >= SP->sb_total_x)
+      return;
+   if ((SP->sb_cur_x = (int)((float)total_x * percent)) >= (total_x - viewport_x))
+      SP->sb_cur_x = total_x - viewport_x;
+
+   /* SP->sb_cur_x = cur_x;*/
+   XawScrollbarSetThumb(w,(double)(cur_x/total_x),(double)(viewport_x/total_x));
+   /*
+    * Send a key: if pixels negative, send KEY_SCROLL_DOWN
+    */
+#if 0
+fprintf(stderr,"Thumb_up_down: percent %f cur_x %d\n",percent,SP->sb_cur_x);
+#endif
+   XCursesSendKeyToCurses( (unsigned long)KEY_SR, NULL );
+}
+#endif
diff -Naur gdb-6.8/pdcurses/x11/pdcx11.h stsgdb-6.8/pdcurses/x11/pdcx11.h
--- gdb-6.8/pdcurses/x11/pdcx11.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/pdcx11.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,355 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+*
+* This file is NOT public domain software.  It is Copyright, Mark Hessling
+* 1994-1999. M.Hessling@qut.edu.au
+***************************************************************************
+*/
+
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include <signal.h>
+#include <ctype.h>
+#include <pwd.h>
+
+/*
+ * #includes specific to running XCurses with seperate processes
+ */
+#ifdef USE_PROCESSES
+# include <sys/types.h>
+# include <sys/socket.h>
+# ifdef HAVE_FCNTL_H
+#  include <fcntl.h>
+# endif
+# ifdef HAVE_SYS_SELECT_H
+#  include <sys/select.h>   /* AIX needs this for FD_ZERO etc macros */
+# endif
+# include <sys/ipc.h>
+# include <sys/shm.h>
+#endif
+
+#if !defined(XPOINTER_TYPEDEFED)
+ typedef char * XPointer;
+#endif
+
+/*
+ * #includes specific to running XCurses with threads
+ */
+#ifdef USE_THREADS
+# include <pthreads.h>
+#endif
+
+#ifdef TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# ifdef HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#ifdef HAVE_ERRNO_H
+# include <errno.h>
+#endif
+
+#include <Intrinsic.h>
+#include <StringDefs.h>
+#include <Shell.h>
+
+#ifdef USE_XAW3D
+#include <Xaw3d/Box.h>
+#include <Xaw3d/Scrollbar.h>
+#elif defined(USE_NEXTAW)
+#include <neXtaw/Box.h>
+#include <neXtaw/Scrollbar.h>
+#else
+#include <Xaw/Box.h>
+#include <Xaw/Scrollbar.h>
+#endif
+#include "x11/ScrollBox.h"
+
+#include "Xmu/StdSel.h"
+#include "Xmu/Atoms.h"
+
+#include <keysym.h>
+#include <Xatom.h>
+#if defined FOREIGN
+# include <Xlocale.h>
+#endif
+
+#ifdef HAVE_DECKEYSYM_H
+#include <DECkeysym.h>
+#endif
+
+#ifdef HAVE_SUNKEYSYM_H
+#include <Sunkeysym.h>
+#endif
+
+#ifdef HAVE_XPM_H
+# include <xpm.h>
+#endif
+
+#include <curses.h>
+
+#define XtNlines         "lines"
+#define XtCLines         "Lines"
+#define XtNcols          "cols"
+#define XtCCols          "Cols"
+
+#define XtCNormalFont    "NormalFont"
+#define XtNnormalFont    "normalFont"
+#define XtCItalicFont      "ItalicFont"
+#define XtNitalicFont      "italicFont"
+
+#define XtCPointer       "Pointer"
+#define XtNpointer       "pointer"
+
+#define XtCShmmin        "Shmmin"
+#define XtNshmmin        "shmmin"
+
+#define XtCComposeKey    "ComposeKey"
+#define XtNcomposeKey    "composeKey"
+
+#define XtCClickPeriod   "ClickPeriod"
+#define XtNclickPeriod   "clickPeriod"
+
+#define XtCDoubleClickPeriod   "DoubleClickPeriod"
+#define XtNdoubleClickPeriod   "doubleClickPeriod"
+
+#define XtCScrollbarWidth   "ScrollbarWidth"
+#define XtNscrollbarWidth   "scrollbarWidth"
+
+#define XtCCursorBlinkRate   "CursorBlinkRate"
+#define XtNcursorBlinkRate   "cursorBlinkRate"
+
+#define XtCPointerForeColor "PointerForeColor"
+#define XtNpointerForeColor "pointerForeColor"
+#define XtCPointerBackColor "PointerBackColor"
+#define XtNpointerBackColor "pointerBackColor"
+
+#define XtNcursorColor   "cursorColor"
+#define XtCCursorColor   "CursorColor"
+
+#define XtNtextCursor   "textCursor"
+#define XtCTextCursor   "TextCursor"
+
+#define XtNcolorBlack    "colorBlack"
+#define XtCColorBlack    "ColorBlack"
+#define XtNcolorRed      "colorRed"
+#define XtCColorRed      "ColorRed"
+#define XtNcolorGreen    "colorGreen"
+#define XtCColorGreen    "ColorGreen"
+#define XtNcolorYellow   "colorYellow"
+#define XtCColorYellow   "ColorYellow"
+#define XtNcolorBlue     "colorBlue"
+#define XtCColorBlue     "ColorBlue"
+#define XtNcolorMagenta  "colorMagenta"
+#define XtCColorMagenta  "ColorMagenta"
+#define XtNcolorCyan     "colorCyan"
+#define XtCColorCyan     "ColorCyan"
+#define XtNcolorWhite    "colorWhite"
+#define XtCColorWhite    "ColorWhite"
+
+#define XtNcolorBoldBlack    "colorBoldBlack"
+#define XtCColorBoldBlack    "ColorBoldBlack"
+#define XtNcolorBoldRed      "colorBoldRed"
+#define XtCColorBoldRed      "ColorBoldRed"
+#define XtNcolorBoldGreen    "colorBoldGreen"
+#define XtCColorBoldGreen    "ColorBoldGreen"
+#define XtNcolorBoldYellow   "colorBoldYellow"
+#define XtCColorBoldYellow   "ColorBoldYellow"
+#define XtNcolorBoldBlue     "colorBoldBlue"
+#define XtCColorBoldBlue     "ColorBoldBlue"
+#define XtNcolorBoldMagenta  "colorBoldMagenta"
+#define XtCColorBoldMagenta  "ColorBoldMagenta"
+#define XtNcolorBoldCyan     "colorBoldCyan"
+#define XtCColorBoldCyan     "ColorBoldCyan"
+#define XtNcolorBoldWhite    "colorBoldWhite"
+#define XtCColorBoldWhite    "ColorBoldWhite"
+
+#ifndef MAX_PATH
+#  define MAX_PATH 256
+#endif
+
+typedef struct
+{
+ int lines;
+ int cols;
+ Pixel cursorColor;
+ Pixel colorBlack;
+ Pixel colorRed;
+ Pixel colorGreen;
+ Pixel colorYellow;
+ Pixel colorBlue;
+ Pixel colorMagenta;
+ Pixel colorCyan;
+ Pixel colorWhite;
+ Pixel colorBoldBlack;
+ Pixel colorBoldRed;
+ Pixel colorBoldGreen;
+ Pixel colorBoldYellow;
+ Pixel colorBoldBlue;
+ Pixel colorBoldMagenta;
+ Pixel colorBoldCyan;
+ Pixel colorBoldWhite;
+ Pixel pointerForeColor;
+ Pixel pointerBackColor;
+ XFontStruct *normalfont;
+ XFontStruct *italicfont;
+ char *bitmapFile;
+#ifdef HAVE_XPM_H
+ char *pixmapFile;
+#endif
+ char *composeKey;
+ Cursor pointer;
+ int shmmin;
+ int borderWidth;
+ int borderColor;
+ int clickPeriod;
+ int doubleClickPeriod;
+ int scrollbarWidth;
+ int cursorBlinkRate;
+ char *textCursor;
+#if 0
+ XtWidgetGeometry geometry;
+#endif
+} AppData;
+
+#define XCURSESNORMALFONTINFO   app_data.normalfont
+#define XCURSESITALICFONTINFO   app_data.italicfont
+#define XCURSESLINES            app_data.lines
+#define XCURSESCOLS             app_data.cols
+#define XCURSESBITMAPFILE       app_data.bitmapFile
+#ifdef HAVE_XPM_H
+# define XCURSESPIXMAPFILE      app_data.pixmapFile
+#endif
+#define XCURSESCOMPOSEKEY       app_data.composeKey
+#define XCURSESPOINTER          app_data.pointer
+#define XCURSESPOINTERFORECOLOR app_data.pointerForeColor
+#define XCURSESPOINTERBACKCOLOR app_data.pointerBackColor
+#define XCURSESCURSORCOLOR      app_data.cursorColor
+#define XCURSESSHMMIN           app_data.shmmin
+#define XCURSESBORDERWIDTH      app_data.borderWidth
+#define XCURSESBORDERCOLOR      app_data.borderColor
+#define XCURSESDOUBLECLICKPERIOD app_data.doubleClickPeriod
+#define XCURSESCLICKPERIOD      app_data.clickPeriod
+#define XCURSESSCROLLBARWIDTH   app_data.scrollbarWidth
+#define XCURSESCURSORBLINKRATE  app_data.cursorBlinkRate
+#define XCURSESGEOMETRY         app_data.geometry
+#define XCURSESTEXTCURSOR       app_data.textCursor
+
+#define XCURSESDISPLAY      (XtDisplay(drawing))
+#define XCURSESWIN          (XtWindow(drawing))
+
+#define MAX_COLORS   8  /* maximum of "normal" colours */
+#define COLOR_CURSOR 16 /* colour of cursor - 1 more than 2*MAX_COLORS */
+#define COLOR_BORDER 17 /* colour of border - 2 more than 2*MAX_COLORS */
+#ifdef HAVE_XPM_H
+# define PDC_NUMBER_OPTIONS 33
+#define PDC_NUMBER_APP_RESOURCES 35
+#else
+# define PDC_NUMBER_OPTIONS 32
+#define PDC_NUMBER_APP_RESOURCES 34
+#endif
+#define PDC_NUMBER_XCURSES_ACTIONS 5
+
+#include "x11.h"
+
+extern GC normal_gc,block_cursor_gc,rect_cursor_gc,italic_gc,border_gc;
+extern int XCursesFontHeight,XCursesFontWidth;
+extern int XCursesFontAscent,XCursesFontDescent;
+extern int XCursesWindowWidth,XCursesWindowHeight;
+extern int resizeXCursesWindowWidth,resizeXCursesWindowHeight;
+extern char *bitmap_file;
+#ifdef HAVE_XPM_H
+extern char *pixmap_file;
+#endif
+extern MOUSE_STATUS Trapped_Mouse_status;
+extern unsigned long pdc_key_modifier;
+extern KeySym compose_key;
+extern int compose_mask;
+extern int state_mask[8];
+extern Atom wm_atom[2];
+extern XtTranslations XCursesTranslations;
+extern char *defaultTranslations;
+extern XtActionsRec XCursesActions[PDC_NUMBER_XCURSES_ACTIONS];
+extern char *XCursesClassName;
+extern XtAppContext app_context;
+extern Widget topLevel,drawing,d1,scrollBox,scrollVert,scrollHoriz;
+extern int ReceivedMapNotify;
+extern Boolean mouse_selection;
+extern char *tmpsel;
+extern unsigned long tmpsel_length;
+extern int selection_start_x;
+extern int selection_start_y;
+extern int selection_end_x;
+extern int selection_end_y;
+extern Pixmap icon_bitmap;
+#ifdef HAVE_XPM_H
+extern Pixmap icon_pixmap;
+extern Pixmap icon_pixmap_mask;
+#endif
+extern XtResource app_resources[PDC_NUMBER_APP_RESOURCES];
+extern XrmOptionDescRec options[PDC_NUMBER_OPTIONS];
+extern char global_display_name[100];
+extern Bool after_first_curses_request;
+/* extern char *XCursesProgramName; */
+extern int colors[(2*MAX_COLORS)+2];
+extern int windowEntered;
+extern int visible_cursor;
+extern Bool vertical_cursor;
+
+typedef RETSIGTYPE (*signal_handler)();
+
+#ifdef HAVE_PROTO
+void XCursesNonmaskable(Widget w,XtPointer client_data,XEvent *event,Boolean *continue_to_dispatch);
+void XCursesExpose(Widget w,XtPointer client_data,XEvent *event,Boolean *continue_to_dispatch);
+signal_handler XCursesSetSignal(int,signal_handler);
+void XCursesGetIcon(void);
+int XCursesRefreshScrollbar(void);
+int XCursesSendKeyToCurses(unsigned long, MOUSE_STATUS *);
+void XCursesButton(Widget,XEvent *,String *,Cardinal *);
+void XCursesCursorBlink(XtPointer unused, XtIntervalId *id);
+void Scroll_up_down(Widget w, XtPointer client_data, XtPointer call_data);
+void Scroll_left_right(Widget w, XtPointer client_data, XtPointer call_data);
+void Thumb_up_down(Widget w, XtPointer client_data, XtPointer call_data);
+void Thumb_left_right(Widget w, XtPointer client_data, XtPointer call_data);
+#else
+void XCursesNonmaskable();
+void XCursesExpose();
+signal_handler XCursesSetSignal();
+void XCursesGetIcon();
+int XCursesRefreshScrollbar();
+int XCursesSendKeyToCurses();
+void XCursesButton();
+void XCursesCursorBlink();
+void Scroll_up_down();
+void Scroll_left_right();
+void Thumb_up_down();
+void Thumb_left_right();
+#endif
diff -Naur gdb-6.8/pdcurses/x11/process/x11.c stsgdb-6.8/pdcurses/x11/process/x11.c
--- gdb-6.8/pdcurses/x11/process/x11.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/process/x11.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,1110 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+*
+* This file is NOT public domain software.  It is Copyright, Mark Hessling
+* 1994-2000.
+***************************************************************************
+*/
+
+#include "pdcx11.h"
+extern AppData app_data;
+
+int visible_cursor=0;
+int windowEntered = 1;
+static char *XCursesProgramName;
+
+#ifdef HAVE_PROTO
+extern void say(const char *);
+#else
+extern void say();
+#endif
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesExitXCursesProcess(int rc,int sig,char *msg)
+#else
+void XCursesExitXCursesProcess(rc,sig,msg)
+int rc,sig;
+char *msg;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+#endif
+   if ( rc | sig )
+      fprintf( stderr, "%s:XCursesExitXCursesProcess() - called: rc:%d sig:%d <%s>\n",(XCursesProcess)?"     X":"CURSES",rc,sig,msg);
+   shmdt((char *)SP);
+   shmdt((char *)Xcurscr);
+   shmctl(shmidSP,IPC_RMID,0);
+   shmctl(shmid_Xcurscr,IPC_RMID,0);
+   XCursesEndwin();
+   shutdown(display_sock,2);
+   close(display_sock);
+   shutdown(exit_sock,2);
+   close(exit_sock);
+   shutdown(key_sock,2);
+   close(key_sock);
+   if (sig)
+      kill(otherpid,sig); /* to kill parent process */
+   _exit(rc);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesDisplayScreen(bool highlight)
+#else
+void XCursesDisplayScreen(highlight)
+bool highlight;
+#endif
+/***********************************************************************/
+/*---------------------------------------------------------------------*/
+/* This function re-draws the entire screen.                           */
+/*---------------------------------------------------------------------*/
+{
+   int row=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesDisplayScreen() - called:\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   for (row=0;row<XCursesLINES;row++)
+   {
+      while(*(Xcurscr+XCURSCR_FLAG_OFF+row))
+      {
+         /*
+          * Patch by:
+          * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+          */
+         dummy_function(); /* loop until we can write to the line */
+         /*
+          * End of patch by:
+          * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+          */
+      }
+      *(Xcurscr+XCURSCR_FLAG_OFF+row) = 1;
+      XCursesDisplayText((chtype *)(Xcurscr+XCURSCR_Y_OFF(row)),row,0,COLS,highlight);
+      *(Xcurscr+XCURSCR_FLAG_OFF+row) = 0;
+   }
+   XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                        SP->cursrow,SP->curscol);
+   /*
+    * Draw the border if required
+    */
+   if (XCURSESBORDERWIDTH)
+      XDrawRectangle(XCURSESDISPLAY,XCURSESWIN,border_gc,
+                    (XCURSESBORDERWIDTH/2),(XCURSESBORDERWIDTH/2),
+                    (XCursesWindowWidth-XCURSESBORDERWIDTH),
+                    (XCursesWindowHeight-XCURSESBORDERWIDTH));
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesRefreshScreen(void)
+#else
+int XCursesRefreshScreen()
+#endif
+/***********************************************************************/
+/*---------------------------------------------------------------------*/
+/* This function draws those portions of the screen that have changed. */
+/*---------------------------------------------------------------------*/
+{
+   int row=0,start_col=0,num_cols=0;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesRefreshScreen() - called:\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   for (row=0;row<XCursesLINES;row++)
+   {
+#if 0
+      num_cols = (int)*((int*)(Xcurscr+XCURSCR_LENGTH_OFF+row));
+printf("Num cols: %d\n",num_cols);
+#else
+      num_cols = (int)*(Xcurscr+XCURSCR_LENGTH_OFF+row);
+#endif
+      if (num_cols != 0)
+      {
+         while(*(Xcurscr+XCURSCR_FLAG_OFF+row))
+         {
+            /*
+             * Patch by:
+             * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+             */
+            dummy_function(); /* loop until we can write to the line */
+            /*
+             * End of patch by:
+             * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+             */
+         }
+         *(Xcurscr+XCURSCR_FLAG_OFF+row) = 1;
+#if 0
+         start_col = (int)*((int*)(Xcurscr+XCURSCR_START_OFF+row));
+printf("start_col: %d\n",start_col);
+#else
+         start_col = (int)*(Xcurscr+XCURSCR_START_OFF+row);
+#endif
+         XCursesDisplayText((chtype *)(Xcurscr+XCURSCR_Y_OFF(row)+(start_col*sizeof(chtype))),row,start_col,num_cols,FALSE);
+#if 0
+         *((int*)(Xcurscr+XCURSCR_LENGTH_OFF+row)) = 0;
+if ( (int)*(Xcurscr+XCURSCR_LENGTH_OFF+row) != 0 )
+    printf("%d difference: num_cols %d mem: %d\n",__LINE__,0,(int)*(Xcurscr+XCURSCR_LENGTH_OFF+row) );
+#else
+         *(Xcurscr+XCURSCR_LENGTH_OFF+row) = 0;
+#endif
+         *(Xcurscr+XCURSCR_FLAG_OFF+row) = 0;
+      }
+   }
+   if (mouse_selection)
+      SelectionOff();
+   XCursesDisplayCursor(SP->cursrow,SP->curscol,
+                        SP->cursrow,SP->curscol);
+   return(0);
+}
+
+/***********************************************************************/ 
+#ifdef HAVE_PROTO 
+void XCursesProcessRequestsFromCurses(XtPointer client_data,int *fid,XtInputId *id) 
+#else 
+void XCursesProcessRequestsFromCurses(client_data,fid,id) 
+XtPointer client_data; 
+int *fid; 
+XtInputId *id; 
+#endif 
+/***********************************************************************/ 
+{ 
+   int s,idx; 
+   int old_row,new_row; 
+   int old_x,new_x; 
+   int pos,num_cols; 
+   long length; 
+   char buf[12]; /* big enough for 2 integers */ 
+   char title[1024]; /* big enough for window title */ 
+   unsigned char save_atrtab[MAX_ATRTAB]; 
+ 
+#ifdef PDCDEBUG 
+   if (trace_on) PDC_debug("%s:XCursesProcessRequestsFromCurses()\n",(XCursesProcess)?"     X":"CURSES"); 
+#endif 
+ 
+   if (!ReceivedMapNotify) 
+      return; 
+   FD_ZERO ( &readfds ); 
+   FD_SET ( display_sock, &readfds ); 
+ 
+   if ( ( s = select ( FD_SETSIZE, (FD_SET_CAST)&readfds, NULL, NULL, &socket_timeout ) ) < 0 ) 
+      XCursesExitXCursesProcess(2,SIGKILL,"exiting from XCursesProcessRequestsFromCurses - select failed"); 
+             
+   if ( s == 0 ) /* no requests pending - should never happen!*/ 
+      return; 
+             
+   if ( FD_ISSET ( display_sock, &readfds ) ) 
+   { 
+/* read first integer to determine total message has been received */ 
+#ifdef PDCDEBUG 
+      if (trace_on) PDC_debug("%s:XCursesProcessRequestsFromCurses() - before read_socket()\n",(XCursesProcess)?"     X":"CURSES"); 
+#endif 
+      if (read_socket(display_sock,buf,sizeof(int)) < 0) 
+         XCursesExitXCursesProcess(3,SIGKILL,"exiting from XCursesProcessRequestsFromCurses - first read"); 
+#ifdef PDCDEBUG 
+      if (trace_on) PDC_debug("%s:XCursesProcessRequestsFromCurses() - after read_socket()\n",(XCursesProcess)?"     X":"CURSES"); 
+#endif 
+      memcpy((char *)&num_cols,buf,sizeof(int)); 
+      after_first_curses_request = True; 
+ 
+      switch(num_cols) 
+      { 
+         case 0: break; 
+         case CURSES_EXIT: /* request from curses to stop */ 
+            say("CURSES_EXIT received from child\n"); 
+            XCursesExitXCursesProcess(0,0,"XCursesProcess requested to exit by child"); 
+            break; 
+         case CURSES_BELL: /* request from curses to beep */ 
+            say("CURSES_BELL received from child\n"); 
+            XBell(XCURSESDISPLAY,50); 
+            break; 
+         case CURSES_CLEAR: /* request from curses to clear window */ 
+            say("CURSES_CLEAR received from child\n"); 
+            XClearWindow(XCURSESDISPLAY,XCURSESWIN); 
+            break; 
+         case CURSES_FLASH: /* request from curses to beep */ 
+            say("CURSES_FLASH received from child\n"); 
+#if 0 
+            XFillRectangle(XCURSESDISPLAY,XCURSESWIN,normal_highlight_gc,10,10,XCursesWindowWidth-10,XCursesWindowHeight-10); 
+            delay_output(50); 
+            XFillRectangle(XCURSESDISPLAY,XCURSESWIN,normal_highlight_gc,10,10,XCursesWindowWidth-10,XCursesWindowHeight-10); 
+            XCursesDisplayCursor(SP->cursrow,SP->curscol, 
+                                 SP->cursrow,SP->curscol); 
+#endif 
+            old_x = CURSES_CONTINUE; 
+            memcpy(buf,(char *)&old_x,sizeof(int)); 
+            if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            break; 
+         case CURSES_REFRESH: /* request from curses to confirm completion of display */ 
+            say("CURSES_REFRESH received from child\n"); 
+            visible_cursor = 1; 
+            XCursesRefreshScreen(); 
+            XCursesDisplayCursor(SP->cursrow,SP->curscol, 
+                                 SP->cursrow,SP->curscol); 
+            old_x = CURSES_CONTINUE; 
+            memcpy(buf,(char *)&old_x,sizeof(int)); 
+            if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            break; 
+         case CURSES_REFRESH_SCROLLBAR: /* request from curses draw scrollbar */ 
+            XCursesRefreshScrollbar(); 
+            break; 
+         case CURSES_CURSOR: /* display cursor */ 
+            say("CURSES_CURSOR received from child\n"); 
+            if (read_socket(display_sock,buf,sizeof(int)*2) < 0) 
+               XCursesExitXCursesProcess(5,SIGKILL,"exiting from CURSES_CURSOR XCursesProcessRequestsFromCurses"); 
+            memcpy((char *)&pos,buf,sizeof(int)); 
+            old_row = pos & 0xFF; 
+            old_x = pos >> 8; 
+            idx = sizeof(int); 
+            memcpy((char *)&pos,buf+idx,sizeof(int)); 
+            new_row = pos & 0xFF; 
+            new_x = pos >> 8; 
+            visible_cursor = 1; 
+            XCursesDisplayCursor(old_row,old_x,new_row,new_x); 
+            break; 
+         case CURSES_DISPLAY_CURSOR: /* display cursor */ 
+            say("CURSES_DISPLAY_CURSOR received from child. Vis now: ");
+            say(visible_cursor ? "1\n" : "0\n");
+            /* 
+             * If the window is not active, ignore this command. The 
+             * cursor will stay solid. 
+             */ 
+            if ( windowEntered ) 
+            { 
+               if ( visible_cursor ) 
+               { 
+                  /* 
+                   * Cursor currently ON, turn it off 
+                   */ 
+                  int save_visibility = SP->visibility; 
+                  SP->visibility = 0; 
+                  XCursesDisplayCursor(SP->cursrow,SP->curscol, 
+                                       SP->cursrow,SP->curscol); 
+                  SP->visibility = save_visibility; 
+                  visible_cursor = 0; 
+               } 
+               else 
+               { 
+                  /* 
+                   * Cursor currently OFF, turn it on 
+                   */ 
+                  XCursesDisplayCursor(SP->cursrow,SP->curscol, 
+                                       SP->cursrow,SP->curscol); 
+                  visible_cursor = 1; 
+               } 
+            } 
+            break; 
+         case CURSES_TITLE: /* display window title */ 
+            say("CURSES_TITLE received from child\n"); 
+            if (read_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(5,SIGKILL,"exiting from CURSES_TITLE XCursesProcessRequestsFromCurses"); 
+            memcpy((char *)&pos,buf,sizeof(int)); 
+            if (read_socket(display_sock,title,pos) < 0) 
+               XCursesExitXCursesProcess(5,SIGKILL,"exiting from CURSES_TITLE XCursesProcessRequestsFromCurses"); 
+            XtVaSetValues(topLevel, XtNtitle, title, NULL); 
+            break; 
+         case CURSES_RESIZE: /* resize window */ 
+            after_first_curses_request = False; 
+            say("CURSES_RESIZE received from child\n"); 
+            SP->lines = XCursesLINES = ((resizeXCursesWindowHeight-(2*XCURSESBORDERWIDTH)) / XCursesFontHeight); 
+            LINES = XCursesLINES - SP->linesrippedoff - SP->slklines; 
+            SP->cols =  COLS  = XCursesCOLS = ((resizeXCursesWindowWidth-(2*XCURSESBORDERWIDTH)) / XCursesFontWidth); 
+            XCursesWindowWidth = resizeXCursesWindowWidth; 
+            XCursesWindowHeight = resizeXCursesWindowHeight; 
+            visible_cursor = 1; 
+            /* 
+             * Draw the border if required 
+             */ 
+            if (XCURSESBORDERWIDTH) 
+               XDrawRectangle(XCURSESDISPLAY,XCURSESWIN,border_gc, 
+                             (XCURSESBORDERWIDTH/2),(XCURSESBORDERWIDTH/2), 
+                             (XCursesWindowWidth-XCURSESBORDERWIDTH), 
+                             (XCursesWindowHeight-XCURSESBORDERWIDTH)); 
+/* 
+ * detach and drop the current shared memory segment and create and attach 
+ * to a new segment. 
+ */ 
+            memcpy(save_atrtab,atrtab,sizeof(save_atrtab)); 
+            SP->XcurscrSize = XCURSCR_SIZE; 
+            shmdt((char *)Xcurscr); 
+            shmctl(shmid_Xcurscr,IPC_RMID,0); 
+            if ((shmid_Xcurscr = shmget(shmkey_Xcurscr,SP->XcurscrSize+XCURSESSHMMIN,0700|IPC_CREAT)) < 0) 
+            { 
+               perror("Cannot allocate shared memory for curscr"); 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            } 
+            Xcurscr = (unsigned char*)shmat(shmid_Xcurscr,0,0); 
+            memset(Xcurscr, 0, SP->XcurscrSize);  
+            atrtab = (unsigned char *)(Xcurscr+XCURSCR_ATRTAB_OFF); 
+            memcpy(atrtab,save_atrtab,sizeof(save_atrtab)); 
+ 
+            old_x = CURSES_CONTINUE; 
+            memcpy(buf,(char *)&old_x,sizeof(int)); 
+            if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            break; 
+         case CURSES_GET_SELECTION: /* request selection contents */ 
+            say("CURSES_GET_SELECTION received from child\n"); 
+            old_x = CURSES_CONTINUE; 
+            memcpy(buf,(char *)&old_x,sizeof(int)); 
+            if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            XtGetSelectionValue(topLevel,XA_PRIMARY,XA_STRING,XCursesRequestorCallbackForGetSelection,(XtPointer)NULL,0); 
+            break; 
+         case CURSES_SET_SELECTION: /* set the selection contents */ 
+            say("CURSES_SET_SELECTION received from child\n"); 
+            if (read_socket(display_sock,buf,sizeof(long)) < 0) 
+               XCursesExitXCursesProcess(5,SIGKILL,"exiting from CURSES_TITLE XCursesProcessRequestsFromCurses"); 
+            memcpy((char *)&length,buf,sizeof(long)); 
+            if (length > tmpsel_length) 
+            { 
+               if (tmpsel_length == 0) 
+                  tmpsel = (char *)malloc(length+1); 
+               else 
+                  tmpsel = (char *)realloc(tmpsel,length+1); 
+            } 
+            if (!tmpsel) 
+            { 
+               old_x = PDC_CLIP_MEMORY_ERROR; 
+               memcpy(buf,(char *)&old_x,sizeof(int)); 
+               if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+                  XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+               break; 
+            } 
+            if (read_socket(display_sock,tmpsel,length) < 0) 
+               XCursesExitXCursesProcess(5,SIGKILL,"exiting from CURSES_TITLE XCursesProcessRequestsFromCurses"); 
+            tmpsel_length = length; 
+            *(tmpsel+length) = '\0'; 
+            if (XtOwnSelection(topLevel, 
+                               XA_PRIMARY, 
+                               CurrentTime, 
+                               XCursesConvertProc, 
+                               XCursesLoseOwnership, 
+                               NULL) == False) 
+            { 
+               old_x = PDC_CLIP_ACCESS_ERROR; 
+               free(tmpsel); 
+               tmpsel = NULL; 
+               tmpsel_length = 0; 
+            } 
+            else 
+               old_x = PDC_CLIP_SUCCESS; 
+            SelectionOff(); 
+            memcpy(buf,(char *)&old_x,sizeof(int)); 
+            if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            break; 
+         case CURSES_CLEAR_SELECTION: /* request clear of selection */
+            say("CURSES_CLEAR_SELECTION received from child\n");
+            old_x = CURSES_CONTINUE; 
+            memcpy(buf,(char *)&old_x,sizeof(int)); 
+            if (write_socket(display_sock,buf,sizeof(int)) < 0) 
+               XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesProcessRequestsFromCurses"); 
+            SelectionOff(); 
+            break; 
+         default: 
+#ifdef PDCDEBUG 
+            if (trace_on) PDC_debug("%s:Unknown request %d\n",(XCursesProcess)?"     X":"CURSES",num_cols); 
+#endif 
+            break; 
+      } 
+   } 
+   return; 
+} 
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesSetupX(char *display_name,int argc, char *argv[])
+#else
+int XCursesSetupX(display_name,argc,argv)
+char *display_name;
+int arc;
+char *argv[];
+#endif
+/***********************************************************************/
+{
+   extern bool sb_started;
+
+   int italic_font_valid;
+   XColor pointerforecolor,pointerbackcolor;
+   XrmValue rmfrom,rmto;
+   XWMHints wmhints;
+   char wait_buf[5];
+   int wait_value=0,i=0;
+   int minwidth=0,minheight=0;
+   int myargc;
+   char *myargv[2];
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesSetupX called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   /*
+    * The following kludge is to force XtVaAppInitialize() to recognize the
+    * name of the program.  Without it, a default value of "main" is used.
+    */
+   if (argv)
+   {
+/*      argv[0] = XCursesProgramName; */
+      XCursesProgramName = argv[0];
+#ifdef PDCDEBUG1
+      for (i=0;i<argc;i++)
+         printf("Arg: %d -> %s\n",i,argv[i]);
+#endif
+   }
+   else
+   {
+      /*
+       * initscr() called rather than initscrX()
+       */
+      XCursesProgramName = myargv[0] = "main";
+      myargv[1] = NULL;
+      myargc=1;
+   }
+
+   /*
+    * Keep open the 'write' end of the socket so the XCurses process can
+    * send a CURSES_EXIT to itself from within the signal handler...
+    */
+#if 0
+   close ( display_sockets[0] );
+#else
+   exit_sock = display_sockets[0];
+#endif
+   display_sock = display_sockets[1];
+   close ( key_sockets[0] );
+   key_sock = key_sockets[1];
+   /*
+    * Trap all signals when XCurses is the child process... 
+    * ...but only if they haven't already been ignored by the
+    * application.
+    */
+   for ( i = 0; i < PDC_MAX_SIGNALS; i++ )
+   {
+      if ( XCursesSetSignal( i, XCursesSignalHandler) == SIG_IGN )
+         XCursesSetSignal( i, SIG_IGN );
+   }
+   /*
+    * Start defining X Toolkit things...
+    */
+#if XtSpecificationRelease > 4
+   XtSetLanguageProc(NULL, (XtLanguageProc)NULL,NULL);
+#endif
+   /*
+    * If a DISPLAY value has been supplied, set the env variable DISPLAY.
+    */
+   if (display_name)
+   {
+      strcpy(global_display_name,"DISPLAY=");
+      strcat(global_display_name,display_name);
+      putenv(global_display_name);
+   }
+   /*
+    * Exit if no DISPLAY variable set...
+    */
+   if (getenv("DISPLAY") == NULL)
+   {
+      fprintf(stderr,"Error: no DISPLAY variable set\n");
+      kill(otherpid,SIGKILL);
+      return(ERR);
+   }
+   /*
+    * Initialise the top level widget...
+    */
+   if (argv)
+   {
+      topLevel = XtVaAppInitialize( &app_context,
+                                    XCursesClassName,
+                                    options,
+                                    XtNumber(options),
+                                    &argc,
+                                    argv,
+                                    NULL,
+/*
+                              XtNinput, (XtArgVal)True,
+                              XtNtitle,XCursesProgramName,
+                              XtNname,"xcurses",
+*/
+                              NULL);
+   }
+   else
+   {
+      topLevel = XtVaAppInitialize( &app_context,
+                                    XCursesClassName,
+                                    options,
+                                    XtNumber(options),
+                                    &myargc,
+                                    myargv,
+                                    NULL,
+/*
+                              XtNinput, (XtArgVal)True,
+                              XtNtitle,XCursesProgramName,
+                              XtNname,"xcurses",
+*/
+                              NULL);
+   }
+#if 0
+      for (i=0;i<argc;i++)
+         printf("Arg: %d -> %s\n",i,argv[i]);
+#endif
+
+   XtVaGetApplicationResources(topLevel,&app_data,app_resources,XtNumber(app_resources),NULL);
+   /* check application resource values here... */
+
+#if 0
+printf("Width %d Height %d\n",XCURSESGEOMETRY.width,XCURSESGEOMETRY.height);
+#endif
+
+   XCursesFontWidth = XCURSESNORMALFONTINFO->max_bounds.rbearing - XCURSESNORMALFONTINFO->min_bounds.lbearing;
+   XCursesFontHeight = XCURSESNORMALFONTINFO->max_bounds.ascent + XCURSESNORMALFONTINFO->max_bounds.descent;
+   XCursesFontAscent = XCURSESNORMALFONTINFO->max_bounds.ascent;
+   XCursesFontDescent = XCURSESNORMALFONTINFO->max_bounds.descent;
+
+   /*
+    * Check that the italic font and normal fonts are the same size...
+    */
+   if (XCursesFontWidth != XCURSESITALICFONTINFO->max_bounds.rbearing - XCURSESITALICFONTINFO->min_bounds.lbearing
+   ||  XCursesFontHeight != XCURSESITALICFONTINFO->max_bounds.ascent + XCURSESITALICFONTINFO->max_bounds.descent)
+   {
+      italic_font_valid = 1;
+   }
+   else
+   {
+      italic_font_valid = 0;
+   }
+
+   /*
+    * Calculate size of display window...
+    */
+   XCursesCOLS = XCURSESCOLS;
+   XCursesLINES = XCURSESLINES;
+   XCursesWindowWidth = (XCursesFontWidth * XCursesCOLS) + (2 * XCURSESBORDERWIDTH);
+   XCursesWindowHeight = (XCursesFontHeight * XCursesLINES) + (2 * XCURSESBORDERWIDTH);
+   minwidth = (XCursesFontWidth*2)+(XCURSESBORDERWIDTH*2);
+   minheight = (XCursesFontHeight*2)+(XCURSESBORDERWIDTH*2);
+   /*
+    * Set up the icon for the application. The default is an internal one
+    * for XCurses. Then set various application level resources...
+    */
+   XCursesGetIcon();
+   
+#ifdef HAVE_XPM_H
+   if (XCURSESPIXMAPFILE != NULL)
+   {
+      XtVaSetValues( topLevel,
+                     XtNminWidth,minwidth,
+                     XtNminHeight,minheight,
+                     XtNiconPixmap,icon_pixmap,
+                     XtNiconMask,icon_pixmap_mask,
+                     NULL);
+   }
+   else
+   {
+      XtVaSetValues( topLevel,
+                     XtNminWidth,minwidth,
+                     XtNminHeight,minheight,
+                     XtNiconPixmap,icon_bitmap,
+                     NULL);
+   }
+#else
+   XtVaSetValues( topLevel,
+                  XtNminWidth,minwidth,
+                  XtNminHeight,minheight,
+                  XtNiconPixmap,icon_bitmap,
+                  NULL);
+#endif
+   /*
+    * Create a BOX widget in which to draw...
+    */
+#if 0
+   fprintf(stderr,"SB Width: %d Width: %d Height: %d sb_started: %d\n",
+                   XCURSESSCROLLBARWIDTH,
+                   XCursesWindowWidth+XCURSESSCROLLBARWIDTH,
+                   XCursesWindowHeight+XCURSESSCROLLBARWIDTH,
+                   sb_started);
+#endif
+   if (XCURSESSCROLLBARWIDTH != 0
+   && sb_started)
+   {
+      scrollBox = XtVaCreateManagedWidget(XCursesProgramName,scrollBoxWidgetClass,topLevel,
+                                          XtNwidth,XCursesWindowWidth+XCURSESSCROLLBARWIDTH,
+                                          XtNheight,XCursesWindowHeight+XCURSESSCROLLBARWIDTH,
+                                          XtNwidthInc,XCursesFontWidth,
+                                          XtNheightInc,XCursesFontHeight,
+                                          NULL);
+      drawing = XtVaCreateManagedWidget(XCursesProgramName,boxWidgetClass,
+                                        scrollBox,
+                                        XtNwidth,XCursesWindowWidth,
+                                        XtNheight,XCursesWindowHeight,
+                                        XtNwidthInc,XCursesFontWidth,
+                                        XtNheightInc,XCursesFontHeight,
+                                        NULL);
+      scrollVert = XtVaCreateManagedWidget("scrollVert", scrollbarWidgetClass,
+                                           scrollBox,
+                                           XtNorientation, XtorientVertical,
+                                           XtNheight, XCursesWindowHeight,
+                                           XtNwidth, XCURSESSCROLLBARWIDTH,
+                                           NULL);
+      XtAddCallback(scrollVert, XtNscrollProc, Scroll_up_down, drawing);
+      XtAddCallback(scrollVert, XtNjumpProc, Thumb_up_down, drawing);
+      scrollHoriz = XtVaCreateManagedWidget("scrollHoriz", scrollbarWidgetClass, 
+                                            scrollBox,
+                                            XtNorientation, XtorientHorizontal,
+                                            XtNwidth, XCursesWindowWidth,
+                                            XtNheight, XCURSESSCROLLBARWIDTH,
+                                            NULL);
+      XtAddCallback(scrollHoriz, XtNscrollProc, Scroll_left_right, drawing);
+      XtAddCallback(scrollHoriz, XtNjumpProc, Thumb_left_right, drawing);
+   }
+   else
+   {
+      drawing = XtVaCreateManagedWidget(XCursesProgramName,boxWidgetClass,topLevel,
+                                        XtNwidth,XCursesWindowWidth,
+                                        XtNheight,XCursesWindowHeight,
+                                        XtNwidthInc,XCursesFontWidth,
+                                        XtNheightInc,XCursesFontHeight,
+                                        NULL);
+      XtVaSetValues( topLevel,
+                     XtNwidthInc,XCursesFontWidth,
+                     XtNheightInc,XCursesFontHeight,
+                     NULL);
+   }
+
+#if 0
+   fprintf(stderr,"Width: %d Height: %d FontWidth: %d FontHeight: %d\n",XCursesWindowWidth+XCURSESSCROLLBARWIDTH,
+                                   XCursesWindowHeight+XCURSESSCROLLBARWIDTH,
+                                        XCursesFontWidth,
+                                        XCursesFontHeight);
+#endif
+/*
+ XtVaSetValues(drawing,
+                                   XtNwidth,XCursesWindowWidth,
+                                   XtNheight,XCursesWindowHeight,
+                              XtNwidthInc,XCursesFontWidth,
+                              XtNheightInc,XCursesFontHeight,
+                              XtNminWidth,XCursesFontWidth*2,
+                              XtNminHeight,XCursesFontHeight*2,
+                        XtNborderWidth,20,
+               NULL);
+*/
+   /*
+    * Process any default translations...
+    */
+   XCursesTranslations = XtParseTranslationTable(defaultTranslations);
+   XtAugmentTranslations(drawing,XCursesTranslations);
+   XtAppAddActions(app_context,XCursesActions,XtNumber(XCursesActions));
+   /*
+    * Process the supplied colors...
+    */
+   if (get_colors() == ERR)
+   {
+      kill(otherpid,SIGKILL);
+      return(ERR);
+   }
+   /*
+    * Determine text cursor alignment from resources
+    */
+   if ( strcmp( XCURSESTEXTCURSOR, "vertical" ) == 0 )
+      vertical_cursor = True;
+   /*
+    * Now have LINES and COLS. Set these in the shared SP so the
+    * curses program can find them...
+    */
+   LINES = XCursesLINES;
+   COLS = XCursesCOLS;
+   if ((shmidSP = shmget(shmkeySP,sizeof(SCREEN)+XCURSESSHMMIN,0700|IPC_CREAT)) < 0)
+   {
+      perror("Cannot allocate shared memory for SCREEN");
+      kill(otherpid,SIGKILL);
+      return(ERR);
+   }
+   SP = (SCREEN*)shmat(shmidSP,0,0);
+   memset(SP, 0, sizeof(SCREEN));
+   SP->XcurscrSize = XCURSCR_SIZE;
+   SP->lines = XCursesLINES;
+   SP->cols = XCursesCOLS;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:SHM size for curscr %d\n",(XCursesProcess)?"     X":"CURSES",SP->XcurscrSize);
+#endif
+   if ((shmid_Xcurscr = shmget(shmkey_Xcurscr,SP->XcurscrSize+XCURSESSHMMIN,0700|IPC_CREAT)) < 0)
+   {
+      perror("Cannot allocate shared memory for curscr");
+      kill(otherpid,SIGKILL);
+      shmdt((char *)SP);
+      shmctl(shmidSP,IPC_RMID,0);
+      return(ERR);
+   }
+   Xcurscr = (unsigned char *)shmat(shmid_Xcurscr,0,0);
+   memset(Xcurscr, 0, SP->XcurscrSize); 
+   atrtab = (unsigned char *)(Xcurscr+XCURSCR_ATRTAB_OFF);
+   PDC_init_atrtab();
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:shmid_Xcurscr %d shmkey_Xcurscr %d LINES %d COLS %d\n",(XCursesProcess)?"     X":"CURSES",shmid_Xcurscr,shmkey_Xcurscr,LINES,COLS);
+#endif
+   /*
+    * Add Event handlers to the drawing widget...
+    */
+   XtAddEventHandler(drawing,ExposureMask,False,XCursesExpose,NULL);
+   /* XtAddEventHandler(drawing,KeyPressMask|KeyReleaseMask,False,XCursesKeyPressKeyRelease,NULL); */
+   /* XtAddEventHandler(drawing,ButtonPressMask|ButtonReleaseMask,False,XCursesButtonPressButtonRelease,NULL);*/
+   XtAddEventHandler(drawing,StructureNotifyMask,False,XCursesStructureNotify,NULL);
+   XtAddEventHandler(drawing,EnterWindowMask|LeaveWindowMask,False,XCursesEnterLeaveWindow,NULL);
+#if 0
+   XtAddEventHandler(drawing,0,True,XCursesNonmaskable,NULL);
+#endif
+   XtAddEventHandler(topLevel,0,True,XCursesNonmaskable,NULL);
+   /*
+    * Add input handler from display_sock (requests from curses program)
+    */
+   XtAppAddInput( app_context, display_sock, (XtPointer)XtInputReadMask, XCursesProcessRequestsFromCurses, NULL );
+   /*
+    * If there is a cursorBlink resource, start the Timeout event...
+    */
+   if ( XCURSESCURSORBLINKRATE )
+   {
+      XtAppAddTimeOut( app_context, XCURSESCURSORBLINKRATE, XCursesCursorBlink, NULL );
+   }
+   /*
+    * Leave telling the curses process that it can start to here so that
+    * when the curses process makes a request, the Xcurses process can
+    * service the request...
+    */
+   wait_value = CURSES_CHILD;
+   memcpy(wait_buf,(char *)&wait_value,sizeof(int));
+   (void)write_socket(display_sock,wait_buf,sizeof(int));
+   /*
+    * Realize the widget...
+    */
+   XtRealizeWidget(topLevel);
+   /*
+    * Handle trapping of the WM_DELETE_WINDOW property...
+    */
+   wm_atom[0] = XInternAtom(XtDisplay(topLevel),"WM_DELETE_WINDOW",False);
+/*   wm_atom[1] = XInternAtom(XtDisplay(topLevel),"WM_SAVE_YOURSELF",False); */
+   /* (void)XSetWMProtocols(XtDisplay(topLevel),RootWindowOfScreen(XtScreen(topLevel)),&wm_delete_window_atom,1);*/
+   /* (void)XSetWMProtocols(XtDisplay(topLevel),XCURSESWIN,&wm_delete_window_atom,1);*/
+   (void)XSetWMProtocols(XtDisplay(topLevel),XtWindow(topLevel),wm_atom,1); /* was 2 with WM_SAVE_YOURSELF included */
+   /*
+    * Create the Graphics Context for drawing. This MUST be done AFTER the
+    * associated widget has been realized...
+    */
+#ifdef PDCDEBUG
+   say("before get_GC\n");
+#endif
+   get_GC(XCURSESDISPLAY,XCURSESWIN,&normal_gc,XCURSESNORMALFONTINFO,COLOR_WHITE,COLOR_BLACK,FALSE);
+   if ( italic_font_valid )
+   {
+      get_GC(XCURSESDISPLAY,XCURSESWIN,&italic_gc,XCURSESITALICFONTINFO,COLOR_WHITE,COLOR_BLACK,FALSE);
+   }
+   else
+   {
+      get_GC(XCURSESDISPLAY,XCURSESWIN,&italic_gc,XCURSESNORMALFONTINFO,COLOR_WHITE,COLOR_BLACK,FALSE);
+   }
+   get_GC(XCURSESDISPLAY,XCURSESWIN,&block_cursor_gc,XCURSESNORMALFONTINFO,COLOR_BLACK,COLOR_CURSOR,FALSE);
+   get_GC(XCURSESDISPLAY,XCURSESWIN,&rect_cursor_gc,XCURSESNORMALFONTINFO,COLOR_CURSOR,COLOR_BLACK,FALSE);
+   get_GC(XCURSESDISPLAY,XCURSESWIN,&border_gc,XCURSESNORMALFONTINFO,COLOR_BORDER,COLOR_BLACK,FALSE);
+   /*
+   XSetLineAttributes(XCURSESDISPLAY,normal_gc,2,LineSolid,CapButt,JoinMiter);
+   */
+   XSetLineAttributes(XCURSESDISPLAY,rect_cursor_gc,2,LineSolid,CapButt,JoinMiter);
+   XSetLineAttributes(XCURSESDISPLAY,border_gc,XCURSESBORDERWIDTH,LineSolid,CapButt,JoinMiter);
+   /*
+    * Set the cursor for the application...
+    */
+   XDefineCursor(XCURSESDISPLAY,XCURSESWIN,XCURSESPOINTER);
+   rmfrom.size = sizeof(Pixel);
+   rmto.size = sizeof(XColor);
+#if XtSpecificationRelease > 4
+   rmto.addr = (XPointer)&pointerforecolor;
+   rmfrom.addr = (XPointer)&(XCURSESPOINTERFORECOLOR);
+   XtConvertAndStore(drawing,XtRPixel,&rmfrom,XtRColor,&rmto);
+#else
+   rmto.addr = (char *)&pointerforecolor;
+   rmfrom.addr = (char *)&(XCURSESPOINTERFORECOLOR);
+   XtConvert(drawing,XtRPixel,&rmfrom,XtRColor,&rmto);
+#endif
+   rmfrom.size = sizeof(Pixel);
+   rmto.size = sizeof(XColor);
+#if XtSpecificationRelease > 4
+   rmfrom.addr = (XPointer)&(XCURSESPOINTERBACKCOLOR);
+   rmto.addr = (XPointer)&pointerbackcolor;
+   XtConvertAndStore(drawing,XtRPixel,&rmfrom,XtRColor,&rmto);
+#else
+   rmfrom.addr = (char *)&(XCURSESPOINTERBACKCOLOR);
+   rmto.addr = (char *)&pointerbackcolor;
+   XtConvert(drawing,XtRPixel,&rmfrom,XtRColor,&rmto);
+#endif
+   XRecolorCursor(XCURSESDISPLAY,XCURSESPOINTER,&pointerforecolor,&pointerbackcolor);
+   /*
+    * Convert the supplied compose key to a Keysym...
+    */
+   compose_key = XStringToKeysym(XCURSESCOMPOSEKEY);
+   if (compose_key
+   &&  IsModifierKey(compose_key))
+   {
+      register int i=0,j=0;
+      KeyCode *kcp;
+      XModifierKeymap *map;
+      KeyCode compose_keycode=XKeysymToKeycode(XCURSESDISPLAY,compose_key);
+      map = XGetModifierMapping(XCURSESDISPLAY);
+      kcp = map->modifiermap;
+      for (i=0;i<8;i++)
+      {
+         for (j=0;j<map->max_keypermod;j++,kcp++)
+         {
+            if (!*kcp)
+               continue;
+            if (compose_keycode == *kcp)
+            {
+               compose_mask = state_mask[i];
+               break;
+            }
+         }
+         if (compose_mask)
+            break;
+      }
+      XFreeModifiermap(map);
+   }
+   /* fprintf(stderr,"COMPOSE KEY: %d %s STATE: %d\n",compose_key,XCURSESCOMPOSEKEY,compose_mask);*/
+   
+#ifdef FOREIGN
+   sleep(20);
+   if ((Xim = XOpenIM(XCURSESDISPLAY,NULL,NULL,NULL)) == NULL)
+   {
+      perror("Cannot open Input Method");
+      kill(otherpid,SIGKILL);
+      shmdt((char *)SP);
+      shmdt((char *)Xcurscr);
+      shmctl(shmidSP,IPC_RMID,0);
+      shmctl(shmid_Xcurscr,IPC_RMID,0);
+      return(ERR);
+   }
+   XGetIMValues(Xim,XNQueryInputStyle, &im_supported_styles, NULL);
+   my_style = XIMPreeditNone|XIMStatusNone;
+   /* call XtCvtStringToFontSet ??? */
+   if ((Xic = XCreateIC(Xim, XNInputStyle, my_style,
+   /*
+   
+   */
+                         NULL)) == NULL)
+   {
+      perror("ERROR: Cannot create input context");
+      kill(otherpid,SIGKILL);
+      shmdt((char *)SP);
+      shmdt((char *)Xcurscr);
+      shmctl(shmidSP,IPC_RMID,0);
+      shmctl(shmid_Xcurscr,IPC_RMID,0);
+      return(ERR);
+   }
+   XFree(im_supported_styles);
+   XGetICValues(Xic, XNFilterEvents, &im_event_mask, NULL);
+   XtAddEventHandler(drawing,im_event_mask,False,NULL,NULL);
+   XSetICFocus(Xic);
+#endif
+   /*
+    * Keep focus on Click-to-front window managers
+    * Change courtesy of Jean-Pierre Demailly
+    */
+   wmhints.flags = InputHint;
+   wmhints.input = True;
+   XSetWMHints(XtDisplay(topLevel), XtWindow(topLevel), &wmhints);
+#if 0
+   XSetInputFocus(XtDisplay(topLevel), XtWindow(topLevel),
+                  RevertToNone, CurrentTime);
+
+   XSetInputFocus(XtDisplay(drawing), XtWindow(drawing),
+                  RevertToNone, CurrentTime);
+#endif
+   /*
+    * Wait for events...
+    */
+   XtAppMainLoop(app_context);
+   return(OK); /* won't get here */
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+RETSIGTYPE XCursesSignalHandler(int signo)
+#else
+RETSIGTYPE XCursesSignalHandler(signo)
+int signo;
+#endif
+/***********************************************************************/
+{
+   char buf[10];
+   int flag = CURSES_EXIT;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesSignalHandler() - called: %d\n",(XCursesProcess)?"     X":"CURSES",signo);
+#endif
+   /*
+    * Patch by:
+    * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 04-Dec-1998
+    */
+   XCursesSetSignal(signo,XCursesSignalHandler);
+#ifdef SIGTSTP
+   if (signo == SIGTSTP) { pause(); return; }
+#endif
+#ifdef SIGCONT
+   if (signo == SIGCONT) return;
+#endif
+#ifdef SIGCLD
+   if (signo == SIGCLD) return;
+#endif
+#ifdef SIGTTIN
+   if (signo == SIGTTIN) return;
+#endif
+#ifdef SIGWINCH
+   if (signo == SIGWINCH) return;
+#endif
+   /*
+    * End of patch by:
+    * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 04-Dec-1998
+    */
+   XCursesSetSignal(signo,SIG_IGN);
+   /*
+    * Send a CURSES_EXIT to myself...
+    */
+   memcpy(buf,(char *)&flag,sizeof(int));
+   if (write_socket(exit_sock,buf,sizeof(int)) < 0)
+      XCursesExitXCursesProcess(7,signo,"exitting from XCursesSignalHandler");
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesRequestorCallbackForGetSelection(Widget w,XtPointer data, Atom *selection,
+                                     Atom *type, XtPointer value, 
+                                     unsigned long *length, int *format)
+#else
+void XCursesRequestorCallbackForGetSelection(w,data,selection,type,value,length,format)
+Widget w;
+XtPointer data;
+Atom *selection;
+Atom *type;
+XtPointer value;
+unsigned long *length;
+int *format;
+#endif
+/***********************************************************************/
+{
+   int rc;
+   char buf[12]; /* big enough for 2 integers */
+   char *string=(char *)value;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesRequestorCallbackForSelection() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   if ((value == NULL) && (*length == 0))
+   {
+      rc = PDC_CLIP_EMPTY;
+      memcpy(buf,(char *)&rc,sizeof(int));
+      if (write_socket(display_sock,buf,sizeof(int)) < 0)
+         XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesRequestorCallbackForGetSelection");
+      return;
+   }
+   /*
+    * Here all is OK, send PDC_CLIP_SUCCESS, then length, then contents
+    */
+   rc = PDC_CLIP_SUCCESS;
+   memcpy(buf,(char *)&rc,sizeof(int));
+   if (write_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesRequestorCallbackForGetSelection");
+
+   rc = *(length);
+   memcpy(buf,(char *)&rc,sizeof(int));
+   if (write_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesRequestorCallbackForGetSelection");
+
+   if (write_socket(display_sock,string,*length) < 0)
+      XCursesExitXCursesProcess(4,SIGKILL,"exiting from XCursesRequestorCallbackForGetSelection");
+
+   return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesStructureNotify(Widget w,XtPointer client_data,XEvent *event,Boolean *continue_to_dispatch)
+#else
+void XCursesStructureNotify(w,client_data,event,continue_to_dispatch)
+Widget w;
+XtPointer client_data;
+XEvent *event;
+Boolean *continue_to_dispatch;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesStructureNotify called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+#if 0
+printf("Notify: %d\n",event->type);
+#endif
+   switch(event->type)
+   {
+      case ConfigureNotify:
+#ifdef PDCDEBUG
+         say("ConfigureNotify received\n");
+#endif
+         /* window has been resized, change width and
+          * height to send to place_text and place_graphics
+          * in next Expose.
+          * Also will  need to kill (SIGWINCH) curses process if screen
+          * size changes
+          */
+         resizeXCursesWindowWidth = (event->xconfigure.width);
+         resizeXCursesWindowHeight = (event->xconfigure.height);
+               
+         after_first_curses_request = False;
+#ifdef SIGWINCH
+# ifdef BEFORE_CHANGE_BY_G_FUCHS
+/*
+ * Patch by:
+ * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+ */
+# else
+         SP->resized = 1;
+# endif
+         kill(otherpid,SIGWINCH);
+#endif
+         XCursesSendKeyToCurses( (unsigned long)KEY_RESIZE, NULL );
+         break;
+      case MapNotify:
+#ifdef PDCDEBUG
+         say("MapNotify received\n");
+#endif
+         ReceivedMapNotify=1;
+         /*
+          * Draw the window border
+          */
+         if (XCURSESBORDERWIDTH)
+            XDrawRectangle(XCURSESDISPLAY,XCURSESWIN,border_gc,
+                          (XCURSESBORDERWIDTH/2),(XCURSESBORDERWIDTH/2),
+                          (XCursesWindowWidth-XCURSESBORDERWIDTH),
+                          (XCursesWindowHeight-XCURSESBORDERWIDTH));
+         break;
+      default:
+#ifdef PDCDEBUG
+         if (trace_on) PDC_debug("%s:XCursesStructureNotify - unknown event %d\n",(XCursesProcess)?"     X":"CURSES",event->type);
+#endif
+         break;
+   }
+   return;
+}
diff -Naur gdb-6.8/pdcurses/x11/process/x11common.c stsgdb-6.8/pdcurses/x11/process/x11common.c
--- gdb-6.8/pdcurses/x11/process/x11common.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/process/x11common.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,143 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+*
+* This file is NOT public domain software.  It is Copyright, Mark Hessling
+* 1994-2000.
+***************************************************************************
+*/
+
+#include "pdcx11.h"
+/* 
+ * Variables specific to process port
+ */
+unsigned char *Xcurscr;
+int XCursesProcess=1;
+int shmidSP;
+int shmid_Xcurscr;
+int shmkeySP;
+int shmkey_Xcurscr;
+int otherpid;
+int XCursesLINES=24;
+int XCursesCOLS=80;
+int display_sock;
+int key_sock;
+int display_sockets[2];
+int key_sockets[2];
+int exit_sock;
+
+fd_set readfds;
+fd_set writefds;
+struct timeval socket_timeout;
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int write_socket(int sock_num,char *buf,int len)
+#else
+int write_socket(sock_num,buf,len)
+int sock_num;
+char *buf;
+int len;
+#endif
+/***********************************************************************/
+{
+   int start=0,length=len,rc;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:write_socket called: sock_num %d len %d\n",(XCursesProcess)?"     X":"CURSES",sock_num,len);
+#endif
+#ifdef MOUSE_DEBUG1
+if (sock_num == key_sock)
+    printf("%s:write_socket(key) len: %d\n",(XCursesProcess)?"     X":"CURSES",len);
+#endif
+   while(1)
+   {
+      rc = write(sock_num,buf+start,length);
+      if (rc < 0
+      ||  rc == length)
+         return(rc);
+      length -= rc;
+      start = rc;
+   }
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int read_socket(int sock_num,char *buf,int len)
+#else
+int read_socket(sock_num,buf,len)
+int sock_num;
+char *buf;
+int len;
+#endif
+/***********************************************************************/
+{
+   int start=0,length=len,rc;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:read_socket called: sock_num %d len %d\n",(XCursesProcess)?"     X":"CURSES",sock_num,len);
+#endif
+   while(1)
+   {
+      rc = read(sock_num,buf+start,length);
+#ifdef MOUSE_DEBUG1
+     if (sock_num == key_sock)
+       printf("%s:read_socket(key) rc %d errno %d resized: %d\n",(XCursesProcess)?"     X":"CURSES",
+                                                        rc,errno,SP->resized);
+#endif
+      if (rc < 0
+      && sock_num == key_sock
+      && errno == EINTR
+#ifdef BEFORE_CHANGE_BY_G_FUCHS
+/*
+ * Patch by:
+ * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+ */
+      && SP->resized == TRUE)
+      {
+#ifdef MOUSE_DEBUG1
+       printf("%s:continuing\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+         rc = 0;
+#else
+      && SP->resized != FALSE)
+      {
+#ifdef MOUSE_DEBUG1
+       printf("%s:continuing\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+         rc = 0;
+         if (SP->resized > 1)
+            SP->resized = TRUE;
+         else
+            SP->resized = FALSE;
+#endif
+         memcpy(buf,(char *)&rc,sizeof(int));
+         return(0); /* must be >= 0 to avoid error */
+      }
+
+#ifdef BEFORE_CHANGE_BY_G_FUCHS
+/*
+ * Patch by:
+ * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+ */
+      if (rc < 0
+#else
+      if (rc <= 0
+#endif
+      ||  rc == length)
+         return(rc);
+      length -= rc;
+      start = rc;
+   }
+}
diff -Naur gdb-6.8/pdcurses/x11/process/x11curses.c stsgdb-6.8/pdcurses/x11/process/x11curses.c
--- gdb-6.8/pdcurses/x11/process/x11curses.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/process/x11curses.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,672 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+*
+* This file is NOT public domain software.  It is Copyright, Mark Hessling
+* 1994-2000.
+***************************************************************************
+*/
+
+/*
+ * This file contains functions that are called by the "curses" process;
+ * ie the parent process.
+ */
+
+#include "pdcx11.h"
+extern AppData app_data;
+
+#ifdef PROTO
+static void XCursesExitCursesProcess(int, char *);
+#else
+static void XCursesExitCursesProcess();
+#endif
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesResizeScreen(int nlines, int ncols)
+#else
+int XCursesResizeScreen(nlines, ncols)
+int nlines,ncols;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesResizeScreen() - called: Lines: %d Cols: %d\n",(XCursesProcess)?"     X":"CURSES",nlines,ncols);
+#endif
+   shmdt((char *)Xcurscr);
+   XCursesInstructAndWait(CURSES_RESIZE);
+   if ((shmid_Xcurscr = shmget(shmkey_Xcurscr,SP->XcurscrSize+XCURSESSHMMIN,0700)) < 0)
+   {
+      perror("Cannot allocate shared memory for curscr");
+      kill(otherpid,SIGKILL);
+      return(ERR);
+   }
+   XCursesLINES = SP->lines;
+   XCursesCOLS = SP->cols;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:shmid_Xcurscr %d shmkey_Xcurscr %d SP->lines %d SP->cols %d\n",(XCursesProcess)?"     X":"CURSES",shmid_Xcurscr,shmkey_Xcurscr,SP->lines,SP->cols);
+#endif
+   Xcurscr = (unsigned char*)shmat(shmid_Xcurscr,0,0);
+   atrtab = (unsigned char *)(Xcurscr+XCURSCR_ATRTAB_OFF);
+   SP->resized=FALSE;
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_display_cursor(int oldrow, int oldcol, int newrow,int newcol,int visibility)
+#else
+int XCurses_display_cursor(oldrow,oldcol,newrow,newcol,visibility)
+int oldrow,oldcol,newrow,newcol,visibility;
+#endif
+/***********************************************************************/
+{
+   char buf[30];
+   int idx,pos;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_display_cursor() - called: NEW row %d col %d, vis %d\n",
+                        (XCursesProcess)?"X":"CURSES",newrow,newcol,visibility);
+#endif
+
+   if ( visibility == -1 )
+   {
+      /*
+       * Only send the CURSES_DISPLAY_CURSOR message, no data
+       */
+      idx = CURSES_DISPLAY_CURSOR;
+      memcpy(buf,(char *)&idx,sizeof(int));
+      idx = sizeof(int);
+   }
+   else
+   {
+      idx = CURSES_CURSOR;
+      memcpy(buf,(char *)&idx,sizeof(int));
+      idx = sizeof(int);
+      pos = oldrow + (oldcol << 8);
+      memcpy(buf+idx,(char *)&pos,sizeof(int));
+      idx += sizeof(int);
+      pos = newrow + (newcol << 8);
+      memcpy(buf+idx,(char *)&pos,sizeof(int));
+      idx += sizeof(int);
+   }
+
+   if (write_socket(display_sock,buf,idx) < 0)
+      XCursesExitCursesProcess(1,"exitting from XCurses_display_cursor");
+
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCurses_set_title(char *title)
+#else
+void XCurses_set_title(title)
+char *title;
+#endif
+/***********************************************************************/
+{
+   char buf[30];
+   int idx,len;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_set_title() - called: TITLE: %s\n",
+                        (XCursesProcess)?"X":"CURSES",title);
+#endif
+
+   idx = CURSES_TITLE;
+   memcpy(buf,(char *)&idx,sizeof(int));
+   idx = sizeof(int);
+   len = strlen(title)+1; /* write nul character */
+   memcpy(buf+idx,(char *)&len,sizeof(int));
+   idx += sizeof(int);
+
+   if (write_socket(display_sock,buf,idx) < 0)
+      XCursesExitCursesProcess(1,"exiting from XCurses_set_title");
+
+   if (write_socket(display_sock,title,len) < 0)
+      XCursesExitCursesProcess(1,"exiting from XCurses_set_title");
+
+   return;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_refresh_scrollbar(void)
+#else
+int XCurses_refresh_scrollbar()
+#endif
+/***********************************************************************/
+{
+   char buf[30];
+   int idx;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_refresh_scrollbar() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   idx = CURSES_REFRESH_SCROLLBAR;
+   memcpy(buf,(char *)&idx,sizeof(int));
+   idx = sizeof(int);
+
+   if (write_socket(display_sock,buf,idx) < 0)
+      XCursesExitCursesProcess(1,"exiting from XCurses_refresh_scrollbar");
+
+   return(OK);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_rawgetch( int delaytenths)
+#else
+int XCurses_rawgetch( delaytenths )
+int delaytenths;
+#endif
+/***********************************************************************/
+{
+   unsigned long newkey=0;
+   int key=0;
+   char buf[100]; /* big enough for MOUSE_STATUS struct */
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_rawgetch() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+   while(1)
+   {
+      if ( delaytenths && !XCurses_kbhit() )
+      {
+         key = -1;
+      }
+      else
+      {
+         if (read_socket(key_sock,buf,sizeof(unsigned long)) < 0)
+            XCursesExitCursesProcess(2,"exiting from XCurses_rawchar"); /* what else ?? */
+         memcpy((char *)&newkey,buf,sizeof(unsigned long));
+         pdc_key_modifier = (newkey >> 24) & 0xFF; /*(sizeof(unsigned long) - sizeof(unsigned char)); */
+         key = (int)(newkey & 0x00FFFFFF);
+      }
+#if 0
+ printf("%s:reading %d mod %ld\n",(XCursesProcess)?"     X":"CURSES",key,pdc_key_modifier);
+#endif
+      if (key == KEY_MOUSE)
+      {
+         if (read_socket(key_sock,buf,sizeof(MOUSE_STATUS)) < 0)
+            XCursesExitCursesProcess(2,"exitting from XCurses_rawchar"); /* what else ?? */
+         memcpy((char *)&Trapped_Mouse_status,buf,sizeof(MOUSE_STATUS));
+         /*
+          * Check if the mouse has been clicked on a slk area. If the return
+          * value is > 0 (indicating the
+          * label number, return with the KEY_F(key) value.
+          */
+/*fprintf(stderr,"%d %d %x\n",TRAPPED_MOUSE_Y_POS,TRAPPED_MOUSE_X_POS,SP->slk_winptr);*/
+         if ((newkey = PDC_mouse_in_slk(TRAPPED_MOUSE_Y_POS,TRAPPED_MOUSE_X_POS)))
+         {
+            if (TRAPPED_BUTTON_STATUS(1) & BUTTON_PRESSED)
+            {
+               key = KEY_F(newkey);
+               break;
+            }
+         }
+         break;
+
+#ifdef MOUSE_DEBUG
+ printf("rawgetch-x: %d y: %d Mouse status: %x\n",
+                                    MOUSE_X_POS,
+                                    MOUSE_Y_POS,
+                                    Mouse_status.changes);
+ printf("rawgetch-Button1: %x Button2: %x Button3: %x\n",
+                                    BUTTON_STATUS(1),
+                                    BUTTON_STATUS(2),
+                                    BUTTON_STATUS(3));
+#endif
+      }
+      else
+         break;
+   }
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_rawgetch() - key %d returned\n",(XCursesProcess)?"     X":"CURSES",key);
+#endif
+   return(key);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_get_input_fd(void)
+#else
+int XCurses_get_input_fd()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("%s:XCurses_get_input_fd() - called\n",(XCursesProcess)?"     X":"CURSES");
+	if (trace_on) PDC_debug("%s:XCurses_get_input_fd() - returning %i\n",(XCursesProcess)?"     X":"CURSES",key_sock);
+#endif
+ return key_sock;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+bool XCurses_kbhit(void)
+#else
+bool XCurses_kbhit()
+#endif
+/***********************************************************************/
+{
+   int s;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_kbhit() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   /*
+    * Is something ready to be read on the socket ? Must be a key.
+    */
+   FD_ZERO( &readfds );
+   FD_SET( key_sock, &readfds );
+   if ( ( s = select ( FD_SETSIZE, (FD_SET_CAST)&readfds, NULL, NULL, &socket_timeout ) ) < 0 )
+      XCursesExitCursesProcess(3,"child - exiting from XCurses_kbhit select failed");
+            
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_kbhit() - returning %s\n",(XCursesProcess)?"     X":"CURSES",(s == 0) ? "FALSE" : "TRUE");
+#endif
+   if ( s == 0 )
+      return(FALSE);
+   return(TRUE);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesInstruct(int flag)
+#else
+int XCursesInstruct(flag)
+int flag;
+#endif
+/***********************************************************************/
+{
+   char buf[10];
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesInstruct() - called flag %d\n",(XCursesProcess)?"     X":"CURSES",flag);
+#endif
+   /*
+    * Send a request to X...
+    */
+   memcpy(buf,(char *)&flag,sizeof(int));
+   if (write_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitCursesProcess(4,"exitting from XCursesInstruct");
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesInstructAndWait(int flag)
+#else
+int XCursesInstructAndWait(flag)
+int flag;
+#endif
+/***********************************************************************/
+{
+   int result;
+   char buf[10];
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesInstructAndWait() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   /*
+    * Tell X we want to do something...
+    */
+   XCursesInstruct(flag);
+   /*
+    * ... wait for X to say the refresh has occurred.
+    */
+   if (read_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCursesInstructAndWait");
+   memcpy((char *)&result,buf,sizeof(int));
+   if (result != CURSES_CONTINUE)
+      XCursesExitCursesProcess(6,"exitting from XCursesInstructAndWait - synchronization error");
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_transform_line(chtype *ch, int row, int start_col, int num_cols)
+#else
+int XCurses_transform_line(ch, row, start_col, num_cols)
+chtype *ch;
+int row,start_col,num_cols;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_transform_line() called: row %d start_col %d num_cols %d flag %d\n",
+                        (XCursesProcess)?"X":"CURSES",row,start_col,num_cols,*(Xcurscr+XCURSCR_FLAG_OFF+row));
+#endif
+
+   while(*(Xcurscr+XCURSCR_FLAG_OFF+row))
+   /*
+    * Patch by:
+    * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+    */
+   dummy_function(); /* loop until we can write to the line */
+   /*
+    * End of patch by:
+    * Georg Fuchs, georg.fuchs@rz.uni-regensburg.de 02-Feb-1999
+    */
+
+   *(Xcurscr+XCURSCR_FLAG_OFF+row) = 1;
+   memcpy(Xcurscr+XCURSCR_Y_OFF(row)+(start_col*sizeof(chtype)),ch,num_cols*sizeof(chtype));
+#if 0
+   *((int*)(Xcurscr+XCURSCR_START_OFF+row)) = start_col;
+   *((int*)(Xcurscr+XCURSCR_LENGTH_OFF+row)) = num_cols;
+   if ( (int)*(Xcurscr+XCURSCR_START_OFF+row) != start_col )
+      printf("%d difference: start_col %d mem: %d\n",__LINE__,start_col,(int)*(Xcurscr+XCURSCR_START_OFF+row) );
+   if ( (int)*(Xcurscr+XCURSCR_LENGTH_OFF+row) != num_cols )
+      printf("%d difference: num_cols %d mem: %d\n",__LINE__,num_cols,(int)*(Xcurscr+XCURSCR_LENGTH_OFF+row) );
+#else
+   *(Xcurscr+XCURSCR_START_OFF+row) = start_col;
+   *(Xcurscr+XCURSCR_LENGTH_OFF+row) = num_cols;
+#endif
+   *(Xcurscr+XCURSCR_FLAG_OFF+row) = 0;
+   return(0);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+static int XCursesSetupCurses(void)
+#else
+static int XCursesSetupCurses()
+#endif
+/***********************************************************************/
+{
+   char wait_buf[5];
+   int wait_value;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesSetupCurses called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   close ( display_sockets[1] );
+   close ( key_sockets[1] );
+   display_sock = display_sockets[0];
+   key_sock = key_sockets[0];
+   FD_ZERO ( &readfds );
+   FD_ZERO ( &writefds );
+   read_socket(display_sock,wait_buf,sizeof(int));
+   memcpy((char *)&wait_value,wait_buf,sizeof(int));
+   if (wait_value != CURSES_CHILD)
+      return(ERR);
+   /*
+    * Set LINES and COLS now so that the size of the
+    * shared memory segment can be allocated
+    */
+   if ((shmidSP = shmget(shmkeySP,sizeof(SCREEN)+XCURSESSHMMIN,0700)) < 0)
+   {
+      perror("Cannot allocate shared memory for SCREEN");
+      kill(otherpid,SIGKILL);
+      return(ERR);
+   }
+   SP = (SCREEN*)shmat(shmidSP,0,0);
+   XCursesLINES = SP->lines;
+   LINES = XCursesLINES - SP->linesrippedoff - SP->slklines;
+   XCursesCOLS = COLS = SP->cols;
+   if ((shmid_Xcurscr = shmget(shmkey_Xcurscr,SP->XcurscrSize+XCURSESSHMMIN,0700)) < 0)
+   {
+      perror("Cannot allocate shared memory for curscr");
+      kill(otherpid,SIGKILL);
+      return(ERR);
+   }
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:shmid_Xcurscr %d shmkey_Xcurscr %d LINES %d COLS %d\n",(XCursesProcess)?"     X":"CURSES",shmid_Xcurscr,shmkey_Xcurscr,LINES,COLS);
+#endif
+   Xcurscr = (unsigned char *)shmat(shmid_Xcurscr,0,0);
+   atrtab = (unsigned char *)(Xcurscr+XCURSCR_ATRTAB_OFF);
+   PDC_init_atrtab();
+#ifdef PDCDEBUG
+   say ("cursesprocess exiting from Xinitscr\n");
+#endif
+   /*
+    * Always trap SIGWINCH if the C library supports SIGWINCH...
+    */
+   XCursesSetSignal(SIGWINCH, XCursesSigwinchHandler );
+   return(OK);
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCursesInitscr(char *display_name, int argc, char *argv[])
+#else
+int XCursesInitscr(display_name,argc,argv)
+char *display_name;
+int argc;
+char *argv[];
+#endif
+/***********************************************************************/
+{
+   int pid,rc;
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesInitscr() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+
+#if defined FOREIGN
+   if (setlocale(LC_ALL, "") == NULL)
+   {
+      fprintf(stderr, "ERROR: cannot set locale\n");
+      return(ERR);
+   }
+   if (!XSupportsLocale())
+   {
+      fprintf(stderr, "ERROR: X does not support locale\n");
+      return(ERR);
+   }
+   if (XSetLocaleModifiers("") == NULL)
+      fprintf(stderr, "WARNING: Cannot set locale modifiers\n");
+#endif
+
+   shmkeySP = getpid();
+   memset ( &socket_timeout, '\0', sizeof ( socket_timeout ) );
+            
+   if ( socketpair ( AF_UNIX, SOCK_STREAM, 0, display_sockets ) < 0 )
+   {
+      fprintf(stderr, "ERROR: cannot create display socketpair\n");
+      return(ERR);
+   }
+            
+   if ( socketpair ( AF_UNIX, SOCK_STREAM, 0, key_sockets ) < 0 )
+   {
+      fprintf(stderr, "ERROR: cannot create key socketpair\n");
+      return(ERR);
+   }
+
+   pid = fork();
+   switch(pid)
+   {
+      case (-1):
+         fprintf(stderr,"ERROR: cannot fork()\n");
+         return(ERR);
+         break;
+      case 0: /* child */
+         shmkey_Xcurscr = getpid();
+#ifdef XISPARENT
+         XCursesProcess=0;
+         rc = XCursesSetupCurses();
+#else
+         XCursesProcess=1;
+         otherpid = getppid();
+         rc = XCursesSetupX(display_name,argc,argv);
+#endif
+         break;
+      default: /* parent */
+         shmkey_Xcurscr = pid;
+#ifdef XISPARENT
+         XCursesProcess=1;
+         otherpid = pid;
+         rc = XCursesSetupX(display_name,argc,argv);
+#else
+         XCursesProcess=0;
+         rc = XCursesSetupCurses();
+#endif
+         break;
+   }
+   return(rc);
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_getclipboard( char **contents, long *length )
+#else
+int XCurses_getclipboard( contents, length )
+char **contents;
+long *length;
+#endif
+/***********************************************************************/
+{
+   int result=0;
+   int len;
+   char buf[12];
+
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_getclipboard() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   XCursesInstructAndWait(CURSES_GET_SELECTION);
+
+   if (read_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCurses_getclipboard");
+   memcpy((char *)&result,buf,sizeof(int));
+   if (result == PDC_CLIP_SUCCESS)
+   {
+      if (read_socket(display_sock,buf,sizeof(int)) < 0)
+         XCursesExitCursesProcess(5,"exiting from XCurses_getclipboard");
+      memcpy((char *)&len,buf,sizeof(int));
+      if (len != 0)
+      {
+         *contents = (char *)malloc(len+1);
+         if (!*contents)
+            XCursesExitCursesProcess(6,"exitting from XCurses_getclipboard - synchronization error");
+         if (read_socket(display_sock,*contents,len) < 0)
+            XCursesExitCursesProcess(5,"exiting from XCurses_getclipboard");
+         *length = len;
+      }
+   }
+   return result;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_setclipboard( char *contents, long length )
+#else
+int XCurses_setclipboard( contents, length )
+char *contents;
+long length;
+#endif
+/***********************************************************************/
+{
+   int rc=0;
+   char buf[12]; /* big enough for 2 integers */
+   long len=length;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_setclipboard() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   XCursesInstruct(CURSES_SET_SELECTION);
+   memcpy(buf,(char *)&len,sizeof(long));
+   if (write_socket(display_sock,buf,sizeof(long)) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCurses_setclipboard");
+   if (write_socket(display_sock,contents,length) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCurses_setclipboard");
+   /*
+    * Wait for X to do its stuff. Now expect return code...
+    */
+   if (read_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCurses_setclipboard");
+   memcpy((char *)&rc,buf,sizeof(int));
+   return rc;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+int XCurses_clearclipboard( void )
+#else
+int XCurses_clearclipboard( )
+#endif
+/***********************************************************************/
+{
+   int rc=0;
+   char buf[12]; /* big enough for 2 integers */
+   long len;
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCurses_clearclipboard() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   XCursesInstruct(CURSES_CLEAR_SELECTION);
+   memcpy(buf,(char *)&len,sizeof(long));
+   if (write_socket(display_sock,buf,sizeof(long)) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCurses_setclipboard");
+   /*
+    * Wait for X to do its stuff. Now expect return code...
+    */
+   if (read_socket(display_sock,buf,sizeof(int)) < 0)
+      XCursesExitCursesProcess(5,"exiting from XCurses_clearclipboard");
+   memcpy((char *)&rc,buf,sizeof(int));
+   return rc;
+}
+
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesCleanupCursesProcess(int rc)
+#else
+void XCursesCleanupCursesProcess(rc)
+int rc;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesCleanupCursesProcess() - called: %d\n",(XCursesProcess)?"     X":"CURSES",rc);
+#endif
+   shutdown(display_sock,2);
+   close(display_sock);
+   shutdown(key_sock,2);
+   close(key_sock);
+   shmdt((char *)SP);
+   shmdt((char *)Xcurscr);
+   if (rc)
+      _exit(rc);
+   else
+      return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+static void XCursesExitCursesProcess(int rc,char *msg)
+#else
+static void XCursesExitCursesProcess(rc,msg)
+int rc;
+char *msg;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesExitCursesProcess() - called: %d %s\n",(XCursesProcess)?"     X":"CURSES",rc,msg);
+#endif
+   endwin();
+   XCursesCleanupCursesProcess(rc);
+   return;
+}
+/***********************************************************************/
+#ifdef HAVE_PROTO
+void XCursesExit(void)
+#else
+void XCursesExit()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+   if (trace_on) PDC_debug("%s:XCursesExit() - called\n",(XCursesProcess)?"     X":"CURSES");
+#endif
+   XCursesInstruct(CURSES_EXIT);
+   XCursesCleanupCursesProcess(0);
+   return;
+}
diff -Naur gdb-6.8/pdcurses/x11/process/x11.h stsgdb-6.8/pdcurses/x11/process/x11.h
--- gdb-6.8/pdcurses/x11/process/x11.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/process/x11.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,90 @@
+#ifdef HAVE_PROTO
+void dummy_function(void);
+void get_GC(Display *,Window, GC *, XFontStruct *,int ,int, bool );
+void makeXY(int ,int ,int ,int ,int *,int *);
+int get_colors(void);
+void start_event_handler(void);
+int XCursesTransformLine(int ,int ,chtype ,int ,int,int,char *);
+int XCursesDisplayText(chtype *, int, int, int,bool);
+void XCursesDisplayScreen(bool);
+void XCursesDisplayCursor( int ,int ,int ,int );
+void XCursesStructureNotify(Widget,XtPointer ,XEvent *,Boolean *);
+void XCursesEnterLeaveWindow(Widget,XtPointer ,XEvent *,Boolean *);
+void XCursesPasteSelection(Widget,XButtonEvent *);
+void XCursesHandleString(Widget,XEvent *,String *,Cardinal *);
+void XCursesKeyPress(Widget,XEvent *,String *,Cardinal *);
+void XCursesModifierPress(Widget,XEvent *,String *,Cardinal *);
+void XCursesButton(Widget,XEvent *,String *,Cardinal *);
+Boolean XCursesConvertProc(Widget,Atom *,Atom *,Atom *,XtPointer *,unsigned long *,int *);
+void XCursesLoseOwnership(Widget,Atom *);
+void XCursesRequestorCallbackForPaste(Widget,XtPointer,Atom *,Atom *,XtPointer,unsigned long *,int *);
+void XCursesRequestorCallbackForGetSelection(Widget,XtPointer,Atom *,Atom *,XtPointer,unsigned long *,int *);
+RETSIGTYPE XCursesSignalHandler(int);
+void XCursesExitXCursesProcess(int,int,char *);
+void SelectionOff(void);
+void SelectionOn(int,int);
+void SelectionExtend(int,int);
+void SelectionSet( void );
+
+int write_socket(int,char *,int);
+int read_socket(int,char *,int);
+int XCursesSetupX(char *display_name,int argc, char *argv[]);
+RETSIGTYPE XCursesSigwinchHandler(int signo);
+#else    
+void dummy_function(void);
+void get_GC();
+void makeXY();
+int get_colors();
+void start_event_handler();
+int XCursesTransformLine();
+int XCursesDisplayText();
+void XCursesDisplayScreen();
+void XCursesDisplayCursor();
+void XCursesStructureNotify();
+void XCursesEnterLeaveWindow();
+void XCursesHandleString();
+void XCursesKeyPress();
+void XCursesModifierPress();
+void XCursesButton();
+void XCursesPasteSelection();
+Boolean XCursesConvertProc();
+void XCursesLoseOwnership();
+void XCursesRequestorCallbackForPaste();
+void XCursesRequestorCallbackForGetSelection();
+RETSIGTYPE XCursesSignalHandler();
+void XCursesExitXCursesProcess();
+void SelectionOff();
+void SelectionOn();
+void SelectionExtend();
+void SelectionSet();
+
+int write_socket();
+int read_socket();
+int XCursesSetupX();
+RETSIGTYPE XCursesSigwinchHandler();
+#endif
+
+#ifdef _HPUX_SOURCE
+# define FD_SET_CAST int *
+#else
+# define FD_SET_CAST fd_set *
+#endif
+extern fd_set readfds;
+extern fd_set writefds;
+extern struct timeval socket_timeout;
+
+extern unsigned char *Xcurscr;
+extern int XCursesProcess;
+extern int shmidSP;
+extern int shmid_Xcurscr;
+extern int shmkeySP;
+extern int shmkey_Xcurscr;
+extern int otherpid;
+extern int XCursesLINES;
+extern int XCursesCOLS;
+extern unsigned char *atrtab;
+extern int display_sock;
+extern int key_sock;
+extern int display_sockets[2];
+extern int key_sockets[2];
+extern int exit_sock;
diff -Naur gdb-6.8/pdcurses/x11/README stsgdb-6.8/pdcurses/x11/README
--- gdb-6.8/pdcurses/x11/README	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/README	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,39 @@
+
+              Welcome to PDCurses for X11 (aka XCurses)
+
+ This is a port of PDCurses for X11.  It is designed to allow existing
+ curses programs to be re-compiled with PDCurses resulting in native
+ X11 programs.
+
+
+ Distribution Status
+ -------------------
+
+ The files in this directory are copyright Mark Hessling 1995-2000.
+ This source code made be used without restriction when used with
+ the PDCurses library.  Any other use of this source code requires
+ written permission of the author, Mark Hessling (M.Hessling@qut.edu.au)
+
+ To be Done
+ ----------
+
+ - add newterm() function and have it create a new X window
+
+ - provide a command line parsing function to enable X command line
+   arguments to be parsed and stripped from the arguments passed back
+   to the calling procedure.
+
+ - add proper 'flash' behaviour
+
+Structure
+---------
+
+x11.c           - contains functions that are X11 specific functions that are
+                  used by both the process and thread implementations
+x11.h           - #defines and includes for the X11 process/thread
+x11_proc.c      - contains functions that are used by the X11 (child) process
+                  in the process implementation
+curses_proc.c   - contains functions that are used by the curses (parent)
+                  process in the process implementation
+x11_thread.c    -
+curses_thread.c -
diff -Naur gdb-6.8/pdcurses/x11/sb.c stsgdb-6.8/pdcurses/x11/sb.c
--- gdb-6.8/pdcurses/x11/sb.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/sb.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,228 @@
+/*
+***************************************************************************
+* This file comprises part of PDCurses. PDCurses is Public Domain software.
+* You may use this code for whatever purposes you desire. This software
+* is provided AS IS with NO WARRANTY whatsoever.
+* Should this software be used in another application, an acknowledgement
+* that PDCurses code is used would be appreciated, but is not mandatory.
+*
+* Any changes which you make to this software which may improve or enhance
+* it, should be forwarded to the current maintainer for the benefit of 
+* other users.
+*
+* The only restriction placed on this code is that no distribution of
+* modified PDCurses code be made under the PDCurses name, by anyone
+* other than the current maintainer.
+* 
+* See the file maintain.er for details of the current maintainer.
+***************************************************************************
+*/
+#define	CURSES_LIBRARY	1
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+#include <curses.h>
+
+/* undefine any macros for functions defined in this module */
+#undef	sb_init
+#undef	sb_set_horz
+#undef	sb_set_vert
+#undef	sb_get_horz
+#undef	sb_get_vert
+#undef	sb_refresh
+
+/* undefine any macros for functions called by this module if in debug mode */
+#ifdef PDCDEBUG
+#endif
+
+#ifdef PDCDEBUG
+char *rcsid_sb  = "$Id: sb.c,v 1.2 2002/07/04 10:23:50 mark Exp $";
+#endif
+
+/*man-start*********************************************************************
+
+  Name:                                                          sb
+
+  Synopsis:
+
+  	int sb_init(void)
+  	int sb_set_horz(int total, int viewport, int cur)
+  	int sb_set_vert(int total, int viewport, int cur)
+  	int sb_get_horz(int *total, int *viewport, int *cur)
+  	int sb_get_vert(int *total, int *viewport, int *cur)
+  	int sb_refresh(void);
+
+  PDCurses Description:
+ 	These functions manipulate the scrollbar...
+
+  PDCurses Return Value:
+ 	All functions return OK on success and ERR on error.
+
+  Portability                             X/Open    BSD    SYS V
+                                          Dec '88
+      sb_init                               -        -       -
+      sb_set_horz                           -        -       -
+      sb_set_vert                           -        -       -
+      sb_get_horz                           -        -       -
+      sb_get_vert                           -        -       -
+      sb_refresh                            -        -       -
+
+**man-end**********************************************************************/
+
+bool sb_started = FALSE;
+
+/***********************************************************************/
+/*
+   sb_init()	is the sb initialization routine.
+   This must be called before initscr().
+ */
+#ifdef HAVE_PROTO
+int	PDC_CDECL	sb_init(void)
+#else
+int	PDC_CDECL	sb_init()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("sb_init() - called\n");
+#endif
+
+	if (SP)
+		return (ERR);
+
+	sb_started = TRUE;
+	return(OK);
+}
+
+/***********************************************************************/
+/*
+	sb_set_horz()	Used to set horizontal scrollbar.
+
+   total = total number of columns
+   viewport = size of viewport in columns
+   cur = current column in total
+ */
+#ifdef HAVE_PROTO
+int	PDC_CDECL	sb_set_horz(int total, int viewport, int cur)
+#else
+int	PDC_CDECL	sb_set_horz(total, viewport, cur)
+int total, viewport, cur;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("sb_set_horz() - called: total %d viewport %d cur %d\n",total, viewport, cur);
+#endif
+	if (!SP)
+		return(ERR);
+
+	SP->sb_total_x = total;
+	SP->sb_viewport_x = viewport;
+	SP->sb_cur_x = cur;
+	return( OK );
+}
+
+/***********************************************************************/
+/*
+	sb_set_vert()	Used to set vertical scrollbar.
+
+   total = total number of columns on line
+   viewport = size of viewport in columns
+   cur = current column in total
+ */
+#ifdef HAVE_PROTO
+int	PDC_CDECL	sb_set_vert(int total, int viewport, int cur)
+#else
+int	PDC_CDECL	sb_set_vert(total, viewport, cur)
+int total, viewport, cur;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("sb_set_vert() - called: total %d viewport %d cur %d\n",total, viewport, cur);
+#endif
+	if (!SP)
+		return(ERR);
+
+	SP->sb_total_y = total;
+	SP->sb_viewport_y = viewport;
+	SP->sb_cur_y = cur;
+	return( OK );
+}
+
+/***********************************************************************/
+/*
+	sb_get_horz()	Used to get horizontal scrollbar.
+
+   total = total number of lines
+   viewport = size of viewport in lines
+   cur = current line in total
+ */
+#ifdef HAVE_PROTO
+int	PDC_CDECL	sb_get_horz(int *total, int *viewport, int *cur)
+#else
+int	PDC_CDECL	sb_get_horz(total, viewport, cur)
+int *total, *viewport, *cur;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("sb_get_horz() - called\n");
+#endif
+	if (!SP)
+		return(ERR);
+
+	if (total) *total = SP->sb_total_x;
+	if (viewport) *viewport = SP->sb_viewport_x;
+	if (cur) *cur = SP->sb_cur_x;
+	return( OK );
+}
+
+/***********************************************************************/
+/*
+	sb_get_vert()	Used to get vertical scrollbar.
+
+   total = total number of lines
+   viewport = size of viewport in lines
+   cur = current line in total
+ */
+#ifdef HAVE_PROTO
+int	PDC_CDECL	sb_get_vert(int *total, int *viewport, int *cur)
+#else
+int	PDC_CDECL	sb_get_vert(total, viewport, cur)
+int *total, *viewport, *cur;
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("sb_get_vert() - called\n");
+#endif
+	if (!SP)
+		return(ERR);
+
+	if (total) *total = SP->sb_total_y;
+	if (viewport) *viewport = SP->sb_viewport_y;
+	if (cur) *cur = SP->sb_cur_y;
+	return( OK );
+}
+
+/***********************************************************************/
+/*
+	sb_refresh()	Used to draw the scrollbars.
+ */
+#ifdef HAVE_PROTO
+int	PDC_CDECL	sb_refresh(void)
+#else
+int	PDC_CDECL	sb_refresh()
+#endif
+/***********************************************************************/
+{
+#ifdef PDCDEBUG
+	if (trace_on) PDC_debug("sb_refresh() - called\n");
+#endif
+
+	if (!SP)
+		return(ERR);
+
+	return(XCurses_refresh_scrollbar());
+}
diff -Naur gdb-6.8/pdcurses/x11/ScrollBox.c stsgdb-6.8/pdcurses/x11/ScrollBox.c
--- gdb-6.8/pdcurses/x11/ScrollBox.c	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/ScrollBox.c	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,356 @@
+/*
+ * Copyright 1989 O'Reilly and Associates, Inc.
+
+     The X Consortium, and any party obtaining a copy of these files from
+     the X Consortium, directly or indirectly, is granted, free of charge, a
+     full and unrestricted irrevocable, world-wide, paid up, royalty-free,
+     nonexclusive right and license to deal in this software and
+     documentation files (the "Software"), including without limitation the
+     rights to use, copy, modify, merge, publish, distribute, sublicense,
+     and/or sell copies of the Software, and to permit persons who receive
+     copies from any such party to do so.  This license includes without
+     limitation a license to do the foregoing actions under any patents of
+     the party supplying this software to the X Consortium.
+ */
+
+/* 
+ * ScrollBox.c - scrollBox composite widget
+ */
+
+#include <X11/IntrinsicP.h>
+#include <X11/StringDefs.h>
+#include <X11/Shell.h>
+
+#include "x11/ScrollBoxP.h"
+
+#include <stdio.h>
+
+#define INITIAL_WIDTH 300
+#define INITIAL_HEIGHT 300
+
+/****************************************************************
+ *
+ * scrollBox Resources
+ *
+ ****************************************************************/
+
+static XtResource resources[] = 
+{
+   { XtNhSpace, XtCHSpace, XtRDimension, sizeof(Dimension),
+      XtOffset(ScrollBoxWidget, scrollBox.h_space), XtRImmediate, (XtPointer)4},
+   { XtNvSpace, XtCVSpace, XtRDimension, sizeof(Dimension),
+      XtOffset(ScrollBoxWidget, scrollBox.v_space), XtRImmediate, (XtPointer)4},
+   { XtNheightInc, XtCHeightInc, XtRDimension, sizeof(Dimension),
+      XtOffset(ScrollBoxWidget, scrollBox.increment_height), XtRImmediate, (XtPointer)13},
+   { XtNwidthInc, XtCWidthInc, XtRDimension, sizeof(Dimension),
+      XtOffset(ScrollBoxWidget, scrollBox.increment_width), XtRImmediate, (XtPointer)7},
+};
+
+/****************************************************************
+ *
+ * Full class record constant
+ *
+ ****************************************************************/
+
+static void Initialize();
+static void Resize();
+static Boolean SetValues();
+static void ChangeManaged();
+static XtGeometryResult QueryGeometry(), GeometryManager();
+static void RefigureLocations();
+
+ScrollBoxClassRec scrollBoxClassRec = {
+  {
+/* core_class fields      */
+    /* superclass         */    (WidgetClass) &compositeClassRec,
+    /* class_name         */    "scrollBox",
+    /* widget_size        */    sizeof(ScrollBoxRec),
+    /* class_initialize   */    NULL,
+    /* class_part_init    */  NULL,
+    /* class_inited       */  FALSE,
+    /* initialize         */    Initialize,
+    /* initialize_hook    */  NULL,
+    /* realize            */    XtInheritRealize,
+    /* actions            */    NULL,
+    /* num_actions     */  0,
+    /* resources          */    resources,
+    /* num_resources      */    XtNumber(resources),
+    /* xrm_class          */    NULLQUARK,
+    /* compress_motion    */  TRUE,
+    /* compress_exposure  */  TRUE,
+    /* compress_enterleave*/  TRUE,
+    /* visible_interest   */    FALSE,
+    /* destroy            */    NULL,
+    /* resize             */    Resize,
+    /* expose             */    NULL,
+    /* set_values         */    SetValues,
+    /* set_values_hook    */  NULL,
+    /* set_values_almost  */    XtInheritSetValuesAlmost,
+    /* get_values_hook    */  NULL,
+    /* accept_focus       */    NULL,
+    /* version            */  XtVersion,
+    /* callback_private   */    NULL,
+    /* tm_table           */    NULL,
+    /* query_geometry     */  QueryGeometry,
+    /* display_accelerator*/  XtInheritDisplayAccelerator,
+    /* extension          */  NULL
+  },{
+/* composite_class fields */
+    /* geometry_manager   */    GeometryManager,
+    /* change_managed     */    ChangeManaged,
+    /* insert_child    */  XtInheritInsertChild,
+    /* delete_child    */  XtInheritDeleteChild,
+    /* extension          */  NULL
+  },{
+/* scrollBox class fields */
+    /* empty        */  0,
+  }
+};
+
+WidgetClass scrollBoxWidgetClass = (WidgetClass)&scrollBoxClassRec;
+
+
+/****************************************************************
+ *
+ * Private Routines
+ *
+ ****************************************************************/
+
+/*
+ * Do a layout, either actually assigning positions, or just 
+ * calculating size.
+ */
+
+/* ARGSUSED */
+static void DoLayout(w, doit)
+Widget w;
+Boolean doit;
+{
+   ScrollBoxWidget sbw = (ScrollBoxWidget) w;
+   Widget wmain, vscroll, hscroll;
+   Widget child;
+   Dimension mw, mh;   /* main window */
+   Dimension vh;   /* vertical scrollbar length (height) */
+   Dimension hw;   /* horizontal scrollbar length (width) */
+   Position vx;
+   Position hy;
+#if 0
+   Dimension th;
+   Dimension tw;
+#endif
+   Cardinal i;
+
+   if (sbw->composite.num_children != 3)
+      XtAppError(XtWidgetToApplicationContext(w),
+            "ScrollBox: must manage exactly three widgets.");
+
+   for (i = 0; i < sbw->composite.num_children; i++) 
+   {
+      child = sbw->composite.children[i];
+      if (!XtIsManaged(child)) 
+      {
+         XtAppError(XtWidgetToApplicationContext(w),
+            "ScrollBox: all three widgets must be managed.");
+      }
+   }
+
+   /*
+    * Child one is the main window, two is the vertical scrollbar,
+    * and three is the horizontal scrollbar.
+    */
+   wmain = sbw->composite.children[0];
+   vscroll = sbw->composite.children[1];
+   hscroll = sbw->composite.children[2];
+
+   /* 
+    * Size all three widgets so that space is fully utilized.
+    */
+#if 1
+   mw = sbw->core.width - (2 * sbw->scrollBox.h_space) -
+        vscroll->core.width - (2 * vscroll->core.border_width) -
+        (2 * wmain->core.border_width);
+
+
+   mh = sbw->core.height - (2 * sbw->scrollBox.v_space) -
+        hscroll->core.height - (2 * hscroll->core.border_width) -
+        (2 * wmain->core.border_width);
+
+   /*
+    * Force the main window to be sized to the appropriate increments
+    */
+   mw = (mw/sbw->scrollBox.increment_width)*sbw->scrollBox.increment_width;
+   mh = ((mh/sbw->scrollBox.increment_height)*sbw->scrollBox.increment_height)+sbw->scrollBox.increment_height;
+
+   vx = wmain->core.x + mw + sbw->scrollBox.h_space + wmain->core.border_width + vscroll->core.border_width; 
+
+   hy = wmain->core.y + mh + sbw->scrollBox.v_space + wmain->core.border_width + hscroll->core.border_width; 
+
+   vh = mh;   /* scrollbars are always same length as main window */
+   hw = mw;
+/* fprintf(stderr,"%s %d: mw %d mh %d vx %d hy %d hinc %d winc %d hspace %d\n",__FILE__,__LINE__,mw,mh,vx,hy,sbw->scrollBox.increment_height,sbw->scrollBox.increment_width,sbw->scrollBox.h_space); */
+
+   if (doit) {
+      XtResizeWidget(wmain, mw, mh, 1);
+#else
+   tw = wmain->core.width + (2 * sbw->scrollBox.h_space) +
+        vscroll->core.width + (2 * vscroll->core.border_width) +
+        (2 * wmain->core.border_width);
+
+   th = wmain->core.height + (2 * sbw->scrollBox.v_space) +
+        hscroll->core.height - (2 * hscroll->core.border_width) +
+        (2 * wmain->core.border_width);
+
+   hw = mw = wmain->core.width;
+   vh = mh = wmain->core.height;
+
+   vx = wmain->core.x + mw + sbw->scrollBox.h_space + wmain->core.border_width + vscroll->core.border_width; 
+   hy = wmain->core.y + mh + sbw->scrollBox.v_space + wmain->core.border_width + hscroll->core.border_width; 
+
+   if (doit) {
+      XtResizeWidget(w, tw, th, 1);
+#endif
+
+      XtResizeWidget(vscroll, vscroll->core.width, vh, 1);
+      XtMoveWidget(vscroll, vx, vscroll->core.y);
+
+      XtResizeWidget(hscroll, hw, hscroll->core.height, 1);
+      XtMoveWidget(hscroll, hscroll->core.x, hy);
+   }
+}
+
+/* ARGSUSED */
+static XtGeometryResult GeometryManager(w, request, reply)
+    Widget w;
+    XtWidgetGeometry *request;
+    XtWidgetGeometry *reply;    /* RETURN */
+{
+   XtWidgetGeometry allowed;
+
+   if (request->request_mode & ~(XtCWQueryOnly | CWWidth | CWHeight))
+      return XtGeometryNo;
+
+   if (request->request_mode & CWWidth)
+      allowed.width = request->width;
+   else
+      allowed.width = w->core.width;
+
+   if (request->request_mode & CWHeight)
+      allowed.height = request->height;
+   else
+      allowed.height = w->core.height;
+
+   if (allowed.width == w->core.width && allowed.height == w->core.height)
+      return XtGeometryNo;
+
+    if (!(request->request_mode & XtCWQueryOnly)) {
+      RefigureLocations(w);
+    }
+    return XtGeometryYes;
+}
+
+static void RefigureLocations(w)
+    Widget w;
+{
+   DoLayout(w, False);
+}
+
+
+/*
+ * Calculate preferred size.  We can't just use the current sizes
+ * of the children, because that calculation would always end up with 
+ * our current size.  Could query each child, and use that size to 
+ * recalculate a size for us, then if it ends up being larger
+ * than width and height passed in, accept bounding box.  
+ * However, we know our children and they don't have any particular
+ * preferred geometry, except the bigger the better.
+ * Therefore, if the parent suggested a size, we'll take it.
+ */
+
+/* ARGSUSED */
+static XtGeometryResult QueryGeometry(w, request, reply_return)
+Widget w;
+XtWidgetGeometry *request, *reply_return;
+{
+   XtGeometryResult result=XtGeometryNo;
+
+   request->request_mode &= CWWidth | CWHeight;
+
+   if (request->request_mode == 0)
+   /* parent isn't going to change w or h, so nothing to re-compute */
+      return XtGeometryYes;
+
+    /* if proposed size is large enough, accept it.  Otherwise,
+     * suggest our arbitrary initial size. */
+
+   if (request->request_mode & CWHeight) 
+   {
+      if (request->height < INITIAL_HEIGHT) 
+      {
+         result = XtGeometryAlmost;
+         reply_return->height = INITIAL_HEIGHT;
+         reply_return->request_mode &= CWHeight;
+      }
+      else
+         result = XtGeometryYes;
+   }
+
+   if (request->request_mode & CWWidth) 
+   {
+      if (request->width < INITIAL_WIDTH) 
+      {
+         result = XtGeometryAlmost;
+         reply_return->width = INITIAL_WIDTH;
+         reply_return->request_mode &= CWWidth;
+      }
+      else
+         result = XtGeometryYes;
+   }
+
+   return(result);
+}
+
+/*
+ * Actually layout the scrollBox
+ */
+
+static void Resize(w)
+Widget w;
+{
+   DoLayout(w, True);
+}
+
+static void ChangeManaged(w)
+Widget w;
+{
+   DoLayout(w, True);
+}
+
+/* ARGSUSED */
+static void Initialize(request, new)
+    Widget request, new;
+{
+   ScrollBoxWidget newsbw = (ScrollBoxWidget)new;
+
+   if (newsbw->core.width == 0)
+      newsbw->core.width = INITIAL_WIDTH;
+
+   if (newsbw->core.height == 0)
+      newsbw->core.height = INITIAL_HEIGHT;
+
+} /* Initialize */
+
+/* ARGSUSED */
+static Boolean SetValues(current, request, new, args, num_args)
+Widget current, request, new;
+ArgList args;
+Cardinal *num_args;
+{
+   ScrollBoxWidget sbwcurrent = (ScrollBoxWidget) current;
+   ScrollBoxWidget sbwnew = (ScrollBoxWidget) new;
+   /* need to relayout if h_space or v_space change */
+   if ((sbwnew->scrollBox.h_space != sbwcurrent->scrollBox.h_space) ||
+                   (sbwnew->scrollBox.v_space != sbwcurrent->scrollBox.v_space))
+      DoLayout(new, True);
+
+   return False;
+}
diff -Naur gdb-6.8/pdcurses/x11/ScrollBox.h stsgdb-6.8/pdcurses/x11/ScrollBox.h
--- gdb-6.8/pdcurses/x11/ScrollBox.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/ScrollBox.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * Copyright 1989 O'Reilly and Associates, Inc.
+
+     The X Consortium, and any party obtaining a copy of these files from
+     the X Consortium, directly or indirectly, is granted, free of charge, a
+     full and unrestricted irrevocable, world-wide, paid up, royalty-free,
+     nonexclusive right and license to deal in this software and
+     documentation files (the "Software"), including without limitation the
+     rights to use, copy, modify, merge, publish, distribute, sublicense,
+     and/or sell copies of the Software, and to permit persons who receive
+     copies from any such party to do so.  This license includes without
+     limitation a license to do the foregoing actions under any patents of
+     the party supplying this software to the X Consortium.
+ */
+
+#ifndef _XORAscrollBox_h
+#define _XORAscrollBox_h
+
+/***********************************************************************
+ *
+ * scrollBox Widget (subclass of CompositeClass)
+ *
+ ***********************************************************************/
+
+/* Parameters:
+
+ Name		     Class		RepType		Default Value
+ ----		     -----		-------		-------------
+ background	     Background		Pixel		XtDefaultBackground
+ border		     BorderColor	Pixel		XtDefaultForeground
+ borderWidth	     BorderWidth	Dimension	1
+ destroyCallback     Callback		Pointer		NULL
+ hSpace 	     HSpace		Dimension	4
+ height		     Height		Dimension	0
+ mappedWhenManaged   MappedWhenManaged	Boolean		True
+ vSpace 	     VSpace		Dimension	4
+ width		     Width		Dimension	0
+ x		     Position		Position	0
+ y		     Position		Position	0
+
+*/
+
+
+/* Class record constants */
+
+extern WidgetClass scrollBoxWidgetClass;
+
+typedef struct _ScrollBoxClassRec *ScrollBoxWidgetClass;
+typedef struct _ScrollBoxRec      *ScrollBoxWidget;
+
+#endif /* _XORAscrollBox_h */
diff -Naur gdb-6.8/pdcurses/x11/ScrollBoxP.h stsgdb-6.8/pdcurses/x11/ScrollBoxP.h
--- gdb-6.8/pdcurses/x11/ScrollBoxP.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/ScrollBoxP.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,70 @@
+/*
+ * Copyright 1989 O'Reilly and Associates, Inc.
+
+     The X Consortium, and any party obtaining a copy of these files from
+     the X Consortium, directly or indirectly, is granted, free of charge, a
+     full and unrestricted irrevocable, world-wide, paid up, royalty-free,
+     nonexclusive right and license to deal in this software and
+     documentation files (the "Software"), including without limitation the
+     rights to use, copy, modify, merge, publish, distribute, sublicense,
+     and/or sell copies of the Software, and to permit persons who receive
+     copies from any such party to do so.  This license includes without
+     limitation a license to do the foregoing actions under any patents of
+     the party supplying this software to the X Consortium.
+ */
+
+/* 
+ * scrollBoxP.h - Private definitions for scrollBox widget
+ * 
+ */
+
+#ifndef _XORAscrollBoxP_h
+#define _XORAscrollBoxP_h
+
+/***********************************************************************
+ *
+ * scrollBox Widget Private Data
+ *
+ ***********************************************************************/
+
+#include "x11/ScrollBox.h"
+
+#include <X11/CompositeP.h>
+
+/* New fields for the scrollBox widget class record */
+typedef struct _ScrollBoxClass {
+	int empty;
+} ScrollBoxClassPart;
+
+/* Full class record declaration */
+typedef struct _ScrollBoxClassRec {
+    CoreClassPart	core_class;
+    CompositeClassPart  composite_class;
+    ScrollBoxClassPart	scrollBox_class;
+} ScrollBoxClassRec;
+
+extern ScrollBoxClassRec scrollBoxClassRec;
+
+/* New fields for the scrollBox widget record */
+typedef struct {
+    Dimension   h_space, v_space;
+    Dimension	preferred_width, preferred_height;
+    Dimension	last_query_width, last_query_height;
+    Dimension	increment_width, increment_height;
+    XtGeometryMask last_query_mode;
+} ScrollBoxPart;
+
+
+/****************************************************************
+ *
+ * Full instance record declaration
+ *
+ ****************************************************************/
+
+typedef struct _ScrollBoxRec {
+    CorePart	    core;
+    CompositePart   composite;
+    ScrollBoxPart   scrollBox;
+} ScrollBoxRec;
+
+#endif /* _XORAscrollBoxP_h */
diff -Naur gdb-6.8/pdcurses/x11/xcurs32.xbm stsgdb-6.8/pdcurses/x11/xcurs32.xbm
--- gdb-6.8/pdcurses/x11/xcurs32.xbm	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/xcurs32.xbm	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,14 @@
+#define xcurs32_width 32
+#define xcurs32_height 32
+static unsigned char xcurs32_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x80, 0x07, 0x00, 0x01, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x1e, 0x40, 0x00,
+   0x00, 0x3c, 0x20, 0x00, 0x00, 0x78, 0x10, 0x00, 0x00, 0xf0, 0x08, 0x00,
+   0x00, 0xe0, 0x05, 0x00, 0x00, 0xc0, 0x06, 0x00, 0x00, 0x40, 0x07, 0x00,
+   0x00, 0x20, 0x0f, 0x00, 0x00, 0x10, 0x1e, 0x00, 0x00, 0x08, 0x3c, 0x00,
+   0x00, 0x04, 0x78, 0x00, 0x00, 0x02, 0xf0, 0x00, 0x00, 0x01, 0xe0, 0x01,
+   0x80, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x4c, 0x2a, 0xc6, 0x18, 0x52, 0x5a, 0x29, 0x25, 0x42, 0x0a, 0x29, 0x25,
+   0x42, 0x0a, 0xe2, 0x09, 0x42, 0x0a, 0x24, 0x10, 0x42, 0x0a, 0x29, 0x20,
+   0x52, 0x0a, 0x29, 0x25, 0x8c, 0x09, 0xc6, 0x18, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -Naur gdb-6.8/pdcurses/x11/xcurs64.xbm stsgdb-6.8/pdcurses/x11/xcurs64.xbm
--- gdb-6.8/pdcurses/x11/xcurs64.xbm	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/xcurs64.xbm	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,46 @@
+#define xcurses_width 64
+#define xcurses_height 64
+static unsigned char xcurses_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
+   0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x01, 0x00, 0xc0, 0x00, 0x00,
+   0x00, 0x00, 0xfc, 0x03, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07,
+   0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x18, 0x00, 0x00,
+   0x00, 0x00, 0xf0, 0x0f, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x1f,
+   0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0x00, 0x06, 0x00, 0x00,
+   0x00, 0x00, 0xc0, 0x3f, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f,
+   0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xc0, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xfe, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
+   0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x33, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0xf8, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
+   0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x0e, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x60, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0,
+   0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x7f, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x98, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
+   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xfe, 0x01, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x03, 0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01,
+   0xfc, 0x03, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0xf8, 0x07, 0x00, 0x00,
+   0x00, 0x00, 0xc0, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
+   0xe0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0xe0, 0x1f, 0x00, 0x00,
+   0x00, 0x00, 0x18, 0x00, 0xc0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00,
+   0x80, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xff, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x23, 0x50, 0x1e,
+   0x7c, 0xf0, 0xe0, 0x03, 0x60, 0x26, 0x50, 0x33, 0xc6, 0x98, 0x31, 0x06,
+   0x30, 0x2c, 0xd0, 0x61, 0x83, 0x0d, 0x1b, 0x0c, 0x10, 0x28, 0xd0, 0x40,
+   0x01, 0x05, 0x0a, 0x08, 0x10, 0x20, 0x50, 0x00, 0x01, 0x05, 0x0a, 0x08,
+   0x10, 0x20, 0x50, 0x00, 0x03, 0x04, 0x1a, 0x00, 0x10, 0x20, 0x50, 0x00,
+   0x06, 0x04, 0x32, 0x00, 0x10, 0x20, 0x50, 0x00, 0x7c, 0xfc, 0xe3, 0x03,
+   0x10, 0x20, 0x50, 0x00, 0xc0, 0x04, 0x00, 0x06, 0x10, 0x20, 0x50, 0x00,
+   0x80, 0x05, 0x00, 0x0c, 0x10, 0x20, 0x50, 0x00, 0x01, 0x05, 0x0a, 0x08,
+   0x10, 0x28, 0x50, 0x00, 0x01, 0x05, 0x0a, 0x08, 0x30, 0x6c, 0x58, 0x00,
+   0x83, 0x0d, 0x1b, 0x0c, 0x60, 0xc6, 0x4c, 0x00, 0xc6, 0x98, 0x31, 0x06,
+   0xc0, 0x83, 0x47, 0x00, 0x7c, 0xf0, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -Naur gdb-6.8/pdcurses/x11/XCurses.def stsgdb-6.8/pdcurses/x11/XCurses.def
--- gdb-6.8/pdcurses/x11/XCurses.def	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/x11/XCurses.def	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,27 @@
+!
+! resources for Xcurses class of programs
+!
+XCurses*lines:	25
+XCurses*cols:	80
+XCurses*normalFont:	9x13
+XCurses*boldFont:	9x13bold
+!XCurses*bitmap:	/tmp/xcurses.xbm
+XCurses*cursor:	clock
+!
+! resources for testcurs
+!
+testcurs.colorRed:	orange
+testcurs.colorBlack:	midnightblue
+testcurs.lines:	30
+testcurs.normalFont:	7x13
+testcurs.boldFont:	7x13bold
+testcurs.cursorColor:	orange
+!
+! resources for THE - Xcurses 
+!
+the.normalFont:	7x13
+the.boldFont:	7x13bold
+the.lines:	40
+the.cols:	86
+the.cursor:	xterm
+the.bitmap:	/home/mark/the/the64.xbm
diff -Naur gdb-6.8/pdcurses/xcurses-config.in stsgdb-6.8/pdcurses/xcurses-config.in
--- gdb-6.8/pdcurses/xcurses-config.in	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/xcurses-config.in	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1,73 @@
+#! /bin/sh
+#
+# The idea to this kind of setup info script was stolen from numerous
+# other packages, such as neon, libxml and gnome.
+#
+# $Id: xcurses-config.in,v 1.2 2002/11/27 11:14:53 mark Exp $
+#
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+includedir=@includedir@
+
+usage()
+{
+    echo "Usage: xcurses-config [OPTION]"
+    echo ""
+    echo "Available values for OPTION include:"
+    echo ""
+    echo "  --help         display this help and exit"
+    echo "  --cflags       pre-processor and compiler flags"
+    echo "                 [-I$includedir]"
+    echo "  --libs         library linking information"
+    echo "                 [-L$prefix/lib -lXCurses @LDFLAGS@ @MH_XLIBS@ @MH_EXTRA_LIBS@"
+    echo "  --prefix       PDCurses install prefix"
+    echo "                 [$prefix]"
+    echo "  --version      output version information"
+    echo "                 [@VER_DOT@]"
+    exit $1
+}
+
+if test $# -eq 0; then
+    usage 1
+fi
+
+while test $# -gt 0; do
+    case "$1" in
+    # this deals with options in the style
+    # --option=value and extracts the value part
+    # [not currently used]
+    -*=*) value=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
+    *) value= ;;
+    esac
+
+    case "$1" in
+    --prefix)
+       echo $prefix
+       ;;
+
+    --version)
+       echo @VER_DOT@
+       exit 0
+       ;;
+
+    --help)
+       usage 0
+       ;;
+
+    --cflags)
+       echo -I$includedir
+       ;;
+
+    --libs)
+       echo -L$prefix/lib -lXCurses @LDFLAGS@ @MH_XLIBS@ @MH_EXTRA_LIBS@
+       ;;
+
+    *)
+       usage
+       exit 1
+       ;;
+    esac
+    shift
+done
+
+exit 0
diff -Naur gdb-6.8/pdcurses/xcurses.h stsgdb-6.8/pdcurses/xcurses.h
--- gdb-6.8/pdcurses/xcurses.h	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/pdcurses/xcurses.h	2008-09-11 10:33:00.000000000 +0100
@@ -0,0 +1 @@
+curses.h
\ No newline at end of file
diff -Naur gdb-6.8/sim/common/ChangeLog.sts-gdb stsgdb-6.8/sim/common/ChangeLog.sts-gdb
--- gdb-6.8/sim/common/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/sim/common/ChangeLog.sts-gdb	2008-09-11 10:33:09.000000000 +0100
@@ -0,0 +1,7 @@
+2006-03-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* run.c: Replace cygdrive support with cygpath() added to libiberty.
+
+2006-02-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* run.c (main): Add /cygdrive/ support for use under MinGW.
diff -Naur gdb-6.8/sim/common/run.c stsgdb-6.8/sim/common/run.c
--- gdb-6.8/sim/common/run.c	2008-01-01 22:53:23.000000000 +0000
+++ stsgdb-6.8/sim/common/run.c	2008-09-11 10:33:09.000000000 +0100
@@ -1,6 +1,7 @@
 /* run front end support for all the simulators.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
    2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -183,6 +184,8 @@
   if (ac <= 0)
     usage ();
 
+  CYGPATH (av[0]);
+
   name = *av;
   prog_args = av;
 
diff -Naur gdb-6.8/sim/sh/ChangeLog.sts-gdb stsgdb-6.8/sim/sh/ChangeLog.sts-gdb
--- gdb-6.8/sim/sh/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/sim/sh/ChangeLog.sts-gdb	2008-09-11 10:33:58.000000000 +0100
@@ -0,0 +1,6 @@
+2007-08-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl27537:
+	* interp.c (sim_store_register): Add missing registers.
+	(sim_fetch_register): Likewise.
+	(set_sr): Only set MOD if a DSP target.
diff -Naur gdb-6.8/sim/sh/interp.c stsgdb-6.8/sim/sh/interp.c
--- gdb-6.8/sim/sh/interp.c	2008-02-04 17:26:07.000000000 +0000
+++ stsgdb-6.8/sim/sh/interp.c	2008-09-11 10:33:58.000000000 +0100
@@ -532,6 +532,9 @@
 #define XF(n) (saved_state.asregs.fregs[(n) >> 5].i[(n) & 0x1f])
 #define SET_XF(n,EXP) (saved_state.asregs.fregs[(n) >> 5].i[(n) & 0x1f] = (EXP))
 
+#define FI_BANK(n) XF((1 << 5) | (n))
+#define SET_FI_BANK(n,EXP) SET_XF((1 << 5) | (n), (EXP))
+
 #define RS saved_state.asregs.cregs.named.rs
 #define RE saved_state.asregs.cregs.named.re
 #define MOD (saved_state.asregs.cregs.named.mod)
@@ -614,7 +617,8 @@
 	}
     }
   saved_state.asregs.cregs.named.sr = new_sr;
-  SET_MOD (MOD);
+  if (target_dsp)
+    SET_MOD (MOD);
 }
 
 static void INLINE 
@@ -2198,6 +2202,9 @@
     case SIM_SH_VBR_REGNUM:
       VBR = val;
       break;
+    case SIM_SH_DBR_REGNUM:
+      DBR = val;
+      break;
     case SIM_SH_MACH_REGNUM:
       MACH = val;
       break;
@@ -2221,6 +2228,14 @@
     case SIM_SH_FR15_REGNUM:
       SET_FI (rn - SIM_SH_FR0_REGNUM, val);
       break;
+    case SIM_SH_XF0_REGNUM: case SIM_SH_XF1_REGNUM: case SIM_SH_XF2_REGNUM:
+    case SIM_SH_XF3_REGNUM: case SIM_SH_XF4_REGNUM: case SIM_SH_XF5_REGNUM:
+    case SIM_SH_XF6_REGNUM: case SIM_SH_XF7_REGNUM: case SIM_SH_XF8_REGNUM:
+    case SIM_SH_XF9_REGNUM: case SIM_SH_XF10_REGNUM: case SIM_SH_XF11_REGNUM:
+    case SIM_SH_XF12_REGNUM: case SIM_SH_XF13_REGNUM: case SIM_SH_XF14_REGNUM:
+    case SIM_SH_XF15_REGNUM:
+      SET_FI_BANK (rn - SIM_SH_XF0_REGNUM, val);
+      break;
     case SIM_SH_DSR_REGNUM:
       DSR = val;
       break;
@@ -2269,6 +2284,9 @@
     case SIM_SH_SPC_REGNUM:
       SPC = val;
       break;
+    case SIM_SH_SGR_REGNUM:
+      SGR = val;
+      break;
     /* The rn_bank idiosyncracies are not due to hardware differences, but to
        a weird aliasing naming scheme for sh3 / sh3e / sh4.  */
     case SIM_SH_R0_BANK0_REGNUM: case SIM_SH_R1_BANK0_REGNUM:
@@ -2374,6 +2392,9 @@
     case SIM_SH_VBR_REGNUM:
       val = VBR;
       break;
+    case SIM_SH_DBR_REGNUM:
+      val = DBR;
+      break;
     case SIM_SH_MACH_REGNUM:
       val = MACH;
       break;
@@ -2397,6 +2418,14 @@
     case SIM_SH_FR15_REGNUM:
       val = FI (rn - SIM_SH_FR0_REGNUM);
       break;
+    case SIM_SH_XF0_REGNUM: case SIM_SH_XF1_REGNUM: case SIM_SH_XF2_REGNUM:
+    case SIM_SH_XF3_REGNUM: case SIM_SH_XF4_REGNUM: case SIM_SH_XF5_REGNUM:
+    case SIM_SH_XF6_REGNUM: case SIM_SH_XF7_REGNUM: case SIM_SH_XF8_REGNUM:
+    case SIM_SH_XF9_REGNUM: case SIM_SH_XF10_REGNUM: case SIM_SH_XF11_REGNUM:
+    case SIM_SH_XF12_REGNUM: case SIM_SH_XF13_REGNUM: case SIM_SH_XF14_REGNUM:
+    case SIM_SH_XF15_REGNUM:
+      val = FI_BANK (rn - SIM_SH_XF0_REGNUM);
+      break;
     case SIM_SH_DSR_REGNUM:
       val = DSR;
       break;
@@ -2445,6 +2474,9 @@
     case SIM_SH_SPC_REGNUM:
       val = SPC;
       break;
+    case SIM_SH_SGR_REGNUM:
+      val = SGR;
+      break;
     /* The rn_bank idiosyncracies are not due to hardware differences, but to
        a weird aliasing naming scheme for sh3 / sh3e / sh4.  */
     case SIM_SH_R0_BANK0_REGNUM: case SIM_SH_R1_BANK0_REGNUM:
diff -Naur gdb-6.8/sim/testsuite/sim/sh/allinsn.exp stsgdb-6.8/sim/testsuite/sim/sh/allinsn.exp
--- gdb-6.8/sim/testsuite/sim/sh/allinsn.exp	2004-09-13 22:02:33.000000000 +0100
+++ stsgdb-6.8/sim/testsuite/sim/sh/allinsn.exp	2008-09-11 10:33:38.000000000 +0100
@@ -6,31 +6,51 @@
 set global_ld_options ""
 
 foreach opt $board_variant_list {
-    switch "x$opt" {
-	x-ml { set global_as_options "-little --defsym LITTLE=1"
-	       set global_ld_options "-EL" }
+    if {[istarget sh-superh-elf]} {
+	# little endian is default
+        set endian little
+	switch "x$opt" {
+	    x-mb { set global_as_options "-big"
+		   set global_ld_options "-EB"
+		   set endian big }
+	}
+    } else {
+        set endian big
+	switch "x$opt" {
+	    x-ml { set global_as_options "-little --defsym LITTLE=1"
+		   set global_ld_options "-EL"
+		   set endian little }
+	}
     }
 }
 
 if [istarget sh-*elf] {
+if {$endian == "big"} {
+    # Some tests don't run in little endian
+    run_sim_test bclr.s   sh
+    run_sim_test bset.s   sh
+    run_sim_test bst.s    sh
+    run_sim_test div.s    sh
+    run_sim_test fcnvds.s sh
+    run_sim_test mov.s    $all
+    run_sim_test movi.s   $all
+    run_sim_test mulr.s   sh
+    run_sim_test resbank.s sh
+    run_sim_test movua.s  $all
+}
     run_sim_test add.s    $all
     run_sim_test and.s    $all
     run_sim_test bandor.s sh
     run_sim_test bandornot.s sh
-    run_sim_test bclr.s   sh
     run_sim_test bld.s    sh
     run_sim_test bldnot.s sh
-    run_sim_test bset.s   sh
-    run_sim_test bst.s    sh
     run_sim_test bxor.s   sh
     run_sim_test clip.s   sh
-    run_sim_test div.s    sh
     run_sim_test dmxy.s   shdsp
     run_sim_test fabs.s   sh
     run_sim_test fadd.s   sh
     run_sim_test fcmpeq.s sh
     run_sim_test fcmpgt.s sh
-    run_sim_test fcnvds.s sh
     run_sim_test fcnvsd.s sh
     run_sim_test fdiv.s   sh
     run_sim_test fipr.s   sh
@@ -52,12 +72,8 @@
     run_sim_test loop.s   shdsp
     run_sim_test macl.s   sh
     run_sim_test macw.s   sh
-    run_sim_test mov.s    $all
-    run_sim_test movi.s   $all
     run_sim_test movli.s  $all
-    run_sim_test movua.s  $all
     run_sim_test movxy.s  shdsp
-    run_sim_test mulr.s   sh
     run_sim_test pabs.s   shdsp
     run_sim_test paddc.s  shdsp
     run_sim_test padd.s   shdsp
@@ -75,7 +91,6 @@
     run_sim_test psub.s   shdsp
     run_sim_test pswap.s  shdsp
     run_sim_test pushpop.s sh
-    run_sim_test resbank.s sh
     run_sim_test sett.s   sh
     run_sim_test shll.s   $all
     run_sim_test shll2.s  $all
diff -Naur gdb-6.8/sim/testsuite/sim/sh/ChangeLog.sts-gdb stsgdb-6.8/sim/testsuite/sim/sh/ChangeLog.sts-gdb
--- gdb-6.8/sim/testsuite/sim/sh/ChangeLog.sts-gdb	1970-01-01 01:00:00.000000000 +0100
+++ stsgdb-6.8/sim/testsuite/sim/sh/ChangeLog.sts-gdb	2008-09-11 10:33:38.000000000 +0100
@@ -0,0 +1,4 @@
+2006-06-15  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* allinsn.exp: Add support for sh-superh-elf configuration.
+	Don't test instructions which don't work in the currect endian.
