Patch to add in support for ST200. This patch is in effect a dump 
of the developement tree so contains sh4 patches etc etc. More work 
required to cut this down to something minimal

Signed-off-by: David McKay <david.mckay@st.com>



diff --git a/ChangeLog b/ChangeLog
new file mode 100644
index 0000000..f7182ee
--- /dev/null
+++ b/ChangeLog
@@ -0,0 +1,11378 @@
+2006-05-14  Ben Elliston  <bje@au.ibm.com>
+
+	* config.sub, config.guess: Update from upstream sources.
+
+2006-05-12  Ben Elliston  <bje@au.ibm.com>
+
+	* config.sub, config.guess: Update from upstream sources.
+
+2006-05-04  Steve Ellcey  <sje@cup.hp.com>
+
+	* blt, iwidgets, mmalloc: Remove directories.
+
+2006-05-01  DJ Delorie  <dj@redhat.com>
+
+	* configure.in: Restore CFLAGS if GMP isn't present.
+	* configure: Regenerate.
+
+2006-04-18  DJ Delorie  <dj@redhat.com>
+
+	* configure.in (m32c): Build libstdc++-v3.  Pass flags to
+	reference libgloss so that libssp can be built in a combined
+	tree.
+	* configure: Regenerate.
+
+2006-04-10  Ben Elliston  <bje@au.ibm.com>
+
+	* contrib: Remove directory.
+
+2006-04-06  Carlos O'Donell <carlos@codesourcery.com>
+
+	* Makefile.tpl: Add install-html target.
+	* Makefile.def: Add install-html target.
+	* Makefile.in: Regenerate.
+	* configure.in: Add --with-datarootdir, --with-docdir,
+	and --with-htmldir options.
+	* configure: Regenerate.
+
+2006-03-31  Ben Elliston  <bje@au.ibm.com>
+
+	PR binutils/1860
+	* configure.in: Require makeinfo 4.4 or higher.
+	* configure: Regenerate.
+
+2006-03-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.in: Regenerate.
+
+2006-03-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync with gcc:
+	2006-03-10  Aldy Hernandez  <aldyh@redhat.com>
+
+        * configure.in: Handle --disable-<component> generically.
+        * configure: Regenerate.
+
+	2006-02-21 Rafael Avila de Espindola <rafael.espindola@gmail.com>
+        
+        * Makefile.tpl  (BUILD_CONFIGDIRS): Remove.
+        (TARGET_CONFIGDIRS): Remove.
+        * configure.in: Remove AC_SUBST(target_configdirs).
+        * Makefile.in, configure: Regenerated.
+
+
+2006-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libgcj/17311
+	* ltmain.sh: Don't use "$finalize_rpath" for compile.
+
+2006-02-20  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/25670
+
+	* Makefile.tpl ([+compare-target+]): Print explanation messages.
+
+	* Makefile.def (ADAFLAGS, BOOT_ADAFLAGS, LANGUAGES): New flags_to_pass.
+	* Makefile.tpl (BASE_FLAGS_TO_PASS): Support optional flags_to_pass.
+	(EXTRA_GCC_FLAGS): Remove ADAFLAGS, BOOT_ADAFLAGS, LANGUAGES,
+	BUILD_PREFIX, BUILD_PREFIX_1. 
+	* configure.in: (BUILD_PREFIX, BUILD_PREFIX_1): Don't substitute.
+
+	* Makefile.def (bootstrap stage 1): Pass LIBCFLAGS too.
+	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Override LIBCFLAGS too.
+
+	* Makefile.tpl (configure-stage[+id+]-[+prefix+][+module+],
+	all-stage[+id+]-[+prefix+][+module+], : Use $(current_stage) instead
+	of `cat stage_current`.  Always provide the `r' and `s' variables.
+	(clean-stage[+id+]-[+prefix+][+module+]): Likewise, and make it into
+	a single shell execution.
+	(configure-[+prefix+][+module+], all-[+prefix+][+module+]): For
+	bootstrapped modules, make the stage1 module if the build was not
+	started yet, else build the current stage.
+	(all-host, all-target): Omit bootstrapped modules (if bootstrapping).
+	(all-build, all-host, all-target, [+make_target+]-host,
+	[+make_target+]-target): Do not use \-continued lines.
+	(target modules): Depend on stage_last, not all-gcc, if bootstrapping.
+	(current_stage, restrap, stage_last): New.
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2006-02-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc:
+
+	2006-01-31  Richard Guenther  <rguenther@suse.de>
+		    Paolo Bonzini  <bonzini@gnu.org>
+
+        * Makefile.def (target_modules): Add libgcc-math target module.
+        * configure.in (target_libraries): Add libgcc-math target library.
+        (--enable-libgcc-math): New configure switch.
+        * Makefile.in: Re-generate.
+        * configure: Re-generate.
+        * libgcc-math: New toplevel directory.
+
+	2006-01-18  Richard Henderson  <rth@redhat.com>
+	            Jakub Jelinek  <jakub@redhat.com>
+	            Diego Novillo  <dnovillo@redhat.com>
+
+        * libgomp: New directory.
+        * Makefile.def: Add target_module libgomp.
+        * Makefile.in: Regenerate.
+        * configure.in (target_libraries): Add target-libgomp.
+        * configure: Regenerate.
+
+2006-02-14  Paolo Bonzini  <bonzini@gnu.org>
+	    Andreas Schwab  <schwab@suse.de>
+	 
+	* configure: Regenerate.
+
+2006-01-16  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Set with_gnu_as, with_gnu_ld, with_newlib earlier.
+	Set md_exec_prefix.  Use ACX_CHECK_INSTALLED_TARGET_TOOL to find
+	the assembler, linker and binutils.
+	* configure: Regenerate.
+
+2006-01-16  Nick Clifton  <nickc@redhat.com>
+
+	* config.sub, config.guess: Sync from config repository.
+
+2006-01-05  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (clean-stage[+id+]-[+prefix+][+module+]): Remove
+	@ from continuation.
+	* Makefile.in: Rebuilt.
+
+2006-01-04  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc:
+
+	2006-01-04  Paolo Bonzini  <bonzini@gnu.org>
+
+        PR bootstrap/24252
+
+        * Makefile.def (flags_to_pass): Add STAGE1_CFLAGS and STAGE1_LANGUAGES.
+        * Makefile.tpl (OBJDUMP): New.
+        (EXTRA_HOST_FLAGS): Add it.
+        (EXTRA_GCC_FLAGS): Remove flags already specified in flags_to_pass.
+
+        * Makefile.tpl (stage[+id+]-start, stage[+id+]-end): Do not try
+        to use symbolic links between directories.  Avoid race conditions
+        or make them harmless.
+        * configure.in: Do not try to use symbolic links between directories.
+
+        * Makefile.def (LEAN): Pass.
+        * Makefile.tpl (LEAN): Define.
+        (stage[+id+]-start): Accept that the previous directory does not
+        exist, if the bootstrap is lean.
+        (stage[+id+]-bubble): Invoke lean bootstrap commands after
+        stage[+id+]-start.  Use a makefile variable and an `if' instead of a
+        configure substitution.
+        ([+compare-target+]): Likewise.
+        ([+bootstrap-target+]-lean): New.
+        * configure.in: Remove lean bootstrap support from here.
+
+        * Makefile.in: Regenerate.
+        * configure: Regenerate.
+
+	2006-01-02  Andreas Schwab  <schwab@suse.de>
+
+        * configure.in: When reconfiguring remove Makefile in
+        all stage directories.
+        * configure: Regenerate.
+
+2005-12-27  Leif Ekblad  <leif@rdos.net>
+
+	* configure.in: Add support for RDOS target.
+	* configure: Regenerate.
+
+2005-12-27  Nick Clifton  <nickc@redhat.com>
+
+	PR binutils/1990
+	* libtool.m4: Synchronize with version in GCC sources.
+
+2005-12-20  Paolo Bonzini  <bonzini@gnu.org>
+
+        Revert Ada-related part of the previous change.
+
+        * Makefile.def (ADAFLAGS, BOOT_ADAFLAGS, ADAFLAGS_FOR_TARGET):
+        Do not pass.
+        * Makefile.tpl (BOOT_ADAFLAGS): Do not define.
+        * Makefile.in: Regenerate.
+        * configure.in: Do not include mt-ppc-aix target fragment.
+        * configure: Regenerate.
+
+2005-12-19  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Select appropriate fragments for PowerPC/AIX.
+	* configure: Regenerate.
+
+	* Makefile.def (flags_to_pass): Add ADAFLAGS, BOOT_ADAFLAGS,
+	BOOT_CFLAGS, BOOT_LDFLAGS.
+	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Handle BOOT_ADAFLAGS,
+	BOOT_CFLAGS, BOOT_LDFLAGS.
+	(TARGET_FLAGS_TO_PASS): Handle ADAFLAGS_FOR_TARGET.
+	(stage[+id+]-bubble): Pass flags recursively to the comparison target.
+	(stage): Fail if we cannot complete the work.
+	* Makefile.in: Regenerate.
+
+2005-12-16  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update copyright year for default
+	copyright.
+
+2005-12-15  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all, do-[+make_target+], do-check, install,
+	install-host-nogcc): Don't invoke $(stage) at the end.
+	* Makefile.in: Regenerate.
+
+2005-12-14  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Flip the top-level bootstrap switch.
+	* configure: Regenerate.
+
+	Merge from gcc:
+
+	2005-12-14  Daniel Jacobowitz  <dan@codesourcery.com>
+
+        * Makefile.tpl: Throughout the file, use : $(MAKE) along with
+        $(stage) and $(unstage).
+        (EXTRA_TARGET_FLAGS): Correct double-quoting.
+        (all): Remove stray semicolon.
+        (local-distclean): Don't handle multilib.tmp and multilib.out.
+        (install.all): Set $s for consistency.
+        (configure-[+prefix+][+module+]): Instead of [+deps+], handle
+        check_multilibs setting.  Always make the install directory.
+        (configure-stage[+id+]-[+prefix+][+module+]): Likewise.
+        Correct @if/@endif.
+        (all-stage[+id+]-[+prefix+][+module+]): Correct @if/@endif.
+        ($(TARGET_SUBDIR)/[+module+]/multilib.out): Remove.
+        (stage[+id+]-start, stage[+id+]-end): Stage $(TARGET_SUBDIR).
+        (multilib.out): Remove.
+        * Makefile.in: Regenerated.
+
+2005-12-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* config.sub: Replace ms1 arch with mt.  Allow ms1 as alias.
+	* configure.in: Replace ms1 arch with mt.
+	* configure: Rebuilt.
+
+2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync with gcc:
+
+2005-12-12  Nathan Sidwell  <nathan@codesourcery.com>
+
+	* config.sub: Replace ms1 arch with mt.  Allow ms1 as alias.
+	* configure.in: Replace ms1 arch with mt.
+	* configure: Rebuilt.
+
+2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync with gcc:
+
+	2005-12-05  Paolo Bonzini  <bonzini@gnu.org>
+
+        * configure.in (CONFIGURED_BISON, CONFIGURED_YACC, CONFIGURED_M4,
+        CONFIGURED_FLEX, CONFIGURED_LEX, CONFIGURED_MAKEINFO): Remove
+        "CONFIGURED_" from the AC_CHECK_PROGS invocation.  Move below.
+        Find in-tree tools if available.
+        (EXPECT, RUNTEST, LIPO, STRIP): Find them and substitute them.
+        (CONFIGURED_*_FOR_TARGET): Don't set nor substitute.
+        (*_FOR_TARGET): Set them with GCC_TARGET_TOOL.
+        (COMPILER_*_FOR_TARGET): New.
+        * Makefile.tpl (HOST_EXPORTS): Add *_FOR_TARGET symbols that gcc needs.
+        (BASE_TARGET_EXPORTS): Use COMPILER_*_FOR_TARGET symbols.
+        (CONFIGURED_*, USUAL_*): Remove.
+        (BISON, YACC, FLEX, LEX, M4, MAKEINFO, EXPECT, RUNTEST, LIPO,
+        STRIP): Use autoconf substitutions.
+        (COMPILER_AS_FOR_TARGET, COMPILER_LD_FOR_TARGET,
+        COMPILER_NM_FOR_TARGET): New.
+        (EXTRA_HOST_FLAGS): Pass LIPO and STRIP.
+
+        (all): Make all-host and all-target in parallel.
+        (do-[+make_target+], do-check, install, [+compare-target+]): Ensure
+        that $$r and $$s are set before invoking a recursive make.
+        (stage[+id+]-bubble): Likewise, and invoke the comparison at the end.
+        ([+bootstrap-target+]): Inline most of the `all' target.
+
+	2005-11-29  Ben Elliston  <bje@au.ibm.com>
+
+        * Makefile.tpl (clean-target-libgcc): Invoke clean-target-libgcc
+        from the gcc build directory.
+        * Makefile.in: Regenerate.
+
+	2005-11-29  Ben Elliston  <bje@au.ibm.com>
+
+        * Makefile.def: Add new libdecnumber host_module.  Make all-gcc
+        depend on all-libdecnumber.
+        * configure.in (host_libs): Include libdecnumber.
+        * Makefile.in: Regenerate.
+        * configure: Likewise.
+
+	2005-11-21  Kean Johnston  <jkj@sco.com>
+
+        * config.sub, config.guess: Sync from upstream sources.
+
+2005-11-11  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* Makefile.def: Remove gdb dependencies for gdbtk.
+	* Makefile.tpl (CONFIGURE_GDB_TK, INSTALL_GDB_TK): New variables.
+	(configure-gdb, install-gdb): New rules.
+	* configure.in: Set CONFIGURE_GDB_TK and INSTALL_GDB_TK.
+	* Makefile.in, configure: Regenerated.
+
+2005-10-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/24297
+	* Makefile.tpl (do-[+make-target+], do-check, install,
+	stage[+id+]-bubble, [+compare-target+]): Ensure $$r and $$s
+	are set before recursing.
+	* Makefile.in: Regenerate.
+
+2005-10-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR bootstrap/18939
+	* Makefile.def (gcc) <target>: Fix thinko.
+	* Makefile.in: Regenerate.
+
+2005-10-17  Bernd Schmidt  <bernd.schmidt@analog.com>
+
+	* configure.in (bfin-*-*): Use test, not brackets, in if statement.
+	* configure: Regenerate.
+
+2005-10-09  Kazu Hirata  <kazu@codesourcery.com>
+
+	* configure.in (arm-*-linux-gnueabi): Add to noconfigdirs
+	target-libffi, target-qthreads, target-libjava, and
+	targetlibobjc.
+	* configure: Regenerate.
+
+2005-10-06  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* Makefile.def (flags_to_pass): Add OBJDUMP_FOR_TARGET.
+	* Makefile.tpl (BASE_TARGET_EXPORTS): Add OBJDUMP.
+	(OBJDUMP_FOR_TARGET, CONFIGURED_OBJDUMP_FOR_TARGET)
+	(USUAL_OBJDUMP_FOR_TARGET): New.
+	(EXTRA_TARGET_FLAGS): Add OBJDUMP.
+	* configure.in: Check for $OBJDUMP_FOR_TARGET.
+	* configure, Makefile.in: Regenerated.
+
+2005-10-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all) [gcc-no-bootstrap]: Make prebootstrap packages
+	before other host packages.
+
+2005-10-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/22340
+
+	* configure.in (default_target): Remove.
+	* Makefile.tpl (all): Do not use prerequisites as subroutines
+	(all) [gcc-bootstrap]: Bootstrap gcc first if it was not done yet.
+	(do-[+make_target+], check, install, [+bootstrap_target+]): Do not
+	use prerequisites as subroutines.
+	(check-host, check-target): New.
+	(bootstrap configure & all targets): Do not use stage*-start
+	if the directory layout is already ok.
+	(non-bootstrap configure & all targets): Prepend a $(unstage).
+	(stage[+id+]-bubble): Do that here.  Do not use NOTPARALLEL.
+	(NOTPARALLEL): Remove.
+	(unstage, stage variables): New variables.
+	(unstage, stage targets): Simply expand to those variables.
+
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2005-10-04  James E Wilson  <wilson@specifix.com>
+
+	* Makefile.def (lang_env_dependencies): Add libmudflap.
+	* Makefile.in: Regenerate.
+
+2005-10-03  Catherine Moore  <clm@cm00re.com>
+
+	* configure.in (bfin-*-*): Support bfin.
+	* configure: Regenerated.
+
+2005-09-30  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* configure.in (*-*-darwin*): Build bfd, binutils and opcodes.
+	* configure: Regenerated.
+
+2005-09-28  Geoffrey Keating  <geoffk@apple.com>
+
+	* Makefile.tpl (BASE_TARGET_EXPORTS): Add LIPO, STRIP.
+	(LIPO_FOR_TARGET): New.
+	(CONFIGURED_LIPO_FOR_TARGET): New.
+	(USUAL_LIPO_FOR_TARGET): New.
+	(STRIP_FOR_TARGET): New.
+	(CONFIGURED_STRIP_FOR_TARGET): New.
+	(USUAL_STRIP_FOR_TARGET): New.
+	* Makefile.def (flags_to_pass): Add LIPO_FOR_TARGET and
+	STRIP_FOR_TARGET.
+	* configure.in: Set LIPO_FOR_TARGET, STRIP_FOR_TARGET,
+	CONFIGURED_LIPO_FOR_TARGET, CONFIGURED_STRIP_FOR_TARGET.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+	
+2005-09-19  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in (powerpc-*-aix*): Add target-libssp to noconfigdirs.
+	(rs6000-*-aix*): Same.
+	* configure: Regenerate.
+
+2005-09-14  Francois-Xavier Coudert  <coudert@clipper.ens.fr>
+
+	* configure.in: Recognize f95 in the --enable-languages option,
+	and substitute it for fortran, issuing a warning.
+	* configure: Regenerate.
+
+2005-09-07  Ben Elliston  <bje@au.ibm.com>
+
+	Import from Autoconf sources:
+
+	2005-09-06  Paul Eggert  <eggert@cs.ucla.edu>
+	* move-if-change: Don't output "$2 is unchanged"; suggested by Ben
+	Elliston.  Handle weird characters correctly.
+
+2005-08-30  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in (*-*-vxworks*):  Add target-libstdc++-v3 to noconfigdirs.
+	* configure:  Regenerated.
+
+2005-08-20  Richard Earnshaw  <richard.earnshaw@arm.com>
+
+        * Makefile.def (libssp): Add to lang_env_dependencies.
+        * Makefile.in: Regenerate.
+
+2005-08-17  Christian Groessler  <chris@groessler.org>
+
+	* Makefile.tpl: (USUAL_CC_FOR_TARGET): Add missing trailing slash.
+	* Makefile.in: Regenerate.
+
+2005-08-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Replace NCN_STRICT_CHECK_TOOL with
+	NCN_STRICT_CHECK_TOOLS, and likewise for NCN_STRICT_CHECK_TARGET_TOOLS.
+	Look for alternate names of the target cc and c++
+	* configure: Regenerate.
+
+2005-08-08  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in (CC_FOR_TARGET, CXX_FOR_TARGET, GCJ_FOR_TARGET,
+	GCC_FOR_TARGET, RAW_CXX_FOR_TARGET, GFORTRAN_FOR_TARGET): Find
+	them with NCN_STRICT_CHECK_TARGET_TOOL, like the other target
+	tools; remove code to manually set them.
+	(Target tools): Look in the environment for them.
+	* Makefile.tpl (CC_FOR_TARGET, CXX_FOR_TARGET, GCJ_FOR_TARGET,
+	GCC_FOR_TARGET, RAW_CXX_FOR_TARGET, GFORTRAN_FOR_TARGET): Redefine.
+	(AS_FOR_TARGET, LD_FOR_TARGET, NM_FOR_TARGET): Look into gcc
+	build directory.
+	(CONFIGURED_CC_FOR_TARGET, CONFIGURED_CXX_FOR_TARGET,
+	CONFIGURED_GCJ_FOR_TARGET, CONFIGURED_GCC_FOR_TARGET,
+	CONFIGURED_GFORTRAN_FOR_TARGET, USUAL_CC_FOR_TARGET,
+	USUAL_CXX_FOR_TARGET, USUAL_GCJ_FOR_TARGET, USUAL_GCC_FOR_TARGET,
+	USUAL_RAW_CXX_FOR_TARGET, USUAL_GFORTRAN_FOR_TARGET): New.
+	(CXX_FOR_TARGET_FOR_RECURSIVE_MAKE,
+	RAW_CXX_FOR_TARGET_FOR_RECURSIVE_MAKE, RECURSE_FLAGS): Delete.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2005-07-27  Mark Mitchell  <mark@codesourcery.com>
+
+	* Makefile.tpl (EXTRA_TARGET_FLAGS): Set LDFLAGS=LDFLAGS_FOR_TARGET.
+	* Makefile.def (flags_to_pass): Add LDFLAGS_FOR_TARGET. 
+	* Makefile.in: Regenerated.
+
+2005-07-26  Mark Mitchell  <mark@codesourcery.com>
+
+	* Makefile.tpl (SYSROOT_CFLAGS_FOR_TARGET): New variable.
+	(CFLAGS_FOR_TARGET): Use it.
+	(CXXFLAGS_FOR_TARGET): Likewise.
+	* Makefile.in: Regenerated.
+	* configure.in (--with-build-sysroot): New option.
+	* configure: Regenerated.
+
+2005-07-24  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Wrap install between unstage and stage
+	* Makefile.in: Regenerate.
+
+2005-07-16  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* all files: Update FSF address.
+
+2005-07-14  Jim Blandy  <jimb@redhat.com>
+
+	* configure.in: Add cases for Renesas m32c.
+	* configure: Regenerated.
+	
+2005-07-14  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* COPYING, compile, config-ml.in, config.guess,
+	config.sub, install-sh, missing, mkinstalldirs,
+	symlink-tree, ylwrap: Sync from upstream sources.
+
+2005-07-13  Eric Christopher  <echristo@redhat.com>
+
+	* configure.in: Add toplevel noconfigdir support for tpf.
+	* configure: Regenerate.
+
+2005-07-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* Makefile.def (target_modules): Add libssp.
+	* configure.in (target_libraries): Add target-libssp.
+	* configure: Rebuilt.
+	* Makefile.in: Rebuilt.
+
+2005-07-11  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR ada/22340
+
+	* Makefile.def: Sync with gcc.
+	* Makefile.tpl (POSTSTAGE1_FLAGS_TO_PASS): Fix pasto.
+	* Makefile.in: Regenerate.
+
+2005-07-07  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.def (flags_to_pass): Add CFLAGS_FOR_BUILD.
+	* Makefile.tpl (EXTRA_GCC_FLAGS): Don't pass CFLAGS_FOR_BUILD here.
+	* Makefile.in: Regenerated.
+
+2005-07-07  Kazu Hirata  <kazu@codesourcery.com>
+
+	* configure.in: Add --enable-libssp and --disable-libssp.
+	* configure: Regenerate with autoconf-2.13.
+
+2005-07-06  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in: Don't build sim or rda when targetting darwin.
+	* configure: Regenerate.
+
+2005-07-04  Ben Elliston  <bje@gnu.org>
+
+	* src-release (do-proto-toplev): Remove dejagnu bits.
+	(DEJAGNU_SUPPORT_DIRS): Remove.
+	(dejagnu.tar.bz2, dejagnu.tar): Likewise.
+	(GDBD_SUPPORT_DIRS): Likewise.
+	(gdb+dejagnu.tar.bz2, gdb+dejagnu.tar): Likewise.
+	(INSIGHTD_SUPPORT_DIRS): Likewise.
+	(insight+dejagnu.tar.bz2, insight+dejagnu.tar): Likewise.
+
+2005-06-30  Ben Elliston  <bje@gnu.org>
+
+	* setup.com (mpw): Remove unused directive.
+
+2005-06-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (stagefeedback): Come after profile.
+	Define profiledbootstrap target.
+	* Makefile.tpl (profiledbootstrap): Remove.
+	(stageprofile-end): Zap stagefeedback.
+	(stagefeedback-start): Copy all .gcda files, not only GCC's.
+	* Makefile.in: Regenerate.
+
+2005-06-13  Zack Weinberg  <zack@codesourcery.com>
+
+	* depcomp: Update from automake CVS.  Add 'ia64hp' stanza.
+	In 'cpp' stanza, support '#line' as well as '# '.
+
+2005-06-07  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (unsupported_languages): New macro.
+	<mmix-knuth-mmixware>: Set unsupported_languages.  Name explicit
+	non-ported target libraries in noconfigdirs.
+	<cris-*, crisv32-*> Ditto, except for non-aout, non-elf,
+	non-linux-gnu.  Remove libgcj_ex_libffi.
+ 	<lang_frag loop>: Set add_this_lang=no if the language is in
+	unsupported_languages.
+	* configure: Regenerate.
+
+2005-06-04  Tobias Schl"uter  <tobias.schlueter@physik.uni-muenchen.de>
+
+	* configure.in: Fix typo in handling of --with-mpfr-dir.
+	* configure: Regenerate.
+
+2005-06-02  Jim Blandy  <jimb@redhat.com>
+
+	* config.sub: Add cases for the Renesas m32c.  (This patch has been
+	accepted into the master sources.)
+
+2005-06-02  Aldy Hernandez  <aldyh@redhat.com>
+            Michael Snyder  <msnyder@redhat.com>
+            Stan Cox  <scox@redhat.com>
+
+        * configure.in: Set noconfigdirs for ms1.
+
+        * configure: Regenerate.
+
+2005-05-25  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (stage[+id+]-start): Iterate over target module as well.
+	(Dependencies): Consider target modules for bootstrap dependencies.
+	Make target bootstrap modules depend on each stage's gcc.
+	* Makefile.in: Regenerate.
+
+2005-05-20  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (configure-gcc): Depend on binutils having been built.
+	(all-gcc): No need to do it here.
+	* Makefile.in: Regenerate.
+
+2005-05-19  Paul Brook  <paul@codesourcery.com>
+
+	* configure.in: Rewrite misleading error message when requested 
+	language cannot be built.
+	* configure: Regenerate.
+
+2005-05-15  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	* ylwrap: Import from Automake 1.9.5.
+
+2005-05-04  Mike Stump  <mrs@apple.com>
+
+	* configure.in: Always pass --target to target configures as
+	otherwise rebuilds that do --recheck will fail.
+	* configure: Rebuilt.
+
+2005-05-04  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (POSTSTAGE1_HOST_EXPORTS): Rename from
+	STAGE_HOST_EXPORTS.
+	(configure, all): Add bootstrap support.
+	(Host modules, target modules): Pass post-stage1 flags and exports.
+	(Top-level bootstrap): Remove bootstrap rules, expanded elsewhere.
+	* Makefile.in: Regenerate.
+
+2005-04-29  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc:
+
+	2005-04-22  Bernd Schmidt  <bernd.schmidt@analog.com>
+
+        * config.sub: Update from master copy.
+
+	2005-04-19  Hans-Peter Nilsson  <hp@axis.com>
+
+        * configure.in <crisv32-*-*, cris-*-*>: New local variable
+        libgcj_ex_libffi.  Have specific match for *-*-linux*.  Separate
+        matches for "*-*-aout" and "*-*-elf".  Don't disable libffi for
+        "*-*-elf" and "*-*-linux*".
+        * configure: Regenerate.
+
+2005-04-06  Paolo Bonzini  <bonzini@gnu.org>
+
+        * Makefile.tpl (BUILD_CONFIGARGS): Include --with-build-subdir.
+	(TARGET_CONFIGARGS): Include --with-target-subdir.
+	(configure, all): New macros.  Use them throughout.
+
+2005-04-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Sync with gcc.
+	* Makefile.in: Regenerate.
+
+2005-03-30  J"orn Rennecke <joern.rennecke@st.com>
+
+	* config/mh-mingw32: Delete.
+	* configure.in: Don't use it.
+	* configure: Regenerate.
+
+2005-03-31  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (bfd, opcodes, libstdc++-v3, libmudflap): Set lib_path.
+	* Makefile.tpl (SET_LIB_PATH, REALLY_SET_LIB_PATH): Remove.
+	(HOST_EXPORTS, STAGE_HOST_EXPORTS, TARGET_EXPORTS): Set $(RPATH_ENVVAR).
+	(HOST_LIB_PATH): Generate from Makefile.def.
+	(TARGET_LIB_PATH): Likewise.
+	(Old bootstrap targets): Include TARGET_LIB_PATH into RPATH_ENVVAR.
+	* Makefile.in: Regenerate.
+	* configure.in (set_lib_path, SET_LIB_PATH, SET_GCC_LIB_PATH): Remove.
+	(RPATH_ENVVAR): Include Darwin case.
+	* configure: Regenerate.
+
+2005-03-25  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in (RPATH_ENVVAR): Set to DYLD_LIBRARY_PATH on Darwin.
+	* configure: Regenerate.
+
+2005-03-21  Zack Weinberg  <zack@codesourcery.com>
+
+	* Makefile.def: Remove libstdcxx_incdir, libsubdir, gxx_include_dir,
+	gcc_version, and gcc_version_trigger from set of flags to pass.
+	* Makefile.tpl: Remove definitions of above variables.
+	(config.status): Remove dependency on $(gcc_version_trigger).
+	* Makefile.in: Regenerate.
+	* configure.in: Do not reference config/gcc-version.m4 nor
+	config/gxx-include-dir.m4.  Do not invoke TL_AC_GCC_VERSION nor
+	TL_AC_GXX_INCLUDE_DIR.  Do not set gcc_version_trigger.
+	* configure: Regenerate.
+
+2005-03-16  Manfred Hollstein  <manfred.h@gmx.net>
+	    Andrew Pinski <pinskia@physics.uc.edu>
+
+	* Makefile.tpl (check-[+module+]): Fix shell statement inside if ... fi.
+	* Makefile.in: Regenerate.
+
+2005-03-01  Alexandre Oliva  <aoliva@redhat.com>
+
+	PR libgcj/20160
+	* ltmain.sh: Avoid creating archives with components that have
+	duplicate basenames.
+
+2005-02-28  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR bootstrap/20250
+	* Makefile.tpl (HOST target installs): Fix copy and pasto, use install
+	instead of check.
+	* Makefile.in: Regenerate.
+
+2005-02-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	Sync from gcc.
+
+	2005-02-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/17383
+	* Makefile.def (target_modules): Remove "stage", now unnecessary.
+	* Makefile.tpl (HOST_SUBDIR): New substitution.
+	(STAGE_HOST_EXPORTS, EXPECT, HOST_LIB_PATH, USUAL_AR_FOR_TARGET,
+	USUAL_AS_FOR_TARGET, USUAL_DLLTOOL_FOR_TARGET, USUAL_GCC_FOR_TARGET,
+	USUAL_LD_FOR_TARGET, USUAL_NM_FOR_TARGET, USUAL_OBJDUMP_FOR_TARGET,
+	USUAL_RANLIB_FOR_TARGET, USUAL_WINDRES_FOR_TARGET): Use it.
+	(Host modules, Bootstrapped modules): Use it.
+	(Build modules, Target modules): Do not create symlink trees,
+	always configure out-of-srcdir.
+	(distclean): Try removing $(host_subdir) with rm before using rm -rf.
+	* configure.in (FLAGS_FOR_TARGET, CC_FOR_TARGET, GCJ_FOR_TARGET,
+	GFORTRAN_FOR_TARGET, CXX_FOR_TARGET, RAW_CXX_FOR_TARGET): Use
+	$(HOST_SUBDIR).  Create a symlink for host_subdir.
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+	Merged from libada-gnattools-branch:
+	2004-11-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def: Add gnattools as a module, depending on target-libada.
+	* Makefile.in: Regenerate.
+	* configure.in: Include gnattools in host_tools; disable it if ada
+	is disabled.
+	* configure: Regenerate.
+
+2005-02-23  Nick Clifton  <nickc@redhat.com>
+
+	* configure: Regenerate.
+
+2005-02-22  Paul Schlie  <schlie@comcast.net>
+
+	* configure.in: Allow darwin targeted ports to build tk, itcl and
+	libgui.
+
+2005-02-21  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	PR libgcj/10353
+	* configure.in (noconfigdirs) <sparc-*-solaris2.[0-6]>: Add libgcj.
+	* configure: Regenerate.
+
+2005-02-08  Andrew Cagney  <cagney@gnu.org>
+
+	* MAINTAINERS: Delete reference to dejagnu/ and mmalloc/ from the
+	gdb/ section.  Update GDB's URL.
+
+2005-01-31  Andrew Cagney  <cagney@gnu.org>
+
+	* gettext.m4: Only set ENABLE_NLS when gettext is present.
+
+2005-01-29  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (noconfigdirs) <crisv32-*-*>: Match like cris-*-*.
+	<crisv32-*-*, cris-*-*>: Only disable target-newlib and
+	target-libgloss when not *-*-elf and *-*-aout.
+	* configure: Regenerate.
+
+2005-01-27  Andrew Cagney  <cagney@gnu.org>
+
+	* gettext.m4: Don't use NONE as a default for CATOBJEXT.
+
+2005-01-24  Andrew Cagney  <cagney@gnu.org>
+
+	* gettext.m4: Only fall back to ../intl/ when it's present.
+
+2005-01-17  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* install-sh, config.sub: Import from upstream.
+
+2005-01-17  Kelley Cook  <kcook@gcc.gnu.org>
+
+	PR bootstrap/18222
+	* Makefile.def: Pass CPPFLAGS_FOR_TARGET.
+	* Makefile.tpl: Define target CPPFLAGS on CPPFLAGS_FOR_TARGET.
+	* Makefile.in: Regenerate.
+
+2005-01-03  Paolo Bonzini  <bonzini@gnu.org>
+
+	Revert 2004-12-28 Makefile changes, a better fix will be
+	applied to mainline and src after GCC 4.0 branches.
+
+2004-12-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/17383
+
+	* Makefile.def (target_modules): Remove stage parameter,
+	it is always true now.
+	* Makefile.tpl (configure-build-[+module+],
+	configure-target-[+module+]): Always build symlink tree
+	for the directory and for include.  BUILD_SUBDIR and
+	TARGET_SUBDIR cannot be . anymore.
+	* Makefile.in: Regenerate.
+
+2004-12-25  David Edelsohn  <edelsohn@gnu.org>
+
+	Revert 2004-12-08 Makefile changes.
+
+2004-12-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.in (sh64-*-*): Reenable gprof.
+	* configure: Regenerate.
+
+2004-12-09  Jim Blandy  <jimb@redhat.com>
+
+	* MAINTAINERS: List 'depcomp' as part of automake.
+
+2004-12-08  David Edelsohn  <edelsohn@gnu.org>
+
+	* Makefile.def (flags_to_pass): Add PICFLAG_FOR_TARGET.
+	* Makefile.tpl (EXTRA_HOST_FLAGS): Add PICFLAG.
+	(EXTRA_TARGET_FLAGS): Add PICFLAG.
+	* Makefile.in: Regenerate.
+
+2004-12-07  Matt Kraai  <kraai@ftbfs.org>
+
+	* Makefile.tpl: Generate normal dependencies if the LHS module is
+	not bootstrapped.
+	* Makefile.in: Regenerate.
+
+2004-12-03  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in: Include config/gxx-include-dir.m4.  Use
+	TL_AC_GXX_INCLUDE_DIR.  Remove some now-redundant AC_SUBSTs.
+	* configure: Regenerate.
+
+2004-12-03  Richard Sandiford  <rsandifo@redhat.com>
+
+	* config.if: Delete.
+	* configure.in: Set libstdcxx_incdir directly.
+	* configure: Regenerate.
+	* MAINTAINERS: Remove mention of config.if.
+	* src-release (DEVO_SUPPORT): Remove config.if.
+
+2004-12-02  Eric Christopher  <echristo@redhat.com>
+
+	* Makefile.tpl (clean-target-libgcc): Add stmp-dirs to list
+	of things to remove.
+	* Makefile.in: Regenerate.
+
+2004-12-02  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in: Clear gcc_version_trigger if the file doesn't exist.
+	* configure: Regenerate.
+
+2004-12-02  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in: Include config/gcc-version.m4.  Use TL_AC_GCC_VERSION
+	to set gcc_version_trigger.  Remove some now-redundant AC_SUBSTs.
+	* configure: Regenerate.
+
+2004-11-26  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* configure.in (hppa*-*-linux*): Don't add libgcj to noconfigdirs.
+	(hppa*64*-*-*): Delete incorrect comment.
+	* configure: Rebuilt.
+
+2004-11-15  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* install-sh, compile: Import from automake.
+
+2004-11-15  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* config.guess, config.sub:  Import from savannnah.
+
+2004-11-12  Mike Stump  <mrs@apple.com>
+
+	* Makefile.def: Add html support.
+	* Makefile.tpl: Likewise.
+	* Makefile.in: Regenerate.
+
+2004-11-11  Geoffrey Keating  <geoffk@apple.com>
+
+	PR 18423
+	* configure.in: Remove all instances of build-fixincludes from
+	noconfigdirs.
+	(build_configargs): Supply --target to subdirectories.
+	* configure: Regenerate.
+
+	* Makefile.def: Make gcc install depend on fixincludes install.
+	* Makefile.in: Regenerate.
+
+2004-11-08  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [mmix-*-*]: Disable
+	target-libgfortran.
+	* configure: Regenerate.
+
+2004-11-07  David Edelsohn  <edelsohn@gnu.org>
+
+	* config-ml.in: Pass FCFLAGS for multilibs, handle GFORTRAN
+	like CC.
+
+2004-11-05  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (host fixincludes): Specify missing targets.
+	* Makefile.in: Regenerate.
+
+2004-11-04  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR other/17783
+	* configure.in: Set up LD_LIBRARY_PATH by default for gcc.
+	* configure: Regenerated.
+
+2004-11-04  Daniel Jacobowitz  <dan@debian.org>
+
+	* configure.in (arm-*-oabi*, thumb-*-oabi*): Remove.
+	* configure: Regenerated.
+
+2004-10-28  Eric B. Weddington  <ericw@evcohs.com>
+
+	PR target/18151
+	* configure.in (case ${target}): Do not build fixincludes for avr.
+	* configure: Regenerated.
+
+2004-10-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in (case ${target}): Do not build fixincludes
+	on platforms where it is not used.
+	* configure: Regenerated.
+
+2004-10-23  Daniel Jacobowitz  <dan@debian.org>
+
+	* configure.in: Use an absolute path to install-sh.
+	* configure: Regenerated.
+
+2004-10-19  Andrew Cagney  <cagney@gnu.org>
+
+	* src-release (do-djunpack, do-md5sum): Install the generated file
+	directly into the proto-toplev/ directory.
+
+2004-10-19  Andrew Cagney  <cagney@gnu.org>
+
+	* src-release (GDB_SUPPORT_DIRS): Remove utils and intl.
+
+2004-10-12  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.in (*-*-cygwin*): Supress warning if newlib not present.
+	* configure: Regenerate.
+
+2004-10-06  Paolo Bonzini  <bonzini@gnu.org>
+
+	Fix wrong conflict resolution in:
+
+	2004-08-16  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.in: Regenerate.
+	* Makefile.tpl (Autogenerated `all-*' targets): Invoke $(TARGET-*)
+	in the recursive `make', instead of hardwiring `all'.
+	(Autogenerated TARGET-* variables): New.
+
+2004-10-05  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	Merged from GCC / libtool upstream:
+	2004-10-02  P.J. Darcy  <darcypj@us.ibm.com>
+	* ltcf-c.sh (tpf*): Add ld_shlibs=yes.
+	* ltcf-cxx.sh (tpf*): Likewise.
+	* ltconfig (tpf*): Add TPF OS configuration support.
+
+2004-09-30  Tomer Levi  <Tomer.Levi@nsc.com>
+
+	* configure.in: Enable target-libgloss for crx-*-*.
+	* configure: Regenerate.
+
+2004-09-24  Michael Roth  <mroth@nessie.de>
+
+	* configure.in (--without-headers): Add missing double quotes.
+	* configure: Regenerate.
+
+2004-09-24  Kelley Cook <kcook@gcc.gnu.org>
+
+	* ylwrap: Revert to previous version.
+
+2004-09-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR bootstrap/17369
+	* Makefile.tpl (REALLY_SET_LIB_PATH): Add @SET_GCC_LIB_PATH@.
+	(HOST_EXPORTS]): Add @SET_GCC_LIB_PATH@. Set and export
+	SET_GCC_LIB_PATH_CMD.
+	(BASE_TARGET_EXPORTS): Likewise.
+	* Makefile.in: Regenerated.
+
+	* configure.in (SET_GCC_LIB_PATH): Set and substitute.
+	* configure: Regenerated.
+
+2004-09-23  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* config.guess: New upstream version
+	* compile, depcomp, install-sh, ylwrap: Likewise.
+
+2004-09-19  Roger Sayle  <roger@eyesopen.com>
+
+	* config/mh-x86omitfp: New host makefile fragment.  Add
+	-fomit-frame-pointer to the default BOOT_CFLAGS.
+	* configure.in: Use it to speed up bootstrap on some IA-32 hosts.
+	* configure: Regenerate.
+
+2004-09-15  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR target/11572
+	* configure.in (*-*-darwin*): Renable libobjc.
+	* configure: Regenerate.
+
+2004-09-09  Daniel Berlin  <dberlin@dberlin.org>
+
+	* Makefile.def: Remove libbanshee.
+	* Makefile.tpl: Ditto.
+	* configure.in: Ditto.
+	* Makefile.in: Regen.
+	* configure: Ditto.
+
+2004-09-07  Paolo Bonzini  <bonzini@gnu.org>
+
+	* missing: Import latest version from master repository.
+
+2004-09-04  Nick Clifton  <nickc@redhat.com>
+
+	* config.sub: Import latest version from master repository.
+	* config.guess: Likewise.
+	This includes these changes:
+
+	2004-08-27  Hans-Peter Nilsson  <hp@axis.com>
+
+	* config.sub: Handle crisv32, alias etraxfs.
+	* config.guess (crisv32:Linux:*:*): Handle.
+
+	2004-08-13  Brad Smith  <brad@comstyle.com>
+
+	* config.guess (*:OpenBSD:*:*): Remove defunct MIPS machines.
+	(sgi:OpenBSD:*:*): Emit mips64, not mipseb.
+
+	2004-08-11  Paul Eggert  <eggert@cs.ucla.edu>
+
+	* config.guess (*:Darwin:*:*): If uname -p reports "unknown",
+	assume the processor is a powerpc.  This is because coreutils
+	uname (at least versions 4.5.7 through 5.2.1) outputs "unknown"
+	in this case, due to a MacOS X bug that causes
+	sysctl ((int[]) {CTL_HW, HW_MACHINE_ARCH}, 2, buffer, &bufsize, 0, 0)
+	to return a negative number.
+	Problem reported by Petter Reinholdtsen in:
+	http://lists.gnu.org/archive/html/bug-gnu-utils/2003-02/msg00201.html
+
+	2004-07-19  Ben Elliston  <bje@gnu.org>
+
+	* config.guess (S7501:*:4.0:3.0): Handle NCR System V UNIX machine.
+
+	2004-06-24  Ben Elliston  <bje@gnu.org>
+
+	* config.guess: Update copyright years.
+	* config.sub: Likewise.
+
+	2004-06-22  Robert Millan  <robertmh@gnu.org>
+
+	* config.guess (*:FreeBSD:*:*): Remove check for glibc (unneeded
+	since GNU/kFreeBSD systems match *:GNU/*:*:* instead).
+
+	2004-06-22  Stanley F. Quayle <stan@stanq.com>
+
+	* config.guess (*:*VMS:*:*): New entry. Replaces
+	Alpha:OpenVMS:*. Recognize and advertise all VMS flavors as dec
+	manufacturer.
+
+	2004-06-22  Ben Elliston  <bje@gnu.org>
+
+	* config.guess: Cray fixes from Wendy Palm <wendyp@cray.com>.
+	* config.sub: Likewise.
+
+	2004-06-22  Ben Elliston  <bje@gnu.org>
+
+	Reported by Hans-Peter Nilsson <hp@bitrange.com>:
+	* config.sub: Correctly handle mmix-knuth and mmix-knuth-mmixware.
+
+	2004-06-11  Ben Elliston  <bje@gnu.org>
+
+	* config.guess (pegasos:OpenBSD:*:*): Remove.
+
+	2004-06-11  Ben Elliston  <bje@gnu.org>
+
+	From Wouter Verhelst <wouter@grep.be>:
+	* config.guess (M68*:*:R3V[5678]:*): Detect R3V8.
+
+	2004-06-11  Ben Elliston  <bje@gnu.org>
+
+	* config.guess (luna88k:OpenBSD:*:*): New.
+
+	2004-03-12  Kazuhiro Inaoka  <inaoka.kazuhiro@renesas.com>
+
+	* config.guess (m32r*:Linux:*:*): New case.
+	* config.sub: Handle m32rle.
+
+	2004-03-12  Ben Elliston  <bje@wasabisystems.com>
+
+	From Jens Petersen  <petersen@redhat.com>:
+	* config.sub: Handle sparcv8.
+
+	2004-03-03  Ben Elliston  <bje@wasabisystems.com>
+
+	From Tom Smith <smith@cag.lkg.hp.com>:
+	* config.guess: Version suffixes are equally significant on Tru64
+	V4.* and V5.*, so do not ignore them on V5.*.  Handle a version
+	prefix of "P" (patched kernel).
+
+	2004-02-23  Tal Agmon  <Tal.Agmon@nsc.com>
+
+	* config.sub: Add support for National Semiconductor CRX target.
+
+2004-09-03  Jan Beulich  <jbeulich@novell.com>
+
+	* configure.in: Remove target-libstdc++-v3 from noconfigdirs for
+	*-*-netware, but add target-libmudflap.
+	Consolidate *-*-netware targets (of which really only i?86 exists)
+	into a single entry.
+	* configure: Likewise.
+
+2004-09-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (sorry): Remove.
+	(clean-stage[+id+], clean-stage[+id+]-module): New targets.
+	(cleanstrap targets): Depend on distclean, not distclean-stage1.
+	(do-clean): Clean per-stage directories too.
+	(do-distclean): Run distclean-stage1 too.
+	(.NOTPARALLEL): Enable during toplevel bootstrap.
+	(stage[+id+]-bubble): Enable parallel execution during
+	the recursive invocation.
+	* Makefile.in: Regenerate.
+
+	Sync from gcc (moving the Makefile.in change to Makefile.tpl):
+
+	2004-08-31  Robert Bowdidge <bowdidge@apple.com>
+
+	* Makefile.in: Move BOOT_CFLAGS above host makefile fragment include.
+	* configure.in: add test for powerpc-*-darwin* to specify makefile frag
+	* configure: regenerate
+	* config/mh-ppc-darwin: create file, override BOOT_CFLAGS for
+	-mdynamic-no-pic
+
+2004-08-31  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Move BOOT_CFLAGS above host makefile fragment
+	include.
+	* configure.in: Fix indentation.
+	* configure: Regenerate.
+
+2004-08-31  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (build_modules): Add fixincludes.
+	(dependencies): Make gcc depend on fixincludes.
+	* configure.in (build_tools): Add fixincludes.
+	(build_configdirs): Always include build_libs.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2004-08-30  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (bootstrap stages): Add 'lean' parameter.
+	* Makefile.tpl (configure-stageN-*, all-stageN-*): Turned into
+	phony targets; do not generate timestamp files.
+	(distclean-stageN): Remove references to their timestamp files.
+	(restageN, touch-stageN): Remove.
+	(stageN-bubble): Rewritten.
+	(compare): Support lean bootstraps.
+	* Makefile.in: Regenerate.
+
+	* configure.in: Only warn when bootstrapping but
+	build != host or build != target.  Support lean bootstraps.
+	* configure: Regenerate.
+
+	Sync from gcc:
+	2004-08-26  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in:  Give a better error message if GMP/MPFR are missing
+	and a language needing them has been requested.
+	* configure:  Regenerated.
+
+	2004-08-25  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in:  Print a list of available language front-ends if
+	a requested one is missing.  Tidy stray tab characters.
+	* configure:  Regenerated.
+
+2004-08-17  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+	* Makefile.def (bootstrap-stage): Rename extra_*_flags to
+	stage_*_flags.
+	* Makefile.tpl (configure-[+module+], all-[+module+]): Exit
+	for bootstrapped modules if toplevel bootstrap is going.
+	(GCC bootstrap): Generate per-stage targets for all bootstrapped
+	modules.  Adjust for changes in Makefile.def.  Enable several
+	rules even in non-bootstrap mode, just to avoid peppering the
+	template with unnecessary "@if/@endif gcc-bootstrap" pairs.
+	(stage-[+prev+]-bubble): Remove.
+
+	* Makefile.def (Dependencies): Depend on all-build-bison,
+	all-build-flex, all-build-byacc, all-build-texinfo, rather
+	than the host variations.
+	* Makefile.tpl (BUILD_DIR_PREFIX): Remove.  Replace throughout
+	with BUILD_SUBDIR.
+	(BISON): Update for recent Bisons.
+	(YACC): Fix typo.
+	(cross): Depend on all-build.
+	(all): Do not depend on all-build.
+	(prebootstrap): Remove.
+	(dep-kind): Accept separate prefixes for MODULE and ON variables.
+	(Prebootstrap dependencies): Add them to the per-stage targets
+	and to all-prebootstrap.
+	* configure.in (build_configdirs): Always enable build_tools.
+	(BUILD_DIR_PREFIX): Remove.
+
+	* Makefile.def (gcc): Add target variable.
+	(gdb, expect, guile, tk, tix): Replace with_x with extra_make_flags.
+	* Makefile.tpl (Autogenerated `all-*' targets): Invoke $(TARGET-*)
+	in the recursive `make', instead of hardwiring `all'.
+	(Autogenerated TARGET-* variables): New.
+
+2004-08-17  Robert Millan  <robertmh@gnu.org>
+
+	* configure.in: In noconfigdirs check, match GNU/k*BSD with GNU/Linux
+	(instead of FreeBSD).
+	* configure: Regenerate.
+
+2004-08-12  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def, configure.in, src-release: Remove useless, bogus
+	references to tix.
+	* Makefile.in, configure: Regenerate.
+
+	* src-release: Stop distributing mmalloc with gdb (which doesn't
+	use it).
+	* Makefile.def: GDB doesn't depend on mmalloc anymore.
+	* Makefile.in: Regenerate.
+
+2004-08-09  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in (arm*-*-eabi*): New target.
+	* configure: Regenerate.
+
+2004-08-01  Robert Millan  <robertmh@gnu.org>
+
+	* configure.in: Turn mt-linux into mt-gnu. Use mt-gnu and enable
+	libmudflap for all GNU-based systems (with Glibc).
+	* configure: Regenerate.
+
+2004-08-06  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (bfd, opcodes, gcc, zlib): Mark as bootstrap module.
+	(bison, byacc, flex, texinfo): Do not mark as bootstrap module.
+	(Dependencies): New section.
+	* Makefile.tpl (Dependencies): Generate from Makefile.def.
+	(configure-target-[+module+]): Depend on maybe-all-gcc
+	(all-prebootstrap): New name of all-bootstrap.  Changed throughout.
+	(toplevel profiledbootstrap): Fix dependencies.
+	* Makefile.in: Regenerate.
+
+2004-08-03  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in (arm*-*-symbianelf*): Add ${libgcj} and
+	target-libiberty to noconfigdirs.
+
+2004-08-03  Paul Brook  <paul@codesourcery.com>
+
+	* configure.in: Check for MPFR as well as GMP.
+	* configure: Regenerate.
+
+2004-08-03 Paolo Bonzini <bonzini@gnu.org>
+
+	* Makefile.def (host-modules): Add gcc.
+	* Makefile.in: Regenerate.
+	* Makefile.tpl (sorry): New rule.
+	(configure-host, all-host, [+make_target+]-host, do-check,
+	install-host): Do not add gcc as a special case.
+	(host modules): Add a small special-casing for gcc.  Export
+	extra_make_flags through the environment.
+	(maybe-configure-gcc, configure-gcc, maybe-all-gcc, all-gcc,
+	maybe-check-gcc, check-gcc, maybe-install-gcc, install-gcc,
+	other recursive targets for gcc): Remove.
+
+	(all, do-[+make_target+], do-check): Wrap between unstage and stage.
+	(stage, unstage): New rules.
+	(stage[+id+]-start, stage[+id+]-end, [+compare-target+],
+	distclean-stage[+id+]): Use stage_current.
+	([+bootstrap-target+], profiledbootstrap): Do not invoke manually
+	the stage*-start rules.
+
+2004-07-19  Robert Millan  <robertmh@gnu.org>
+
+	Synced from gcc:
+
+	2004-04-26  Robert Millan  <robertmh@gnu.org>
+
+	Add patches from libtool CVS.
+	* libtool.m4: Add kfreebsd*-gnu and knetbsd*-gnu.
+	* ltconfig: Likewise.
+	* ltcf-c.sh: Likewise.
+	* ltcf-cxx.sh: Likewise.
+	* ltcf-gcj.sh: Likewise.
+
+2004-07-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Add noconfigdirs for crx-*-*.
+	* configure: Regenerate.
+
+2004-07-12  Paolo Bonzini  <bonzini@gnu.org>
+
+	Synced from gcc:
+
+	2004-07-09  Loren J. Rittle <ljrittle@acm.org>
+
+	* configure.in: Build libmudflap by default on FreeBSD.
+	* configure: Regenerated.
+
+	2004-07-09  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in: Do not build libmudflap by default on non-GNU/Linux
+	systems.
+	* configure: Regenerated.
+
+	2004-07-08 John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/16344
+	* Makefile.tpl (profiledbootstrap): Build runtime libraries with
+	feedback based compiler.
+	* Makefile.in: Rebuilt.
+
+	2004-07-05  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in:  Do not prepend $srcdir to /dev/null in
+	makefile fragments.
+	* configure:  Regenerate.
+
+2004-07-08  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.def (host_modules): Set bootstrap=true for flex.
+	* Makefile.tpl (all-gcc): Depend on texinfo and flex.
+	* Makefile.in: Rebuilt.
+
+2004-07-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (build_modules): Add bison, byacc, flex,
+	m4, texinfo.
+	(flags_to_pass): Add FLEX.
+	* Makefile.tpl (BUILD_DIR_PREFIX, BASE_EXPORTS): New.
+	(BUILD_EXPORTS, HOST_EXPORTS, BASE_TARGET_EXPORTS): Include it.
+	(DEFAULT_YACC, USUAL_YACC, DEFAULT_LEX, USUAL_LEX, DEFAULT_M4,
+	DEFAULT_MAKEINFO): Remove.
+	(CONFIGURED_YACC, CONFIGURED_FLEX, CONFIGURED_BISON,
+	CONFIGURED_LEX, CONFIGURED_M4, CONFIGURED_MAKEINFO): Substitute.
+	(YACC, FLEX, BISON, LEX, M4, MAKEINFO): Define to look into
+	objdir or else use configured tool.
+	(all-build): New.
+	(all): Depend on it.
+	(Build module dependencies): Add.
+	* Makefile.in: Regenerate.
+	* configure.in: Better support for multiple build modules,
+	matching what is done for host/target modules.  Do not look
+	for "plausible" locations of build tools if Canadian cross.
+	Use autoconf's AC_PROG_CC to find a C compiler.  Define
+	BUILD_DIR_PREFIX.  Look for flex, makeinfo and m4.
+	* configure: Regenerate.
+
+2004-06-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (HOST_EXPORTS): Fix pasto.
+	* Makefile.in: Regenerate.
+
+2004-06-22  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (configure-build-[+module+],
+	configure-[+module+], configure-target-[+module+]): Pass
+	[+extra_configure_args+].
+	(all-build-[+module+], all-[+module+], check-[+module+],
+	install-[+module+], [+make_target+]-[+module+],
+	all-target-[+module+], check-target-[+module+],
+	install-target-[+module+], [+make_target+]-target-[+module+]):
+	Pass [+extra_make_args+].
+	(HOST_EXPORTS): Include the former GCC_HOST_EXPORTS.
+	(GCC_HOST_EXPORTS): Remove.
+	(configure-gcc, all-gcc, GCC_STRAP_TARGETS, profiledbootstrap,
+	cross, check-gcc, check-gcc-c++, install-gcc,
+	gcc-no-fixedincludes, [+make_target+]-gcc, stage[+id+]-bubble):
+	Replace GCC_HOST_EXPORTS with HOST_EXPORTS.
+	* Makefile.in: Regenerate.
+
+2004-06-21  Christopher Faylor  <cgf@alum.bu.edu>
+
+	* configure.in: Check for srcdir/winsup rather than build directory
+	winsup.
+	* configure: Regenerate.
+
+2004-06-17  Corinna Vinschen  <vinschen@redhat.com>
+
+	* configure.in: Don't build Cygwin native newlib if winsup
+	directory is missing.  Emit warning instead.
+	* configure: Regenerate.
+
+2004-06-09  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (touch-stage[+id+]): New.
+	(restage[+prev+]): Depend on touch-stage[+id+].
+
+	* Makefile.tpl (RECURSE_FLAGS_TO_PASS): New.
+	Use it throughout.
+
+	* Makefile.def: Add profile and feedback bootstrap stages.
+	Remove next field from bootstrap stages.
+	* Makefile.tpl (LN, LN_S): Substitute.
+	(stageN-start, stageN-end): Use double-colon rules, to
+	provide a hook for additional setup commands.
+	(distclean-stageN-gcc, restageN): Create dependencies from
+	[+prev+], not from [+next+].
+	(stageN-bubble): Add commands for successive stages from
+	[+prev+], using double-colon rules.
+	(all-stageN-gcc): Fix typo.
+	(stagefeedback-start, profiledbootstrap): New.
+	* Makefile.in: Regenerate.
+	* configure.in: Call ACX_PROG_LN.
+	* configure: Regenerate.
+
+2004-06-03  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Fix --enable-bootstrap breakage introduced in trees
+	without gcc.
+	* configure: Regenerate.
+
+2004-06-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl: Fix typo.
+	* Makefile.in: Regenerate.
+
+2004-06-01  Paolo Bonzini <bonzini@gnu.org>
+
+	* configure.in: Remove new- prefix from toplevel
+	bootstrap targets.
+	* configure: Regenerate.
+
+2004-06-01  Paolo Bonzini <bonzini@gnu.org>
+
+	Merge this patch from the gcc tree:
+
+	2004-05-30  Andreas Jaeger  <aj@suse.de>
+		    Jim Wilson <wilson@specifixinc.com>
+
+	* config-ml.in: Pass FFLAGS and ADAFLAGS for multilibs, handle F77
+	like CC.
+
+2004-06-01  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all.normal): Rename to all.
+	(all): Replace with a rule to pick the default
+	target from configure.
+	(all-gcc, configure-gcc): Use conditionals to
+	do nothing when toplevel bootstrap is going on.
+	(GCC directory bootstrap) [gcc-bootstrap]: Disable.
+	(Toplevel bootstrap) [gcc-no-bootstrap]: Disable.
+	* configure.in: Support --enable-bootstrap.
+
+	* Makefile.def: Remove new- prefix from toplevel
+	bootstrap targets.
+	* Makefile.tpl: Likewise.
+
+	* Makefile.def: Add bootstrap_stage 4.  Add bootstrap2
+	target.
+
+	* Makefile.tpl (Toplevel bootstrap): Pass $(BASE_FLAGS_TO_PASS)
+	$(RECURSE_FLAGS) to recursive invocation of make.
+
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2004-05-27  Daniel Jacobowitz  <dan@debian.org>
+
+	* configure.in: Fix sed invocation for GFORTRAN_FOR_TARGET.
+	* configure: Regenerate.
+
+2004-05-25  Daniel Jacobowitz  <drow@false.org>
+
+	* Makefile.tpl (BUILD_EXPORTS, HOST_EXPORTS, GCC_HOST_EXPORTS)
+	(STAGE_HOST_EXPORTS, BASE_TARGET_EXPORTS, RAW_CXX_TARGET_EXPORTS)
+	(NORMAL_TARGET_EXPORTS): New macros.  Use them in all the recursive
+	targets.
+	* Makefile.in: Regenerate.
+
+2005-05-24  Paolo Bonzini <bonzini@gnu.org>
+
+	* configure.in: Test the ability to symlink directories.
+	* configure: Regenerate.
+
+	* Makefile.def (bootstrap-stage): New definitions.
+	* Makefile.tpl (configure-stage1-gcc,
+	configure-stage2-gcc, configure-stage3-gcc,
+	all-stage1-gcc, all-stage2-gcc, all-stage3-gcc,
+	new-bootstrap, new-cleanstrap, new-restage1, new-restage2,
+	new-restage3, compare): Autogenerate, see Makefile.in
+	entry for behavioral changes.
+	(distclean-stage1, new-stage1-start, new-stage1-end,
+	new-stage1-bubble, distclean-stage2, new-stage2-start,
+	new-stage2-end, new-stage2-bubble, distclean-stage3,
+	new-stage3-start, new-stage3-end): New autogenerated targets.
+	(objext, prebootstrap, BOOT_CFLAGS,
+	POSTSTAGE1_FLAGS_TO_PASS): Move above the autogenerated
+	targets.
+
+	* Makefile.in: Regenerate.
+	(distclean-stage1, new-stage1-start, new-stage1-end,
+	new-stage1-bubble, distclean-stage2, new-stage2-start,
+	new-stage2-end, new-stage2-bubble, distclean-stage3,
+	new-stage3-start, new-stage3-end): New targets.
+	(all-stage1-gcc): Move prebootstrap dependency from here...
+	(configure-stage1-gcc): ...to here.
+	(new-bootstrap): Use bubble targets.
+	(new-cleanstrap, new-restage1, new-restage2, new-restage3):
+	Use per-stage distclean targets.
+	(configure-stage1-gcc, configure-stage2-gcc,
+	configure-stage3-gcc, all-stage1-gcc,
+	all-stage2-gcc, all-stage3-gcc, new-bootstrap):
+	Use new-stageN-start to prepare the tree.
+
+2004-05-23  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (host_modules): add libcpp.
+	* Makefile.tpl: Add dependencies on and for libcpp.
+	* Makefile.in: Regenerate.
+	* configure.in: Add libcpp host module.
+	* configure: Regenerate.
+
+2004-05-17  Zack Weinberg  <zack@codesourcery.com>
+
+	* Makefile.def, Makefile.tpl, configure.in: Remove all mention
+	of libf2c.
+	* configure, Makefile.in: Regenerate.
+
+2004-05-13  Diego Novillo  <dnovillo@redhat.com>
+
+	Merge from tree-ssa-20020619-branch.
+
+	* Makefile.def: Add libbanshee, libmudflap and libgfortran.
+	* Makefile.tpl (BUILD_CONFIGDIRS): Add libbanshee.
+	(HOST_GMPLIBS): Define.
+	(HOST_GMPINC): Define.
+	(TARGET_LIB_PATH): Add libmudflap.
+	(GFORTRAN_FOR_TARGET): Define.
+	(configure-build*): Export GFORTRAN.
+	(configure-gcc): Export GMPLIBS and GMPINC.
+	(all-gcc): Add maybe-all-libbanshee.
+	(configure-target-libgfortran): Define.
+	* Makefile.in: Regenerate.
+	* configure.in (host_libs): Add libbanshee.
+	(target_libraries): Add target-libmudflap and target-libgfortran.
+	Add --with-libbanshee.
+	Handle --disable-libmudflap.
+	(*-*-freebsd*): Use with_gmp.
+	Add $(libgcj) to noconfigdirs.
+	* configure: Regenerate.
+	* depcomp: New file.
+	* MAINTAINERS: Add tree-ssa maintainers.
+
+2004-04-28  Paolo Bonzini  <bonzini@gnu.org>
+
+	* config/acx.m4: Fix fastcompare support for new-bootstrap.
+	* configure: Regenerate.
+
+2004-04-27  Paolo Bonzini  <bonzini@gnu.org>
+
+	Revert:
+	2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (flags_to_pass): Remove *dir variables that
+	are passed to the modules via TOPLEVEL_CONFIGURE_ARGUMENTS,
+	as well as prefix and exec_prefix.
+	* Makefile.in: Regenerate.
+
+2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (host_modules): Mark with the bootstrap
+	flag packages on which gcc depends.
+	* Makefile.tpl (all-bootstrap): Use it.
+	* Makefile.in: Regenerate.
+
+2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.def (flags_to_pass): Remove *dir variables that
+	are passed to the modules via TOPLEVEL_CONFIGURE_ARGUMENTS,
+	as well as prefix and exec_prefix.
+	* Makefile.in: Regenerate.
+
+2004-04-26  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Invoke ACX_PROG_CMP_IGNORE_INITIAL.
+	* configure: Regenerate.
+	* config/acx.m4: Mutuate ACX_PROG_CMP_IGNORE_INITIAL from gcc.
+	* gcc/Makefile.tpl (compare): Use the result of the test.
+	* gcc/Makefile.in: Regenerate.
+
+2004-04-23  Paolo Bonzini  <bonzini@gnu.org>
+
+	* Makefile.tpl (all-stage1-gcc, all-stage2-gcc, all-stage3-gcc):
+	Always relocate gcc and prev-gcc to the original names, even
+	if the build fails.
+	(new-cleanstrap, new-restage1, new-restage2, new-restage3):
+	New targets.
+
+2004-04-19  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in (mips*-*-irix5*): Enable ld.
+	* configure: Regenerate.
+
+2004-04-15  James E Wilson  <wilson@specifixinc.com>
+
+	* Makefile.tpl (configure-[+module+], configure-gcc,
+	configure-stage1-gcc, configure-stage2-gcc, configure-stage3-gcc):
+	Set and export LDFLAGS.
+	* Makefile.in: Regenerate.
+
+2004-04-09  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/14871
+	* Makefile.tpl: If we don't have built-in-tree target tools,
+	use the ones found by configure rather than hacking around with
+	program_transform_name.
+	* configure.in: Give Makefile.tpl the information necessary
+	to do that.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2004-04-06  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/14760
+	* configure.in: When computing baseargs, strip *all* copies of
+	offending options.  Also, don't match/substitute the trailing space,
+	so that this actually works when two similar options are separated by
+	only one space.
+	* configure: Regenerate.
+
+2004-04-06  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in (powerpc-*-aix*): Remove target-libada from noconfigdirs.
+	(rs6000-*-aix*): Same.
+	* configure: Regenerate.
+
+2004-03-25  Stan Shebs  <shebs@apple.com>
+
+	Remove MPW support, no longer used.
+	* mpw-README, mpw-build.in, mpw-config.in, mpw-configure,
+	mpw-install: Remove files.
+	* src-release (DEVO_SUPPORT): Remove names of removed files.
+	* MAINTAINERS: Likewise.
+
+2004-03-24  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl (top level bootstrap support): Remove now-unneeded
+	STRICT_WARN, WARN_CFLAGS flags passed down to make.
+	* Makefile.in: Regenerate.
+
+	* configure.in (top level bootstrap support): Rework --enable-werror
+	to set @stage2_werror_flag@.
+	* configure: Regenerate.
+	* Makefile.tpl (top level bootstrap support): Pass
+	@stage2_werror_flag@ down to configure in stages 2 and 3.
+	* Makefile.in: Regenerate.
+
+2004-03-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl (new-bootstrap): Set CC and CC_FOR_BUILD in configure
+	for stages 2 and 3 as well as in make.  As a consequence, remove
+	OUTPUT_OPTION (now detected by configure) from the flags passed down
+	to make.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl (new-bootstrap): Fix typo.
+	* Makefile.in: Regenerate.
+
+2004-03-22  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Rearrange by moving recursive_targets rules
+	into their proper sections.
+	* Makefile.tpl (top level bootstrap support): Move disabling
+	of coverage flags from 'make' to 'configure'; improve comments.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl (experimental top level bootstrap) Move stage1
+	language setting from all- target to configure- target; disable
+	intermodule optimization in stage 1; prevent gratuitous rebuilds
+	of stage 1.
+	* Makefile.in: Regenerate.
+	* configure.in: Comma-separate stage 1 language list for top
+	level bootstrap.
+	* configure: Regenerate.
+
+	* Makefile.tpl: Clean up experimental top level bootstrap support:
+	note known problems; set CONFIG_SHELL; don't set BUILD_CC; relocate
+	prev-gcc in configure- targets as well as all- targets.
+	* Makefile.in: Regenerate.
+
+2004-03-17  Paolo Bonzini  <bonzini@gnu.org>
+
+	* configure.in: Remove symbolic link section.
+	* configure: Regenerate.
+	* Makefile.tpl (links): Remove.
+	* Makefile.in: Regenerate.
+
+2004-03-15  Paolo Bonzini  <bonzini@gnu.org>
+	    Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in (DEFAULT_YACC, DEFAULT_M4, DEFAULT_LEX):
+	Set with AC_CHECK_PROGS.
+	* configure.in: Fix comment typo from last patch.
+	* configure: Regenerate.
+
+2004-03-15  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Introduce experimental top level bootstrap support.
+	* Makefile.in: Regenerate.
+	* configure.in: Introduce support for top level bootstrap.
+	* configure: Regenerate.
+
+2004-03-12  Eric Botcazou  <ebotcazou@gcc.gnu.org>
+	    Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/14522
+	* configure.in: Cope with shells that do not support unquoted ^
+	* configure: Regenerate.
+
+2004-03-11  Eric Botcazou  <ebotcazou@gcc.gnu.org>
+	    Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/14522
+	* configure.in: Cope with shell that do not support nesting
+	quotes inside quoted backquote substitutions.
+	* configure: Regenerate.
+
+2004-03-10  Andrew Pinski  <pinskia@physics.uc.edu>
+
+	PR bootstrap/14522
+	* configure.in: Fix escaping of $.
+	* configure: Regenerate.
+
+2004-03-11  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Regenerate.
+
+2004-03-08  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR ada/14131
+	Move language detection to the top level.
+	* configure.in: Find default values for the tools as
+	soon as possible.  Disable ada if GNAT is not found.
+	Emit error message about missing languages.  Expand
+	--enable-languages=all for the gcc subdirectory.
+
+2004-03-01  Richard Sandiford  <rsandifo@redhat.com>
+
+	* configure.in (mips64*-*-linux*): Override mips*-*-linux* case
+	and disable libgcj.
+	* configure: Regenerated.
+
+2004-02-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/7087
+	* Makefile.tpl: Guard XFOO sed statements better.
+	* Makefile.tpl: Add dependency for configure-target-libada.
+	* Makefile.in: Regenerate (incidentally fixes broken
+	commit when libada-branch was merged).
+
+2004-02-28  Andrew Cagney  <cagney@redhat.com>
+
+	* src-release (CVS_NAMES): Define.
+	(do-tar, do-tar): Prune $(CVS_NAMES).
+
+2004-02-23  Andrew Cagney  <cagney@redhat.com>
+
+	* texinfo/texinfo.tex: Update from version 2003-02-03.16 to
+	2004-02-19.09.
+
+2004-02-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR bootstrap/11932
+	* mkinstalldirs, install-sh: Import from automake CVS HEAD.
+
+2004-02-19  Andrew Cagney  <cagney@redhat.com>
+
+	* config.guess: Update from version 2003-06-12 to 2004-02-16.
+	* config.sub: Update from version 2003-06-13 to 2004-02-16.
+
+2004-02-11  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in (powerpc-*-aix*): Add target-libada to noconfigdirs.
+	(rs6000-*-aix*): Same.
+	* configure: Regenerate.
+
+2004-02-11  Kelley Cook  <kcook@gcc.gnu.org>
+
+	* configure.in (host): Add in missing $noconfigdirs to defines.
+	* configure: Regenerate.
+
+2004-02-10  Arnaud Charlet  <charlet@act-europe.fr>,
+	    Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	PR ada/6637, PR ada/5911
+	Merge with libada-branch:
+	* configure.in, Makefile.tpl, Makefile.def: Add target-libada,
+	with appropriate dependencies. Add --enable-libada configure switch.
+	* configure, Makefile.in: Regenerate.
+
+2004-02-05  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in: Don't pass --with-stabs on IRIX 5 either.
+	* configure: Regenerate.
+
+2004-02-02  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update Red Hat license to 2004.
+
+2004-01-23  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.def (target_modules) [libiberty]: Don't stage.
+	* Makefile.in: Rebuilt.
+
+2004-01-23  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update to include copyrights for new
+	iconv code.
+
+2004-01-15  Andrew Cagney  <cagney@redhat.com>
+
+	* src-release: Update copyright year.
+	(do-proto-toplev): Configure using i686-pc-linux-gnu.
+	(NEWLIB_SUPPORT_DIRS): Delete macro.
+	(newlib.tar.bz2): Delete rule.
+
+2004-01-14  Loren J. Rittle <ljrittle@acm.org>
+
+	* Makefile.def (target_modules) [libtermcap, libiberty, zlib]: Stage.
+	* Makefile.tpl (configure-target-[+module+]): Support stage.
+	* Makefile.in: Rebuilt.
+
+2003-01-14  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>
+
+	* gettext.m4: Quote names of macros to be defined by AC_DEFUN
+	throughout.
+
+2004-01-04  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Use ./config.cache, not config.cache.
+	* configure: Regenerate.
+	* Makefile.tpl: Special-casing not needed for GCC any more.
+	* Makefile.in: Regenerate.
+
+	* configure.in: Don't share a cache file for host dirs.
+	* configure: Regenerate.
+
+	* config-ml.in: Don't mess with the cache file.
+
+2004-01-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make GCC use a separate config.cache.
+	* Makefile.in: Regenerate.
+
+	PR bootstrap/11932, PR bootstrap/11933
+	(I don't know if it will fix either of them, but it relates
+	to them.)
+	* configure.in: Don't use shared config.cache for target
+	directories.
+	* configure: Regenerate.
+
+2003-12-31  Roger Sayle  <roger@eyesopen.com>
+
+	* configure.in (ia64*-*-hpux*): Disable building java libraries.
+	* configure: Regenerated.
+
+2003-12-21  Bernardo Innocenti  <bernie@develer.com>
+
+ 	* configure.in (*-*-uclinux): Exclude newlib, libgloss and rda.
+ 	* configure: Regenerated.
+
+2003-12-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	Port change over from GCC:
+	2003-11-20  Kelley Cook  <kcook@gcc.gnu.org>
+	* Makefile.tpl (BASE_FLAGS_TO_PASS): Pass along CONFIG_SHELL.
+	(configure-build-[+module+], configure-[+module+]): Likewise.
+	(configure-target-[+module+], configure-gcc, config.status): Likewise.
+	* Makefile.in: Regenerate.
+
+2003-12-08  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (raw_libstdcxx_flags): Remove the leading space.
+	* configure: Regenerate.
+
+2003-11-27  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Add license info for long long routines added to
+	stdlib.
+
+2003-11-14  Arnaud Charlet  <charlet@act-europe.fr>
+
+	* Makefile.tpl (EXTRA_GCC_FLAGS): Pass BOOT_ADAFLAGS.
+	* Makefile.in: Regenerate.
+
+2003-10-20  Phil Edwards  <phil@codesourcery.com>
+
+	* configure.in (*-*-vxworks):  Add target-libiberty to noconfdirs.
+	* configure:  Regenerate.
+
+2003-10-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make GCC_FLAGS_TO_PASS a superset of
+	HOST_FLAGS_TO_PASS.
+	* Makefile.in: Regenerate.
+
+2003-10-05  Mohan Embar  <gnustuff@thisiscool.com>
+
+	* configure.in: Allow explicit specification of CFLAGS_FOR_BUILD.
+	* configure: Rebuilt
+	* Makefile.tpl: Use CFLAGS_FOR_BUILD computed by configure
+	* Makefile.in: Rebuilt
+
+2003-10-03  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* ltconfig (sys_lib_search_path_spec): Fix a typo for HPUX.
+
+2003-10-01  Phil Edwards  <pme@gcc.gnu.org>
+
+	* config-ml.in:  Use ac_configure_args directly instead of
+	ml_arguments.  Only set ml_norecursion if --no[-]recursion is
+	actually seen.
+
+2003-10-01  Eric Botcazou  <ebotcazou@libertysurf.fr>
+
+	* config-ml.in: Propagate INSTALL variables.
+
+2003-09-21  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in: Pass a computed --program-transform-name
+	to subconfigures.
+	* configure: Regenerated.
+
+2003-09-20  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Don't pass down obsolete ENQUIRE variable.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Don't pass (unused) DLLTOOL or WINDRES to gcc.
+	* Makefile.in: Regenerate.
+
+2003-09-17  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in (TOPLEVEL_CONFIGURE_ARGUMENTS, baseargs): Fix
+	quoting.
+	* configure: Regenerated.
+
+2003-09-12  Michael Chastain  <mec@shout.net>
+
+	Fix PR gdb/857.
+	* src-release (do-proto-topleve): Remove junk files
+	intl/config.cache, intl/config.status,
+	intl/config.h, intl/stamp-h.
+
+2003-09-14  Andrew Cagney  <cagney@redhat.com>
+
+	* src-release (dejagnu.tar): New target.
+	(dejagnu.tar.bz2): Recursively call "gdb-taz" rule.
+	(do-djunpack): Use $(PACKAGE) for the package name.
+
+2003-09-04  DJ Delorie  <dj@redhat.com>
+
+	* configure: Regenerate.
+
+2003-09-04  Robert Millan  <robertmh@gnu.org>
+
+	* configure.in: Match GNU/KFreeBSD with new kfreebsd*-gnu triplet.
+
+2003-09-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* configure.in: Ensure arguments to sed are properly spaced.
+	* configure: Regenerate.
+
+2003-08-28  Daniel Jacobowitz  <drow@mvista.com>
+
+	Merge from gcc:
+	2003-07-20  Phil Edwards  <pme@gcc.gnu.org>
+	* install-sh:  Update to newer upstream versions (associated with
+	aclocal 1.7).
+	* missing:  Likewise, plus $1Help2man -> $1 typo fix.
+
+2003-08-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in: Set RAW_CXX_FOR_TARGET if unset.
+	* configure: Regenerated.
+
+2003-08-23  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure.in:  Use newline instead of semicolon when assuming
+	shell arguments in a for loop.
+	* configure:  Regenerated.
+
+2003-08-20  Geoffrey Keating  <geoffk@apple.com>
+
+	PR 8180
+	* configure.in: When testing with_libs and with_headers, treat
+	'no' as unset.  Based on a patch by Dan Kegel <dank@kegel.com>.
+	* configure: Regenerate.
+
+	* configure.in (TOPLEVEL_CONFIGURE_ARGUMENTS): Quote properly for
+	make, shell, etc.
+	(baseargs): Likewise.
+	* configure: Regenerate.
+
+2003-08-19  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in: Disable libgcj for darwin not on powerpc.
+	* configure: Rebuild.
+
+2003-08-15  Michael Chastain  <mec@shout.net>
+
+	* src-release (do-proto-toplev): Remove junk files
+	dejagnu/example/calc/config.status,
+	dejagnu/example/calc/config.log.
+
+2003-08-14  Alexandre Duret-Lutz  <adl@gnu.org>
+
+	* config-ml.in, symlink-tree: Add license.
+
+2003-08-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	Merge from gcc:
+
+	2003-08-01  Matt Kraai  <kraai@alumni.cmu.edu>
+	* Makefile.tpl (check, check-c++): Express dependencies using
+	dependencies rather than commands.
+	* Makefile.in: Regenerate.
+
+	2003-07-31  Geoffrey Keating  <geoffk@apple.com>
+	* Makefile.tpl (libsubdir): Use gcc instead of gcc-lib.
+	* Makefile.in: Update.
+
+2003-08-01  Andrew Cagney  <cagney@redhat.com>
+
+	* configure.in (noconfigdirs): Do not add GDB when m32r-*-*.
+	* configure: Ditto.
+
+2003-07-30  Andreas Tobler  <a.tobler@schweiz.ch>
+
+	* configure.in: Enable libgcj for darwin.
+	* configure: Rebuild.
+
+2003-07-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* mkinstalldirs: Import autoconf 2.57 / automake 1.7 version.
+
+2003-07-27  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Use 'mkinstalldirs' rather than 'mkdir' when
+	creating target and build subdirs to build all parent dirs as needed.
+	* Makefile.in: Rebuild.
+	* configure.in: Don't build dirs explicitly here.
+	* configure: Rebuild.
+
+2003-07-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (all-make): Depend on intl.
+	* Makefile.in: Rebuilt.
+
+2003-07-16  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* config.if: Remove unused libc_interface determination.
+
+2003-07-14  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.in: Regenerate, correctly this time.
+
+2003-07-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Set INSTALL and friends using autoconf.  Remove
+	unused INSTALL_PROGRAM_ARGS.
+	* configure.in: Use AC_PROG_INSTALL.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2003-07-10  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure: Rebuilt.
+	2001-09-26  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in (noconfigdirs) [am33_2.0-*-linux*]: Don't build
+	newlib nor libgloss.
+	Wed May  9 10:07:19 2001  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in (am33_2.0-*-linux*): Added.
+
+2003-07-09  Bob Wilson  <bob.wilson@acm.org>
+
+	* configure.in: Add ${libgcj} to noconfigdirs for xtensa-*-* targets.
+	* configure: Regenerate.
+
+2003-07-06  H.J. Lu <hongjiu.lu@intel.com>
+
+	* config-ml.in: Replace PWD with PWD_COMMAND.
+	* Makefile.tpl: Likewise.
+	* Makefile.in: Regenerated.
+
+2003-06-27  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Clean up config-lang.in handling.  Delete
+	useless assignment to "subdirs".
+	* configure: Regenerate.
+
+2003-06-26  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Rename 'target_libs' to 'target_libraries'.
+	Remove useless reference to 'target_libs'.
+	* configure: Regenerate.
+
+2003-06-23  Keith Seitz  <kseitz@sources.redhat.com>
+
+	* Makefile.tpl: Add maybe-configure-itcl to configure-gdb.
+	* Makefile.in: Regenerate.
+
+2003-06-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def: Introduce flags_to_pass.
+	* Makefile.tpl: Generate BASE_FLAGS_TO_PASS using it.
+	* Makefile.in: Regenerate.
+
+2003-06-23  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) <cris-*-*>: Disable target-newlib
+	and target-libgloss.
+	<d30v-*-*, fr30-*-*, i960-*-*, m32r-*-*>: Disable gdb.
+	<h8300*-*-*>: Disable libf2c and ${libgcj}.
+	* configure: Regenerate.
+
+2003-06-17  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* configure.in: Update testsuite_flags to new location.
+	* configure. Regenerate.
+
+2003-06-18  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Remove BUILD_CC stuff.
+	* Makefile.in: Regenerate.
+
+2003-06-14  H.J. Lu <hongjiu.lu@intel.com>
+
+	* config.guess: Update to 2003-06-12 version.
+	* config.sub: Update to 2003-06-13 version.
+
+2003-06-12  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+
+	* MAINTAINERS: Add myself as MIPS co-maintainer.
+
+2003-06-12  H.J. Lu <hongjiu.lu@intel.com>
+
+	* config.guess: Update to 2003-06-06 version.
+	* config.sub: Update to 2003-06-06 version.
+
+2003-06-11  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in: Don't pass --with-stabs for mips*-sgi-irix6*o32.
+	* configure. Regenerate.
+
+2003-06-10  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Disable serial configure by default.
+	* configure: Regenerate.
+	* Makefile.tpl: Abolish .NOTPARALLEL.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Replace {build,host,target}_canonical by
+	{build,host,target}.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Fix stupid pasto.
+	* Makefile.in: Regenerate.
+
+2003-06-09  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Remove bogus conditional.
+	* Makefile.in: Regenerate.
+
+2003-06-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make 'recursive targets' using autogen rather
+	than shell loop.  Remove duplicate 'clean' targets and false
+	comments.
+	* Makefile.def: Add systematic dependencies to 'recursive' targets.
+	Add systematic method of specifying missing targets in subdirs.
+	Add copyright boilerplate.
+	* Makefile.in: Regenerate.
+	* configure.in: Add 'recursive targets' to maybe list.
+	* configure: Regenerate.
+
+	* Makefile.tpl: Rename [+target+] to [+make_target+].
+	* Makefile.def: Rename 'target' to 'make_target'.
+
+2003-05-30  Nick Clifton  <nickc@redhat.com>
+
+	* README-maintainer-mode: Update URL for locating blessed config
+	tools.
+
+2003-05-29  Robert Millan  <rmh@debian.org>
+
+	* ltconfig: Import this patch and modify for use with current
+	version of ltconfig:
+
+	2003-05-21  Bruno Haible  <bruno@clisp.org>
+
+	* libtool.m4 (AC_LIBTOOL_SYS_DYNAMIC_LINKER): Add support for
+	GNU/FreeBSD.
+
+2003-05-28  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl: Make maybe-check-gcc .PHONY.
+	* Makefile.in: Regenerate.
+
+2003-05-28  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Add license info for newlib/libc/sys/linux/stdlib.
+
+2003-05-21  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl (configure-target-libiberty): Depend only on gcc, not
+	newlib or libgloss.
+	* Makefile.in: Regenerate.
+
+2003-05-21  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl: Add missing empty maybe-check-gcc target.
+	* Makefile.in: Regenerate.
+
+2003-05-20  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>
+
+	* configure.in: Use curly braces in the definition of tooldir.
+	* configure: Regenerate.
+
+2003-05-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Switch more things to use maybe dependencies.
+	* Makefile.tpl: Switch more things to use maybe dependencies.
+	Factor out common code from autogen IF statements.
+	* configure: Regenerate.
+	* Makefile.in: Regenerate.
+
+2003-05-14  Kelley Cook  <kelleycook@wideopenwest.com>
+
+	* configure.in: Accept i[3456789]86 for machine type.
+	* configure: Regenerate.
+
+2003-05-18  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Switch more things to use maybe dependencies.
+	Rearrange a little.  Use GCC_TOPLEV_SUBDIRS.
+	* configure: Regenerate.
+	* Makefile.tpl: Switch more things to use maybe dependencies.
+	* Makefile.in: Regenerate.
+
+2003-05-16  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl (install-opcodes): Define.
+	* Makefile.in: Rebuild.
+
+2003-05-13  Andreas Jaeger  <aj@suse.de>
+
+	* config.guess: Update to 2003-05-09 version.
+	* config.sub: Update to 2003-05-09 version.
+
+2003-05-13  Michael Eager <eager@mvista.com>
+
+	* configure.in: Correct sed script so that options in quotes are not
+	deleted.
+	* configure: Rebuild.
+
+2003-05-12  Corinna Vinschen  <corinna@vinschen.de>
+
+	* configure.in (FLAGS_FOR_TARGET): Remove $$s/newlib/libc/sys/cygwin
+	and $$s/newlib/libc/sys/cygwin32 include paths.
+	* configure: Ditto.
+
+2003-05-05  H.J. Lu <hjl@gnu.org>
+
+	* config-ml.in: Restored from gcc repository.
+
+2003-05-02  Chris Demetriou  <cgd@broadcom.com>
+
+	* Makefile.tpl: Require "makeinfo" from texinfo 4.2 or later.
+	* Makefile.in: Regenerate.
+
+2003-04-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	* src-release (DEVO_SUPPORT): Add src-release, Makefile.tpl,
+	and Makefile.def.
+
+2003-04-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	* Makefile.tpl: Clean $(BUILD_SUBDIR).
+	* Makefile.in: Regenerated.
+
+2003-04-18  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>
+
+	* Makefile.tpl (MAKEINFOFLAGS): Default to --split-size=5000000.
+	* Makefile.in: Regenerate.
+
+2003-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (powerpc64*-*-linux*): Remove.
+	* configure: Rebuilt.
+
+2003-04-17  Phil Edwards  <pme@gcc.gnu.org>
+
+	* Makefile.tpl (GCC_STRAP_TARGETS):  New variable containing all the
+	previous bootstrap targets, plus bubblestrap, quickstrap, cleanstrap,
+	and restrap.
+	* Makefile.in:  Regenerate.
+
+2003-04-16  Richard Earnshaw  <rearnsha@arm.com>
+
+	* configure.in (arm-*-netbsdelf*): Enable building java libraries.
+	* configure: Regenerated.
+
+2003-04-11  Alexandre Oliva  <aoliva@redhat.com>
+
+	* libtool.m4 (lt_cv_deplibs_check_method): Use pass_all on mips*.
+	* */configure: Rebuilt.
+
+2003-03-14  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Move .NOEXPORT, MAKEOVERRIDES back down.
+	* Makefile.in: Regenerate.
+
+2003-03-14  Michael Chastain  <mec@shout.net>
+
+	* Makefile.in: Regenerate with correct Makefile.def.
+
+2003-03-12  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Move .NOEXPORT, MAKEOVERRIDES up.  Delete unused
+	Make macro.
+	* Makefile.in: Regenerate.
+	* configure.in: Clean up gxx_include_dir logic.
+	* configure: Regenerate.
+
+2003-03-09  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* configure.in (gxx_include_dir): Fix typo.
+	* configure: Regenerated.
+
+2003-03-06  Andrew Cagney  <cagney@redhat.com>
+
+	* texinfo/texinfo.tex: Import version 2003-02-03.16.
+
+2003-03-04  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in: Include $(build_tooldir)/sys-include in
+	FLAGS_FOR_TARGET.
+	* configure: Regenerated.
+
+2003-03-04  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Reindent.
+	* Makefile.in: Regenerate.
+	* configure.in: Reindent.  Don't set unused variables.
+	* configure: Regenerate.
+
+	* Makefile.tpl: Always pass down RANLIB.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Don't set unused enable_shared, enable_threads macros.
+	* Makefile.in: Regenerate.
+	* configure.in: Remove unused logic relating to --enable-shared
+	and --enable-threads.  Remove bogus comments.  Remove redundant
+	noconfigdirs.
+	* configure: Regenerate.
+
+	* configure.in: Replace ${libstdcxx_version} by its value.
+	Remove reference to mh-dgux.
+	* configure: Regenerate.
+
+2003-02-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Rearrange.
+	* Makefile.in: Regenerate.
+
+2003-02-25  Nick Clifton  <nickc@redhat.com>
+
+	* configure: Remove site-file supprot - it is obsolete.
+
+2003-02-24  Uwe Stieber <uwe@wwws.de>
+
+	* configure.in: Add support for kaOS as cross build target system.
+	* configure: Regenerated.
+
+2003-02-20  Sean McNeil  <sean@blue.mcneil.com>
+
+	* Makefile.tpl: Add definition of CPPFLAGS to pass into
+	configure-target-* as some target builds may require additional
+	flags for preprocessor tests.
+	* Makefile.in: Regenerated.
+
+2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
+
+	* libtool.m4 (LD): Append -melf* option to LD on IRIX with GNU ld.
+	* ltconfig: Handle it.
+	* ltcf-cxx.sh: Use with_gnu_ld passed as a shell variable instead of
+	auto-detecting it.
+
+2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-cxx.sh: Replace $linker_flags with $compiler_flags wherever
+	it is used as argument to $CC.
+	* ltcf-gcj.sh: Likewise.
+
+2003-02-19  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Introduce --enable-maintainer-mode.
+	* configure: Rebuilt.
+	* Makefile.tpl (Makefile.in, configure): Enable dependencies only
+	for maintainer mode.
+	* Makefile.in: Rebuilt.
+
+2003-02-19  Andrew Cagney <ac131313@redhat.com>
+
+	* configure: Regenerate using autoconf 2.13.
+
+2003-02-19  Alan Modra  <amodra@bigpond.net.au>
+
+	* config.guess: Import latest version.
+	* config.sub: Import latest version.
+
+2003-02-18  Jason Merrill  <jason@redhat.com>
+
+	* Makefile.tpl (check-c++): Allow parallelism.
+
+2003-02-17  Andrew Cagney  <ac131313@redhat.com>
+
+	* configure: Regenerate using autoconf 000227.
+
+2003-02-15  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in (*-*-darwin*): Rename from powerpc*-*-darwin*,
+	don't configure target-libobjc.
+	* configure: Regenerate.
+
+2003-02-14  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* Makefile.tpl (RANLIB): Define.
+	* Makefile.in: Regenerate.
+
+2003-02-06  Keith R Seitz  <keiths@redhat.com>
+
+	* Makefile.def: Remove "snavigator", "grep", and "db" modules.
+	* Makefile.tpl: Remove "all-snavigator" and "all-grep".
+	* Makefile.in: Regenerated.
+	* configure.in: Remove all traces of snavigator, db, and grep.
+	* configure: Regenerated.
+
+2003-01-31  Frank Ch. Eigler  <fche@redhat.com>
+
+	* Makefile.tpl (all-sid): Add libiberty/bfd/opcodes dependencies.
+	* Makefile.in: Regenerated.
+
+2003-01-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config.if: Copy from GCC.
+
+2003-01-27  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure.in:  Revert 24Jan change.
+	* configure:  Regenerate.
+
+2003-01-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Revert previous change.
+	* configure: Regenerate.
+
+2003-01-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Make rda native-only.
+	* configure: Regenerate.
+
+2003-01-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Add missing \.
+	* configure: Rebuilt.
+
+2003-01-17  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (baseargs): Avoid using \| in sed regular
+	expressions.
+	* configure: Rebuilt.
+
+2003-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	* configure.in (baseargs): Remove all supported forms of
+	--cache-file, --srcdir, --host, --build and --target options
+	from argument lists.
+	* configure: Rebuilt.
+
+2003-01-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs): Don't skip gas on IRIX 6.
+	* configure: Rebuilt.
+
+2003-01-09  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Substitute TOPLEVEL_CONFIGURE_ARGUMENTS.
+	* Makefile.tpl: Pass TOPLEVEL_CONFIGURE_ARGUMENTS to gcc.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
+2003-01-09  Christian Cornelssen  <ccorn@cs.tu-berlin.de>
+
+	* Makefile.tpl (BASE_FLAGS_TO_PASS): Also pass DESTDIR.
+	(install-info, dir.info): Prepend $(DESTDIR) to $(infodir).
+	* Makefile.in: Regenerate.
+
+2003-01-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Remove Makefile in build, host and target modules
+	unless configure was run with --no-recursion.
+	* configure: Rebuilt.
+
+2003-01-08  Chris Demetriou  <cgd@broadcom.com>
+
+	* config.guess: Update to 2003-01-03 version.
+	* config.sub: Update to 2003-01-03 version.
+
+2003-01-07  Christopher Faylor  <cgf@redhat.com>
+
+	* configure: Regenerate with proper autoconf 2.13.
+
+2003-01-07  Christopher Faylor  <cgf@redhat.com>
+
+	* configure.in: Add AC_PREREQ for consistency.
+	* configure: Regenerate.
+
+2003-01-06  Andrew Cagney  <ac131313@redhat.com>
+
+	* configure.in (GDB_TK): Add tcl directories conditional on
+	gdb/gdbtk directory being present.
+	* configure: Regenerate.
+
+2003-01-04 John David Anglin  <dave.anglin@nrc.ca>
+
+	* configure.in (LD): Improve test for gcc.  Try to set LD to the ld used
+	by gcc if LD is not defined and we are not doing a Canadian Cross.
+	* configure: Rebuilt.
+
+2003-01-01  Daniel Jacobowitz  <drow@mvista.com>
+
+	* src-release (ETC_SUPPORT): Add fdl.texi and texi2pod.pl.
+
+2002-12-31  Tom Tromey  <tromey@redhat.com>
+
+	* Makefile.in: Rebuilt.
+	* Makefile.def (target_modules) [libffi]: Allow installation.
+
+2002-12-31  Andreas Schwab  <schwab@suse.de>
+
+	* configure.in: Fix use of $program_transform_name.
+	* configure: Regenerated.
+
+2002-12-30  Daniel Jacobowitz  <drow@mvista.com>
+
+	* configure.in (baseargs): Don't remove first configure argument.
+	* configure: Regenerated.
+
+2002-12-29  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (local-distclean): Don't remove...
+	(multilib.ts): ... this.  Moved into...
+	(multilib.out): ... this.  Don't use sub-make.
+	($(BUILD_SUBDIR)/[+module+]/Makefile, [+module+]/Makefile,
+	$(TARGET_SUBDIR)/[+module+]/Makefile, gcc/Makefile): Moved into...
+	(configure-build-[+module+], configure-[+module+],
+	configure-target-[+module+], configure-gcc): ... these.  Test
+	for Makefile existence.  Drop config.status from dependencies.
+	* Makefile.in: Rebuilt.
+	* configure.in: Move gcc-version-trigger to the end of
+	ac_configure_args.  Add comments to maybedep.tmp and
+	serdep.tmp.  Introduce --disable-serial-configure.  Remove
+	nonopt from baseargs, matching and removing corresponding
+	whitespace while at it.
+	* configure: Rebuilt.
+
+2002-12-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (host_configargs): Replace reference to
+	no-longer-defined buildopts with --build=${build_alias}.
+	* configure: Rebuilt.
+
+2002-12-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl ($(NOTPARALLEL)): Move to the end.  Bring uses of
+	program_transform_name to standard idiom.
+	(AUTOGEN, AUTOCONF): Define.
+	(Makefile.in): Use $(AUTOGEN).
+	(Makefile): Depend on config.status, and use autoconf-style rule to
+	build it.  Move original commands to...
+	(config.status): ... this new target.
+	(configure): Add $(srcdir).  Depend on config/acx.m4.  Use
+	$(AUTOCONF).
+	* Makefile.in: Rebuilt.
+
+2002-12-28  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Fix dramatic bustage due to change in
+	program_transform_name.
+	* Makefile.in: Regenerate.
+
+	* configure.in: Remove unnecessary PATH setting.
+	* configure: Regnerate.
+
+	* configure.in: Don't default to unprefixed tools unless
+	the native tools will work.
+	* configure: Regenerate.
+
+	* configure.in: Convert to autoconf script.  Blow away lots
+	of now-redundant Makefile fragments.
+	* configure: Generate using Autoconf.
+	* Makefile.tpl: Rewrite to reflect autoconfiscation.
+	* Makefile.in: Regenerate.
+
+2002-12-27  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Remove unneeded 'export's.  Make CC_FOR_TARGET,
+	CXX_FOR_TARGET, GCJ_FOR_TARGET substituted in configure.in only.
+
+	* ChangeLog: Move a couple of entries from here to winsup/cygwin,
+	where they belong.
+
+2002-12-24  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl (multilib.out): Fix missing space.
+	* Makefile.in: Regenerate.
+
+2002-12-23  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Use shared multilib.out.  Use move-if-change for it.
+	Convert (cd foo; make) to (cd foo && make).  Clean up multilib.out.
+	* Makefile.in: Regenerate.
+	* configure.in: Remove unnecessary leftovers.
+
+2002-12-21  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in (extra_ranlibflags_for_target): New variable.
+	(*-*-darwin): Add -c to ranlib commands.
+	* configure (tooldir): Handle extra_ranlibflags_for_target.
+
+2002-12-20  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Updated.
+	* COPYING.LIBGLOSS: Ditto.
+
+2002-12-19  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Revert HJL's change.
+	* Makefile.in: Regenerated.
+	* configure.in: Put build_prefix before $(BUILD_SUBDIR) here, and
+	always.
+
+2002-12-19  Andreas Schwab  <schwab@suse.de>
+
+	* Makefile.tpl, configure.in: Substitute libstdcxx_incdir.
+	* Makefile.in: Regenerate.
+
+2002-12-18  H.J. Lu <hjl@gnu.org>
+
+	* Makefile.tpl: Add @build_prefix@ before $(BUILD_SUBDIR).
+	* Makefile.in: Regenerated.
+
+	* configure.in (build_prefix): New. Substitute.
+
+2002-12-18  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Don't let real targets depend on phony targets.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl (do-info): Depend on maybe-all-texinfo, not all-texinfo.
+	* Makefile.in: Regenerate.
+
+2002-12-16  Jason Merrill  <jason@redhat.com>
+
+	* Makefile.tpl (all-gcc): Use 'make quickstrap' if there was a
+	previous 'make bootstrap'.
+	* Makefile.in: Regenerate.
+
+2002-12-17  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [mmix-*-*]: Disable libgloss and gdb.
+
+2002-12-13  Jason Merrill  <jason@redhat.com>
+
+	* Makefile.tpl (check-gcc-c++): Renamed from check-c++.  Don't run
+	library tests.
+	(check-c++): Just depend on it and check-target-libstdc++-v3.
+	* Makefile.in: Regenerate.
+
+2002-12-13  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in, Makefile.tpl, Makefile.def: Remove tclX.
+	* Makefile.in: Regenerate.
+
+2002-12-12  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update list of alternate Regent of California
+	licenses and discuss official revoking of advertising clause.
+	* COPYING.LIBGLOSS: Ditto.
+
+2002-12-12  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.tpl (configure-target-rda): Depend on $(ALL_GCC_C).
+	* Makefile.in: Rebuilt.
+
+2002-12-10  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Fix bug put in by gremlins.
+
+	* Makefile.tpl: Substitute more autoconfily.
+	* configure: Substitute more autoconfily.
+	* Makefile.in: Regenerate.
+
+2002-12-08  Andrew Cagney  <ac131313@redhat.com>
+
+	* Makefile.tpl (all-sim): Depend on maybe-configure-gdb.
+	* Makefile.in (all-sim): Ditto.
+
+2002-12-06  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.tpl: Change configure dependencies to not have real
+	targets depend on phony targets.
+
+2002-12-05  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Revert unintentional change.
+
+	* src-release: Configure host subdirs.
+
+	* Makefile.tpl: Change dependency for */multilib.out so that
+	it works when gcc isn't in the tree.
+
+	* configure.in: Substitute more.
+	* configure: Run subconfigures from the Makefile.
+	* Makefile.tpl: Run subconfigures from the Makefile; add a few
+	convenience targets.  Make sure gcc isn't rebuilt after bootstrap.
+
+2002-12-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Add targets for configuring host subdirs in Makefile,
+	and corresponding dependencies.
+	* Makefile.in: Regenerate.
+
+	* configure.in (host_tools): Order binutils, gas and ld for
+	convenience in running the testsuites.
+
+	* Makefile.tpl: Introduce rules to serialize subconfigure runs.
+	* Makefile.in: Regenerate.
+	* configure.in: Introduce rules to serialize subconfigure runs.
+
+	* configure.in: Introduce BASE_CC_FOR_TARGET.
+	* Makefile.tpl: Reorganize and comment.  Introduce HOST_CONFIGARGS.
+	Realize configure-build-* targets.  Realize configure-target-* targets.
+	* Makefile.in: Regenerate.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Move gcc_version_trigger stuff from here...
+	* configure.in: ...to here.
+
+	* configure.in: Separate subconfigure options added by this file from
+	options given by the user.  Add machinery to put args for host
+	subconfigures into the Makefile.
+
+	* Makefile.tpl: Remove 'vault' targets.
+	* Makefile.tpl: Reorder and comment dependencies.
+	* Makefile.in: Regenerate.
+
+2002-11-28  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in: Move host-specific darwin noconfigdirs into
+	the host-specific section.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Restore bkorb's style patch, accidentally lost
+	during replay.
+	* Makefile.in: Regenerate.
+
+	(finishing slow-motion replay)
+	* configure: Remove skip-this-dir support.
+	* Makefile.tpl: Remove skip-this-dir support.
+
+	* Makefile.tpl: Remove leftover support for non-autoconfiscated
+	subdirectories.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Strip out useless setting of 'dir'.
+	* Makefile.in: Regenerate.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(finishing slow-motion replay)
+	* configure.in: Fix deeply stupid bug.
+
+	* configure.in: Introduce RAW_CXX_FOR_TARGET and simplify embedded
+	shell code in CXX_FOR_TARGET
+	* Makefile.def: Introduce raw_cxx.
+	* Makefile.tpl: Use raw_cxx to select between CXX_FOR_TARGET and
+	RAW_CXX_FOR_TARGET.
+	* Makefile.in: Regenerate.
+
+2002-12-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(finishing slow-motion replay)
+	* Makefile.tpl: Remove unnecessary ifs.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Implement soft dependency machinery.  Maybe-ize
+	dependencies.  Maybe-ize build-libiberty.  Create dummy install
+	targets for 'no_install' modules.
+	* configure: Move GDB_TK substitution to configure.in.  Move
+	build_modules stuff to configure.in.
+	* configure.in: Implement soft dependency machinery.  Maybe-ize
+	GDB_TK, rearrange slightly.  Move build_modules stuff from configure.
+	* Makefile.in: Regenerate.
+
+2002-12-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(continuing slow-motion replay)
+	* Makefile.tpl: Make all-target, install-target behave similarly
+	to all, install (only hitting configured targets).  Eliminate
+	unused macro defintions.
+
+	* Makefile.tpl: Add all-gcc: all-build-libiberty dependency when
+	build != host.
+
+	* Makefile.tpl: Add all-gcc: all-libiberty dependency.
+
+	* ltcf-c.sh, ltcf-gcj.sh, Makefile.tpl: Correct BUILD/HOST confusion.
+
+	* configure.in: Produce lists of subdir targets we're actually
+	configuring.  Remove references to "dosrel".
+	* Makefile.tpl: Let configure set which subdir targets are hit.
+	Remove install-cross; clean up install; remove ALL.  Remove
+	references to "dosrel".  Remove "EXTRA_TARGET_HOST" hackery.
+	Autogenerate host module targets.  Remove empty dependency lines
+	and redundant dependency; rearrange slightly.
+	* Makefile.def: Add host-side libtermcap, utils.
+
+	* Makefile.in: Regenerate.
+
+2002-12-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* Makefile.def: Add list of recursive targets to autogenerate.
+	Add build_modules.
+	* Makefile.tpl: Autogenerate do-* targets.  Autogenerate *-target-*
+	targets.  Autogenerate *-build-* targets.
+	* Makefile.in: Regenerate.
+
+2002-11-30  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* configure: More autoconf-style substitutions.
+	* Makefile.tpl: More autoconf-style substitutions.
+	* Makefile.in: Regenerate.
+
+2002-11-30  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* configure: Substitute more variables in a more autoconf-friendly
+	way.  Simplify slightly.
+	* Makefile.tpl: Make more variables substitutable in an
+	autoconf-friendly way.
+	* Makefile.in: Regenerate.
+
+2002-11-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Continuing slow-motion replay)
+	* configure.in (v810*): Remove special setting of tools.
+
+	* configure: Add support for extra required flags for ar or nm.
+	* configure.in (aix4.3+): Use above support for target-specific
+	issues, rather than using config/mt-aix43.
+
+2002-11-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	(Starting slow-motion replay merge from gcc 3.4 b-i-b branch)
+	* configure: Remove 'removing', which doesn't work.  Replace $subdir
+	with . everywhere.  Replace $subdirs with ''.  Replace $makesrcdir
+	with $srcdir.  Reformat indentation.  Substitute some variables
+	formerly hard-coded in the Makefile for build=host.
+	* Makefile.tpl: Autogenerate more; make more autoconf-friendly.
+	* Makefile.def: Autogenerate more.
+	* Makefile.in: Regenerate.
+
+2002-11-13  Bruce Korb  <bkorb@gnu.org>
+
+	* Makefile.tpl: syntactic cleanup
+
+2002-11-04  Kevin Buettner  <kevinb@redhat.com>
+
+	* Makefile.def (host_modules): Add rda.
+	* Makefile.in: Regenerate.
+	* configure.in (target_tool): Add target-rda to list.
+
+2002-10-25  Phil Edwards  <pme@gcc.gnu.org>
+
+	* Makefile.tpl (bootstrap):  Add bubblestrap, quickstrap, cleanstrap,
+	and restrap targets to this rule.
+	* Makefile.in:  Regenerate.
+
+2002-10-24  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (i[3456]86-*-linux*): Add check to disable
+	${libgcj} for glibc1.
+
+2002-10-07  Svein E. Seldal  <Svein.Seldal@solidas.com>
+
+	* configure.in: Add tic4x target.
+
+2002-10-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make SET_LIB_PATH substitution more autoconfy.
+	* Makefile.tpl: Make RPATH_ENVVAR substitution more autoconfy.
+	* configure.in: Make SET_LIB_PATH substitution more autoconfy.
+	* configure.in: Make RPATH_ENVVAR substitution more autoconfy.
+	* Makefile.in: Regenerate.
+
+2002-10-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Eliminate reference to all-gui, all-libproc.
+	* Makefile.in: Regenerate.
+
+	* Makefile.def: Remove order dependency comments.
+	* Makefile.tpl: Add explicit install-install dependencies.
+	* Makefile.in: Regenerate.
+
+	* Makefile.tpl: Remove material now in src-release.  (Finally!)
+	* Makefile.in: Regenerate.
+
+	* configure: Restore my original patch by syncing with gcc version.
+
+	* Bring following over from gcc:
+
+2002-09-30  Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* configure.in (s390*-*-linux*): Enable libgcj.
+
+2002-10-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.in: Regenerate.  This really ought to fix things. :sigh:
+
+2002-10-02  Alan Modra  <amodra@bigpond.net.au>
+
+	* configure: Move stray lines back to where they belong.
+
+2002-10-01  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Insert configure-target target, for src-release.
+
+	* configure: Finish reverting change which Andrew Cagney started
+	reverting.  Should fix bustage.
+
+	* src-release (BINUTILS_SUPPORT_DIRS): Add cpu directory.
+	* src-release: New file.  Contains material for making net
+	releases for gdb, binutils, et al., formerly in Makefile.in.
+
+2002-09-30  Nick Clifton  <nickc@redhat.com>
+
+	* cpu: New top level directory.  Intended to hold input files for
+	CGEN which have FSF copyright assignment.
+	* Makefile.in (BINUTILS_SUPPORT_DIRS): Add cpu directory.
+
+2002-09-29  Andrew Cagney  <ac131313@redhat.com>
+
+	Revert below (note that src does not contain Makefile.tpl):
+	* Makefile.tpl: Make subsituted variables more autoconfy.
+	* Makefile.in: Regenerate.
+
+2002-09-29  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure: Revert accidentally applied changes.
+
+	* Makefile.tpl: Make more autoconf-friendly.
+	* Makefile.in: Regenerate.
+	* configure: Make substitution more autoconf-like.
+
+2002-09-28  Richard Earnshaw  <rearnsha@arm.com>
+
+	* configure.in (arm-*-coff, strongarm-*-coff, xscale-*-coff): Use a
+	single entry to handle all these.
+	(arm-*-elf, strongarm-*-elf, xscale-*-elf): Likewise.  Also enable
+	libjava on arm-*-elf.
+
+2002-09-27  Geoffrey Keating  <geoffk@apple.com>
+
+	* configure.in (powerpc-*-darwin*): Don't configure BFD, TK, or the
+	things that depend on them.
+
+2002-09-25  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Make subsituted variables more autoconfy.
+	* Makefile.in: Regenerate.
+	* configure: Make seds more autoconfy.
+
+2002-09-25  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.tpl: Rewrite substituted lines to look autoconfy.
+	* Makefile.in: Regenerate.
+	* configure.in: Rewrite sed statements to look autoconfy.
+
+	* Makefile.tpl: Autogenerate *-target-* lists, dependencies of
+	all-target-foo on configure-target-foo.
+	* Makefile.def: Ditto.
+	* Makefile.in: Rebuild.
+
+2002-09-22  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* Makefile.def: New file.
+	* Makefile.tpl: New file.
+	* Makefile.in: Generate from Makefile.tpl with 'autogen Makefile.def'.
+
+	* configure.in: Minor rearrangement.  Simplify tests.
+
+2002-09-23  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (with_headers): Skip copy if value is "yes".
+	(with_libs): Likewise.
+
+2002-09-20  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in (*-*-netbsd*): Use noconfigdirs, not skipdirs.
+	* configure.in (sh*-*-pe*): Ditto.
+	* configure.in (mips*-*-pe*): Ditto.
+	* configure.in (*arm-wince-pe): Ditto.
+
+	* configure.in: Rearrange.
+
+2002-09-12  Nick Clifton  <nickc@redhat.com>
+
+	* Import these changes from the config master repository:
+
+	2002-09-05  Svein E. Seldal  <Svein.Seldal@solidas.com>
+
+		* config.sub: Add tic4x target.
+
+	2002-09-03  Ben Elliston  <bje@redhat.com>
+
+		* config.guess: Detect NSR-D machines for nsr-tandem-nsk.
+		Reported by <Duncan_Stodart@insession.com>.
+
+2002-09-10  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: More updates.
+
+2002-09-09  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update.
+
+2002-08-23  Andrew Cagney  <ac131313@redhat.com>
+
+	* texinfo/texinfo.tex: Import version 2002-06-04.06.
+
+	* config.guess: Import version 2002-08-23.
+	* config.sub: Import version 2002-08-22.
+
+2002-08-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (GCC_FOR_TARGET): Prepend STAGE_CC_WRAPPER.
+	* configure.in (CC_FOR_TARGET, GCJ_FOR_TARGET, CXX_FOR_TARGET,
+	CXX_FOR_TARGET_FOR_RECURSIVE_MAKE): Likewise.
+
+2002-08-06  Federico G. Schwindt <fgsch@olimpo.com.br>
+
+	* configure.in (hppa*-*-openbsd*): Treat like hppa*-*-*elf*.
+
+2002-08-04  H.J. Lu  (hjl@gnu.org)
+
+	* configure.in (mips*-*-linux*): Don't skip target-libffi.
+
+2002-07-31  Alan Modra  <amodra@bigpond.net.au>
+
+	* configure.in: Move generic linux case to end.	 Copy generic
+	linux noconfigdirs to mips*-*-linux* entry and new
+	powerpc64*-*-linux* entry.  Add target-libffi for the latter.
+
+2002-07-19  Chris Demetriou  <cgd@broadcom.com>
+
+	* MAINTAINERS: Clarify on config.guess and config.sub, and add
+	one instance of them which was missed to the list to update.
+
+2002-07-16  Chris Demetriou  <cgd@broadcom.com>
+
+	* config.guess: Update to 2002-07-09 version.
+	* config.sub: Update to 2002-07-03 version.
+
+2002-07-11  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Remove two redundant tests.
+
+2002-07-11  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in (mips*-*-irix6*o32): Enable stabs.
+
+2002-07-08  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Don't build grez.
+	* Makefile.in: Ditto.
+
+	* Makefile.in: Remove references to bsp, cygmon, libstub.
+	* configure.in: Ditto.
+
+	* configure.in: Remove leftover reference to gdbtest.
+
+2002-07-08  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure.in (gxx_include_dir):  Change to match versioned
+	C++ headers if --enable-version-specific-runtime-libs is used.
+
+2002-07-04  Steve Ellcey  <sje@cup.hp.com>
+
+	* ltcf-cxx.sh (hpux*): Modify to support ia64-*-hpux*.
+
+2002-07-03  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Make --without-x work.
+
+2002-07-03  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* contrib: New directory.  Created to contain a copy of the
+	texi2pod.pl script so that it is in the same place as the version in
+	the FSF GCC sources.
+
+2002-07-02  Nathanael Nerode  <neroden@gcc.gnu.org>
+
+	* configure.in: Rearrange target Makefile fragment collection.
+
+	* Makefile.in: Don't try to build gdbtest, tgas, ispell, inet, or
+	cvs[src].
+	* configure.in: Ditto.
+
+2002-07-01  Nathanael Nerode <neroden@gcc.gnu.org>
+
+	* Makefile.in: Eliminate 'apache' targets.
+	* configure.in: Eliminate 'apache' targets.
+
+	* configure.in: Eliminate redundant tests.  Reorganize.
+
+	* Makefile.in: Eliminate last reference to LIBGCC1_TEST.
+
+	* config-ml.in: Eliminate references to Cygnus configure.
+
+	* Makefile.in: Eliminate references to building emacs.
+
+2002-07-01  Denis Chertykov  <denisc@overta.ru>
+
+	* configure.in: Add support for ip2k.
+
+2002-06-24  Ben Elliston  <bje@redhat.com>
+
+	* configure.in (host_tools): Remove cgen.
+
+	* Makefile.in (all-cgen): Remove; runs from its source directory.
+	(check-cgen, install-cgen, clean-cgen): Likewise.
+	(all-opcodes): No not depend on all-cgen.
+	(all-sim): Likewise.
+
+2002-06-22  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Fix AIX configury bug.
+
+2002-06-19  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Replace ${topsrcdir} with ${srcdir}.
+
+	* configure.in: Move definition of libstdcxx_flags right above
+	usage, rather than way earlier.
+
+	* configure.in: Pull definition of is_cross_compiler earlier.
+
+	* configure.in: Rearrange a little.
+
+	* configure.in: Remove references to librx.
+	* Makefile.in: Remove references to librx.
+
+2002-06-19  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Eliminate ${gasdir} variable.
+
+2002-06-18  Dave Brolley  <brolley@redhat.com>
+
+	* configure.in: Add support for frv.
+	* config.sub: Add support for frv.
+
+2002-06-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* Makefile.in (CFLAGS_FOR_TARGET): Add -O2.
+
+2002-06-08  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (vax-*-netbsd*): Re-enable gas.
+
+2002-05-31  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* Makefile.in: Replace HOST_PREFIX, HOST_PREFIX_1 with BUILD_PREFIX,
+	BUILD_PREFIX_1, to correct nomenclature.
+	* configure: Likewise.
+
+	* Makefile.in: Eliminate version-specific references to tcl8.1, tk8.1.
+	* configure.in: Eliminate version-specific references to tcl8.1, tk8.1.
+
+2002-05-31  Olaf Hering  <olh@suse.de>
+
+	* config-ml.in: Propogate DESTDIR also.
+
+2002-05-29  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (vax-*-netbsd*): Don't build gas for this
+	platform.
+
+2002-05-28  Marek Michalkiewicz  <marekm@amelek.gda.pl>
+
+	* configure.in (noconfigdirs): Don't compile libiberty, libstdcxx
+	and libgcj for AVR.
+
+2002-05-28  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* config.sub: Add DLX target.
+
+2002-05-22  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* config.guess: Update to 2002-05-22 version.
+	* config.sub: Likewise.
+
+2002-05-16  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* Makefile.in: Allow for PWDCMD to override hardcoded pwd.
+	* config-ml.in: Likewise.
+	* configure: Likewise.
+	* configure.in: Likewise.
+
+2002-05-13  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: Simplify makefile fragment collection.
+
+	* configure.in: Remove code to build emacs.
+
+	* configure.in : Remove --srcdir argument from targargs and buildargs
+	(it's always overridden in the Makefile anyway).  Rearrange a bit.
+
+	* configure: Move some logic to configure.in.
+	* configure.in: Move some logic from configure.
+
+2002-05-07  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.LIBGLOSS: New file.
+
+2002-05-07  Federico G. Schwindt <fgsch@olimpo.com.br>
+
+	* Makefile.in: Honour DESTDIR.
+
+2002-05-05  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs): Don't disable libgcj on
+	sparc64-*-solaris* and sparcv9-*-solaris*.
+
+2002-05-03  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Revert 2002-04-18's patch; fixed in libjava.
+
+2002-05-03  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Do not add
+	-B$$r/$(TARGET_SUBDIR)/newlib/ when compiling newlib natively
+	on i[3456]86-*-linux*.
+
+2002-05-01  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (noconfigdirs): Replace [ ] with test.
+
+	* configure.in (noconfigdirs): Do not add target-newlib if
+	target == i[3456]86-*-linux*, and host == target.
+
+2002-04-29  Mark Mitchell  <mark@codesourcery.com>
+
+	* config.guess: Updated to 2002-04-26's version.
+	* config.sub: Updated to 2002-04-26's version.
+
+2002-04-29  Nathanael Nerode  <neroden@doctormoo.dyndns.org>
+
+	* configure.in: delete reference to absent file
+
+	* configure.in: replace '[' with 'test'
+
+	* configure.in: Eliminate references to gash.
+	* Makefile.in: Eliminate references to gash.
+
+	* configure.in: remove useless references to 'pic' makefile fragments.
+
+	* configure.in: (*-*-windows*) Finish removing.
+
+	* configure.in: Eliminate redundant test for libgui.
+
+2002-04-26  Joel Sherrill  <joel@OARcorp.com>
+
+	* configure.in (h8300*-*-rtems*): Disable libf2c and libgcj.
+	(sparc-*-elf*, sparc64-*-elf*): Disable libgcj.
+
+2002-04-19  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: remove references to dead files
+
+2002-04-18  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Disallow configuring libgcj when it is already
+	installed and we're using Solaris 2.8 linker.  Do enable libgcj on
+	Solaris 2.8 by default.  For PR libgcj/6158.
+
+2002-04-17  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in:  Move default CC setting out of config/mh-* fragments
+	directly into here.
+
+2002-04-17  Nathanael Nerode  <neroden@twcny.rr.com>
+
+	* configure.in: don't even try to configure or make a subdirectory
+	if there's no configure script for it.
+
+2002-04-15  Mark Mitchell  <mark@codesourcery.com>
+
+	* MAINTAINERS: Remove chill maintainers.
+	* Makefile.in (CHILLFLAGS): Remove.
+	(CHILL_LIB): Remove.
+	(TARGET_CONFIGDIRS): Remove libchill.
+	(CHILL_FOR_TARGET): Remove.
+	(BASE_FLAGS_TO_PASS): Don't pass CHILLFLAGS, CHILL_FOR_TARGET, or
+	CHILL_LIB.
+	(CONFIGURE_TARGET_MODULES): Remove configure-target-libchill.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(configure-target-libchill): Remove.
+	(all-target-libchill): Remove.
+	* configure.in (target_libs): Remove target-libchill.
+	Do not compute CHILL_FOR_TARGET.
+	* libchill: Remove directory.
+
+2002-04-15  DJ Delorie  <dj@redhat.com>
+
+	* Makefile.in, configure.in, configure: Sync with gcc, entries
+	follow...
+
+2002-04-08  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Add FLAGS_FOR_TARGET to GCJ_FOR_TARGET.
+	Fixes PR libgcj/6068.
+
+2002-03-30  Krister Walfridsson  <cato@df.lth.se>
+
+	* configure.in (i*86-*-netbsdelf*): Don't disable libgcj.
+
+2002-03-27  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* configure.in (alpha*-dec-osf*): Enable libgcj.
+
+2002-03-24  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	Fix for: PR bootstrap/3591, target/5676
+	* configure.in (mcore-pe): Disable the configuration of
+	libstdc++-v3 since exceptions are not supported.
+
+2002-03-20  Anthony Green  <green@redhat.com>
+
+	* configure.in: Enable libgcj for xscale-elf target.
+
+2002-02-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Don't add libstdc++-v3 flags for
+	libjava.
+	(CXX_FOR_TARGET): Explain why -shared-libgcc here.
+
+2002-02-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CXX_FOR_TARGET): Add -shared-libgcc for
+	libstdc++-v3 and libjava.
+
+2002-02-11  Adam Megacz <adam@xwt.org>
+
+	* gcc/Makefile.in: Removed libstdc++-v3 dependancy for libjava and
+	boehm-gc
+
+2002-02-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config.guess: Updated to 2002-01-30's version.
+	* config.sub: Updated to 2002-02-01's version.
+	Contribute sh64-elf.
+	2000-12-01  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in: Added sh64-*-*.
+
+2002-01-17  H.J. Lu <hjl@gnu.org>
+
+	* Makefile.in (all-fastjar): Also depend on all-libiberty.
+	(all-target-fastjar): Also depend on all-target-libiberty.
+
+Wed Dec  5 07:33:45 2001  Douglas B. Rupp  <rupp@gnat.com>
+
+	* configure, configure.in: Use temp file for long sed commands.
+
+2001-11-14  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [h8300*-*-*, h8500-*-*]: Disable
+	libf2c.
+
+2001-11-03  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* configure.in (noconfigdirs) [mmix-*-*]: Disable libgcj.
+
+2001-10-11  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (noconfigdirs) [cris-*-*]: Disable libgcj.
+
+2001-10-02  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* configure: Handle temporary files securely using mkdir.
+
+2001-09-26  Will Cohen <wcohen@redhat.com>
+
+	* configure.in (*-*-linux*): Disable configuration of target-newlib
+	and target-libgloss.
+
+2001-09-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (EXTRA_TARGET_FLAGS): Pass RANLIB_FOR_TARGET for
+	RANLIB.
+
+2001-08-11  Graham Stott  <grahams@redhat.com>
+
+	* Makefile.in (check-c++): Add missing semicolon.
+
+2001-07-25  Andrew Haley  <aph@cambridge.redhat.com>
+
+	* configure.in (sh-*-linux*): New.
+
+2001-07-12  Stephane Carrez  <Stephane.Carrez@worldnet.fr>
+
+	* configure.in (noconfigdirs): Don't compile libiberty, libstdcxx
+	and libgcj on m68hc11/m68hc12.
+
+2001-06-27  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile (CFLAGS_FOR_BUILD): New.
+	(EXTRA_GCC_FLAGS): Add CFLAGS_FOR_BUILD.
+
+2001-06-01  Hans-Peter Nilsson  <hp@axis.com>
+
+	* configure.in (libstdcxx_flags): Do not try to execute
+	libstdc++-v3/testsuite_flags until it exists.
+
+2001-05-18  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* configure.in (libstdcxx_flags): Remove reference to libstdc++.INC.
+
+2001-05-09  Jeffrey Oldham  <oldham@codesourcery.com>
+
+	* ltcf-cxx.sh: Add -nostdlib to IRIX 6 archive_cmds.
+
+Mon Apr 23 09:15:03 2001  Anthony Green  <green@redhat.com>
+
+	* configure.in: Move *-chorusos target case to the proper switch.
+	Disable libgcj.
+
+2001-04-13  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>
+
+	* Makefile.in (STAGE1_CFLAGS): Pass down.
+
+2001-04-13  Alan Modra  <amodra@one.net.au>
+
+	* config.guess: Add hppa64-linux support.  Note for next import that
+	this is already in the master file.
+	* configure.in: Likewise.  Accept `parisc' alias for `hppa'.
+
+2001-03-22  Colin Howell  <chowell@redhat.com>
+
+	* Makefile.in (DO_X): Do not backslash single-quotes in
+	backquotes (two places).
+
+2001-03-18  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in (DO_X): Quote nested quotes.
+
+2001-03-15  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in (DO_X): Use double quotes for quoting
+	"RANLIB=$${RANLIB}".
+
+2001-03-09  Nicola Pero <n.pero@mi.flashnet.it>
+
+	* configure.in: Only use `lang_requires' for languages athat are
+	actually enabled.
+
+2001-03-07  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Allow config-lang.in to set `lang_requires' to list
+	of other required languages.
+
+2001-03-06  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in: Remove RANLIB definition. Use RANLIB
+	in RANLIB_FOR_TARGET, EXTRA_HOST_FLAGS, EXTRA_TARGET_FLAGS,
+	EXTRA_GCC_FLAGS, $(DO_X) targets only when the RANLIB is set.
+
+2001-02-28  Benjamin Kosnik  <bkoz@redhat.com>
+	    Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (check-c++): Use tabs, not spaces.
+
+2001-02-19  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* Makefile.in (check-c++): New rule.
+
+	* configure.in (target_libs): Remove libg++.
+	(noconfigdirs): Remove libg++.
+	(noconfigdirs): Same.
+	(noconfigdirs): Same.
+	(noconfigdirs): Same.
+
+	* config-ml.in: Remove libg++ references.
+
+	* Makefile.in (TARGET_CONFIGDIRS): Remove libio, libstdc++, libg++.
+	(ALL_TARGET_MODULES): Same.
+	(configure-target-libg++): Remove.
+	(all-target-libg++): Remove.
+	(configure-target-libio): Remove.
+	(all-target-libio): Remove.
+	(check-target-libio): Remove.
+	(.PHONY): Remove.
+	(libg++.tar.bz2): Remove.
+	(all-target-cygmon): Remove libio.
+	(all-target-libstdc++): Remove.
+	(configure-target-libstdc++): Remove.
+	(TARGET_LIB_PATH): Remove libstdc++.
+	(ALL_GCC_CXX): Remove libstdc++.
+	(all-target-gperf): Correct.
+
+2001-02-15  Anthony Green  <green@redhat.com>
+
+	* configure: Introduce GCJ_FOR_TARGET.
+	* configure.in: Ditto.
+	* Makefile.in: Ditto.
+
+2001-02-08  Chandrakala Chavva <cchavva@redhat.com>
+
+	* configure.in: for *-chorusos, don't config target-newlib and
+	target-libgloss.
+
+2001-02-04  Mark Mitchell  <mark@codesourcery.com>
+
+	Remove V2 C++ library.
+	* configure.in: Remove --enable-libstdcxx_v3 support.
+
+2001-01-27  Richard Henderson  <rth@redhat.com>
+
+	* configure.in (target_makefile_frag) [alpha*-*]: Use mt-alphaieee.
+
+2001-01-26  Tom Tromey  <tromey@redhat.com>
+
+	* configure.in: Allow libgcj to be built on Sparc Solaris.
+
+2001-01-23  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* configure.in: Enable libgcj on several additional platforms.
+
+2001-01-22  Bryce McKinlay  <bryce@albatross.co.nz>
+
+	* configure.in: Enable libgcj for linux targets.
+
+2001-01-09  Mike Stump  <mrs@wrs.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Pass back configuration
+	failures of subdirectories.
+
+2001-01-02  Laurynas Biveinis  <lauras@softhome.net>
+
+	* configure: handle DOS-style absolute paths.
+
+2001-01-02  Laurynas Biveinis  <lauras@softhome.net>
+
+	* configure.in: remove supported directories from $noconfigdirs for DJGPP.
+
+2000-12-18  Benjamin Kosnik  <bkoz@redhat.com>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Alphabetize.
+	(libstdcxx_incdir): Pass down.
+	* config.if: Remove expired bits for cxx_interface, add stub.
+	(libstdcxx_incdir): Add variable for g++ include directory.
+	* configure.in (gxx_include_dir): Use it.
+
+2000-12-15  Andreas Jaeger  <aj@suse.de>
+
+	* configure.in: Handle lang_dirs.
+
+2000-12-13  Anthony Green  <green@redhat.com>
+
+	* configure.in: Disable libgcj for any target not specifically
+	listed.  Disable libgcj for x86 and Alpha Linux until compatible
+	with g++ abi.
+
+2000-12-13  Mike Stump  <mrs@wrs.com>
+
+	* Makefile.in (local-distclean): Also remove fastjar.
+
+2000-12-10  Anthony Green  <green@redhat.com>
+
+	* configure.in: Define libgcj.  Disable libgcj target libraries for
+	most targets.
+
+2000-12-09  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* configure.in (target_libs): Revert 2000-12-08 patch.
+	(noconfigdirs): Added target-libjava.
+
+2000-12-09  Laurynas Biveinis  <lauras@softhome.net>
+
+	* Makefile.in: handle DOS-style absolute paths.
+
+2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* Makefile.in (TARGET_CONFIGDIRS): Wrong place. Removed note about
+	libjava.
+	* configure.in (target_libs): Removed `target-libjava'.
+
+2000-12-08  Alexandre Petit-Bianco  <apbianco@cygnus.com>
+
+	* Makefile.in (TARGET_CONFIGDIRS): Added note about libjava.
+	(ALL_MODULES): Added fastjar.
+	(NATIVE_CHECK_MODULES, INSTALL_MODULES, CLEAN_MODULES): Likewise.
+	(all-target-libjava): all-fastjar replaces all-zip.
+	(all-fastjar): Added.
+	(configure-target-fastjar, all-target-fastjar): Likewise.
+	* configure.in (host_tools): Added fastjar.
+
+2000-12-07  Mike Stump  <mrs@wrs.com>
+
+	* Makefile.in (local-distclean): Remove leftover built files.
+
+2000-11-16  Fred Fish  <fnf@be.com>
+
+	* configure.in (enable_libstdcxx_v3): Fix typo,
+	libstd++ -> libstdc++.
+
+2000-11-13  Joseph S. Myers  <jsm28@cam.ac.uk>
+
+	* configure: Provide the original toplevel configure arguments
+	(including $0) to subprocesses in the environment rather than
+	through gcc/configargs.h.
+
+2000-11-12  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure: Turn on libstdc++ V3 by default.
+
+2000-10-16  Michael Meissner  <meissner@redhat.com>
+
+	* configure (gcc/configargs.h): Only create if there is a build GCC
+	directory created.
+
+2000-10-05  Phil Edwards  <pme@gcc.gnu.org>
+
+	* configure: Save configure arguments to gcc/configargs.h.
+
+2000-10-04  Andris Pavenis  <pavenis@latnet.lv>
+
+	* Makefile.in (bootstrap): avoid recursion if subdir missing
+	(cross): ditto
+	(do-proto-toplev): ditto
+
+Wed Sep 13 11:11:29 2000  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Do not build byacc for hppa64.  Provide paths to the
+	X11 libraries for hppa64.
+
+2000-09-02  Anthony Green  <green@cygnus.com>
+
+	* Makefile.in (all-gcc): Depend on all-zlib.
+	(CLEAN_MODULES): Add clean-zlib.
+	(ALL_MODULES): Add all-zlib.
+	* configure.in (host_libs): Add zlib.
+
+2000-08-25  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Use $target_configdirs and
+	$targargs to tell whether newlib is going to be built.
+
+	* configure.in [disable-libstdcxx-v3] (libstdcxx_flags): Search
+	$$r/TARGET_SUBDIR/libio for _G_config.h.
+
+2000-08-14  Zack Weinberg  <zack@wolery.cumb.org>
+
+	* configure.in (libstdcxx_flags): Remove -isystem $$s/libio/stdio.
+
+	* configure: Make enable_threads and enable_shared defaults
+	explicit.  Substitute enable_threads into generated Makefiles.
+	* configure.in: Accept *-*-linux* not just *-*-linux-gnu*.
+	* libtool.m4: Accept *-*-linux* not just *-*-linux-gnu*.
+
+2000-08-02  Manfred Hollstein  <manfredh@redhat.com>
+
+	* configure.in: Re-enable all references to libg++ and librx.
+
+2002-04-09  Loren James Rittle  <rittle@labs.mot.com>
+
+	* configure.in: Add *-*-freebsd* configurations.
+
+2002-04-07  Andrew Cagney  <ac131313@redhat.com>
+
+	* Makefile.in (do-tar-bz2): Delete rule.  Replace with ...
+	(do-tar, do-bz2): New rules.
+	(taz): Update.  Replace do-tar-bz2 with do-tar and do-bz2.
+	(gdb-tar): New rule.
+	(gdb-taz): Rewrite.  Use gdb-tar and do-bz2.
+	(insight_dejagnu.tar): New rule.
+	(insight.tar): New rule.
+	(gdb+dejagnu.tar): New rule.
+	(gdb.tar): New rule.
+
+2002-04-07  Andrew Cagney  <ac131313@redhat.com>
+
+	* MAINTAINERS: Update dejagnu/
+
+2002-03-16  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltmain.sh (relink_command): Fix typo in previous change.
+
+2002-03-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltmain.sh (taglist): Initialized.  Don't let `CC' tag out of it.
+	(relink_command): Added --tag flags.
+	(mode=install): If relinking fails; error out.
+
+2002-03-12  Richard Henderson  <rth@redhat.com>
+
+	* Makefile.in (NOTPARALLEL): New.  Use it instead of explicit
+	.NOTPARALLEL tag.
+	(do-check): Rename from check.
+	(check): Allow parallel check.
+
+2002-03-11  Richard Henderson  <rth@redhat.com>
+
+	* Makefile.in (.NOTPARALLEL): Add fake tag.
+
+2002-03-07  H.J. Lu  (hjl@gnu.org)
+
+	* configure.in: Enable gprof for mips*-*-linux*.
+
+2002-02-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Don't add libstdc++-v3 flags for
+	libjava.
+	(CXX_FOR_TARGET): Add -shared-libgcc for libstdc++-v3 and libjava.
+
+2002-02-24  Andrew Cagney  <ac131313@redhat.com>
+
+	* texinfo/texinfo.tex: Update to version 2002-02-14.08.
+
+2002-02-23  Daniel Jacobowitz  <drow@mvista.com>
+
+	* config.guess: Import from master sources, rev 1.232.
+	* config.sub: Import from master sources, rev 1.246.
+
+2002-02-23  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (MAKEINFO): Don't assume makeinfo will be built just
+	because its Makefile is there; test for the executable instead.
+
+2002-02-09  Alexandre Oliva  <aoliva@redhat.com>
+
+	Contribute sh64-elf.
+	2000-12-01  Alexandre Oliva  <aoliva@redhat.com>
+	* configure.in: Added sh64-*-*.
+
+2002-02-04  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Remove advertising clause from
+	Berkeley and Red Hat licenses.
+
+2002-02-01  Mo DeJong  <supermo@bayarea.net>
+
+	* Makefile.in: Add all-tix to deps for all-snavigator
+	so that tix is built when building snavigator.
+
+2002-02-01  Ben Elliston  <bje@redhat.com>
+
+	* config.guess: Import from master sources, rev 1.229.
+	* config.sub: Import from master sources, rev 1.240.
+
+2002-01-27  Daniel Jacobowitz  <drow@mvista.com>
+
+	From Steve Ellcey <sje@cup.hp.com>:
+	* libtool.m4 (HPUX_IA64_MODE): Set to 32 or 64 based on ABI.
+	(lt_cv_deplibs_check_method, lt_cv_file_magic_cmd,
+	lt_cv_file_magic_test_file): Set to appropriate values for HP-UX
+	IA64.
+	* ltcf-c.sh (archive_cmds, hardcode_*): Ditto.
+	* ltconfig (shlibpath_*, dynamic_linker, library_names_spec,
+	soname_spec, sys_lib_search_path_spec): Ditto.
+
+2002-01-26  Jason Thorpe  <thorpej@wasabisystems.com>
+
+	* configure.in (*-*-netbsd*): New.  Skip target-newlib,
+	target-libiberty, and target-libgloss.  Skip Java-related
+	libraries if not supported for NetBSD on target CPU.
+
+2002-01-23  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* configure.in: Import StrongARM and XScale target_configdirs from
+	FSF GCC version.
+
+2002-01-16  H.J. Lu  (hjl@gnu.org)
+
+	* config.guess: Import from master sources, rev 1.225.
+	* config.sub: Import from master sources, rev 1.238.
+
+	* MAINTAINERS: Updated notes on config.guess and config.sub.
+
+2002-01-11  Steve Ellcey  <sje@cup.hp.com>
+
+	* configure.in (ia64*-*-hpux*): New target for IA64 HP-UX,
+	ld and gdb are not supported.
+
+2002-01-07  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* Change reference to Cygnus Solutions to be Red Hat.
+
+2002-01-07  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Update generic copyright date.
+
+2002-01-07  Mark Salter  <msalter@redhat.com>
+
+	* configure.in: Remove target-bsp and target-cygmon from arm builds.
+	  Allow target-libgloss to be built for arm, strongarm, and xscale.
+
+2002-01-03  Ben Elliston  <bje@redhat.com>
+
+	* MAINTAINERS: Update URL for config.* scripts.
+
+2001-12-18  Alan Modra  <amodra@bigpond.net.au>
+
+	* config.sub: Import latest version.
+	* config.guess: Likewise.
+
+2001-12-13  Thomas Fitzsimmons  <fitzsim@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Remove -nostdinc and -isystem
+	options for i[3456]86-pc-linux* native builds.
+
+2001-12-05  Laurent Guerby  <guerby@acm.org>
+
+	* MAINTAINERS: gcc adopts symlink-tree, refer more to
+	libiberty.
+
+	Import this patch from gcc:
+
+	2000-12-09  Laurynas Biveinis  <lauras@softhome.net>
+
+	    * symlink-tree: handle DOS-style absolute paths.
+
+2001-11-28  DJ Delorie <dj@redhat.com>
+	    Zack Weinberg  <zack@codesourcery.com>
+
+	When build != host, create libiberty for the build machine.
+
+	* Makefile.in (TARGET_CONFIGARGS, BUILD_CONFIGARGS): Replace
+	CONFIG_ARGUMENTS.
+	(ALL_BUILD_MODULES_LIST, BUILD_CONFIGDIRS, BUILD_SUBDIR):
+	New variables.
+	(ALL_BUILD_MODULES, CONFIGURE_BUILD_MODULES): New variables
+	and rules.
+	(all.normal): Depend on ALL_BUILD_MODULES.
+	(CONFIGURE_TARGET_MODULES rule): Use TARGET_CONFIGARGS.
+	(all-build-libiberty): Depend on configure-build-libiberty.
+
+	* configure: Calculate and substitute proper value for
+	ALL_BUILD_MODULES.
+	* configure.in: Create the build subdirectory.
+	Calculate and substitute TARGET_CONFIGARGS (formerly
+	CONFIG_ARGUMENTS); also BUILD_SUBDIR and BUILD_CONFIGARGS (new).
+
+2001-11-26  Geoffrey Keating  <geoffk@redhat.com>
+
+	* config.sub: Update to version 1.232 on subversion.
+
+2001-11-20  Nick Clifton  <nickc@cambridge.redhat.com>
+
+	* Makefile.in (do-proto-toplev): Use msgfmt to generate .gmo
+	files from .po files for a distribution.
+
+2001-11-19  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* COPYING.NEWLIB: Mention preserved notice in specific parts.
+
+2001-11-13  Jeff Holcomb  <jeffh@redhat.com>
+
+	Merged from net gcc:
+	2001-07-30  Jeff Sturm  <jsturm@one-pont.com>
+	* ltcf-c.sh: Use $objext, not $ac_objext.
+	2001-07-27  Mark Kettenis  <kettenis@gnu.org>
+	* ltcf-cxx.sh: Add support for GNU.
+	2001-07-22  Timothy Wall  <twall@redhat.com>
+	* ltcf-c.sh: Don't disable shared libraries for AIX5/IA64.  Preserve
+	default settings if using GNU tools with that configuration.
+	* ltcf-cxx.sh: Ditto.
+	* ltcf-gcj.sh: Ditto.
+	2001-07-21  Michael Chastain  <chastain@redhat.com>
+	* ltconfig: Set max_cmd_len to a maximum of 512Kb, as it seems some
+	HPUX 11.0 systems have trouble with 1MB.  Mark as gcc-local.
+	* ltmain.sh: Mark as gcc-local.
+
+2001-11-13  Jeff Holcomb  <jeffh@redhat.com>
+
+	* Makefile.in (all-bison): Revert 2001-10-24.
+	Don't depend on texinfo.
+
+2001-11-12  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* COPYING.NEWLIB: Add BSD-style license/copyright blurb for my work.
+
+2001-11-08  Phil Edwards  <pedwards@disaster.jaj.com>
+
+	* configure.in (--enable-languages): Be more permissive about
+	syntax.  Check for empty lists better.  Warn about $LANGUAGES.
+
+2001-11-06  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* Makefile.in (MAKEINFO): Use "missing" for makeinfo older than 4.0.
+
+2001-10-24  Jeff Holcomb  <jeffh@redhat.com>
+
+	Makefile.in (all-bison): Don't depend on texinfo.
+
+2001-10-03  Alan Modra  <amodra@bigpond.net.au>
+
+	* gettext.m4: Test po/POTFILES.in exists before trying to read.
+
+2001-09-29  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (configure-target-gperf): Depend on $(ALL_GCC_CXX).
+
+2001-09-28  Hans-Peter Nilsson  <hp@axis.com>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-09-21  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (AS_FOR_TARGET, LD_FOR_TARGET,
+	DLLTOOL_FOR_TARGET, WINDRES_FOR_TARGET, AR_FOR_TARGET,
+	RANLIB_FOR_TARGET, NM_FOR_TARGET): Don't use double quotes to
+	avoid quotes nesting problems.
+	(NATIVE_CHECK_MODULES): Ditto, just for consistency.
+	(DO_X): Export only variables that are set.
+
+2001-09-19  Ben Elliston  <bje@redhat.com>
+
+	* configure.in (sparc-sun-solaris2*): Don't use /usr/bin/which on
+	Solaris when testing for the /usr/ucb/cc compiler; it has incorrect
+	semantics.  Use the shell built-in "type" command instead.
+
+2001-09-15  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+
+	* config.sub: Reverted the earlier change, this version is not the
+	master file.
+
+2001-09-14  Thiemo Seufer <seufer@csv.ica.uni-stuttgart.de>
+
+	* config.sub: Change machine triplets from mipsel*-* to mips*el-*.
+	Add support for mips64.
+
+2001-09-03  Jeff Holcomb  <jeffh@redhat.com>
+
+	* configure.in: Enable libstdc++-v3 for h8300 targets.
+
+2001-08-30  Eric Christopher  <echristo@redhat.com>
+	    Jason Eckhardt  <jle@redhat.com>
+
+	* config.sub: Add support for mipsisa32.
+
+2001-08-30  Eric Christopher  <echristo@redhat.com>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-08-20  Alan Modra  <amodra@bigpond.net.au>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-07-26  DJ Delorie  <dj@redhat.com>
+
+	* MAINTAINERS: Clarify libiberty merge rules and procedures.
+
+2001-06-19  Alan Modra  <amodra@bigpond.net.au>
+
+	* Makefile.in: Revert 2001-06-17.
+	(VER): If AM_INIT_AUTOMAKE uses BFD_VERSION, get version from bfd/.
+
+2001-06-17  H.J. Lu <hjl@gnu.org>
+
+	* Makefile.in (gas.tar.bz2): Pass TOOL=bfd PACKAGE=gas to make.
+	(gas+binutils.tar.bz2): Likewise.
+	(binutils.tar.bz2): Pass TOOL=bfd PACKAGE=binutils to make.
+
+Fri Jun  8 11:14:02 2001  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (VER): When present, extract the version number from
+	the file version.in.
+
+2001-06-08  Alexandre Oliva  <aoliva@redhat.com>, Jeff Sturm  <jsturm@one-point.com>
+
+	* Makefile.in (AS_FOR_TARGET, LD_FOR_TARGET, NM_FOR_TARGET): If
+	gcc/xgcc is built, use -print-prog-name to find out the program
+	name to use.
+
+2001-06-04  Mark Mitchell  <mark@codesourcery.com>
+
+	* ltcf-c.sh (archive_cmds, archive_expsym_cmds) [solaris,
+	with_gcc]: Use `gcc -shared' to build a shared library.
+
+2001-06-04  John David Anglin  <dave@hiauly1.hia.nrc.ca>
+
+	* ltcf-c.sh (archive_cmd) [hpux, with_gcc]: Use gcc to link shared
+	archives.
+
+2001-05-28  Simon Patarin <simon.patarin@inria.fr>
+
+	* ltcf-cxx.sh (osf3/osf4/osf5): Support creation of C++  shared
+	libraries when using g++ with native linker.
+
+2001-05-28  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh: Upgrade to libtool 1.4a 1.641.2.256.
+
+2001-05-24  Tom Rix <trix@redhat.com>
+
+	* configure.in : enable ld for aix
+
+2001-05-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-cxx.sh (allow_undefined_flag, no_undefined_flag)
+	[aix4*|aix5*]: Prepend blank.
+
+2001-05-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh, ltcf-cxx.sh,
+	ltcf-gcj.sh: Upgraded to libtool 1.4a 1.641.2.254.  Rebuilt a number
+	of subdir/configure scripts to use the new libtool.m4.
+
+2001-05-14  H.J. Lu <hjl@gnu.org>
+
+	* config.if (libc_interface): Set to -libc6.2- for cross
+	compiling to Linux/glibc 2.2.
+
+2001-05-03  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs) [*-cygwin*, *-mingw*, *-beos]: Disable
+	libgcj.
+
+2001-04-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs): Don't reset it from scratch in the
+	target case; only append to it.
+
+2001-04-26  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (noconfigdirs) [hppa*-*-*, mips*-*-irix6*,
+	sparc-*-solaris2.8]: Disable ${libgcj}.
+
+2001-04-25  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libgcj_saved): Copy from $libgcj.
+	(libgcj): Zero out if --enable-libgcj; add to noconfigdirs is
+	--disable-libgcj.
+
+2001-04-20  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, ltcf-cxx.sh: Upgraded to libtool 1.4a
+	1.641.2.228.
+
+2001-04-12  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh, ltcf-cxx.sh,
+	ltcf-gcj.sh: Upgraded to libtool 1.4a 1.641.2.226.
+
+2001-04-01  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (CXX_FOR_TARGET_FOR_RECURSIVE_MAKE, RECURSE_FLAGS):
+	New macros.
+	(bootstrap, cross): Use RECURSE_FLAGS.
+	* configure.in: Subst CXX_FOR_TARGET_FOR_RECURSIVE_MAKE.
+
+2001-03-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CXX_FOR_TARGET): Use xgcc for libstdc++-v3.
+
+2001-03-23  Nick Clifton  <nickc@redhat.com>
+
+	* README-maintainer-mode: Add note about inability to use "make
+	distclean" in maintainer mode.
+
+2001-03-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	Re-installed:
+	2001-01-02  Laurynas Biveinis  <lauras@softhome.net>
+	* ltcf-c.sh: Clear ac_cv_prog_cc_pic for DJGPP.  Do not add
+	'-DPIC' to ac_cv_prog_cc_pic for DJGPP.
+	* ltcf-cxx.sh: Likewise.
+	* ltcf-gcj.sh: Likewise.
+
+2001-03-22  Philip Blundell  <philb@gnu.org>
+
+	* config.sub, config.guess: Import latest from subversions.
+
+2001-03-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh, ltcf-cxx.sh,
+	ltcf-gcj.sh: Upgraded to libtool 1.4a 1.641.2.198.
+
+2001-03-20  Michael Chastain  <chastain@redhat.com>
+
+	* Makefile.in: all-m4 depends on all-texinfo.
+
+2001-03-08  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (ALL_GCC, ALL_GCC_C, ALL_GCC_CXX): Set before use.
+
+2001-02-22  Jeff Johnston <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Remove DJ Delorie's address because it is no
+	longer valid.
+
+2001-02-16  Nick Clifton  <nickc@redhat.com>
+
+	* configure.in (noconfigdirs): Allow configuration of texinfo
+	for Cygwin hosts.
+
+2001-02-09  Martin Schwidefsky  <schwidefsky@de.ibm.com>
+
+	* config.guess: Add linux target for S/390.
+	* config.sub: Likewise.
+	* configure.in: Likewise.
+
+2001-02-06  Ben Elliston  <bje@redhat.com>
+
+	* configure: Output host type to stdout, not stderr.
+
+2001-02-04  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* config.guess: Import from subversions.gnu.org (revision 1.181).
+	* config.sub: Import from subversions.gnu.org (revision 1.199).
+
+2001-01-30  Alan Modra  <alan@linuxcare.com.au>
+
+	* config.guess: Handle hppa64-linux systems.
+
+2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* ltcf-cxx.sh (ac_cv_prog_cc_pic_works, ac_cv_prog_cc_static_works):
+	Don't unset, it's non-portable and no longer necessary, set to empty
+	instead.
+
+2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>,  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* ltconfig: Shell portability fix for the tagname validity check.
+
+2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* ltcf-cxx.sh: Use parentheses around eval $ac_compile.
+
+2001-01-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-c.sh (ld_shlibs) [aix5*]: Disable on unknown CPU types.
+	* ltcf-cxx.sh, ltcf-gcj.sh: Likewise.
+
+2001-01-24  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltmain.sh (TAG disable-shared, TAG disable-static): Make sure we
+	keep at least one of build_libtool_libs or build_old_libs set to
+	yes.
+
+2001-01-24  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-gcj.sh (lt_simple_link_test_code): Remove stray `(0)'.
+	* libtool.m4 (_AC_LIBTOOL_GCJ): Pass $CPPFLAGS on.
+
+2000-11-07  Philip Blundell  <pb@futuretv.com>
+
+	* Makefile.in (ETC_SUPPORT): Also add configbuild.* and configdev.*.
+
+2000-11-03  Philip Blundell  <pb@futuretv.com>
+
+	* Makefile.in (ETC_SUPPORT): Add configure.texi and associated info
+	files.
+
+2001-01-15  Jeff Johnston  <jjohnstn@redhat.com>
+
+	* COPYING.NEWLIB: Put into source repository.
+
+2001-01-15  Ben Elliston  <bje@redhat.com>
+
+	* configure.in (host_tools): Add sid.
+	Always configure cgen.
+	* Makefile.in (all-sid): New target.
+	(check-sid, clean-sid, install-sid): Likewise.
+
+2001-01-07  Andreas Jaeger  <aj@suse.de>
+
+	* config.sub, config.guess: Update from subversions.
+
+2000-12-12  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in: Disable language-specific target libraries for
+	languages that aren't enabled.
+
+2000-11-24  Nick Clifton  <nickc@redhat.com>
+
+	* configure.in (xscale-elf): Add target.
+	(xscale-coff): Add target.
+	(c4x, c5x, tic54x): Move after ARM targets.
+
+2000-11-23  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltcf-gcj.sh: Added file, required by 2000-11-18 merge.
+
+2000-11-20  Ian Lance Taylor  <ian@zembu.com>
+
+	* ltcf-cxx.sh: Added file, required by 2000-11-18 merge.
+
+2000-11-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in: Merge with GCC and libgcj.
+	(ALL_GCC_C, ALL_GCC_CXX): New macros.  Use them as dependencies of
+	configure-target-<library> when their configure scripts need the C
+	or C++ library to have already been built to work properly.
+	(do_proto_toplev): Set them to an empty string.
+
+2000-11-18  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (HOST_LIB_PATH, TARGET_LIB_PATH): New macros.
+	(REALLY_SET_LIB_PATH): Use them.
+
+2000-11-06  Christopher Faylor <cgf@cygnus.com>
+
+	* config.sub: Add support for Sun Chorus
+
+2000-11-02  Per Lundberg  <plundis@chaosdev.org>
+
+	* config.sub: Add support for the *-storm-chaos OS.
+
+2000-10-30  Stephane Carrez  <stcarrez@worldnet.fr>
+
+	* configure.in (noconfigdirs): Don't compile some
+	of the libraries for 68HC11 & 68hc12 targets.
+
+2000-09-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh, libtool.m4: Updated from libtool
+	multi-language branch, to work around Solaris' /bin/sh bug.  Rebuilt
+	all affected `configure' scripts.
+
+2000-09-25  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (DEVO_SUPPORT): Added gettext.m4, libtool.m4 and
+	ltcf-c.sh.
+
+2000-09-12  Philip Blundell  <philb@gnu.org>
+
+	* config.sub, config.guess: Update from subversions.
+
+2000-09-06  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (all-zlib): Added dummy target.
+
+	* ltconfig, ltmain.sh, libtool.m4, ltcf-c.sh: Updated from libtool
+	multi-language branch.
+
+2000-09-05  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (all-bootstrap): Added all-texinfo and all-zlib.
+	(bootstrap*): Depend on all-bootstrap.
+
+2000-09-02  Alexandre Oliva  <aoliva@redhat.com>, DJ Delorie  <dj@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): Use -nostdinc even for Canadian
+	crosses, but add gcc/include to the header search path for them.
+
+2000-08-31  Alexandre Oliva  <aoliva@redhat.com>
+
+	* ltconfig, ltmain.sh: Updated from libtool multi-language branch.
+	* libtool.m4, ltcf-c.sh: Copied from libtool multi-language branch.
+	* gettext.m4: New file, extracted from aclocal.m4.
+
+2000-08-22  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config-ml.in (CC, CXX): Avoid trailing whitespace.
+	(LD_LIBRARY_PATH, SHLIB_PATH): Adjust for multilibs and export to
+	sub-configures.
+
+2000-08-20  Doug Evans  <dje@casey.transmeta.com>
+
+	* Makefile.in (ALL_MODULES): Add all-cgen.
+	(CROSS_CHECK_MODULES,INSTALL_MODULES,CLEAN_MODULES): Similarily.
+	(all-cgen): New target.
+	(all-opcodes,all-sim): Depend on all-cgen.
+	* configure.in (host_tools): Add cgen.
+	Only configure cgen if --enable-cgen-maint.
+
+2000-08-17  Alexandre Oliva  <aoliva@redhat.com>
+
+	* config-ml.in (CC, CXX): Don't introduce a leading space.
+
+2000-08-16  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Use
+	libstdc++-v3/src/libstdc++.INC.
+
+2000-08-15  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Use libstdc++-v3/src/INCLUDES.
+
+2000-08-11  Jason Merrill  <jason@redhat.com>
+
+	* configure.in (CC_FOR_TARGET, CHILL_FOR_TARGET,
+	CXX_FOR_TARGET): Add -B$$r/gcc/ here.
+	(FLAGS_FOR_TARGET): Not here.
+	(CHILL_FOR_TARGET, CXX_FOR_TARGET): Don't check the list of languages.
+
+2000-08-07  DJ Delorie  <dj@redhat.com>
+
+	* configure.in (FLAGS_FOR_TARGET): invert test for xgcc, should mean
+	"if we're also building gcc, and it's a gcc that will run on the
+	build machine, we want to use its includes instead of the system's
+	default includes".
+
+2000-08-03  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (libstdcxx_flags): Don't use `"'.
+
+	* config-ml.in: Adjust multilib search paths to the
+	appropriate multilib tree.
+
+2000-08-02  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CHILL_FOR_TARGET, CXX_FOR_TARGET): Convert blanks to
+	commas in $LANGUAGES.
+
+2000-08-01  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (qCXX_FOR_TARGET): Use echo instead of expr.
+
+2000-07-31  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (qCXX_FOR_TARGET): Quote `&' characters in
+	CXX_FOR_TARGET for sed.
+
+2000-07-30  Alexandre Oliva  <aoliva@redhat.com>
+
+	* configure.in (CC_FOR_TARGET, CHILL_FOR_TARGET, CXX_FOR_TARGET):
+	Do not override if already set in the environment or in configure.
+	Don't duplicate $(FLAGS_FOR_TARGET) if it already appears in them.
+	(FLAGS_FOR_TARGET): Don't use host directories on Canadian crosses.
+
+2000-07-27  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (FLAGS_FOR_TARGET): New macro.
+	(GCC_FOR_TARGET): Use it.
+	(CC_FOR_TARGET, CXX_FOR_TARGET, CHILL_FOR_TARGET): Now defined...
+	* configure.in: ... here.
+	(FLAGS_FOR_TARGET): Define.  Add ld build dir to -L path.
+	(libstdcxx_flags): Define and append to CXX_FOR_TARGET.
+
+2000-07-24  Alexandre Oliva  <aoliva@redhat.com>
+
+	* Makefile.in (configure-target-libf2c): Depend on $(ALL_GCC).
+	(configure-target-libchill, configure-target-libobjc): Likewise.
+
+	* configure.in: Use the same cache file for all target libs.
+	* config-ml.in: But different cache files per multilib variant.
+
+2000-07-23  Michael Sokolov  <msokolov@ivan.Harhan.ORG>
+
+	* configure (topsrcdir): Don't use dirname.
+
+2000-07-20  Jason Merrill  <jason@redhat.com>
+
+	* configure.in: Remove all references to libg++ and librx.
+
+	* configure, configure.in, Makefile.in: Unify gcc and binutils.
+
+2000-07-20  Hans-Peter Nilsson  <hp@axis.com>
+
+	* config.sub: Update to subversions version 2000-07-06.
+
+2000-07-12  Andrew Haley  <aph@cygnus.com>
+
+	* configure.in (host_makefile_frag): Use mh-ia64pic on IA-64 hosts.
+	(target_makefile_frag): Use mt-ia64pic on IA-64 targets.
+
+2000-07-07  Phil Edwards  <pme@sourceware.cygnus.com>
+
+	* symlink-tree:  Check number of arguments.
+
+2000-06-06  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* texinfo/texinfo.tex: Update to version 2000-05-28.15.
+
+2000-07-05  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (CXX_FOR_TARGET): Add libstdc++ to the library
+	search path for a g++ extracted from the build tree.  This
+	will allow link tests run by configure scripts in
+	subdirectories to succeed.
+
+2000-07-01  Koundinya K  <kk@ddeorg.soft.net>
+
+	* ltconfig: Add support for mips-dde-sysv4.2MP
+
+2000-06-28  Corinna Vinschen  <vinschen@cygnus.com>
+
+	* ltconfig: Check for host_os beeing one of `cygwin', `mingw' or
+	`os2'. Force ac_cv_exeext to be ".exe" in that case.
+
+2000-06-19  Timothy Wall  <twall@cygnus.com>
+
+	* configure.in (noconfigdirs): Set noconfigdirs for tic54x target.
+	* config.sub: Add tic54x target.
+
+2000-06-07  Phillip Thomas  <pthomas@suse.de>
+
+	* README-maintainer-mode: New file: Contains notes on using
+	--enable-maintainer-mode with binutils.
+
+2000-05-29  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* texinfo/texinfo.tex: Update. Version from makeinfo 4.0.
+
+2000-05-30  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* config.sub: Import CVS version 1.167 Tue May 30 09:00:07 2000.
+	* config.guess: Import CVS version 1.148 Tue May 30 09:00:06 2000
+
+20000-05-21  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile.in (CC_FOR_TARGET): Make sure as/ld in the gcc
+	directory are used if they exist. Make sure
+	$(build_tooldir)/include is searched for header files,
+	$(build_tooldir)/lib/ for library files.
+	(GCC_FOR_TARGET): Likewise.
+	(CXX_FOR_TARGET): Likewise.
+
+2000-05-18  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (hppa*64*-*-*): Do build ld for this configuration.
+
+2000-05-17  Alexandre Oliva  <aoliva@cygnus.com>
+
+	* Makefile.in (configure-target-libiberty): Depend on
+	configure-target-newlib.
+
+2000-05-16  Alexandre Oliva  <aoliva@cygnus.com>
+
+	* configure.in, Makefile.in: Merge all libffi-related
+	configury stuff from the libgcj tree.
+
+2000-05-16  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	Thu Apr 27 11:01:48 2000 Andrew Cagney <cagney@b1.cygnus.com>:
+	* Makefile.in (do-tar-bz2, do-md5sum): Skip CVS directories.
+
+2000-05-16  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	Wed Apr 26 17:03:53 2000 Andrew Cagney <cagney@b1.cygnus.com>:
+	* Makefile.in (do-djunpack): New target. Update djunpack.bat with
+	current version information.  Add to proto-toplev directory.
+	(gdb-taz): Build do-djunpack.
+
+2000-05-15  David Edelsohn  <edelsohn@gnu.org>
+
+	* configure.in: Special case powerpc*-*-aix* target_makefile_frag.
+
+2000-05-13 Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* ltmain.sh: Preserve in relink_command any environment
+	variables that may affect the linker behavior.
+
+2000-05-12  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub (basic_machine): Recognize hppa64 as a valid cpu type.
+
+2000-05-10  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (ia64*-*-elf*): Add gdb and friends to noconfigdirs.
+
+2000-05-08  Eli Zaretskii  <eliz@is.elta.co.il>
+
+	* djunpack.bat: Change the Sed script to replace @V@ in fnchange.lst
+	with the version name.
+
+2000-05-01  Benjamin Kosnik  <bkoz@cygnus.com>
+
+	* config.if: Tweak.
+
+2000-04-23  Eli Zaretskii  <eliz@is.elta.co.il>
+
+	* djunpack.bat: New file.
+
+2000-04-19  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (taz, gdb-taz, gas.tar.bz2, binutils.tar.bz2,
+	gas+binutils.tar.bz2, libg++.tar.bz2, gnats.tar.bz2, gdb.tar.bz2,
+	dejagnu.tar.bz2, gdb+dejagnu.tar.bz2, insight.tar.bz2,
+	insight+dejagnu.tar.bz2, newlib.tar.bz2): Pass MD5PROG to sub-make.
+
+2000-04-16  Dave Pitts  <dpitts@cozx.com>
+
+	* config.sub (case $basic_machine): Change default for "ibm-*"
+	to "openedition".
+
+2000-04-12  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (gdb-taz): New target.  GDB specific archive.
+	(do-md5sum): New target.
+	(MD5PROG): Define.
+	(PACKAGE): Default to TOOL.
+	(VER): Default to a shell script.
+	(taz): Rewrite target.  Move real work to do-proto-toplev.  Include
+	md5 checksum generation.
+	(do-proto-toplev): New target. Create $(PACKAGE)-$(VER) link.
+	(do-tar-bz2): Delete creation of $(PACKAGE)-$(VER) link.
+	(gdb.tar.bz2, dejagnu.tar.bz2, gdb+dejagnu.tar.bz2,
+	insight.tar.bz2): Use gdb-taz to create archive.
+
+2000-04-07  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure (warn_cflags): Delete.
+
+2000-04-05  Benjamin Kosnik  <bkoz@cygnus.com>
+	    Martin v. Loewis  <martin@loewis.home.cs.tu-berlin.de>
+
+	* configure.in (enable_libstdcxx_v3): Add.
+	(target_libs): Add bits here to switch between libstdc++-v2 and
+	libstdc++-v3.
+	* config.if: And this file too.
+	* Makefile.in: Add libstdc++-v3 targets.
+
+2000-04-05  Michael Meissner  <meissner@redhat.com>
+
+	* config.sub (d30v): Add d30v as a basic machine type.
+
+2000-03-29  Jason Merrill  <jason@casey.cygnus.com>
+
+	* configure.in: -linux-gnu*, not -linux-gnu.
+
+2000-03-03  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (taz): Set PACKAGE to TOOL when not defined.
+	(do-tar-bz2): Replace TOOL with PACKAGE.
+	(gdb.tar.bz2): Remove GDBTK from GDB package.
+	(gdb+dejagnu.tar.bz2, insight.tar.bz2, insight+dejagnu.tar.bz2,
+	dejagnu.tar.bz2): New packages.
+
+2000-02-27  Andreas Jaeger  <aj@suse.de>
+
+	* configure.in: Add entry for mips*-*-linux*, move catch all
+	*-*-*linux* entry below this one.
+
+2000-02-27  Ian Lance Taylor  <ian@zembu.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.3.4.
+
+2000-02-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Support an OS of "wince".
+
+2000-02-24  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* config.guess, config.sub: Updated to match config's 2000-02-15
+	version.
+
+2000-02-23  Linas Vepstas <linas@linas.org>
+
+	* config.sub: Add support for Linux/IBM 370.
+	* configure.in: Likewise.
+
+2000-02-22  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add mips-pe, sh-pe and arm-wince-pe targets.
+
+2000-02-20  Christopher Faylor <cgf@cygnus.com>
+
+	* config.guess: Guess "cygwin" rather than "cygwin32".
+
+2000-02-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>
+
+	* configure (gcc_version): When setting, narrow search to
+	lines containing `version_string'.
+
+2000-02-15  Denis Chertykov  <denisc@overta.ru>
+
+	* config.sub: Add support for avr target.
+
+2000-02-01  Hans-Peter Nilsson  <hp@bitrange.com>
+
+	* config.sub: Add mmix-knuth-mmixware.
+
+2000-01-27  Christopher Faylor <cgf@redhat.com>
+
+	* Makefile.in (CC_FOR_TARGET): Add new winsup directory
+	structure stuff to -L library search.
+	(CXX_FOR_TARGET): Ditto.
+	(CROSS_CHECK_MODULES): Fix spelling mistake.
+
+2000-01-24  Mark Mitchell  <mark@codesourcery.com>
+
+	* Makefile.in (CXX_FOR_TARGET): Use g++, not xgcc, to invoke
+	the C++ compiler.
+
+2000-01-12  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: Don't build some bits for beos.
+
+2000-01-12  Joel Sherrill (joel@OARcorp.com)
+
+	* Makefile.in (CC_FOR_TARGET): Use newlib libraries as well
+	as include files.
+
+2000-01-06  Geoff Keating  <geoffk@cygnus.com>
+
+	* configure.in: Use mt-aix43 to handle *_TARGET defs,
+	not mh-aix43.
+
+1999-12-14  Richard Henderson  <rth@cygnus.com>
+
+	* config.guess (alpha-osf, alpha-linux): Detect ev67.
+	* config.sub: Accept alphaev[78], alphaev8.
+
+1999-12-03  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>
+
+	* config.guess, config.sub: Update from autoconf.
+
+Tue Nov 23 00:57:41 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* config-ml.in (sparc*-*-*): Disable sparcv9 support if the
+	necessary libraries are missing.
+
+1999-10-25  Andreas Schwab  <schwab@suse.de>
+
+	* configure: Fix quoting inside arguments of eval.
+
+1999-10-21  Nick Clifton  <nickc@cygnus.com>
+
+	* config-ml.in: Allow suppression of some ARM multilibs.
+
+Tue Sep  7 23:33:57 1999  Linas Vepstas  <linas@linas.org>
+
+	* config.guess: Add OS/390 match pattern.
+	* config.sub: Add mvs, openedition targets.
+	* configure.in (i370-ibm-opened*): New.
+
+1999-09-04  Steve Chamberlain  <sac@pobox.com>
+
+	* config.sub: Add support for configuring for pj.
+
+1999-08-31  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub (maybe_os): Add support for configuring for fr30.
+
+1999-08-25  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Do not configure or build ld for AIX
+	platforms.  ld is known to be broken on these platforms.
+
+Wed Aug 25 01:12:25 1999  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>
+
+	* config-ml.in: Pass compiler flag corresponding to multidirs to
+	subdir configures.
+
+1999-08-09  Ian Lance Taylor  <ian@zembu.com>
+
+	* Makefile.in (LDFLAGS): Define.
+
+1999-08-08  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* configure.in (i[3456]-*-mingw32*): Don't put gprof in
+	noconfigdirs.
+	(*-*-cygwin*): Likewise.
+
+1999-08-08  Ian Lance Taylor  <ian@zembu.com>
+
+	* mkdep: New file.
+	* Makefile.in (GAS_SUPPORT_DIRS): Add mkdep.
+	(BINUTILS_SUPPORT_DIRS): Add mkdep.
+
+	From Eli Zaretskii <eliz@is.elta.co.il>:
+	* configure (tmpfile): Change cONf$$ to cNf$$ to avoid an overly
+	long file name when using DJGPP on MS-DOS.
+
+Wed Aug  4 02:07:14 1999  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub (vxworks case): Use os=-vxworks, not os=vxworks.
+
+1999-07-30  Alan Modra  <alan@spri.levels.unisa.edu.au>
+
+	* Makefile.in (check-target-libio): Remove all-target-libstdc++
+	dependency as this causes "make check" to globally "make all"
+
+Tue Jun 22 23:45:18 1999  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in (target_libs): Added target-zlib.
+	* Makefile.in (ALL_TARGET_MODULES): Added zlib.
+	(CONFIGURE_TARGET_MODULES): Likewise.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(configure-target-zlib): New target.
+	(all-target-zlib): Likewise.
+	(all-target-libjava): Depend on all-target-zlib.
+	(configure-target-libjava): Depend on configure-target-zlib.
+
+	* Makefile.in (configure-target-libjava): Depend on
+	configure-target-newlib.
+	(configure-target-boehm-gc): New target.
+	(configure-target-qthreads): New target.
+
+	* configure.in (target_libs): Added target-qthreads.
+	* Makefile.in (ALL_TARGET_MODULES): Added qthreads.
+	(CONFIGURE_TARGET_MODULES): Likewise.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(all-target-qthreads): New target.
+	(configure-target-libjava): Depend on configure-target-qthreads.
+	(all-target-libjava): Depend on all-target-qthreads.
+
+	* Makefile.in (ALL_TARGET_MODULES): Added libjava, boehm-gc.
+	(CONFIGURE_TARGET_MODULES): Likewise.
+	(CHECK_TARGET_MODULES): Likewise.
+	(INSTALL_TARGET_MODULES): Likewise.
+	(CLEAN_TARGET_MODULES): Likewise.
+	(all-target-libjava): New target.
+	(all-target-boehm-gc): Likewise.
+	* configure.in (target_libs): Added libjava, boehm-gc.
+
+1999-07-22  Ian Lance Taylor  <ian@zembu.com>
+
+	* Makefile.in (binutils.tar.bz2): Don't pass makeall.bat and
+	configure.bat in SUPPORT_FILES.
+	(gas+binutils.tar.bz2): Likewise.
+
+	* makeall.bat: Remove; obsolete.
+
+1999-07-21  Ian Lance Taylor  <ian@zembu.com>
+
+	From Mark Elbrecht:
+	* configure.bat: Remove; obsolete.
+
+1999-07-11  Ian Lance Taylor  <ian@zembu.com>
+
+	* configure: Add -W -Wall to the default CFLAGS when compiling with
+	gcc.
+
+Thu Jul  8 12:32:23 1999  John David Anglin <dave@hiauly1.hia.nrc.ca>
+
+	* configure.in: Build ld, binutils & gas for hppa*-*-linux-gnu*.
+
+1999-06-30  Mark Mitchell  <mark@codesourcery.com>
+
+	* configure.in: Build ld on IRIX6.
+
+1999-06-12  Ian Lance Taylor  <ian@zembu.com>
+
+	* Makefile.in: Change distribution targets to use bzip2 instead of
+	gzip.
+	(TEXINFO_SUPPORT): Set to just texinfo/texinfo.tex.
+	(taz): Don't use texinfo/gpl.texinfo or texinfo/lgpl.texinfo.
+
+1999-06-04  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Add mcore target.
+
+1999-05-30  Cort Dougan  <cort@cs.nmt.edu>
+
+	* config.guess (ppc-*-linux-gnu): Also use ld emul elf32ppclinux.
+
+1999-05-25  H.J. Lu  (hjl@gnu.org)
+
+	* config.guess (dummy): Changed to $dummy.
+
+1999-05-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Tidied up case statements.
+
+1999-05-22  Ben Elliston  <bje@cygnus.com>
+
+	* config.guess: Handle NEC UX/4800. Contributed by Jiro Takabatake
+	<jiro@din.or.jp>.
+
+	* config.guess: Merge with FSF version. Future changes will be
+	more accurately recorded in this ChangeLog.
+	* config.sub: Likewise.
+
+1999-05-20   Stephen L Moshier  <moshier@world.std.com>
+
+	 * Makefile.in (GCC_FOR_TARGET): Add -I$(build_tooldir)/include.
+
+1999-04-30  Tom Tromey  <tromey@cygnus.com>
+
+	* ltmain.sh: [mode link] Always use CC given by ltconfig.
+
+1999-04-23  Tom Tromey  <tromey@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2f.
+
+1999-04-20  Drew Moseley  <dmoseley@cygnus.com>
+
+	* configure.in (noconfigdirs): Don't build libstub for arm-elf targets.
+	(noconfigdirs): Don't build any bsp stuff for for arm-oabi targets.
+	Bad merge removed these two changes.
+
+Tue Apr 13 22:50:54 1999  Donn Terry (donn@interix.com)
+			  Martin Heller (Ing.-Buero_Heller@t-online.de)
+
+	* config.guess (interix Alpha): Add.
+
+1999-04-11  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in (i?86-*-beos*): Do config gperf; don't config
+	gdb, newlib, or libgloss.
+
+1999-04-11  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* config-ml.in: On mips*-*-*, if multidirs contains mabi=64, try to
+	link a trivial program with -mabi=64.  If it fails, remove mabi=64
+	from multidirs.
+
+1999-04-10  Philipp Thomas  (kthomas@gwdg.de)
+
+	* config.sub: Set basic_machine to i586 when target_alias = k6-*.
+
+1999-04-08  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Add support for mcore targets.
+
+1999-04-07  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*): Use config/mt-d30v as makefile fragment,
+	not mt-ospace, in order to shut up assembler warning about using
+	symbols that are named the same as registers.
+
+1999-04-07  Drew Moseley  <dmoseley@cygnus.com>
+
+	* Makefile.in (all-target-cygmon): Added all-target-bsp to the
+	dependency list for all-target-cygmon.
+
+1999-04-05  Doug Evans  <devans@casey.cygnus.com>
+
+	* config-ml.in: Check $host, not $target, for selective multilibs.
+	(arm-*-*): Allow disabling of biendian, h/w fp, 26 bit apcs,
+	thumb interworking, and underscore prefix multilibs.
+
+1999-04-04  Ian Lance Taylor  <ian@zembu.com>
+
+	* missing: Update to version from current automake.
+
+Fri Apr  2 15:11:32 1999  H.J. Lu  (hjl@gnu.org)
+
+	* configure (gxx_include_dir): Removed.
+
+	* configure.in (gxx_include_dir): Handle it.
+	* Makefile.in: Likewise.
+
+1999-03-29  Gavin Romig-Koch  <gavin@cygnus.com>
+
+	* config.sub (mips64vr4111,mips64vr4111el) Add.
+
+1999-03-21  Ben Elliston  <bje@cygnus.com>
+
+	* config.guess: Correct typo for detecting ELF on FreeBSD.
+
+Thu Mar 18 00:17:50 1999  Mark Elbrecht <snowball3@usa.net>
+
+	* configure.in (pc-msdosdjgpp): Set host_makefile_frag to
+	config/mh-djgpp.
+
+Thu Mar 11 18:37:23 1999  Drew Moseley  <dmoseley@cygnus.com>
+
+	* Makefile.in (all-target-bsp): Added all-gcc all-binutils and
+	all-target-newlib to dependency list for all-target-bsp.
+
+Thu Mar 11 01:19:31 1999  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* config.sub: Add i386-uwin support.
+	* config.guess: Likewise.
+
+Thu Mar 11 01:07:55 1999  Franz Sirl <Franz.Sirl-kernel@lauterbach.com>
+
+	* configure.in: cleanup, add mh-*pic handling for arm, special
+	case powerpc*-*-aix*
+
+Wed Mar 10 18:35:07 1999  Jeff Johnston  <jjohnstn@cygnus.com>
+
+	* configure.in (noconfigdirs): Removed target-libgloss so libnosys.a
+	can be built.
+
+Wed Mar 10 17:39:09 1999  Drew Moseley  <dmoseley@cygnus.com>
+
+	* configure.in: Added bsp support to arm-*-coff and arm-*-elf
+	targets.
+
+1999-03-02  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Rename CYGNUS LOCAL to EGCS LOCAL
+
+1999-02-28  Geoffrey Noer  <noer@cygnus.com>
+
+	* config.sub: Check for "cygwin*" rather than "cygwin32*"
+
+1999-02-24  Nick Clifton  <nickc@cygnus.com>
+
+	* config.sub: Fix typo in arm recognition.
+
+1999-02-24  Drew Moseley  <dmoseley@cygnus.com>
+
+	* configure.in (noconfigdirs): Changed target_configdirs to
+	include target-bsp only for m68k-*-elf* and m68k-*-coff*
+	rather than m68k-*-* since it is not known to work on
+	m68k-aout. Ditto for arm-*-*oabi.
+
+1999-02-24  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* configure.in (*-*-windows*): Remove, no longer used.
+
+1999-02-19  Ben Elliston <bje@cygnus.com>
+
+	* config.guess: Automatically recognise ELF on FreeBSD. From Niall
+	Smart and improved by Andrew Cagney.
+
+1999-02-18  Marc Espie <espie@cvs.openbsd.org>
+
+	* config.guess: Recognize openbsd-*-hppa.
+
+1999-02-17  H.J. Lu  (hjl@gnu.org)
+
+	* Makefile.in (REALLY_SET_LIB_PATH): Append $$$(RPATH_ENVVAR)
+	only if it is not empty.
+
+1999-02-17  Nick Clifton  <nickc@cygnus.com>
+
+	Patch from: Scott Bambrough <scottb@corelcomputer.com>
+
+	* config.guess: Modified to recognize uname's armv* syntax.
+
+	* config.sub: Modified to recognize uname's armv* syntax.
+
+1999-02-17  Mark Salter  <msalter@cygnus.com>
+
+	* configure.in: Added target-bsp for sparclite.
+
+1999-02-08  Richard Henderson  <rth@cygnus.com>
+
+	* config.sub: Recognize alphapca5[67] and up to alphaev8.
+
+1999-02-08  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add support for strongarm port.
+	* config.sub: Add support for strongarm target.
+
+1999-02-07  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* configure.in (*-*-cygwin32*): Use config/mh-cygwin instead of
+	the old name config/mh-cygwin32.
+	Enable texinfo.
+
+1999-02-04  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Do build ld for ix86 Solaris.
+
+1999-02-02  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS):  Set AR to $AR instead of
+	$AR_FOR_TARGET.  Likewise for RANLIB.
+
+1999-02-02  Catherine Moore  <clm@cygnus.com>
+
+	* config.sub (oabi):  Recognize.
+	* configure.in (arm-*-oabi):  Handle.
+
+1999-01-30  Robert Lipe  (robertlipe@usa.net)
+
+	* config.guess: Improve detection of i686 on UnixWare 7.
+
+1999-01-30  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* config.guess: Add support for i386-pc-interix.
+	* config.sub: Likewise.
+	* configure.in: Likewise.
+
+1999-01-18  Christopher Faylor <cgf@cygnus.com>
+
+	* Makefile.in: Remove unneeded all-target-libio from
+	from all-target-winsup target since it is now unneeded.
+	Add all-target-libtermcap in its place since it is now
+	needed.
+
+1998-12-30  Christopher Faylor <cgf@cygnus.com>
+
+	* configure.in: makefile stub for cygwin target is probably
+	unnecessary.  Remove it for now.
+
+1998-12-30  Christopher Faylor <cgf@cygnus.com>
+
+	* configure.in: libtermcap.a should be built when cygwin is the
+	target as well as the host.
+	* config.guess: Allow mixed case in cygwin uname output.
+	* Makefile.in: Add libtermcap target.
+
+1998-12-23  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Clean up handling of hppa2.0.
+
+1998-12-22  Rodney Brown  (rodneybrown@pmsc.com)
+
+	* config.guess: Use C code to identify more HP machines.
+
+Thu Dec 17 01:22:30 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Handle hppa2.0.
+
+Tue Dec 15 17:02:58 1998  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in: Add cygmon for x86-coff and x86-elf. Configure
+	cygmon for all sparclite targets, regardless of object format.
+
+1998-12-15  Mark Salter  <msalter@cygnus.com>
+
+	* configure.in: Added target-bsp for several target architectures.
+
+	* Makefile.in: Added rules for bsp.
+
+Fri Dec  4 01:34:02 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Improve detection of hppa2.0 processors.
+
+Fri Dec  4 01:33:05 1998  Niall Smart <nialls@euristix.ie>
+
+	* config.guess: Recognize FreeBSD using ELF automatically.
+
+1998-11-26  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (skip-this-dir): Add handling for new shell script, which
+	might be created by a sub-directory's configure to indicate, this particular
+	directory is "unwanted".
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): Likewise.
+
+Wed Nov 18 18:28:45 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* ltconfig: import from libtool, after changing libtool to
+	account for the cygwin name change.
+
+Wed Nov 18 18:09:14 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: CC_FOR_TARGET and CXX_FOR_TARGET should also
+	include newlib/libc/sys/cygwin and newlib/libc/sys/cygwin32.
+
+Wed Nov 18 20:13:29 1998  Christopher Faylor <cgf@cygnus.com>
+
+	* configure.in: Add libtermcap to list of cygwin dependencies.
+
+1998-11-17  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: modify CC_FOR_TARGET and CXX_FOR_TARGET so that
+	they include winsup/include when it's a cygwin target.
+
+1998-11-12  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in (host_tools): Added zip.
+	* Makefile.in (all-target-libjava): Depend on all-zip.
+	(all-zip): New target.
+	(ALL_MODULES): Added all-zip.
+	(NATIVE_CHECK_MODULES): Added check-zip.
+	(INSTALL_MODULES): Added install-zip.
+	(CLEAN_MODULES): Added clean-zip.
+
+1998-11-12  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: lose "32" from comment about cygwin.
+
+1998-11-05  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Use -Os to build target libraries for the fr30.
+
+1998-11-04  Dave Brolley  <brolley@cygnus.com>
+
+	* config.sub: Add fr30.
+
+1998-11-02  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: drop "32" from config/mh-cygwin32.  Check
+	cygwin* instead of cygwin32*.
+	* config.sub: Check cygwin* instead of cygwin32*.
+
+1998-10-22  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: Match any version of Unixware7.
+
+1998-10-20  Syd Polk  <spolk@cygnus.com>
+
+	* Makefile.in configure.in: Add the ability to use tcl8.1 and tk8.1
+	if desired.
+
+1998-10-18  Jeffrey A Law  (law@cygnus.com)
+
+	* config.if (cxx_interface, libstdcxx_interface): Do not try to set
+	these if the appropriate directories and files to not exist.
+
+1998-10-14  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (DEVO_SUPPORT): Add config.if.
+
+1998-10-13  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure: Add pattern to replace "build_tooldir"'s
+	definition in the generated Makefile with "tooldir"'s
+	actual value.
+
+Tue Oct 13 09:17:06 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Bring back lost sparcv9.
+
+	* Makefile.in (all-snvavigator): Remove all-flexlm dependency.
+
+Mon Oct 12 12:09:44 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (CHILL_FOR_TARGET): Mirror recent changes to
+	CC_FOR_TARGET and friends.
+
+Mon Oct 12 12:09:30 1998  Alexandre Oliva  <oliva@dcc.unicamp.br>
+
+	* Makefile.in (build_tooldir): New variable, same as tooldir.
+	(CC_FOR_TARGET, GCC_FOR_TARGET, CXX_FOR_TARGET): Add
+	-B$(build_tooldir)/bin/.
+	(BASE_FLAGS_TO_PASS): Pass build_tooldir down.
+
+Wed Sep 30 22:20:50 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.sub: Add support for i[34567]86-pc-udk.
+	* configure.in: Likewise.
+
+Wed Sep 30 19:23:48 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: add bzip2 package building bits for user
+	tools module
+	* configure.in: ditto
+
+Wed Sep 30 03:00:05 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS): Add libobjc.
+	(ALL_TARGET_MODULES): Add all-target-libobjc.
+	(CONFIGURE_TARGET_MODULES, CHECK_TARGET_MODULES): Similarly.
+	(INSTALL_TARGET_MODULES, CLEAN_TARGET_MODULES): Similarly.
+	(all-target-libchill): Add dependencies.
+	* configure.in (target_libs): Add libchill.
+
+1998-09-30  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure.in (target_subdir): Remove duplicate line.
+
+Tue Sep 29 22:45:41 1998  Felix Lee  <flee@cygnus.com>
+
+	* Makefile.in (all-automake): fix dependencies.
+
+Mon Sep 28 04:04:27 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Minor cleanups for building in the $(target_alias)
+	subdir.
+
+1998-09-22  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (bootstrap): Set r and s before make all.  Use
+	BASE_FLAGS_TO_PASS in make all.
+	(cross): Likewise.
+
+1998-09-20  Mark Mitchell  <mark@markmitchell.com>
+
+	* Makefile.in (bootstrap): Pass TARGET_FLAGS_TO_PASS to `make all'.
+
+Sun Sep 20 00:13:02 1998  Richard Henderson  <rth@cygnus.com>
+
+	* config.sub: Fix typo in last change.
+
+1998-09-19  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>
+
+	* config.sub: Add support for C4x target.
+	* configure.in: Likewise.
+
+1998-09-13  David S. Miller  <davem@pierdol.cobaltmicro.com>
+
+	* config.sub: Recognize sparcv9 just like sparc64.
+
+Wed Sep  9 15:44:52 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: Match "Pent II" or "PentII" for OpenServer.
+
+Tue Sep  8 01:18:39 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Correctly identify Pentium II sco boxes.
+
+	* config.guess: Fix "tr" code.  From Weiwen Liu.
+
+Sat Sep  5 13:56:52 1998  John Hughes  <john@Calva.COM>
+
+	* configure.in: Do not assume x86-svr4 or x86-unixware can handle
+	stabs.
+
+Sat Sep  5 02:12:02 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS): Add libchill.
+	(ALL_TARGET_MODULES): Add all-target-libchill.
+	(CONFIGURE_TARGET_MODULES, CHECK_TARGET_MODULES): Similarly.
+	(INSTALL_TARGET_MODULES, CLEAN_TARGET_MODULES): Similarly.
+	(all-target-libchill): Add dependencies.
+	* configure.in (target_libs): Add libchill.
+
+Sun Aug 30 22:27:02 1998  Lutz Wohlrab <lutz.wohlrab@informatik.tu-chemnitz.de>
+
+	* config.guess: Avoid assumptions about "tr" behaves when
+	LANG is set to something other than English.
+
+Sun Aug 30 22:14:44 1998  H.J. Lu  (hjl@gnu.org)
+
+	* configure (gxx_include_dir): Changed to
+	'${prefix}/include/g++'-${libstdcxx_interface}.
+
+	* config.if: New to determine the interfaces.
+
+Sun Aug 30 21:15:19 1998  Mark Klein (mklein@dis.com)
+
+	* config.guess: Detect and handle MPE/IX.
+	* config.sub: Deal with MPE/IX.
+
+Sat Aug 29 14:32:55 1998  David Edelsohn  <edelsohn@mhpcc.edu>
+
+	* configure.in: Use mh-aix43.
+
+1998-07-29  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure: Fix --without/--disable cases for gxx-include-dir.
+
+Fri Aug 28 12:28:26 1998  Per Bothner  <bothner@cygnus.com>
+
+	* mdata-sh:  Imported.  Needed for automake support.
+
+Thu Aug 13 12:49:29 1998  H.J. Lu  <hjl@gnu.org>
+
+	* Makefile.in (taz): Try "chmod -R og=u ." before
+	"chmod og=u `find . -print`".
+
+Fri Jul 31 09:38:33 1998  Catherine Moore  <clm@cygnus.com>
+
+	* configure.in: Add arm-elf and thumb-elf support.
+
+Mon Jul 27 16:23:58 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* Makefile.in: Undo previous patch.
+
+Fri Jul 24 19:55:24 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* Makefile.in (INSTALL_TARGET): Move EXTRA_TARGET_HOST_INSTALL_MODULES
+	to here ...
+	(install-no-fixedincludes): and here
+	(INSTALL_MODULES): ... from here.
+
+Fri Jul 24 17:01:42 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with FSF.
+
+	* config.guess: Merge with FSF.
+
+Fri Jul 24 08:43:36 1998  Doug Evans  <devans@canuck.cygnus.com>
+
+	* configure (extraconfigdirs): New variable.
+	(SUBDIRS): Add extraconfigdirs and recurse on them too.
+	* Makefile.in (all): Move higher in file.
+	(EXTRA_TARGET_HOST_ALL_MODULES): New variable.
+	(EXTRA_TARGET_HOST_{INSTALL,CHECK}_MODULES): New variables.
+	(ALL_MODULES): Add EXTRA_TARGET_HOST_ALL_MODULES.
+	(CROSS_CHECK_MODULES): Add EXTRA_TARGET_HOST_CHECK_MODULES.
+	(INSTALL_MODULES): Add EXTRA_TARGET_HOST_INSTALL_MODULES.
+
+1998-07-23  Brendan Kehoe  <brendan@cygnus.com>
+
+	* Makefile.in (all-target-libjava): Depend on all-gcc and
+	all-target-newlib.
+	(configure-target-libjava): Depend on $(ALL_GCC).
+
+Sat Jul 18 14:32:43 CDT 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: (*-pc-sco3.2v5) Add detection for Pentium II.
+	(*-pc-unixware7) Add detection for Pentium II, Pentium Pro.
+
+Fri Jul 17 13:30:18 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ylwrap: Change absolute path checks to check for DOS style path
+	names.
+
+	* ylwrap: Don't use a full path name if the source file is in the
+	same directory.  From hjl@lucon.org (H.J. Lu).
+
+	* config-ml.in: Default to being verbose, to match Feb 18 change to
+	configure.
+
+Thu Jul 16 12:29:51 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	Brought over from egcs:
+
+	Sat Jun 27 22:46:32 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (target_subdir): Set to ${target_alias} instead
+	of "libraries".
+
+	Mon Sep  1 16:45:44 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (target_subdir): Set to libraries if enable_multilib.
+
+Wed Jul 15 01:00:54 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): If there are any
+	multilibs, force reconfiguration the first time we create
+	multilib.out in a subdirectory, in case TARGET_SUBDIR is `.'.
+
+Tue Jul 14 23:41:03 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Strip any --no option from CONFIG_ARGUMENTS, to
+	avoid confusion with --no-recursion.
+
+Tue Jul 14 15:37:41 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: Win32 hosts shouldn't use install -x
+	* install-sh: remove -x option, and special .exe-handling
+	hack.
+
+Tue Jul 14 15:28:41 1998  Richard Henderson  <rth@cygnus.com>
+
+	* config.guess: Recognize i586-pc-beos.
+	* configure.in: Don't build some bits for beos.
+
+Tue Jul 14 13:22:18 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If CC is set but CFLAGS is not, and CC is gcc, make
+	CFLAGS default to -O2.
+
+	* ltmain.sh: Add some hacks to make SunOS --enable-shared work
+	when using GNU ld.
+
+Fri Jul 10 13:18:23 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltmain.sh: Correct install when using a different shell.
+
+Tue Jul  7 15:24:38 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2b.
+
+Thu Jul  2 13:57:36 1998  Klaus Kaempf  <kkaempf@rmi.de>
+
+	* makefile.vms: Update to build binutils/makefile.vms.  Add install
+	target.
+
+Wed Jul  1 16:45:21 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig: Update to correct AIX handling.
+
+Sat Jun 27 22:46:32 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Add TARGET_SUBDIR.
+
+	* configure.in (target_subdir): Set to ${target_alias} instead
+	of "libraries".
+
+1998-06-26  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Add gcc_version_trigger.
+	(Makefile): Depend on $(gcc_version_trigger).
+
+	* configure (gcc_version): Change default initializer to empty
+	string.
+	(gcc_version_trigger): New variable; pass this variable down
+	to subdir configures to enable them checking gcc's version
+	themselves. Emit make macros for both gcc_version vars.
+	(topsrcdir): Initialize reliably.
+	(recursion line): Remove --with-gcc-version=${gcc_version}.
+
+1998-06-24  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (enable_version_specific_runtime_libs): Implement new flag
+	--enable-version-specific-runtime-libs which installs C++ runtime stuff
+	in $(libsubdir); emit definition in each generated Makefile.
+	(gxx_include_dir): Initialize depending on
+	$enable_version_specific_runtime_libs.
+
+1998-06-24  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (gcc_version): Initialize properly depending on
+	how and where configure is started.
+	(recursion line): Pass a --with-gcc-version=${gcc_version}
+	to configures in subdirs.
+
+Wed Jun 24 16:01:59 1998  John Metzler  <jmetzler@cygnus.com>
+
+	* configure.in (noconfigdirs): Add configure pattern for mips tx39
+	cygmon
+
+Tue Jun 23 22:42:32 1998  Mark Alexander  <marka@cygnus.com>
+
+	* configure.in: Add cygmon and libstub support for mn10200.
+
+1998-06-19  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (gcc_version): Add new variable describing the
+	particular gcc version we're building.
+	* Makefile.in (libsubdir): Add new macro for the directory
+	in which the compiler finds executables, libraries, etc.
+	(BASE_FLAGS_TO_PASS): Pass down gcc_version, target_alias
+	and libsubdir.
+
+Fri Jun 19 02:36:59 1998  Alexandre Oliva <oliva@dcc.unicamp.br>
+
+	* Makefile.in (local-clean): Remove *.log.
+	(warning.log): Built with warn_summary from build.log.
+	(mail-report.log): Run test_summary.
+	(mail-report-with-warnings.log): Run test_summary including
+	warning.log in the report.
+
+Thu Jun 18 11:26:03 1998  Robert Lipe  <robertl@dgii.com>
+
+	* config.guess: Detection of Pentium II for *-sco-3.2v5*.
+
+Mon Jun 15 14:53:54 1998  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (grep): Grep no longer depends on libiberty.
+
+Fri Jun 12 14:03:34 1998  Syd Polk  <spolk@cygnus.com>
+
+	* Makefile.in: all-snavigator needs all-libgui.
+
+Thu Jun 11 19:43:47 1998  Mark Alexander  <marka@cygnus.com>
+
+	* configure.in: Add cygmon and libstub support for mn10300.
+
+Wed Jun 10 11:19:47 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* missing: Update to version from automake 1.3.
+
+	* ltmain.sh: On installation, don't get confused if the same name
+	appears more than once in the list of library names.
+
+Wed Jun  3 14:51:42 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Accept m68060 and m5200 as CPU names.
+
+Mon Jun  1 17:25:16 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Use && rather than using -a in test, because odd
+	strings can confuse test.
+	* configure.in: Likewise.
+
+Thu May 28 19:31:13 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Bring in Visual C++ support.
+
+Sat May 23 23:44:13 1998  Alexandre Oliva <oliva@dcc.unicamp.br>
+
+	* Makefile.in (boostrap2-lean, bootstrap3-lean,
+	bootstrap4-lean): New targets.
+
+Mon May 11 23:55:56 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* mpw-* Delete.  Not used.
+
+Mon May 11 23:11:34 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* COPYING.LIB: Update FSF address.
+
+Fri May  8 01:30:20 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2a.
+
+	* Makefile.in (GASB_SUPPORT_DIRS): Remove intl; already included via
+	GAS_SUPPORT_DIRS.
+
+Thu May  7 17:27:35 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Avoid producing a version number if
+	-version-info was not used.
+
+Tue May  5 18:02:24 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Add --with-newlib to CONFIG_ARGUMENTS if we are
+	building with newlib.
+
+1998-04-30  Paul Eggert  <eggert@twinsun.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Remove backslash at end;
+	Solaris `make' causes it to continue to next definition.
+
+Tue Apr 28 16:24:24 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* Makefile.in (install-gdbtk): Call this 'install-gdb' so that
+	the right GUI libraries and files are installed along with GDB.
+
+Tue Apr 28 18:11:24 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Change alpha to alpha* in several places.
+
+Tue Apr 28 07:42:00 1998  Mark Alexander  <marka@cygnus.com>
+
+	* config.sub: Recognize sparc86x.
+
+Tue Apr 28 07:35:02 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (--enable-target-optspace): Remove debug echo.
+
+Thu Apr 23 21:31:16 1998  Jim Wilson  <wilson@cygnus.com>
+
+	* configure: Set CXXFLAGS from CXXFLAGS, not CFLAGS.
+
+Thu Apr 23 12:26:38 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig: Update cygwin32 support.
+
+	* Makefile.in (GAS_SUPPORT_DIRS): Add intl.
+	(BINUTILS_SUPPORT_DIRS, GASB_SUPPORT_DIRS): Likewise.
+	(GDB_SUPPORT_DIRS): Likewise.
+
+Wed Apr 22 12:30:10 1998  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (target_makefile_frag): If --enable-target-optspace,
+	use -Os to compile target libraries rather than -O2.  Default to
+	using -Os for d10v and m32r if --{enable,disable}-target-optspace is
+	not used.
+	* configure.in (target_cflags): Ditto for d30v.
+
+Tue Apr 21 23:06:54 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (all-bfd): Depend on all-intl.
+	(all-binutils): Likewise.
+	(all-gas): Likewise.
+	(all-gprof): Likewise.
+	(all-ld): Likewise.
+
+1998-04-19  Brendan Kehoe  <brendan@cygnus.com>
+
+	* configure.in (host_tools): Fix typo, lbtool -> libtool.
+
+Fri Apr 17 16:20:42 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (all-bfd): Depend upon all-libiberty.
+
+	* ltconfig, ltmain.sh: Bring in newer cygwin32 support.
+
+Fri Apr 17 12:22:22 1998  Bob Manson  <manson@charmed.cygnus.com>
+
+	* Makefile.in: Add libstub.
+
+	* configure.in: Ditto. Build libstub for targets that have cygmon
+	support.
+
+Tue Apr 14 18:01:55 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't set PICFLAG on ix86-cygwin32.
+
+Tue Apr 14 12:24:45 1998  J. Kean Johnston  <jkj@sco.com>
+
+	* configure.in: Recognise i[3456]96-*-sysv5* as a valid host, and
+	use mh-sysv5 if specified.  Support gprof on SCO Open Server.
+
+Tue Apr 14 11:33:51 1998  Krister Walfridsson <cato@df.lth.se>
+
+	* configure: Define DEFAULT_M4 by searching PATH.
+	* Makfile.in: Use DEFAULT_M4.
+
+Mon Apr 13 15:37:24 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig: Add cygwin32 support.
+
+	* Makefile.in, configure.in: Add libtool as a native only directory
+	to configure and build.
+
+Sun Apr 12 20:58:46 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_MODULES): Remove texinfo.
+
+Wed Apr  8 13:18:56 1998  Philippe De Muyter  <phdm@macqel.be>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): XFOO lines shortened.
+
+Thu Apr  2 14:48:44 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: add ash make rules
+	* configure.in: add ash to native_only and host_tools lists
+
+Thu Mar 26 12:53:20 1998  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (all-gettext, all-intl): New targets.
+	(ALL_MODULES): Added all-gettext, all-intl.
+	(CROSS_CHECK_MODULES): Added check-gettext, check-intl.
+	(INSTALL_MODULES): Added install-gettext, install-intl.
+	(CLEAN_MODULES): Added clean-gettext, clean-intl.
+
+	* configure.in (host_tools): Added gettext.
+	(native_only): Likewise.
+	(noconfigdirs) [various cases]: Likewise.
+	(host_libs): Added intl.
+
+Thu Mar 26 15:00:11 1998  Keith Seitz  <keiths@onions.cygnus.com>
+
+	* configure: Do not disable building gdbtk for cygwin32 hosts.
+
+Wed Mar 25 10:04:18 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add thumb-coff target.
+	* config.sub: Add thumb-coff target.
+
+Wed Mar 25 11:49:12 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* Makefile.in: Revert yesterday's change.
+	(all-target-winsup):  all-target-librx stays out of here.
+
+Tue Mar 24 16:58:29 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS, ALL_TARGET_MODULES,
+	CONFIGURE_TARGET_MODULES, CHECK_TARGET_MODULES,
+	INSTALL_TARGET_MODULES, CLEAN_TARGET_MODULES, all-target-winsup):
+	Remove references to librx and libg++.
+
+Tue Mar 24 18:28:12 1998  Eric Mumpower  <nocturne@cygnus.com>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Pass $(lispdir) down to
+	recursive makes
+
+Tue Mar 24 11:37:45 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET): Use $(TARGET_SUBDIR) when passing -B
+	for newlib directory.
+	(CXX_FOR_TARGET): Likewise.
+
+Mon Mar 23 11:30:21 1998  Jeffrey A Law  (law@cygnus.com)
+
+	* ltconfig: Update after libtool/ltconfig.in change for
+	hpux11.
+
+Fri Mar 20 18:51:43 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update to libtool 1.2.
+
+Fri Mar 20 09:32:14 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (install-gcc): Don't specify LANGUAGES here.
+	(install-gcc-cross): Instead, override LANGUAGES here.
+
+1998-03-18  Dave Love  <d.love@dl.ac.uk>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): Set CONFIG_SITE to a
+	non-existent file since /dev/null loses with bash 2.0/autoconf 2.12.
+
+Wed Mar 18 09:24:59 1998  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in: Add Thumb-pe target.
+
+Tue Mar 17 16:59:00 1998  Syd Polk <spolk@cygnus.com>
+
+	* Makefile.in - changed sn targets to snavigator
+	* configure.in - changed sn targets to snavigator
+
+Tue Mar 17 10:33:28 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* config-ml.in: After building symlink tree call make distclean
+	if a Makefile got linked into ${ml_dir}/${ml_libdir}; this happens
+	to be the case for libiberty.
+
+Tue Mar 17 10:22:37 1998  H.J. Lu  (hjl@gnu.ai.mit.edu)
+
+	* configure: When making link, also check the current
+	directory. The configure scripts may create one.
+
+Fri Mar  6 01:02:03 1998  Richard Henderson  <rth@cygnus.com>
+
+	* config.sub: Accept alphapca56 and alphaev6 properly.
+
+Fri Mar  6 00:14:55 1998  Franz Sirl <Franz.Sirl-kernel@lauterbach.com>
+
+	* configure.in: Revert 3 Jan change for powerpc-linux-gnulibc1.
+
+Mon Feb 23 15:09:18 1998  Bruno Haible <bruno@linuix.mathematik.uni-karlsruhe.de
+
+	* config.sub (sco5): Fix typo.
+
+Mon Feb 23 14:46:06 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_MODULES): Move install-tcl before
+	install-itcl.
+	(install-itcl): Remove dependency on install-tcl.
+
+Mon Feb 23 09:53:28 1998  Mark Alexander  <marka@cygnus.com>
+
+	* configure.in: Remove libgloss from noconfigdirs for MN10300.
+
+Thu Feb 19 13:40:41 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't build libgui for a cygwin32 target when not on
+	a cygwin32 host.
+
+Wed Feb 18 12:29:00 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* configure (redirect): Set to null, so default behavior of
+	configure is now --verbose.
+
+1998-02-16  Dave Love  <d.love@dl.ac.uk>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): Run configure with
+	CONFIG_SITE=/dev/null to forestall lossage with site configuration.
+
+Mon Feb 16 12:23:53 1998  Manfred Hollstein  <Manfred.Hollstein@ks.sel.alcatel.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS, EXTRA_TARGET_FLAGS): Really add
+	this change to sync Makefile.in with its ChangeLog entries.
+
+Thu Feb 12 15:03:08 1998  H.J. Lu  <hjl@gnu.org>
+
+	* ltmain.sh (mkdir): Check that the directory doesn't exist
+	before we exit with error, so that we don't get races during
+	parallel builds.
+
+Sat Feb  7 15:19:18 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update from libtool 1.0i.
+
+Fri Feb  6 01:33:52 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Don't pass PICFLAG and
+	PICFLAG_FOR_TARGET.
+	(EXTRA_TARGET_FLAGS): Don't pass PICFLAG_FOR_TARGET.
+
+	* configure: Emit a definition for the new macro enable_shared
+	into each Makefile.
+
+Thu Feb  5 17:01:12 1998  Jason Molenda  (crash@bugshack.cygnus.com)
+
+	* configure.in (host_tools, native_only): Add libtool.
+
+Wed Feb  4 16:53:58 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: add target-gperf to noconfigdirs for Cygwin32.
+	Fix typo in ming config comment.
+
+Wed Feb  4 18:56:13 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltconfig, ltmain.sh: Update from libtool 1.0h.
+
+Mon Feb  2 19:38:19 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Add tic30 cases, and map c30 to tic30.
+
+Sun Feb  1 02:40:41 1998  Richard Henderson  <rth@cygnus.com>
+
+	* Makefile.in (TARGET_CONFIGDIRS): Add libf2c.
+	(ALL_TARGET_MODULES, CONFIGURE_TARGET_MODULES): Similarly
+	(CHECK_TARGET_MODULES, INSTALL_TARGET_MODULES): Similarly
+	(CLEAN_TARGET_MODULES): Similarly
+	(all-target-libf2c): Add dependences.
+	* configure.in (target_libs): Add libf2c.
+
+Fri Jan 30 17:18:32 1998  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: Remove expect from noconfigdirs when target
+	is cygwin32.  OK to build expect and dejagnu with Canadian
+	Cross.
+
+Wed Jan 28 12:58:49 1998  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Do build expect, dejagnu, and cvssrc for a cygwin32
+	host.
+
+	* config.guess: Use ${UNAME_MACHINE} rather than i386 for cygwin32
+	and mingw32.
+
+Wed Jan 28 10:26:37 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Remove passing $(local_prefix)
+	here as it is not defined in the toplevel Makefile.
+
+Tue Jan 27 23:25:06 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (package_makefile_rules_frag): New variable, which names
+	a file with generic rules, ...
+	Change comment to mention we now have FIVE parts.
+	* configure: Undo last change.
+
+Tue Jan 27 23:15:55 1998  Lassi A. Tuura  <lat@iki.fi>
+
+	* config.guess: More accurate determination of HP processor types.
+	* config.sub: More accurate determination of HP processor types.
+
+Sat Jan 24 01:59:45 1998  Manfred Hollstein  <manfred@s-direktnet.de>
+
+	* configure (package_makefile_frag): Move inserting the
+	${package_makefile_frag} to where it should be according
+	to the comment.
+
+Fri Jan 23 00:29:28 1998  Philip Blundell  <pb@nexus.co.uk>
+
+	* config.guess: Add support for Linux/ARM.
+
+Thu Jan 22 15:14:01 1998  Fred Fish  <fnf@cygnus.com>
+
+	* .cvsignore: Remove *-info and *-install since they match
+	release-info and mpw-install, which we don't want to just ignore.
+
+Thu Jan 22 01:38:33 1998  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: Revert 3 Jan change for alpha-linux-gnulibc1.
+
+Sat Jan 17 21:28:08 1998  Pieter Nagel <pnagel@epiuse.co.za>
+
+	* Makefile.in (FLAGS_TO_PASS): Pass down gcc_include_dir and
+	local_prefix to sub-make invocations.
+
+Sat Jan 17 21:04:59 1998 H.J. Lu  (hjl@gnu.org)
+
+	* configure.in: Check makefile fragments in the source
+	directory.
+
+Fri Jan 16 00:41:37 1998  Alexandre Oliva <oliva@dcc.unicamp.br>
+
+	* configure.in: Check whether host and target makefile
+	fragments exist before adding them to *_makefile_frag.
+
+Wed Jan 14 23:39:10 1998  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in (target_configdirs): Add cygmon for sparc64-elf.
+
+Wed Jan 14 12:48:07 1998  Keith Seitz  <keiths@pizza.cygnus.com>
+
+	* configure.in: Make sure we only replace RPATH_ENVVAR on
+	lines which begin with RPATH_ENVVAR, i.e. add "^" to the
+	regexp to sed.
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Pass RRPATH_ENVVAR down
+	to sub-makes.
+
+1998-01-13  Lee Iverson   (leei@ai.sri.com)
+
+	* config-ml.in (multi-do): LDFLAGS must include multilib
+	designator.
+
+Tue Jan 13 01:13:24 1998   Robert Lipe (robertl@dgii.com)
+
+	* config.guess: Recognize i[3456]-i586-UnixWare7-sysv5.
+
+Sun Jan  4 01:06:55 1998  Mumit Khan  <khan@xraylith.wisc.edu>
+
+	* config.sub: Add mingw32 support.
+	* configure.in: Likewise.
+
+Sat Jan  3 12:11:05 1998 Franz Sirl <franz.sirl-kernel@lauterbach.com>
+
+	* configure.in: Finalize support for {alpha|powerpc}*-*-linux-gnulibc1
+
+Sun Dec 28 11:28:58 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_TARGET): Do install-gcc first.
+	* configure (gxx_include_dir): Provide a definition for subdirs
+	which do not use autoconf.
+
+Wed Dec 24 22:46:55 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Sync with egcs.  Picks up new alpha support,
+	BeOS & some additional linux support.
+
+Tue Dec 23 12:44:24 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: HP 9000/803 is a PA1.1 machine.
+
+Mon Dec 22 02:39:24 1997  Richard Henderson  <rth@cygnus.com>
+
+	* configure.in: It's alpha*-...
+
+Sun Dec 21 16:53:12 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)
+
+	* configure.in (host_makefile_frag, target_makefile_frag):
+	Handle multiple config files.
+	(alpha-*-linux*): Treat alpha-*-linux* as alpha-*-linux* and
+	alpha-*-*.
+
+Thu Dec 18 13:13:03 1997  Doug Evans  <devans@canuck.cygnus.com>
+
+	* mkdep: New file.
+
+Wed Dec 17 09:53:02 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Allow configuring of libide, vmake, etc.
+
+Tue Dec 16 17:36:05 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Add libgui directory.
+	(GDB_TK): Add all-libgui.
+	* configure.in: Add libgui directory.
+	* configure: Add all-libgui to GDB_TK.
+
+Mon Dec 15 16:12:28 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* config-ml.in (multidirs): Add m32r to multilib list.
+
+Fri Dec 12 10:43:31 1997  Brendan Kehoe  <brendan@canuck.cygnus.com>
+
+	* Makefile.in (all-target-gperf): Change dependency to
+	all-target-libstdc++.
+
+Thu Dec 11 23:30:51 1997  Fred Fish  <fnf@ninemoons.com>
+
+	* config.guess: Add BeOS support.
+
+Wed Dec 10 15:10:38 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	Source directory cvs renamed to cvssrc:
+	* configure.in (host_tools): Change cvs to cvssrc.
+	(native_only): Likewise.
+	(noconfigdirs) [various cases]: Likewise.
+	* Makefile.in (ALL_MODULES): Change all-cvs to all-cvssrc.
+	(CROSS_CHECK_MODULES): Change check-cvs to check-cvssrc.
+	(INSTALL_MODULES): Change install-cvs to install-cvssrc.
+	(CLEAN_MODULES): Change clean-cvs to clean-cvssrc.
+	(all-cvssrc): Rename target from all-cvs.
+
+Wed Dec  3 07:55:59 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* configure (gxx_include_dir): Fix thinko.
+
+Tue Dec  2 10:55:34 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_TARGET_CROSS): Define.
+	(install-cross, install-gcc-cross): New targets.
+
+Tue Dec  2 10:08:31 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (noconfigdirs): Add support for Thumb target.
+
+	* config.sub (maybe_os): Add support for Thumb target.
+
+Sun Nov 30 16:12:27 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* Makefile.in: Add rules for cygmon.
+
+	* configure.in: Build cygmon for sparc-elf and sparclite-aout.
+
+Thu Nov 27 01:31:30 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (INSTALL_TARGET): Do install-gcc first.
+	* configure (gxx_include_dir): Provide a definition for subdirs
+	which do not use autoconf.
+
+Wed Nov 26 11:53:33 1997  Keith Seitz  <keiths@onions.cygnus.com>
+
+	* Makefile.in, configure, configure.in, ChangeLog: merge with foundry's
+	11/18/97 build
+
+Wed Nov 26 16:08:50 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* From Franz Sirl.
+	* config.guess (powerpc*-*-linux): Handle glibc2 beta release
+	found on RedHat Linux systems.
+
+Fri Nov 21 09:51:01 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess (alpha stuff): Merge with FSF to avoid incorrect
+	guesses.
+
+Thu Nov 13 11:38:37 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (i[3456]86-ncr-sysv4.3*): Tweak.
+
+Mon Nov 10 15:23:21 1997  H.J. Lu  <hjl@gnu.ai.mit.edu>
+
+	* ltmain.sh: If mkdir fails, check whether the directory was created
+	anyhow by some other process.
+
+Mon Nov 10 14:38:03 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure all directories.
+
+Sun Nov  9 17:36:20 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure newlib, libiberty directories
+	for the D30V.
+
+Sat Nov  8 14:42:59 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure target-libgloss on the D30V.
+
+Fri Nov  7 10:34:09 1997  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* include/libiberty.h: Add extern "C" { so it can be used with C++
+	progrms.
+	* include/remote-sim.h:  Add extern "C" { so it can be used with C++
+	programs.
+
+Thu Oct 30 11:09:29 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (d30v-*-*): Configure GCC now.
+
+Mon Oct 27 13:17:24 1997  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* configure.in: Remove a "second pass" of tweaking noconfigdirs,
+	is no longer needed.
+
+Mon Oct 27 12:03:53 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in: check-target-libio depends on all-target-libstdc++.
+
+Sun Oct 26 11:48:27 1997  Manfred Hollstein  (manfred@s-direktnet.de)
+
+	* Makefile.in (bootstrap-lean): Combined with `normal' bootstrap
+	targets using "$@" to provide support for similar but not identical
+	targets without having to duplicate code.
+
+Mon Oct 20 15:28:49 1997  Klaus K"ampf  <kkaempf@progis.de>
+
+	* makefile.vms: Fix to work with DEC C.
+
+Tue Oct  7 23:58:57 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Add mips-tx39-elf to marketing names.
+
+Tue Oct  7 14:24:41 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltmain.sh: Handle symlinks in generated script.
+
+Wed Oct  1 13:11:27 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Handle autoconf style directory options: --bindir,
+	--datadir, --includedir, --infodir, --libdir, --libexecdir,
+	--mandir, --oldincludedir, --sbindir, --sharedstatedir,
+	--sysconfdir.
+	* Makefile.in (sbindir, libexecdir, sysconfdir): New variables.
+	(sharedstatedir, localstatedir, oldincludedir): New variables.
+	(BASE_FLAGS_TO_PASS): Pass down bindir, datadir, includedir,
+	infodir, libdir, libexecdir, localstatedir, mandir, oldincludedir,
+	sbindir, sharedstatedir, and sysconfdir.
+
+Mon Sep 29 00:38:08 1997 Aaron Jackson <jackson@negril.msrce.howard.edu>
+
+	* Makefile.in (bootstrap-lean): New target.
+
+Wed Sep 24 18:06:27 1997  Stu Grossman  <grossman@babylon-5.cygnus.com>
+
+	* configure.in (d30v):  Remove tcl, tk, expect, gdb, itcl, tix, db,
+	sn, and gnuserv from noconfigdirs.
+
+Wed Sep 24 15:18:32 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ltmain.sh: Tweak shell pattern to avoid bug in NetBSD /bin/sh.
+
+Thu Sep 18 23:58:27 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (cross): New target.
+
+Thu Sep 18 21:43:23 1997  Alexandre Oliva  <oliva@dcc.unicamp.br>
+			  Jeff Law	   <law@cygnus.com>
+
+	* Makefile.in (bootstrap2, bootstrap3): New targets.
+	(all-bootstrap): Remove outdated and confusing target.
+	(bootstrap, bootstrap2, bootstrap3): Don't pass BOOT_CFLAGS down.
+
+Thu Sep 18 15:37:42 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure (tooldir): enable_gdbtk=YES for cygwin32, NO for
+	windows.  Consistent with gdb/configure.
+
+1997-09-15 02:37  Ulrich Drepper  <drepper@cygnus.com>
+
+	* configure.in: Name Linux target fragment.
+
+	* configure: Rewrite so that project Makefile fragment is inserted
+	first and appears last in the resulting Makefile.
+
+Tue Sep 16 09:55:07 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (install-itcl): Install tcl first.
+
+Fri Sep 12 16:19:20 1997  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: remove bison from noconfigdirs for Cygwin32 host
+
+Thu Sep 11 16:40:46 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)
+
+	* Makefile.in (local-distclean): Also remove mh-frag mt-frag.
+
+	* configure.in (skipdirs): Add target-librx for Linux.
+	(alpha-*-linux*): Use config/mh-elfalphapic and config/mt-elfalphapic.
+
+Wed Sep 10 21:29:54 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* Makefile.in (bootstrap): New target.
+
+Wed Sep 10 15:19:22 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Accept 'amigados' for backward compatability.
+
+Mon Sep  8 20:46:20 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.guess: Merge with FSF.
+
+Sun Sep  7 23:18:32 1997  Fred Fish  <fnf@ninemoons.com>
+
+	* config.sub: Change 'amigados' to 'amigaos' to match current usage.
+
+Sun Sep  7 15:55:28 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Add "marketing-names" patch.
+
+Fri Sep  5 16:11:28 1997  Joel Sherrill  (joel@OARcorp.com)
+
+	* configure.in (*-*-rtems*): Do not build libgloss for rtems.
+
+Fri Sep  5 12:27:17 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Handle v850-elf.
+
+Wed Sep  3 22:01:58 1997  Fred Fish  <fnf@ninemoons.com>
+
+	* .cvsignore (*-install): Remove.
+
+Wed Sep  3 12:15:24 1997  Chris Provenzano  <proven@cygnus.com>
+
+	* ltconfig: Set CONFIG_SHELL in libtool.
+	* ltmain.sh: Use CONFIG_SHELL instead of /bin/sh
+
+Mon Sep  1 16:45:44 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (target_subdir): Set to libraries if enable_multilib.
+
+Wed Aug 27 16:15:11 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* config.guess: Update from gcc directory.
+
+Tue Aug 26 16:46:46 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (all-sim): Depends on all-readline.
+
+Wed Aug 20 19:57:37 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (BISON, YACC): Use $$s.
+	(all-bison): Depend on all-texinfo.
+
+Tue Aug 19 01:41:32 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (BISON): Add -L flag.
+	(YACC): Likewise.
+
+Mon Aug 18 11:30:50 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (noconfigdirs): Add support for v850e target.
+
+	* config.sub (maybe_os): Add support for v850e target.
+
+Mon Aug 18 11:30:50 1997  Nick Clifton  <nickc@cygnus.com>
+
+	* configure.in (noconfigdirs): Add support for v850ea target.
+
+	* config.sub (maybe_os): Add support for v850ea target.
+
+Mon Aug 18 09:24:06 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Add mipstx39.  Delete r3900.
+
+Mon Aug 18 17:20:10 1997  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* Makefile.in (all-autoconf): Depends on all-texinfo.
+
+Fri Aug 15 23:09:26 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* config-ml.in ({powerpc,rs6000}*-*-*): Update to current AIX and
+	eabi targets.
+
+Thu Aug 14 14:42:17 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Get CFLAGS and CXXFLAGS from Makefile, if possible.
+
+	* configure: When handling a Canadian Cross, handle YACC as well as
+	BISON.  Just set BISON to bison.  When setting YACC, prefer bison.
+	* Makefile.in (all-bison): Depend upon all-texinfo.
+
+Tue Aug 12 20:09:48 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (BISON): bison, not byacc or bison -y.
+	(YACC): bison -y or byacc or yacc.
+	(various): Add *-bison as appropriate.
+	(taz): No need to mess with BISON anymore.
+
+Tue Aug 12 22:33:08 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If OSTYPE matches *win32*, try to find a good value for
+	CONFIG_SHELL.
+
+Sun Aug 10 14:41:11 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (taz): Get the version number from AM_INIT_AUTOMAKE in
+	configure.in if it is present.
+
+Sat Aug  9 00:58:01 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (LD_FOR_TARGET): Change ld.new to ld-new.
+
+Fri Aug  8 16:30:13 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: Recognize `arc' cpu.
+	* configure.in: Likewise.
+	* config-ml.in: Likewise.
+
+Thu Aug  7 11:02:34 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in ($(INSTALL_X11_MODULES)): Depend upon installdirs.
+
+Wed Aug  6 16:27:29 1997  Chris Provenzano  <proven@cygnus.com>
+
+	* configure: Changed sed delimiter from ':' to '|' when
+	attempting to substitute ${config_shell} for SHELL. On
+	NT ${config_shell} may contain a ':' in it.
+
+Wed Aug  6 12:29:05 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Fix for non-bash shells.
+
+Wed Aug  6 00:42:35 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (AS_FOR_TARGET): Change as.new to as-new.
+
+Tue Aug  5 14:08:51 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (NM_FOR_TARGET): Change nm.new to nm-new.
+
+	* ylwrap: If the program is a relative path, force it to be
+	absolute.
+
+Tue Aug  5 12:12:44 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* configure (tooldir): Set BISON to `bison -y' and not just bison.
+
+Mon Aug  4 22:59:02 1997  Andrew Cagney  <cagney@b1.cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET): When winsup/Makefile present,
+	correctly specify the target build directory $(TARGET_SUBDIR)/winsup
+	for libraries.
+
+Mon Aug  4 12:40:24 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Fix handling of macros with values
+	separated by spaces.
+
+Thu Jul 31 19:49:49 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* ylwrap: New file.
+	* Makefile.in (DEVO_SUPPORT): Add ylwrap.
+
+	* ltmain.sh: Handle /bin/sh at start of install program.
+
+	* Makefile.in (DEVO_SUPPORT): Add ltconfig, ltmain.sh, and missing.
+
+	* ltconfig, ltmain.sh: New files, from libtool 1.0.
+	* missing: New file, from automake 1.2.
+
+Thu Jul 24 12:57:56 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Treat tix like tk, putting it in X11_MODULES.  Add
+	check-tk to CHECK_X11_MODULES.
+
+Wed Jul 23 17:03:29 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with FSF.
+
+Tue Jul 22 19:08:29 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.guess: Merge with FSF.
+
+Tue Jul 22 14:50:42 1997  Robert Hoehne <robert.hoehne@Mathematik.TU-Chemnitz.DE>
+
+	* configure: Treat msdosdjgpp like go32.
+	* configure.in: Likewise.  Don't remove gprof for go32.
+
+	* configure: Change Makefile.tem2 to Makefile.tm2.
+
+Mon Jul 21 10:31:26 1997  Stephen Peters  <speters@cygnus.com>
+
+	* configure.in (noconfigdirs): For alpha-dec-osf*, don't ignore grep.
+
+Tue Jul 15 14:33:03 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* install-sh (chmodcmd): Set to null if the DST directory already
+	exists.  Same as Nov 11th change.
+
+Mon Jul 14 11:01:15 1997  Martin M. Hunt  <hunt@cygnus.com>
+
+	* configure (GDB_TK): Needs itcl and tix.
+
+Mon Jul 14 00:32:10 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* config.guess: Update from FSF.
+
+Fri Jul 11 11:57:11 1997  Martin M. Hunt  <hunt@cygnus.com>
+
+	* Makefile.in (GDB_TK): Depend on itcl and tix.
+
+Fri Jul  4 13:25:31 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_PROGRAM_ARGS): New variable.
+	(INSTALL_PROGRAM): Use $(INSTALL_PROGRAM_ARGS).
+	(INSTALL_SCRIPT): New variable.
+	(BASE_FLAGS_TO_PASS): Pass down INSTALL_SCRIPT.
+	* configure.in: If host is *-*-cygwin32*, set INSTALL_PROGRAM_ARGS
+	to -x.
+	* install-sh: Add support for -x option.
+
+Mon Jun 30 15:51:30 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in, Makefile.in: Treat tix like itcl.
+
+Thu Jun 26 13:59:19 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (WINDRES): New variable.
+	(WINDRES_FOR_TARGET): New variable.
+	(BASE_FLAGS_TO_PASS): Add WINDRES_FOR_TARGET.
+	(EXTRA_HOST_FLAGS): Add WINDRES.
+	(EXTRA_TARGET_FLAGS): Add WINDRES.
+	(EXTRA_GCC_FLAGS): Add WINDRES.
+	($(DO_X)): Pass down WINDRES.
+	($(CONFIGURE_TARGET_MODULES)): Set WINDRES when configuring.
+	* configure: Treat WINDRES like DLLTOOL, and WINDRES_FOR_TARGET like
+	DLLTOOL_FOR_TARGET.
+
+Wed Jun 25 15:01:26 1997  Felix Lee  <flee@cygnus.com>
+
+	* configure.in: configure sim before gdb for win32-x-ppc
+
+Wed Jun 25 12:18:54 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	Move gperf into the toplevel, from libg++.
+	* configure.in (target_tools): Add target-gperf.
+	(native_only): Add target-gperf.
+	* Makefile.in (all-target-gperf): New target, depend on
+	all-target-libg++.
+	(configure-target-gperf): Empty rule.
+	(ALL_TARGET_MODULES): Add all-target-gperf.
+	(CONFIGURE_TARGET_MODULES): Add configure-target-gperf.
+	(CHECK_TARGET_MODULES): Add check-target-gperf.
+	(INSTALL_TARGET_MODULES): Add install-target-gperf.
+	(CLEAN_TARGET_MODULES): Add clean-target-gperf.
+
+Mon Jun 23 10:51:53 1997  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub (mn10200): Recognize new basic machine.
+
+Thu Jun 19 14:16:42 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: Don't set ENABLE_MULTILIB, so we'll be passing
+	--enable-multilib down to subdirs; setting TARGET_SUBDIR was enough.
+
+Tue Jun 17 15:31:20 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: If we're building mips-sgi-irix6* native, turn on
+	ENABLE_MULTILIB and set TARGET_SUBDIR.
+
+Tue Jun 17 12:20:59 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (all-sn): Depend on all-grep.
+
+Mon Jun 16 11:11:10 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Use mh-ppcpic and mt-ppcpic for powerpc*-* targets.
+
+	* configure: Set CFLAGS and CXXFLAGS, and substitute them into
+	Makefile.  From Jeff Makey <jeff@cts.com>.
+	* Makefile.in: Add comment for CFLAGS and CXXFLAGS.
+
+	* Makefile.in (DISTBISONFILES): Remove.
+	(taz): Don't futz with DISTBISONFILES.  Change BISON to use
+	$(DEFAULT_YACC).
+
+	* configure.in: Build itl, db, sn, etc., when building for native
+	cygwin32.
+
+	* Makefile.in (LD): New variable.
+	(EXTRA_HOST_FLAGS): Pass down LD.
+	($(DO_X)): Likewise.
+
+Mon Jun 16 11:10:35 1997  Philip Blundell  <Philip.Blundell@pobox.com>
+
+	* Makefile.in (INSTALL): Use $(SHELL) when executing install-sh.
+
+Fri Jun 13 10:22:56 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in (targargs): Strip out any supplied --build argument
+	before adding our own. Always add --build.
+
+Thu Jun 12 21:12:28 1997  Bob Manson  <manson@charmed.cygnus.com>
+
+	* configure.in (targargs): Pass --build if we're doing
+	a cross-compile.
+
+Fri Jun  6 21:38:40 1997  Rob Savoye  <rob@chinadoll.cygnus.com>
+
+	* configure: Use '|' instead of ":" as the separator in
+	sed. Otherwise sed chokes on NT path names with drive
+	designators. Also look for "?:*" as the leading characters in an
+	absolute pathname.
+
+Mon Jun  2 13:05:20 1997  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Support for r3900.
+
+Wed May 21 17:33:31 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Use install-sh, not install.sh.
+
+Wed May 14 16:06:51 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (taz): Improve check for BISON so it doesn't try to
+	apply it twice.
+
+Fri May  9 17:22:05 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_MODULES): Put install-opcodes before
+	install-binutils.
+
+Thu May  8 17:29:50 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Add automake targets.
+	* configure.in (host_tools): Add automake.
+
+Tue May  6 15:49:52 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Default CXX to c++, not gcc.
+	* Makefile.in (CXX): Set to c++, not gcc.
+	(CXX_FOR_TARGET): When cross, transform c++, not gcc.
+
+Thu May  1 10:11:43 1997  Geoffrey Noer  <noer@cygnus.com>
+
+	* install-sh: try appending a .exe if source file doesn't
+	exist
+
+Wed Apr 30 12:05:36 1997  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* configure.in: Turn on multilib by default.
+	(cross_only): Remove target-libiberty.
+
+	* Makefile.in (all-gcc): Don't depend on libiberty.
+
+Mon Apr 28 18:39:45 1997  Michael Snyder  <msnyder@cleaver.cygnus.com>
+
+	* config.guess: improve algorithm for recognizing Gnu Hurd x86.
+
+Thu Apr 24 19:30:07 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Add mpw-install.
+	(DISTBISONFILES): Add ld/Makefile.in
+
+Tue Apr 22 17:17:28 1997  Geoffrey Noer  <noer@pizza.cygnus.com>
+
+	* configure.in: if target is cygwin32 but host isn't cygwin32,
+	don't configure gdb tcl tk expect, not just gdb.
+
+Mon Apr 21 13:33:39 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* configure.in: Added gnuserv everywhere sn appears.
+
+	* Makefile.in (ALL_MODULES): Added all-gnuserv.
+	(CROSS_CHECK_MODULES): Added check-gnuserv.
+	(INSTALL_MODULES): Added install-gnuserv.
+	(CLEAN_MODULES): Added clean-gnuserv.
+	(all-gnuserv): New target.
+
+Thu Apr 17 13:57:06 1997  Per Fogelstrom  <pefo@openbsd.org>
+
+	* config.guess: Fixes for MIPS OpenBSD systems.
+
+Tue Apr 15 12:21:07 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (INSTALL_XFORM): Remove.
+	(BASE_FLAGS_TO_PASS): Remove INSTALL_XFORM.
+
+	* mkinstalldirs: New file, copied from automake.
+	* Makefile.in (installdirs): Rename from install-dirs.  Use
+	mkinstalldirs.  Change all users.
+	(DEVO_SUPPORT): Add mkinstalldirs.
+
+Mon Apr 14 11:21:38 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* install-sh: Rename from install.sh.
+	* Makefile.in (INSTALL): Change install.sh to install-sh.
+	(DEVO_SUPPORT): Likewise.
+
+	* configure: Use ${config_shell} with ${moveifchange}.  From Thomas
+	Graichen <graichen@rzpd.de>.
+
+Fri Apr 11 16:37:10 1997  Niklas Hallqvist  <niklas@appli.se>
+
+	* config.guess: Recognize OpenBSD systems correctly.
+
+Fri Apr 11 17:07:04 1997  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* README, Makefile.in (ETC_SUPPORT): Remove references to
+	cfg-paper*, configure.{texi,man,info*}._
+
+Sun Apr  6 18:47:57 1997  Andrew Cagney  <cagney@kremvax.cygnus.com>
+
+	* Makefile.in (all.normal): Ensure that gcc is built after all
+	the x11 - ie gdb - targets.
+
+Tue Apr  1 16:28:50 1997  Klaus Kaempf  <kkaempf@progis.de>
+
+	* makefile.vms: Don't run conf-a-gas.
+
+Mon Mar 31 16:26:55 1997  Joel Sherrill  <joel@oarcorp.com>
+
+	* configure.in (hppa1.1-*-rtems*): New target, like hppa-*-*elf*.
+
+Sun Mar 30 12:38:27 1997  Fred Fish  <fnf@cygnus.com>
+
+	* configure.in: Remove noconfigdirs case since gdb also
+	configures and builds for tic80-coff.
+
+Fri Mar 28 18:28:52 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Set cache_file to config.cache.
+	* Makefile.in (local-distclean): Remove config.cache.
+
+Wed Mar 26 18:49:39 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* COPYING: Update FSF address.
+
+Wed Mar 26 10:38:25 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (tic80-*-*): Remove G++ libraries and libgloss from
+	noconfigdirs.
+
+Mon Mar 24 15:02:39 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (install-dirs): Don't crash if prefix, and hence
+	MAKEDIRS, is empty.
+
+Mon Mar 24 12:40:55 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: Tweak mn10300 entry.
+
+Fri Mar 21 15:35:27 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (host_tools): Put sim before gdb, so gdb's
+	configure.tgt can determine if the simulator was configured.
+
+Sun Mar 16 16:07:08 1997  Fred Fish  <fnf@cygnus.com>
+
+	* config.sub: Move BeOS $os case to be with other Cygnus
+	local cases.
+
+Sun Mar 16 01:34:55 1997  Martin Hunt <hunt@cygnus.com>
+
+	* config.sub: Remove misplaced comment that broke Linux.
+
+Sat Mar 15 22:50:15 1997  Fred Fish  <fnf@cygnus.com>
+
+	* config.sub: Add BeOS support.
+
+Mon Mar 10 13:30:11 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (CHECK_X11_MODULES): Don't run check-tk.
+
+Wed Mar  5 12:09:29 1997  Martin  <hunt@cygnus.com>
+
+	* configure.in (noconfigdirs): Remove tcl and tk from
+	noconfigdirs for cygwin32 builds.
+
+Fri Feb 28 18:20:15 1997  Fred Fish  <fnf@cygnus.com>
+
+	* configure.in (tic80-*-*): Remove ld from noconfigdirs.
+
+Thu Feb 27 14:57:26 1997  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (GAS_SUPPORT_DIRS, BINUTILS_SUPPORT_DIRS): Remove
+	make-all.com, use makefile.vms instead.
+
+Tue Feb 25 18:46:14 1997  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* config.sub: Accept -lnews*.
+
+Tue Feb 25 13:19:14 1997  Andrew Cagney  <cagney@kremvax.tpgi.com.au>
+
+	* configure.in (noconfigdirs): Disable target-newlib,
+	target-examples and target-libiberty for d30v.
+
+Fri Feb 21 17:56:25 1997  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (noconfigdirs): Enable ld for d30v.
+
+Fri Feb 21 20:58:51 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* configure.in (tic80-*-*): Build compiler.
+
+Sun Feb 16 15:41:09 1997  Andrew Cagney  <cagney@critters.cygnus.com>
+
+	* configure.in (d30v-*): Remove sim directory from list of
+	unsupported d30v directories
+
+Tue Feb 18 17:32:42 1997  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* config.sub, configure.in: Add d30v target cpu.
+
+Thu Feb 13 22:04:44 1997  Klaus Kaempf  <kkaempf@progis.de>
+
+	* makefile.vms: New file.
+	* make-all.com: Remove.
+
+Wed Feb 12 12:54:18 1997  Jim Wilson  <wilson@cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Add LIBGCC2_DEBUG_CFLAGS.
+
+Sat Feb  8 20:36:49 1997  Michael Meissner  <meissner@cygnus.com>
+
+	* Makefile.in (all-itcl): The rule is all-itcl, not all-tcl.
+
+Tue Feb  4 11:39:29 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Added all-db.
+	(CROSS_CHECK_MODULES): Addec check-db.
+	(INSTALL_MODULES): Added install-db.
+	(CLEAN_MODULES): Added clean-db.
+
+Mon Feb  3 13:29:36 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.guess: Merge with latest FSF sources.
+
+Tue Jan 28 09:20:37 1997  Tom Tromey  <tromey@cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Added all-itcl.
+	(CROSS_CHECK_MODULES): Added check-itcl.
+	(INSTALL_MODULES): Added install-itcl.
+	(CLEAN_MODULES): Added clean-itcl.
+
+Thu Jan 23 01:44:27 1997  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: build gdb for mn10200
+
+Fri Jan 17 15:32:15 1997  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (all-target-winsup): Depend on all-target-libio.
+
+Mon Jan 13 22:46:54 1997  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (tic80-*-*): Turn off most targets right now.
+
+Fri Jan  3 16:04:03 1997  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (MAKEINFO): Check for the existence of the Makefile,
+	rather than the makeinfo program.
+	(do-info): Depend upon all-texinfo.
+
+Tue Dec 31 16:00:31 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Remove uses of config/mh-linux.
+
+	* config.sub, config.guess: Merge with latest FSF sources.
+
+Fri Dec 27 23:04:33 1996  Fred Fish  <fnf@cygnus.com>
+
+	* config.sub (case $basic_machine): Add tic80 entries.
+
+Fri Dec 27 12:07:59 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub, config.guess: Merge with latest FSF sources.
+
+Wed Dec 18 22:46:39 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-build.in: Build ld before gcc, use NewFolderRecursive.
+	* mpw-config.in: Test for NewFolderRecursive.
+	* mpw-install: Use symbolic name for startup filename.
+	* mpw-README: Add various additional details.
+
+Wed Dec 18 13:11:46 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (mips*-sgi-irix6*): Remove binutils from noconfigdirs.
+
+Wed Dec 18 10:29:31 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Do build gcc and the target libraries for
+	the mn10200.
+
+Wed Dec  4 16:53:05 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: don't avoid building gdb for mn10300 any more
+	* Makefile.in: double-quote GCC_FOR_TARGET line in EXTRA_GCC_FLAGS
+	instead of single-quoting it.
+
+Tue Dec  3 23:26:50 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* configure.in: Don't use --with-stabs on IRIX 6.
+
+Tue Dec  3 09:05:25 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in (m32r): Build gdb, libg++ now.
+
+Sun Dec  1 00:18:59 1996  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* configure.in (mips*-sgi-irix6*):  Remove gdb and related
+	directories from noconfigdirs.
+
+Tue Nov 26 11:45:33 1996  Kim Knuttila  <krk@cygnus.com>
+
+	* config.sub (basic_machine): added mips16 configuration
+
+Sat Nov 23 19:26:22 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.sub: Handle d10v-unknown.
+
+Sat Nov 23 10:23:01 1996  Gavin Koch  <gavin@cygnus.com>
+
+	* config.sub: Handle v850-unknown.
+
+Thu Nov 21 16:19:44 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* Makefile.in: add findutils
+	* configure.in: add findutils to list of host_tools
+
+Wed Nov 20 10:09:01 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* config.sub: Handle mn10200 and mn10300.
+
+Tue Nov 19 16:35:14 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (d10v-*): Do not build librx.
+
+Mon Nov 18 13:28:41 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in (mn10300): Build everything except gdb & libgloss.
+
+Wed Nov 13 14:59:46 1996  Per Bothner  <bothner@deneb.cygnus.com>
+
+	* config.guess:  Patch for Dansk Data Elektronik servers,
+	from Niels Skou Olsen <nso@dde.dk>.
+
+	For ncr, use /bin/uname rather than uname, since GNU uname does not
+	support -p.  Suggested by Mark Mitchell <mmitchell@usa.net>.
+
+	Patch for MIPS R4000 running System V,
+	from Eric S. Raymond <esr@snark.thyrsus.com>.
+
+	Fix thinko for nextstep.
+
+	Patch for OSF1 in i?86, from Dan Murphy <dlm@osf.org> via Harlan Stenn.
+
+	Sat Jun 24 18:58:17 1995  Morten Welinder  <terra+@cs.cmu.edu>
+	* config.guess: Guess mips-dec-mach_bsd4.3.
+
+	Thu Oct 10 04:07:04 1996  Harlan Stenn <harlan@pfcs.com>
+	* config.guess (i?86-ncr-sysv*):  Emit just enough of the minor
+	release numbers.
+	* config.guess (mips-mips-riscos*):  Emit just enough of the
+	release number.
+
+	Tue Oct  8 10:37:22 1996  Frank Vance <fvance@waii.com>
+	* config.guess (sparc-auspex-sunos*):  Added.
+	(f300-fujitsu-*): Added.
+
+	Wed Sep 25 22:00:35 1996  Jeff Woolsey <woolsey@jlw.com>
+	* config.guess:  Recognize a Tadpole as a sparc.
+
+Wed Nov 13 00:53:09 1996  David J. MacKenzie  <djm@churchy.gnu.ai.mit.edu>
+
+	* config.guess: Don't assume that NextStep version is either 2 or
+	3.  NextStep 4 (aka OpenStep 4) has come out now.
+
+Mon Nov 11 23:52:03 1996  David J. MacKenzie  <djm@churchy.gnu.ai.mit.edu>
+
+	* config.guess: Support Cray T90 that reports itself as "CRAY TS".
+	From Rik Faith <faith@cs.unc.edu>.
+
+Fri Nov  8 11:34:58 1996  David J. MacKenzie  <djm@geech.gnu.ai.mit.edu>
+
+	* config.sub: Contributions from bug-gnu-utils to:
+	Support plain "hppa" (no version given) architecture, reported by
+	OpenStep.
+	OpenBSD like NetBSD.
+	LynxOs is not a hardware supplier.
+
+	* config.guess: Contributions from bug-gnu-utils to add support for:
+	OpenBSD like NetBSD.
+	Stratus systems.
+	More Pyramid systems.
+	i[n>4]86 Intel chips.
+	M680[n>4]0 Motorola chips.
+	Use unknown instead of lynx for hardware manufacturer.
+
+Mon Nov 11 10:09:08 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* install.sh (chmodcmd): Set to null if the DST directory already
+	exists.
+
+Mon Nov 11 10:43:41 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpc*-{eabi,elf,linux,rtem,sysv,solaris}*): Do
+	not use mt-ppc target Makefile fragment any more.
+
+Sun Nov  3 19:17:07 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in (*-*-windows):  Exclude everything but those dirs
+	needed to build windows.
+
+Tue Oct 29 16:41:31 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (all-target-winsup): Depend on all-target-librx.
+
+Mon Oct 28 17:32:46 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  Exclude mmalloc from i386-windows.
+
+Thu Oct 24 09:22:46 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* Undo my previous change.
+
+Thu Oct 24 12:12:04 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): Pass down GCC_FOR_TARGET
+	unconditionally.
+	(MAKEOVERRIDES): Define (revert this part of October 18 change).
+
+Thu Oct 24 09:02:07 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* Makefile.in (FLAGS_TO_PASS):  Add $(HOST_FLAGS) to allow the
+	host to add it's own flags.
+
+Tue Oct 22 15:20:26 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Handle GCC_FOR_TARGET like CC_FOR_TARGET.
+
+Fri Oct 18 13:37:13 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET): Check for xgcc, not Makefile.
+	(CXX_FOR_TARGET): Likewise.
+	(GCC_FOR_TARGET): Define.
+	(BASE_FLAGS_TO_PASS): Remove GCC_FOR_TARGET.
+	(EXTRA_GCC_FLAGS): Define GCC_FOR_TARGET based on whether
+	CC_FOR_TARGET was specified on the command line.
+	(MAKEOVERRIDES): Don't define.
+
+Thu Oct 17 10:27:56 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in (m32r): Fix spelling of libg++ libs.
+
+Thu Oct 10 10:37:17 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* config.sub (-apple*): Remove, now redundant.
+
+Thu Oct 10 12:30:54 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Don't get confused by CPU-VENDOR-linux-gnu.
+
+	* configure: Rework yesterday's sed script patch.
+
+	* config.sub: Merge with FSF.
+
+Wed Oct  9 17:24:59 1996  Per Bothner  <bothner@deneb.cygnus.com>
+
+	* config.guess:  Merge from FSF.
+
+	1996-09-12  Richard Stallman  <rms@ethanol.gnu.ai.mit.edu>
+	* config.guess: Use pc instead of unknown, for pc clone systems.
+	Change linux to linux-gnu.
+
+	Mon Jul 15 23:51:11 1996  Karl Heuer  <kwzh@gnu.ai.mit.edu>
+	* config.guess: Avoid non-portable tr syntax.
+
+Wed Oct  9 06:06:46 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* test-build.mk (HOLES): Add "xargs" for gdb.
+
+	* configure: Avoid hpux10.20 sed bug.
+
+Tue Oct  8 08:32:48 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  Add support for windows host
+	(that is a build done under the Microsoft build environment).
+
+Tue Oct  8 10:39:08 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Replace all uses of srcroot with s, to shrink
+	command line lengths.
+
+	Patches from Geoffrey Noer <noer@cygnus.com>:
+	* configure.in: If configuring for newlib, pass --with-newlib to
+	subdirectories.
+	* Makefile.in (CC_FOR_TARGET): If winsup/Makefile exists, pass a
+	-Bnewlib/ and -Lwinsup to gcc.
+	(CXX_FOR_TARGET): Likewise.
+
+Mon Oct  7 10:59:35 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (ETC_SUPPORT): Add configure.
+
+Fri Oct  4 12:22:58 1996  Angela Marie Thomas (angela@cygnus.com)
+
+	* configure.in: Use config/mh-dgux386 for i[345]86-dg-dgux
+	host configuration file.
+
+Thu Oct  3 09:28:25 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Break mn10x00 support into separate
+	mn10200 and mn10300 configurations.
+	* config.sub: Likewise.
+
+Wed Oct  2 22:27:52 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Add lots of stuff to noconfigdirs for
+	the mn10x00 targets.
+
+	* config.sub, configure.in: Add mn10x00 support.
+
+Wed Oct  2 15:52:36 1996  Klaus Kaempf  <kkaempf@progis.de>
+
+	* make-all.com: Call conf-a-gas, not config-a-gas.
+
+Tue Oct  1 01:28:41 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* configure.in (noconfigdirs): Don't build libgloss for arm-coff
+	targets.
+
+Mon Sep 30 14:24:01 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-README: Add much more detail for native PowerMac.
+	* mpw-install: New file.
+	* mpw-configure: Add --norecursion and --help options.
+	* mpw-config.in: Translate readme and install files when
+	copying to objdir.
+	* mpw-build.in: Don't always depend on byacc and flex.
+	(install-only-top): New action.
+
+Fri Sep 27 17:39:44 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  You can now configure GDB for the v850.
+
+Tue Sep 24 19:05:12 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* configure.in (noconfigdirs): Don't configure any C++ dirs
+	if targeting D10V.
+
+Tue Sep 17 12:15:31 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Recognize mips64vr5000.
+
+Mon Sep 16 17:00:52 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Use a single line for host_tools and native_only.
+
+Mon Sep  9 12:21:30 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub, configure.in: Add entries for m32r.
+
+Thu Sep  5 13:52:47 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (inet-install): Don't run install-gzip.
+
+Wed Sep  4 17:26:13 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* configure.in:  Don't config lots of things for *-*-windows*.
+
+Sat Aug 31 11:45:57 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-config.in: Test for mpw-true, true, and null-command scripts.
+	(host_libs, host_tools): Copy from configure.in.
+	* mpw-configure: Don't complain about directories not found.
+
+Thu Aug 29 16:44:58 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (i[345]86): Recognize i686 for pentium pro.
+	(i[3456]86-*-dgux*): Use config/mh-sysv for the host configuration
+	file.
+
+	* config.guess (i[345]86): Ditto.
+
+Mon Aug 26 18:34:42 1996  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (noconfigdirs): Removed gdb for D10V.
+
+Thu Aug 22 17:13:52 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* configure.in: Remove ld, target-libio, target-libg++, and
+	target-libstdc++ from noconfigdirs.
+
+Wed Aug 21 18:56:38 1996  Fred Fish  <fnf@cygnus.com>
+
+	* configure: Fix three locations where shell scripts were
+	being run directly rather than with config_shell.
+
+Tue Aug 20 13:08:47 1996  J.T. Conklin  <jtc@hippo.cygnus.com>
+
+	* configure.in (v850-*-*): Set up initial $noconfigdirs.
+	* config.sub (basic_machine): Recognize v850.
+
+Thu Aug 15 12:19:33 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Handle multiple enable/disable options and
+	pass them down recursively, handle -c and -s flags appropriately
+	depending on choice of compiler, add escape mechanism for
+	quoted arguments to gC.
+
+Mon Aug 12 13:15:13 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpc*-*-*): For eabi, system V.4, Linux, and
+	solaris targets, use config/mt-ppc to set C{,XX}FLAGS_FOR_TARGETS
+	so that -mrelocatable-lib and -mno-eabi are used.
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): If target compiler does
+	not support --print-multi-lib, don't abort.
+
+Thu Aug  8 12:18:59 1996  Klaus Kaempf  <kkaempf@progis.de>
+
+	* make-all.com: Run config-a-gas.
+	* setup.com: Don't copy subdirectory files around.
+
+Tue Jul 30 17:49:31 1996  Brendan Kehoe  <brendan@cygnus.com>
+
+	* configure.in (*-*-ose): Remove exclusion of libgloss for this
+	target, it now compiles correctly.
+
+Sat Jul 27 15:10:43 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-config.in: Generate Mac include for elf/dwarf2.h.
+
+Tue Jul 23 10:47:04 1996  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (d10v-*-*): Remove ld from $noconfigdirs.
+
+Mon Jul 22 13:28:51 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in (native_only): Add prms.
+
+Mon Jul 22 12:27:58 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (GAS_SUPPORT_DIRS): Add make-all.com and setup.com.
+	(BINUTILS_SUPPORT_DIRS): Likewise.
+
+Thu Jul 18 12:55:40 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (d10v-*-*): Don't configure ld or gdb until the
+	d10v support is added.
+
+Wed Jul 17 14:33:09 1996  Martin M. Hunt  <hunt@pizza.cygnus.com>
+
+	* configure.in (d10v-*-*): New target.
+
+Mon Jul 15 11:53:00 1996  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess (HP 9000/811): Recognize this as a PA1.1
+	machine.
+
+Fri Jul 12 23:21:17 1996  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (do-tar-gz): New target, split out from tail end of
+	taz target.  Run each command separately, don't use pipes.
+	(taz): Use it.
+
+Fri Jul 12 12:08:04 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Look for g-mpw-make.sed in config/mpw.
+	* mpw-build.in: No builds should depend on building byacc or flex,
+	they are assumed to be installed already.
+
+Fri Jul 12 09:52:52 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Set r environment
+	variable that CC_FOR_TARGET needs.
+
+Thu Jul 11 10:09:45 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Determine if the multlib
+	options have changed since the last time the subdirectory was
+	configured, and if it has, reconfigure.
+	(CLEAN_TARGET_MODULES): Delete multilib.out and tmpmulti.out, which
+	CONFIGURE_TARGET_MODULES uses to remember the old multilib options.
+
+Wed Jul 10 18:56:59 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (ALL_MODULES,CROSS_CHECK_MODULES,INSTALL_MODULES,
+	CLEAN_MODULES): Add bash.
+	(all-bash): New target.
+
+Mon Jul  8 17:33:14 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (mips-sgi-irix6*): Use mh-irix6 instead of mh-irix5.
+
+Mon Jul  1 13:31:35 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.sub (basic_machine): Recognize d10v as a valid processor.
+
+Fri Jun 28 12:14:35 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Add support for --bindir.
+	* mpw-build.in: Use a GCC-specific build script for GCC actions.
+
+Wed Jun 26 17:20:12 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: add bash, time, gawk to list of hosttools and things
+	to only build for native toolchains
+
+Tue Jun 25 23:09:03 1996  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* Makefile.in (docdir): Remove.
+
+Tue Jun 25 19:00:08 1996  Jason Molenda  (crash@godzilla.cygnus.co.jp)
+
+	* Makefile.in (datadir): Set to $(prefix)/share.
+
+Mon Jun 24 23:26:07 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: build diff and patch for cygwin32-hosted
+	toolchains.
+
+Mon Jun 24 15:01:12 1996  Joel Sherrill  <joel@merlin.gcs.redstone.army.mil>
+
+	* config.sub: Accept -rtems*.
+
+Sun Jun 23 22:41:54 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: enable dosrel for cygwin32-hosted builds,
+		remove diff from the list of things not buildable
+		via Canadian Cross
+
+Sat Jun 22 11:39:01 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (TARGET_SUBDIR): Move comment to previous line so we
+	don't get ". ".
+
+Fri Jun 21 17:24:48 1996  Jim Wilson  <wilson@cygnus.com>
+
+	* configure.in (mips*-sgi-irix6*): Set noconfigdirs appropriately.
+
+Thu Jun 20 16:57:40 1996  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (taz): Handle case where tex3patch didn't even get
+	checked out.  Also, if it was found, put the symlink in a new util
+	subdirectory.
+
+Thu Jun 20 12:20:33 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.guess (*:Linux:*:*): Add support for PowerPC Linux.
+
+Tue Jun 18 14:24:12 1996  Klaus Kaempf  (kkaempf@progis.de)
+
+	* config.sub: Recognize -openvms.
+	* configure.in (alpha*-*-*vms*): Set noconfigdirs.
+	* make-all.com, setup.com: New files.
+
+Mon Jun 17 16:34:46 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (taz): tex3patch moved to texinfo/util.
+
+Sat Jun 15 17:13:25 1996  Geoffrey Noer <noer@cygnus.com>
+
+	* configure: enable_gdbtk=no for cygwin32-hosted toolchains
+	* configure.in: remove make from disable-if-Can-Cross list
+		enable gdb if ${host} and ${target} are cygwin32
+
+Fri Jun  7 18:16:52 1996  Harlan Stenn <harlan@pfcs.com>
+
+	* config.guess (i?86-ncr-sysv*):  Emit minor release numbers.
+	Recognize the NCR 4850 machine and NCR Pentium-based platforms.
+
+Wed Jun  5 00:09:17 1996  Per Bothner  <bothner@wombat.gnu.ai.mit.edu>
+
+	* config.guess:  Combine mips-mips-riscos cases, and use cpp to
+	distinguish sysv/svr4/bsd variants.
+	Based on a patch from Harlan Stenn <harlan@pfcs.com>.
+
+Fri Jun  7 14:24:49 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* configure.in: Added copyright notice.
+	* move-if-change: Added copyright notice.
+
+Thu Jun  6 16:27:05 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpcle-*-solaris*): Until we get shared
+	libraries working, don't build gdb, sim, make, tcl, tk, or
+	expect.
+
+Tue Jun  4 20:41:45 1996  Per Bothner  <bothner@deneb.cygnus.com>
+
+	* config.guess:  Merge with FSF:
+
+	Mon Jun  3 08:49:14 1996  Karl Heuer  <kwzh@gnu.ai.mit.edu>
+	* config.guess (*:Linux:*:*): Add guess for sparc-unknown-linux.
+
+	Fri May 24 18:34:53 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
+	* config.guess (AViiON:dgux:*:*): Fix typo in recognizing mc88110.
+
+	Fri Apr 12 20:03:59 1996  Per Bothner  <bothner@spiff.gnu.ai.mit.edu>
+	* config.guess:  Combine two OSF1 rules.
+	Also recognize field test versions.  From mjr@zk3.dec.com.
+	* config.guess (dgux):  Use /usr/bin/uname rather than uname,
+	because GNU uname does not support -p.  From pmr@pajato.com.
+
+Tue Jun  4 11:07:25 1996  Tom Tromey  <tromey@csk3.cygnus.com>
+
+	* Makefile.in (MAKEDIRS): Removed $(tooldir).
+
+Tue May 28 12:30:50 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-README: Document GCCIncludes.
+
+Sun May 26 15:16:27 1996  Fred Fish  <fnf@cygnus.com>
+
+	* configure.in (alpha-*-linux*): Set enable_shared to yes.
+
+Tue May 21 15:41:39 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Handle --enable-FOO and --disable-FOO.
+
+Mon May 20 10:12:29 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in (*-*-cygwin32): Configure make.
+
+Tue May  7 14:19:42 1996  Tom Tromey  <tromey@snuffle.cygnus.com>
+
+	* Makefile.in (inet-install): Quote value of INSTALL_MODULES.
+
+Fri May  3 08:57:17 1996  Tom Tromey  <tromey@lisa.cygnus.com>
+
+	* Makefile.in (all-inet): Depend on all-perl.
+
+	* Makefile.in (inet-install): New target.
+
+	* Makefile.in (all-inet): Depend on all-tcl.
+	(all-inet): Depend on all-send-pr.
+
+Tue Apr 30 13:55:51 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (powerpcle-*-solaris*): Turn off tk and tcl
+	temporarily.
+
+Thu Apr 25 11:48:20 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure --with-gnu-ld on AIX.
+
+Thu Apr 25 06:33:36 1996  Michael Meissner  <meissner@wogglebug.tiac.net>
+
+	* configure.in (powerpcle-*-solaris*): Turn off gdb temporarily.
+
+Tue Apr 23 09:07:39 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Added all-inet.
+	(CROSS_CHECK_MODULES): Added check-inet.
+	(INSTALL_MODULES): Added install-inet.
+	(CLEAN_MODULES): Added clean-inet.
+	(all-indent): New target.
+
+	* configure.in (host_tools): Added inet.
+	(native_only): Added inet.
+	(noconfigdirs): Added inet.
+
+Fri Apr 19 15:35:29 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure libgloss if we are not configuring
+	newlib.
+
+Wed Apr 17 19:30:01 1996  Rob Savoye  <rob@chinadoll.cygnus.com>
+
+	* configure.in: Don't configure libgloss for unsupported
+	architectures.
+
+Tue Apr 16 11:17:05 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (CLEAN_MODULES): Add clean-apache.
+
+Mon Apr 15 15:09:05 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Include all-apache.
+	(CROSS_CHECK_MODULES): Include check-apache.
+	(INSTALL_MODULES): Include install-apache.
+	(all-apache): New target.
+
+	* configure.in: Added apache everywhere perl is seen.
+
+Mon Apr 15 14:59:13 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in: Add support for clean-{module} and
+	clean-target-{module} rules.
+
+Wed Apr 10 21:37:41 PDT 1996  Marilyn E. Sander <msander@cygnus.com>
+
+	* configure.in (*-*-ose) do not build libgloss.
+
+Mon Apr  8 16:16:20 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.guess (prep*:SunOS:5.*:*): Turn into
+	powerpele-unknown-solaris2.
+
+Mon Apr  8 14:45:41 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Permit --enable-shared to specify a list of
+	directories.
+
+Fri Apr  5 08:17:57 1996  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (host==solaris): Pass only the first word of $CC
+	to /usr/bin/which when checking if we're using /usr/ccs/bin/cc.
+
+Fri Apr  5 03:16:13 1996  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): pass down $(MAKE).
+
+Thu Mar 28 14:11:11 1996  Tom Tromey  <tromey@creche.cygnus.com>
+
+	* Makefile.in (ALL_MODULES): Include all-perl.
+	(CROSS_CHECK_MODULES): Include check-perl.
+	(INSTALL_MODULES): Include install-perl.
+	(ALL_X11_MODULES): Include all-guile.
+	(CHECK_X11_MODULES): Include check-guile.
+	(INSTALL_X11_MODULES): Include install-guile.
+	(all-perl): New target.
+	(all-guile): New target.
+
+	* configure.in (host_tools): Include perl and guile.
+	(native_only): Include perl and guile.
+	(noconfigdirs): Don't build guile and perl; no ports have been
+	done.
+
+Tue Mar 26 21:18:50 1996  Andrew Cagney  <cagney@kremvax.highland.com.au>
+
+	* configure (--enable-*): Handle quoted option lists such as
+	--enable-sim-cflags='-g0 -O' better.
+
+Thu Mar 21 11:53:08 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in ({,inst}all-target): New rule so we can make and
+	install all of the target directories easily.
+
+Wed Mar 20 18:10:57 1996  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* configure.in: Add missing global flag in sed substitution when
+	deleting `target-' from ${configdirs}.
+
+Thu Mar 14 19:15:06 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DO_X): Don't get confused if CC contains `=' in an
+	option.
+
+	* configure.in (mips*-nec-sysvr4*): Use a host_makefile_frag of
+	config/mh-necv4.
+
+	* install.sh: Correct misspelling of transformbasename.
+
+	* config.guess: Recognize mips-*-sysv*.
+
+Mon Mar 11 15:36:42 1996  Dawn Perchik  <dawn@critters.cygnus.com>
+
+	* config.sub: Recognize mon960.
+
+Sun Mar 10 13:18:38 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Restore Canadian Cross handling of BISON and LEX,
+	removed in Feb 20 change.
+
+Fri Mar  8 20:07:09 1996  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* README:  Suggestions from Torbjorn Granlund <tege@matematik.su.se>:
+	Mention make install.  Remove the old copyright date as well the
+	clumsy and rather pointless copyright on the README file.
+
+Fri Mar  8 17:51:35 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)): If there is a
+	Makefile after running symlink-tree, then run `make distclean' to
+	avoid clobbering any generated files in srcdir.
+
+Tue Mar  5 08:21:44 1996  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (m68k-*-netbsd*): Build everything now.
+
+Wed Feb 28 12:25:46 1996  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* Makefile.in (taz): Fix quoting.
+
+Tue Feb 27 11:33:57 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* configure.in (sparclet-*-*): Build everything now.
+
+Tue Feb 27 14:31:51 1996  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* configure.in (m68k-*-linux*): New host.
+
+Mon Feb 26 14:32:44 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Check for bison before byacc.
+
+Tue Feb 20 23:12:35 1996  Stu Grossman  (grossman@critters.cygnus.com)
+
+	* Makefile.in configure:  Change the way LEX and BISON/YACC are
+	set.  configure now defines DEFAULT_LEX and DEFAULT_YACC by
+	searching PATH.  These are used as fallbacks by Makefile.in if
+	flex/bison/byacc aren't in objdir.
+
+Mon Feb 19 11:45:30 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in: Make everything which depends upon all-bfd also
+	depend upon all-opcodes, in case --with-commonbfdlib is used.
+
+Thu Feb 15 19:50:50 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (host *-*-cygwin32): Don't build gdb if we are
+	building NT native compilers on Unix.
+
+Thu Feb 15 17:42:25 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't get CC from the host Makefile fragment if we
+	can find gcc in PATH, or if this is a Canadian Cross.  Move the
+	Solaris test for /usr/ucb/cc to the post target script, just after
+	the compiler sanity test.
+
+Wed Feb 14 16:57:40 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with FSF.
+
+Tue Feb 13 14:27:48 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (RPATH_ENVVAR): New variable.
+	(REALLY_SET_LIB_PATH): Use it.
+	* configure.in: On HP/UX, set RPATH_ENVVAR to SHLIB_PATH.
+
+Mon Feb 12 15:28:49 1996  Doug Evans  <dje@charmed.cygnus.com>
+
+	* config.sub, configure.in: Recognize sparclet cpu.
+
+Mon Feb 12 15:33:59 1996  Christian Bauernfeind <chrisbfd@theorie3.physik.uni-erlangen.de>
+
+	* config.guess:  Support m68k-cbm-sysv4.
+
+Sat Feb 10 12:06:42 1996  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* config.guess (*:Linux:*:*): Guess m68k-unknown-linux and
+	m68k-unknown-linuxaout from linker help string.  Put quotes around
+	$ld_help_string.
+
+Thu Dec  7 09:03:24 1995  Tom Horsley  <Tom.Horsley@mail.hcsc.com>
+
+	* config.guess (powerpc-harris-powerunix): Add guess for port
+	to new target.
+
+Thu Feb  8 15:37:52 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* config.guess (UNAME_VERSION): Recognize X4.x as an OSF version.
+
+Mon Feb  5 16:36:51 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: If --enable-shared was used, set SET_LIB_PATH to
+	$(REALLY_SET_LIB_PATH) in Makefile.
+	* Makefile.in (SET_LIB_PATH): New variable.
+	(REALLY_SET_LIB_PATH): New variable.
+	($(DO_X)): Use $(SET_LIB_PATH).
+	(install.all, gcc-no-fixedincludes, $(ALL_MODULES)): Likewise.
+	($(NATIVE_CHECK_MODULES), $(CROSS_CHECK_MODULES)): Likewise.
+	($(INSTALL_MODULES), $(CONFIGURE_TARGET_MODULES)): Likewise.
+	($(ALL_TARGET_MODULES), $(CHECK_TARGET_MODULES)): Likewise.
+	($(INSTALL_TARGET_MODULES), $(ALL_X11_MODULES)): Likewise.
+	($(CHECK_X11_MODULES), $(INSTALL_X11_MODULES)): Likewise.
+	(all-gcc, all-bootstrap, check-gcc, install-gcc): Likewise.
+	(install-dosrel): Likewise.
+	(all-opcodes): Depend upon all-libiberty.
+
+Sun Feb  4 16:51:11 1996  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* config.guess (*:CYGWIN*): New
+
+Sat Feb  3 10:42:35 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (all-target-winsup): All all-target-libiberty.
+
+Fri Feb  2 17:58:56 1996  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* configure.in (noconfigdirs): Add missing # in front of comment.
+
+Thu Feb  1 14:38:13 1996  Geoffrey Noer  <noer@cygnus.com>
+
+	* configure.in: add second pass to things added to noconfigdirs
+	so *-gm-magic can exclude libgloss properly.
+
+Thu Feb  1 11:10:16 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure (extralibs_name, rez_name): Set correctly
+	for MWC68K compiler.
+
+	* mpw-README: Add more info on the necessary build tools.
+
+Thu Feb  1 10:22:38 1996  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in, config.sub: Recognize cygwin32.
+
+Wed Jan 31 14:17:10 1996  Richard Henderson  <rth@tamu.edu>
+
+	* config.guess, config.sub: Recognize A/UX.
+
+Wed Jan 31 13:52:14 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge with gcc/config.sub.
+
+Thu Jan 25 11:01:10 1996  Raymond Jou  <rjou@mexican.cygnus.com>
+
+	* mpw-build.in (do-binutils): Add build of stamps.
+
+Thu Jan 25 17:05:26 1996  James G. Smith  <jsmith@cygnus.co.uk>
+
+	* config.sub: Add recognition for mips64vr4100*-* targets.
+
+Wed Jan 24 12:47:55 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* test-build.mk: Add checking of `hpux9' rather than just `hpux'.
+	Add creation of gconfigargs with `--enable-shared' turned on.
+	($(host)-stamp-stage2-configured): Pass $(gconfigargs).
+	($(host)-stamp-stage3-configured): Likewise.
+	(HOLES): Add chatr and ldd.
+	(i386-ncr-sysv4.3*): Add use of /usr/ccs/bin in the PATH and HOLE_DIRS.
+
+Wed Jan 24 20:32:30 1996  Torbjorn Granlund  <tege@noisy.matematik.su.se>
+
+	* configure: Pass --nfp to recursive configures.
+
+Mon Jan 22 10:41:56 1996  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* Makefile.in (DLLTOOL): New.
+	(DLLTOOL_FOR_TARGET): New.
+	(EXTRA_HOST_FLAGS): Pass down DLLTOOL.
+	(EXTRA_TARGET_FLAGS): Ditto.
+	(EXTRA_GCC_FLAGS): Ditto.
+	(CONFIGURE_TARGET_MODULES): Ditto.
+	(DO_X): Ditto.
+	* configure: Add DLLTOOL.
+
+Fri Jan 19 13:30:15 1996  Stan Shebs  <shebs@andros.cygnus.com>
+
+	SCO OpenServer 5 changes from Robert Lipe <robertl@dgii.com>:
+	* configure.in (i[345]86-*-sco3.2v5*): Use mh-sysv instead of
+	mh-sco, since old workarounds no longer needed, and don't
+	build ld, since libraries have weak symbols in COFF.
+
+Sun Jan 14 23:01:31 1996  Fred Fish  <fnf@cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Add missing ';'.
+
+Fri Jan 12 15:25:35 1996  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Make sure that ${CC} can be used to compile an
+	executable.
+
+Sat Jan  6 07:23:33 1996  Michael Meissner  <meissner@wogglebug.tiac.net>
+
+	* Makefile.in (all-gdb): Depend on $(GDB_TK).
+	* configure (GDB_TK): Set GDB_TK to either "all-tcl all-tk" or
+	nothing depending on whether gdbtk is being built.
+
+Wed Jan  3 17:54:41 1996  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (newlib.tar.gz): Delete building of newlib's info files.
+
+Mon Jan  1 19:09:14 1996  Brendan Kehoe  <brendan@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Put ld or gas in this early, if the
+	user specifically used --with-gnu-ld=no or --with-gnu-as=no.
+
+Sat Dec 30 16:08:57 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config-ml.in: Add support for
+	--disable-{softfloat,m68881,m68000,m68020} on m68*-*-*.
+	Simplify setting of multidirs from --disable-foo.
+
+Fri Dec 29 07:56:11 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* Makefile.in (EXTRA_GCC_FLAGS): If any of the make variables
+	LANGUAGES, BOOT_CFLAGS, STMP_FIXPROTO, LIMITS_H_TEST,
+	LIBGCC1_TEST, LIBGCC2_CFLAGS, LIBGCC2_INCLUDES, and ENQUIRE are
+	non-empty, pass them on to the	GCC make.
+	(all-bootstrap): New rule that is like all-gcc, except it executes
+	the GCC bootstrap rule instead of the GCC all rule.
+
+Wed Dec 27 15:51:48 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config-ml.in (ml_realsrcdir): New, to account for ${subdir}.
+
+Tue Dec 26 11:45:31 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.guess (AViiON:dgux:*:*): Update from FSF to add pentium
+	DG/UX support.
+
+Fri Dec 15 10:01:27 1995  Stan Cox  <coxs@dg-rtp.dg.com>
+
+	* config.sub (i*86*) Change [345] to [3456]
+
+Wed Dec 20 17:41:40 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in (noconfigdirs): Add gas or ld if --with-gnu-as=no or
+	--with-gnu-ld=no.
+
+Wed Dec 20 15:15:35 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config-ml.in (rs6000*, powerpc*): Add switches to control which
+	AIX multilibs get built.
+
+Mon Dec 18 17:55:46 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (i386-win32): Don't build expect if we're not
+	building the tcl subdir.
+
+Mon Dec 18 11:47:19 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* Makefile.in: (configure-target-examples, all-target-examples):
+	New targets, configure and build example programs.
+
+Fri Dec 15 16:13:03 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: If an mpw-config.in generated a file mk.sed,
+	use it as input to sedit the generated MPW makefile.
+	* mpw-README: Add a suggestion about Gestalt.h.
+
+Wed Dec 13 16:43:51 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Accept *-*-ieee*.
+
+Tue Dec 12 11:52:57 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (local-distclean): Remove $(TARGET_SUBDIR).  From
+	Ronald F. Guilmette <rfg@monkeys.com>.
+
+Mon Dec 11 15:31:58 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (host==powerpc-pe): Add many directories to noconfigdirs
+	for powerpc-pe native.
+	(target==i386-win32): add tcl, make to noconfigdirs if canadian cross.
+	(target==powerpc-pe): duplicate i386-win32 entry.
+
+Sat Dec  9 14:58:28 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* configure.in (noconfigdirs): Exclude target-newlib for all versions
+	of vxworks, not just vxworks5.1.
+
+Mon Dec  4 12:05:40 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Add support for exec-prefix.
+
+Mon Dec  4 10:22:50 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* config.guess: Recognize HP model 816 machines as having
+	a PA1.1 processor.
+
+Mon Dec  4 12:38:15 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Ignore new autoconf configure options.
+
+Thu Nov 30 16:57:33 1995  Per Bothner  <bothner@wombat.gnu.ai.mit.edu>
+
+	* config.guess:  Recognize Pentium under SCO.
+	From Robert Lipe <robertl@arnet.com>.
+
+Wed Nov 29 13:49:08 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable target-libio on v810-*-*.
+
+Wed Nov 29 12:12:01 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure gas for alpha-dec-osf*.
+
+Tue Nov 28 17:16:48 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Default to --with-stabs for some targets for which
+	it makes sense: mips*-*-*, alpha*-*-osf*, i[345]86*-*-sysv4* and
+	i[345]86*-*-unixware*.
+
+Mon Nov 27 13:44:15 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config-ml.in: Get list of multidirs using gcc --print-multi-lib
+	rather than basing it on the target.  Simplify handling of options
+	controlling which directories to configure.  Remove extraneous
+	slash in multi-clean target.
+
+Fri Nov 24 17:29:29 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* config-ml.in: Prefix more variables with ml_ so they don't collide
+	with configure's.
+
+Wed Nov 22 11:27:02 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Don't turn -v into --v.
+
+Tue Nov 21 16:48:02 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* configure.in (targargs): Fix typo.
+
+	* Makefile.in (DEVO_SUPPORT): Add symlink-tree.
+
+Tue Nov 21 14:08:28 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Strip --host and --target options from
+	CONFIG_ARGUMENTS, and always configure for --host only.  Add
+	--with-cross-host option when building with a cross-compiler.
+	* configure: Canonicalize the arguments put into config.status by
+	always using `=' for an option with an argument.  Pass a presumed
+	--host or --target explicitly.
+
+Fri Nov 17 17:50:30 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* config.sub: Merge -macos*, -magic*, -pe*, and -win32 cases
+	into general OS recognition case.
+
+Fri Nov 17 17:42:25 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (target_configdirs): add target-winsup only
+	for win32 target systems.
+
+Thu Nov 16 14:04:47 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (all-target-libgloss): Depend upon
+	configure-target-newlib, since when libgloss is built it looks to
+	see if the newlib directory exists.
+
+Wed Nov 15 14:47:52 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Use config-ml.in instead of
+	cfg-ml-*.in.
+
+Wed Nov 15 11:45:23 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Handle LD and LD_FOR_TARGET when configuring a
+	Canadian Cross.
+
+Tue Nov 14 14:56:11 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (target_libs): add target-winsup.
+	(target==i386-win32): add patch diff flex make to $noconfigdirs.
+	(target==ppcle-pe): remove ld from $noconfigdirs.
+
+Tue Nov 14 01:25:50 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* Makefile.in (CONFIGURE_TARGET_MODULES): Pass --with-target-subdir.
+	Preserve relative path names in $srcdir.  Build symlink tree if
+	configuring cross target dir and srcdir=. (= no VPATH support).
+	(configure-target-libg++): Depend on configure-target-librx.
+	* cfg-ml-com.in, cfg-ml-pos.in: Deleted.
+	* config-ml.in: New file.
+	* symlink-tree: New file.
+	* configure: Ensure srcdir="." if that's what it is.
+
+Mon Nov 13 12:34:20 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-README: Clarify some phrasing, add notes about CodeWarrior
+	includes and FLEX_SKELETON setting.
+	* mpw-configure (--with-gnu-ld): New option, controls whether
+	to use PPCLink or ld with PowerMac GCC.
+	* mpw-build.in (all-grez, do-grez, install-grez): New targets.
+	* mpw-config.in: Configure grez if targeting Mac.
+
+	* config.sub: Accept pmac and pmac-mpw as names for PowerMacs,
+	accept mpw and mac-mpw as names for m68k Macs, change macos7 to
+	just macos.
+	* configure.in: Configure grez resource compiler if targeting Mac.
+	* Makefile.in (all-grez, install-grez): New targets.
+
+Wed Nov  8 17:33:51 1995  Jason Merrill  <jason@yorick.cygnus.com>
+
+	* configure: CXX defaults to gcc, not g++.  If we find
+	gcc in the path, set CC to gcc -O2.
+
+Tue Nov  7 15:45:17 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Default ${build} correctly.  Avoid picking up extra
+	spaces when reading CC and CXX from Makefile.  When doing a
+	Canadian Cross, use plausible default values for numerous
+	variables.
+	* configure.in: When doing a Canadian Cross, don't try to
+	configure tools whose configure script can't handle it.
+
+Mon Nov  6 19:32:17 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* cfg-ml-com.in (sh-*-*): Add m2 and ml/m2 to multidirs.
+
+Sun Nov  5 00:15:41 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure:  Remove dubious bug reporting address.
+
+Fri Nov  3 08:17:54 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in ($(CONFIGURE_TARGET_MODULES)):  If subdir has
+	configure script, run that instead of this directory's configure.
+	In either case, print a message that we're configuring the sub-dir.
+
+Thu Nov  2 23:23:36 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in: Before checking for the existence of various files,
+	use sed to filter out "target-".
+
+Thu Nov  2 13:24:56 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DO_X): Split rule to decrease command line length
+	for systems with small ARG_MAX values.  From phdm@info.ucl.ac.be
+	(Philippe De Muyter).
+
+Wed Nov  1 15:18:35 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (all-patch): depend on all-libiberty.
+
+Wed Nov  1 12:23:20 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: If the only directory in target_configdirs which
+	actually exists is libiberty, then set target_configdirs to empty,
+	to avoid trying to build a target libiberty in a gas or gdb
+	distribution.
+
+Tue Oct 31 17:52:39 1995  J.T. Conklin  <jtc@slave.cygnus.com>
+
+	* configure.in (host_makefile_frag): Use m68k-sun-sunos* instead
+	of m68k-sun-* when selecting mh-sun3 to avoid matching NetBSD/sun3
+	systems.
+
+Tue Oct 31 16:57:32 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* configure.in (copy_dirs): Use sys-include instead of include
+	for --with-headers option.
+
+Tue Oct 31 10:29:36 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* Makefile.in, configure.in: Make winsup builds work with
+	new scheme.
+
+Mon Oct 30 18:57:09 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Build the linker on AIX.
+
+Mon Oct 30 12:27:16 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (CC_FOR_TARGET, CXX_FOR_TARGET):  Add $(TARGET_SUBDIR)
+	where needed.
+
+Mon Oct 30 12:45:25 1995  Doug Evans  <dje@cygnus.com>
+
+	* Makefile.in (all-gcc): Fix typo.
+
+Sat Oct 28 10:27:59 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in ($(CHECK_TARGET_MODULES)):  Fix typo.
+
+Fri Oct 27 23:14:12 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in:  Rename libFOO to target-libFOO, and xiberty
+	to target-xiberty, to provide more flexibility.
+	(target_subdir):  Define.  Create if cross.
+	Set TARGET_SUBDIR in Makefile to ${target_subdir}.
+	* Makefile.in:  Rename all-libFOO -> all-target-libFOO, all-xiberty
+	-> all-target-libiberty, configure-libFOO -> configure-target-libFOO,
+	check-libFOO -> check-target-libFOO, etc.
+	($(DO_X)):  Iterate over TARGET_CONFIGDIRS after SUBDIRS.
+	($(CONFIGURE_TARGET_MODULES), $(CHECK_TARGET_MODULES),
+	$(ALL_TARGET_MODULES), $(INSTALL_TARGET_MODULES)): Update accordingly.
+	(configure-target-XXX):  Depend on $(ALL_GCC), not all-gcc, to
+	allow ALL_GCC="" to only configure.
+	(DEVO_SUPPORT):  Add cfg-ml-com.in and cfg-ml-pos.in.
+	(ETC_SUPPORT, ETC_SUPPORT_PFX):  Merge;  update 'taz' accordingly.
+	(LIBGXX_SUPPORT_DIRS):  Remove xiberty.
+
+Sat Oct 28 01:53:49 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* Makefile.in (taz): Build "info" in etc explicitly.
+
+Fri Oct 27 09:32:30 1995  Stu Grossman  (grossman@cygnus.com)
+
+	* configure.in:  Make sure that CC is undefined (as opposed to
+	null) if toplevel/config/mh-{host} doesn't define it.  Fixes a
+	problem with autoconf trying to configure on a host without GCC.
+
+Thu Oct 26 22:35:01 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Set host alias from choice of host compiler,
+	only use generic MPW Makefile sed if present, edit a file
+	named "hacked_Makefile.in" instead of "Makefile.in" if present.
+	* mpw-README: Add problem notes about CW6 and CW7.
+
+Thu Oct 26 05:45:10 1995  Ken Raeburn  <raeburn@kr-pc.cygnus.com>
+
+	* Makefile.in (taz): Use ";" instead of ";;".
+
+Wed Oct 25 15:18:24 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (taz):  Grep for '^diststuff:' or '^info:' in
+	sub-directory Makefiles, instead of using DISTSTUFFDIRS and
+	DISTDOCDIRS.
+	(DISTSTUFFDIRS, DISTDOCDIRS):  Removed - no longer used.
+	(newlib.tar.gz):  Don't pass DISTDOCDIRS to recursive make.
+
+Wed Oct 25 14:43:55 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (DISTDOCDIRS):  Remove ld gprof bnutils gas libg++ gdb
+	and gnats, because they are now subsumed by DISTSTUFFDIRS.
+	Move bfd to DISTSTUFFDIRS.
+
+Tue Oct 24 18:19:09 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (X11_LIB): Removed.
+	(X11_FLAGS_TO_PASS): pass only X11_EXTRA_CFLAGS and X11_EXTRA_LIBS.
+
+	* configure.in (host_makefile_frag): mh-aix & mh-sun removed.
+
+Sun Oct 22 13:04:42 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*): Shorten some of the multilib directory
+	names.
+
+Fri Oct 20 18:02:10 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*-eabi*): Add mcall-aixdesc varients.
+
+Thu Oct 19 10:40:57 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in (i[345]86-*-win32): Always build newlib.
+	Don't configure cvs, autoconf or texinfo.
+	* Makefile.in (LD_FOR_TARGET): New.
+	(BASE_FLAGS_TO_PASS, EXTRA_TARGET_FLAGS, CONFIGURE_TARGET_MODULES):
+	Pass down LD_FOR_TARGET.
+
+Wed Oct 18 15:53:56 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* winsup: New directory.
+	* Makefile.in: Build winsup.
+	* configure.in: Winsup is configured when target is win32.
+	Can only build win32 target GDB when native.
+
+Mon Oct 16 09:42:31 1995  Jeffrey A Law  (law@cygnus.com)
+
+	* config.guess: Recognize HP model 819 machines as having
+	a PA 1.1 processor.
+
+Mon Oct 16 10:49:43 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Fix sed loop which substitutes for CC and CXX to
+	avoid bug found in various sed implementations.
+
+Wed Oct 11 16:16:20 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc-*-eabisim): Delete separate rule for
+	simulator.  Use standard powerpc-*-eabi*.
+
+Mon Oct  9 17:21:56 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Stop putting gas and binutils in noconfigdirs for
+	powerpc-*-aix* and rs6000-*-*.
+
+Mon Oct  9 12:38:40 1995  Michael Meissner  <meissner@cygnus.com>
+
+	* cfg-ml-com.in (powerpc*-*-eabisim*): Add support for building
+	-mcall-aixdesc libraries.
+
+Fri Oct  6 16:17:57 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	Mon Sep 25 22:49:32 1995  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>
+
+	* config.sub (arm | armel | armeb): Fix shell syntax.
+
+Fri Oct  6 14:40:28 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in ({powerpc,rs6000}-ibm-aix*): Add multilibs for
+	-msoft-float and -mcpu=common support.
+	(powerpc*-*-eabisim*): Add support for building -mcall-aix
+	libraries.
+
+Thu Oct  5 13:26:37 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: Allow configuration and build of emacs19 for the alpha.
+
+Wed Oct  4 22:05:36 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (CC): Get ^CC, not just any old CC, from
+	${host_makefile_frag}.
+
+Wed Oct  4 21:55:00 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in (CC): Try to get CC from
+	${srcdir}/${host_makefile_frag}, not ${host_makefile_frag}.
+
+Wed Oct  4 21:44:12 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in (TARGET_CONFIGDIRS): configure targetdirs
+	only if it exists in $(srcdir).
+
+Wed Oct  4 11:52:31 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If CC and CXX are not set in the environment, set
+	them, based on either an existing Makefile or on searching for gcc
+	in PATH.  Substitute for CC and CXX in Makefile.
+	* configure.in: Remove libm from target_libs.  Separate
+	target_configdirs from configdirs.  If CC is not set in
+	environment, try to get it from a host Makefile fragment.  Rewrite
+	changes of configdirs to use skipdirs instead.  A few minor
+	tweaks.  Take directories out of target_configdirs as they are
+	taken out of configdirs.  Remove existing Makefile files from
+	subdirectories.  Substitute for TARGET_CONFIGDIRS and
+	CONFIG_ARGUMENTS in Makefile.
+	* Makefile.in (TARGET_CONFIGDIRS): New variable, automatically set
+	by configure.in.
+	(CONFIG_ARGUMENTS): Likewise.
+	(CONFIGURE_TARGET_MODULES): New variable.
+	($(DO_X)): Loop over TARGET_CONFIGDIRS as well as SUBDIRS.
+	($(CONFIGURE_TARGET_MODULES)): New target.
+	(configure-libg++, configure-libio): New targets.
+	(all-libg++): Depend upon configure-libg++.
+	(all-libio): Depend upon configure-libio.
+	(configure-libgloss, all-libgloss): New targets.
+	(configure-libstdc++): New target.
+	(all-libstdc++): Depend upon configure-libstdc++.
+	(configure-librx, all-librx): New targets.
+	(configure-newlib): New target.
+	(all-newlib): Depend upon configure-newlib
+	(configure-xiberty): New target.
+	(all-xiberty): Depend upon configure-xiberty.
+
+Sat Sep 30 04:32:59 1995  Jason Molenda (crash@phydeaux.cygnus.com)
+
+	* configure.in (host i[345]86-*-win32):  Expand the
+	noconfigdirs again.
+
+Thu Sep 28 21:18:49 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-configure: Fix sed command file name.
+
+Thu Sep 28 17:39:56 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in (host i[345]86-*-win32): Reduce the
+	noconfigdirs again.
+
+Wed Sep 27 12:24:00 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Don't configure ld and gdb for powerpc*-*-winnt*
+	or powerpc*-*-pe*, since they are not yet supported.
+
+Tue Sep 26 14:30:01 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	Add PowerMac support and many other enhancements.
+	* mpw-configure: New option --cc to select compiler to use,
+	paste options set according to --cc into the generated
+	Makefile, generate the Makefile by sed'ing the Unix Makefile.in
+	if mpw-make.sed is present.
+	* mpw-config.in: Don't test for gC1, test for mpw-touch,
+	add forward includes for PowerPC include files.
+	* mpw-build.in: Build using Makefile.PPC if present.
+	(do-byacc, etc): Remove separate version resource builds.
+	(do-gas): Build "stamps" before "all".
+	(do-gcc): Build "stamps-h" and "stamps-c" before "all".
+	* mpw-README: Update to reflect --cc option, PowerMac support,
+	and recently-reported compatibility problems.
+
+Fri Sep 22 12:15:42 1995  Doug Evans  <dje@deneb.cygnus.com>
+
+	* cfg-ml-com.in (m68*-*-*): Only build multilibs for
+	embedded m68k systems (-aout, -coff, -elf, -vxworks).
+	(--with-multilib-top): Pass to recursive invocations.
+
+Tue Sep 19 13:51:05 1995  J.T. Conklin  <jtc@blues.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable libg++ and libstdc++ on
+	v810-*-*.
+
+Mon Sep 18 23:08:26 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable bfd, binutils, gas, gcc,
+	gdb, ld and opcodes on v810-*-*.
+
+Tue Sep 12 18:03:31 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* Makefile.in (DO_X): Change do-realclean to do-maintainer-clean.
+	(local-maintainer-clean): New target.
+	(maintainer-clean): New target.
+	(realclean): Just depend upon maintainer-clean.
+
+Fri Sep  8 17:11:14 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Disable gdb on m68k-*-netbsd*.
+
+Fri Sep  8 16:46:29 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in: Build ld in mips*-*-bsd* case.
+
+Thu Sep  7 20:03:41 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* config.sub: Accept -lites* OS.  From Ian Dall.
+
+Fri Sep  1 08:06:58 1995  James G. Smith  <jsmith@beauty.cygnus.com>
+
+	* config.sub: recognise mips64vr4300 and mips64vr4300el as valid
+	targets.
+
+Wed Aug 30 21:06:50 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* configure.in: treat i386-win32 canadian cross the same as
+	i386-go32 canadian cross.
+
+Thu Aug 24 14:53:20 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*-*-eabisim): Add support for PowerPC
+	running under the simulator to build a reduced set of libraries.
+	(powerpc-*-eabiaix): Add fine grained multilib support added to
+	other powerpc targets yesterday.
+
+Wed Aug 23 09:41:56 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* cfg-ml-com.in (powerpc*): Add support for -disable-biendian,
+	-disable-softfloat, -disable-relocatable, -disable-aix, and
+	-disable-sysv to control which multilib libraries get built.
+
+Thu Aug 17 16:03:41 1995  Ken Raeburn  <raeburn@kr-laptop.cygnus.com>
+
+	* configure: Add Makefile.tem to list of files to remove in trap
+	handler.
+
+Mon Aug 14 19:27:56 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess (*Linux*):  Add missing "exit"s.
+	Also, need specific check for alpha-unknown-linux (uses COFF).
+
+Fri Aug 11 15:38:20 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Merge with FSF:
+
+	Wed Jun 28 17:57:27 1995  David Edelsohn  <edelsohn@mhpcc.edu>
+	* config.guess (AIX4): More robust release numbering discovery.
+
+	Thu Jun 22 19:01:24 1995  Kenneth Stailey  (kstailey@eagle.dol-esa.gov)
+	* config.guess (i386-sequent-ptx): Properly get version number.
+
+	Thu Jun 22 18:36:42 1995  Uwe Seimet  (seimet@iris1.chemie.uni-kl.de)
+	* config.guess (mips:*:4*:UMIPS): New case.
+
+Mon Aug  7 09:21:35 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in (i386-go32 host): Fix typo (deja-gnu -> dejagnu).
+	(i386-win32 host): Likewise.  Don't build readline.
+
+Sat Aug  5 09:51:49 1995  Fred Fish  <fnf@rtl.cygnus.com>
+
+	* Makefile.in (GDBTK_SUPPORT_DIRS):  Define and pass as part of
+	SUPPORT_FILES to submakes.
+
+Fri Aug  4 13:04:36 1995  Fred Fish  <fnf@cygnus.com>
+
+	* Makefile.in (GDB_SUPPORT_DIRS): Add utils.
+	(DEVO_SUPPORT): Add mpw-README, mpw-build.in, mpw-config.h and
+	mpw-configure.
+
+Wed Aug  2 16:32:40 1995  Ken Raeburn  <raeburn@cygnus.com>
+
+	* configure.in (appdirs): Use =, not ==, in test expression when
+	trying to build the text to print in the warning message for
+	Solaris users.
+
+Mon Jul 31 09:56:18 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* cfg-ml-com.in (z8k-*-coff): Add 'std' multilib build.
+
+Fri Jul 28 00:16:31 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* config.guess: Recognize lynx-2.3.
+
+Thu Jul 27 15:47:59 1995  steve chamberlain  <sac@slash.cygnus.com>
+
+	* config.sub (z8ksim): Deleted
+	(z8k-*-coff): New, this is the one true name of the target.
+
+Thu Jul 27 14:33:33 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* cfg-ml-pos.in (dotdot): Work around SunOS sed bug.
+
+Thu Jul 27 13:31:05 1995  Fred Fish  (fnf@cygnus.com)
+
+	* config.guess (*:Linux:*:*): First try asking the linker what the
+	default object file format is (elf, aout, or coff).  Then if this
+	fails, try previous methods.
+
+Thu Jul 27 11:28:17 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in: Don't build newlib for *-*-vxworks5.1.
+
+Thu Jul 27 11:18:47 1995  Brendan Kehoe  <brendan@lisa.cygnus.com>
+
+	* configure.in: Don't build newlib for a29k-*-vxworks5.1.
+	* test-build.mk: Add setting of --with-headers for a29k-vxworks5.1.
+
+Tue Jul 25 21:25:39 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* cfg-ml-pos.in (MULTITOP): Trim excess trailing "/.".
+
+Fri Jul 21 10:41:12 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* cfg-ml-com.in: New file.
+	* cfg-ml-pos.in: New file.
+
+Wed Jul 19 00:37:27 1995  Jeffrey A. Law  <law@rtl.cygnus.com>
+
+	* COPYING.NEWLIB: Add HP free copyright to list.
+
+Tue Jul 18 10:58:51 1995  Michael Meissner  <meissner@tiktok.cygnus.com>
+
+	* config.sub: Recognize -eabi* for the system, not just -eabi.
+
+Mon Jul  3 13:44:51 1995  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* Makfile.in (DLLTOOL_FOR_TARGET): New name, pass it down.
+	* config.sub, configure.in (win32): New target and host.
+
+Wed Jun 28 23:57:08 1995  Steve Chamberlain  <sac@slash.cygnus.com>
+
+	* configure.in: Add i386-pe configuration.
+
+Fri Jun 23 14:28:44 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-build.in (install): Install GDB after LD.
+
+Thu Jun 22 17:10:53 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	* mpw-config.in (elf/mips.h): Always forward-include, needed
+	for GDB to build.
+
+Wed Jun 21 15:17:30 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* testsuite: New directory for customer acceptance and whole tool
+	chain tests.
+
+Wed Jun 21 16:50:29 1995  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* configure: If per-host line isn't found, but AC_OUTPUT is found
+	and a configure script exists, run it instead.
+
+Thu Jun 15 21:09:24 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Update from FSF, for alpha-dec-winnt3.5 and  Crays.
+
+Tue Jun 13 21:43:27 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* configure: Set build_{cpu,vendor,os,alias} to host values when
+	--build isn't specified.
+
+Mon Jun  5 18:26:36 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* Makefile.in (PICFLAG, PICFLAG_FOR_TARGET): New macros.
+	(FLAGS_TO_PASS): Pass them.
+	(EXTRA_TARGET_FLAGS): Ditto.
+
+Wed May 31 22:27:42 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* Makefile.in (all-libg++): Depend on all-libstdc++.
+
+Thu May 25 22:40:59 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (noconfigdirs): Enable all packages for
+	  i386-unknown-netbsd.
+
+Sat May 20 13:22:31 1995  Angela Marie Thomas  <angela@cirdan.cygnus.com>
+
+	* configure.in (noconfigdirs): Don't configure tk for i386-go32
+	hosted builds (DOS builds)
+
+Thu May 18 18:08:49 1995  Ken Raeburn  <raeburn@kr-laptop.cygnus.com>
+
+	Changes for ARM based on patches from Richard Earnshaw:
+	* config.sub: Handle armeb and armel.
+	* configure.in: Omit arm linker only for riscix.
+
+Thu May 11 17:23:26 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Update from FSF.
+
+Tue May  9 15:52:05 1995  Michael Meissner  <meissner@cygnus.com>
+
+	* config.sub: Recognize powerpcle as the little endian varient of
+	the PowerPC.  Recgonize ppc as a PowerPC variant, and ppcle as a
+	powerpcle variant.  Convert pentium into i586, not i486.  Add p5
+	alias for i586.  Map new x86 variants p6, k5, nexgen into i586
+	temporarily.
+
+Tue May  2 16:29:41 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* configure.in (hppa*-*-lites*): Treat like hppa*-*-*elf*.
+
+Sun Apr 30 21:38:09 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* config.sub: Accept -lites* as a basic system type.
+
+Thu Apr 27 11:33:29 1995  Michael Meissner  (meissner@cygnus.com)
+
+	* config.guess (*:Linux:*:*): Check for whether the pre-BFD linker is
+	installed, and if so return linuxoldld as the system name.
+
+Wed Apr 26 10:59:02 1995  Jeff Law  (law@snake.cs.utah.edu)
+
+	* config.guess: Add hppa1.1-hp-lites support.
+
+Tue Apr 25 11:08:11 1995  Rob Savoye  <rob@darkstar.cygnus.com>
+
+	* configure.in: Don't build newlib for m68k-vxworks5.1.
+
+Wed Apr 19 17:02:43 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* configure.in (mips-sgi-irix6): Use mh-irix5.
+
+Fri Apr 14 15:21:17 1995  Doug Evans  <dje@chestnut.cygnus.com>
+
+	* Makefile.in (all-gcc): Depend on all-ld (for libgcc1-test).
+
+Wed Apr 12 16:06:01 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* test-build.mk: Enable building of shared libraries on IRIX 5 and
+	OSF/1.  Fix compiler flags.
+	* build-all.mk: Support Linux and OSF/1 3.0.  Fix compiler flags.
+
+Tue Apr 11 18:55:40 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* configure.in: Recognize --with-newlib.
+	(sparc-*-sunos4*): Build sim, dejagnu, expect, tcl if cross target.
+
+Mon Apr 10 14:38:20 1995  Jason Molenda (crash@phydeaux.cygnus.com)
+
+	* Makefile.in: move {all,check,install}-gdb from *_MODULES
+	to *_X11_MODULES due to gdbtk needing X include files et al.
+
+Mon Apr 10 11:42:22 1995  Stan Shebs  <shebs@andros.cygnus.com>
+
+	Merge in support for Mac MPW as a host.
+	(Old change descriptions retained for informational value.)
+
+	* mpw-config.in: Add generic include forwards for cpu-specific
+	include files in aout and elf directories.
+
+	* mpw-configure: Added copyright.
+	* mpw-config.in: Check for presence of required build tools.
+	(target_libs): Add newlib.
+	(target_tools): Add examples.
+	(Read Me): Generate as "Read Me for MPW" instead.
+	* mpw-build.in: Base sub-builds on all-foo instead of do-foo.
+	(all-byacc, do-byacc, all-flex, do-flex, do-newlib): New actions.
+	(do-gas, do-gcc, do-gdb, do-ld): Build Version.r first.
+
+	* mpw-configure: Remove subdir-specific makefile hackery,
+	delete mk.tmp after using it.
+
+	* mpw-build.in (all): Display start and end times.
+
+	* mpw-configure (host_canonical): Set.
+	(target_cpu): Always add to makefiles.
+	(ARCHDEFS, EMUL): Add to makefile only if nonempty.
+	(TM_FILE, XM_FILE, NM_FILE): No longer add to makefile.
+	(mpw-mh-mpw): Look for in srcdir and srcroot.
+	Use sed instead of mpw-edit-prefix to edit prefix definitions.
+
+	* mpw-build.in: (install-only): New target.
+
+	* mpw-configure (host_alias, target_alias): Rename from hostalias
+	and targetalias, add into generated Makefile.
+	(mk.tmp): If present, add into generated Makefile.
+	* mpw-build.in (all-gas): Build config.h first before gas proper.
+
+	* mpw-configure (config.status): Write only if changed.
+	* mpw-config.in (readline): Configure it (not built, just used for
+	definitions).
+
+	* mpw-config.in (elf/mips.h): Add a forward include.
+
+	* mpw-config.in: Forward-include most .h files in include into
+	extra-include.
+	(readline): Don't build.
+	mpw-build.in (install): Install GDB.
+
+	* mpw-configure (prefix, mpw_prefix): Handle it.
+	* mpw-config.in (mmalloc, readline): Don't configure.
+	* mpw-build.in (thisscript): Rename to ThisScript.
+	Use mpw-build instead of BuildProgram everywhere.
+	(mmalloc, readline): Don't build.
+	* mpw-README: New file, basic documentation about the MPW port.
+
+	* mpw-config.in: Use forward-include to create include files.
+
+	* mpw-configure: Add more things to the top of each configured
+	Makefile, including contents of config/mpw-mh-mpw.
+	* mpw-config.in (extra-include): Create this directory and fill it
+	with Posix-like include files when configuring.
+
+	* config.sub (apple, mac, mpw): Add various aliases.
+
+	* mpw-build.in: New file, top-level build script fragment for MPW.
+	* mpw-configure: New file, configure script for MPW.
+	* mpw-config.in: New file, config fragment for MPW.
+
+Fri Apr  7 19:33:16 1995  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in (host_libs): Remove glob, since it is gone from the
+	sources.
+
+Fri Mar 31 11:36:17 1995  Jason Molenda  (crash@phydeaux.cygnus.com)
+
+	* Makefile.in: define empty GDB_NLM_DEPS var.
+
+	* configure.in(target_makefile_frag): use config/mt-netware
+	for netware targets.
+
+Thu Mar 30 13:51:43 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* config.sub: Merge in recent FSF changes.  Remove linux special
+	cases.
+
+Tue Mar 28 14:47:34 1995  Jason Molenda (crash@phydeaux.cygnus.com)
+
+	Revert this change:
+
+	Tue Mar 30 10:03:09 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+		* build-all.mk: Use CC=cc -Xs on Solaris.
+
+Tue Mar 21 10:43:32 1995  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* glob/*: Removed.  Schauer's 24 Feb 1994 readline change made us
+	stop using it.
+	* Makefile.in: Nuke all references to glob subdirectory.
+
+Thu Mar 16 13:35:30 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* configure.in: Fix --enable-shared logic in per-host.
+
+Mon Mar 13 12:33:15 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure.in (*-hp-hpux[78]*): Use mh-hpux8.
+
+Mon Mar  6 10:21:58 1995  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in (noconfigdirs): Don't build gas on AIX, for
+	powerpc*-*-aix* as well as for rs6000*-*-aix*.
+
+Wed Mar  1 12:51:53 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: Fix --cache-file to work if the file argument is a
+	relative path.
+
+Tue Feb 28 17:36:07 1995  Ian Lance Taylor  <ian@cygnus.com>
+
+	* configure: If the --cache-file is used, pass it down to
+	configure in subdirectories.
+
+Mon Feb 27 12:52:46 1995  Kung Hsu  <kung@mexican.cygnus.com>
+
+	* config.sub: add vxworks29k configuration.
+
+Fri Feb 10 16:12:26 1995  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (taz): Do "diststuff" part quietly.
+
+Sun Feb  5 14:16:35 1995  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: Mini-merge with gcc/config.sub.
+
+Sat Feb  4 12:11:35 1995  Jim Wilson  <wilson@chestnut.cygnus.com>
+
+	* config.guess (IRIX): Sed - to _.
+
+Fri Feb  3 11:54:42 1995  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* Makefile.in (source-vault, binary-vault): New targets.
+
+Thu Jan 26 13:00:11 1995  Michael Meissner  <meissner@cygnus.com>
+
+	* config.sub: Recognize -eabi as a basic system type.
+
+Thu Jan 12 13:13:23 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* configure.in (enable_shared stuff): Fix typo.
+
+Thu Jan 12 01:36:51 1995  deanm@medulla.LABS.TEK.COM (Dean Messing)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): Fix typo in passing LIBCXXFLAGS*.
+
+Wed Jan 11 16:29:53 1995  Jason Merrill  <jason@phydeaux.cygnus.com>
+
+	* Makefile.in (LIBCXXFLAGS_FOR_TARGET): Add -fno-implicit-templates.
+
+Mon Jan  9 12:48:01 1995  Jim Kingdon  <kingdon@lioth.cygnus.com>
+
+	* configure.in (rs6000-*-*): Don't build gas.
+
+Wed Jan  4 23:53:49 1995  Ian Lance Taylor  <ian@tweedledumb.cygnus.com>
+
+	* Makefile.in: Use /x/x/ instead of /brokensed/brokensed/, to
+	reduce command line length.
+	(AS_FOR_TARGET): Check for as.new, not Makefile.
+	(NM_FOR_TARGET): Check for nm.new, not Makefile.
+
+Wed Jan  4 13:02:39 1995  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* config.guess:  Merge from FSF.
+
+Thu Dec 15 17:11:37 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* configure: Don't use $ when handling program_suffix.
+
+Mon Dec 12 12:09:37 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* configure.in:  Configure tk for hppa/hpux.
+
+Fri Dec  2 15:55:38 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in (LIBGXX_SUPPORT_DIRS):  Add libstdc++.
+
+Tue Nov 29 19:37:56 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* Makefile.in:  Move -fno-implicit-template from CXXFLAGS
+	to LIBCXXFLAGS.  Tests are better run without it.
+
+Wed Nov 23 10:29:25 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* Makefile.in (all-ispell): Depend on all-emacs19 instead of all-emacs.
+
+Mon Nov 21 11:14:01 1994  J.T. Conklin  <jtc@rtl.cygnus.com>
+
+	* configure.in (*-*-netware*): Don't configure xiberty.
+
+Mon Nov 14 08:49:15 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* configure.in:  Remove tk from native_only list.
+
+Fri Nov 11 15:31:26 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* build-all.mk: Add mips-ncd-elf target to sun4 targets
+	  for special NCD build.
+
+Mon Nov  7 20:58:17 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Remove configure.bat and
+	makeall.bat, they're only useful for binutils snapshots.
+	(binutils.tar.gz, gas+binutils.tar.gz): Add configure.bat and
+	makeall.bat to specified SUPPORT_FILES.
+
+Mon Nov  7 17:25:18 1994  Bill Cox  (bill@cirdan.cygnus.com)
+
+	* build-all.mk: Add Ericsson targets to sun4 and solaris
+	  hosts.  Add  BNR's sun4 target to solaris host, so their
+	  build-from-source will be tested in-house first.
+
+Sat Nov  5 18:43:30 1994  Jason Merrill  (jason@phydeaux.cygnus.com)
+
+	* Makefile.in (LIBCFLAGS): New variable.
+	(CFLAGS_FOR_TARGET): Ditto.
+	(LIBCFLAGS_FOR_TARGET): Ditto.
+	(LIBCXXFLAGS): Ditto.
+	(CXXFLAGS_FOR_TARGET): Ditto.
+	(LIBCXXFLAGS_FOR_TARGET): Ditto.
+	(BASE_FLAGS_TO_PASS): Pass them.
+	(EXTRA_TARGET_FLAGS): Ditto.
+
+	* configure.in: Support --enable-shared.
+
+Sat Nov  5 15:44:00 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in (target_libs):  Include libstdc++ again.
+	* config.guess:  Update from FSF (for FreeBSD).
+
+Thu Nov  3 16:32:30 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (DEVO_SUPPORT): Include configure.bat and
+	makeall.bat.
+	(DISTDOCDIRS): Add `etc'.
+	(ETC_SUPPORT_PFX): New variable.
+	(taz): Include anything from etc starting with a word in
+	ETC_SUPPORT_PFX.
+
+Wed Oct 26 16:19:35 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* config.sub: Update for recent FSF changes.  Remove obsolete
+	h8300hds entry.  Add -windows* and -osx as basic os.  Minor
+	spacing changes.
+
+Thu Oct 20 18:41:56 1994  Per Bothner  <bothner@kalessin.cygnus.com>
+
+	* configure.in (target_libs):  Remove libstdc++ for libg++-2.6.1.
+
+	* config.guess:  Merge with FSF.
+	* configure.in:  Match on i?86-ncr-sysv4.3, not i?86-ncr-sysv43.
+
+Thu Oct 20 19:26:56 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* configure: Since the "trap 0" handler will override the exit
+	status on many systems, only use it for "exit 1", and make it set
+	a non-zero exit status; reset it before "exit 0".  Also, check
+	exit status of config.sub, and error out if it failed.
+
+Wed Oct 19 18:49:55 1994  Rob Savoye  (rob@cygnus.com)
+
+	* Makefile.in: (ALL_TARGET_MODULES,INSTALL_TARGET_MODULES) Build
+	and install libgloss.
+
+Tue Oct 18 15:25:24 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* Makefile.in (all-binutils): Depend upon all-byacc.
+
+	* configure.in: Don't build emacs on Irix 5.
+
+Mon Oct 17 16:22:12 1994  J.T. Conklin  (jtc@phishhead.cygnus.com)
+
+	* configure.in (*-*-netware*): Add libio.
+
+Thu Oct 13 15:51:20 1994  Jason Merrill  (jason@phydeaux.cygnus.com)
+
+	* Makefile.in (ALL_TARGET_MODULES): Add libstdc++.
+	(CHECK_TARGET_MODULES): Ditto.
+	(INSTALL_TARGET_MODULES): Ditto.
+	(TARGET_LIBS): Ditto.
+	(all-libstdc++): Note dependencies.
+
+Thu Oct 13 01:43:08 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (BINUTILS_SUPPORT_DIRS): Add gas.
+
+Tue Oct 11 12:12:29 1994  Jason Merrill  (jason@phydeaux.cygnus.com)
+
+	* Makefile.in (CXXFLAGS): Use -fno-implicit-templates instead of
+	-fexternal-templates.
+
+	* configure.in (target_libs): Add libstdc++.
+	(noconfigdirs): Add libstdc++ as appropriate.
+
+Thu Oct  6 18:00:54 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Update from FSF.
+
+Tue Oct  4 12:05:42 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* configure: Use ${config_shell} when running ${configsub}.
+
+Mon Oct  3 14:28:34 1994  Doug Evans  <dje@canuck.cygnus.com>
+
+	* config.sub: No longer recognize h8300h.
+
+Mon Oct  3 12:40:54 1994  Ian Lance Taylor  <ian@sanguine.cygnus.com>
+
+	* config.sub: Remove extraneous differences between config.sub and
+	gcc/config.sub.
+
+Sat Oct  1 00:23:12 1994  Ken Raeburn  <raeburn@cujo.cygnus.com>
+
+	* Makefile.in (DISTSTUFFDIRS): Add gas.
+
+Thu Sep 22 19:04:55 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* COPYING.NEWLIB: New file.
+
+Mon Sep 19 18:25:40 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (HP-UX):  Patch from Harlan Stenn
+	<harlan@landmark.com> to also emit release level.
+
+Wed Sep  7 13:15:25 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* config.guess (sun4*:SunOS:*:*): Change '-JL' to '_JL'.
+
+Tue Sep  6 23:23:18 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Merge nextstep cleanup from FSF.
+
+Mon Sep  5 05:01:30 1994  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure.in (arm-*-*): Don't configure ld for this target.
+
+Thu Sep  1 09:35:00 1994  J.T. Conklin  (jtc@phishhead.cygnus.com)
+
+	* configure.in (*-*-netware): don't configure libg++, libio,
+	  librx, or newlib.
+
+Wed Aug 31 13:52:08 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure.in (alpha-dec-osf*): Use osf*, not osf1*.  Don't
+	configure ld--it works, but it doesn't support shared libraries.
+
+Sun Aug 28 18:13:45 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (*-unknown-freebsd*):  Get rid of possible
+	trailing "(Release)" in version string.
+	Patch from Paul Richards <paul@isl.cf.ac.uk>.
+
+Sat Aug 27 15:00:49 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Fix i486-ncr-sysv43 -> i486-ncr-sysv4.3.
+	Fix type: *-next-neststep -> *-next-nextstep.
+
+	* config.guess:  Merge from FSF:
+
+	Fri Aug 26 18:45:25 1994  Philippe De Muyter (phdm@info.ucl.ac.be)
+
+	* config.guess: Recognize powerpc-ibm-aix3.2.5.
+
+	Wed Apr 20 06:36:32 1994  Philippe De Muyter  (phdm@info.ucl.ac.be)
+
+	* config.guess: Recognize UnixWare 1.1 (UNAME_SYSTEM is SYSTEM_V
+	instead of UNIX_SV for UnixWare 1.0).
+
+Sat Aug 27 01:56:30 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* Makefile.in (all-gdb):  Add dependencies on all-gcc and all-ld
+	to make gdb/nlm/* build after the compiler and linker.
+
+Fri Aug 26 14:30:05 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (netbsd, freebsd, linux):  Accept any machine,
+	not just i[34]86.
+	(m68k-atari-sysv4):  Relocate to match FSF version.
+
+	* config.guess:  More merges from the FSF:
+
+	Add a space before function call or macro invocation.
+
+	Tue May 10 16:53:55 1994  Roland McGrath (roland@churchy.gnu.ai.mit.edu)
+
+	* config.guess: Add trap cmd to remove dummy.c and dummy when
+	interrupted.
+
+	Wed Apr 20 18:07:13 1994  Roland McGrath (roland@churchy.gnu.ai.mit.edu)
+
+	* config.guess (dummy.c): Redirect stderr for `hostinfo' command.
+	(dummy): Redirect stderr from compilation of dummy.c.
+
+	Sat Apr  9 14:59:28 1994  Christian Kranz  (kranz@sent5.uni-duisburg.de)
+
+	* config.guess: Distinguish between NeXTStep 2.1 and 3.x.
+
+Fri Aug 26 13:42:20 1994  Ken Raeburn  (raeburn@kr-laptop.cygnus.com)
+
+	* configure: Accept and ignore --cache*, for compatibility with
+	new autoconf.
+
+Fri Aug 26 13:05:27 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Merge from FSF:
+
+	Thu Aug 25 20:28:51 1994  Richard Stallman  <rms@mole.gnu.ai.mit.edu>
+
+	* config.guess (Pyramid*:OSx*:*:*): New case.
+	(PATH): Add /.attbin at end for finding uname.
+	(dummy.c): Handle i860-alliant-bsd.  Follow whitespace conventions.
+
+	Wed Aug 17 18:21:02 1994  Tor Egge  (tegge@pvv.unit.no)
+
+	* config.guess (M88*:DolphinOS:*:*): New case.
+
+	Thu Aug 11 17:00:13 1994  Stan Cox  (coxs@dg-rtp.dg.com)
+
+	* config.guess (AViiON:dgux:*:*): Use TARGET_BINARY_INTERFACE
+	to select whether to use ELF or COFF.
+
+	Sun Jul 24 16:20:53 1994  Richard Stallman  <rms@mole.gnu.ai.mit.edu>
+
+	* config.guess: Recognize i860-stardent-sysv and i860-unknown-sysv.
+
+	Sun May  1 10:23:10 1994  Richard Stallman  (rms@mole.gnu.ai.mit.edu)
+
+	* config.guess: Guess the OS version for HPUX.
+
+	Tue Mar  1 21:53:03 1994  Karl Heuer  (kwzh@hal.gnu.ai.mit.edu)
+
+	* config.guess (UNAME_VERSION): Recognize aix3.2.4 and aix3.2.5.
+
+Fri Aug 26 11:19:08 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure.in: Recognize --with-headers, --with-libs, and
+	--without-newlib.
+	* Makefile.in (all-xiberty): Depend upon all-ld.
+
+Wed Aug 24 12:36:50 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure.in: Change i[34]86 to i[345]86.
+
+Mon Aug 22 10:58:33 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure (version): A few more tweaks to help message.
+
+Fri Aug 19 12:40:25 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in:  Remove (for now) librx as a host library,
+	now that we're building it for target.
+
+Fri Aug 19 10:49:17 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure: Fix up help message; from karl@owl.hq.ileaf.com
+	(Karl Berry).
+
+Tue Aug 16 16:11:08 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure.in:  Also configure librx.
+
+Mon Aug 15 16:51:45 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in:  Update various rules to reflect that librx
+	is now needed for libg++.
+
+Fri Aug 12 18:07:21 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* config.sub: Accept mips64orion and mips64orionel as a CPU name.
+
+Mon Aug  8 11:36:17 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* configure.in: Configure the examples directory.
+
+Thu Aug  4 16:12:36 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure: Simplify Jun 2 1994 change.
+
+Wed Aug  3 04:58:16 1994  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* change CC to /usr/latest/bin/gcc for lynx host builds, since
+	/bin/gcc isn't good enough to build gcc.
+
+Wed Jul 27 09:07:14 1994  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (GDB_SUPPORT_FILES): Remove
+	(setup-dirs-gdb, gdb.tar.gz, make-gdb.tar.gz):  Remove old rules.
+	(gdb.tar.gz): Add new rule to use standard distribution building
+	mechanism.
+
+Mon Jul 25 11:10:06 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Warn about use of /usr/ucb/cc on Solaris.  From
+	Bill Cox <bill@cygnus.com>.
+
+Sat Jul 23 12:19:46 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Recognize ISC.  Patch from kwzh@gnu.ai.mit.edu.
+
+Fri Jul 22 17:53:59 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* configure:  Search current dir first in .gdbinit.
+
+Fri Jul 22 11:28:30 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Recognize freebsd (merged from gcc config.sub).
+
+Thu Jul 21 14:10:52 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Refer to NeXT's operating system as nextstep.
+
+	* config.sub (case $basic_machine):  Re-order the cases, to match
+	the order in the FSF version (which is mostly alphabethical).
+	Merge in some additions and changes from the FSF.
+
+Sat Jul 16 12:03:08 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* config.guess: Recognize m68k-atari-sysv4 and m88k-harris-csux7.
+	* config.sub: Recognize cxux7.
+	* configure.in: Use mh-cxux for m88k-harris-cxux*.
+
+Mon Jul 11 14:37:39 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.sub:  Fix typo powerpc -> powerpc-*.
+
+Sat Jul  9 13:03:43 1994  Michael Tiemann  (tiemann@blues.cygnus.com)
+
+	* Makefile.in: `all-emacs19' depends on `all-byacc'.
+
+	* Makefile.in: Add all-emacs19 and install-emacs19 rules (in
+	parallel with all-emacs and install-emacs).  Top-level command
+	`make all-emacs19 CC=gcc' now behaves as `make all-emacs CC=gcc'.
+
+Thu Jun 30 16:53:42 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* test-build.mk ($(host)-stamp-stage2-installed): Remove
+	$(relbindir)/make before doing ``make install'', and use
+	$(GNU_MAKE) while doing it.  Avoids problem on SunOS with
+	installing over running make binary.
+	($(host)-stamp-stage3-installed): Likewise.
+
+Tue Jun 28 13:43:25 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize Mach.
+
+Mon Jun 27 16:41:14 1994  Ian Lance Taylor  (ian@sanguine.cygnus.com)
+
+	* configure: Check ${exec_prefixoption}, not ${exec_prefix}, to
+	see whether --exec-prefix was used.
+
+Sun Jun 26 21:15:54 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* README:  Explicitly mention libg++/README.  (Zoo's idea.)
+
+Tue Jun 21 12:45:55 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Add all-librx target similar to all-libproc.
+
+Wed Jun  8 23:11:55 1994  Stu Grossman  (grossman@cygnus.com)
+
+	* config.guess:  Rearrange tests for Alpha-OSF1 to properly deal
+	with post 1.2 uname bogosity.
+
+Thu Jun  9 00:27:59 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure: Remove temporary files on receipt of a signal.
+
+Tue Jun  7 12:06:24 1994  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: If there is a package_makefile_frag, remove
+	${subdir}/Makefile.tem after copying it in.
+
+Mon Jun  6 21:35:02 1994  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* build_all.mk: support rs6000 lynx identifies itself as
+	rs6000-lynx-lynxos2.2.2.  Also, use /usr/cygnus/progressive/bin/gcc
+	since /bin/gcc is too feeble to compile a modern gcc.
+
+Mon Jun  6 16:06:34 1994  Karen Christiansen (karen@cirdan.cygnus.com)
+
+	* brought devo/test-build.mk update-to-date with progressive/
+	  test-build.mk. Add lynx targets and hppa flag info.
+
+Sat Jun  4 17:23:54 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure.in:  Use mh-ncrsvr43.  Patch from
+	Tom McConnell <tmcconne@sedona.intel.com>.
+
+Fri Jun  3 17:47:24 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess (i386-unknown-bsdi):  No longer need to
+	check #if defined(__bsdi__) && defined(__i386__).
+
+Thu Jun  2 18:56:46 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure: Set program_transform_nameoption correctly.
+
+Thu Jun  2 10:57:06 1994  Karen Christiansen (karen@cirdan.cygnus.com)
+
+	* brought build-all.mk update-to-date with progressive build-all.mk,
+	  added new targets and hppa info.
+
+Thu Jun  2 00:12:44 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure: If config.guess result is a prefix of the user
+	specified target, assume a native build and use the user specified
+	target as the host alias.  Remove SunOS patch suffix removal hack.
+	* configure.in: Remove SunOS patch suffix removal hack.
+
+	* Makefile.in (CROSS_CHECK_MODULES): Remove check-flex, since it's
+	in NATIVE_CHECK_MODULES.
+
+Wed Jun  1 10:49:41 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* Makefile.in: Rename HOST_ONLY to NATIVE.
+	* configure: Delete SunOs patch suffix from host_canonical
+	  and build_canonical variables that are prepended to Makefiles.
+	* configure.in: Add comments for easier maintenance.
+
+Tue May 31 19:39:47 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Add all-libproc target similar to all-gui.
+
+Tue May 31 17:16:33 1994  Tom Lord  (lord@cygnus.com)
+
+	* Makefile.in (CHECK_MODULES): split into
+	HOST_ONLY_CHECK_MODULES and CROSS_CHECK_MODULES.
+
+Tue May 31 16:36:36 1994  Paul Eggert  (eggert@twinsun.com)
+
+	* config.guess (i386-unknown-bsdi): New system to guess.
+
+Wed May 25 16:47:10 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Add all-gui target (but not yet build by "all").
+
+Thu May 26 08:53:19 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* config.sub: Move deletion of patch suffix from here...
+	* configure.in: To here, at Ian's suggestion.  The top-
+	  level scripts might need to know of a patch level.
+
+Wed May 25 09:15:54 1994  Bill Cox  (bill@rtl.cygnus.com)
+
+	* config.sub: Strip off patch suffix so rtl is recognized
+	  as a sunos4.1.3 machine, even though it's been patched.
+
+Fri May 20 08:25:49 1994  Steve Chamberlain  (sac@deneb.cygnus.com)
+
+	* Makefile.in (INSTALL_LAST): Delete.
+	(INSTALL_DOSREL): New.
+
+Thu May 19 17:12:12 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Use ld for i[34]86-*-sysv4* and sparc-*-solaris2*.
+	Don't set use_gnu_ld to no for *-*-sysv4; that only controls
+	whether we pass down --with-gnu-ld anyhow.
+
+Thu May 19 09:29:12 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* Makefile.in (INSTALL_LAST): Change operation so it works
+	on more flavors of make.
+	* configure.in (go32): Don't build libg++ or libio.
+
+Fri May 13 13:28:34 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* Makefile.in (Move HOST_PREFIX_1 and friends up so
+	they can be overriden by templates.
+
+Sat May  7 16:46:44 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* configure.in (target==go32): Don't build gdb.
+	* dosrel: New directory.
+
+Fri May  6 14:19:25 1994  Steve Chamberlain  (sac@cygnus.com)
+
+	* configure.in (host==go32): Configure dosrel too.
+	* Makefile.in (INTALL_TARGET): Call INSTALL_LAST last.
+	(HOST_CC, HOST_PREFIX, HOST_PREFIX_1): Undefine, they should
+	be set by incoming names or templates.
+	(INSTALL_LAST): New rule.
+
+Thu May  5 17:35:05 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* config.sub (sparclitefrw, sparclitefrwcompat): Don't set the os.
+
+Thu May  5 20:06:45 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure.in (appdirs): New variable.  Currently empty, but will
+	be used in gas distribution.  If nonempty, lists a set of
+	directories at least one of which must get configured, or top
+	level configuration is considered to have failed.
+	(rs6000-*-lynxos*): Use new file name.
+
+Thu May  5 13:38:36 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	Eliminate XTRAFLAGS.
+	* Makefile.in (CC_FOR_TARGET): If newlib exists, refer to the
+	newlib include files using -idirafter, and also use -nostdinc.
+	(CXX_FOR_TARGET): Likewise.
+	(XTRAFLAGS): Removed.
+	(BASE_FLAGS_TO_PASS): Remove XTRAFLAGS_FOR_TARGET.
+	(EXTRA_HOST_FLAGS): Remove XTRAFLAGS.
+	(EXTRA_TARGET_FLAGS, EXTRA_GCC_FLAGS): Likewise.
+	($(DO_X)): Don't pass down XTRAFLAGS.
+
+Thu May  5 00:16:36 1994  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure.in (mips*-dec-bsd*): New target; do build linker.
+	(mips*-*-bsd*): New target; don't build linker.
+
+Wed May  4 20:10:10 1994  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* configure.in: support rs6000-*-lynxos* configuration.
+	support sunos4 as a cross target.
+
+	* config.sub: look for lynx*, not lynx since the OS version may
+	legitimately be part of the name.
+
+Tue May  3 21:48:11 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure.in (i[34]86-*-sco*): Move to be with other i386
+	targets.
+	(romp-*-*): New target.  Skip various binary utilities.
+	(vax-*-*): New target.  Don't build newlib.
+	(vax-*-vms): Renamed from *-*-vms.  Don't build opcodes or newlib.
+
+Thu Apr 28 15:03:05 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure.in: Only set host_makefile_frag if config
+	directory exists.
+
+Wed Apr 27 12:14:30 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* install.sh: If $dstdir exists, don't check whether each
+	component does.
+
+Tue Apr 26 18:11:33 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* test-build.mk (HOLES): Add sleep; used by rcs/src/conf.sh.
+
+Mon Apr 25 15:06:34 1994  Stan Shebs  (shebs@andros.cygnus.com)
+
+	* configure.in (*-*-lynxos*): Don't configure newlib for either
+	native or cross Lynx.
+
+Sat Apr 16 11:58:16 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub (sparc64-elf): Fix os.
+	(z8k): Remove duplicate.
+
+Thu Apr 14 23:33:17 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* Makefile.in (gcc-no-fixedincludes): Touch gcc/include/fixed, not
+	gcc/stmp-fixproto, to try to prevent fixproto from being run.
+
+Wed Apr 13 15:14:52 1994  Bill Cox  (bill@cygnus.com)
+
+	* configure: Make file links cleanly even if Lynx fails on
+	  an NFS symlink (at least fail cleanly).
+
+Mon Apr 11 10:58:56 1994  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* test-build.mk (CC): For mips-sgi-irix4, change -XNh1500 to
+	-XNh2000.
+
+Sat Apr  9 15:10:45 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Unknown options are fatal again.
+
+Fri Apr  8 12:01:41 1994  David J. Mackenzie  (djm@cygnus.com)
+
+	* configure: Ignore --x-includes and --x-libraries, for Autoconf
+	compatibility.
+
+Thu Apr  7 17:31:43 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* build-all.mk: Add `clean' target.
+
+Wed Apr  6 20:44:56 1994  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* config.guess:  Add SINIX support.
+	* configure.in:  Add mips-*-sysv4* support.
+
+Mon Apr  4 17:41:44 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* build-all.mk: Document all useful targets.
+	If canonhost is sparc-sun-solaris2.3, change it to sparc-sun-solaris2.
+	If canonhost is mips-sgi-irix4.0.5H, change it to mips-sgi-irix4.
+
+Thu Mar 31 04:55:57 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Support --silent, --quiet.
+
+Wed Mar 30 21:37:38 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Support --disable-FEATURE.
+
+Tue Mar 29 19:15:05 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize NCR running SVR4.3.
+
+Mon Mar 28 14:55:15 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Make BSDI generate i386-unknown-bsd386.
+	Patch from Paul Eggert <eggert@twinsun.com>.
+
+Mon Mar 28 12:54:52 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in (powerpc-*-aix*): Treat like rs6000-*-*.
+
+Sat Mar 26 11:25:48 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Make unrecognized options give nonfatal warnings
+	instead of fatal errors, and pass them to any subdirectory
+	configures in case they recognize them.
+	Make --x equivalent to --with-x.
+
+Fri Mar 25 21:52:10 1994  David J. Mackenzie  (djm@rtl.cygnus.com)
+
+	* configure: Add --enable-* options.  Clean up usage message and
+	some comments.
+
+Thu Mar 24 09:12:53 1994  Doug Evans  (dje@canuck.cygnus.com)
+
+	* Makefile.in (NM_FOR_TARGET): Build tree version is now nm.new.
+
+Sun Mar 20 11:28:22 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* configure.in (hppa*-*-*): Enable binutils.
+
+Sat Mar 19 11:50:16 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.sub: Recognize cisco.
+
+Fri Mar 18 16:42:32 1994  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* Makefile.in (CXXFLAGS): Add -fexternal-templates.
+
+Tue Mar 15 11:25:55 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: about target *-hitachi-hiuxwe2, don't print more
+	than one configuration name.  Add comment.
+
+Sun Mar  6 23:13:38 1994  Hisashi MINAMINO  (minamino@sra.co.jp)
+
+	* config.guess: about target *-hitachi-hiuxwe2, fixed
+	machine guessing order.  [Hitachi's CPU_IS_HP_MC68K
+	macro is incorrect.]
+
+Sun Mar 13 09:10:08 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (TAGS): Just build TAGS in each subdirectory, rather
+	than the "make ls" stuff which used to be here.
+
+Fri Mar 11 12:52:39 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Recognize i[34]86-unknown-freebsd.
+	From Shawn M Carey <smcarey@rodan.syr.edu>.
+
+Thu Mar  3 14:24:21 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure.in (noconfigdirs for alpha): Remove libg++ and libio.
+
+Wed Mar  2 13:28:48 1994  Jim Kingdon  (kingdon@deneb.cygnus.com)
+
+	* config.guess: Check for ptx.
+
+Mon Feb 28 16:46:50 1994  Kung Hsu  (kung@mexican.cygnus.com)
+
+	* config.sub: Add os9k checking.
+
+Thu Feb 24 07:09:04 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* config.guess: Handle OSF1 running on HPPA processors
+
+Fri Feb 18 14:14:00 1994  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure: If subdir configure fails, print out a message with
+	subdirectory name, in case subdir's configure code didn't identify
+	itself.
+
+Fri Feb 18 12:50:15 1994  Doug Evans  (dje@cygnus.com)
+
+	* configure.in: Remove embedded newlines from configdirs.
+	Avoid mismatches of substrings.  Fix matching strings at end
+	of configdirs.
+
+Fri Feb 11 15:33:33 1994  Stu Grossman  (grossman at cygnus.com)
+
+	* config.guess:  Add Lynx/rs6000 config support.
+
+Tue Feb  8 13:41:09 1994  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure.in (alpha-dec-osf1*, alpha*-*-*): Build gas.
+
+Mon Feb  7 15:42:36 1994  Jeffrey A. Law  (law@cygnus.com)
+
+	* configure.in (hppa*-*-osf*): Treat this just like most other
+	PA configurations (eg no binutils or ld).
+	(hppa*-*-*elf*): These configurations have binutils and ld.
+
+Sun Feb  6 16:35:07 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* config.sub (hiux): Fix typo.  From m-kasahr@sramhc.sra.co.JP.
+
+Sat Feb  5 01:00:33 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in (rs6000-*-*): Build gas.
+
+Wed Feb  2 13:57:57 1994  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* Makefile.in:  Avoid bug in losing hpux sed.
+
+Wed Feb  2 14:53:05 1994  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in, test-build.mk: Remove MUNCH_NM; it was only needed
+	for GDB and GDB has been fixed to not need it.
+
+Sun Jan 30 17:58:06 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* config.guess: Recognize vax hosts.
+
+Fri Jan 28 15:29:38 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure (while loop): Don't use "break 2" inside case
+	statement -- the case statement isn't an enclosing loop.
+
+Mon Jan 24 18:40:06 1994  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Clean up NeXT support, to allow nextstep
+	on Intel machines.  Make OS be nextstep.
+
+Sun Jan 23 18:47:22 1994  Richard Kenner  (kenner@vlsi1.ultra.nyu.edu)
+
+	* config.guess: Add alternate forms for Convex.
+
+Thu Jan 20 16:13:41 1994  Stu Grossman  (grossman at cygnus.com)
+
+	* configure:  Completely rewrite option processing.  Take
+	advantage of pattern-matching to avoid invoking test frequently.
+	Also clean up host and target defaulting logic.
+
+Mon Jan 17 15:06:56 1994  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* Makefile.in: Replace all occurrances of "rootme" with "r" and
+	"$${rootme}" with "$$r", to increase the likelihood that the do-*
+	commands (plus user environment) will fit SCO limits.
+
+Thu Jan  6 11:20:57 1994  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Don't issue warnings about directories which are
+	not being configured if -norecursion is set.  Correct test for
+	--with-gnu-as and --with-gnu-ld to not get confused by substring
+	matches.
+
+	* configure.in: Don't build gas for alpha-dec-osf1*.
+
+Tue Jan  4 17:10:19 1994  Stu Grossman  (grossman at cygnus.com)
+
+	* configure:  Back out Per's change of 12/19/1993.  It changes the
+	behavior of configure in unexpected and confusing ways.
+
+	Also, use different delim char when calculating
+	program_transform_name so that the name can contain slashes.
+
+Sat Jan  1 13:45:31 1994  Rob Savoye  (rob@darkstar.cygnus.com)
+
+	* configure.in, config.sub: Add support for VSTa micro-kernel.
+
+Sat Dec 25 20:00:47 1993  Jeffrey A. Law  (law@snake.cs.utah.edu)
+
+	* configure.in: Nuke hacks which were used to get a special
+	version of GAS for HPPA configurations.
+
+Sun Dec 19 20:40:44 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* configure:  If only ${target_alias} is given, use that
+	as the default for ${host_alias}.
+	* configure:  Add missing back-slashes before nested quotes.
+
+Wed Dec 15 18:07:18 1993  david d `zoo' zuhn  (zoo@andros.cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): add YACC=$(BISON)
+
+Tue Dec 14 21:25:33 1993  Per Bothner  (bothner@cygnus.com)
+
+	* config.guess:  Recognize some Tektronix configurations.
+	From Kaveh R. Ghazi <ghazi@noc.rutgers.edu>.
+
+Sat Dec 11 11:18:00 1993  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* config.sub: Match any flavor of SH.
+
+Thu Dec  2 17:16:58 1993  Ken Raeburn  (raeburn@cujo.cygnus.com)
+
+	* configure.in: Don't try to configure newlib for Alpha.
+
+Thu Dec  2 14:35:54 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Don't build ld for Irix 5.  Don't build gas,
+	libg++ or libio for any Alpha target.
+
+	* configure.in (mips*-sgi-irix5*): New target; use mh-irix5.
+
+Wed Dec  1 17:00:33 1993  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* Makefile.in (GZIPPROG): Renamed from GZIP, which gzip uses for
+	default arguments -- so it tried to compress itself.
+
+Tue Nov 30 13:45:15 1993  david d `zoo' zuhn  (zoo@andros.cygnus.com)
+
+	* configure.in (notsupp): ensure that a space is always at the end
+	  of the configdirs list, since the grep checks for an explicit space
+
+Tue Nov 16 15:04:27 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in (target i386-sysv4.2): don't build ld, since static
+	  versions of many libraries are not available.
+
+Tue Nov 16 14:28:12 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize Apollos (using environment variables).
+	* configure.in: Don't configure ld, binutils, or gprof for Apollo.
+
+Thu Nov 11 12:03:50 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize Sony news mips running newsos.
+
+Wed Nov 10 16:57:00 1993  Mark Eichin  (eichin@cygnus.com)
+
+	* Makefile.in (all-cygnus, build-cygnus): "fi else" needs to be
+	"fi ; else" for bash.
+
+Tue Nov  9 15:54:01 1993  Mark Eichin  (eichin@cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): pass SHELL.
+
+Fri Nov  5 08:07:27 1993  D. V. Henkel-Wallace  (gumby@blues.cygnus.com)
+
+	* config.sub: accept unixware as an alias for svr4.2.
+	Fix some inconsistancies with the gcc version.
+
+Fri Nov  5 15:14:12 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (DISTDOCDIRS):  Add gdb.
+
+Fri Nov  5 11:59:42 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in (DISTDOCDIRS):  Add libg++ and libio.
+
+Fri Nov  5 10:35:05 1993  Ken Raeburn  (raeburn@rover.cygnus.com)
+
+	* Makefile.in (taz): Only build "info" in DISTDOCDIRS.
+	(DISTDOCDIRS): Don't assume libg++ and gdb folks necessarily want
+	this now.
+
+Thu Nov  4 18:58:23 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.sub: Accept hiux* as an OS name.
+
+	* Makefile.in: Change RUNTEST_FLAGS back to RUNTESTFLAGS per
+	etc/make-stds.texi.  The underscore came from gcc, and dje now
+	agrees that RUNTESTFLAGS is the correct name.
+
+Thu Nov  4 10:49:01 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* install.sh:  Remove 'set -e'.  It makes any conditionals
+	in the script useless.
+
+	* config.guess: Automatically recognize arm-acorn-riscix
+	Patch from Richard Earnshaw (rwe11@cl.cam.ac.uk).
+
+Thu Nov 04 08:08:04 1993  Jeffrey Wheat  (cassidy@cygnus.com)
+
+	* Makefile.in: Change RUNTESTFLAGS to RUNTEST_FLAGS
+
+Wed Nov  3 22:09:46 1993  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* Makefile.in (DISTDOCDIRS): New variable.
+	(taz): Edit local Makefile.in sooner, instead of proto-toplev
+	Makefile.in later.  Build "info" and "dvi" in DISTDOCDIRS.
+
+Wed Nov  3 21:31:52 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in (hppa target): check the source directory for the
+	  pagas sub-directory
+
+Wed Nov  3 11:12:22 1993  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub: Allow -aout* and -elf*.
+
+Wed Nov  3 11:08:33 1993  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure.in: Don't build ld on i386-solaris2, same as for
+	sparc-solaris2.
+
+Tue Nov  2 14:21:25 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in (taz): Add texinfo/lgpl.texinfo (for libg++).
+
+Tue Nov  2 13:38:30 1993  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* configure.in:  Configure gdb for alpha.
+
+Mon Nov  1 10:42:54 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (CXXFLAGS): Add -O.
+
+Wed Oct 27 10:45:06 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* config.guess: added support for DG Aviion
+
+Tue Oct 26 14:37:37 1993  Ken Raeburn  (raeburn@rover.cygnus.com)
+
+	* configure.in: Produce warning message for subdirectories not
+	configurable for this host/target combination.  Don't try to
+	configure gdb for vms.
+
+Mon Oct 25 11:22:15 1993  Ken Raeburn  (raeburn@rover.cygnus.com)
+
+	* Makefile.in (taz): Replace "byacc" with "bison -y" in the
+	appropriate files before making "diststuff".
+	(DISTBISONFILES): New var: list of files to be edited.
+	(DISTSTUFFDIRS): Add binutils.
+
+Fri Oct 22 20:32:15 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* config.sub: also handle mipsel and mips64el (for little endian mips)
+
+Fri Oct 22 07:59:20 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Add * to end of all OS names.
+
+Thu Oct 21 11:38:28 1993  Stan Shebs  (shebs@rtl.cygnus.com)
+
+	* configure.in: Build newlib for LynxOS native.
+
+Wed Oct 20 09:56:12 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Add support for delta 88k running SVR3.
+
+	* configure.in: Add comment about HP compiler vs. emacs.
+
+Tue Oct 19 16:02:22 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: don't build ld on solaris2 (not a viable option
+	  due to bugs in getpwnam & getpwuid)
+
+Tue Oct 19 15:13:56 1993  Ken Raeburn  (raeburn@rtl.cygnus.com)
+
+	* configure.in: Accept alpha-dec-osf1*, not just -osf1, since
+	config.guess will produce a full version number.
+
+Tue Oct 19 15:58:01 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Build linker and binutils for alpha-dec-osf1.
+
+Tue Oct 19 11:41:55 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in: Remove -O from CXXFLAGS for consistency with CFLAGS,
+	and gdb/testsuite/Makefile.in.
+
+Sat Oct  9 18:39:07 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: recognize mips*- instead of mips-
+
+Fri Oct  8 14:15:39 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* config.sub: Accept linux*coff and linux*elf as operating
+	systems.
+
+Thu Oct  7 12:57:19 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* config.sub: Recognize mips64, and mips3 as an alias for it.
+
+Wed Oct  6 13:54:21 1993  Peter Schauer  (pes@regent.e-technik.tu-muenchen.de)
+
+	* configure.in: Remove alpha-dec-osf*, no longer necessary now that
+	gdb knows how to handle OSF/1 shared libraries.
+
+Tue Oct  5 11:55:04 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Recognize hppa*-*-hiux* (currently synonym for hpux).
+	* config.guess: Recognize Hitachi's HIUX.
+	* config.sub: Recognize h3050r* and hppahitachi.
+	Remove redundant cases for hp9k[23]*.
+
+Mon Oct  4 16:15:09 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: default to '--with-gnu-as' and '--with-gnu-ld'
+	if gas and ld are in the source tree and are in ${configdirs}.
+	If ${use_gnu_as} or ${use_gnu_ld} are 'no', then don't set the
+	--with options (but still pass them down on the command line,
+	if they were explicitly specified).
+
+Fri Sep 24 19:11:13 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure: substitute SHELL value in Makefile.in with
+	${CONFIG_SHELL}
+
+Thu Sep 23 18:05:13 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* configure.in: Build gas, ld, and binutils for *-*-sysv4* and
+	*-*-solaris2* targets.
+
+Sun Sep 19 17:01:41 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in: define M4, and pass it down to sub-makes;
+	all-autoconf now depends on all-m4
+
+Sat Sep 18 00:38:23 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in ({AR,RANLIB}_FOR_TARGET): make contingent on
+	presence of {ar,ranlib} instead of a configured directory
+
+Wed Sep 15 08:41:44 1993  Jim Kingdon  (kingdon@cirdan.cygnus.com)
+
+	* config.guess: Accept 34?? as well as 33?? for NCR.
+
+Mon Sep 13 12:28:43 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: grab mt-hppa for HPPA targets; use 'gas ' instead
+	of 'gas' in sed commands, since 'gash' is now in the tree as well.
+
+Fri Sep 10 11:23:52 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure: grab values for $(CC) and $(CXX) from the
+	environment, so that someone can do "CC=gcc configure; make" and
+	have it work right (matching the way that autoconf works now)
+
+	* configure.in, Makefile.in: add support for gash, the tcl
+	interface to Galaxy
+
+	* config.guess: add NetBSD variants (hp300, x86)
+
+Thu Sep  9 16:48:52 1993  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* install.sh: Support -d option (in the manner of SunOS 4 install,
+	as it is more deterministic than that of GNU install)
+	(chmodcmd): Set file to mode 755 by default (should also do default
+	chgrp and chown, but I don't feel like dealing with that now)
+
+Tue Sep  7 11:59:39 1993  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub: Remove h8300hhms alias.
+
+Tue Aug 31 11:00:09 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Match *-*-solaris2* not *-sun-solaris2*.
+
+Mon Aug 30 18:29:10 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in (gcc-no-fixedincludes): touch stmp-fixproto as well
+	as stmp-fixinc
+
+Wed Aug 25 16:35:59 1993  K. Richard Pixley  (rich@sendai.cygnus.com)
+
+	* config.sub: recognize m88110-bug-coff.
+
+Tue Aug 24 10:23:24 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in (all-libio): all dependencies on the toolchain used
+	to build this (gcc, gas, ld, etc)
+
+Fri Aug 20 17:24:24 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Deal with OSF/1 1.3 on alpha.
+
+Thu Aug 19 11:43:04 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* install.sh: add some 'else true' clauses for portability
+
+	* configure.in: don't build libio for h8[35]00-*-* targets
+
+Tue Aug 17 19:02:31 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* Makefile.in:  Add support for new libio.
+
+Sun Aug 15 20:48:55 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* install.sh: If one command fails, don't try the rest.  Don't try
+	to remove $dsttmp (via trap) unless we have already created it.
+	If $src doesn't exist, detect it and exit with an error.
+
+	* config.guess: Recognize BSD on hp300.
+
+Wed Aug 11 18:35:13 1993  Per Bothner  (bothner@kalessin.cygnus.com)
+
+	* config.guess:  Map (9000/[34]??:HP-UX:*:*) to m68k-hp-hpux.
+	Bug report from "Hamish (H.I.) Macdonald" <hamish@bnr.ca>.
+
+Wed Aug 11 15:37:51 1993  Jason Merrill  (jason@deneb.cygnus.com)
+
+	* Makefile.in (all-send-pr): depends on all-prms
+
+Wed Aug 11 16:56:03 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Fix typo (9000/8??:4.3bsd -> 9000/7??:4.3bsd).
+
+Fri Aug  6 14:45:02 1993  Ian Lance Taylor  (ian@tweedledumb.cygnus.com)
+
+	* config.guess: From michael@mercury.cs.mun.ca (Michael Rendell):
+	Added test for mips-mips-riscos5.
+
+Thu Aug  5 15:45:08 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure.in: use mh-hp300 for 68k HP hosts
+
+Mon Aug  2 11:56:53 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* configure: add support for CONFIG_SHELL, so that you can use
+	some alternate shell for evaluating configure scripts
+
+Sun Aug  1 11:36:27 1993  Fred Fish  (fnf@deneb.cygnus.com)
+
+	* Makefile.in (make-gdb.tar.gz):  Sed bug reporting address
+	in configure script to bug-gdb@prep.ai.mit.edu when building
+	distribution archive.
+	* Makefile.in (COMPRESS):  Remove def.
+	* Makefile.in (gdb.tar.gz, make-gdb.tar.gz):  Renamed from
+	gdb.tar.Z and make-gdb.tar.Z respectively.
+	* Makefile.in (make-gdb.tar.gz):  Now only build gzip'd archive.
+	* Makefile.in (make-gdb.tar.gz):  Minor changes to move closer
+	to convergence with 'taz' target in Makefile.in.
+
+Fri Jul 30 12:34:57 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* install.sh (dsttmp): use trap to ensure that tmp files go
+	away on error conditions
+
+Wed Jul 28 11:57:36 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* Makefile.in (BASE_FLAGS_TO_PASS): remove LOADLIBES
+
+Tue Jul 27 12:43:40 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* Makefile.in (install-dirs): Deal with a prefix like /gnu;
+	its parent is '/' not ''.
+
+	* Makefile.in (DEVO_SUPPORT): Add comments about ChangeLog.
+
+Fri Jul 23 09:53:37 1993  Jason Merrill  (jason@wahini.cygnus.com)
+
+	* configure: if ${newsrcdir}/configure doesn't exist, don't assume
+	that ${newsrcdir}/configure.in does.
+
+Tue Jul 20 11:28:50 1993  david d `zoo' zuhn  (zoo@rtl.cygnus.com)
+
+	* test-build.mk: support for CONFIG_SHELL
+
+Mon Jul 19 21:54:46 1993  Fred Fish  (fnf@deneb.cygnus.com)
+
+	* config.sub (netware):  Add as a basic system type.
+
+Wed Jul 14 12:03:11 1993  K. Richard Pixley  (rich@sendai.cygnus.com)
+
+	* Makefile.in (Makefile): depend on configure.in.  Also drop the
+	  $(srcdir)/ from the dependency on Makefile.in.
+
+Tue Jul 13 20:10:58 1993  Doug Evans  (dje@canuck.cygnus.com)
+
+	* config.sub: Recognize h8300hhms as h8300h-hitachi-hms.
+	(h8300hhms is temporary until multi-libraries are implemented).
+	* configure.in: Handle h8300h too.
+
+Sun Jul 11 17:35:27 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize dpx/2 as m68k-bull-sysv3.
+
+Thu Jul  8 18:26:12 1993  John Gilmore  (gnu@cygnus.com)
+
+	* configure:  Remove extraneous output when guessing host type.
+	* config.guess:  Remove extraneous output when guessing using C
+	compiler rather than uname, or when guessing fails.
+
+Wed Jul  7 17:58:14 1993  david d `zoo' zuhn  (zoo at rtl.cygnus.com)
+
+	* Makefile.in: remove all.cross and install.cross targets
+
+	* configure: remove CROSS=-DCROSS_COMPILE and ALL=all.cross
+	  definitions
+
+Tue Jul  6 10:39:44 1993  Steve Chamberlain  (sac@phydeaux.cygnus.com)
+
+	* configure.in (target sh): Build gprof.
+
+Thu Jul  1 16:52:56 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: change -solaris to -solaris2
+
+Thu Jul  1 15:46:16 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* configure.in: Use config/mh-riscos for mips-*-sysv*.
+
+Wed Jun 30 09:31:58 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: Correct error message for missing Makefile.in to
+	print correct directory.
+
+Tue Jun 29 13:52:16 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* install.sh: kludge around 386BSD shell bug
+
+Tue Jun 29 13:06:49 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.guess:  Recognize NeXT.
+	* config.guess:  Recognize i486-ncr-sysv4.
+	* Makefile.in (taz):  rm $(TOOL)-$$VER before linking.
+
+Tue Jun 29 12:50:57 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (MAKEINFOFLAGS): New variable.
+	(FLAGS_TO_PASS): Pass MAKEINFO as MAKEINFO MAKEINFOFLAGS.
+	* build-all.mk, test-build.mk: Pass down --no-split as
+	MAKEINFOFLAGS when hosted on DOS.  Compile DOS hosted without -g.
+
+Thu Jun 24 13:39:11 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (DEVO_SUPPORT):  Add COPYING COPYING.LIB install.sh.
+
+Wed Jun 23 12:59:21 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (libg++.tar.z):  New rule.
+	* Makefile.in (taz):  Replace 'configure -rm' by 'make distclean'.
+	* Makefile.in (taz):  Only do a single chmod.
+
+Fri Jun 18 12:03:10 1993  david d `zoo' zuhn  (zoo at majipoor.cygnus.com)
+
+	* install.sh: don't use dirname anymore (replaced with sed usage)
+
+Thu Jun 17 18:43:42 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in:  Change extension for gzip'd files from '.z' to
+	'.gz' per new FSF standard usage.
+
+Thu Jun 17 16:58:50 1993  david d `zoo' zuhn  (zoo at majipoor.cygnus.com)
+
+	* configure: put quotes around the final value of program_transform_name
+
+Tue Jun 15 16:48:51 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: new install.sh support; update install-info rules
+
+Wed Jun  9 12:31:34 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure.in: Build diff for crosses, but not for go32 host.
+
+	* configure.in: Build gprof only for native, and don't build it
+	for mips-*-*, rs6000-*-*, or i[34]86-*-sco*.
+
+Mon Jun  7 13:12:11 1993  david d `zoo' zuhn  (zoo at deneb.cygnus.com)
+
+	* configure.in: don't build gas,ld,binutils on for *-*-sysv4
+
+Mon Jun  7 11:40:11 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* configure.in (host_tools): Add prms.
+
+Fri Jun  4 13:30:42 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: install gcc, do installation of $(INSTALL_MODULES)
+	with $(FLAGS_TO_PASS) on the command line
+
+	* config.sub: Recognize lynx and lynxos
+
+Fri Jun  4 10:59:56 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub: Accept -ecoff*, not just -ecoff.
+
+Thu Jun  3 17:38:54 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (taz): Use .gz suffix instead of .z.
+	(binutils.tar.gz, gas+binutils.tar.gz, gas.tar.gz): Fixed target
+	names.
+
+Thu Jun  3 00:27:06 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in (vault-install): add an 'else true' (for Ultrix)
+
+Wed Jun  2 18:19:16 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in (install-no-fixedincludes):  install gcc last, so
+	that rebuilds that might happen during 'make install' don't get
+	bogus gcc include files
+
+Wed Jun  2 16:14:10 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	Change from Utah for HPPA support:
+	* config.guess: Recognize hppa1.x-hp-bsd.
+
+Wed Jun  2 11:53:33 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.guess:  Add support for Motorola Delta 68k, up to r3v7.
+	Patch from pot@fly.cnuce.cnr.it (Francesco Potorti`).
+
+Tue Jun  1 17:48:42 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+	* config.sub: Add support for rom68k and bug boot monitors.
+
+Mon May 31 09:36:37 1993  Jim Kingdon  (kingdon@cygnus.com)
+
+	* Makefile.in: Make all-opcodes depend on all-bfd.
+
+Thu May 27 08:05:31 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.guess: Added special check for i[34]86-univel-sysv4*.
+
+Wed May 26 16:33:40 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.guess: For i[34]86-unknown-sysv4 use UNAME_MACHINE for
+	the processor rather than assuming i486.
+
+Wed May 26 09:40:18 1993  Jim Kingdon  (kingdon@lioth.cygnus.com)
+
+	* config.guess: Recognize SunOS6 as Solaris3.
+
+Tue May 25 23:03:11 1993  Per Bothner  (bothner@cygnus.com)
+
+	* config.guess:  Fix typo.  Avoid #elif (not in K&R 1).
+	Recognize SunOS 5.* only (and not [6-9].*) as being Solaris2.
+
+Tue May 25 12:44:18 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk (all-cross): New target for Canadian Cross.
+	Added Q2 go32 targets.
+	* test-build.mk: Configure go32 cross sparclite-aout and
+	mips-idt-ecoff -with-gnu-ld.  Moved build binary directory from
+	PARTIAL_HOLE_DIRS to BUILD_HOLES_DIRS.
+
+Mon May 24 15:30:06 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: fix Alpha GDB typo; also, don't build DejaGnu for
+	GO32 hosted toolchains
+
+Mon May 24 14:18:41 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+	* configure: change  so "-exec-prefix" gets passed down rather
+	than "-exec_prefix" so autoconf generated Makefiles get the
+	exec_prefix set right.
+
+Fri May 21 10:42:25 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.guess: get the Solaris2 minor version number
+
+	* Makefile.in: add standards.texi and make-stds.texi to ETC_SUPPORT
+
+Fri May 21 06:20:52 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* config.guess: Recognize some Sequent platforms.
+
+Thu May 20 14:33:48 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: added the vault-install target
+
+	* configure.in: actually use the Sun3 makefile fragment that's in
+	config, also added the release dir to configdirs
+
+Thu May 20 14:19:18 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (taz): Fix modes on stuff in $(TOOL) dir also.
+
+Tue May 18 20:26:41 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: remove some program from Alpha targetted toolchains
+
+Tue May 18 15:23:19 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* Makefile.in (DISTSTUFFDIRS): Renamed from PROTODIRS.  Add ld and
+	gprof.
+	(taz): Run "make diststuff" in those directories instead of "make
+	proto-dir".  Look for "VERSION=" only at start of line in subdir
+	Makefile.  Use "gzip -9" for compression.
+	(TEXINFO_SUPPORT, DIST_SUPPORT, BINUTILS_SUPPORT_DIRS): New vars.
+	(binutils.tar.z): New target.
+
+Mon May 17 17:01:15 1993  Ken Raeburn  (raeburn@deneb.cygnus.com)
+
+	* Makefile.in (taz): Include gpl.texinfo.
+
+Fri May 14 06:48:38 1993  Ken Raeburn  (raeburn@deneb.cygnus.com)
+
+	* Makefile.in (setup-dirs): Merged into "taz" target.
+	(taz): Only do `proto-dir' stuff if a directory is actually needed
+	for this target.
+
+Wed May 12 13:09:44 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (MUNCH_NM): New variable, defined to be $(NM).
+	(FLAGS_TO_PASS): Pass down MUNCH_NM.
+	(HOST_CC, HOST_PREFIX, HOST_PREFIX_1): New variables.
+	(EXTRA_GCC_FLAGS): Pass down HOST_* variables.
+	(gcc-no-fixedincludes): Correct for current gcc Makefile.
+
+Tue May 11 10:14:25 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  Add configure, config.guess,
+	config.sub, and move-if-change to gdb testsuite distribution
+	archive, so the testsuite can be extracted, configured, and
+	run separately from the gdb distribution.  Blow away the Chill
+	tests that require a Chill compiled executable, since GNU Chill
+	is not yet publically available.
+
+Mon May 10 17:22:26 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* test-build.mk: set environment variables in a single command,
+	instead of a list of assignments and exports
+
+	* config.guess: recognize Alpha/OSF1 systems
+
+Mon May 10 14:55:51 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: Change help message to prefer --options rather than
+	  -options.
+
+Mon May 10 05:58:35 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* config.sub: Convergent Tech. "miniframe" uses m68010, sez
+	zippy@ecst.csuchico.edu.
+	* config.guess: Recognize miniframe.
+
+Sun May  9 17:47:57 1993  Rob Savoye  (rob at darkstar.cygnus.com)
+
+       * Makefile.in: Use srcroot to find runtest rather than rootme.
+       Pass RUNTESTFLAGS and EXPECT down in BASE_FLAGS_TO_PASS.
+
+Fri May  7 14:55:59 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk: Extensive additions to support building on a
+	machine other than the host.
+
+Wed May  5 08:35:04 1993  Ken Raeburn  (raeburn@deneb.cygnus.com)
+
+	* configure (tooldir): Fix for i386-aix again.
+
+Mon May  3 19:00:27 1993  Per Bothner  (bothner@cygnus.com)
+
+	* configure, Makefile.in:  Change definition of $(tooldir)
+	to match the FSF.
+
+Fri Apr 30 15:55:21 1993  Fred Fish  (fnf@cygnus.com)
+
+	* config.guess:  Recognize i[34]86/SVR4.
+
+Fri Apr 30 15:52:46 1993  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in (all-gdb): gdb depends on sim.
+
+Thu Apr 29 23:30:48 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (gdb.tar.Z):  Make prototype gdb testsuite directory
+	at the same time we make the prototype gdb directory.
+	* Makefile.in (make-gdb.tar.Z):  Make the testsuite distribution
+	files at the same time as the gdb base release distribution.
+
+Thu Apr 29 12:50:37 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (check): Use individual check targets rather than
+	DO_X rule.
+	(check-gcc): Added.
+
+Thu Apr 29 09:50:07 1993  Jim Kingdon  (kingdon@cygnus.com)
+
+	* config.sub: Use sysv3.2 not sysv32 for canonical OS
+	for System V release 3.2.
+
+Thu Apr 29 10:33:22 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* config.sub: Recognize hppaosf.
+	* configure.in: Do configure ld/binutils/gas for it.
+
+Tue Apr 27 06:25:34 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure (tooldir): Alter syntax used to set this, for systems
+	where "\$" isn't handled right, like i386-aix.
+
+Thu Apr 22 08:17:35 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: Pass program-transform-name, not
+	program_transform_name, to recursive configures.
+
+Thu Apr 22 02:58:21 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* Makefile.in (gas+binutils.tar.z): New rule for building snapshots
+	of gas+ld+binutils.
+
+Mon Apr 19 17:41:30 1993  Per Bothner  (bothner@cygnus.com)
+
+	* config.guess:  Recognize AIX3.2 as distinct from 3.1.
+
+Sat Apr 17 17:19:50 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: rename m88k-motorola-m88kbcs to m88k-motorola-sysv
+
+Tue Apr 13 16:52:16 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* Makefile.in (PRMS): Set back to all-prms.
+
+Sat Apr 10 12:04:07 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk: Pass -with-gnu-as for known MIPS native and MIPS
+	targets, rather than for MIPS hosts.
+
+Fri Apr  9 13:51:06 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: add comment for --with-x default values
+
+	* config.guess: handle Motorola Delta88 box for SVR3 and SVR4.
+
+	* Makefile.in: add check-* targets for each of the directories in
+	the tree.  Add a definition of RUNTEST that will use the one we
+	just built, if it exists.  Pass this down via FLAGS_TO_PASS.
+
+Thu Apr  8 09:21:30 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure.in: Removed obsolete references to bfd_target and
+	target_makefile_frag.
+
+	* build-all.mk: Set assorted targets for Q2.
+	* config.sub: Recognize z8k-sim and h8300-hms.
+	* test-build.mk: Really don't pass host to configure.
+	(HOLES): Added uname.
+
+Wed Apr  7 15:48:19 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: Handle an empty program-prefix, program-suffix or
+	program-transform-name correctly.
+
+Tue Apr  6 13:48:41 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: -G 8 no longer required for MIPS targets.
+	* test-build.mk: Don't pass host argument to configure; make it
+	guess.
+
+Tue Apr  6 10:36:53 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (gdb.tar.Z):  Fix for building gzip'd distribution.
+	* Makefile.in (COMPRESS):  New macro, like GZIP.
+
+Fri Apr  2 09:02:31 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk: Use -with-gnu-as for mips-sgi-irix4 as well.
+
+	* build-all.mk: Set GCC to gcc -O -G 8 for MIPS targets, since gcc
+	with gas currently defaults to -G 0.
+
+Thu Apr  1 08:25:42 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (all-flex): flex depends on byacc.
+
+	* build-all.mk: If host not specified, use config.guess.  Pass TAG
+	to test-build.mk as RELEASE_TAG.
+	* test-build.mk (configargs): New variable containing arguments to
+	pass to configure.  Set to -with-gnu-as on mips-dec-ultrix.
+	(FLAGS_TO_PASS): Pass down RELEASE_TAG.
+
+	* config.guess: Use /bin/uname when checking -X argument on SCO,
+	to avoid invoking GNU uname which doesn't understand -X.
+
+	* test-build.mk: Don't use /usr/unsupported/bin/as on AIX.
+
+	* configure.in: Build gas for mips-*-*.
+
+Wed Mar 31 21:20:58 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in (all.normal): insert missing backslash.
+
+Wed Mar 31 12:31:56 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: Bump -XNh value to 1500 to match gcc requirements.
+
+	* Makefile.in: Complete overhaul to merge many almost identical
+	targets.
+
+Tue Mar 30 20:17:01 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (setup-dirs-gdb): Renamed from setup-dirs.
+	(gdb.tar.Z): Adjusted.
+
+	* Makefile.in (setup-dirs, taz): New targets; should be general
+	enough to adapt for gdb sometime.  Build only .z file.
+	(gas.tar.z): New target.
+
+Tue Mar 30 10:03:09 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: Use CC=cc -Xs on Solaris.
+
+Thu Mar 25 15:14:30 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in:  Incorporate changes suggested by wilson@cygnus.com
+	for handling BISON for FSF releases.
+
+Thu Mar 25 06:19:48 1993  Ken Raeburn  (raeburn@kr-pc.cygnus.com)
+
+	* configure: Actually implement the change zoo just documented.
+
+Wed Mar 24 13:02:44 1993  david d `zoo' zuhn  (zoo at poseidon.cygnus.com)
+
+	* configure: when using config.guess, only set target_alias when
+	it's not already been set (ie, on the command line)
+
+Mon Mar 22 23:07:39 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: add installcheck target, set PRMS to install-prms
+
+Sun Mar 21 16:46:12 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure: add support for package_makefile_fragment, handle the
+	case where a directory has a configure.in file but no Makefile.in
+	more gracefully (with an actual understandable error message, even);
+	add support for --without (and add this to the usage message); also
+	explicitly add a --host=${host_alias} to the command line when
+	config.guess is used
+
+Sun Mar 21 12:11:58 1993  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* configure: Must use both --host and --target in recursive calls.
+
+Thu Mar 18 12:31:35 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: Change deja-gnu to dejagnu.
+
+Mon Mar 15 15:44:35 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure.in (h8300-*-*, h8500-*-*): Don't build libg++.
+
+Fri Mar 12 18:30:14 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: canonicalize all instances to *-*-solaris2*,
+	also strip out a number of tools to not build for go32 host
+
+Wed Mar 10 12:08:27 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* config.guess: add GPL.
+
+	* Makefile.in, config.guess, config.sub, configure: bump
+	  copyrights to 93.
+
+Wed Mar 10 07:12:48 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (do-info): Removed obsolete check for existence of
+	localenv file.
+
+	* Makefile.in (MAKEOVERRIDES): Define to be empty.
+
+Wed Mar 10 03:11:56 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: a couple of 'else true' for decstation,
+	support for TclX
+
+	* configure.in: configure tclX too; don't remove Tk on RS/6000 anymore
+
+Tue Mar  9 16:06:12 1993  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in (setup-dirs): change invocation of make to $(MAKE).
+
+Mon Mar  8 14:52:11 1993  Ken Raeburn  (raeburn@cambridge)
+
+	* config.guess: Recognize i386-ibm-aix (PS/2).
+	* configure.in: Use config/mh-aix386 file for it.
+
+Mon Mar  8 11:12:43 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (GCC_FOR_TARGET): Eliminated definition; use
+	CC_FOR_TARGET instead.
+	(BASE_FLAGS_TO_PASS): Pass GCC_FOR_TARGET=$(CC_FOR_TARGET).
+
+Wed Mar  3 16:00:28 1993  Steve Chamberlain  (sac@ok.cygnus.com)
+
+	* Makefile.in: Add sim to list of directories sent with gdb
+
+Wed Mar  3 11:42:39 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* configure.in: Put back mips-dec-bsd* case.
+
+Tue Mar  2 21:15:58 1993  Fred Fish  (fnf@cygnus.com)
+
+	(Ultrix 2.2 support from Michael Rendell <michael@mercury.cs.mun.ca>)
+	* configure.in (vax-*-ultrix2*):  Add Ultrix 2.2 triplet.
+	* config.guess:  Change 'VAX*:ULTRIX:*:*' to 'VAX*:ULTRIX*:*:*'.
+
+Tue Mar  2 18:11:03 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: remove no-op mips-dec-bsd* in "case $target"
+
+	* Makefile.in (dir.info): only run gen-info-dir if it exists,
+	(install-info): install dir.info only if it exists,
+	(all-expect, install-expect): pass along X11_FLAGS_TO_PASS
+
+Tue Mar  2 09:01:30 1993  Ken Raeburn  (raeburn@cygnus.com)
+
+	* configure.in: For vms target, skip bfd, ld, binutils.  Do build
+	gas for mips-dec-bsd.
+
+Tue Mar  2 08:35:24 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure (makesrcdir): If ${srcdir} is relative and not ".",
+	and ${subdir} is not ".", set makesrcdir based on ${invsubdir}.
+
+Tue Feb 23 14:18:28 1993  Mike Werner  (mtw@poseidon.cygnus.com)
+
+	* configure.in: Added "dejagnu" to hosttools list.
+
+Mon Feb 22 23:28:38 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.sub, configure.in, config.guess:  Add support
+	for Bosx, an AIX variant from Bull.
+	Patches from F.Pierresteguy@frcl.bull.fr.
+
+Sun Feb 21 11:15:22 1993  Mike Werner  (mtw@poseidon.cygnus.com)
+
+	* devo/dejagnu: Initial creation of devo/dejagnu.
+	Migrated dejagnu testcases and support files for testing software
+	tools to reside as subdirectories, currently called "testsuite",
+	within the directory of the software tool.  Migrated all programs,
+	support libraries, etc. beloging to dejagnu proper from
+	devo/deja-gnu to devo/dejagnu.	These files were moved "as is"
+	with no modifications.	The changes to these files which will
+	allow them to configure, build, and execute properly will be made
+	in a future update.
+
+Fri Feb 19 20:19:39 1993  Brendan Kehoe  (brendan@lisa.cygnus.com)
+
+	* Makefile.in: Change send_pr to send-pr.
+	* configure.in: Likewise.
+	* send_pr: Renamed directory to send-pr.
+
+Fri Feb 19 19:00:13 1993  Per Bothner  (bothner@cygnus.com)
+
+	* Makefile.in:  Add some extra semi-colons (needed if SHELL=bash).
+
+Fri Feb 19 00:59:33 1993  John Gilmore  (gnu@cygnus.com)
+
+	* README:  Update for gdb-4.8 release.
+	* Makefile.in (gdb.tar.Z):  Add texinfo/tex3patch.  Build
+	gdb-xxx.tar.z (gzip'd) file also.
+
+Thu Feb 18 09:16:17 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: make all-diff depend on all-libiberty
+
+Tue Feb 16 16:06:31 1993  K. Richard Pixley  (rich@cygnus.com)
+
+	* config.guess: add vax-ultrix in the spirit of mips-ultrix.
+
+Tue Feb 16 05:57:15 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in, Makefile.in: add hello, tar, gzip, recode, indent
+
+Tue Feb 16 00:58:20 1993  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in (DEVO_SUPPORT):  Remove etc directory
+	(ETC_SUPPORT):  Only add the files GDB wants from etc/.
+	(gdb.tar.Z):  Use ETC_SUPPORT.  Use byacc when building the file.
+
+Thu Feb 11 20:14:28 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in:  makeinfo binary is in a new location
+
+Tue Feb  9 12:42:27 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub: Accept -ecoff as an OS.
+
+	* Makefile.in: Various changes to eliminate a level of make
+	recursion and reduce the required command line length.
+	(BASE_FLAGS_TO_PASS): New variable holding flags passed to all
+	sub-makes.
+	(EXTRA_HOST_FLAGS, EXTRA_TARGET_FLAGS, EXTRA_GCC_FLAGS): New
+	variables holding settings for specific sub-makes.
+	(FLAGS_TO_PASS, TARGET_FLAGS_TO_PASS, GCC_FLAGS_TO_PASS): Rewrote
+	in terms of BASE_FLAGS_TO_PASS.
+	(TARGET_LIBS): New variable listing directories which use
+	TARGET_FLAGS_TO_PASS.
+	(subdir_do): Eliminated.
+	(do-*): New set of targets to replace subdir_do.
+	(various): All targets which used subdir_do now depend on do-*.
+	(local-clean): Renamed from do_clean.
+	(local-distclean): New target, dependency of distclean and
+	realclean.
+	(install-info): Don't create directories.  Depend on dir.info
+	rather than calling make recursively.
+	(install-dir.info): Eliminated.
+	(install-info-dirs): Create all info directories here.
+	(dir.info): Depend upon do-install-info.
+
+	* test-build.mk (HOLES): Added false.
+
+Sat Feb  6 14:05:09 1993  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.guess:  Recognize BSDI and BSDJ (Jolitz 386bsd).
+
+Thu Feb  4 20:49:18 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in (info): remove dependency on all-texinfo.  The
+	problem was really in texinfo/C, not at this level.
+
+Thu Feb  4 13:38:41 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (info): Added dependency on all-texinfo (PR 2112).
+
+Thu Feb  4 01:50:53 1993  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  Change BISON to 'bison -y' for
+	GDB releases.
+
+Wed Feb  3 17:22:16 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* configure: Include srcdir in message about target of link not
+	being found.  Don't convert `-' to `_' in `with' options being
+	passed to subdirs.
+
+Tue Feb  2 18:57:59 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: add uudecode to host_tools
+
+	* Makefile.in: added {all,install}-uudecode targets, added them to
+	the appropriate lists
+
+Tue Feb  2 11:45:53 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (all-gcc): Added dependency on all-gas.
+
+	* configure.in (mips-*-*): Build ld and binutils.
+
+Mon Feb  1 12:35:41 1993  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: check return code from mkdir, print error message and
+	  exit on failure.
+
+Sat Jan 30 16:40:28 1993  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  New location for texinfo.tex.
+
+Thu Jan 28 15:09:59 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* test-build.mk (HOLES): Added tar, cpio and uudecode.
+
+Wed Jan 27 16:50:32 1993  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* config.sub (h8500):  Recognize this as a cpu type.
+
+Sat Jan 23 20:32:01 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure: source directory missing is no longer a warning
+
+	* configure.in: recognize irix[34]* instead of irix[34]
+
+	* Makefile.in: define and pass down X11_LIB
+
+Sat Jan 23 13:49:40 1993  Per Bothner  (bothner@cygnus.com)
+
+	* guess-systype: Renamed to ...
+	* config.guess:  ... by popular request.
+	* configure.in, Makefile.in:  Update accordingly.
+
+Thu Jan 21 12:20:55 1993  Per Bothner  (bothner@cygnus.com)
+
+	* guess-systype:  Patches from John Eaton <jwe@che.utexas.edu>:
+	+ Add Convex, Cray/Unicos, and Encore/Multimax support.
+	+ Execute ./dummy instead of assuming . is in PATH.
+
+Tue Jan 19 17:18:06 1993  Per Bothner  (bothner@cygnus.com)
+
+	* guess-systype:  New shell script.  Attempts to guess the
+	canonical host name of the executing host.
+	Only a few hosts are supported so far.
+	* configure:  Call guess-systype if no host is specified.
+
+Tue Jan 19 08:26:07 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (gcc-no-fixedincludes): Made to work with current
+	gcc Makefile.
+
+
+Fri Jan 15 10:27:02 1993  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (GCC_FLAGS_TO_PASS): New variable.
+	(all-gcc, install-gcc, subdir_do): Use it.
+
+Wed Jan 13 17:06:45 1993  Jim Wilson  (wilson@sphagnum.cygnus.com)
+
+	* Makefile.in: Rename uninstalled gcc driver from gcc to xgcc.
+
+Wed Jan  6 20:29:16 1993  Mike Werner  (mtw@rtl.cygnus.com)
+
+	* Makefile.in: Removed explicit setting of SUBDIRS. SUBDIRS is now
+	  set exclusively by configure, using configure.in .
+
+Wed Jan  6 13:44:11 1993  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* test-build.mk: set $PATH for all builds
+
+	* Makefile.in: pass TARGET_FLAGS_TO_PASS for xiberty and libm
+
+Wed Jan  6 11:02:10 1993  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (GCC_FOR_TARGET):  Supply a default that matches
+	the one used in gcc/Makefile.in, so that a null expansion doesn't
+	override the one needed to build gcc with a native cc.
+
+
+Tue Jan  5 07:55:12 1993  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* configure: Accept -with arguments.
+
+Sun Jan  3 15:15:09 1993  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in: added h8300sim
+
+Tue Dec 29 15:06:00 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* build-all.mk: If canonhost is i386-unknown-sco3.2v4, change it
+	to i386-sco3.2v4.  Set TARGETS and CFLAGS for i386-sco3.2v4.
+	(all-cygnus, native, build-cygnus): Make
+	$(canonhost)-stamp-3stage-done, not $(host)....
+	* test-build.mk (stamp-3stage-compared): Use tail +10c for
+	i386-sco3.2v4.  Added else true to if command.
+
+Mon Dec 28 12:08:56 1992  Ken Raeburn  (raeburn@cygnus.com)
+
+	* config.sub: (from FSF) Sequent uses a BSD-like OS.
+
+Mon Dec 28 08:32:06 1992  Minh Tran-Le  (mtranle@paris.intellicorp.com)
+
+	* configure.in (i[34]86-*-isc*): added; uses mh-sysv.
+
+Thu Dec 24 17:26:24 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: don't remove binutils from Solaris builds
+
+Thu Dec 24 14:08:38 1992 david d`zoo' zuhn  (zoo@cygnus.com)
+
+	* Makefile.in: get rid of earlier definitions for *clean,
+	also handle the recursive info rule better
+
+Thu Dec 24 12:40:21 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (mostlyclean, distclean, realclean):  Fix to
+	do more-or-less the right thing.
+
+Wed Dec 16 10:25:31 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: Add lines defining CC and CXX, and use CXX rather
+	than gcc in definitions of CXX_FOR_BUILD and CXX_FOR_TARGET.
+
+Tue Dec 15 00:34:32 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: change all $(host_cpu)-$(host_vendor)-$(host_os) to
+	$(host_canonical).
+
+	* configure.in: split the configdirs list into 4 categories (native
+	v. cross, library v. tool) and handle the cross-only and native-
+	only in more reasonable (and correct!) way.
+
+Mon Dec 14 17:04:22 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* configure.in (hppa*-*-*):  Don't remove bfd and gdb from
+	configdirs anymore.
+
+Sun Dec 13 00:37:26 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: extensive cleanup::  removed all of the explicit
+	clean-* targets, collapsed many wrappers around subdir_do into
+	one, added additional targets to satisfy standards.texi, deleted
+	some old targets, some changes for consistency
+
+Fri Dec 11 20:18:02 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: handle some programs as cross-only, and others as
+	native only
+
+	* test-build.mk: handle partial holes in a more generic manner
+
+	* Makefile.in: m4 depends on libiberty
+
+Thu Dec  3 21:52:11 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: add m4, textutils, fileutils, sed, shellutils,
+	time, wdiff, and find to configdirs
+
+	* Makefile.in: all, clean, and install rules for the new programs
+	added to configure.in
+
+Mon Nov 30 14:54:34 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: use mh-sun for all *-sun-* hosts
+
+Fri Nov 27 18:35:54 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: define flags for X11 include files and library file
+	locations, pass them down to the programs that need this info
+
+	* build-all.mk: added a 'native' target, to 3stage the native toolchain
+
+Sun Nov 22 18:59:13 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: start building libg++ for HP-UX targets
+
+Wed Nov 18 19:33:11 1992  John Gilmore  (gnu@cygnus.com)
+
+	* README:  Update references to files moved into etc/.
+
+Sun Nov 15 09:36:08 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub (i386sol2, i486sol2):  i[34]86-unknown-solaris2.
+	* configure.in (i[34]86-*-solaris2*):  Use config/mh-sysv4.
+
+Thu Nov 12 08:50:42 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: accept dash as well as underscore in long option
+	names for FSF compatibility.
+
+Wed Nov 11 08:04:37 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub: added -sco3.2v4 support from FSF.
+
+Sun Nov  8 21:14:30 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: expand the section that adds or removes
+	directories from the list of programs to build, to handle native
+	vs. cross in addition to host v. native
+
+Sat Nov  7 18:52:27 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in:  Replace C++ in macro names with CXX.
+	This is less likely to break ...
+
+Sat Nov  7 15:16:58 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* test-build.mk: add -w to GNU_MAKE
+
+Fri Nov  6 23:10:37 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: remove 'sparc'-->'sparc-sun' default transformation,
+	add 'sparc' to list of recognized cpus.  This needed to make
+	'sparc-aout' expand to 'sparc-unknown-aout' instead of 'sparc-sun-aout'.
+	Delete some redundant ose68 variants.  Recognize -wrs as an os,
+	then changes that into $CPU-wrs-vxworks.
+
+	* configure.in: remove most references to gdbtest, regularize
+	target based program removal
+
+	* test-build.mk: import from p3 tree (many fixes and changes)
+
+Fri Nov  6 20:59:00 1992  david d `zoo' zuhn  (zoo@cygnus.com)
+
+	* Makefile.in: added rules to handle tcl, tk, and expect
+
+	* configure.in: handle those directories if they exist
+
+Thu Nov  5 14:35:41 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: removed bogus hppabsd and hppahpux names, since
+	"hppa" is not a valid cpu (hppa1.1 or hppa1.0 are, though)
+
+Thu Oct 29 00:12:41 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: all-gcc now depends on all-binutils.  all-libg++
+	depends upon all-xiberty
+
+	* Makefile.in: changes from p3, including:
+
+	Thu Oct  8 15:00:17 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (XTRAFLAGS): include newlib directories if
+	newlib/Makefile exists, rather than if host != target.
+
+	Fri Sep 25 13:41:52 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -nostdinc to XTRAFLAGS if we are using gcc
+	from the same source tree and not building a cross-compiler.  This
+	matters for the libg++ configuration if reconfiguring a tree that
+	has already been installed.
+
+	Thu Sep 10 10:35:51 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -I for newlib/targ-include to XTRAFLAGS, to
+	pick up the machine and system specific header files.
+
+	* Makefile.in: added AS_FOR_TARGET, passed down in
+	TARGET_FLAGS_TO_PASS.  Added CC_FOR_BUILD, which is intended to be
+	the C compiler to use to create programs which are run in the
+	build environment, set it to default to $(CC), and passed it down
+	in FLAGS_TO_PASS and TARGET_FLAGS_TO_PASS.
+
+	Mon Sep  7 22:34:42 1992  Ian Lance Taylor  (ian@cirdan.cygnus.com)
+
+	* Makefile.in: add $(host) = $(target) tests back to *_FOR_TARGET.
+	We need them for unusual native builds, like systems without
+	ranlib.
+
+	* configure: also define $(host_canonical) and
+	$(target_canonical), which are the full, canonical names for the
+	given host and target
+
+Sun Nov  1 16:38:17 1992  Per Bothner  (bothner@cygnus.com)
+
+	* Makefile.in:  Added separate definitions for C++.
+
+Fri Oct 30 11:37:52 1992  Fred Fish  (fnf@cygnus.com)
+
+	* configure.in (configdirs):  Add deja-gnu.
+
+Fri Oct 23 00:39:18 1992  John Gilmore  (gnu@cygnus.com)
+
+	* README:  Update for configure.texi and gdb-4.7 release.
+
+Wed Oct 21 21:54:27 1992  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in:  Move "all" target to top of file.
+	Previously, first target was ".PHONY" which caused BSD4.4 make
+	to build .PHONY when make was run without arguments.
+
+Mon Oct 19 01:17:54 1992  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in:  Add COPYING.LIB to GDB releases, now that there's
+	Library-copylefted code in libiberty.
+
+Tue Oct 13 01:22:32 1992  John Gilmore  (gnu@cygnus.com)
+
+	* config.sub:  Replace m68kmote with plain old m68k.
+
+Fri Oct  9 03:14:24 1992  John Gilmore  (gnu@cygnus.com)
+
+	* Makefile.in:  Remove space from blank line, avoid Make complaints.
+
+Thu Oct  8 18:41:45 1992  Ken Raeburn  (raeburn@cygnus.com)
+
+	* config.sub: Complain if no argument is given.  Added support for
+	386bsd as OS and target alias.
+
+Thu Oct  8 15:07:22 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in (XTRAFLAGS): include newlib directories if
+	newlib/Makefile exists, rather than if host != target.
+
+Mon Oct  5 03:00:09 1992  Mark Eichin  (eichin at tweedledumber.cygnus.com)
+
+	* config.sub: recognize sparclite-wrs-vxworks.
+
+	* Makefile.in (install-xiberty): added *-xiberty make rules (from
+	p3.) Added clean-xiberty to clean.
+
+Thu Oct  1 17:59:19 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: use *-*-* instead of nested cases for host and target
+
+Tue Sep 29 14:11:18 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -nostdinc to XTRAFLAGS if we are using gcc
+	from the same source tree and not building a cross-compiler.  This
+	matters for the libg++ configuration if reconfiguring a tree that
+	has already been installed.
+
+Sep 20 08:53:10 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub (i486v/i486v4):  Merge in from FSF version.
+
+Fri Sep 18 00:32:00 1992  Mark Eichin  (eichin@cygnus.com)
+
+	* configure: only set PWD if it is already set.
+
+Thu Sep 17 23:05:53 1992  Mark Eichin  (eichin@cygnus.com)
+
+	* configure: just set PWD=`pwd` at the top, since Ultrix sh
+	doesn't have unset and all success paths (and most error paths)
+	out set it anyway. (Note: should change all uses of ${PWD=`pwd`}
+	to just ${PWD} to avoid confusion.)
+
+Tue Sep 15 16:00:54 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: always set $(tooldir) to $(libdir)/$(target_alias),
+	even for a native compilation.
+
+Tue Sep 15 02:22:56 1992  John Gilmore  (gnu@cygnus.com)
+
+	Changes to make the gdb.tar.Z rule work better.
+
+	* Makefile.in (GDB_SUPPORT_DIRS):  Add opcodes.
+	(DEVO_SUPPORT):  Add configure.texi.
+	(bfd-ilrt.tar.Z):  Remove ancient rule.
+
+Thu Sep 10 10:43:19 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added -I for newlib/targ-include to XTRAFLAGS, to
+	pick up the machine and system specific header files.
+
+	* configure.in, config.sub: added new target m68010-adobe-scout,
+	with alias of adobe68k.  Changed configure.in to check for
+	-scout before -sco* to avoid a false match.
+
+	* Makefile.in: added AS_FOR_TARGET, passed down in
+	TARGET_FLAGS_TO_PASS.  Added CC_FOR_BUILD, which is intended to be
+	the C compiler to use to create programs which are run in the
+	build environment, set it to default to $(CC), and passed it down
+	in FLAGS_TO_PASS and TARGET_FLAGS_TO_PASS.
+
+Wed Sep  9 12:21:42 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* Makefile.in: added TARGET_FLAGS_TO_PASS, CC_FOR_TARGET,
+	AR_FOR_TARGET, RANLIB_FOR_TARGET, NM_FOR_TARGET.  Pass
+	TARGET_FLAGS_TO_PASS, which defines CC, AR, RANLIB and NM as the
+	FOR_TARGET variants, to newlib and libg++.
+
+Tue Sep  8 17:28:30 1992  Ken Raeburn  (raeburn@cambridge.cygnus.com)
+
+	* Makefile.in (all-gas, all-gdb): Require all-opcodes to be built
+	first.
+
+Wed Sep  2 02:50:05 1992  John Gilmore  (gnu@cygnus.com)
+
+	* config.sub:  Accept `elf' as an environment.
+
+Tue Sep  1 15:48:30 1992  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in (all-opcodes):  cd into the right directory
+
+Sun Aug 30 21:12:11 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* configure: added -program_transform_name option, used as
+	argument to sed when installing programs.
+	configure.texi: added documentation for -program_prefix,
+	-program_suffix and -program_transform_name.
+
+Thu Aug 27 21:59:44 1992  John Gilmore  (gnu@cygnus.com)
+
+	* config.sub:  Accept i486 where i386 ok.
+
+Thu Aug 27 13:04:42 1992  Brendan Kehoe  (brendan@rtl.cygnus.com)
+
+	* config.sub: accept we32k
+
+Mon Aug 24 14:05:14 1992  Ian Lance Taylor  (ian@cygnus.com)
+
+	* config.sub, configure.in: accept OSE68000 and OSE68k.
+
+	* Makefile.in: don't create all directories for ``make install'';
+	let the subdirectories create the ones they need.
+
+Tue Aug 11 23:13:17 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* COPYING: new file, GPL v2
+
+Tue Aug  4 01:12:43 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: use the new gen-info-dir, which needs a template
+	argument (which also lives in texinfo)
+
+	* configure.texi, standards.texi: fix INFO-DIR-ENTRY
+
+Mon Aug  3 00:34:17 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub (ncr3000):  Change i386 to i486.
+
+Thu Jul 23 00:12:17 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* Makefile.in: add install-rcs, install-grep to
+	install-no-fixedincludes, removed install-bison and install-libgcc
+
+Tue Jul 21 01:01:50 1992  david d `zoo' zuhn (zoo@cygnus.com)
+
+	* configure.in: grab the HPUX makefile fragment if on HPUX
+
+Mon Jul 20 11:02:09 1992  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* Makefile.in: eradicate bison spoor (ditto libgcc).
+	 configure.in: recognise m68{k,000}-ericsson-OSE.
+	 es1800 is alias for m68k-ericsson-OSE
+
+Sun Jul 19 17:49:02 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: rearrange the parts that remove programs from
+	configdirs, based now on HOST==TARGET or by canonical triple.
+
+Fri Jul 17 22:52:49 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* test-build.mk: recurse explicitly with -f test-build.mk when
+	  appropriate.  predicate stage3 and comparison on the existence
+	  of gcc.  That is, if gcc isn't around, we aren't three-staging.
+	  On very clean, also remove ...stamp-co.  Build in-place before
+	  doing other builds.
+
+Thu Jul 16 18:33:09 1992  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* Makefile.in, configure.in: add tgas
+
+Thu Jul 16 16:05:28 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: a number of changes merged in from progressive.
+
+	* configure.in: add libm.
+
+	* .cvsignore: ignore some stuff that comes from test-build.mk.
+
+Tue Jul  7 00:24:52 1992  Fred Fish  (fnf@cygnus.com)
+
+	* config.sub:  Add es1800 (m68k-ericsson-es1800).
+
+Tue Jun 30 20:24:41 1992  D. V. Henkel-Wallace  (gumby@cygnus.com)
+
+	* configure: Add program_suffix (parallel to program_prefix)
+	* Makefile.in: adjust directory-creating script for losing decstation
+
+Mon Jun 22 23:43:48 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure:  Minor $subdir-related fixes.
+
+Mon Jun 22 18:30:26 1992  Steve Chamberlain  (sac@thepub.cygnus.com)
+
+	* configure: fix various problems with propogating
+	makefile_target_frag in subdirs.
+	* configure.in: config libgcc if its there
+
+Fri Jun 19 15:19:40 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* config.sub:  HPPA merge.
+
+Sun Jun 14 10:29:19 1992  John Gilmore  (gnu at cygnus.com)
+
+	* Makefile.in:  Replace all-bison with all-byacc in all
+	dependency lines for other tools (which now use byacc).
+
+Fri Jun 12 22:21:57 1992  John Gilmore  (gnu at cygnus.com)
+
+	* config.sub:  Add sun4sol2 => sparc-sun-solaris2.
+
+Thu Jun  4 12:07:32 1992  Mark Eichin  (eichin@cygnus.com)
+
+	* Makefile.in: make gprof rules similar to byacc rules (instead of
+	vestigal $(unsubdir) that didn't work...)
+
+Thu Jun  4 00:37:05 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* config.sub:  Add support for Linux.
+	* Makefile.in:  Use $(FLAGS_TO_PASS) more consistently
+	(at least for libg++).
+
+Tue Jun 02 20:03:00 1992  david d `zoo' zuhn (zoo@cygnus.com)
+
+	* configure.texi: fix doc for the -nfp option to configure
+
+Tue Jun  2 17:20:52 1992  Michael Tiemann  (tiemann@cygnus.com)
+
+	* Makefile.in (all-binutils): ar needs flex, so depend on all-flex.
+
+Sun May 31 15:04:08 1992  Mark Eichin  (eichin at cygnus.com)
+
+	* config.sub: changed [^-]+ to [^-][^-]* so that it works under
+	Sun sed. (BSD 4.3 sed doesn't handle [^-]+ either.)
+	* configure.in: added solaris* host_makefile_frag hook.
+
+Sun May 31 01:10:34 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub: changed recognition of m68000 so that various
+	m68k types can be specified via m680[01234]0
+
+Sat May 30 21:01:06 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* config.sub (basic_machine): fix sed so that '-foo' isn't
+	completely substituted out while .+'-foo' loses the '-foo'
+
+Wed May 27 23:18:52 1992  Michael Tiemann  (tiemann@rtl.cygnus.com)
+
+	* config.sub ($os): Add -aout.
+
+Fri May 22 14:00:02 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure:  If host_makefile_frag is absolute, don't
+	prefix ${invsubdir} (relevant to libg++ auto-configure).
+
+Thu May 21 18:00:09 1992  Michael Tiemann  (tiemann@rtl.cygnus.com)
+
+	* Makefile.in (tooldir): Define it.
+	(all-ld): Depend on all-flex.
+
+Sun May 10 21:45:59 1992  Per Bothner  (bothner@rtl.cygnus.com)
+
+	* Makefile.in (check):  Fix libg++ special case.
+
+Fri May  8 08:31:41 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: do not bury `pwd` into config.status, thus do fewer
+	  pwd's.
+
+	* configure: print the "Building in" message only when building in
+	  other than "." AND verbose.
+
+	* configure: remove -s, rework -v to better accomodate guested
+	  configures.
+
+	* standards.texi: updated to 3 may, fixed librid <-> libdir typo.
+
+Fri May  1 18:00:50 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: macroize flags passed on recursion.  remove
+	  fileutils.
+
+Thu Apr 30 08:56:20 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: get makesrcdir right for subdirs deeper than 1.
+
+	* Makefile.in: pass INSTALL, INSTALL_DATA, INSTALL_PROGRAM on
+	  install.
+
+Fri Apr 24 15:51:51 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: don't print subdir_do or recursion lines.
+
+Fri Apr 24 15:22:04 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* standards.texi: added menu item.
+
+	* Makefile.in: build and install standards.info.
+
+	* standards.texi: new file.
+
+Wed Apr 22 18:06:55 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: test for and move config.status pieces from
+	  ${subdir}/.
+
+Wed Apr 22 14:38:34 1992  Fred Fish  (fnf@cygnus.com)
+
+	* configure:  Test for existance of files before trying to mv
+	them, to avoid numerous non-existance messages.
+
+Tue Apr 21 12:31:33 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: correct final line of config.status.
+
+	* configure: patch from eggert.  Avoids a protection problem if
+	  the original Makefile.in is read only.
+
+	* configure: use move-if-change from gcc to create config.status.
+	  Some makefiles depend on config.status to tell if a directory
+	  has been reconfigured for a different host.  This change
+	  prevents those directories from remaking everything in the case
+	  where the reconfig was only intended to rebuild a Makefile.
+
+	* configure: test for config.sub with "config.sub sun4" rather
+	  than "config.sub ${host_alias}".  Otherwise we can't tell a bad
+	  host alias from a missing config.sub.
+
+Mon Apr 20 18:16:36 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: explicitly pass CFLAGS on recursion. no longer pass
+	  MINUS_G (this can be done with CFLAGS).  Default CFLAGS to -g.
+
+Fri Apr 17 18:27:51 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure: mkdir ${subdir} as needed.
+
+Wed Apr 15 17:37:22 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in,configure.in: added autoconf.
+
+Wed Apr 15 17:27:34 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: no longer pass against on recursion.
+
+	* Makefile.in: added .NOEXPORT: so that stray makefile_frag
+	  definitions are not inherited.
+
+	* configure: correct makesrcdir when subdir is .
+
+Tue Apr 14 11:56:09 1992  Per Bothner  (bothner@cygnus.com)
+
+	* configure:  Add support for 'subdirs' variable, which is
+	like 'configdirs', except that configure doesn't re-invoke
+	itself for subdirs, it just creates a Makefile for each subdir.
+	* configure.texi:  Document subdirs.
+
+Mon Apr 13 18:50:16 1992  david d `zoo' zuhn  (zoo at cirdan.cygnus.com)
+
+	* configure.in: added flex to configdirs
+
+Mon Apr 13 18:43:55 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: remove clean-stamps from clean.
+
+Sat Apr 11 03:52:03 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.in:  Add gdbtest to configdirs.
+
+Fri Apr 10 23:11:49 1992  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in (MINUS_G):  Add macro, default to -g, pass on
+	to recursive makes.
+	* configure.in:  Recognize new ncr3000 config.
+
+Wed Apr  8 23:08:12 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in, configure.in: removed references to gdbm.
+
+Tue Apr  7 16:48:20 1992  Per Bothner  (bothner@cygnus.com)
+
+	* config.sub:  Don't canonicalize os value
+	newsos* to bsd (readline needs to check for newsos).
+	(This fix was earlier made Jan 31, but got re-broken.)
+
+Mon Apr  6 14:34:08 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* configure.in:  sco is an os, not a vendor!
+
+	* configure:  Quote $( better.  Keep various shells happy.
+
+Tue Mar 31 16:32:57 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: eliminate stamp-files.
+
+Mon Mar 30 22:20:23 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: add send_pr.  remove "force" from .stmp-gprof rule.
+	  Supress echoing of all the "if [ -d ... $(MAKE)" lines.
+
+Wed Mar 25 15:20:04 1992  Stu Grossman  (grossman@cygnus.com)
+
+	* config.sub:  fix iris/iris3.
+
+Wed Mar 25 10:34:19 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: re-add -rm.
+
+Tue Mar 24 23:50:16 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Maskefile.in: add .stmp-rcs to all.
+
+	* configure.in: remove gas from rs6000 build, use aix host fragment.
+
+Mon Mar 23 19:43:35 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: pass down site_option during recursion.
+
+Thu Mar 19 16:49:36 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in (all.cross):  Add .stmp-bfd .stmp-readline.
+
+Wed Mar 18 15:29:33 1992  Mike Stump  (mrs@cygnus.com)
+
+	* configure: Change exec_prefix so that it really defaults to prefix.
+
+Sat Mar 14 17:20:38 1992  Fred Fish  (fnf@cygnus.com)
+
+	* Makefile.in, configure.in:  Add support for mmalloc library.
+
+Fri Mar 13 18:44:18 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: add stmp dependencies for a few more things.
+
+Thu Mar 12 04:56:24 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* configure: adjusted error message on objdir/srcdir configure
+	  collision, per john's suggestion.
+
+	* Makefile.in: add libiberty stmp to all and all.cross.
+
+Wed Mar 11 02:07:52 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in: remove force dependencies, add grep to all.
+
+Tue Mar 10 21:49:18 1992  K. Richard Pixley  (rich@mars.cygnus.com)
+
+	* Makefile.in: drop flex.  make stamp files work.
+
+	* configure: added test for conflicting configuration in srcdir,
+	  remove trailing slashes from srcdir.  Otherwise emacs gdb mode
+	  gets cranky.  use relative paths for configure and srcdir
+	  whenever possible.  Send some error messages to stderr that were
+	  going to stdout.
+
+Tue Mar 10 18:01:55 1992  Per Bothner  (bothner@cygnus.com)
+
+	* Makefile.in:  Fix libg++ rule to check for gcc directory
+	before using gcc/gcc.  Also pass XTRAFLAGS.
+
+Thu Mar  5 21:45:07 1992  K. Richard Pixley  (rich@sendai)
+
+	* Makefile.in: added stmp-files so that directories aren't polled
+	  when they are already built.
+
+	* configure.texi: fixed a node pointer problem.
+
+Thu Mar  5 12:05:58 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* config.sub configure.in gdb/configure.in
+	gdb/mips-tdep.c gdb/mipsread.c gdb/procfs.c gdb/signame.h
+	gdb/tm-irix3.h gdb/tm-mips.h gdb/xm-irix4.h gdb/config/mt-irix3
+	gdb/config/mh-irix4 texinfo/configure.in:  Port to SGI Irix-4.x.
+
+Wed Mar  4 02:57:46 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: -recurring becomes -silent.  corrected help message
+	  for -site= option.
+
+	* Makefile.in: mkdir $(exec_prefix) and $(tooldir).
+
+Tue Mar  3 14:51:21 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* configure: when building Makefile for crosses, replace
+	  tooldir and program_prefix.  default srcdir from location of
+	  config.sub.  remove "for host in hosts" and "for target in
+	  targets" loops.
+
+Wed Feb 26 19:48:25 1992  K. Richard Pixley  (rich@rtl.cygnus.com)
+
+	* Makefile.in: Do not pass bindir or mandir to cvs.
+
+Wed Feb 26 18:04:40 1992  K. Richard Pixley  (rich@cygnus.com)
+
+	* Makefile.in, configure.in: removed traces of namesubdir,
+	  -subdirs, $(subdir), $(unsubdir), some rcs triggers.  Forced
+	  copyrights to '92, changed some from Cygnus to FSF.
+
+	* configure.texi: remove most references to multiple hosts,
+	  multiple targets, subdirs, etc.
+
+	* configure.man: removed rcsid. reference config.sub not
+	  config.subr.
+
+	* Makefile.in: mkdir $(infodir) on install-info.
+
+Wed Feb 19 15:41:13 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.texi:  Explain better about .gdbinit and about
+	the environment that configure.in sections run in.
+
+Fri Feb  7 07:55:00 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.in:  Ultrix is only a decstation if it's a MIPS.
+
+Fri Jan 31 21:54:51 1992  John Gilmore  (gnu at cygnus.com)
+
+	* README:  DOC.configure => cfg-paper.texi.
+
+Fri Jan 31 21:48:18 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* config.sub (near case $os):  Don't convert newsos* to bsd!
+
+Fri Jan 31 02:27:32 1992  John Gilmore  (gnu at cygnus.com)
+
+	* Makefile.in:  Reinstall change from gdb-4.3 that reduces
+	the number of copies of COPYING that go into the GDB tar file.
+
+Thu Jan 30 16:17:30 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* bfd/configure.in, gdb/config/mh-i386sco,
+	gdb/config/mt-i386v32, gdb/configure.in, readline/configure.in:
+	Fix SCO configuration stuff.
+
+Tue Jan 28 23:51:07 1992  Per Bothner  (bothner at cygnus.com)
+
+	* Makefile.in:  For libg++, make sure the -I pointing
+	to the gcc directory goes *after* all the libg++-local -I flags.
+	Also, move just-gcc dependency from just-libg++ to all-libg++.
+
+Tue Jan 28 12:56:24 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* configure:  Change -x to -f to keep Ultrix /bin/test happy.
+
+Sat Jan 18 17:45:11 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in (make-gdb.tar.Z):  Remove texinfo targets.
+
+Sat Jan 18 17:03:21 1992  Fred Fish  (fnf at cygnus.com)
+
+	* config.sub:  Add stratus configuration frags.  Also
+	submitted to FSF.
+
+Sat Jan 18 15:35:29 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in (DEV_SUPPORT):  add configure.man.
+
+	* config.sub(Decode manufacturer-specific):  add -none*.
+
+Fri Jan 17 17:58:05 1992  Stu Grossman  (grossman at cygnus.com)
+
+	* Makefile.in:  remove form feeds to make Sun's make happy.
+	(DEVO_SUPPORT):  DOC.configure => cfg-paper.texi.
+
+Sat Jan  4 16:11:44 1992  John Gilmore  (gnu at cygnus.com)
+
+	* Makefile.in (AR_FLAGS):  Make quieter.
+
+Thu Jan  2 22:57:12 1992  John Gilmore  (gnu at cygnus.com)
+
+	* configure.in:  Add libg++.
+	* configure:  When verbose, don't output the command line at each
+	level; it will be unremarkably the same as the previous version,
+	which will be the same as what the user typed.
+
+Fri Dec 27 16:26:47 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* configure.in, Makefile.in: fix clean-info, add flex.  add
+	  fileutils.
+
+	* configure: be less sensitive to spaces in Makefile.in.  Do not
+	  look for sources in "..".  Doing so breaks subdirectories that
+	  might have their own configure.  If a subdir has it's own
+	  configure script, use it.
+
+Thu Dec 26 16:30:26 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* cfg-paper.texi: some changes suggested by rms.
+
+Thu Dec 26 10:13:36 1991  Fred Fish  (fnf at cygnus.com)
+
+	* config.sub:  Merge in some small additions from the FSF version,
+	taken from the gcc distribution, to bring the Cygnus and FSF
+	versions into closer sync.
+
+Fri Dec 20 11:34:18 1991  Fred Fish  (fnf at cygnus.com)
+
+	* configure.in:  Changed svr4 references to sysv4.
+
+Thu Dec 19 15:54:29 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* configure: added -V for version number option.
+
+Wed Dec 18 15:39:34 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* DOC.configure, cfg-paper.texi: revised, updated, and texinfo'd.
+	  renamed from DOC.configure to cfg-paper.texi.
+
+Mon Dec 16 23:05:19 1991  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure, config.subr, config.sub: config.subr is now
+	  config.sub again.
+
+Fri Dec 13 01:17:06 1991  K. Richard Pixley  (rich at cygnus.com)
+
+	* configure.texi: new file, in progress.
+
+	* Makefile.in: build info file and install the man page for
+	  configure.
+
+	* configure.man: new file, first cut.
+
+	* configure: find config.subr again now that configuration "none"
+	  has gone.  removed all traces of the -ansi option.  removed all
+	  traces of the -languages option.
+
+	* config.subr: resync from rms.
+
+1991-12-11  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure, config.sub, config.subr: merge config.sub into
+	  config.subr, call the result config.subr, remove config.sub, use
+	  config.subr.
+
+	* Makefile.in: revised install for dir.info.
+
+1991-12-10  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure.in: add decstation host makefile frag.
+
+	* Makefile.in: BISON now bison -y again.  also install-gcc on
+	  install.  clean-gdbm on clean.  infodir belongs in datadir.
+	  Make directories for info install.  Build dir.info here then
+	  install it.
+
+1991-12-09  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* Makefile.in: fix for bad directory tests.
+
+1991-12-07  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure: \{1,2\} appears to be a sysv'ism.  Use a different
+	  regexp.  -srcdir relative was being handled incorrectly.
+
+	* Makefile.in: unwrapped some for loops so that parallel makes
+	  work again and so one can focus one's attention on a particular
+	  package.
+
+1991-12-06  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure: added PWD as a stand in for `pwd` (for speed). use
+	  elif wherever possible.  make -srcdir work without -objdir.
+	  -objdir= commented out.
+
+1991-12-05  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* configure: +options become --options.  -subdirs commented out.
+	  added -host, -datadir.  Renamed -destdir to -prefix.  Comment in
+	  Makefile now at top of generated Makefile.  Removed cvs log
+	  entries.  added -srcdir.  create .gdbinit only if there is one
+	  in ${srcdir}.
+
+	* Makefile.in: idestdir and ddestdir go away.  Added copyrights
+	  and shift gpl to v2.  Added ChangeLog if it didn't exist. docdir
+	  and mandir now keyed off datadir by default.
+
+1991-11-22  K. Richard Pixley  (rich at rtl.cygnus.com)
+
+	* Freshly created ChangeLog.
+
+
+Local Variables:
+mode: change-log
+left-margin: 8
+fill-column: 76
+version-control: never
+End:
diff --git a/ChangeLog.sts-gdb b/ChangeLog.sts-gdb
new file mode 100644
index 0000000..2797a05
--- /dev/null
+++ b/ChangeLog.sts-gdb
@@ -0,0 +1,5 @@
+2008-07-18  Denis Pilat  <denis.pilat@st.com>
+
+	* libdecnumber: upgraded to latest vresion to fix Solaris compilation problem.
+
+
diff --git a/bfd/ChangeLog.sts-gdb b/bfd/ChangeLog.sts-gdb
new file mode 100644
index 0000000..984c1f7
--- /dev/null
+++ b/bfd/ChangeLog.sts-gdb
@@ -0,0 +1,18 @@
+2007-09-14  Antony King  <antony.king@st.com>
+
+	Fix INSbl27871:
+	* config.bfd: Add sh*-superh-elf* target.
+
+2006-10-17  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* bfd.c (_bfd_abort): Add exit to silence a warning from GCC 2.95.2.
+
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* archures.c: Add st40-300 variants.
+	* bfd-in2.h: Likewise.
+	* cpu-sh.c: Likewise.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* po/Make-in: Do the 'chmod -w' after the move. Cygwin prefers it.
diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 8e0a79c..69488b1 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -83,6 +83,7 @@ ALL_MACHINES = \
 	cpu-i960.lo \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
+	cpu-lx.lo \
 	cpu-m32c.lo \
 	cpu-m32r.lo \
 	cpu-m68hc11.lo \
@@ -149,6 +150,7 @@ ALL_MACHINES_CFILES = \
 	cpu-i960.c \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
+	cpu-lx.c \
 	cpu-m32c.c \
 	cpu-m32r.c \
 	cpu-m68hc11.c \
@@ -264,6 +266,8 @@ BFD32_BACKENDS = \
 	elf32-i960.lo \
 	elf32-ip2k.lo \
 	elf32-iq2000.lo \
+	elf32-lx.lo \
+	elf32-lx-linux.lo \
 	elf32-m32c.lo \
 	elf32-m32r.lo \
 	elf32-m68hc11.lo \
@@ -319,6 +323,7 @@ BFD32_BACKENDS = \
 	i386mach3.lo \
 	i386os9k.lo \
 	ieee.lo \
+	ipa_bfd.lo \
 	m68k4knetbsd.lo \
 	m68klinux.lo \
 	m68knetbsd.lo \
@@ -445,6 +450,8 @@ BFD32_BACKENDS_CFILES = \
 	elf32-i960.c \
 	elf32-ip2k.c \
 	elf32-iq2000.c \
+	elf32-lx.c \
+	elf32-lx-linux.c \
 	elf32-m32c.c \
 	elf32-m32r.c \
 	elf32-m68k.c \
@@ -500,6 +507,7 @@ BFD32_BACKENDS_CFILES = \
 	i386mach3.c \
 	i386os9k.c \
 	ieee.c \
+    ipa_bfd.c \
 	m68k4knetbsd.c \
 	m68klinux.c \
 	m68knetbsd.c \
@@ -1421,6 +1429,14 @@ elf32-iq2000.lo: elf32-iq2000.c $(INCDIR)/filenames.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
   $(INCDIR)/elf/iq2000.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-lx.lo: elf32-lx.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/lx.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
+elf32-lx-linux.lo: elf32-lx-linux.c elf32-lx.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/lx.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-m32c.lo: elf32-m32c.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/m32c.h \
@@ -1656,6 +1672,7 @@ i386os9k.lo: i386os9k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/bfdlink.h libaout.h $(INCDIR)/os9k.h
 ieee.lo: ieee.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/ieee.h libieee.h $(INCDIR)/safe-ctype.h
+ipa_bfd.lo: ipa_bfd.c ipa_bfd.h
 m68k4knetbsd.lo: m68k4knetbsd.c netbsd.h $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h libaout.h $(INCDIR)/bfdlink.h aout-target.h \
   $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def \
@@ -1988,6 +2005,7 @@ elf64-ia64.lo: elf64-ia64.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
 peigen.lo: peigen.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/i386.h $(INCDIR)/coff/external.h \
   $(INCDIR)/coff/pe.h libcoff.h $(INCDIR)/bfdlink.h libpei.h
+ipa_bfd.lo: ipa_bfd.c $(INCDIR)/filenames.h
 pepigen.lo: pepigen.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/ia64.h $(INCDIR)/coff/external.h \
   $(INCDIR)/coff/pe.h libcoff.h $(INCDIR)/bfdlink.h libpei.h
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index be000ae..adccf44 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -333,6 +333,7 @@ ALL_MACHINES = \
 	cpu-i960.lo \
 	cpu-ip2k.lo \
 	cpu-iq2000.lo \
+	cpu-lx.lo \
 	cpu-m32c.lo \
 	cpu-m32r.lo \
 	cpu-m68hc11.lo \
@@ -399,6 +400,7 @@ ALL_MACHINES_CFILES = \
 	cpu-i960.c \
 	cpu-ip2k.c \
 	cpu-iq2000.c \
+	cpu-lx.c \
 	cpu-m32c.c \
 	cpu-m32r.c \
 	cpu-m68hc11.c \
@@ -515,6 +517,8 @@ BFD32_BACKENDS = \
 	elf32-i960.lo \
 	elf32-ip2k.lo \
 	elf32-iq2000.lo \
+	elf32-lx.lo \
+	elf32-lx-linux.lo \
 	elf32-m32c.lo \
 	elf32-m32r.lo \
 	elf32-m68hc11.lo \
@@ -570,6 +574,7 @@ BFD32_BACKENDS = \
 	i386mach3.lo \
 	i386os9k.lo \
 	ieee.lo \
+	ipa_bfd.lo \
 	m68k4knetbsd.lo \
 	m68klinux.lo \
 	m68knetbsd.lo \
@@ -696,6 +701,8 @@ BFD32_BACKENDS_CFILES = \
 	elf32-i960.c \
 	elf32-ip2k.c \
 	elf32-iq2000.c \
+	elf32-lx.c \
+	elf32-lx-linux.c \
 	elf32-m32c.c \
 	elf32-m32r.c \
 	elf32-m68k.c \
@@ -751,6 +758,7 @@ BFD32_BACKENDS_CFILES = \
 	i386mach3.c \
 	i386os9k.c \
 	ieee.c \
+	ipa_bfd.c \
 	m68k4knetbsd.c \
 	m68klinux.c \
 	m68knetbsd.c \
@@ -2002,6 +2010,14 @@ elf32-iq2000.lo: elf32-iq2000.c $(INCDIR)/filenames.h \
   $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h \
   $(INCDIR)/elf/iq2000.h $(INCDIR)/elf/reloc-macros.h \
   elf32-target.h
+elf32-lx.lo: elf32-lx.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/lx.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
+elf32-lx-linux.lo: elf32-lx-linux.c elf32-lx.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/lx.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-m32c.lo: elf32-m32c.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/m32c.h \
@@ -2237,6 +2253,7 @@ i386os9k.lo: i386os9k.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/bfdlink.h libaout.h $(INCDIR)/os9k.h
 ieee.lo: ieee.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/ieee.h libieee.h $(INCDIR)/safe-ctype.h
+ipa_bfd.lo: ipa_bfd.c ipa_bfd.h
 m68k4knetbsd.lo: m68k4knetbsd.c netbsd.h $(INCDIR)/filenames.h \
   $(INCDIR)/hashtab.h libaout.h $(INCDIR)/bfdlink.h aout-target.h \
   $(INCDIR)/aout/aout64.h $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def \
@@ -2569,6 +2586,7 @@ elf64-ia64.lo: elf64-ia64.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
 peigen.lo: peigen.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/i386.h $(INCDIR)/coff/external.h \
   $(INCDIR)/coff/pe.h libcoff.h $(INCDIR)/bfdlink.h libpei.h
+ipa_bfd.lo: ipa_bfd.c $(INCDIR)/filenames.h
 pepigen.lo: pepigen.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/ia64.h $(INCDIR)/coff/external.h \
   $(INCDIR)/coff/pe.h libcoff.h $(INCDIR)/bfdlink.h libpei.h
diff --git a/bfd/archures.c b/bfd/archures.c
index 9a5c7c4..24a31dd 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -1,8 +1,12 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* BFD library support routines for architectures.
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
    Hacked by John Gilmore and Steve Chamberlain of Cygnus Support.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -264,6 +268,11 @@ DESCRIPTION
 .#define bfd_mach_sh4        0x40
 .#define bfd_mach_sh4_nofpu  0x41
 .#define bfd_mach_sh4_nommu_nofpu  0x42
+.#define bfd_mach_st40_300   0x430
+.#define bfd_mach_st40_300_nofpu 0x431
+.#define bfd_mach_st40_300_nofpu_or_sh2a_nofpu 0x432
+.#define bfd_mach_st40_300_nofpu_or_sh4a_nofpu 0x433
+.#define bfd_mach_st40_300_or_sh4a 0x434
 .#define bfd_mach_sh4a       0x4a
 .#define bfd_mach_sh4a_nofpu 0x4b
 .#define bfd_mach_sh4al_dsp  0x4d
@@ -402,6 +411,9 @@ DESCRIPTION
 .#define bfd_mach_z80            3 {* With ixl, ixh, iyl, and iyh.  *}
 .#define bfd_mach_z80full        7 {* All undocumented instructions.  *}
 .#define bfd_mach_r800           11 {* R800: successor with multiplication.  *}
+.  bfd_arch_lx,        {* STMicroelectronics ST200 *}
+.#define bfd_mach_st231                0
+.#define bfd_mach_st240                1
 .  bfd_arch_last
 .  };
 */
@@ -505,6 +517,7 @@ extern const bfd_arch_info_type bfd_xtensa_arch;
 extern const bfd_arch_info_type bfd_xc16x_arch;
 extern const bfd_arch_info_type bfd_z80_arch;
 extern const bfd_arch_info_type bfd_z8k_arch;
+extern const bfd_arch_info_type bfd_lx_arch;
 
 static const bfd_arch_info_type * const bfd_archures_list[] =
   {
@@ -574,6 +587,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
     &bfd_xc16x_arch,
     &bfd_z80_arch,
     &bfd_z8k_arch,
+    &bfd_lx_arch,
 #endif
   0
 };
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index c1b5341..f1488ee 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -10,6 +10,7 @@
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    Contributed by Cygnus Support.
 
@@ -1941,6 +1942,11 @@ enum bfd_architecture
 #define bfd_mach_sh4        0x40
 #define bfd_mach_sh4_nofpu  0x41
 #define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_st40_300   0x430
+#define bfd_mach_st40_300_nofpu 0x431
+#define bfd_mach_st40_300_nofpu_or_sh2a_nofpu 0x432
+#define bfd_mach_st40_300_nofpu_or_sh4a_nofpu 0x433
+#define bfd_mach_st40_300_or_sh4a 0x434
 #define bfd_mach_sh4a       0x4a
 #define bfd_mach_sh4a_nofpu 0x4b
 #define bfd_mach_sh4al_dsp  0x4d
@@ -2079,6 +2085,9 @@ enum bfd_architecture
 #define bfd_mach_z80            3 /* With ixl, ixh, iyl, and iyh.  */
 #define bfd_mach_z80full        7 /* All undocumented instructions.  */
 #define bfd_mach_r800           11 /* R800: successor with multiplication.  */
+  bfd_arch_lx,        /* STMicroelectronics ST200 */
+#define bfd_mach_st231                0
+#define bfd_mach_st240                1
   bfd_arch_last
   };
 
@@ -2974,6 +2983,46 @@ probably a 32 bit wide absolute relocation, but the target can choose.
 It generally does map to one of the other relocation types.  */
   BFD_RELOC_CTOR,
 
+/* LX relocations  */
+  BFD_RELOC_LX_16,
+  BFD_RELOC_LX_32,
+  BFD_RELOC_LX_32_PCREL,
+  BFD_RELOC_LX_23_PCREL,
+  BFD_RELOC_LX_HI23,
+  BFD_RELOC_LX_LO9,
+  BFD_RELOC_LX_GPREL_HI23,
+  BFD_RELOC_LX_GPREL_LO9,
+  BFD_RELOC_LX_REL32,
+  BFD_RELOC_LX_GOTOFF_HI23,
+  BFD_RELOC_LX_GOTOFF_LO9,
+  BFD_RELOC_LX_GOTOFFX_HI23,
+  BFD_RELOC_LX_GOTOFFX_LO9,
+  BFD_RELOC_LX_LTV32,
+  BFD_RELOC_LX_SEGREL32,
+  BFD_RELOC_LX_FPTR32,
+  BFD_RELOC_LX_PLTOFF_HI23,
+  BFD_RELOC_LX_PLTOFF_LO9,
+  BFD_RELOC_LX_GOTOFF_FPTR_HI23,
+  BFD_RELOC_LX_GOTOFF_FPTR_LO9,
+  BFD_RELOC_LX_IPLT,
+  BFD_RELOC_LX_NEG_GPREL_HI23,
+  BFD_RELOC_LX_NEG_GPREL_LO9,
+  BFD_RELOC_LX_COPY,
+  BFD_RELOC_LX_JMP_SLOT,
+  BFD_RELOC_LX_TPREL_HI23,
+  BFD_RELOC_LX_TPREL_LO9,
+  BFD_RELOC_LX_TPREL32,
+  BFD_RELOC_LX_GOTOFF_TPREL_HI23,
+  BFD_RELOC_LX_GOTOFF_TPREL_LO9,
+  BFD_RELOC_LX_GOTOFF_DTPLDM_HI23,
+  BFD_RELOC_LX_GOTOFF_DTPLDM_LO9,
+  BFD_RELOC_LX_DTPREL_HI23,
+  BFD_RELOC_LX_DTPREL_LO9,
+  BFD_RELOC_LX_DTPMOD32,
+  BFD_RELOC_LX_DTPREL32,
+  BFD_RELOC_LX_GOTOFF_DTPNDX_HI23,
+  BFD_RELOC_LX_GOTOFF_DTPNDX_LO9,
+
 /* ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
 not stored in the instruction.  */
   BFD_RELOC_ARM_PCREL_BRANCH,
diff --git a/bfd/bfd.c b/bfd/bfd.c
index da27baa..977168b 100644
--- a/bfd/bfd.c
+++ b/bfd/bfd.c
@@ -850,6 +850,7 @@ _bfd_abort (const char *file, int line, const char *fn)
        BFD_VERSION_STRING, file, line);
   (*_bfd_error_handler) (_("Please report this bug.\n"));
   _exit (EXIT_FAILURE);
+  exit(EXIT_FAILURE);  /* Make sure the compiler knows this doesn't return.  */
 }
 
 /*
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 03ef1c3..a61209b 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -1,3 +1,4 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
 # config.bfd
 # Convert a canonical host type into a BFD host type.
 # Set shell variable targ to canonical target name, and run
@@ -85,6 +86,7 @@ fido*)		 targ_archs=bfd_m68k_arch ;;
 hppa*)		 targ_archs=bfd_hppa_arch ;;
 i[3-7]86)	 targ_archs=bfd_i386_arch ;;
 i370)		 targ_archs=bfd_i370_arch ;;
+lx*)             targ_archs=bfd_lx_arch ;;
 m6811*|m68hc11*) targ_archs="bfd_m68hc11_arch bfd_m68hc12_arch" ;;
 m6812*|m68hc12*) targ_archs="bfd_m68hc12_arch bfd_m68hc11_arch" ;;
 m68*)		 targ_archs=bfd_m68k_arch ;;
@@ -1262,7 +1264,7 @@ case "${targ}" in
     ;;
 
 #ifdef BFD64
-  shl*-*-elf* | sh[1234]l*-*-elf* | sh3el*-*-elf* | shl*-*-kaos*)
+  sh*-superh-elf* | shl*-*-elf* | sh[1234]l*-*-elf* | sh3el*-*-elf* | shl*-*-kaos*)
     targ_defvec=bfd_elf32_shl_vec
     targ_selvecs="bfd_elf32_sh_vec shlcoff_vec shcoff_vec shlcoff_small_vec shcoff_small_vec bfd_elf32_sh64_vec bfd_elf32_sh64l_vec bfd_elf64_sh64_vec bfd_elf64_sh64l_vec"
     targ_underscore=yes
@@ -1411,6 +1413,16 @@ case "${targ}" in
     want64=true
     ;;
 
+  lx-*-elf*)
+    targ_defvec=bfd_elf32_lx_vec
+    targ_selvecs=bfd_elf32_littlelx_vec
+    ;;  
+
+  lx-*-linux-gnu*)
+    targ_defvec=bfd_elf32_littlelx_linux_vec
+    targ_selvecs=bfd_elf32_lx_linux_vec
+    ;;
+
 #if HAVE_host_aout_vec
   tahoe-*-*)
     targ_defvec=host_aout_vec
diff --git a/bfd/config.in b/bfd/config.in
index 3864885..d86716a 100644
--- a/bfd/config.in
+++ b/bfd/config.in
@@ -105,6 +105,9 @@
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
+/* Define to 1 if you have the <libintl.h> header file. */
+#undef HAVE_LIBINTL_H
+
 /* Define if <sys/procfs.h> has lwpstatus_t. */
 #undef HAVE_LWPSTATUS_T
 
diff --git a/bfd/configure b/bfd/configure
index 882b320..ce80a52 100644
--- a/bfd/configure
+++ b/bfd/configure
@@ -19069,6 +19069,10 @@ do
     bfd_elf32_iq2000_vec)       tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
     bfd_elf32_little_generic_vec) tb="$tb elf32-gen.lo elf32.lo $elf" ;;
     bfd_elf32_littlearc_vec)	tb="$tb elf32-arc.lo elf32.lo $elf" ;;
+    bfd_elf32_lx_vec)           tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_littlelx_vec)     tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_lx_linux_vec)	tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_littlelx_linux_vec) tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
     bfd_elf32_littlearm_symbian_vec)
                                 tb="$tb elf32-arm.lo elf32.lo elf-vxworks.lo $elf" ;;
     bfd_elf32_littlearm_vxworks_vec)
diff --git a/bfd/configure.in b/bfd/configure.in
index 99ea584..fd2df53 100644
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -1,3 +1,4 @@
+dnl THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
 dnl Process this file with autoconf to produce a configure script.
 dnl
 
@@ -678,6 +679,10 @@ do
     bfd_elf32_iq2000_vec)       tb="$tb elf32-iq2000.lo elf32.lo $elf" ;;
     bfd_elf32_little_generic_vec) tb="$tb elf32-gen.lo elf32.lo $elf" ;;
     bfd_elf32_littlearc_vec)	tb="$tb elf32-arc.lo elf32.lo $elf" ;;
+    bfd_elf32_lx_vec)           tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;  
+    bfd_elf32_littlelx_vec)     tb="$tb elf32-lx.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_lx_linux_vec)	tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
+    bfd_elf32_littlelx_linux_vec) tb="$tb elf32-lx-linux.lo elf32.lo $elf $ipa" ;;
     bfd_elf32_littlearm_symbian_vec)
                                 tb="$tb elf32-arm.lo elf32.lo elf-vxworks.lo $elf" ;;
     bfd_elf32_littlearm_vxworks_vec)
diff --git a/bfd/cpu-lx.c b/bfd/cpu-lx.c
new file mode 100644
index 0000000..c9676d3
--- /dev/null
+++ b/bfd/cpu-lx.c
@@ -0,0 +1,43 @@
+/* BFD support for the HP Lisard architecture.
+   Copyright 1992 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "symcat.h"
+
+
+#define N(number, print, default, next)  \
+{  32, 32, 8, bfd_arch_lx, number, "lx/st200", print, 3, default, bfd_default_compatible, bfd_default_scan, next }
+
+
+#define ST231_NEXT  &arch_info_struct[0]
+#define ST240_NEXT  &arch_info_struct[1]
+
+static const bfd_arch_info_type arch_info_struct[] =
+{
+  N (bfd_mach_st231,      "st231",   FALSE, ST240_NEXT),
+  N (bfd_mach_st240,      "st240",   FALSE, NULL)
+};
+
+const bfd_arch_info_type bfd_lx_arch =
+      N (0, "st200", TRUE, ST231_NEXT);
+
+
+
diff --git a/bfd/cpu-sh.c b/bfd/cpu-sh.c
index af97a47..84d2264 100644
--- a/bfd/cpu-sh.c
+++ b/bfd/cpu-sh.c
@@ -2,6 +2,7 @@
    Copyright 1993, 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
    2007 Free Software Foundation, Inc.
    Hacked by Steve Chamberlain of Cygnus Support.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -45,6 +46,11 @@
 #define SH2A_NOFPU_OR_SH3_NOMMU_NEXT       arch_info_struct + 17
 #define SH2A_OR_SH4_NEXT                   arch_info_struct + 18
 #define SH2A_OR_SH3E_NEXT                  arch_info_struct + 19
+#define ST40_300_NOFPU_OR_SH2A_NOFPU_NEXT  arch_info_struct + 20
+#define ST40_300_NOFPU_OR_SH4A_NOFPU_NEXT  arch_info_struct + 21
+#define ST40_300_NOFPU_NEXT                arch_info_struct + 22
+#define ST40_300_OR_SH4A_NEXT              arch_info_struct + 23
+#define ST40_300_NEXT                      arch_info_struct + 24
 #define SH64_NEXT                          NULL
 
 static const bfd_arch_info_type arch_info_struct[] =
@@ -316,6 +322,76 @@ static const bfd_arch_info_type arch_info_struct[] =
     SH2A_OR_SH3E_NEXT
   },
   {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_nofpu_or_sh2a_nofpu,
+    "sh",			/* Architecture name.  */
+    "st40-300-nofpu-or-sh2a-nofpu",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NOFPU_OR_SH2A_NOFPU_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_nofpu_or_sh4a_nofpu,
+    "sh",			/* Architecture name.  */
+    "st40-300-nofpu-or-sh4a-nofpu",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NOFPU_OR_SH4A_NOFPU_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_nofpu,
+    "sh",			/* Architecture name.  */
+    "st40-300-nofpu",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NOFPU_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300_or_sh4a,
+    "sh",			/* Architecture name.  */
+    "st40-300-or-sh4a",		/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_OR_SH4A_NEXT
+  },
+  {
+    32,				/* 32 bits in a word.  */
+    32,				/* 32 bits in an address.  */
+    8,				/* 8 bits in a byte.  */
+    bfd_arch_sh,
+    bfd_mach_st40_300,
+    "sh",			/* Architecture name.  */
+    "st40-300",			/* Machine name.  */
+    1,
+    FALSE,			/* Not the default.  */
+    bfd_default_compatible,
+    bfd_default_scan,
+    ST40_300_NEXT
+  },
+  {
     64,				/* 64 bits in a word.  */
     64,				/* 64 bits in an address.  */
     8,				/* 8 bits in a byte.  */
@@ -378,6 +454,12 @@ static struct { unsigned long bfd_mach, arch, arch_up; } bfd_to_arch_table[] =
   { bfd_mach_sh4_nofpu,       arch_sh4_nofpu,       arch_sh4_nofpu_up },
   { bfd_mach_sh4_nommu_nofpu, arch_sh4_nommu_nofpu, arch_sh4_nommu_nofpu_up },
   { bfd_mach_sh4a_nofpu,      arch_sh4a_nofpu,      arch_sh4a_nofpu_up },
+
+  { bfd_mach_st40_300_nofpu_or_sh2a_nofpu,           arch_st40_300_nofpu_or_sh2a_nofpu,	  arch_st40_300_nofpu_or_sh2a_nofpu_up },
+  { bfd_mach_st40_300_nofpu_or_sh4a_nofpu,           arch_st40_300_nofpu_or_sh4a_nofpu,	  arch_st40_300_nofpu_or_sh4a_nofpu_up },
+  { bfd_mach_st40_300_nofpu,  arch_st40_300_nofpu,   arch_st40_300_nofpu_up },
+  { bfd_mach_st40_300_or_sh4a,arch_st40_300_or_sh4a, arch_st40_300_or_sh4a_up },
+  { bfd_mach_st40_300,        arch_st40_300,         arch_st40_300_up },
   { 0, 0, 0 }   /* Terminator.  */
 };
 
diff --git a/bfd/doc/archures.texi b/bfd/doc/archures.texi
index 3d11f11..48f5280 100644
--- a/bfd/doc/archures.texi
+++ b/bfd/doc/archures.texi
@@ -229,6 +229,11 @@ enum bfd_architecture
 #define bfd_mach_sh4        0x40
 #define bfd_mach_sh4_nofpu  0x41
 #define bfd_mach_sh4_nommu_nofpu  0x42
+#define bfd_mach_st40_300   0x430
+#define bfd_mach_st40_300_nofpu 0x431
+#define bfd_mach_st40_300_nofpu_or_sh2a_nofpu 0x432
+#define bfd_mach_st40_300_nofpu_or_sh4a_nofpu 0x433
+#define bfd_mach_st40_300_or_sh4a 0x434
 #define bfd_mach_sh4a       0x4a
 #define bfd_mach_sh4a_nofpu 0x4b
 #define bfd_mach_sh4al_dsp  0x4d
diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
index 444b9a7..6204c52 100644
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -167,6 +167,14 @@ struct elf_link_hash_entry
      FIXME: There is no real need for this field if def_dynamic is never
      cleared and all places that test def_dynamic also test def_regular.  */
   unsigned int dynamic_def : 1;
+#ifdef IPA_LINK
+  /* Symbol was marked as having their address taken.  */
+  unsigned int address_taken : 1;
+
+  /* The internal index ipa has for this symbol */
+  long ipa_indx;
+#endif
+
   /* Symbol is weak in all shared objects.  */
   unsigned int dynamic_weak : 1;
   /* Symbol is referenced with a relocation where C/C++ pointer equality
diff --git a/bfd/elf32-lx-linux.c b/bfd/elf32-lx-linux.c
new file mode 100644
index 0000000..5aff2db
--- /dev/null
+++ b/bfd/elf32-lx-linux.c
@@ -0,0 +1,31 @@
+/* LX specific support for 32-bit Linux
+   Copyright 2000 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define TARGET_LITTLE_SYM               bfd_elf32_littlelx_linux_vec
+#define TARGET_LITTLE_NAME              "elf32-littlelx-linux"
+#define TARGET_BIG_SYM                  bfd_elf32_lx_linux_vec
+#define TARGET_BIG_NAME                 "elf32-lx-linux"
+#define ELF_ARCH			bfd_arch_lx
+#define ELF_MACHINE_CODE		EM_LX
+#define ELF_MACHINE_ALT1		EM_LX_OLD
+#define ELF_MAXPAGESIZE			0x100000
+#define LINUX_ABI			1
+#define NO_COMPRESSION_SUPPORT          1
+
+#include "elf32-lx.c"
diff --git a/bfd/elf32-lx.c b/bfd/elf32-lx.c
new file mode 100644
index 0000000..a0be37e
--- /dev/null
+++ b/bfd/elf32-lx.c
@@ -0,0 +1,7591 @@
+/* Generic support for 32-bit ELF
+   Copyright 1993 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf32-lx.h"
+
+#define MAX_FWD_BRANCH_OFFSET (((1 << 22) - 1) << 2)
+#define MAX_BWD_BRANCH_OFFSET (-((1 << 22) << 2))
+#define NOP_BUNDLE ((bfd_vma)0x80000000)
+#define NOP_NOP_BUNDLE ((bfd_vma)0xb1000001)
+
+/* This does not include any relocations, but should be good enough
+   for GDB to read the file.  */
+
+typedef struct bfd_hash_entry *(*new_hash_entry_func)
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+
+/* In dynamically (linker-) created sections, we generally need to keep track
+   of the place a symbol or expression got allocated to. This is done via hash
+   tables that store entries of the following type.  */
+
+struct elf_lx_dyn_sym_info
+{
+  /* The addend for which this entry is relevant.  */
+  bfd_vma addend;
+
+  /* Next addend in the list.  */
+  struct elf_lx_dyn_sym_info *next;
+
+  bfd_vma got_offset;
+  bfd_vma fptr_offset;
+  bfd_vma pltoff_offset;
+  bfd_vma plt_offset;
+  bfd_vma plt2_offset;
+  bfd_vma tprel_offset;
+  bfd_vma dtpndx_offset;
+  bfd_vma dtpldm_offset;
+
+  /* The symbol table entry, if any, that this was derived from.  */
+  struct elf_link_hash_entry *h;
+
+  /* Used to count non-got, non-plt relocations for delayed sizing
+     of relocation sections.  */
+  struct elf_lx_dyn_reloc_entry
+  {
+    struct elf_lx_dyn_reloc_entry *next;
+
+    /* The section that is the target of the relocation. */
+    asection *sec;
+
+    /* The section that should contain the dynamic relocation. */
+    asection *srel;
+
+    /* The type of the dynamic relocation. */ 
+    int type;
+
+    /* Repeat count. */
+    int count;
+  } *reloc_entries;
+
+  /* True when the section contents have been updated.  */
+  unsigned got_done : 1;
+  unsigned fptr_done : 1;
+  unsigned pltoff_done : 1;
+  unsigned tprel_done : 1;
+  unsigned dtpldm_done : 1;
+  unsigned dtpndx_done : 1;
+
+  /* True for the different kinds of linker data we want created.  */
+  unsigned want_fptr : 1;
+  unsigned want_ltoff_fptr : 1;
+  unsigned want_plt : 1;
+  unsigned want_plt2 : 1;
+  unsigned want_pltoff : 1;
+
+  unsigned want_tprel;
+  unsigned want_dtpndx;
+  unsigned want_dtpldm;
+
+  /* Count of the number of references to the got entry for this.
+     Zero if there are none. */
+  long int want_got;
+};
+
+struct elf_lx_local_hash_entry
+{
+  struct bfd_hash_entry root;
+  struct elf_lx_dyn_sym_info *info;
+
+  /* True if this hash entry's addends was translated for
+     SHF_MERGE optimization.  */
+  unsigned sec_merge_done : 1;
+};
+
+struct elf_lx_local_hash_table
+{
+  struct bfd_hash_table root;
+  /* No additional fields for now.  */
+};
+
+struct elf_lx_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+  /* A pointer to the most recently used stub hash entry against this
+     symbol. */
+  struct elf_lx_stub_hash_entry *stub_cache;
+  struct elf_lx_dyn_sym_info *info;
+  /* Non-zero means allocate that many bytes of .dynbss. */
+  bfd_vma dynbss_size;
+  /* True when space has been allocated in dynbss section. */
+  bfd_boolean dynbss_allocated;
+  /* True when space has been allocated for relocation in .rel.dynbss section. */
+  bfd_boolean rel_dynbss_allocated;
+};
+
+struct elf_lx_link_hash_table
+{
+  /* The main hash table */
+  struct elf_link_hash_table root;
+
+  /* The stub hash table.  */
+  struct bfd_hash_table stub_hash_table;
+
+  /* Linker stub bfd.  */
+  bfd *stub_bfd;
+
+  /* Linker call-backs.  */
+  asection * (*add_stub_section) PARAMS ((const char *, asection *));
+  void (*layout_sections_again) PARAMS ((void));
+
+  /* Array to keep track of which stub sections have been created, and
+     information on stub grouping.  */
+  struct map_stub {
+    /* This is the section to which stubs in the group will be
+       attached.  */
+    asection *link_sec;
+    /* The stub section.  */
+    asection *stub_sec;
+  } *stub_group;
+
+  /* Number of stubs against global syms.  */
+  unsigned long stub_globals;
+
+  /* Count of stubs for non-global symbols created so far. */
+  unsigned long local_stub_count;
+
+  /* Assorted information used by elf_lx_size_stubs.  */
+  unsigned int bfd_count;
+  int top_index;
+  asection **input_list;
+
+  asection *got_sec;		/* the linkage table section (or NULL) */
+  asection *rel_got_sec;	/* dynamic relocation section for same */
+  asection *fptr_sec;		/* function descriptor table (or NULL) */
+  asection *plt_sec;		/* the primary plt section (or NULL) */
+  asection *pltoff_sec;		/* PIC ABI: private descriptors for plt (or NULL) */
+                                /* Embedded ABI: gotplt function pointers */
+  asection *rel_pltoff_sec;	/* dynamic relocation section for same */
+  asection *dynbss_sec;         /* dynbss section (or NULL) */
+  asection *rel_dynbss_sec;     /* dynamic relocation section for same */
+  bfd_size_type minplt_entries;	/* number of minplt entries */
+  unsigned reltext : 1;		/* are there relocs against readonly sections? */
+  unsigned self_dtpldm_done : 1;/* has self DTPLDM entry been finished? */
+  unsigned transform_to_absolute : 1; /* transform GP-relative insts to absolute? */
+  bfd_vma self_dtpldm_offset;   /* got offset to self DTPLDM entry */
+
+  bfd *got_bfd;                 /* The bfd that owns the .got section */
+
+  /* rel_hash information for the GOT static relocations. */
+  struct elf_link_hash_entry **got_rel_hash;
+
+  struct elf_lx_local_hash_table loc_hash_table;
+};
+
+/*
+ * Ordered table of sections that have a lma != vma.
+ * This table is created when section compression is performed 
+ * called by objcopy, using the secinit information.
+ * This table is used in a second pass of objcopy to compact the
+ * sections in the lma taking into account the space freed by
+ * the section compression. In this second pass, the sections lma 
+ * and sections size are updated in the ELF headers.
+ * initial_lma and compress_lma may be different if a previous section
+ * (in lma order) has been compressed.
+ * initial_size and compress_size may be the same for sections described
+ * in the secinit table for a COPY and not a COMPRESS action.
+ */
+struct elf_lx_cpt {
+    unsigned int secinit_index;	/* Index of corresponding entry in secinit table */
+    char *sec_name;		/* section name */
+    bfd_vma initial_lma;	/* section lma before compression */
+    bfd_vma compress_lma;	/* section lma after compression */
+    bfd_size_type initial_size;	/* section size before copmpression */
+    bfd_size_type compress_size;/* section size after copmpression */
+};
+struct elf_lx_cpt *elf_lx_cpt_tab_ = NULL;
+struct elf_lx_cpt **elf_lx_cpt_tab = NULL;
+/* Number of entries actually in the table */
+unsigned int elf_lx_cpt_tab_nb;
+#define DEBUG_COMPRESSION 1
+
+#define elf_lx_hash_table(p) \
+  ((struct elf_lx_link_hash_table *) ((p)->hash))
+
+#define lx_stub_hash_lookup(table, string, create, copy) \
+  ((struct elf_lx_stub_hash_entry *) \
+   bfd_hash_lookup ((table), (string), (create), (copy)))
+
+static bfd_boolean elf_lx_relocate_section (
+                 bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd, 
+                 asection *input_section, bfd_byte *contents, 
+                 Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms, 
+                 asection **local_sections);
+static bfd_boolean lx_elf_set_mach_from_flags PARAMS ((bfd *));
+static bfd_boolean lx_mach_has_st240_encodings PARAMS ((bfd *));
+static bfd_boolean lx_elf_set_flags_from_mach PARAMS ((bfd *));
+static bfd_boolean lx_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));
+static bfd_boolean lx_elf_print_private_bfd_data PARAMS ((bfd *, PTR));
+static bfd_boolean lx_elf_set_private_flags PARAMS ((bfd *, flagword));
+static bfd_boolean lx_elf_copy_private_flags PARAMS ((bfd *, bfd *));
+static bfd_boolean lx_elf_is_local_label_name PARAMS((bfd *, const char *));
+
+static reloc_howto_type *bfd_elf32_bfd_reloc_name_lookup
+  PARAMS ((bfd *abfd ATTRIBUTE_UNUSED, const char *r_name));
+static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
+  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
+static bfd_boolean abi_uses_reloc_p PARAMS ((bfd_boolean, unsigned int));
+static void lx_info_to_howto_rel PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
+static void lx_info_to_howto  PARAMS((bfd *, 
+				      arelent *, Elf_Internal_Rela *));
+static bfd_boolean pic_abi_p PARAMS((bfd *));
+static bfd_boolean reloc_matching_pair PARAMS((bfd *, Elf_Internal_Rela *,
+					   Elf_Internal_Rela *, bfd_byte *));
+static bfd_boolean elf32_lx_relax_got_load PARAMS((bfd *, struct bfd_link_info *,
+					       bfd_byte *, Elf_Internal_Rela *,
+					       unsigned int,
+					       struct elf_link_hash_entry *,
+					       Elf_Internal_Rela *,
+					       Elf_Internal_Rela *,
+					       bfd_boolean *, bfd_boolean *));
+static bfd_boolean elf_lx_relax_section PARAMS((bfd *, asection *,
+					    struct bfd_link_info *, bfd_boolean *));
+static bfd_boolean elf_lx_dynamic_symbol_p PARAMS((struct elf_link_hash_entry *,
+					       struct bfd_link_info *));
+static bfd_boolean main_program_weak_def_p PARAMS((struct elf_link_hash_entry *,
+					       struct bfd_link_info *));
+static bfd_boolean elf_lx_local_hash_table_init
+  PARAMS((struct elf_lx_local_hash_table *, bfd *, new_hash_entry_func));
+static struct bfd_hash_entry *elf_lx_new_loc_hash_entry
+  PARAMS((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static struct bfd_hash_entry *elf_lx_new_elf_hash_entry
+  PARAMS((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static struct bfd_hash_entry *stub_hash_newfunc
+  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
+static void transfer_relocs PARAMS((struct elf_lx_dyn_sym_info *,
+				    struct elf_lx_dyn_sym_info *));
+static void elf_lx_hash_copy_indirect (struct bfd_link_info *info,
+				       struct elf_link_hash_entry *,
+				       struct elf_link_hash_entry *);
+static void elf_lx_hash_hide_symbol PARAMS((struct bfd_link_info *,
+					    struct elf_link_hash_entry *,
+					    bfd_boolean));
+static struct bfd_link_hash_table *elf_lx_hash_table_create PARAMS((bfd *));
+static void elf_lx_hash_table_free
+  PARAMS ((struct bfd_link_hash_table *));
+static struct elf_lx_local_hash_entry *elf_lx_local_hash_lookup
+  PARAMS((struct elf_lx_local_hash_table *, const char *, bfd_boolean, bfd_boolean));
+static bfd_boolean elf_lx_global_dyn_sym_thunk
+  PARAMS((struct bfd_hash_entry *, PTR));
+static bfd_boolean elf_lx_local_dyn_sym_thunk PARAMS((struct bfd_hash_entry *,
+						  PTR));
+static void elf_lx_dyn_sym_traverse
+  PARAMS((struct elf_lx_link_hash_table *,
+	  bfd_boolean (*func) (struct elf_lx_dyn_sym_info *, PTR),
+	  PTR));
+static bfd_boolean elf_lx_create_dynamic_sections
+  PARAMS((bfd *, struct bfd_link_info *));
+static struct elf_lx_local_hash_entry *get_local_sym_hash
+  PARAMS((struct elf_lx_link_hash_table *, bfd *, const Elf_Internal_Rela *,
+	  bfd_boolean));
+static struct elf_lx_dyn_sym_info *get_dyn_sym_info
+  PARAMS((struct elf_lx_link_hash_table *, struct elf_link_hash_entry *,
+	  bfd *, const Elf_Internal_Rela *, bfd_boolean));
+static asection *get_got PARAMS((bfd *, struct bfd_link_info *,
+				 struct elf_lx_link_hash_table *));
+static asection *get_fptr PARAMS((bfd *, struct bfd_link_info *,
+				  struct elf_lx_link_hash_table *));
+static asection *get_pltoff PARAMS((bfd *, struct bfd_link_info *,
+				    struct elf_lx_link_hash_table *));
+static asection *get_reloc_section
+  PARAMS((bfd *, struct elf_lx_link_hash_table *, asection *, bfd_boolean));
+static bfd_boolean count_dyn_reloc
+  PARAMS((bfd *, struct elf_lx_dyn_sym_info *, asection *, asection *, int));
+static bfd_boolean elf_lx_check_relocs
+  PARAMS((bfd *, struct bfd_link_info *, asection *,
+	  const Elf_Internal_Rela *));
+static bfd_boolean allocate_global_data_got
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_global_fptr_got
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_local_got PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static long global_sym_index PARAMS((struct elf_link_hash_entry *));
+static bfd_boolean allocate_fptr PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_plt_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_plt2_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_pltoff_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean allocate_dynrel_entries
+  PARAMS((struct elf_lx_dyn_sym_info *, PTR));
+static bfd_boolean elf_lx_adjust_dynamic_symbol
+  PARAMS((struct bfd_link_info *, struct elf_link_hash_entry *));
+static void group_sections
+  PARAMS ((struct elf_lx_link_hash_table *, bfd_size_type, bfd_boolean));
+static enum elf_lx_stub_type lx_type_of_stub
+  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *,
+	   struct elf_lx_link_hash_entry *, bfd_vma));
+static char *lx_stub_name
+  PARAMS ((const asection *, const asection *,
+	   const struct elf_lx_link_hash_entry *,
+	   const Elf_Internal_Rela *));
+static struct elf_lx_stub_hash_entry *lx_get_stub_entry
+  PARAMS ((const asection *, const asection *,
+	   struct elf_link_hash_entry *,
+	   const Elf_Internal_Rela *,
+	   struct elf_lx_link_hash_table *));
+static struct elf_lx_stub_hash_entry *lx_add_stub
+  PARAMS ((const char *, asection *, struct elf_lx_link_hash_table *));
+static bfd_boolean lx_size_one_stub
+  PARAMS ((struct bfd_hash_entry *, PTR));
+static bfd_boolean lx_build_one_stub
+  PARAMS ((struct bfd_hash_entry *, PTR));
+static bfd_boolean elf_lx_size_dynamic_sections
+  PARAMS((bfd *, struct bfd_link_info *));
+static void elf_lx_install_dyn_reloc
+  PARAMS((bfd *, struct bfd_link_info *, asection *, asection *, bfd_vma,
+	  unsigned int, long, bfd_vma));
+static bfd_vma set_got_entry
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_lx_dyn_sym_info *,
+	  long, bfd_vma, bfd_vma, unsigned int));
+static bfd_vma set_fptr_entry
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_lx_dyn_sym_info *,
+	  bfd_vma));
+static bfd_vma set_pltoff_entry
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_lx_dyn_sym_info *,
+	  bfd_vma, bfd_boolean));
+static bfd_vma elf_lx_tprel_base
+  PARAMS ((struct bfd_link_info *info));
+static bfd_vma elf_lx_dtprel_base
+  PARAMS ((struct bfd_link_info *info));
+static bfd_boolean elf_lx_relocate_section
+  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
+static bfd_boolean elf_lx_output_arch_local_syms(
+  bfd *output_bfd,
+  struct bfd_link_info *info,
+  void *finfo, bfd_boolean (*func) (void *, const char *,
+				    Elf_Internal_Sym *,
+				    asection *,
+				    struct elf_link_hash_entry *));
+static bfd_boolean elf_lx_finish_dynamic_symbol
+  PARAMS((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
+	  Elf_Internal_Sym *));
+static bfd_boolean elf_lx_finish_dynamic_sections
+  PARAMS((bfd *, struct bfd_link_info *info));
+static bfd_boolean lx_elf_set_private_flags PARAMS((bfd *, flagword));
+static enum elf_reloc_type_class elf_lx_reloc_type_class
+  PARAMS((const Elf_Internal_Rela *rela));
+static void elf_lx_merge_symbol_attribute (struct elf_link_hash_entry *h,
+					   const Elf_Internal_Sym *isym,
+					   bfd_boolean definition,
+					   bfd_boolean dynamic);
+
+int elf_lx_get_compact_info (bfd *abfd, sec_ptr sec,
+			     bfd_vma *initial_lma, bfd_vma *compress_lma,
+			     bfd_size_type *initial_size, 
+			     bfd_size_type *compress_size);
+int elf_lx_sort_sections_by_lma (const void *arg1, const void *arg2);
+void elf_lx_dump_secinit_table(bfd *abfd, FILE *writer);
+static unsigned int elf_lx_action_discarded (asection *sec);
+
+static const char *lx_elf_print_symbol_all
+  PARAMS ((bfd *, PTR, asymbol *));
+/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
+extern enum bfd_architecture bfd_external_binary_architecture;
+
+/* Set in objcopy using -B option for binary files. */
+unsigned long bfd_external_binary_mach = 0;
+
+
+bfd_reloc_status_type _bfd_final_link_relocate (reloc_howto_type *howto,
+						bfd *input_bfd,
+						asection *input_section,
+						bfd_byte *contents,
+						bfd_vma address,
+						bfd_vma value,
+						bfd_vma addend);
+
+static reloc_howto_type elf32_lx_howto_table[] =
+{
+  HOWTO (R_LX_NONE,		/* type */
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Simple 16 bit relocation -- for data */
+
+  HOWTO (R_LX_16,		/* type */
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Simple 32 bit relocation -- for data */
+
+  HOWTO (R_LX_32,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_32",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /*  32 bit pcrel relocation -- for data */
+
+  HOWTO (R_LX_32_PCREL,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_32_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+  /* A PC Relative 24-bit relocation, shifted by 2  */
+  /* right container                                */
+
+  HOWTO (R_LX_23_PCREL, 	/* type */
+	 2,	                /* rightshift */
+	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
+	 23,	                /* bitsize */
+	 TRUE,	                /* pc_relative */
+	 0,	                /* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_23_PCREL",	/* name */
+	 FALSE,	                /* partial_inplace */
+	 0x0,		        /* src_mask */
+	 0x7fffff,   		/* dst_mask */
+	 TRUE), 		/* pcrel_offset */
+
+    /* A HI part of a 32 bit absolute relocation */
+
+  HOWTO (R_LX_HI23,		/* type */
+	 9,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_HI23",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a 32 immediate */
+
+  HOWTO (R_LX_LO9,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_LX_LO9",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a GP-relative reference */
+
+  HOWTO (R_LX_GPREL_HI23,       /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a GP-relative reference */
+
+  HOWTO (R_LX_GPREL_LO9,        /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relative to load address */
+
+  HOWTO (R_LX_REL32,            /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_REL32",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFF_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFF_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of an optimizable reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFFX_HI23,     /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFFX_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of an optimizable reference to a global offset table entry */
+
+  HOWTO (R_LX_GOTOFFX_LO9,      /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFFX_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation for data, resolves to link-time value */
+
+  HOWTO (R_LX_LTV32,            /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_LTV32",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit segment-relative relocation for data */
+
+  HOWTO (R_LX_SEGREL32,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_SEGREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation to obtain official function pointer */
+
+  HOWTO (R_LX_FPTR32,           /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_FPTR32",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a local function descriptor in the GOT */
+
+  HOWTO (R_LX_PLTOFF_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_PLTOFF_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a local function descriptor in the GOT */
+
+  HOWTO (R_LX_PLTOFF_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_PLTOFF_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a GOT entry that points to an official
+     function descriptor */
+
+  HOWTO (R_LX_GOTOFF_FPTR_HI23, /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_FPTR_HI23", /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a GOT entry that points to an official
+     function descriptor */
+
+  HOWTO (R_LX_GOTOFF_FPTR_LO9,  /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_FPTR_LO9", /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation to obtain official function pointer */
+
+  HOWTO (R_LX_IPLT,             /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_IPLT",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a GP-relative reference */
+
+  HOWTO (R_LX_NEG_GPREL_HI23,   /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_NEG_GPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a GP-relative reference */
+
+  HOWTO (R_LX_NEG_GPREL_LO9,    /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_NEG_GPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* copy initialized data to bss */
+
+  HOWTO (R_LX_COPY,             /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	        /* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_COPY",	        /* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit relocation to obtain function pointer */
+
+  HOWTO (R_LX_JMP_SLOT,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_JMP_SLOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a TP-relative reference */
+
+  HOWTO (R_LX_TPREL_HI23,       /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_TPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a TP-relative reference */
+
+  HOWTO (R_LX_TPREL_LO9,        /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_TPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit TP-relative reference */
+
+  HOWTO (R_LX_TPREL32,          /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_TPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry containing a TP-relative offset */
+
+  HOWTO (R_LX_GOTOFF_TPREL_HI23,/* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_TPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry containing a TP-relative offset */
+
+  HOWTO (R_LX_GOTOFF_TPREL_LO9, /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_TPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPLDM_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPLDM_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPLDM_LO9,/* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPLDM_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of offset from start of TLS block */
+
+  HOWTO (R_LX_DTPREL_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPREL_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of offset from start of TLS block */
+
+  HOWTO (R_LX_DTPREL_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPREL_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit TLS dynamic module ID */
+
+  HOWTO (R_LX_DTPMOD32,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPMOD32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* 32-bit offset from start of TLS block */
+
+  HOWTO (R_LX_DTPREL32,         /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,    	       	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_DTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* high part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPNDX_HI23,      /* type */
+	 9,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 23,    		/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPNDX_HI23",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x7fffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* low part of a reference to a global offset table entry containing a ti_index */
+
+  HOWTO (R_LX_GOTOFF_DTPNDX_LO9,       /* type */
+	 0,                     /* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 9,    	        	/* bitsize */
+	 FALSE,			/* pc_relative */
+	 12,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_LX_GOTOFF_DTPNDX_LO9",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0, 		        /* src_mask */
+	 0x1ff000,		/* dst_mask */
+	 FALSE)		        /* pcrel_offset */
+
+};
+
+struct lx_reloc_map
+{
+   bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned char elf_reloc_val;
+  bfd_boolean used_in_embedded_abi;
+  bfd_boolean used_in_pic_abi;
+};
+
+static const struct lx_reloc_map lx_reloc_map[] =
+{
+  { BFD_RELOC_NONE,                  R_LX_NONE,               TRUE,  TRUE  },
+  { BFD_RELOC_16,                    R_LX_16,                 TRUE,  TRUE  },
+  { BFD_RELOC_32,                    R_LX_32,                 TRUE,  TRUE  },
+  { BFD_RELOC_32_PCREL,              R_LX_32_PCREL,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_23_PCREL,           R_LX_23_PCREL,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_HI23,               R_LX_HI23,               TRUE,  FALSE },
+  { BFD_RELOC_LX_LO9,                R_LX_LO9,                TRUE,  FALSE },
+  { BFD_RELOC_LX_GPREL_HI23,         R_LX_GPREL_HI23,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_GPREL_LO9,          R_LX_GPREL_LO9,          TRUE,  TRUE  },
+  { BFD_RELOC_LX_REL32,              R_LX_REL32,              TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_HI23,        R_LX_GOTOFF_HI23,        TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_LO9,         R_LX_GOTOFF_LO9,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFFX_HI23,       R_LX_GOTOFFX_HI23,       TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFFX_LO9,        R_LX_GOTOFFX_LO9,        TRUE,  TRUE  },
+  { BFD_RELOC_LX_LTV32,              R_LX_LTV32,              TRUE,  TRUE  },
+  { BFD_RELOC_LX_SEGREL32,           R_LX_SEGREL32,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_FPTR32,             R_LX_FPTR32,             FALSE, TRUE  },
+  { BFD_RELOC_LX_PLTOFF_HI23,        R_LX_PLTOFF_HI23,        FALSE, TRUE  },
+  { BFD_RELOC_LX_PLTOFF_LO9,         R_LX_PLTOFF_LO9,         FALSE, TRUE  },
+  { BFD_RELOC_LX_GOTOFF_FPTR_HI23,   R_LX_GOTOFF_FPTR_HI23,   FALSE, TRUE  },
+  { BFD_RELOC_LX_GOTOFF_FPTR_LO9,    R_LX_GOTOFF_FPTR_LO9,    FALSE, TRUE  },
+  { BFD_RELOC_LX_IPLT,               R_LX_IPLT,               FALSE, TRUE  },
+  { BFD_RELOC_LX_NEG_GPREL_HI23,     R_LX_NEG_GPREL_HI23,     TRUE,  TRUE  },
+  { BFD_RELOC_LX_NEG_GPREL_LO9,      R_LX_NEG_GPREL_LO9,      TRUE,  TRUE  },
+  { BFD_RELOC_LX_COPY,               R_LX_COPY,               TRUE,  FALSE },
+  { BFD_RELOC_LX_JMP_SLOT,           R_LX_JMP_SLOT,           TRUE,  FALSE },
+  { BFD_RELOC_LX_TPREL_HI23,         R_LX_TPREL_HI23,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_TPREL_LO9,          R_LX_TPREL_LO9,          TRUE,  TRUE  },
+  { BFD_RELOC_LX_TPREL32,            R_LX_TPREL32,            TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_TPREL_HI23,  R_LX_GOTOFF_TPREL_HI23,  TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_TPREL_LO9,   R_LX_GOTOFF_TPREL_LO9,   TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPLDM_HI23, R_LX_GOTOFF_DTPLDM_HI23, TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPLDM_LO9,  R_LX_GOTOFF_DTPLDM_LO9,  TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPREL_HI23,        R_LX_DTPREL_HI23,        TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPREL_LO9,         R_LX_DTPREL_LO9,         TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPMOD32,           R_LX_DTPMOD32,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_DTPREL32,           R_LX_DTPREL32,           TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPNDX_HI23, R_LX_GOTOFF_DTPNDX_HI23, TRUE,  TRUE  },
+  { BFD_RELOC_LX_GOTOFF_DTPNDX_LO9,  R_LX_GOTOFF_DTPNDX_LO9,  TRUE,  TRUE  }
+};
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+				 const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < (sizeof (elf32_lx_howto_table)
+	    / sizeof (elf32_lx_howto_table[0]));
+       i++)
+    if (elf32_lx_howto_table[i].name != NULL
+	&& strcasecmp (elf32_lx_howto_table[i].name, r_name) == 0)
+      return &elf32_lx_howto_table[i];
+
+  return NULL;
+}
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup(abfd, code)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     bfd_reloc_code_real_type code;
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof(lx_reloc_map) / sizeof (struct lx_reloc_map); i++)
+    {
+      if (lx_reloc_map[i].bfd_reloc_val == code)
+	return &elf32_lx_howto_table[lx_reloc_map[i].elf_reloc_val];
+    }
+  return NULL;
+}
+
+static bfd_boolean
+abi_uses_reloc_p (pic_abi_p, r_type)
+     bfd_boolean pic_abi_p;
+     unsigned int r_type;
+{
+  unsigned int i;
+  for (i = 0; i < sizeof(lx_reloc_map) / sizeof (struct lx_reloc_map); i++)
+    {
+      if (lx_reloc_map[i].elf_reloc_val == r_type)
+	return pic_abi_p ? lx_reloc_map[i].used_in_pic_abi
+	  : lx_reloc_map[i].used_in_embedded_abi;
+    }
+  return FALSE;
+}
+
+/* Set the howto pointer for an LX ELF reloc. */
+
+static void lx_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED, 
+				  arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  unsigned r_type;
+  
+  r_type = ELF32_R_TYPE(dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_LX_max);
+  cache_ptr->howto = &elf32_lx_howto_table[r_type];
+}
+
+static void lx_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, 
+			      arelent *cache_ptr, Elf_Internal_Rela *dst)
+{
+  lx_info_to_howto_rel(abfd, cache_ptr, dst);
+
+  /* If we ever need to do any extra processing with dst->r_addend
+     (the field omitted in an Elf_Internal_Rel) we can do it here.  */
+}
+
+/* The name of the dynamic interpreter.  This is put in the .interp
+   section.  */
+
+#define ELF_DYNAMIC_INTERPRETER "/lib/ld-linux.so.2"
+
+#define L_RELOCATABLE 0
+
+#define INSN_IS_IMML_P(I)          (((I) & 0x7f800000) == 0x15000000)
+#define INSN_IS_IMMR_P(I)          (((I) & 0x7f800000) == 0x15800000)
+#define INSN_IS_ADDI_R16_P(I)      (((I) & 0x7fe00fc0) == 0x08000400)
+#define INSN_IS_CALL_P(I)          (((I) & 0x7f800000) == 0x30000000)
+#define INSN_IS_LDW_OR_LDWD_P(B,I) (lx_mach_has_st240_encodings (B) \
+                                    ? (((I) & 0x7fe00000) == 0x21000000) \
+                                    : (((I) & 0x7f600000) == 0x20000000))
+#define INSN_IS_BUNDLE_END_P(I)    (((I) & 0x80000000) == 0x80000000)
+#define LDW_TO_ADD(I)              (((I) & ~0x7fe00000) | 0x08000000)
+
+static struct elf_link_hash_entry *
+symbol_for_relax (bfd *abfd,
+		  unsigned long r_symndx)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry *h;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  if (r_symndx < symtab_hdr->sh_info)
+    h = NULL;
+  else
+    {
+      h = elf_sym_hashes (abfd)[r_symndx - symtab_hdr->sh_info];
+      BFD_ASSERT (h != NULL);
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *)h->root.u.i.link;
+    }
+  return h;
+}
+
+static bfd_boolean
+reloc_matching_pair (abfd, rel1, rel2, contents)
+     bfd *abfd;
+     Elf_Internal_Rela *rel1;
+     Elf_Internal_Rela *rel2;
+     bfd_byte *contents;
+{
+  unsigned int rel1_r_type = ELF32_R_TYPE (rel1->r_info);
+  unsigned int rel2_r_type = ELF32_R_TYPE (rel2->r_info);
+
+  /* Ensure high reloc. is in rel1 and low reloc is in rel2. */
+  if (rel1_r_type == R_LX_GPREL_LO9
+      || rel1_r_type == R_LX_GOTOFF_LO9
+      || rel1_r_type == R_LX_GOTOFFX_LO9
+      || rel1_r_type == R_LX_GOTOFF_TPREL_LO9
+      || rel1_r_type == R_LX_GOTOFF_DTPLDM_LO9
+      || rel1_r_type == R_LX_GOTOFF_DTPNDX_LO9)
+    {
+      unsigned int temp_r_type;
+      Elf_Internal_Rela *temp_reloc;
+
+      temp_r_type = rel1_r_type; rel1_r_type = rel2_r_type; rel2_r_type = temp_r_type;
+      temp_reloc = rel1; rel1 = rel2; rel2 = temp_reloc;
+    }
+  if (ELF32_R_SYM (rel1->r_info) == ELF32_R_SYM (rel2->r_info)
+      && rel1->r_addend == rel2->r_addend
+      && ((rel1_r_type == R_LX_GPREL_HI23 && rel2_r_type == R_LX_GPREL_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_HI23 && rel2_r_type == R_LX_GOTOFF_LO9)
+	  || (rel1_r_type == R_LX_GOTOFFX_HI23 && rel2_r_type == R_LX_GOTOFFX_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_TPREL_HI23
+	      && rel2_r_type == R_LX_GOTOFF_TPREL_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_DTPLDM_HI23
+	      && rel2_r_type == R_LX_GOTOFF_DTPLDM_LO9)
+	  || (rel1_r_type == R_LX_GOTOFF_DTPNDX_HI23
+	      && rel2_r_type == R_LX_GOTOFF_DTPNDX_LO9)))
+    {
+      bfd_vma insn = bfd_get_32 (abfd, contents + rel1->r_offset);
+
+      if (INSN_IS_IMML_P(insn)
+	  && rel1->r_offset == rel2->r_offset + 4)
+	return TRUE;
+      else if (INSN_IS_IMMR_P(insn)
+	       && rel1->r_offset + 4 == rel2->r_offset)
+	return TRUE;
+    }
+  return FALSE;
+}
+
+static bfd_boolean elf32_lx_relax_got_load (abfd, link_info, contents, irel, r_type, h,
+					irelocs, irelend,
+					changed_contents, changed_relocs)
+     bfd *abfd;
+     struct bfd_link_info *link_info;
+     bfd_byte *contents;
+     Elf_Internal_Rela *irel;
+     unsigned int r_type;
+     struct elf_link_hash_entry *h;
+     Elf_Internal_Rela *irelocs ATTRIBUTE_UNUSED;
+     Elf_Internal_Rela *irelend;
+     bfd_boolean *changed_contents;
+     bfd_boolean *changed_relocs;
+{
+  struct elf_lx_dyn_sym_info *dyn_i;
+  struct elf_lx_link_hash_table *lx_info;
+
+  if (! elf_lx_dynamic_symbol_p (h, link_info)
+      && irel < (irelend - 1)
+      && reloc_matching_pair (abfd, irel, irel + 1, contents))
+    {
+      Elf_Internal_Rela *low_rel;
+      Elf_Internal_Rela *high_rel;
+      bfd_vma insn;
+
+      if (r_type == R_LX_GOTOFF_LO9)
+	{
+	  low_rel = irel;
+	  high_rel = irel + 1;
+	}
+      else
+	{
+	  low_rel = irel + 1;
+	  high_rel = irel;
+	  r_type = ELF32_R_TYPE (low_rel->r_info);
+	}
+
+      insn = bfd_get_32 (abfd, contents + low_rel->r_offset);
+
+      if (r_type == R_LX_GOTOFF_LO9 && 
+	  INSN_IS_LDW_OR_LDWD_P(abfd, insn))
+	{ /* R_LX_GOTOFF_LO9 with an ldw or ldw.d,
+	     R_LX_GOTOFF_HI23 with imml or immr.
+	     Make the transformation. */
+	  /* Instruction is ldw or ldw.d, convert to add. */
+	  insn = LDW_TO_ADD (insn);
+	  bfd_put_32 (abfd, insn, contents + low_rel->r_offset);
+	  *changed_contents = TRUE;
+#if 0
+	  (*_bfd_error_handler)
+	    (_("%s: information: converting @gotoff to @gprel for %s"),
+	     bfd_get_filename (abfd),
+	     (h != NULL) ? h->root.root.string : "local symbol");
+#endif
+	  /* Change relocation to GPREL. */
+	  low_rel->r_info = ELF32_R_INFO (ELF32_R_SYM (low_rel->r_info), R_LX_GPREL_LO9);
+	  high_rel->r_info = ELF32_R_INFO (ELF32_R_SYM (high_rel->r_info),
+							R_LX_GPREL_HI23);
+	  *changed_relocs = TRUE;
+	  lx_info = elf_lx_hash_table (link_info);
+	  dyn_i = get_dyn_sym_info (lx_info, h, abfd, irel, FALSE);
+	  BFD_ASSERT (dyn_i != NULL);
+	  BFD_ASSERT (dyn_i->want_got > 1);
+
+	  dyn_i->want_got -= 2;
+	}
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_relax_section (abfd, sec, link_info, again)
+     bfd *abfd;
+     asection *sec;
+     struct bfd_link_info *link_info;
+     bfd_boolean *again;
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *internal_relocs;
+  Elf_Internal_Rela *irel, *irelend;
+  bfd_byte *contents;
+  struct elf_link_hash_entry *h;
+  bfd_boolean changed_contents = FALSE;
+  bfd_boolean changed_relocs = FALSE;
+
+  /* We are not currently changing any sizes, so only one pass.  */
+  *again = FALSE;
+
+  if (link_info->relocatable
+      || (sec->flags & SEC_RELOC) == 0
+      || sec->reloc_count == 0)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  internal_relocs = (_bfd_elf_link_read_relocs
+		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
+		      link_info->keep_memory));
+  if (internal_relocs == NULL)
+    return FALSE;
+  if (elf_section_data (sec)->this_hdr.contents != NULL)
+    contents = elf_section_data (sec)->this_hdr.contents;
+  else
+    {
+      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+	goto error_return;
+    }
+
+  irelend = internal_relocs + sec->reloc_count;
+  for (irel = internal_relocs; irel < irelend; irel++)
+    {
+      unsigned int  r_type = ELF32_R_TYPE (irel->r_info);
+      unsigned long r_symndx = ELF32_R_SYM (irel->r_info);
+
+      h = symbol_for_relax (abfd, r_symndx);
+
+      switch (r_type)
+	{
+	default:
+	  break;
+	case R_LX_GOTOFF_HI23:
+	case R_LX_GOTOFF_LO9:
+	  if (!elf32_lx_relax_got_load (abfd, link_info, contents, irel,
+					r_type, h, internal_relocs, irelend,
+					&changed_contents,
+					&changed_relocs))
+	    goto error_return;
+	  break;
+	}
+    }
+
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != contents)
+    {
+      if (!changed_contents && !link_info->keep_memory)
+	free (contents);
+      else
+	{
+	  /* Cache the section contents for elf_link_input_bfd. */
+	  elf_section_data (sec)->this_hdr.contents = contents;
+	}
+    }
+
+  if (elf_section_data (sec)->relocs != internal_relocs)
+    {
+      if (!changed_relocs)
+	free (internal_relocs);
+      else
+	elf_section_data (sec)->relocs = internal_relocs;
+    }
+
+  return TRUE;
+
+ error_return:
+  if (contents != NULL
+      && elf_section_data (sec)->this_hdr.contents != contents)
+    free (contents);
+  if (internal_relocs != NULL
+      && elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+  return FALSE;
+}
+
+/* The size in bytes of an entry in the procedure linkage table.  */
+
+#define PLT_HEADER_SIZE     32
+#define PLT_MIN_ENTRY_SIZE  16
+#define PLT_FULL_ENTRY_SIZE 32
+#define PLT_FULL_ENTRY_SIZE_PIC_ABI 40
+#define PLT_RESERVED_WORDS   3
+
+/* PLT templates for PIC ABI */
+
+static const bfd_vma pic_abi_plt_header_pre_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.8]    */ 0x20004FC8,
+    /* mov $r0.11=$r0.63   ;; */ 0x8000BFC0,
+    /* ldw $r0.10=0[$r0.8] ;; */ 0xA0000288,
+    /* ldw $r0.14=8[$r0.8] ;; */ 0xA0008388,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.11   ;; */ 0x8003F2C0,
+    /* nop                 ;; */ NOP_BUNDLE,
+  };
+
+static const bfd_vma pic_abi_plt_header_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.8]    */ 0x21004FC8,
+    /* mov $r0.11=$r0.63   ;; */ 0x8000BFC0,
+    /* ldw $r0.10=0[$r0.8] ;; */ 0xA1000288,
+    /* ldw $r0.14=8[$r0.8] ;; */ 0xA1008388,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.11   ;; */ 0x8003F2C0,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE,
+  };
+
+static const bfd_vma plt_min_entry[PLT_MIN_ENTRY_SIZE / 4] =
+  {
+    /* goto .PLT0             */ 0x31000000,
+    /* mov $r0.9=0 	      */ 0x08000240,
+    /* imml 0              ;; */ 0x95000000,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+static const bfd_vma pic_abi_plt_full_entry_pre_st240[PLT_FULL_ENTRY_SIZE_PIC_ABI / 4] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* ldw $r0.63=0[$r0.14]   */ 0x20000FCE,
+    /* mov $r0.9=$r0.63    ;; */ 0x80009FC0,
+    /* mov $r0.8=$r0.14    ;; */ 0x80008380,
+    /* immr 0                 */ 0x15800000,
+    /* ldw $r0.14=0[$r0.14];; */ 0xa000038E,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.9    ;; */ 0x8003F240,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+static const bfd_vma pic_abi_plt_full_entry_st240[PLT_FULL_ENTRY_SIZE_PIC_ABI / 4] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* ldw $r0.63=0[$r0.14]   */ 0x21000FCE,
+    /* mov $r0.9=$r0.63    ;; */ 0x80009FC0,
+    /* mov $r0.8=$r0.14    ;; */ 0x80008380,
+    /* immr 0                 */ 0x15800000,
+    /* ldw $r0.14=0[$r0.14];; */ 0xa100038E,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.9    ;; */ 0x8003F240,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+/* PLT templates for embedded ABI */
+
+static const bfd_vma embedded_abi_plt_header_pre_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.14]   */ 0x20004FCE,
+    /* mov $r0.11=$r0.63   ;; */ 0x8000BFC0,
+    /* ldw $r0.10=0[$r0.14];; */ 0xA000028E,
+    /* goto 1              ;; */ NOP_NOP_BUNDLE,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.11   ;; */ 0x8003F2C0,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+static const bfd_vma embedded_abi_plt_header_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* ldw $r0.63=4[$r0.14]   */ 0x21004FCE,
+    /* mov $r0.11=$r0.63   ;; */ 0x8000BFC0,
+    /* ldw $r0.10=0[$r0.14];; */ 0xA100028E,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.11   ;; */ 0x8003F2C0,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+static const bfd_vma embedded_abi_absolute_plt_header_pre_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* ldw $r0.63=0[$r0.0]    */ 0x20000FC0,
+    /* mov $r0.11=$r0.63   ;; */ 0x8000BFC0,
+    /* ldw $r0.10=0[$r0.0]    */ 0x20000280,
+    /* imml 0              ;; */ 0x95000000,
+    /* goto 1              ;; */ NOP_NOP_BUNDLE,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.11   ;; */ 0x8003F2C0,
+  };
+
+static const bfd_vma embedded_abi_absolute_plt_header_st240[PLT_HEADER_SIZE / 4] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* ldw $r0.63=0[$r0.0]    */ 0x21000FC0,
+    /* mov $r0.11=$r0.63   ;; */ 0x8000BFC0,
+    /* ldw $r0.10=0[$r0.0]    */ 0x21000280,
+    /* imml 0              ;; */ 0x95000000,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.11   ;; */ 0x8003F2C0,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+/* We use the same plt_min_entry for PIC ABI and embedded ABI,
+   PIC and absolute. */
+
+/* We use the same plt_full_entry template for embedded ABI PIC and
+   absolute, but adjust the base register in one instruction. */
+
+static const bfd_vma embedded_abi_plt_full_entry_pre_st240[PLT_FULL_ENTRY_SIZE / 4] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* Adjust the base register on the next instruction:
+       For PIC, use $r0.14, for absolute use $r0.0. */
+    /* ldw $r0.63=0[$r0.0]    */ 0x20000FC0,
+    /* mov $r0.9=$r0.63    ;; */ 0x80009FC0,
+    /* goto 1              ;; */ NOP_NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.9    ;; */ 0x8003F240,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+static const bfd_vma embedded_abi_plt_full_entry_st240[PLT_FULL_ENTRY_SIZE / 4] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* Adjust the base register on the next instruction:
+       For PIC, use $r0.14, for absolute use $r0.0. */
+    /* ldw $r0.63=0[$r0.0]    */ 0x21000FC0,
+    /* mov $r0.9=$r0.63    ;; */ 0x80009FC0,
+    /* goto $r0.63            */ 0x31800000,
+    /* mov $r0.63=$r0.9    ;; */ 0x8003F240,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE,
+    /* nop                 ;; */ NOP_BUNDLE
+  };
+
+static const bfd_vma abs_long_branch_stub[] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* movi $r63=0            */ 0x08000fc0,
+    /* mov $r9=$r63        ;; */ 0x80009fc0,
+    /* goto 1              ;; */ NOP_NOP_BUNDLE,
+    /* goto $r63              */ 0x31800000,
+    /* mov $r63=$r9        ;; */ 0x8003f240
+  };
+
+static const bfd_vma pic_long_branch_stub_pre_st240[] =
+  {
+    /* call $r63=8            */ 0x30000002,
+    /* mov $r9=$r63        ;; */ 0x80009fc0,
+    /* immr 0                 */ 0x15800000,
+    /* add $r63=$r63,0     ;; */ 0x88000fff,
+    /* goto 1              ;; */ NOP_NOP_BUNDLE,
+    /* goto $r63              */ 0x31800000,
+    /* mov $r63=$r9        ;; */ 0x8003f240
+  };
+
+static const bfd_vma pic_long_branch_stub_st240[] =
+  {
+    /* immr 0                 */ 0x15800000,
+    /* addpc $r9 = 0       ;; */ 0x89000240,
+    /* mov $r63 = $r9         */ 0x0003f240,
+    /* mov $r9 = $r63      ;; */ 0x80009fc0,
+    /* goto $r63              */ 0x31800000,
+    /* mov $r63 = $r9      ;; */ 0x8003f240
+  };
+
+/* Section name for stubs is the associated section name plus this
+   string.  */
+#define STUB_SUFFIX ".stub"
+
+enum elf_lx_stub_type {
+  lx_stub_none,
+  lx_stub_abs_long_branch,
+  lx_stub_pic_long_branch_pre_st240,
+  lx_stub_pic_long_branch_st240
+};
+
+struct elf_lx_stub_hash_entry {
+
+  /* Base hash table entry structure.  */
+  struct bfd_hash_entry root;
+
+  /* The stub section.  */
+  asection *stub_sec;
+
+  /* Offset within stub_sec of the beginning of this stub.  */
+  bfd_vma stub_offset;
+
+  /* Given the symbol's value and its section we can determine its final
+     value when building the stubs (so the stub knows where to jump).  */
+  bfd_vma target_value;
+  asection *target_section;
+
+  enum elf_lx_stub_type stub_type;
+
+  /* The symbol table entry, if any, that this was derived from.  */
+  struct elf_lx_link_hash_entry *h;
+
+  /* A symbol labelling the stub.  Only created if needed. */
+  struct elf_lx_link_hash_entry *sh;
+
+  /* Where this stub is being called from, or, in the case of combined
+     stub sections, the first input section in the group.  */
+  asection *id_sec;
+};
+
+/* Are we using the PIC ABI or the embedded ABI? */
+
+static bfd_boolean
+pic_abi_p (abfd)
+     bfd *abfd;
+{
+  flagword flags;
+
+  flags = lx_elf_get_private_flags (abfd);
+  return (flags & ELF_LX_ABI_MASK) == ELF_LX_ABI_PIC;
+}
+
+/* Should we do dynamic things to this symbol?  */
+
+static bfd_boolean
+elf_lx_dynamic_symbol_p (h, info)
+     struct elf_link_hash_entry *h;
+     struct bfd_link_info *info;
+{
+  if (h == NULL)
+    return FALSE;
+
+  while (h->root.type == bfd_link_hash_indirect
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  if (h->dynindx == -1)
+    return FALSE;
+  /* Visibility attributes not supported in old binutils version */
+  switch (ELF_ST_VISIBILITY (h->other))
+    {
+    case STV_INTERNAL:
+    case STV_HIDDEN:
+      return FALSE;
+    }
+  if (h->root.type == bfd_link_hash_undefweak
+      || h->root.type == bfd_link_hash_defweak)
+    return TRUE;
+
+  if ((info->unresolved_syms_in_objects == RM_IGNORE
+       && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
+      || (h->def_dynamic && h->ref_regular))
+    return TRUE;
+  return FALSE;
+}
+
+static bfd_boolean
+main_program_weak_def_p (h, info)
+     struct elf_link_hash_entry *h;
+     struct bfd_link_info *info;
+{
+  if (h != NULL
+      && ! info->shared)
+    {
+
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      if (h->root.type == bfd_link_hash_defweak
+	  && h->def_regular)
+	return TRUE;
+    }
+
+  return FALSE;
+}
+
+static bfd_boolean
+non_preemptible_def_p (struct elf_link_hash_entry *h,
+		       struct bfd_link_info *info)
+{
+  if (!h)
+    /* Local symbols are non-preemptible. */
+    return TRUE;
+  
+  while (h->root.type == bfd_link_hash_indirect
+	 || h->root.type == bfd_link_hash_warning)
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  /* Symbols with restricted visibility are non-preemptible. */
+  switch (ELF_ST_VISIBILITY (h->other))
+    {
+    case STV_INTERNAL:
+    case STV_HIDDEN:
+      return TRUE;
+    case STV_PROTECTED:
+     /* Unfortunately, STV_PROTECTED symbols defined in a shared
+	library can be prempted, but STV_PROTECTED symbols defined
+	in a main program cannot be preempted. */
+      return (h->def_regular
+	      ? TRUE
+	      : FALSE);
+    }
+
+  /* Symbol with a regular, non-weak definition in a main
+     program is non-preemptible. */
+  /* Care: common symbols can have neither ELF_LINK_HASH_DEF_REGULAR
+     or ELF_LINK_HASH_DEF_DYNAMIC.  Also, symbols can have both
+     ELF_LINK_HASH_DEF_REGULAR and ELF_LINK_HASH_DEF_DYNAMIC. */
+  if ((h->def_regular
+       || ! h->def_dynamic)
+      && ! main_program_weak_def_p (h, info))
+    return TRUE;
+
+  return FALSE;
+}
+
+
+static bfd_boolean
+elf_lx_local_hash_table_init (ht, abfd, new)
+     struct elf_lx_local_hash_table *ht;
+     bfd *abfd ATTRIBUTE_UNUSED;
+     new_hash_entry_func new;
+{
+  memset (ht, 0, sizeof (*ht));
+  return bfd_hash_table_init (&ht->root, new, sizeof(struct elf_lx_local_hash_entry));
+}
+
+static struct bfd_hash_entry*
+elf_lx_new_loc_hash_entry (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct elf_lx_local_hash_entry *ret;
+  ret = (struct elf_lx_local_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (!ret)
+    ret = bfd_hash_allocate (table, sizeof (*ret));
+
+  if (!ret)
+    return 0;
+
+  /* Initialize our local data.  All zeros, and definitely easier
+     than setting a handful of bit fields.  */
+  memset (ret, 0, sizeof (*ret));
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_lx_local_hash_entry *)
+	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+static struct bfd_hash_entry*
+elf_lx_new_elf_hash_entry (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  struct elf_lx_link_hash_entry *ret;
+  ret = (struct elf_lx_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (!ret)
+    ret = bfd_hash_allocate (table, sizeof (*ret));
+
+  if (!ret)
+    return 0;
+
+  /* Initialize our local data.  All zeros, and definitely easier
+     than setting a handful of bit fields.  */
+  memset (ret, 0, sizeof (*ret));
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_lx_link_hash_entry *)
+	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+				     table, string));
+  if (ret != NULL)
+    ret->stub_cache = NULL;
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Initialize an entry in the stub hash table.  */
+
+static struct bfd_hash_entry *
+stub_hash_newfunc (entry, table, string)
+     struct bfd_hash_entry *entry;
+     struct bfd_hash_table *table;
+     const char *string;
+{
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (entry == NULL)
+    {
+      entry = bfd_hash_allocate (table,
+				 sizeof (struct elf_lx_stub_hash_entry));
+      if (entry == NULL)
+	return entry;
+    }
+
+  /* Call the allocation method of the superclass.  */
+  entry = bfd_hash_newfunc (entry, table, string);
+  if (entry != NULL)
+    {
+      struct elf_lx_stub_hash_entry *eh;
+
+      /* Initialize the local fields.  */
+      eh = (struct elf_lx_stub_hash_entry *) entry;
+      eh->stub_sec = NULL;
+      eh->stub_offset = 0;
+      eh->target_value = 0;
+      eh->target_section = NULL;
+      eh->stub_type = lx_stub_none;
+      eh->h = NULL;
+      eh->id_sec = NULL;
+    }
+
+  return entry;
+}
+
+static void
+transfer_relocs (dst, src)
+     struct elf_lx_dyn_sym_info *dst;
+     struct elf_lx_dyn_sym_info *src;
+{
+  struct elf_lx_dyn_reloc_entry **pp;
+  struct elf_lx_dyn_reloc_entry *p;
+
+  /* Note the strange way the relocs are transferred:
+     for items that are on both src and dst lists,
+     we update the count on the dst list and remove the item
+     from the src list.
+     for items that are only on the src list, leave them there.
+     After walking the whole src list, append the whole dst
+     list to the src list, then move the src list to the dst.
+  */
+  for (pp = &src->reloc_entries; (p = *pp) != NULL; )
+    {
+      struct elf_lx_dyn_reloc_entry *q;
+
+      for (q = dst->reloc_entries; q != NULL; q = q->next)
+	{
+	  if (p->sec == q->sec
+	      && p->srel == q->srel
+	      && p->type == q->type)
+	    {
+	      q->count += p->count;
+	      /* Remove this item from src list. */
+	      *pp = p->next;
+	      break;
+	    }
+	}
+      if (q == NULL)
+	pp = &p->next;
+    }
+  *pp = dst->reloc_entries;
+  dst->reloc_entries = src->reloc_entries;
+  src->reloc_entries = NULL;
+}
+
+static void
+elf_lx_hash_copy_indirect (struct bfd_link_info *info,
+			   struct elf_link_hash_entry *xdir,
+			   struct elf_link_hash_entry *xind)
+{
+  struct elf_lx_link_hash_entry *dir, *ind;
+
+  dir = (struct elf_lx_link_hash_entry *) xdir;
+  ind = (struct elf_lx_link_hash_entry *) xind;
+
+#if 0
+  printf ("copy_indirect (%s) %s (%p) => %s (%p)\n",
+	  (xind->root.type == bfd_link_hash_indirect
+	   ? "indirect"
+	   : "weak to strong"),
+	  xind->root.root.string, xind,
+	  xdir->root.root.string, xdir);
+#endif
+
+  if (ind->root.root.type == bfd_link_hash_indirect)
+    {
+      struct elf_lx_dyn_sym_info *dyn_i;
+
+      if (dir->info == NULL)
+	{
+	  dir->info = ind->info;
+	  ind->info = NULL;
+	  /* Fix up the dyn_sym_info pointers to the global symbol.  */
+	  for (dyn_i = dir->info; dyn_i; dyn_i = dyn_i->next)
+	    dyn_i->h = &dir->root;
+	}
+      BFD_ASSERT (ind->info == NULL);
+      dir->dynbss_size = ind->dynbss_size;
+      ind->dynbss_size = 0;
+      dir->dynbss_allocated = ind->dynbss_allocated;
+      ind->dynbss_allocated = FALSE;
+      dir->rel_dynbss_allocated = ind->rel_dynbss_allocated;
+      ind->rel_dynbss_allocated = FALSE;
+    }
+  else
+    {
+      /* We are copying a weak definition to a strong
+	 definition.  Transfer the relocs over, but otherwise
+	 leave the info lists intact.
+      */
+      if (ind->info != NULL)
+	{
+	  struct elf_lx_dyn_sym_info *p;
+	  struct elf_lx_dyn_sym_info *q;
+	  struct elf_lx_dyn_sym_info *prevq;
+
+	  /* Transfer the ind relocs to the dir list. */
+	  if (dir->info != NULL
+	      && xind->root.type == bfd_link_hash_indirect)
+	    abort ();
+
+	  for (p = ind->info; p != NULL; p = p->next)
+	    {
+	      for (prevq = NULL, q = dir->info;
+		   q != NULL;
+		   prevq = q, q = q->next)
+		if (q->addend == p->addend)
+		  break;
+	      if (q == NULL)
+		{
+		  /* This addend not found on the direct list.
+		     Create it, and append it to the direct list.
+		  */
+
+		  /* Memory leak: I would like to use bfd_zalloc here,
+		     but I do not have a bfd available. */
+		  q = (struct elf_lx_dyn_sym_info *)
+		    bfd_malloc ((bfd_size_type) sizeof *q);
+		  memset (q, 0, (bfd_size_type) sizeof *q);
+		  q->h = &dir->root;
+		  q->reloc_entries = NULL;
+		  q->next = NULL;
+		  if (prevq == NULL)
+		    dir->info = q;
+		  else
+		    prevq->next = q;
+		}
+	      transfer_relocs (q, p);
+	    }
+	}
+    }
+
+#if 0
+  {
+    struct elf_lx_dyn_sym_info *p;
+    printf ("  info list: ");
+    for (p = dir->info; p; p = p->next)
+      printf ("{ %p, %ld } ", p->h, (long)p->addend);
+    printf ("\n");
+  }
+#endif
+  _bfd_elf_link_hash_copy_indirect (info, xdir, xind);
+
+}
+
+static void
+elf_lx_hash_hide_symbol (info, xh, force_local)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *xh;
+     bfd_boolean force_local;
+{
+  struct elf_lx_link_hash_entry *h;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  h = (struct elf_lx_link_hash_entry *)xh;
+
+  _bfd_elf_link_hash_hide_symbol (info, &h->root, force_local);
+
+  for (dyn_i = h->info; dyn_i; dyn_i = dyn_i->next)
+    dyn_i->want_plt2 = 0;
+}
+
+/* Create the derived linker hash table.  The lx ELF port uses this
+   derived hash table to keep information specific to the lx ElF
+   linker (without using static variables).  */
+
+static struct bfd_link_hash_table*
+elf_lx_hash_table_create (abfd)
+     bfd *abfd;
+{
+  struct elf_lx_link_hash_table *ret;
+
+  ret = bfd_zalloc (abfd, (bfd_size_type) sizeof (*ret));
+  if (!ret)
+    return 0;
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      elf_lx_new_elf_hash_entry,
+				      sizeof (struct elf_lx_link_hash_entry)))
+    {
+      bfd_release (abfd, ret);
+      return 0;
+    }
+
+  if (!elf_lx_local_hash_table_init (&ret->loc_hash_table, abfd,
+				     elf_lx_new_loc_hash_entry))
+    return 0;
+
+  if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc,
+			    sizeof (struct elf_lx_stub_hash_entry)))
+    return 0;
+
+  return &ret->root.root;
+}
+
+/* Free the derived linker hash table.  */
+
+static void
+elf_lx_hash_table_free (hash)
+     struct bfd_link_hash_table *hash;
+{
+  struct elf_lx_link_hash_table *ret
+    = (struct elf_lx_link_hash_table *) hash;
+
+  bfd_hash_table_free (&ret->stub_hash_table);
+  _bfd_generic_link_hash_table_free (hash);
+}
+
+/* Look up an entry in an lx ELF linker hash table.  */
+
+static INLINE struct elf_lx_local_hash_entry *
+elf_lx_local_hash_lookup(table, string, create, copy)
+     struct elf_lx_local_hash_table *table;
+     const char *string;
+     bfd_boolean create, copy;
+{
+  return ((struct elf_lx_local_hash_entry *)
+	  bfd_hash_lookup (&table->root, string, create, copy));
+}
+
+/* Traverse both local and global hash tables.  */
+
+struct elf_lx_dyn_sym_traverse_data
+{
+  bfd_boolean (*func) PARAMS ((struct elf_lx_dyn_sym_info *, PTR));
+  PTR data;
+};
+
+static bfd_boolean
+elf_lx_global_dyn_sym_thunk (xentry, xdata)
+     struct bfd_hash_entry *xentry;
+     PTR xdata;
+{
+  struct elf_lx_link_hash_entry *entry
+    = (struct elf_lx_link_hash_entry *) xentry;
+  struct elf_lx_dyn_sym_traverse_data *data
+    = (struct elf_lx_dyn_sym_traverse_data *) xdata;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  if (entry->root.root.type == bfd_link_hash_warning)
+    entry = (struct elf_lx_link_hash_entry *) entry->root.root.u.i.link;
+
+  for (dyn_i = entry->info; dyn_i; dyn_i = dyn_i->next)
+    if (! (*data->func) (dyn_i, data->data))
+      return FALSE;
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_local_dyn_sym_thunk (xentry, xdata)
+     struct bfd_hash_entry *xentry;
+     PTR xdata;
+{
+  struct elf_lx_local_hash_entry *entry
+    = (struct elf_lx_local_hash_entry *) xentry;
+  struct elf_lx_dyn_sym_traverse_data *data
+    = (struct elf_lx_dyn_sym_traverse_data *) xdata;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  for (dyn_i = entry->info; dyn_i; dyn_i = dyn_i->next)
+    if (! (*data->func) (dyn_i, data->data))
+      return FALSE;
+  return TRUE;
+}
+
+static void
+elf_lx_dyn_sym_traverse (lx_info, func, data)
+     struct elf_lx_link_hash_table *lx_info;
+     bfd_boolean (*func) PARAMS ((struct elf_lx_dyn_sym_info *, PTR));
+     PTR data;
+{
+  struct elf_lx_dyn_sym_traverse_data xdata;
+
+  xdata.func = func;
+  xdata.data = data;
+
+  elf_link_hash_traverse (&lx_info->root,
+			  elf_lx_global_dyn_sym_thunk, &xdata);
+  bfd_hash_traverse (&lx_info->loc_hash_table.root,
+		     elf_lx_local_dyn_sym_thunk, &xdata);
+}
+
+
+static bfd_boolean
+elf_lx_create_dynamic_sections (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *s;
+
+  if (! _bfd_elf_create_dynamic_sections (abfd, info))
+    return FALSE;
+
+  lx_info = elf_lx_hash_table (info);
+
+  lx_info->plt_sec = bfd_get_section_by_name (abfd, ".plt");
+  if (lx_info->got_sec == NULL)
+    {
+      lx_info->got_sec = bfd_get_section_by_name (abfd, ".got");
+      lx_info->got_bfd = abfd;
+    }
+
+  if (!get_pltoff (abfd, info, lx_info))
+    return FALSE;
+
+  if (pic_abi_p (abfd))
+    {
+      s = bfd_make_section(abfd, ".rela.lx.pltoff");
+      if (s == NULL
+	  || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
+					       | SEC_HAS_CONTENTS
+					       | SEC_IN_MEMORY
+					       | SEC_LINKER_CREATED
+					       | SEC_READONLY))
+	  || !bfd_set_section_alignment (abfd, s, 2))
+	return FALSE;
+      lx_info->rel_pltoff_sec = s;
+    }
+  else
+    lx_info->rel_pltoff_sec = bfd_get_section_by_name (abfd, ".rela.plt");
+
+  s = bfd_make_section(abfd, ".rela.got");
+  if (s == NULL
+      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
+					   | SEC_HAS_CONTENTS
+					   | SEC_IN_MEMORY
+					   | SEC_LINKER_CREATED
+					   | SEC_READONLY))
+      || !bfd_set_section_alignment (abfd, s, 2))
+    return FALSE;
+  lx_info->rel_got_sec = s;
+  lx_info->dynbss_sec = bfd_get_section_by_name (abfd, ".dynbss");
+  lx_info->rel_dynbss_sec = bfd_get_section_by_name (abfd, ".rela.bss");
+  return TRUE;
+}
+
+/* Find and/or create a hash entry for local symbol.  */
+static struct elf_lx_local_hash_entry *
+get_local_sym_hash (lx_info, abfd, rel, create)
+     struct elf_lx_link_hash_table *lx_info;
+     bfd *abfd;
+     const Elf_Internal_Rela *rel;
+     bfd_boolean create;
+{
+  char *addr_name;
+  size_t len;
+  struct elf_lx_local_hash_entry *ret;
+
+  /* Construct a string for use in the elf_lx_local_hash_table.
+     name describes what was once anonymous memory.  */
+
+  len = sizeof (void*)*2 + 1 + sizeof (bfd_vma)*4 + 1 + 1;
+  len += 10;	/* %p slop */
+
+  addr_name = bfd_malloc (len);
+  if (addr_name == NULL)
+    return 0;
+  sprintf (addr_name, "%p:%lx",
+	   (void *) abfd, (unsigned long) ELF32_R_SYM (rel->r_info));
+
+  /* Collect the canonical entry data for this address.  */
+  ret = elf_lx_local_hash_lookup (&lx_info->loc_hash_table,
+				  addr_name, create, create);
+  free (addr_name);
+  return ret;
+}
+
+/* Find and/or create a descriptor for dynamic symbol info.  This will
+   vary based on global or local symbol, and the addend to the reloc.  */
+
+static struct elf_lx_dyn_sym_info *
+get_dyn_sym_info (lx_info, h, abfd, rel, create)
+     struct elf_lx_link_hash_table *lx_info;
+     struct elf_link_hash_entry *h;
+     bfd *abfd;
+     const Elf_Internal_Rela *rel;
+     bfd_boolean create;
+{
+  struct elf_lx_dyn_sym_info **pp;
+  struct elf_lx_dyn_sym_info *dyn_i;
+  bfd_vma addend = rel ? rel->r_addend : 0;
+
+  if (h)
+    pp = &((struct elf_lx_link_hash_entry *)h)->info;
+  else
+    {
+      struct elf_lx_local_hash_entry *loc_h;
+
+      loc_h = get_local_sym_hash (lx_info, abfd, rel, create);
+      BFD_ASSERT (loc_h);
+
+      pp = &loc_h->info;
+    }
+
+#if 0
+  printf ("get_dyn_sym_info: h = %p addend = %ld\n",
+	  h,
+	  (long)addend);
+#endif
+
+  for (dyn_i = *pp; dyn_i && dyn_i->addend != addend; dyn_i = *pp)
+    pp = &dyn_i->next;
+
+  if (dyn_i == NULL && create)
+    {
+      dyn_i = ((struct elf_lx_dyn_sym_info *)
+	       bfd_zalloc (abfd, (bfd_size_type) sizeof *dyn_i));
+      *pp = dyn_i;
+      dyn_i->addend = addend;
+    }
+
+  return dyn_i;
+}
+
+static asection *
+get_got (abfd, info, lx_info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_link_hash_table *lx_info;
+{
+  asection *got;
+  bfd *dynobj;
+
+  got = lx_info->got_sec;
+  if (!got)
+    {
+      dynobj = lx_info->root.dynobj;
+      if (!dynobj)
+	lx_info->root.dynobj = dynobj = abfd;
+      if (!_bfd_elf_create_got_section (dynobj, info))
+	return 0;
+
+      got = bfd_get_section_by_name (dynobj, ".got");
+      BFD_ASSERT (got);
+      lx_info->got_sec = got;
+      lx_info->got_bfd = abfd;
+    }
+
+  return got;
+}
+
+/* Create function descriptor section (.opd).  This section is called .opd
+   because it contains "official procedure descriptors".  The "official"
+   refers to the fact that these descriptors are used when taking the address
+   of a procedure, thus ensuring a unique address for each procedure.  */
+
+static asection *
+get_fptr (abfd, info, lx_info)
+     bfd *abfd;
+     struct bfd_link_info *info ATTRIBUTE_UNUSED;
+     struct elf_lx_link_hash_table *lx_info;
+{
+  asection *fptr;
+  bfd *dynobj;
+
+  fptr = lx_info->fptr_sec;
+  if (!fptr)
+    {
+      dynobj = lx_info->root.dynobj;
+      if (!dynobj)
+	lx_info->root.dynobj = dynobj = abfd;
+
+      fptr = bfd_make_section (dynobj, ".opd");
+      if (!fptr
+	  || !bfd_set_section_flags (dynobj, fptr,
+				     (SEC_ALLOC
+				      | SEC_LOAD
+				      | SEC_HAS_CONTENTS
+				      | SEC_IN_MEMORY
+				      | SEC_READONLY
+				      | SEC_LINKER_CREATED))
+	  || !bfd_set_section_alignment (abfd, fptr, 3))
+	{
+	  BFD_ASSERT (0);
+	  return NULL;
+	}
+
+      lx_info->fptr_sec = fptr;
+    }
+
+  return fptr;
+}
+
+static asection *
+get_pltoff (abfd, info, lx_info)
+     bfd *abfd;
+     struct bfd_link_info *info ATTRIBUTE_UNUSED;
+     struct elf_lx_link_hash_table *lx_info;
+{
+  asection *pltoff;
+  bfd *dynobj;
+
+  pltoff = lx_info->pltoff_sec;
+  if (!pltoff)	
+    {
+      if (pic_abi_p (abfd))
+	{
+	  dynobj = lx_info->root.dynobj;
+	  if (!dynobj)
+	    lx_info->root.dynobj = dynobj = abfd;
+	  
+	  pltoff = bfd_make_section (dynobj, ELF_STRING_lx_pltoff);
+	  if (!pltoff
+	      || !bfd_set_section_flags (dynobj, pltoff,
+					 (SEC_ALLOC
+					  | SEC_LOAD
+					  | SEC_HAS_CONTENTS
+					  | SEC_IN_MEMORY
+					  | SEC_LINKER_CREATED))
+	      || !bfd_set_section_alignment (abfd, pltoff, 3))
+	    {
+	      BFD_ASSERT (0);
+	      return NULL;
+	    }
+
+	}
+      else
+	pltoff = bfd_get_section_by_name (abfd, ".got.plt");
+      lx_info->pltoff_sec = pltoff;
+    }
+
+  return pltoff;
+}
+
+static asection *
+get_reloc_section (abfd, lx_info, sec, create)
+     bfd *abfd;
+     struct elf_lx_link_hash_table *lx_info;
+     asection *sec;
+     bfd_boolean create;
+{
+  const char *srel_name;
+  asection *srel;
+  bfd *dynobj;
+
+  srel_name = (bfd_elf_string_from_elf_section
+	       (abfd, elf_elfheader(abfd)->e_shstrndx,
+		elf_section_data(sec)->rel_hdr.sh_name));
+  if (srel_name == NULL)
+    return NULL;
+
+  BFD_ASSERT ((strncmp (srel_name, ".rela", 5) == 0
+	       && strcmp (bfd_get_section_name (abfd, sec),
+			  srel_name+5) == 0)
+	      || (strncmp (srel_name, ".rel", 4) == 0
+		  && strcmp (bfd_get_section_name (abfd, sec),
+			     srel_name+4) == 0));
+
+  dynobj = lx_info->root.dynobj;
+  if (!dynobj)
+    lx_info->root.dynobj = dynobj = abfd;
+
+  srel = bfd_get_section_by_name (dynobj, srel_name);
+  if (srel == NULL && create)
+    {
+      srel = bfd_make_section (dynobj, srel_name);
+      if (srel == NULL
+	  || !bfd_set_section_flags (dynobj, srel,
+				     (SEC_ALLOC
+				      | SEC_LOAD
+				      | SEC_HAS_CONTENTS
+				      | SEC_IN_MEMORY
+				      | SEC_LINKER_CREATED
+				      | SEC_READONLY))
+	  || !bfd_set_section_alignment (dynobj, srel, 2))
+	return NULL;
+    }
+
+  return srel;
+}
+
+static bfd_boolean
+count_dyn_reloc (abfd, dyn_i, sec, srel, type)
+     bfd *abfd;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     asection *sec;
+     asection *srel;
+     int type;
+{
+  struct elf_lx_dyn_reloc_entry *rent;
+
+  for (rent = dyn_i->reloc_entries; rent; rent = rent->next)
+    if (rent->srel == srel && rent->type == type && rent->sec == sec)
+      break;
+
+  if (!rent)
+    {
+      rent = ((struct elf_lx_dyn_reloc_entry *)
+	      bfd_alloc (abfd, (bfd_size_type) sizeof (*rent)));
+      if (!rent)
+	return FALSE;
+
+      rent->next = dyn_i->reloc_entries;
+      rent->sec = sec;
+      rent->srel = srel;
+      rent->type = type;
+      rent->count = 0;
+      dyn_i->reloc_entries = rent;
+    }
+  rent->count++;
+
+  return TRUE;
+}
+
+/* Determine the type of stub needed, if any, for a call.  */
+
+static enum elf_lx_stub_type
+lx_type_of_stub (abfd, info, input_sec, rel, hash, destination)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *input_sec;
+     const Elf_Internal_Rela *rel;
+     struct elf_lx_link_hash_entry *hash ATTRIBUTE_UNUSED;
+     bfd_vma destination;
+{
+  bfd_vma location;
+  bfd_signed_vma branch_offset;
+
+  /* Determine where the call point is.  */
+  location = (input_sec->output_offset
+	      + input_sec->output_section->vma
+	      + rel->r_offset);
+
+  branch_offset = (bfd_signed_vma)(destination - location);
+  if (branch_offset > MAX_FWD_BRANCH_OFFSET
+      || (branch_offset < MAX_BWD_BRANCH_OFFSET))
+    return (info->shared)
+      ? (lx_mach_has_st240_encodings (abfd)
+	 ? lx_stub_pic_long_branch_st240
+	 : lx_stub_pic_long_branch_pre_st240)
+      : lx_stub_abs_long_branch;
+
+  return lx_stub_none;
+}
+
+/* Build a name for an entry in the stub hash table.  */
+
+static char *
+lx_stub_name (input_section, sym_sec, hash, rel)
+     const asection *input_section;
+     const asection *sym_sec;
+     const struct elf_lx_link_hash_entry *hash;
+     const Elf_Internal_Rela *rel;
+{
+  char *stub_name;
+  bfd_size_type len;
+
+  if (hash)
+    {
+      len = 8 + 1 + strlen (hash->root.root.root.string) + 1 + 8 + 1;
+      stub_name = bfd_malloc (len);
+      if (stub_name != NULL)
+	{
+	  sprintf (stub_name, "%08x_%s+%x",
+		   input_section->id & 0xffffffff,
+		   hash->root.root.root.string,
+		   (int) rel->r_addend & 0xffffffff);
+	}
+    }
+  else
+    {
+      len = 8 + 1 + 8 + 1 + 8 + 1 + 8 + 1;
+      stub_name = bfd_malloc (len);
+      if (stub_name != NULL)
+	{
+	  sprintf (stub_name, "%08x_%x:%x+%x",
+		   input_section->id & 0xffffffff,
+		   sym_sec->id & 0xffffffff,
+		   (int) ELF32_R_SYM (rel->r_info) & 0xffffffff,
+		   (int) rel->r_addend & 0xffffffff);
+	}
+    }
+  return stub_name;
+}
+
+void
+lx_elf_init_stub_bfd (abfd, info)
+     bfd *abfd;
+     struct bfd_link_info *info;
+{
+  struct elf_lx_link_hash_table *htab;
+
+  elf_elfheader (abfd)->e_ident[EI_CLASS] = ELFCLASS32;
+
+  htab = elf_lx_hash_table (info);
+  htab->stub_bfd = abfd;
+}
+
+/* Look up an entry in the stub hash.  Stub entries are cached because
+   creating the stub name takes a bit of time.  */
+
+static struct elf_lx_stub_hash_entry *
+lx_get_stub_entry (input_section, sym_sec, hash, rel, htab)
+     const asection *input_section;
+     const asection *sym_sec;
+     struct elf_link_hash_entry *hash;
+     const Elf_Internal_Rela *rel;
+     struct elf_lx_link_hash_table *htab;
+{
+  struct elf_lx_stub_hash_entry *stub_entry;
+  struct elf_lx_link_hash_entry *h = (struct elf_lx_link_hash_entry *) hash;
+  const asection *id_sec;
+
+  if ((input_section->flags & SEC_CODE) == 0)
+    return NULL;
+
+  /* If this input section is part of a group of sections sharing one
+     stub section, then use the id of the first section in the group.
+     Stub names need to include a section id, as there may well be
+     more than one stub used to reach say, printf, and we need to
+     distinguish between them.  */
+  id_sec = htab->stub_group[input_section->id].link_sec;
+
+  if (h != NULL && h->stub_cache != NULL
+      && h->stub_cache->h == h
+      && h->stub_cache->id_sec == id_sec)
+    {
+      stub_entry = h->stub_cache;
+    }
+  else
+    {
+      char *stub_name;
+
+      stub_name = lx_stub_name (id_sec, sym_sec, h, rel);
+      if (stub_name == NULL)
+	return NULL;
+
+      stub_entry = lx_stub_hash_lookup (&htab->stub_hash_table,
+					stub_name, FALSE, FALSE);
+      if (h != NULL)
+	h->stub_cache = stub_entry;
+
+      free (stub_name);
+    }
+
+  return stub_entry;
+}
+
+/* Add a new stub entry to the stub hash.  Not all fields of the new
+   stub entry are initialised.  */
+
+static struct elf_lx_stub_hash_entry *
+lx_add_stub (stub_name, section, htab)
+     const char *stub_name;
+     asection *section;
+     struct elf_lx_link_hash_table *htab;
+{
+  asection *link_sec;
+  asection *stub_sec;
+  struct elf_lx_stub_hash_entry *stub_entry;
+
+  link_sec = htab->stub_group[section->id].link_sec;
+  stub_sec = htab->stub_group[section->id].stub_sec;
+  if (stub_sec == NULL)
+    {
+      stub_sec = htab->stub_group[link_sec->id].stub_sec;
+      if (stub_sec == NULL)
+	{
+	  size_t namelen;
+	  bfd_size_type len;
+	  char *s_name;
+
+	  namelen = strlen (link_sec->name);
+	  len = namelen + sizeof (STUB_SUFFIX);
+	  s_name = bfd_alloc (htab->stub_bfd, len);
+	  if (s_name == NULL)
+	    return NULL;
+
+	  memcpy (s_name, link_sec->name, namelen);
+	  memcpy (s_name + namelen, STUB_SUFFIX, sizeof (STUB_SUFFIX));
+	  stub_sec = (*htab->add_stub_section) (s_name, link_sec);
+	  if (stub_sec == NULL)
+	    return NULL;
+	  htab->stub_group[link_sec->id].stub_sec = stub_sec;
+	}
+      htab->stub_group[section->id].stub_sec = stub_sec;
+    }
+
+  /* Enter this entry into the linker stub hash table.  */
+  stub_entry = lx_stub_hash_lookup (&htab->stub_hash_table, stub_name,
+				    TRUE, FALSE);
+  if (stub_entry == NULL)
+    {
+      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
+			     section->owner,
+			     stub_name);
+      return NULL;
+    }
+
+  stub_entry->stub_sec = stub_sec;
+  stub_entry->stub_offset = 0;
+  stub_entry->id_sec = link_sec;
+  return stub_entry;
+}
+
+static bfd_boolean
+lx_build_one_stub (gen_entry, in_arg)
+     struct bfd_hash_entry *gen_entry;
+     PTR in_arg;
+{
+  struct elf_lx_stub_hash_entry *stub_entry;
+  struct bfd_link_info *info;
+  struct elf_lx_link_hash_table *htab;
+  asection *stub_sec;
+  bfd *stub_bfd;
+  bfd_vma stub_addr;
+  bfd_byte *loc;
+  bfd_vma sym_value;
+  unsigned long symndx;
+  Elf_Internal_Rela *relocs;
+  int template_size;
+  int size;
+  const bfd_vma *template;
+  int i;
+  bfd_boolean has_interlocks;
+  bfd_vma addend;
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf_lx_stub_hash_entry *) gen_entry;
+  info = (struct bfd_link_info *) in_arg;
+
+  htab = elf_lx_hash_table (info);
+  stub_sec = stub_entry->stub_sec;
+
+  /* Make a note of the offset within the stubs for this entry.  */
+  stub_entry->stub_offset = stub_sec->size;
+  loc = stub_sec->contents + stub_entry->stub_offset;
+
+  stub_bfd = htab->stub_bfd;
+
+  /* This is the address of the start of the stub */
+  stub_addr = stub_sec->output_section->vma + stub_sec->output_offset
+    + stub_entry->stub_offset;
+
+  /* This is the address of the stub destination */
+  sym_value = (stub_entry->target_value
+	       + stub_entry->target_section->output_offset
+	       + stub_entry->target_section->output_section->vma);
+
+  symndx = 0;
+  addend = sym_value;
+  relocs = NULL;
+
+  if (info->emitrelocations)
+    {
+      struct bfd_elf_section_data *elfsec_data;
+      struct elf_lx_link_hash_entry *h;
+      struct bfd_link_hash_entry *bh = NULL;
+      struct elf_link_hash_entry *eh;
+      bfd_vma stub_offset;
+      const char *stub_name = stub_entry->root.string;
+
+      h = stub_entry->h;
+
+      /* Create a symbol to label the stub.
+	 For the relocations that are redirected to this stub, we will rewrite
+	 them to refer to this symbol.
+      */
+      stub_offset = stub_sec->output_offset + stub_entry->stub_offset;
+      /* Make a symbol to mark the start of the stub. */
+      if (! _bfd_generic_link_add_one_symbol (info, stub_bfd, stub_name, BSF_GLOBAL,
+					      stub_sec, stub_offset,
+					      NULL, TRUE, FALSE, &bh))
+	return FALSE;
+      stub_entry->sh = (struct elf_lx_link_hash_entry *)bh;
+      eh = (struct elf_link_hash_entry *)bh;
+      eh->type = STT_FUNC;
+      eh->other = (eh->other & ~ELF_ST_VISIBILITY (-1)) | STV_HIDDEN;
+      elf_lx_hash_hide_symbol (info, eh, TRUE);
+
+      if (stub_entry->stub_type != lx_stub_abs_long_branch)
+	/* We are only able to emit relocations for an absolute long
+	   branch stub.  The PC-relative long branch stubs require
+	   relocation types that do not exist (we would need something
+	   like R_LX_LO9_PCREL/R_LX_HI23_PCREL).
+	*/
+	{
+	  (*_bfd_error_handler)
+	    (_("%s: cannot emit relocations for PIC far call to %s"),
+	       bfd_get_filename (stub_entry->id_sec->owner),
+	       (h != NULL) ? h->root.root.root.string: "local symbol");
+	  return FALSE;
+	}
+      if (h != NULL)
+	{
+	  struct elf_link_hash_entry **hashes;
+	  
+	  hashes = elf_sym_hashes (stub_bfd);
+	  if (hashes == NULL)
+	    {
+	      bfd_size_type hsize;
+	      
+	      hsize = (htab->stub_globals + 1) * sizeof (*hashes);
+	      hashes = bfd_zalloc (stub_bfd, hsize);
+	      if (hashes == NULL)
+		return FALSE;
+	      elf_sym_hashes (stub_bfd) = hashes;
+	      htab->stub_globals = 1;
+	    }
+	  symndx = htab->stub_globals++;
+	  hashes[symndx] = &h->root;
+	  addend = 0;
+	}
+
+      elfsec_data = elf_section_data (stub_sec);
+      relocs = elfsec_data->relocs;
+      if (relocs == NULL)
+	{
+	  bfd_size_type relsize;
+	  relsize = stub_sec->reloc_count * sizeof (*relocs);
+	  relocs = bfd_alloc (stub_bfd, relsize);
+	  if (relocs == NULL)
+	    return FALSE;
+	  elfsec_data->relocs = relocs;
+	  elfsec_data->rel_hdr.sh_size = relsize;
+	  elfsec_data->rel_hdr.sh_entsize = sizeof (Elf32_External_Rela);
+	  stub_sec->reloc_count = 0;
+	}
+    }
+
+  switch (stub_entry->stub_type)
+    {
+    case lx_stub_abs_long_branch:
+      template = abs_long_branch_stub;
+      template_size = (sizeof(abs_long_branch_stub) / sizeof (bfd_vma)) * 4;
+      break;
+    case lx_stub_pic_long_branch_pre_st240:
+      template = pic_long_branch_stub_pre_st240;
+      template_size = (sizeof(pic_long_branch_stub_pre_st240) / sizeof (bfd_vma)) * 4;
+      break;
+    case lx_stub_pic_long_branch_st240:
+      template = pic_long_branch_stub_st240;
+      template_size = (sizeof(pic_long_branch_stub_st240) / sizeof (bfd_vma)) * 4;
+      break;
+    default:
+      BFD_FAIL ();
+      return FALSE;
+    }
+
+  has_interlocks = 1;
+  size = 0;
+  for (i = 0; i < (template_size / 4); i++)
+    if (!has_interlocks
+	|| (template[i] != NOP_BUNDLE && template[i] != NOP_NOP_BUNDLE))
+      {
+	bfd_put_32 (stub_bfd, template[i], loc + size);
+	size += 4;
+      }
+  if (size & 7)
+    { /* To ensure all stubs are even-aligned (convenient because
+	 the templates do not work on odd-alignment) we tail pad. */
+      bfd_put_32 (stub_bfd, NOP_BUNDLE, loc + size);
+      size += 4;
+    }
+  stub_sec->size += size;
+  if (stub_entry->sh)
+    stub_entry->sh->root.size = size;
+
+  switch (stub_entry->stub_type)
+    {
+    case lx_stub_abs_long_branch:
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23, stub_bfd,
+				stub_sec, stub_sec->contents,
+				stub_entry->stub_offset, sym_value, 0);
+      if (info->emitrelocations)
+	{
+	  Elf_Internal_Rela *r = relocs + stub_sec->reloc_count++;
+	  r->r_offset = stub_entry->stub_offset;
+	  r->r_info = ELF32_R_INFO (symndx, R_LX_HI23);
+	  r->r_addend = addend;
+	}
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9, stub_bfd,
+				stub_sec, stub_sec->contents,
+				stub_entry->stub_offset + 4, sym_value,  0);
+      if (info->emitrelocations)
+	{
+	  Elf_Internal_Rela *r = relocs + stub_sec->reloc_count++;
+	  r->r_offset = stub_entry->stub_offset + 4;
+	  r->r_info = ELF32_R_INFO (symndx, R_LX_LO9);
+	  r->r_addend = addend;
+	}
+      break;
+    case lx_stub_pic_long_branch_pre_st240:
+      /* We want the value relative to the address
+	 8 bytes from the start of the stub */
+      sym_value -= stub_addr + 8;
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23, stub_bfd,
+				stub_sec, stub_sec->contents,
+				stub_entry->stub_offset + 8, sym_value, 0);
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9, stub_bfd,
+				stub_sec, stub_sec->contents,
+				stub_entry->stub_offset + 12, sym_value,  0);
+      break;
+    case lx_stub_pic_long_branch_st240:
+      /* We want the value relative to the address
+	 of the first bundle of the stub */
+      sym_value -= stub_addr;
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23, stub_bfd,
+				stub_sec, stub_sec->contents,
+				stub_entry->stub_offset + 0, sym_value, 0);
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9, stub_bfd,
+				stub_sec, stub_sec->contents,
+				stub_entry->stub_offset + 4, sym_value,  0);
+    default:
+      break;
+    }
+
+  return TRUE;
+}
+
+/* As above, but don't actually build the stub.  Just bump offset so
+   we know stub section sizes.  */
+
+static bfd_boolean
+lx_size_one_stub (gen_entry, in_arg)
+     struct bfd_hash_entry *gen_entry;
+     PTR in_arg;
+{
+  struct elf_lx_stub_hash_entry *stub_entry;
+  struct bfd_link_info *info;
+  struct elf_lx_link_hash_table *htab;
+  const bfd_vma *template;
+  int template_size;
+  int size;
+  int i;
+  bfd_boolean has_interlocks;
+  int relocs;
+  asection *stub_sec;
+
+  /* Massage our args to the form they really have.  */
+  stub_entry = (struct elf_lx_stub_hash_entry *) gen_entry;
+  info = in_arg;
+  htab = elf_lx_hash_table (info);
+
+  relocs = 0;
+  stub_sec = stub_entry->stub_sec;
+
+  switch (stub_entry->stub_type)
+    {
+    case lx_stub_abs_long_branch:
+      template =  abs_long_branch_stub;
+      template_size = (sizeof(abs_long_branch_stub) / sizeof (bfd_vma)) * 4;
+      relocs = 2;
+      break;
+    case lx_stub_pic_long_branch_pre_st240:
+      template = pic_long_branch_stub_pre_st240;
+      template_size = (sizeof(pic_long_branch_stub_pre_st240) / sizeof (bfd_vma)) * 4;
+      break;
+    case lx_stub_pic_long_branch_st240:
+      template = pic_long_branch_stub_st240;
+      template_size = (sizeof(pic_long_branch_stub_st240) / sizeof (bfd_vma)) * 4;
+      break;
+    default:
+      BFD_FAIL ();
+      return FALSE;
+      break;
+    }
+
+  has_interlocks = 1;
+  size = 0;
+  for (i = 0; i < (template_size/4); i++)
+    if (!has_interlocks	||
+	(template[i] != NOP_BUNDLE && template[i] != NOP_NOP_BUNDLE))
+      size += 4;
+  size = (size + 7) & ~7;
+  stub_sec->size += size;
+
+  if (info->emitrelocations)
+    {
+      stub_sec->reloc_count += relocs;
+      stub_sec->flags |= SEC_RELOC;
+    }
+  
+  return TRUE;
+}
+
+/* External entry points for sizing and building linker stubs.  */
+
+/* Set up various things so that we can make a list of input sections
+   for each output section included in the link.  Returns -1 on error,
+   0 when no stubs will be needed, and 1 on success.  */
+
+int
+elf_lx_setup_section_lists (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  bfd *input_bfd;
+  unsigned int bfd_count;
+  int top_id, top_index;
+  asection *section;
+  asection **input_list, **list;
+  bfd_size_type amt;
+  struct elf_lx_link_hash_table *htab = elf_lx_hash_table (info);
+
+  if (bfd_get_flavour (info->output_bfd) != bfd_target_elf_flavour)
+    return 0;
+
+  /* Count the number of input BFDs and find the top input section id.  */
+  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
+       input_bfd != NULL;
+       input_bfd = input_bfd->link_next)
+    {
+      bfd_count += 1;
+      for (section = input_bfd->sections;
+	   section != NULL;
+	   section = section->next)
+	{
+	  if (top_id < section->id)
+	    top_id = section->id;
+	}
+    }
+  htab->bfd_count = bfd_count;
+
+  amt = sizeof (struct map_stub) * (top_id + 1);
+  htab->stub_group = (struct map_stub *) bfd_zmalloc (amt);
+  if (htab->stub_group == NULL)
+    return -1;
+
+  /* We can't use output_bfd->section_count here to find the top output
+     section index as some sections may have been removed, and
+     strip_excluded_output_sections doesn't renumber the indices. */
+  for (section = output_bfd->sections, top_index = 0;
+       section != NULL;
+       section = section->next)
+    {
+      if (top_index < section->index)
+	top_index = section->index;
+    }
+
+  htab->top_index = top_index;
+  amt = sizeof (asection *) * (top_index + 1);
+  input_list = (asection **) bfd_malloc (amt);
+  htab->input_list = input_list;
+  if (input_list == NULL)
+    return -1;
+
+  /* For sections we aren't interested in, mark their entries with a
+     value we can check later.  */
+  list = input_list + top_index;
+  do
+    *list = bfd_abs_section_ptr;
+  while (list-- != input_list);
+
+  for (section = output_bfd->sections;
+       section != NULL;
+       section = section->next)
+    {
+      if ((section->flags & SEC_CODE) != 0)
+	input_list[section->index] = NULL;
+    }
+
+  return 1;
+}
+
+/* The linker repeatedly calls this function for each input section,
+   in the order that input sections are linked into output sections.
+   Build lists of input sections to determine groupings between which
+   we may insert linker stubs.  */
+
+void
+elf_lx_next_input_section (info, isec)
+     struct bfd_link_info *info;
+     asection *isec;
+{
+  struct elf_lx_link_hash_table *htab = elf_lx_hash_table (info);
+
+  if (isec->output_section->index <= htab->top_index)
+    {
+      asection **list = htab->input_list + isec->output_section->index;
+      if (*list != bfd_abs_section_ptr)
+	{
+	  /* Steal the link_sec pointer for our list.  */
+#define PREV_SEC(sec) (htab->stub_group[(sec)->id].link_sec)
+	  /* This happens to make the list in reverse order,
+	     which is what we want.  */
+	  PREV_SEC (isec) = *list;
+	  *list = isec;
+	}
+    }
+}
+
+/* See whether we can group stub sections together.  Grouping stub
+   sections may result in fewer stubs.  More importantly, we need to
+   put all .init* and .fini* stubs at the beginning of the .init or
+   .fini output sections respectively, because glibc splits the
+   _init and _fini functions into multiple parts.  Putting a stub in
+   the middle of a function is not a good idea.  */
+
+static void
+group_sections (htab, stub_group_size, stubs_always_before_branch)
+     struct elf_lx_link_hash_table *htab;
+     bfd_size_type stub_group_size;
+     bfd_boolean stubs_always_before_branch;
+{
+  asection **list = htab->input_list + htab->top_index;
+  do
+    {
+      asection *tail = *list;
+      if (tail == bfd_abs_section_ptr)
+	continue;
+      while (tail != NULL)
+	{
+	  asection *curr;
+	  asection *prev;
+	  bfd_size_type total;
+
+	  curr = tail;
+	  total = tail->size;
+	  while ((prev = PREV_SEC (curr)) != NULL
+		 && ((total += curr->output_offset - prev->output_offset)
+		     < stub_group_size))
+	    curr = prev;
+
+	  /* OK, the size from the start of CURR to the end is less
+	     than stub_group_size and thus can be handled by one stub
+	     section.  (or the tail section is itself larger than
+	     stub_group_size, in which case we may be toast.)
+	     We should really be keeping track of the total size of
+	     stubs added here, as stubs contribute to the final output
+	     section size. */
+	  do
+	    {
+	      prev = PREV_SEC (tail);
+	      /* Set up this stub group.  */
+	      htab->stub_group[tail->id].link_sec = curr;
+	    }
+	  while (tail != curr && (tail = prev) != NULL);
+
+	  /* But wait, there's more!  Input sections up to stub_group_size
+	     bytes before the stub section can be handled by it too.  */
+	  if (!stubs_always_before_branch)
+	    {
+	      total = 0;
+	      while (prev != NULL
+		     && ((total += tail->output_offset - prev->output_offset)
+			 < stub_group_size))
+		{
+		  tail = prev;
+		  prev = PREV_SEC (tail);
+		  htab->stub_group[tail->id].link_sec = curr;
+		}
+	    }
+	  tail = prev;
+	}
+    }
+  while (list-- != htab->input_list);
+  free (htab->input_list);
+#undef PREV_SEC
+}
+
+/* Determine and set the size of the stub section for a final link.
+
+   The basic idea here is to examine all the relocations looking for
+   PC-relative calls to a target that is unreachable with a "bl"
+   instruction.  */
+
+bfd_boolean
+elf_lx_size_stubs (output_bfd, stub_bfd, info, group_size,
+		   add_stub_section, layout_sections_again)
+     bfd *output_bfd;
+     bfd *stub_bfd;
+     struct bfd_link_info *info;
+     bfd_signed_vma group_size;
+     asection * (*add_stub_section) PARAMS ((const char *, asection *));
+     void (*layout_sections_again) PARAMS ((void));
+{
+  bfd_size_type stub_group_size;
+  bfd_boolean stubs_always_before_branch;
+  bfd_boolean stub_changed = 0;
+  struct elf_lx_link_hash_table *htab = elf_lx_hash_table (info);
+
+  /* Propagate mach to stub bfd, because it may not have been
+     finalized when we created stub_bfd. */
+  bfd_set_arch_mach (stub_bfd, bfd_get_arch (output_bfd),
+		     bfd_get_mach (output_bfd));
+
+  /* Stash our params away.  */
+  htab->add_stub_section = add_stub_section;
+  htab->layout_sections_again = layout_sections_again;
+  stubs_always_before_branch = group_size < 0;
+  if (group_size < 0)
+    stub_group_size = -group_size;
+  else
+    stub_group_size = group_size;
+  if (stub_group_size == 1)
+    {
+      /* Default values.  */
+      /* Normal branch range is +-16MB.  This value is
+	 77K less than that, which allows for 2757 28-byte stubs.
+	 If we exceed that, then we will fail to link.  The user
+	 will have to relink with an explicit group size option.
+      */
+      stub_group_size = 16700000;
+    }
+
+  group_sections (htab, stub_group_size, stubs_always_before_branch);
+
+  while (1)
+    {
+      bfd *input_bfd;
+      unsigned int bfd_indx;
+      asection *stub_sec;
+
+      for (input_bfd = info->input_bfds, bfd_indx = 0;
+	   input_bfd != NULL;
+	   input_bfd = input_bfd->link_next, bfd_indx++)
+	{
+	  Elf_Internal_Shdr *symtab_hdr;
+	  asection *section;
+	  Elf_Internal_Sym *local_syms = NULL;
+
+	  /* We'll need the symbol table in a second.  */
+	  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+	  if (symtab_hdr->sh_info == 0)
+	    continue;
+
+	  /* Walk over each section attached to the input bfd.  */
+	  for (section = input_bfd->sections;
+	       section != NULL;
+	       section = section->next)
+	    {
+	      Elf_Internal_Rela *internal_relocs, *irelaend, *irela;
+
+	      /* If there aren't any relocs, then there's nothing more
+		 to do.  */
+	      if ((section->flags & SEC_RELOC) == 0
+		  || section->reloc_count == 0
+		  || (section->flags & SEC_CODE) == 0)
+		continue;
+
+	      /* If this section is a link-once section that will be
+		 discarded, then don't create any stubs.  */
+	      if (section->output_section == NULL
+		  || section->output_section->owner != output_bfd)
+		continue;
+
+	      /* Get the relocs.  */
+	      internal_relocs
+		= _bfd_elf_link_read_relocs (input_bfd, section, NULL,
+					       (Elf_Internal_Rela *) NULL,
+					       info->keep_memory);
+	      if (internal_relocs == NULL)
+		goto error_ret_free_local;
+
+	      /* Now examine each relocation.  */
+	      irela = internal_relocs;
+	      irelaend = irela + section->reloc_count;
+	      for (; irela < irelaend; irela++)
+		{
+		  unsigned int r_type, r_indx;
+		  enum elf_lx_stub_type stub_type;
+		  struct elf_lx_stub_hash_entry *stub_entry;
+		  asection *sym_sec;
+		  bfd_vma sym_value;
+		  bfd_vma destination;
+		  struct elf_lx_link_hash_entry *hash;
+		  char *stub_name;
+		  const asection *id_sec;
+
+		  r_type = ELF32_R_TYPE (irela->r_info);
+		  r_indx = ELF32_R_SYM (irela->r_info);
+
+		  if (r_type >= (unsigned int) R_LX_max)
+		    {
+		      bfd_set_error (bfd_error_bad_value);
+		    error_ret_free_internal:
+		      if (elf_section_data (section)->relocs == NULL)
+			free (internal_relocs);
+		      goto error_ret_free_local;
+		    }
+
+		  /* Only look for stubs on call instructions.  */
+		  if (r_type != (unsigned int) R_LX_23_PCREL)
+		    continue;
+
+		  /* Now determine the call target, its name, value,
+		     section.  */
+		  sym_sec = NULL;
+		  sym_value = 0;
+		  destination = 0;
+		  hash = NULL;
+		  if (r_indx < symtab_hdr->sh_info)
+		    {
+		      /* It's a local symbol.  */
+		      Elf_Internal_Sym *sym;
+		      Elf_Internal_Shdr *hdr;
+
+		      if (local_syms == NULL)
+			{
+			  local_syms
+			    = (Elf_Internal_Sym *) symtab_hdr->contents;
+			  if (local_syms == NULL)
+			    local_syms
+			      = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
+						      symtab_hdr->sh_info, 0,
+						      NULL, NULL, NULL);
+			  if (local_syms == NULL)
+			    goto error_ret_free_internal;
+			}
+
+		      sym = local_syms + r_indx;
+		      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
+		      sym_sec = hdr->bfd_section;
+		      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
+			sym_value = sym->st_value;
+		      destination = (sym_value + irela->r_addend
+				     + sym_sec->output_offset
+				     + sym_sec->output_section->vma);
+		    }
+		  else
+		    {
+		      /* It's an external symbol.  */
+		      int e_indx;
+
+		      e_indx = r_indx - symtab_hdr->sh_info;
+		      hash = ((struct elf_lx_link_hash_entry *)
+			      elf_sym_hashes (input_bfd)[e_indx]);
+
+		      while (hash->root.root.type == bfd_link_hash_indirect
+			     || hash->root.root.type == bfd_link_hash_warning)
+			hash = ((struct elf_lx_link_hash_entry *)
+				hash->root.root.u.i.link);
+
+		      if (hash->root.root.type == bfd_link_hash_defined
+			  || hash->root.root.type == bfd_link_hash_defweak)
+			{
+			  sym_sec = hash->root.root.u.def.section;
+			  sym_value = hash->root.root.u.def.value;
+			  if (sym_sec->output_section != NULL)
+			    destination = (sym_value + irela->r_addend
+					   + sym_sec->output_offset
+					   + sym_sec->output_section->vma);
+			}
+		      else if (hash->root.root.type == bfd_link_hash_undefweak
+			       || hash->root.root.type == bfd_link_hash_undefined)
+			/* For a shared library, these will need a PLT stub,
+			   which is treated separately.
+			   For absolute code, they cannot be handled.
+			*/
+			continue;
+		      else
+			{
+			  bfd_set_error (bfd_error_bad_value);
+			  goto error_ret_free_internal;
+			}
+		    }
+
+		  /* Determine what (if any) linker stub is needed.  */
+		  stub_type = lx_type_of_stub (output_bfd, info,
+					       section, irela, hash,
+					       destination);
+		  if (stub_type == lx_stub_none)
+		    continue;
+
+		  /* Support for grouping stub sections.  */
+		  id_sec = htab->stub_group[section->id].link_sec;
+
+		  /* Get the name of this stub.  */
+		  stub_name = lx_stub_name (id_sec, sym_sec, hash, irela);
+		  if (!stub_name)
+		    goto error_ret_free_internal;
+
+		  stub_entry = lx_stub_hash_lookup (&htab->stub_hash_table,
+						    stub_name,
+						    FALSE, FALSE);
+		  if (stub_entry != NULL)
+		    {
+		      /* The proper stub has already been created.  */
+		      free (stub_name);
+		      continue;
+		    }
+
+		  stub_entry = lx_add_stub (stub_name, section, htab);
+		  if (stub_entry == NULL)
+		    {
+		      free (stub_name);
+		      goto error_ret_free_internal;
+		    }
+
+		  stub_entry->target_value = sym_value;
+		  stub_entry->target_section = sym_sec;
+		  stub_entry->stub_type = stub_type;
+		  stub_entry->h = hash;
+		  
+		  if (hash != NULL)
+		    htab->stub_globals += 1;
+
+		  stub_changed = TRUE;
+		}
+
+	      /* We're done with the internal relocs, free them.  */
+	      if (elf_section_data (section)->relocs == NULL)
+		free (internal_relocs);
+	    }
+	}
+
+      if (!stub_changed)
+	break;
+
+      /* OK, we've added some stubs.  Find out the new size of the
+	 stub sections.  */
+      for (stub_sec = stub_bfd->sections;
+	   stub_sec != NULL;
+	   stub_sec = stub_sec->next)
+	{
+	  stub_sec->size = 0;
+	}
+
+      bfd_hash_traverse (&htab->stub_hash_table, lx_size_one_stub, info);
+
+      /* Ask the linker to do its stuff.  */
+      (*htab->layout_sections_again) ();
+      stub_changed = FALSE;
+    }
+
+  return TRUE;
+
+ error_ret_free_local:
+  return FALSE;
+}
+
+/* Build all the stubs associated with the current output file.  The
+   stubs are kept in a hash table attached to the main linker hash
+   table.  We also set up the .plt entries for statically linked PIC
+   functions here.  This function is called via lx_elf_finish in the
+   linker.  */
+
+bfd_boolean
+elf_lx_build_stubs (info)
+     struct bfd_link_info *info;
+{
+  asection *stub_sec;
+  struct bfd_hash_table *table;
+  struct elf_lx_link_hash_table *htab;
+
+  htab = elf_lx_hash_table (info);
+
+  for (stub_sec = htab->stub_bfd->sections;
+       stub_sec != NULL;
+       stub_sec = stub_sec->next)
+    if (stub_sec->size != 0)
+      {
+	bfd_size_type size;
+
+	/* Allocate memory to hold the linker stubs.  */
+	size = stub_sec->size;
+	stub_sec->contents = (unsigned char *) bfd_zalloc (htab->stub_bfd, size);
+	if (stub_sec->contents == NULL)
+	  return FALSE;
+	stub_sec->size = 0;
+      }
+
+  /* Build the stubs as directed by the stub hash table.  */
+  table = &htab->stub_hash_table;
+  bfd_hash_traverse (table, lx_build_one_stub, info);
+
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase, and
+   calculate needed space in the global offset table, procedure linkage
+   table, and dynamic reloc sections.  */
+
+static bfd_boolean
+elf_lx_check_relocs (abfd, info, sec, relocs)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *sec;
+     const Elf_Internal_Rela *relocs;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  Elf_Internal_Shdr *symtab_hdr;
+  asection *got, *fptr, *srel;
+
+  if (info->relocatable)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  lx_info = elf_lx_hash_table (info);
+
+  got = fptr = srel = NULL;
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      enum {
+	NEED_GOT = 1,
+	NEED_FPTR = 2,
+	NEED_PLTOFF = 4,
+	NEED_MIN_PLT = 8,
+	NEED_FULL_PLT = 16,
+	NEED_DYNREL = 32,
+	NEED_LTOFF_FPTR = 64,
+	NEED_TPREL = 128,
+	NEED_DTPLDM = 256,
+	NEED_DTPNDX = 512,
+	NEED_DYNBSS = 1024
+      };
+
+      struct elf_link_hash_entry *h = NULL;
+      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
+      struct elf_lx_dyn_sym_info *dyn_i;
+      int need_entry;
+      bfd_boolean maybe_dynamic;
+      int dynrel_type = R_LX_NONE;
+      unsigned int r_type;
+
+      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
+	{
+	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
+				 abfd, r_symndx);
+	  return FALSE;
+	}
+
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  /* We're dealing with a global symbol -- find its hash entry
+	     and mark it as being referenced.  */
+	  long indx = r_symndx - symtab_hdr->sh_info;
+	  h = elf_sym_hashes (abfd)[indx];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  h->ref_regular = 1;
+	}
+
+      /* We can only get preliminary data on whether a symbol is
+	 locally or externally defined, as not all of the input files
+	 have yet been processed.  Do something with what we know, as
+	 this may help reduce memory usage and processing time later.  */
+      maybe_dynamic = FALSE;
+      if (h && ((info->shared
+		      && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
+		|| ! h->def_regular
+		|| h->root.type == bfd_link_hash_defweak))
+	maybe_dynamic = TRUE;
+
+      need_entry = 0;
+
+      r_type = ELF32_R_TYPE (rel->r_info); 
+      switch (r_type)
+	{
+	case R_LX_GOTOFF_FPTR_HI23:
+	case R_LX_GOTOFF_FPTR_LO9:
+	  need_entry = NEED_FPTR | NEED_GOT | NEED_LTOFF_FPTR;
+	  break;
+
+	case R_LX_FPTR32:
+	  if (info->shared || h)
+	    need_entry = NEED_FPTR | NEED_DYNREL;
+	  else
+	    need_entry = NEED_FPTR;
+	  dynrel_type = R_LX_FPTR32;
+	  break;
+
+	case R_LX_GOTOFF_HI23:
+	case R_LX_GOTOFF_LO9:
+	case R_LX_GOTOFFX_HI23:
+	case R_LX_GOTOFFX_LO9:
+	  need_entry = NEED_GOT;
+	  break;
+
+	case R_LX_PLTOFF_HI23:
+	case R_LX_PLTOFF_LO9:
+	  need_entry = NEED_PLTOFF;
+	  if (h)
+	    {
+	      if (maybe_dynamic)
+		need_entry |= NEED_MIN_PLT;
+	    }
+	  else
+	    {
+	      (*info->callbacks->warning)
+		(info, _("@pltoff reloc against local symbol"), 0,
+		 abfd, 0, (bfd_vma) 0);
+	    }
+	  break;
+
+	case R_LX_23_PCREL:
+	  /* This is a call or jump (tailcall) to a symbol. */
+	  /* Depending on where the symbol is defined, we may or may not
+	     need a full plt entry.  Only skip if we know we'll not need
+	     the entry -- static or symbolic, and the symbol definition
+	     has already been seen.  */
+	  if (maybe_dynamic && rel->r_addend == 0)
+	    need_entry = NEED_FULL_PLT;
+	  break;
+
+	case R_LX_HI23:
+	case R_LX_LO9:
+	case R_LX_16:
+	  /* R_LX_HI23 and R_LX_LO9 use absolute addresses.  They should
+	     never appear in PIC code.  Currently, we only allow PIC
+	     code in shared libraries, so if we are linking a shared
+	     library, there is a mistake. */
+	  /* R_LX_16 should not appear in a dynamic object.
+	     ??? Should this be faulted? */
+	  /* ??? Would also like to check if these relocations occur
+	     in a PIC main program. */
+	  if (info->shared || L_RELOCATABLE)
+	    {
+	      (*_bfd_error_handler) (_("%B: contains absolute relocation: %d"),
+				     abfd, r_type);
+	      return FALSE;
+	    }
+	  if (h && ! (info->shared || L_RELOCATABLE))
+	    {
+	      h->non_got_ref = 1;
+	    }
+	  if (maybe_dynamic)
+	    need_entry = NEED_DYNBSS | NEED_DYNREL;
+	  dynrel_type = r_type;
+	  break;
+
+	case R_LX_32:
+	  if (h && !(info->shared || L_RELOCATABLE))
+	    {
+	      h->non_got_ref = 1;
+	    }
+	  /* Shared objects will always need at least a REL relocation.  */
+	  if (info->shared || L_RELOCATABLE || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = R_LX_32;
+	  break;
+
+	case R_LX_IPLT:
+	  if (info->shared || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = R_LX_IPLT;
+	  break;
+
+	case R_LX_32_PCREL:
+	  /* A PC-relative relocation to a symbol in another load module
+	     requires a dynamic relocation. */
+	  if (maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = R_LX_32_PCREL;
+	  break;
+
+	case R_LX_TPREL32:
+	  if (info->shared || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = r_type;
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  break;
+
+	case R_LX_GOTOFF_TPREL_HI23:
+	case R_LX_GOTOFF_TPREL_LO9:
+	  need_entry = NEED_TPREL;
+	  if (info->shared)
+	    info->flags |= DF_STATIC_TLS;
+	  break;
+
+	case R_LX_GOTOFF_DTPLDM_HI23:
+	case R_LX_GOTOFF_DTPLDM_LO9:
+	  need_entry = NEED_DTPLDM;
+	  break;
+
+	case R_LX_GOTOFF_DTPNDX_HI23:
+	case R_LX_GOTOFF_DTPNDX_LO9:
+	  need_entry = NEED_DTPNDX;
+	  break;
+
+	case R_LX_DTPMOD32:
+	case R_LX_DTPREL32:
+	  if (info->shared || maybe_dynamic)
+	    need_entry = NEED_DYNREL;
+	  dynrel_type = r_type;
+	  break;
+	}
+
+      if (!need_entry)
+	continue;
+
+      if ((need_entry & NEED_FPTR) != 0
+	  && rel->r_addend)
+	{
+	  (*info->callbacks->warning)
+	    (info, _("non-zero addend in @fptr reloc"), 0,
+	     abfd, 0, (bfd_vma) 0);
+	}
+
+      dyn_i = get_dyn_sym_info (lx_info, h, abfd, rel, TRUE);
+
+      /* Record whether or not this is a local symbol. */
+      dyn_i->h = h;
+
+      if (need_entry & (NEED_GOT | NEED_TPREL | NEED_DTPLDM | NEED_DTPNDX))
+	{
+	  if (!got)
+	    {
+	      got = get_got (abfd, info, lx_info);
+	      if (!got)
+		return FALSE;
+	    }
+	  if (need_entry & NEED_GOT)
+	    dyn_i->want_got++;
+	  if (need_entry & NEED_TPREL)
+	    dyn_i->want_tprel++;
+	  if (need_entry & NEED_DTPLDM)
+	    dyn_i->want_dtpldm++;
+	  if (need_entry & NEED_DTPNDX)
+	    dyn_i->want_dtpndx++;
+	}
+      if (need_entry & NEED_FPTR)
+	{
+	  if (!fptr)
+	    {
+	      fptr = get_fptr (abfd, info, lx_info);
+	      if (!fptr)
+		return FALSE;
+	    }
+
+	  /* FPTRs for shared libraries are allocated by the dynamic
+	     linker.  Make sure this local symbol will appear in the
+	     dynamic symbol table. */
+	  if (!h && info->shared)
+	    {
+	      /* Old binutils does not support this, so give up. */
+	      if (! (bfd_elf_link_record_local_dynamic_symbol
+		     (info, abfd, (long) r_symndx)))
+		return FALSE;
+	    }
+	  dyn_i->want_fptr = 1;
+	}
+      if (need_entry & NEED_LTOFF_FPTR)
+	dyn_i->want_ltoff_fptr = 1;
+      if (need_entry & (NEED_MIN_PLT | NEED_FULL_PLT))
+	{
+	  if (!lx_info->root.dynobj)
+	    lx_info->root.dynobj = abfd;
+	  h->needs_plt = 1;
+	  dyn_i->want_plt = 1;
+	}
+      if (need_entry & NEED_FULL_PLT)
+	dyn_i->want_plt2 = 1;
+      if (need_entry & NEED_PLTOFF)
+	dyn_i->want_pltoff = 1;
+      if ((need_entry & NEED_DYNREL) && (sec->flags & SEC_ALLOC))
+	{
+	  if (!srel)
+	    {
+	      srel = get_reloc_section (abfd, lx_info, sec, TRUE);
+	      if (!srel)
+		return FALSE;
+	    }
+	  if (!count_dyn_reloc (abfd, dyn_i, sec, srel, dynrel_type))
+	    return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+struct elf_lx_allocate_data
+{
+  struct bfd_link_info *info;
+  bfd *output_bfd;
+  bfd_size_type ofs;
+  bfd_size_type align;
+};
+
+/* For cleanliness, and potentially faster dynamic loading, allocate
+   external GOT entries first.  */
+
+static bfd_boolean
+allocate_global_data_got (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (x->info);
+  asection *got_sec = lx_info->got_sec;
+  bfd_boolean emitrelocations = x->info->emitrelocations;
+
+  if (dyn_i->want_got
+      && ! dyn_i->want_fptr
+      && elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+     {
+       dyn_i->got_offset = x->ofs;
+       x->ofs += 4;
+       if (emitrelocations)
+	 got_sec->reloc_count++;
+     }
+  if (dyn_i->want_tprel)
+    {
+      dyn_i->tprel_offset = x->ofs;
+      x->ofs += 4;
+      if (emitrelocations)
+	got_sec->reloc_count++;
+    }
+  if (dyn_i->want_dtpldm)
+    {
+      if (elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+	{
+	  dyn_i->dtpldm_offset = x->ofs;
+	  x->ofs += 8;
+	  if (emitrelocations)
+	    got_sec->reloc_count++;
+	}
+      else
+	{
+	  if (lx_info->self_dtpldm_offset == (bfd_vma) -1)
+	    {
+	      lx_info->self_dtpldm_offset = x->ofs;
+	      x->ofs += 8;
+	      if (emitrelocations)
+		got_sec->reloc_count++;
+	    }
+	  dyn_i->dtpldm_offset = lx_info->self_dtpldm_offset;
+	}
+    }
+  if (dyn_i->want_dtpndx)
+    {
+      dyn_i->dtpndx_offset = x->ofs;
+      x->ofs += 8;
+      if (emitrelocations)
+	got_sec->reloc_count += 2;
+    }
+  return TRUE;
+}
+
+/* Next, allocate all the GOT entries used by GOTOFF_FPTR relocs.  */
+
+static bfd_boolean
+allocate_global_fptr_got (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (x->info);
+  asection *got_sec = lx_info->got_sec;
+
+  if (dyn_i->want_got
+      && dyn_i->want_fptr
+      && elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+    {
+      dyn_i->got_offset = x->ofs;
+      x->ofs += 4;
+      if (x->info->emitrelocations)
+	got_sec->reloc_count += 1;
+    }
+  return TRUE;
+}
+
+/* Lastly, allocate all the GOT entries for local data.  */
+
+static bfd_boolean
+allocate_local_got (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (x->info);
+  asection *got_sec = lx_info->got_sec;
+
+  if (dyn_i->want_got
+      && ! elf_lx_dynamic_symbol_p (dyn_i->h, x->info))
+    {
+      dyn_i->got_offset = x->ofs;
+      x->ofs += 4;
+      if (x->info->emitrelocations)
+	got_sec->reloc_count += 1;
+    }
+  return TRUE;
+}
+
+/* Search for the index of a global symbol in it's defining object file.  */
+
+static long
+global_sym_index (h)
+     struct elf_link_hash_entry *h;
+{
+  struct elf_link_hash_entry **p;
+  bfd *obj;
+
+  BFD_ASSERT (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak);
+
+  obj = h->root.u.def.section->owner;
+  for (p = elf_sym_hashes (obj); *p != h; ++p)
+    continue;
+
+  return p - elf_sym_hashes (obj) + elf_tdata (obj)->symtab_hdr.sh_info;
+}
+
+/* Allocate function descriptors.  We can do these for every function
+   in a main executable that is not exported.  */
+
+static bfd_boolean
+allocate_fptr (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_fptr)
+    {
+      struct elf_link_hash_entry *h = dyn_i->h;
+
+      if (h)
+	while (h->root.type == bfd_link_hash_indirect
+	       || h->root.type == bfd_link_hash_warning)
+	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      if (x->info->shared)
+	{
+	  if (h && h->dynindx == -1)
+	    {
+	      BFD_ASSERT ((h->root.type == bfd_link_hash_defined)
+			  || (h->root.type == bfd_link_hash_defweak));
+
+	      if (!bfd_elf_link_record_local_dynamic_symbol
+		    (x->info, h->root.u.def.section->owner,
+		     global_sym_index (h)))
+		return FALSE;
+	    }
+
+	  dyn_i->want_fptr = 0;
+	}
+      else if (h == NULL || h->dynindx == -1)
+	{
+	  dyn_i->fptr_offset = x->ofs;
+	  x->ofs += 8;
+	}
+      else
+	dyn_i->want_fptr = 0;
+    }
+  return TRUE;
+}
+
+/* Allocate all the minimal PLT entries.  */
+
+static bfd_boolean
+allocate_plt_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_plt)
+    {
+      struct elf_link_hash_entry *h = dyn_i->h;
+
+      if (h)
+	while (h->root.type == bfd_link_hash_indirect
+	       || h->root.type == bfd_link_hash_warning)
+	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+      /* ??? Versioned symbols seem to lose ELF_LINK_HASH_NEEDS_PLT.  */
+      if (elf_lx_dynamic_symbol_p (h, x->info)
+	  && !main_program_weak_def_p (h, x->info))
+	{
+	  bfd_size_type offset = x->ofs;
+	  if (offset == 0)
+	    offset = PLT_HEADER_SIZE;
+	  dyn_i->plt_offset = offset;
+	  
+	  x->ofs = offset + PLT_MIN_ENTRY_SIZE;
+
+	  dyn_i->want_pltoff = 1;
+	}
+      else
+	{
+	  dyn_i->want_plt = 0;
+	  dyn_i->want_plt2 = 0;
+	}
+    }
+  return TRUE;
+}
+
+/* Allocate all the full PLT entries.  */
+
+static bfd_boolean
+allocate_plt2_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_plt2)
+    {
+      struct elf_link_hash_entry *h = dyn_i->h;
+      bfd_size_type ofs = x->ofs;
+
+      dyn_i->plt2_offset = ofs;
+
+      x->ofs = ofs + (pic_abi_p (x->output_bfd)
+		      ? PLT_FULL_ENTRY_SIZE_PIC_ABI
+		      : PLT_FULL_ENTRY_SIZE);
+
+      while (h->root.type == bfd_link_hash_indirect
+	     || h->root.type == bfd_link_hash_warning)
+	h = (struct elf_link_hash_entry *) h->root.u.i.link;
+      dyn_i->h->plt.offset = ofs;
+
+      /* If this symbol is not defined in a regular file, and we are
+	 not generating a shared library, then set the symbol to this
+	 location in the .plt.  This is required to make function
+	 pointers compare as equal between the normal executable and
+	 the shared library.  */
+      if (! pic_abi_p (x->output_bfd)
+	  && ! x->info->shared
+	  && h
+	  && ! h->def_regular)
+	{
+	  struct elf_lx_link_hash_table *lx_info;
+	  
+	  lx_info = elf_lx_hash_table (x->info);
+	  h->root.u.def.section = lx_info->plt_sec;
+	  h->root.u.def.value = ofs;
+	}
+    }
+  return TRUE;
+}
+
+/* Allocate all the PLTOFF entries requested by relocations and
+   plt entries.  We can't share space with allocated FPTR entries,
+   because the latter are not necessarily addressable by the GP.
+   ??? Relaxation might be able to determine that they are.
+   PIC ABI: Allocate local function descriptors in .pltoff.
+   Embedded ABI: Allocate function pointers in .got.plt. */
+
+static bfd_boolean
+allocate_pltoff_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+
+  if (dyn_i->want_pltoff)
+    {
+      dyn_i->pltoff_offset = x->ofs;
+      if (pic_abi_p (x->output_bfd))
+	/* pltoff contains function descriptors */
+	x->ofs += 8;
+      else
+	/* pltoff (.got.plt) contains function pointers */
+	x->ofs += 4;
+    }
+  return TRUE;
+}
+
+/* Allocate dynamic relocations for those symbols that turned out
+   to be dynamic.  */
+
+static bfd_boolean
+allocate_dynrel_entries (dyn_i, data)
+     struct elf_lx_dyn_sym_info *dyn_i;
+     PTR data;
+{
+  struct elf_lx_allocate_data *x = (struct elf_lx_allocate_data *)data;
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_lx_dyn_reloc_entry *rent;
+  bfd_boolean dynamic_symbol, shared;
+
+  lx_info = elf_lx_hash_table (x->info);
+  dynamic_symbol = elf_lx_dynamic_symbol_p (dyn_i->h, x->info);
+  shared = x->info->shared;
+
+ /* Take care of the normal data relocations.  */
+
+  for (rent = dyn_i->reloc_entries; rent; rent = rent->next)
+    {
+      int count = rent->count;
+
+      switch (rent->type)
+	{
+	case R_LX_FPTR32:
+	  /* Allocate one iff !want_fptr, which by this point will
+	     be true only if we're actually allocating one statically
+	     in the main executable.  */
+	  if (dyn_i->want_fptr)
+	    continue;
+	  break;
+	case R_LX_IPLT:
+	case R_LX_JMP_SLOT:
+	  if (!dynamic_symbol && !shared)
+	    continue;
+	  /* Use two REL relocations for IPLT relocations
+	     against local symbols, one REL relocation for
+	     JMP_SLOT relocations against local symbols.  */
+	  if (!dynamic_symbol && rent->type == R_LX_IPLT)
+	    count *= 2;
+	  break;
+	case R_LX_32_PCREL:
+	  if (!dynamic_symbol)
+	    continue;
+	  break;
+	case R_LX_32:
+	  /* Dynamic symbols need a relocation.
+	     All symbols in shared/L_relocatable links need a relocation,
+	     unless they are absolute.
+	  */
+	  if (! dynamic_symbol && ! (shared || L_RELOCATABLE))
+	    continue;
+	  break;
+	case R_LX_LO9:
+	case R_LX_HI23:
+	  continue;
+	case R_LX_TPREL32:
+	case R_LX_DTPREL32:
+	case R_LX_DTPMOD32:
+	  break;
+	default:
+	  abort ();
+	}
+      rent->srel->size += sizeof (Elf32_External_Rela) * count;
+      if (count && (rent->sec->flags & SEC_READONLY))
+	lx_info->reltext = 1;
+    }
+
+  /* Take care of the GOT and PLT relocations.  */
+
+  if (((dynamic_symbol || shared) && dyn_i->want_got)
+      || (dyn_i->want_ltoff_fptr && dyn_i->h && dyn_i->h->dynindx != -1))
+    lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+  if ((dynamic_symbol || shared) && dyn_i->want_tprel)
+    lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+  if (dynamic_symbol && dyn_i->want_dtpldm)
+    lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+  if ((dynamic_symbol || shared) && dyn_i->want_dtpndx)
+    {
+      lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+      if (dynamic_symbol)
+	lx_info->rel_got_sec->size += sizeof (Elf32_External_Rela);
+    }
+
+  if (dyn_i->want_pltoff)
+    {
+      bfd_size_type t = 0;
+
+      /* Dynamic symbols get one IPLT relocation.
+         Local symbols in shared libraries get two REL
+         relocations (in the PIC ABI which uses fn descriptors)
+	 or one REL relocation (in the embedded ABI).
+	 Local symbols in main applications get nothing.  */
+      if (dynamic_symbol)
+	t = sizeof (Elf32_External_Rela);
+      else if (shared)
+	{
+	  if (pic_abi_p (x->output_bfd))
+	    t = 2 * sizeof (Elf32_External_Rela);
+	  else
+	    t = sizeof (Elf32_External_Rela);
+	}
+      lx_info->rel_pltoff_sec->size += t;
+    }
+
+  /* Take care of the COPY relocation. */
+  {
+    struct elf_lx_link_hash_entry *lx_h = (struct elf_lx_link_hash_entry *)dyn_i->h;
+
+    if (lx_h && lx_h->dynbss_size && ! lx_h->rel_dynbss_allocated)
+      {
+	lx_info->rel_dynbss_sec->size += sizeof (Elf32_External_Rela);
+	lx_h->rel_dynbss_allocated = TRUE;
+      }
+  }
+
+  return TRUE;
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+elf_lx_adjust_dynamic_symbol (info, h)
+     struct bfd_link_info *info;
+     struct elf_link_hash_entry *h;
+{
+  bfd *dynobj;
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_lx_dyn_sym_info *dyn_i;
+  struct elf_lx_dyn_sym_info *d;
+  struct elf_lx_dyn_reloc_entry *rent;
+
+#if 0
+  printf ("elf_lx_adjust_dynamic_symbol: %s (%p)\n", h->root.root.string, h);
+#endif
+
+  lx_info = elf_lx_hash_table (info);
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->u.weakdef != NULL
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && ! h->def_regular)));
+
+  dyn_i = get_dyn_sym_info (lx_info, h, NULL, NULL, FALSE);
+
+  /* Undefined symbols with PLT entries should be re-defined
+     to be the PLT entry.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (! dyn_i
+	  || (! info->shared
+	      && ! h->def_dynamic
+	      && ! h->ref_dynamic
+	      && h->root.type != bfd_link_hash_undefined))
+	{
+	  h->needs_plt = 0;
+	  return TRUE;
+	}
+
+      dyn_i->want_plt = 1;
+      dyn_i->want_plt2 = 1;
+      /* We want to set the symbol to the location in the .plt
+	 section, but cannot do that until it is allocated in
+	 size_dynamic_sections. */
+      return TRUE;
+    }
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+                  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* If this is a reference to a symbol defined by a dynamic object which
+     is not a function, we might allocate the symbol in our .dynbss section
+     and allocate a COPY dynamic relocation.
+  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (! h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  for (d = ((struct elf_lx_link_hash_entry *)h)->info; d; d = d->next)
+    {
+      for (rent = d->reloc_entries; rent; rent = rent->next)
+	{
+	  asection *s = rent->sec->output_section;
+	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	    break;
+	}
+      if (rent)
+	break;
+    }
+
+  /* If we didn't find any dynamic relocs in read-only sections, then
+     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
+  if (! d)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+#if 0
+  printf ("Allocating %s (%p) in bss\n", h->root.root.string, h);
+#endif
+
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
+    {
+      h->needs_copy = 1;
+    }
+
+  {
+    struct elf_lx_link_hash_entry *lx_h = (struct elf_lx_link_hash_entry *)h;
+    asection *s = lx_info->dynbss_sec;
+    unsigned int power_of_two = bfd_log2 (h->size);
+
+    if (power_of_two > 3)
+      power_of_two = 3;
+
+    s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
+    if (power_of_two > bfd_get_section_alignment (lx_info->root.dynobj, s))
+      {
+	if (! bfd_set_section_alignment (lx_info->root.dynobj, s, power_of_two))
+	  return FALSE;
+      }
+
+    /* Define the symbol as being at this point in the section.  */
+    h->root.u.def.section = s;
+    h->root.u.def.value = s->size;
+
+    /* Increment the section size to make room for the symbol.  */
+    s->size += h->size;
+
+    lx_h->dynbss_size = h->size;
+  }
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_size_dynamic_sections (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  struct elf_lx_allocate_data data;
+  struct elf_lx_link_hash_table *lx_info;
+  asection *sec;
+  bfd *dynobj;
+  bfd_boolean relplt = FALSE;
+
+  dynobj = elf_hash_table(info)->dynobj;
+  lx_info = elf_lx_hash_table (info);
+  lx_info->self_dtpldm_offset = (bfd_vma) -1;
+  BFD_ASSERT(dynobj != NULL);
+  data.info = info;
+  data.output_bfd = output_bfd;
+
+  /* Set the contents of the .interp section to the interpreter.  */
+  if (lx_info->root.dynamic_sections_created
+      && !info->shared)
+    {
+      sec = bfd_get_section_by_name (dynobj, ".interp");
+      BFD_ASSERT (sec != NULL);
+      sec->contents = (bfd_byte *) ELF_DYNAMIC_INTERPRETER;
+      sec->size = strlen (ELF_DYNAMIC_INTERPRETER) + 1;
+    }
+
+  /* Allocate the GOT entries.  */
+
+  if (lx_info->got_sec)
+    {
+      asection *got_sec = lx_info->got_sec;
+
+      data.ofs = 0;
+      elf_lx_dyn_sym_traverse (lx_info, allocate_global_data_got, &data);
+      elf_lx_dyn_sym_traverse (lx_info, allocate_global_fptr_got, &data);
+      elf_lx_dyn_sym_traverse (lx_info, allocate_local_got, &data);
+      got_sec->size = data.ofs;
+      if (got_sec->reloc_count > 0)
+	{
+	  /* Allocate relocs now, but do not fill it until we enter
+	     elf_lx_relocate_section for the got section. */
+	  struct bfd_elf_section_data *elfsec_data = elf_section_data (got_sec);
+	  bfd_size_type relsize = got_sec->reloc_count * sizeof (Elf_Internal_Rela);
+	  Elf_Internal_Rela *relocs = bfd_zalloc(lx_info->got_bfd, relsize);
+	  bfd_size_type relhash_size = (got_sec->reloc_count
+					* sizeof (struct elf_link_hash_entry *));
+	  BFD_ASSERT (elfsec_data->relocs == 0);
+	  elfsec_data->relocs = relocs;
+	  elfsec_data->rel_hdr.sh_size = relsize;
+	  elfsec_data->rel_hdr.sh_entsize = sizeof (Elf32_External_Rela);
+	  lx_info->got_rel_hash = bfd_zmalloc (relhash_size);
+	}
+    }
+
+  /* Allocate the FPTR entries.  */
+
+  if (lx_info->fptr_sec)
+    {
+      data.ofs = 0;
+      elf_lx_dyn_sym_traverse (lx_info, allocate_fptr, &data);
+      lx_info->fptr_sec->size = data.ofs;
+    }
+
+  /* Now that we've seen all of the input files, we can decide which
+     symbols need plt entries.  Allocate the minimal PLT entries first.
+     We do this even though dynamic_sections_created may be FALSE, because
+     this has the side-effect of clearing want_plt and want_plt2.  */
+
+  data.ofs = 0;
+  elf_lx_dyn_sym_traverse (lx_info, allocate_plt_entries, &data);
+
+  lx_info->minplt_entries = 0;
+  if (data.ofs)
+    {
+      lx_info->minplt_entries
+	= (data.ofs - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
+    }
+
+  /* Align the pointer for the plt2 entries.  */
+  data.ofs = (data.ofs + 31) & (bfd_vma) -32;
+
+  elf_lx_dyn_sym_traverse (lx_info, allocate_plt2_entries, &data);
+  if (data.ofs != 0)
+    {
+      BFD_ASSERT (lx_info->root.dynamic_sections_created);
+
+      lx_info->plt_sec->size = data.ofs;
+
+      /* If we've got a .plt, we need some extra memory for the dynamic
+	 linker.  We stuff these in .got.plt.  */
+      sec = bfd_get_section_by_name (dynobj, ".got.plt");
+      sec->size = 4 * PLT_RESERVED_WORDS;
+    }
+
+  /* Allocate the PLTOFF entries.  */
+
+  if (lx_info->pltoff_sec)
+    {
+      if (pic_abi_p (output_bfd))
+	data.ofs = 0;
+      else
+	/* In the embedded ABI, the PLTOFF entries go in .got.plt.
+           Remember the start of .got.plt is reserved.
+	*/
+	data.ofs = lx_info->pltoff_sec->size;
+      elf_lx_dyn_sym_traverse (lx_info, allocate_pltoff_entries, &data);
+      lx_info->pltoff_sec->size = data.ofs;
+    }
+
+  if (lx_info->root.dynamic_sections_created)
+    {
+      /* Allocate space for the dynamic relocations that turned out to be
+	 required.  */
+
+      if (info->shared && lx_info->self_dtpldm_offset != (bfd_vma) -1)
+	lx_info->rel_got_sec->size += 2 * sizeof (Elf32_External_Rela);
+      elf_lx_dyn_sym_traverse (lx_info, allocate_dynrel_entries, &data);
+    }
+
+  /* We have now determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  for (sec = dynobj->sections; sec != NULL; sec = sec->next)
+    {
+      bfd_boolean strip;
+
+      if (!(sec->flags & SEC_LINKER_CREATED))
+	continue;
+
+      /* If we don't need this section, strip it from the output file.
+	 There were several sections primarily related to dynamic
+	 linking that must be create before the linker maps input
+	 sections to output sections.  The linker does that before
+	 bfd_elf_size_dynamic_sections is called, and it is that
+	 function which decides whether anything needs to go into
+	 these sections.  */
+
+      strip = (sec->size == 0);
+
+      if (sec == lx_info->got_sec)
+	strip = FALSE;
+      else if (sec == lx_info->rel_got_sec)
+	{
+	  if (strip)
+	    lx_info->rel_got_sec = NULL;
+	  else
+	    /* We use the reloc_count field as a counter if we need to
+	       copy relocs into the output file.  */
+	    sec->reloc_count = 0;
+	}
+      else if (sec == lx_info->fptr_sec)
+	{
+	  if (strip)
+	    lx_info->fptr_sec = NULL;
+	}
+      else if (sec == lx_info->plt_sec)
+	{
+	  if (strip)
+	    lx_info->plt_sec = NULL;
+	}
+      else if (sec == lx_info->pltoff_sec)
+	{
+	  if (strip)
+	    lx_info->pltoff_sec = NULL;
+	}
+      else if (sec == lx_info->rel_pltoff_sec)
+	{
+	  if (strip)
+	    lx_info->rel_pltoff_sec = NULL;
+	  else
+	    {
+	      relplt = TRUE;
+	      /* We use the reloc_count field as a counter if we need to
+		 copy relocs into the output file.  */
+	      sec->reloc_count = 0;
+	    }
+	}
+      else
+	{
+	  const char *name;
+
+	  /* It's OK to base decisions on the section name, because none
+	     of the dynobj section names depend upon the input files.  */
+	  name = bfd_get_section_name (dynobj, sec);
+
+	  if (strcmp (name, ".got.plt") == 0)
+	    strip = FALSE;
+	  else if (strncmp (name, ".rel", 4) == 0)
+	    {
+	      if (!strip)
+		{
+		  /* We use the reloc_count field as a counter if we need to
+		     copy relocs into the output file.  */
+		  sec->reloc_count = 0;
+		}
+	    }
+	  else
+	    continue;
+	}
+
+      if (strip)
+	sec->flags |= SEC_EXCLUDE;
+      else
+	{
+	  /* Allocate memory for the section contents.  */
+	  sec->contents = (bfd_byte *) bfd_zalloc (dynobj, sec->size);
+	  if (sec->contents == NULL && sec->size != 0)
+	    return FALSE;
+	}
+    }
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the values
+	 later (in finish_dynamic_sections) but we must add the entries now
+	 so that we get the correct size for the .dynamic section.  */
+
+      if (!info->shared)
+	{
+	  /* The DT_DEBUG entry is filled in by the dynamic linker and used
+	     by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
+
+	  if (!add_dynamic_entry (DT_DEBUG, 0))
+	    return FALSE;
+	}
+
+      if (!add_dynamic_entry (DT_PLTGOT, 0))
+	return FALSE;
+
+      if (relplt)
+	{
+	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
+	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
+	      || !add_dynamic_entry (DT_JMPREL, 0))
+	    return FALSE;
+	}
+
+      if (!add_dynamic_entry (DT_RELA, 0)
+	  || !add_dynamic_entry (DT_RELASZ, 0)
+	  || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
+	return FALSE;
+
+      if (lx_info->reltext)
+	{
+	  if (!add_dynamic_entry (DT_TEXTREL, 0))
+	    return FALSE;
+	  info->flags |= DF_TEXTREL;
+	}
+    }
+
+  return TRUE;
+}
+
+static void
+elf_lx_install_dyn_reloc (abfd, info, sec, srel, offset, type,
+			  dynindx, addend)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     asection *sec;
+     asection *srel;
+     bfd_vma offset;
+     unsigned int type;
+     long dynindx;
+     bfd_vma addend;
+{
+  Elf_Internal_Rela outrel;
+
+  offset += sec->output_section->vma + sec->output_offset;
+
+  BFD_ASSERT (dynindx != -1);
+  outrel.r_info = ELF32_R_INFO (dynindx, type);
+  outrel.r_addend = addend;
+  outrel.r_offset = _bfd_elf_section_offset (abfd, info, sec, offset);
+  if ((outrel.r_offset | 1) == (bfd_vma) -1)
+    {
+      /* Run for the hills.  We shouldn't be outputting a relocation
+	 for this.  So do what everyone else does and output a no-op.  */
+      outrel.r_info = ELF32_R_INFO (0, R_LX_NONE);
+      outrel.r_addend = 0;
+      outrel.r_offset = 0;
+    }
+
+  bfd_elf32_swap_reloca_out (abfd, &outrel,
+			     (bfd_byte *) (((Elf32_External_Rela *) 
+					    srel->contents)
+					   + srel->reloc_count++));
+  BFD_ASSERT ((srel->size > 0 
+	       && (sizeof (Elf32_External_Rela) * srel->reloc_count
+		   <= srel->size)));
+}
+
+static void
+elf_lx_install_got_static_reloc (struct bfd_link_info *info,
+				 bfd_vma got_offset, struct elf_link_hash_entry *h,
+				 unsigned int r_type,
+				 bfd_vma addend, bfd_vma value)
+{
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+  asection *got_sec = lx_info->got_sec;
+  struct bfd_elf_section_data *elfsec_data = elf_section_data (got_sec);
+  unsigned int reloc_number = elfsec_data->rel_count++;
+  unsigned long symndx = STN_UNDEF;
+
+  Elf_Internal_Rela *rel = elfsec_data->relocs + reloc_number;
+  bfd_vma offset = got_offset + got_sec->output_section->vma + got_sec->output_offset;
+
+  if (h)
+    lx_info->got_rel_hash[reloc_number] = h;
+  else
+    {
+      /* For a local symbol, we do not know the symbol table index (it may not even
+	 have one), so we put the full value in the addend, and set the
+	 symbol index to undef.
+	 We could probably do better, by setting it relative to the section symbol of
+	 the output section that contains it. */
+      addend += value;
+    }
+  rel->r_info = ELF32_R_INFO (symndx, r_type);
+  rel->r_addend = addend;
+  rel->r_offset = offset;
+}
+
+/* Store an entry for target address DYN_I + ADDEND in the global offset
+   table and return the address of the linkage table entry.  */
+
+static bfd_vma
+set_got_entry (abfd, info, dyn_i, dynindx, addend, value, dyn_r_type)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     long dynindx;
+     bfd_vma addend;
+     bfd_vma value;
+     unsigned int dyn_r_type;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *got_sec;
+  bfd_boolean done;
+  bfd_vma got_offset;
+  bfd_vma value2 = 0;
+  bfd_boolean put_value2 = FALSE;
+
+  lx_info = elf_lx_hash_table (info);
+  got_sec = lx_info->got_sec;
+
+  switch (dyn_r_type)
+    {
+    case R_LX_TPREL32:
+      done = dyn_i->tprel_done;
+      dyn_i->tprel_done = TRUE;
+      got_offset = dyn_i->tprel_offset;
+      break;
+    case R_LX_GOTOFF_DTPLDM_LO9:
+      /* We want a ldm ti_index structure in the GOT */
+      if (dyn_i->dtpldm_offset != lx_info->self_dtpldm_offset)
+	{
+	  done = dyn_i->dtpldm_done;
+	  dyn_i->dtpldm_done = TRUE;
+	}
+      else
+	{
+	  done = lx_info->self_dtpldm_done;
+	  lx_info->self_dtpldm_done = TRUE;
+	  dynindx = 0;
+	}
+      got_offset = dyn_i->dtpldm_offset;
+      dyn_r_type = R_LX_DTPMOD32;
+      break;
+    case R_LX_GOTOFF_DTPNDX_LO9:
+      /* We want an ndx ti_index structure in the GOT */
+      done = dyn_i->dtpndx_done;
+      dyn_i->dtpndx_done = TRUE;
+      got_offset = dyn_i->dtpndx_offset;
+      value2 = value;
+      if (! info->shared && ! elf_lx_dynamic_symbol_p (dyn_i->h, info))
+	value = 1;
+      else
+	value = 0;
+      put_value2 = TRUE;
+      break;
+    default:
+      done = dyn_i->got_done;
+      dyn_i->got_done = TRUE;
+      got_offset = dyn_i->got_offset;
+      break;
+    }
+
+  BFD_ASSERT ((got_offset & 3) == 0);
+
+  if (! done)
+    {
+      unsigned int static_r_type = dyn_r_type;
+      bfd_vma static_addend = addend;
+      bfd_boolean dyn_needed;
+
+      /* Store the target address in the global offset table entry.  */
+      bfd_put_32 (abfd, value, got_sec->contents + got_offset);
+      if (put_value2)
+	bfd_put_32 (abfd, value2, got_sec->contents + got_offset + 4);
+
+      dyn_needed = (info->shared
+		    || elf_lx_dynamic_symbol_p (dyn_i->h, info)
+		    || (dynindx != -1 && dyn_r_type == R_LX_FPTR32));
+
+      /* Install a dynamic relocation if needed.  */
+      if (dynindx == -1
+	  && dyn_r_type != R_LX_TPREL32
+	  && dyn_r_type != R_LX_DTPMOD32
+	  && dyn_r_type != R_LX_GOTOFF_DTPNDX_LO9)
+	{
+	  dyn_r_type = R_LX_REL32;
+	  dynindx = 0;
+	  addend = value;
+	}
+
+      if (dyn_r_type == R_LX_GOTOFF_DTPNDX_LO9)
+	{
+	  /* Create an ndx ti_index structure in the GOT */
+	  if (dyn_needed)
+	    elf_lx_install_dyn_reloc (abfd, NULL, got_sec,
+				      lx_info->rel_got_sec,
+				      got_offset, R_LX_DTPMOD32,
+				      dynindx, addend);
+	  if (info->emitrelocations)
+	    elf_lx_install_got_static_reloc (info, got_offset,
+					     dyn_i->h, R_LX_DTPMOD32,
+					     static_addend, value);
+	  
+	  if (dynindx != 0)
+	    {
+	      if (dyn_needed)
+		elf_lx_install_dyn_reloc (abfd, NULL, got_sec,
+					  lx_info->rel_got_sec,
+					  got_offset + 4, R_LX_DTPREL32,
+					  dynindx, addend);
+	      if (info->emitrelocations)
+		elf_lx_install_got_static_reloc (info, got_offset + 4,
+						 dyn_i->h, R_LX_DTPREL32,
+						 static_addend, value2);
+	    }
+	}
+      else
+	{
+	  if (dyn_needed)
+	    elf_lx_install_dyn_reloc (abfd, NULL, got_sec,
+				      lx_info->rel_got_sec,
+				      got_offset, dyn_r_type,
+				      dynindx, addend);
+	  if (info->emitrelocations)
+	    elf_lx_install_got_static_reloc (info, got_offset, dyn_i->h,
+					     static_r_type, static_addend,
+					     value);
+	}
+    }
+  
+  /* Return the address of the global offset table entry.  */
+  value = (got_sec->output_section->vma
+	   + got_sec->output_offset
+	   + got_offset);
+
+  return value;
+}
+
+/* Fill in a function descriptor consisting of the function's code
+   address and its global pointer.  Return the descriptor's address.  */
+
+static bfd_vma
+set_fptr_entry (abfd, info, dyn_i, value)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     bfd_vma value;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *fptr_sec;
+
+  lx_info = elf_lx_hash_table (info);
+  fptr_sec = lx_info->fptr_sec;
+
+  if (!dyn_i->fptr_done)
+    {
+      dyn_i->fptr_done = 1;
+
+      /* Fill in the function descriptor.  */
+      bfd_put_32 (abfd, value, fptr_sec->contents + dyn_i->fptr_offset);
+      bfd_put_32 (abfd, _bfd_get_gp_value (abfd),
+		  fptr_sec->contents + dyn_i->fptr_offset + 4);
+    }
+
+  /* Return the descriptor's address.  */
+  value = (fptr_sec->output_section->vma
+	   + fptr_sec->output_offset
+	   + dyn_i->fptr_offset);
+
+  return value;
+}
+
+/* Fill in a PLTOFF entry consisting of the function's code address
+   and its global pointer.  Return the descriptor's address.  */
+
+static bfd_vma
+set_pltoff_entry (abfd, info, dyn_i, value, is_plt)
+     bfd *abfd;
+     struct bfd_link_info *info;
+     struct elf_lx_dyn_sym_info *dyn_i;
+     bfd_vma value;
+     bfd_boolean is_plt;
+{
+  struct elf_lx_link_hash_table *lx_info;
+  asection *pltoff_sec;
+
+  lx_info = elf_lx_hash_table (info);
+  pltoff_sec = lx_info->pltoff_sec;
+
+  /* Don't do anything if this symbol uses a real PLT entry.  In
+     that case, we'll fill this in during finish_dynamic_symbol.  */
+  if ((! dyn_i->want_plt || is_plt)
+      && !dyn_i->pltoff_done)
+    {
+      bfd_vma gp = _bfd_get_gp_value (abfd);
+
+      /* Fill in the function descriptor.  */
+      bfd_put_32 (abfd, value, pltoff_sec->contents + dyn_i->pltoff_offset);
+      if (pic_abi_p (abfd))
+	bfd_put_32 (abfd, gp, pltoff_sec->contents + dyn_i->pltoff_offset + 4);
+
+      /* Install dynamic relocations if needed.  */
+      if (!is_plt && info->shared)
+	{
+	  elf_lx_install_dyn_reloc (abfd, NULL, pltoff_sec,
+				    lx_info->rel_pltoff_sec,
+				    dyn_i->pltoff_offset,
+				    R_LX_REL32, 0, value);
+	  if (pic_abi_p (abfd))
+	    elf_lx_install_dyn_reloc (abfd, NULL, pltoff_sec,
+				      lx_info->rel_pltoff_sec,
+				      dyn_i->pltoff_offset + 4,
+				      R_LX_REL32, 0, gp);
+	}
+
+      dyn_i->pltoff_done = 1;
+    }
+
+  /* Return the descriptor's address.  */
+  value = (pltoff_sec->output_section->vma
+	   + pltoff_sec->output_offset
+	   + dyn_i->pltoff_offset);
+
+  return value;
+}
+
+/* Return the base VMA address which should be subtracted from real addresses
+   when resolving @tprel() relocation.
+   Main program TLS (whose template starts at PT_TLS p_vaddr)
+   is assigned offset round(16, PT_TLS p_align).  */
+
+static bfd_vma
+elf_lx_tprel_base (info)
+     struct bfd_link_info *info;
+{
+  asection *tls_sec = elf_hash_table (info)->tls_sec;
+
+  if (tls_sec == NULL)
+    return 0;
+  return (tls_sec->vma - align_power ((bfd_vma) 16, tls_sec->alignment_power));
+}
+
+/* Return the base VMA address which should be subtracted from real addresses
+   when resolving @dtprel() relocation.
+   This is PT_TLS segment p_vaddr.  */
+
+static bfd_vma
+elf_lx_dtprel_base (info)
+     struct bfd_link_info *info;
+{
+  asection *tls_sec = elf_hash_table (info)->tls_sec;
+  
+  if (tls_sec == NULL)
+    return 0;
+  return tls_sec->vma;
+}
+
+/* Called after we have determined section placement.  If sections
+   move, we'll be called again.  Provide a value for GP.  */
+
+bfd_boolean
+elf_lx_set_gp (output_bfd, info)
+     bfd *output_bfd;
+     struct bfd_link_info *info;
+{
+  /* Decide where gp should point.
+     We point it at the .got section if that exists,
+     otherwise at the lowest addressed data section. */
+  bfd_vma gp_val;
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+
+  asection *got_sec = lx_info->got_sec;
+  if (got_sec)
+    gp_val = got_sec->output_section->vma;
+  else
+    {
+      bfd_vma min_vma = (bfd_vma) -1;
+      asection *os;
+      
+      for (os = output_bfd->sections; os ; os = os->next)
+	{
+	  if ((os->flags & (SEC_ALLOC | SEC_DATA))
+	      == (SEC_ALLOC | SEC_DATA)
+	      && os->size > 0)
+	    {
+	      if (os->vma < min_vma)
+		min_vma = os->vma;
+	    }
+	}
+      gp_val = min_vma;
+    }
+  _bfd_set_gp_value (output_bfd, gp_val);
+  return TRUE;
+}
+
+static void
+transform_tls_relocs (bfd *abfd,
+		      struct bfd_link_info *info, 
+		      Elf_Internal_Rela *relstart,
+		      Elf_Internal_Rela *relend,
+		      bfd_byte *contents)
+{
+  Elf_Internal_Rela *rel;
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_link_hash_entry *tls_get_addr;
+
+  if (info->shared)
+    /* No transformations are performed for shared libs */
+    return;
+
+  lx_info = elf_lx_hash_table (info);
+  tls_get_addr = elf_link_hash_lookup (&lx_info->root, "__tls_get_addr",
+				       FALSE, FALSE, TRUE);
+  for (rel = relstart; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      unsigned long r_symndx;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      switch (r_type)
+	{
+	case R_LX_23_PCREL:
+	case R_LX_GOTOFF_DTPLDM_HI23:
+	case R_LX_GOTOFF_DTPLDM_LO9:
+	case R_LX_GOTOFF_DTPNDX_HI23:
+	case R_LX_GOTOFF_DTPNDX_LO9:
+	  {
+	    /* Any one of these could begin a TLS GD/LD sequence. */
+
+	    Elf_Internal_Rela *low_rel = NULL;
+	    Elf_Internal_Rela *high_rel = NULL;
+	    Elf_Internal_Rela *call_rel = NULL;
+	    bfd_vma low_offset = rel->r_offset;
+	    bfd_vma high_offset = rel->r_offset;
+	    bfd_vma offset;
+	    bfd_vma insn;
+	    Elf_Internal_Rela *rel2;
+	    struct elf_link_hash_entry *h = NULL;
+	    struct elf_link_hash_entry *call_h = NULL;
+
+	    for (rel2 = rel; rel2 < (rel + 3) && rel2 < relend; rel2++)
+	      {
+		unsigned int rel2_type = ELF32_R_TYPE (rel2->r_info);
+		if (rel2_type == R_LX_23_PCREL)
+		  {
+		    call_rel = rel2;
+		    call_h = symbol_for_relax (abfd, ELF32_R_SYM (rel2->r_info));
+		  }
+		else if (rel2_type == R_LX_GOTOFF_DTPLDM_LO9
+			 || rel2_type == R_LX_GOTOFF_DTPNDX_LO9)
+		  {
+		    low_rel = rel2;
+		    r_symndx = ELF32_R_SYM (rel2->r_info);
+		    h = symbol_for_relax (abfd, r_symndx);
+		  }
+		else if (rel2_type == R_LX_GOTOFF_DTPLDM_HI23
+			 || rel2_type == R_LX_GOTOFF_DTPNDX_HI23)
+		  high_rel = rel2;
+		if (rel2->r_offset < low_offset)
+		  low_offset = rel2->r_offset;
+		else if (rel2->r_offset > high_offset)
+		  high_offset = rel2->r_offset;
+	      }
+	    if (! (low_rel && high_rel && call_rel)
+		|| ! non_preemptible_def_p (h, info)
+		|| ! reloc_matching_pair (abfd, high_rel, low_rel, contents)
+		|| ! INSN_IS_ADDI_R16_P(bfd_get_32 (abfd, contents + low_rel->r_offset))
+		|| ! INSN_IS_CALL_P (bfd_get_32 (abfd, contents + call_rel->r_offset))
+		|| call_h != tls_get_addr)
+	      continue;
+
+	    /* As a final check, all these operations must be in the same
+	       bundle. */
+	    for (offset = low_offset; offset < high_offset; offset += 4)
+	      {
+		insn = bfd_get_32 (abfd, contents + offset);
+		if (INSN_IS_BUNDLE_END_P (insn))
+		  break;
+	      }
+	    if (offset < high_offset)
+	      /* There is a bundle terminator separating the relocations */
+	      continue;
+
+	    /* Transformation GD/LD => LE */
+	    if (ELF32_R_TYPE (low_rel->r_info) == R_LX_GOTOFF_DTPLDM_LO9)
+	      {
+		/* Transforming LD to LE, so we want TPREL of module
+		   containing sym (i.e. main program), not TPREL of sym. */
+		r_symndx = 0;
+		low_rel->r_addend += elf_lx_dtprel_base (info);
+		high_rel->r_addend += elf_lx_dtprel_base (info);
+	      }
+
+	    low_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_LO9);
+	    insn = bfd_get_32 (abfd, contents + low_rel->r_offset);
+	    insn = (insn & ~0x3f) | 0x0d;
+	    bfd_put_32 (abfd, insn, contents + low_rel->r_offset);
+
+	    high_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_HI23);
+
+	    call_rel->r_info = ELF32_R_INFO (0, R_LX_NONE);
+	    insn = bfd_get_32 (abfd, contents + call_rel->r_offset);
+	    insn = (insn & 0x80000000) | 0;
+	    bfd_put_32 (abfd, insn, contents + call_rel->r_offset);
+	  }
+	  break;
+	case R_LX_GOTOFF_TPREL_LO9:
+	case R_LX_GOTOFF_TPREL_HI23:
+	  {
+	    /* These could begin a TLS IE sequence. */
+
+	    Elf_Internal_Rela *low_rel;
+	    Elf_Internal_Rela *high_rel;
+	    struct elf_link_hash_entry *h;
+	    bfd_vma insn;
+
+	    h = symbol_for_relax (abfd, r_symndx);
+
+	    if (rel == relend - 1
+		|| ! reloc_matching_pair (abfd, rel, rel + 1, contents)
+		|| ! non_preemptible_def_p (h, info))
+	      continue;
+
+	    if (r_type == R_LX_GOTOFF_TPREL_LO9)
+	      {
+		low_rel = rel;
+		high_rel = rel + 1;
+	      }
+	    else
+	      {
+		high_rel = rel;
+		low_rel = rel + 1;
+	      }
+	    if (! INSN_IS_LDW_OR_LDWD_P (abfd,
+					 bfd_get_32 (abfd, contents + low_rel->r_offset)))
+	      continue;
+
+	    /* Transformation IE => LE */
+	    low_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_LO9);
+	    insn = bfd_get_32 (abfd, contents + low_rel->r_offset);
+	    /* Rewrite ldw[.d] to be add */
+	    insn = LDW_TO_ADD (insn);
+	    /* Rewrite base register as r0 */
+	    insn &= 0xffffffc0;
+
+	    bfd_put_32 (abfd, insn, contents + low_rel->r_offset);
+
+	    high_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_TPREL_HI23);
+	  }
+	  break;
+	}
+    }
+}
+
+static bfd_boolean 
+elf_lx_relocate_section (
+                 bfd *output_bfd, struct bfd_link_info *info, bfd *input_bfd, 
+                 asection *input_section, bfd_byte *contents, 
+                 Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms, 
+                 asection **local_sections)
+{
+  struct elf_lx_link_hash_table *lx_info;
+  Elf_Internal_Shdr *symtab_hdr;
+  /*   struct elf_link_hash_entry **sym_hashes; ??? worry about this */
+  Elf_Internal_Rela *rel, *relend;
+  asection *srel;
+  bfd_boolean ret_val = TRUE; /* for non-fatal errors */
+  bfd_vma gp_val;
+  struct elf_link_hash_entry **rel_hash;
+  asection *output_section;
+
+  /* sym_hashes = elf_sym_hashes (input_bfd); */
+  lx_info = elf_lx_hash_table (info);
+
+  /* Don't relocate stub sections.  */
+  if (input_section->owner == lx_info->stub_bfd)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+
+  gp_val = _bfd_get_gp_value (output_bfd);
+  srel = get_reloc_section (input_bfd, lx_info, input_section, FALSE);
+  rel = relocs;
+  relend = relocs + input_section->reloc_count;
+
+  output_section = input_section->output_section;
+  rel_hash = (elf_section_data (output_section)->rel_hashes
+	      + elf_section_data (output_section)->rel_count
+	      + elf_section_data (output_section)->rel_count2);
+
+  transform_tls_relocs (input_bfd, info, rel, relend, contents);
+
+  for (; rel < relend; rel++)
+    {
+      unsigned int r_type;
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      struct elf_link_hash_entry *h;
+      struct elf_lx_dyn_sym_info *dyn_i;
+      bfd_vma value;
+      bfd_reloc_status_type r;
+      asection *sym_sec;
+      bfd_boolean dynamic_symbol_p;
+      bfd_boolean undef_weak_ref;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      if (r_type >= R_LX_max)
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: unknown relocation type %d"),
+	     input_bfd, (int)r_type);
+	  bfd_set_error (bfd_error_bad_value);
+	  ret_val = FALSE;
+	  continue;
+	}
+      howto = elf32_lx_howto_table + r_type;
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      /* A little checking, to catch relocation types
+	 that are not appropriate for the selected ABI. */
+      if (!abi_uses_reloc_p (pic_abi_p (output_bfd), r_type))
+	{
+	  (*_bfd_error_handler)
+	    (_("%B: contains relocation (%d) not appropriate for output ABI"),
+	     input_bfd, (int) r_type);
+	  ret_val = FALSE;
+	  continue;
+	}
+	     
+      /* This is a final link.  */
+      h = NULL;
+      sym = NULL;
+      sym_sec = NULL;
+      undef_weak_ref = FALSE;
+
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  /* Reloc against local symbol.  */
+	  sym = local_syms + r_symndx;
+	  sym_sec = local_sections[r_symndx];
+	  value = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
+	  if (! info->relocatable
+	      && (sym_sec->flags & SEC_MERGE) != 0
+	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
+	      && (sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE))
+ 	    {
+	      struct elf_lx_local_hash_entry *loc_h;
+      
+	      loc_h = get_local_sym_hash (lx_info, input_bfd, rel, FALSE);
+	      if (loc_h && ! loc_h->sec_merge_done)
+		{
+		  struct elf_lx_dyn_sym_info *dynent;
+		  asection *msec;
+
+		  for (dynent = loc_h->info; dynent; dynent = dynent->next)
+		    {
+		      msec = sym_sec;
+		      dynent->addend =
+			_bfd_merged_section_offset (output_bfd, &msec,
+						    elf_section_data (msec)->sec_info,
+						    sym->st_value + dynent->addend);
+		      dynent->addend -= sym->st_value;
+		      dynent->addend += msec->output_section->vma
+					+ msec->output_offset
+					- sym_sec->output_section->vma
+					- sym_sec->output_offset;
+		    }
+		  loc_h->sec_merge_done = 1;
+		}
+	    }
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc;
+	  bfd_boolean warned;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, elf_sym_hashes (input_bfd),
+				   h, sym_sec, value,
+				   unresolved_reloc, warned);
+
+	  if (h->root.type == bfd_link_hash_undefweak)
+	    {
+	      undef_weak_ref = TRUE;
+	      /* (pp) modify default in order to avoid linker overflow */
+	      if (howto->pc_relative)
+		value = (input_section->output_section->vma
+			 + input_section->output_offset);
+	      
+	      else
+		value = 0;
+	    }
+	  else if (warned)
+	    continue;
+	}
+      
+      /* For relocs against symbols from removed linkonce sections,
+	 or sections discarded by a linker script, we just want the
+	 section contents zeroed.  Avoid any special processing.  */
+      if (sym_sec != NULL && elf_discarded_section (sym_sec))
+	{
+	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
+	  rel->r_info = 0;
+	  rel->r_addend = 0;
+	  continue;
+	}
+
+      /* TB: when building a relocatable with pcrel relocs against local
+	 symbol resolved, ignore all reloc except R_LX_23_PCREL against
+	 local symbol*/
+	if (info->relocatable
+	    && (! howto->pc_relative
+		|| r_symndx >= symtab_hdr->sh_info))
+	continue;
+
+      value += rel->r_addend;
+      dynamic_symbol_p = elf_lx_dynamic_symbol_p (h, info);
+
+      switch (r_type)
+	{
+	case R_LX_NONE:
+	  continue;
+
+	case R_LX_HI23:
+	case R_LX_LO9:
+	case R_LX_16:
+	case R_LX_32:
+	case R_LX_DTPMOD32:
+	  /* These require a dynamic relocation if the symbol is
+	     dynamic or we are making a shared library. */
+	  /* clarkes: do not emit a dynamic relocation for an absolute
+	     symbol that is owned by a shared library or relocatable module - if
+	     it is absolute then it should not need relocating.  Note this differs
+	     from standard Linux behaviour for a shared library.  */
+	  if ((dynamic_symbol_p
+	       || ((info->shared || L_RELOCATABLE) && ! bfd_is_abs_section (sym_sec)))
+	      && r_symndx != 0
+	      && (input_section->flags & SEC_ALLOC) != 0
+	      && (h == NULL || ! h->non_got_ref))
+	    {
+	      /* Dynamic relocation required. */
+	      if ((input_section->flags & (SEC_CODE | SEC_READONLY)) != 0)
+		{
+		  (*_bfd_error_handler)
+		    (_("%B: dynamic relocation of non-writeable section required (reference to %s)"),
+		     input_bfd, (h != NULL) ? h->root.root.string : "local symbol");
+		  ret_val = FALSE;
+		  continue;
+		}
+	      else
+		{
+		  unsigned int dyn_r_type = r_type;
+		  long dynindx = 0;
+		  bfd_vma addend = 0;
+
+		  if (dynamic_symbol_p)
+		    {
+		      dynindx = h->dynindx;
+		      addend = rel->r_addend;
+		      value = 0;
+		    }
+		  else
+		    {
+		      switch (r_type)
+			{
+			case R_LX_32:
+			  dyn_r_type = R_LX_REL32;
+			  break;
+			case R_LX_DTPMOD32:
+			  value = 0;
+			  break;
+			default:
+			  /* We can't represent this without a dynamic symbol. */
+			  (*_bfd_error_handler)
+			    (_("%B: linking non-pic code in a shared library"),
+			     input_bfd);
+			  ret_val = FALSE;
+			  continue;
+			}
+		      addend = value;
+		    }
+
+		  elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					    srel, rel->r_offset, dyn_r_type,
+					    dynindx, addend);
+		}
+	      value = 0;
+	    }
+	  else if (r_type == R_LX_DTPMOD32)
+	    value = 1; /* Main program module number */
+	  goto default_reloc;
+
+	case R_LX_GPREL_HI23:
+	case R_LX_GPREL_LO9:
+	case R_LX_NEG_GPREL_HI23:
+	case R_LX_NEG_GPREL_LO9:
+	  if ((lx_info->transform_to_absolute
+               || bfd_is_abs_section (sym_sec))
+	      && ! info->shared
+	      && (r_type == R_LX_GPREL_HI23
+		  || r_type == R_LX_GPREL_LO9))
+	    {
+	      /* Convert the GP-relative instruction to absolute by
+		 rewriting the base register.
+	      */
+	      if (rel < (relend - 1)
+		  && reloc_matching_pair (output_bfd, rel, rel + 1, contents))
+		{
+		  /* Handle this relocation and the next one together. */
+
+		  Elf_Internal_Rela *low_rel;
+		  Elf_Internal_Rela *high_rel;
+		  bfd_vma insn;
+
+		  if (r_type == R_LX_GPREL_LO9)
+		    {
+		      low_rel = rel;
+		      high_rel = rel + 1;
+		    }
+		  else
+		    {
+		      low_rel = rel + 1;
+		      high_rel = rel;
+		    }
+		  insn = bfd_get_32 (input_bfd, contents + low_rel->r_offset);
+		  if ((insn & 0x3f) != 0)
+		    { /* Do the transformation. */
+		      insn &= 0xffffffc0; /* Rewrite base register to be r0. */
+		      bfd_put_32 (input_bfd, insn, contents + low_rel->r_offset);
+		      low_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_LO9);
+		      high_rel->r_info = ELF32_R_INFO (r_symndx, R_LX_HI23);
+#if 0
+		      (*_bfd_error_handler)
+			(_("%s: information: converting @gprel to absolute for %s"),
+			 bfd_get_filename (output_bfd),
+			 (h != NULL) ? h->root.root.string : "local symbol");
+#endif
+		    }
+		  else
+		    value -= gp_val;
+		  r = _bfd_final_link_relocate (elf32_lx_howto_table
+						+ ELF32_R_TYPE (low_rel->r_info),
+						input_bfd, input_section, contents,
+						low_rel->r_offset, value, 0);
+		  if (r == bfd_reloc_ok)
+		    {
+		      r = _bfd_final_link_relocate (elf32_lx_howto_table
+						    + ELF32_R_TYPE (high_rel->r_info),
+						    input_bfd, input_section, contents,
+						    high_rel->r_offset, value, 0);
+		    }
+		  rel++; /* We have processed the next rel */
+		  break;
+		}
+	    }
+	  if (dynamic_symbol_p)
+	    {
+	      (*_bfd_error_handler)
+		(_("%B: @gprel relocation against dynamic symbol %s"),
+		 input_bfd, h->root.root.string);
+	      ret_val = FALSE;
+	      continue;
+	    }
+	  value -= gp_val;
+	  if (r_type == R_LX_NEG_GPREL_HI23 || r_type == R_LX_NEG_GPREL_LO9)
+	    value = -value;
+	  goto default_reloc;
+
+	case R_LX_GOTOFF_HI23:
+	case R_LX_GOTOFF_LO9:
+	case R_LX_GOTOFFX_HI23:
+	case R_LX_GOTOFFX_LO9:
+	  dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	  value = set_got_entry (input_bfd, info, dyn_i, (h ? h->dynindx : -1),
+				 rel->r_addend, value, R_LX_32);
+	  if (lx_info->transform_to_absolute
+	      && ! info->shared)
+	    {
+	      /* Convert the GP-relative instruction to absolute by
+		 rewriting the base register.
+	      */
+	      if (rel < (relend - 1)
+		  && reloc_matching_pair (output_bfd, rel, rel + 1, contents))
+		{
+		  /* Handle this relocation and the next one together. */
+		  Elf_Internal_Rela *low_rel;
+		  Elf_Internal_Rela *high_rel;
+		  bfd_vma insn;
+
+		  if (r_type == R_LX_GOTOFF_LO9
+		      || r_type == R_LX_GOTOFFX_LO9)
+		    {
+		      low_rel = rel;
+		      high_rel = rel + 1;
+		    }
+		  else
+		    {
+		      low_rel = rel + 1;
+		      high_rel = rel;
+		    }
+		  insn = bfd_get_32 (input_bfd, contents + low_rel->r_offset);
+		  if ((insn & 0x3f) != 0)
+		    { /* Do the transformation. */
+
+		      insn &= 0xffffffc0; /* Rewrite base register to be r0 */
+		      bfd_put_32 (input_bfd, insn, contents + low_rel->r_offset);
+		      if (info->emitrelocations)
+			{
+			  struct elf_link_hash_entry *hgot = elf_hash_table(info)->hgot;
+			  bfd_vma hgot_value = hgot->root.u.def.value
+			    + hgot->root.u.def.section->output_section->vma
+			    + hgot->root.u.def.section->output_offset;
+
+			  low_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_LO9);
+			  low_rel->r_addend = value - hgot_value;
+			  rel_hash[low_rel - relocs] = hgot;
+			  high_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_HI23);
+			  high_rel->r_addend = value - hgot_value;
+			  rel_hash[high_rel - relocs] = hgot;
+			}
+		    }
+		  else
+		    value -= gp_val;
+		  r = _bfd_final_link_relocate (elf32_lx_howto_table
+						+ ELF32_R_TYPE (low_rel->r_info),
+						input_bfd, input_section, contents,
+						low_rel->r_offset, value, 0);
+		  if (r == bfd_reloc_ok)
+		    {
+		      r = _bfd_final_link_relocate (elf32_lx_howto_table
+						    + ELF32_R_TYPE (high_rel->r_info),
+						    input_bfd, input_section, contents,
+						    high_rel->r_offset, value, 0);
+		    }
+		  rel++; /* We have processed the next rel */
+		  break;
+		}
+	    }
+	  value -= gp_val;
+	  goto default_reloc;
+
+	case R_LX_PLTOFF_HI23:
+	case R_LX_PLTOFF_LO9:
+          dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	  value = set_pltoff_entry (output_bfd, info, dyn_i, value, FALSE);
+	  value -= gp_val;
+	  goto default_reloc;
+
+	case R_LX_FPTR32:
+          dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	  if (dyn_i->want_fptr)
+	    {
+	      if (!undef_weak_ref)
+		value = set_fptr_entry (output_bfd, info, dyn_i, value);
+	    }
+	  else
+	    {
+	      long dynindx;
+
+	      /* Otherwise, we expect the dynamic linker to create
+		 the entry.  */
+
+	      if (h)
+		{
+		  if (h->dynindx != -1)
+		    dynindx = h->dynindx;
+		  else
+		    dynindx = (_bfd_elf_link_lookup_local_dynindx
+			       (info, h->root.u.def.section->owner,
+				global_sym_index (h)));
+		}
+	      else
+		{
+		  dynindx = (_bfd_elf_link_lookup_local_dynindx
+			     (info, input_bfd, (long) r_symndx));
+		}
+
+	      elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					srel, rel->r_offset, r_type,
+					dynindx, rel->r_addend);
+	      value = 0;
+	    }
+
+	  goto default_reloc;
+
+	case R_LX_GOTOFF_FPTR_HI23:
+	case R_LX_GOTOFF_FPTR_LO9:
+	  {
+	    long dynindx;
+
+	    dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	    if (dyn_i->want_fptr)
+	      {
+		BFD_ASSERT (h == NULL || h->dynindx == -1);
+	        if (!undef_weak_ref)
+	          value = set_fptr_entry (output_bfd, info, dyn_i, value);
+		dynindx = -1;
+	      }
+	    else
+	      {
+	        /* Otherwise, we expect the dynamic linker to create
+		   the entry.  */
+	        if (h)
+		  {
+		    if (h->dynindx != -1)
+		      dynindx = h->dynindx;
+		    else
+		      dynindx = (_bfd_elf_link_lookup_local_dynindx
+				 (info, h->root.u.def.section->owner,
+				  global_sym_index (h)));
+		  }
+		else
+		  dynindx = (_bfd_elf_link_lookup_local_dynindx
+			     (info, input_bfd, (long) r_symndx));
+		value = 0;
+	      }
+
+	    value = set_got_entry (output_bfd, info, dyn_i, dynindx,
+				   rel->r_addend, value, R_LX_FPTR32);
+	    value -= gp_val;
+	  }
+	  goto default_reloc;
+
+	case R_LX_32_PCREL:
+	  /* Install a dynamic relocation for this reloc.  */
+	  if (dynamic_symbol_p && r_symndx != 0)
+	    {
+	      BFD_ASSERT (srel != NULL);
+
+	      elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					srel, rel->r_offset, r_type,
+					h->dynindx, rel->r_addend);
+	    }
+	  goto default_reloc;
+
+	case R_LX_23_PCREL:
+	  /* We should have created a PLT entry for any dynamic symbol.  */
+	  dyn_i = NULL;
+	  if (h)
+	    dyn_i = get_dyn_sym_info (lx_info, h, NULL, NULL, FALSE);
+
+	  if (dyn_i && dyn_i->want_plt2)
+	    {
+	      /* Should have caught this earlier.  */
+	      BFD_ASSERT (rel->r_addend == 0);
+
+	      value = (lx_info->plt_sec->output_section->vma
+		       + lx_info->plt_sec->output_offset
+		       + dyn_i->plt2_offset);
+	    }
+	  else
+	    {
+	      bfd_vma from;
+	      bfd_signed_vma branch_offset;
+
+	      /* Since there's no PLT entry, Validate that this is
+		 locally defined.  */
+	      BFD_ASSERT (undef_weak_ref || sym_sec->output_section != NULL);
+
+	      /* If the symbol is undef_weak, we shouldn't be trying
+		 to call it.  There's every chance that we'd wind up
+		 with an out-of-range fixup here.  Don't bother setting
+		 any value at all.  */
+	      if (undef_weak_ref)
+		continue;
+
+	      from = (input_section->output_section->vma
+		      + input_section->output_offset
+		      + rel->r_offset);
+	      branch_offset = (bfd_signed_vma)(value - from);
+	      if (branch_offset > MAX_FWD_BRANCH_OFFSET
+		  || branch_offset < MAX_BWD_BRANCH_OFFSET)
+		{
+		  /* The target is out of reach, so redirect the
+		     branch to the local stub for this function.
+		  */
+		  struct elf_lx_stub_hash_entry *stub_entry;
+
+		  stub_entry = lx_get_stub_entry (input_section, sym_sec, h,
+						  rel, lx_info);
+		  if (stub_entry != NULL)
+		    {
+		      value = (stub_entry->stub_offset
+			       + stub_entry->stub_sec->output_offset
+			       + stub_entry->stub_sec->output_section->vma);
+		      if (info->emitrelocations)
+			{
+			  /* Simpler version where we put the stub symbol in
+			     rel_hashes, and set the index to STN_UNDEF to prevent
+			     . */
+			  rel_hash[rel - relocs] =
+			    (struct elf_link_hash_entry *)stub_entry->sh;
+
+			  stub_entry->sh->root.indx = -2;
+			  rel->r_info = ELF32_R_INFO(STN_UNDEF, r_type);
+			}
+		    }
+		}
+	    }
+	  goto default_reloc;
+
+	case R_LX_SEGREL32:
+	  {
+	    struct elf_segment_map *m;
+	    Elf_Internal_Phdr *p;
+	    
+	    /* Find the segment that contains the output_section.  */
+	    for (m = elf_tdata (output_bfd)->segment_map,
+		   p = elf_tdata (output_bfd)->phdr;
+		 m != NULL;
+		 m = m->next, p++)
+	      {
+		int i;
+		for (i = m->count - 1; i >= 0; i--)
+		  if (m->sections[i] == sym_sec->output_section)
+		    break;
+		if (i >= 0)
+		  break;
+	      }
+	    
+	    if (m == NULL)
+	      {
+		r = bfd_reloc_notsupported;
+	      }
+	    else
+	      {
+		/* The VMA of the segment is the vaddr of the associated
+		   program header.  */
+		if (value > p->p_vaddr)
+		  value -= p->p_vaddr;
+		else
+		  value = 0;
+		goto default_reloc;
+	      }
+	  }
+	  break;
+
+	case R_LX_IPLT:
+	case R_LX_JMP_SLOT:
+	  /* Install a dynamic relocation for this reloc.  */
+	  if ((dynamic_symbol_p || info->shared)
+	      && (input_section->flags & SEC_ALLOC) != 0)
+	    {
+	      BFD_ASSERT (srel != NULL);
+
+	      /* If we don't need dynamic symbol lookup, install
+		 RELATIVE relocations.  */
+	      if (! dynamic_symbol_p)
+		{
+		  unsigned int dyn_r_type;
+
+		  dyn_r_type = R_LX_REL32;
+
+		  elf_lx_install_dyn_reloc (output_bfd, info,
+					    input_section,
+					    srel, rel->r_offset,
+					    dyn_r_type, 0, value);
+		  if (r_type == R_LX_IPLT)
+		    elf_lx_install_dyn_reloc (output_bfd, info,
+					      input_section,
+					      srel, rel->r_offset + 4,
+					      dyn_r_type, 0, gp_val);
+		}
+	      else
+		elf_lx_install_dyn_reloc (output_bfd, info, input_section,
+					  srel, rel->r_offset, r_type,
+					  h->dynindx, rel->r_addend);
+	    }
+
+	  howto = elf32_lx_howto_table + R_LX_32;
+	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					contents, rel->r_offset, value, 0);
+	  if (r == bfd_reloc_ok && r_type == R_LX_IPLT)
+	    r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					  contents, rel->r_offset + 4, gp_val,
+					  0);
+	  break;
+
+	case R_LX_LTV32:
+	default_reloc:
+	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
+					contents, rel->r_offset, value, 0);
+	  break;
+
+	case R_LX_TPREL_HI23:
+	case R_LX_TPREL_LO9:
+	case R_LX_TPREL32:
+	  value -= elf_lx_tprel_base (info);
+	  goto default_reloc;
+
+	case R_LX_DTPREL_HI23:
+	case R_LX_DTPREL_LO9:
+	case R_LX_DTPREL32:
+	  value -= elf_lx_dtprel_base (info);
+	  goto default_reloc;
+
+	case R_LX_GOTOFF_TPREL_HI23:
+	case R_LX_GOTOFF_TPREL_LO9:
+	case R_LX_GOTOFF_DTPLDM_HI23:
+	case R_LX_GOTOFF_DTPLDM_LO9:
+	case R_LX_GOTOFF_DTPNDX_HI23:
+	case R_LX_GOTOFF_DTPNDX_LO9:
+	  {
+	    int got_r_type;
+	    long dynindx = h ? h->dynindx : -1;
+	    bfd_vma r_addend = rel->r_addend;
+
+	    switch (r_type)
+	      {
+	      default:
+	      case R_LX_GOTOFF_TPREL_HI23:
+	      case R_LX_GOTOFF_TPREL_LO9:
+		if (!dynamic_symbol_p)
+		  {
+		    if (!info->shared)
+		      value -= elf_lx_tprel_base (info);
+		    else
+		      {
+			r_addend += value - elf_lx_dtprel_base (info);
+			dynindx = 0;
+		      }
+		  }
+		got_r_type = R_LX_TPREL32;
+		break;
+	      case R_LX_GOTOFF_DTPLDM_HI23:
+	      case R_LX_GOTOFF_DTPLDM_LO9:
+		if (!dynamic_symbol_p && !info->shared)
+		  value = 1;  /* Main program module number */
+		got_r_type = R_LX_GOTOFF_DTPLDM_LO9;
+		break;
+	      case R_LX_GOTOFF_DTPNDX_HI23:
+	      case R_LX_GOTOFF_DTPNDX_LO9:
+		if (!dynamic_symbol_p)
+		  {
+		    value -= elf_lx_dtprel_base (info);
+		    dynindx = 0;
+		  }
+		got_r_type = R_LX_GOTOFF_DTPNDX_LO9;
+		break;
+	      }
+	    dyn_i = get_dyn_sym_info (lx_info, h, input_bfd, rel, FALSE);
+	    value = set_got_entry (input_bfd, info, dyn_i, dynindx, r_addend,
+				   value, got_r_type);
+
+	    if (lx_info->transform_to_absolute
+		&& ! info->shared)
+	      {
+		/* Convert the GP-relative instruction to absolute by
+		   rewriting the base register.
+		*/
+		if (rel < (relend - 1)
+			 && reloc_matching_pair (output_bfd, rel, rel + 1,
+						 contents))
+		  {
+		    /* Handle this relocation and the next one together. */
+		    Elf_Internal_Rela *low_rel;
+		    Elf_Internal_Rela *high_rel;
+		    bfd_vma insn;
+		    
+
+		    if (r_type == R_LX_GOTOFF_TPREL_LO9
+			|| r_type == R_LX_GOTOFF_DTPLDM_LO9
+			|| r_type == R_LX_GOTOFF_DTPNDX_LO9)
+		      {
+			low_rel = rel;
+			high_rel = rel + 1;
+		      }
+		    else
+		      {
+			low_rel = rel + 1;
+			high_rel = rel;
+		      }
+		    insn = bfd_get_32 (input_bfd, contents + low_rel->r_offset);
+		    if ((insn & 0x3f) != 0)
+		      { /* Do the transformation. */
+			insn &= 0xffffffc0; /* Rewrite base register to be r0 */
+			bfd_put_32 (input_bfd, insn, contents + low_rel->r_offset);
+			if (info->emitrelocations)
+			  {
+			    struct elf_link_hash_entry *hgot = elf_hash_table(info)->hgot;
+			    bfd_vma hgot_value = hgot->root.u.def.value
+			      + hgot->root.u.def.section->output_section->vma
+			      + hgot->root.u.def.section->output_offset;
+
+			    low_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_LO9);
+			    low_rel->r_addend = value - hgot_value;
+			    rel_hash[low_rel - relocs] = hgot;
+			    high_rel->r_info = ELF32_R_INFO(STN_UNDEF, R_LX_HI23);
+			    high_rel->r_addend = value - hgot_value;
+			    rel_hash[high_rel - relocs] = hgot;
+			  }
+		      }
+		    else
+		      value -= gp_val;
+		    r = _bfd_final_link_relocate (elf32_lx_howto_table
+						  + ELF32_R_TYPE (low_rel->r_info),
+						  input_bfd, input_section, contents,
+						  low_rel->r_offset, value, 0);
+		    if (r == bfd_reloc_ok)
+		      {
+			r = _bfd_final_link_relocate (elf32_lx_howto_table
+						      + ELF32_R_TYPE (high_rel->r_info),
+						      input_bfd, input_section, contents,
+						      high_rel->r_offset, value, 0);
+		      }
+		    rel++; /* We have processed the next rel */
+		    break;
+		  }
+	      }
+	    else
+	      value -= gp_val;
+	    goto default_reloc;
+	  }
+
+	default:
+	  r = bfd_reloc_notsupported;
+	  break;
+	}
+
+      switch (r)
+	{
+	case bfd_reloc_ok:
+	  break;
+	  
+	case bfd_reloc_undefined:
+	  /* This can happen for global table relative relocs if
+	     __gp is undefined.  This is a panic situation so we
+	     don't try to continue.  */
+	  (*info->callbacks->undefined_symbol)
+	    (info, "__gp", input_bfd, input_section, rel->r_offset, 1);
+	  return FALSE;
+
+	case bfd_reloc_notsupported:
+	  {
+	    const char *name;
+
+	    if (h)
+	      name = h->root.root.string;
+	    else
+	      {
+		name = bfd_elf_string_from_elf_section (input_bfd,
+							symtab_hdr->sh_link,
+							sym->st_name);
+		if (name == NULL)
+		  return FALSE;
+		if (*name == '\0')
+		  name = bfd_section_name (input_bfd, input_section);
+	      }
+	    if (!(*info->callbacks->warning) (info, _("unsupported reloc"),
+					      name, input_bfd,
+					      input_section, rel->r_offset))
+	      return FALSE;
+	    ret_val = FALSE;
+	  }
+	  break;
+
+	case bfd_reloc_dangerous:
+	case bfd_reloc_outofrange:
+	case bfd_reloc_overflow:
+	default:
+	  {
+	    const char *name;
+
+	    if (h)
+	      name = h->root.root.string;
+	    else
+	      {
+		name = bfd_elf_string_from_elf_section (input_bfd,
+							symtab_hdr->sh_link,
+							sym->st_name);
+		if (name == NULL)
+		  return FALSE;
+		if (*name == '\0')
+		  name = bfd_section_name (input_bfd, input_section);
+	      }
+	    if (!(*info->callbacks->reloc_overflow) (info,
+						     (h ? &h->root : NULL),
+						     name,					     
+						     howto->name,
+						     (bfd_vma) 0,
+						     input_bfd,
+						     input_section,
+						     rel->r_offset))
+	      return FALSE;
+	    ret_val = FALSE;
+	  }
+	  break;
+	}
+    }
+
+  return ret_val;
+}
+
+static bfd_boolean elf_lx_output_arch_local_syms(
+  bfd *output_bfd,
+  struct bfd_link_info *info,
+  void *finfo ATTRIBUTE_UNUSED,
+  bfd_boolean (*func) (void *, const char *,
+		       Elf_Internal_Sym *,
+		       asection *,
+		       struct elf_link_hash_entry *) ATTRIBUTE_UNUSED)
+{
+  /* Ugly: hijack this hook to do some late GOT relocation processing.
+     It is not at all the purpose of this hook, but it happens to occur
+     at the correct stage of processing. */
+  struct elf_lx_link_hash_table *lx_info = elf_lx_hash_table (info);
+  asection *got_sec = lx_info->got_sec;
+  if (got_sec != NULL)
+    {
+      unsigned int reloc_count = got_sec->reloc_count;
+      if (reloc_count > 0)
+	{
+	  asection *output_section = got_sec->output_section;
+	  struct bfd_elf_section_data *esdo = elf_section_data (output_section);
+	  struct bfd_elf_section_data *esdg = elf_section_data (got_sec);
+	  Elf_Internal_Rela *relocs = esdg->relocs;
+	  unsigned int rel_count = esdg->rel_count;
+	  struct elf_link_hash_entry **rel_hash;
+	  
+	  rel_hash = esdo->rel_hashes + esdo->rel_count + esdo->rel_count2;
+	  memcpy (rel_hash, lx_info->got_rel_hash, reloc_count * sizeof (*rel_hash));
+	  free (lx_info->got_rel_hash);
+	  lx_info->got_rel_hash = NULL;
+	  if (rel_count < reloc_count)
+	    {
+	      /* We have reserved space for more relocs than we actually used.
+		 So, tidy the trailing ones so that they have a sensible offset.
+		 They will be of type R_LX_NONE.
+	      */
+	      bfd_vma last_offset;
+	      Elf_Internal_Rela *rel;
+	      
+	      if (rel_count > 0)      
+		last_offset = (relocs + rel_count - 1)->r_offset;
+	      else
+		last_offset = got_sec->output_section->vma + got_sec->output_offset;
+	      for (rel = relocs + rel_count; rel < relocs + reloc_count; rel++)
+		rel->r_offset = last_offset;
+	      elf_section_data (got_sec)->rel_count = reloc_count;
+	    }
+	  return _bfd_elf_link_output_relocs (output_bfd, output_section,
+					      &elf_section_data (got_sec)->rel_hdr,
+					      relocs, rel_hash);
+	}
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_gc_sweep_hook (bfd *abfd, struct bfd_link_info *link_info,
+		      asection *sec, const Elf_Internal_Rela *relocs)
+{
+  const Elf_Internal_Rela *rel, *relend;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_lx_link_hash_table *lx_info;
+
+  lx_info = elf_lx_hash_table (link_info);
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_link_hash_entry *h = NULL;
+      struct elf_lx_dyn_sym_info *dyn_i;
+      struct elf_lx_dyn_reloc_entry **pp;
+      struct elf_lx_dyn_reloc_entry *p;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  long indx = r_symndx - symtab_hdr->sh_info;
+	  h = elf_sym_hashes (abfd)[indx];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+      dyn_i = get_dyn_sym_info (lx_info, h, abfd, rel, FALSE);
+      if (dyn_i)
+	{
+	  for (pp = &dyn_i->reloc_entries; (p = *pp) != NULL; pp = &p->next)
+	    if (p->sec == sec)
+	      /* Everything must go for SEC. */
+	      *pp = p->next;
+	  r_type = ELF32_R_TYPE (rel->r_info);
+	  /* Update want_got, want_tprel, want_dtpndx, want_dtpldm counts for
+	     DYN_I. */
+	  /* Note that we do not have refcounts available for PLT requirements, so
+	     here we cannot eliminate unused PLT entries. */
+	  switch (r_type)
+	    {
+	    case R_LX_GOTOFF_FPTR_HI23:
+	    case R_LX_GOTOFF_FPTR_LO9:
+	    case R_LX_GOTOFF_HI23:
+	    case R_LX_GOTOFF_LO9:
+	    case R_LX_GOTOFFX_HI23:
+	    case R_LX_GOTOFFX_LO9:
+	      if (dyn_i->want_got > 0)
+		dyn_i->want_got--;
+	      break;
+	    case R_LX_GOTOFF_TPREL_HI23:
+	    case R_LX_GOTOFF_TPREL_LO9:
+	      if (dyn_i->want_tprel > 0)
+		dyn_i->want_tprel--;
+	      break;
+	    case R_LX_GOTOFF_DTPLDM_HI23:
+	    case R_LX_GOTOFF_DTPLDM_LO9:
+	      if (dyn_i->want_dtpldm > 0)
+		dyn_i->want_dtpldm--;
+	      break;
+	    case R_LX_GOTOFF_DTPNDX_HI23:
+	    case R_LX_GOTOFF_DTPNDX_LO9:
+	      if (dyn_i->want_dtpndx > 0)
+		dyn_i->want_dtpndx--;
+	      break;
+	    }
+	}
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_finish_dynamic_symbol (
+			      bfd *output_bfd,
+			      struct bfd_link_info *info,
+			      struct elf_link_hash_entry *h,
+			      Elf_Internal_Sym *sym)
+{
+
+  struct elf_lx_link_hash_table *lx_info;
+  struct elf_lx_dyn_sym_info *dyn_i;
+
+  lx_info = elf_lx_hash_table (info);
+  dyn_i = get_dyn_sym_info (lx_info, h, NULL, NULL, FALSE);
+
+  /* Fill in the PLT data, if required.  */
+  if (dyn_i && dyn_i->want_plt)
+    {
+      Elf_Internal_Rela outrel;
+      bfd_byte *loc;
+      asection *plt_sec;
+      bfd_vma plt_addr, pltoff_addr, gp_val, index, reloc_offset;
+      Elf32_External_Rela *rel;
+      int i;
+
+      gp_val = _bfd_get_gp_value (output_bfd);
+
+      /* Initialize the minimal PLT entry.  */
+
+      index = (dyn_i->plt_offset - PLT_HEADER_SIZE) / PLT_MIN_ENTRY_SIZE;
+      plt_sec = lx_info->plt_sec;
+      loc = plt_sec->contents + dyn_i->plt_offset;
+      reloc_offset = index * sizeof (Elf32_External_Rela);
+
+      for (i = 0; i < (PLT_MIN_ENTRY_SIZE / 4); i++)
+	bfd_put_32 (output_bfd, plt_min_entry[i],
+		    loc + (4 * i));
+      
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_23_PCREL,
+				output_bfd, plt_sec, plt_sec->contents,
+				dyn_i->plt_offset + 0,
+				plt_sec->output_section->vma, 0);
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9,
+				output_bfd, plt_sec, plt_sec->contents,
+				dyn_i->plt_offset + 4, reloc_offset, 0);
+      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23,
+				output_bfd, plt_sec, plt_sec->contents,
+				dyn_i->plt_offset + 8, reloc_offset, 0);
+
+      plt_addr = (plt_sec->output_section->vma
+		  + plt_sec->output_offset
+		  + dyn_i->plt_offset);
+      pltoff_addr = set_pltoff_entry (output_bfd, info, dyn_i, plt_addr,
+				      TRUE);
+
+      /* Initialize the FULL PLT entry, if needed.  */
+      if (dyn_i->want_plt2)
+	{
+	  loc = plt_sec->contents + dyn_i->plt2_offset;
+
+	  if (pic_abi_p (output_bfd))
+	    {
+	      const bfd_vma *template = (lx_mach_has_st240_encodings (output_bfd)
+					 ? pic_abi_plt_full_entry_st240
+					 : pic_abi_plt_full_entry_pre_st240);
+
+	      for (i = 0; i < (PLT_FULL_ENTRY_SIZE_PIC_ABI / 4); i++)
+		bfd_put_32 (output_bfd, template[i], loc + (4 * i));
+	      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23,
+					output_bfd, plt_sec, plt_sec->contents,
+					dyn_i->plt2_offset + 0,
+					pltoff_addr - gp_val, 0);
+	      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9,
+					output_bfd, plt_sec, plt_sec->contents,
+					dyn_i->plt2_offset + 4,
+					pltoff_addr - gp_val, 0);
+	      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23,
+					output_bfd, plt_sec, plt_sec->contents,
+					dyn_i->plt2_offset + 16,
+					(pltoff_addr + 4)- gp_val, 0);
+	      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9,
+					output_bfd, plt_sec, plt_sec->contents,
+					dyn_i->plt2_offset + 20,
+					(pltoff_addr + 4)- gp_val, 0);
+	    }
+	  else
+	    { /* embedded ABI */
+	      bfd_vma got_entry_addr = pltoff_addr;
+	      bfd_vma base_reg = 0;
+	      const bfd_vma *template = (lx_mach_has_st240_encodings (output_bfd)
+					 ? embedded_abi_plt_full_entry_st240
+					 : embedded_abi_plt_full_entry_pre_st240);
+
+	      if (info->shared)
+		{
+		  got_entry_addr = pltoff_addr - gp_val;
+		  base_reg = 14;
+		}
+
+	      for (i = 0; i < (PLT_FULL_ENTRY_SIZE / 4); i++)
+		{
+		  bfd_vma val = template[i];
+		  if (i == 1)
+		    val |= base_reg;
+		  bfd_put_32 (output_bfd, val, loc + (4 * i));
+		}
+	      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_HI23,
+					output_bfd, plt_sec,
+					plt_sec->contents,
+					dyn_i->plt2_offset + 0,
+					got_entry_addr, 0);
+	      _bfd_final_link_relocate (elf32_lx_howto_table + R_LX_LO9,
+					output_bfd, plt_sec,
+					plt_sec->contents,
+					dyn_i->plt2_offset + 4,
+					got_entry_addr, 0);
+	    }
+	      
+	  /* Mark the symbol as undefined, rather than as defined in the
+	     plt section.  Leave the value alone.  */
+	  if (! h->def_regular)
+	    sym->st_shndx = SHN_UNDEF;
+	}
+
+      /* Create the dynamic relocation.  */
+      outrel.r_offset = pltoff_addr;
+      if (pic_abi_p (output_bfd))
+	outrel.r_info = ELF32_R_INFO (h->dynindx, R_LX_IPLT);
+      else
+	outrel.r_info = ELF32_R_INFO (h->dynindx, R_LX_JMP_SLOT);
+      outrel.r_addend = 0;
+
+      /* This is fun.  In the .lx.pltoff section, we've got entries
+	 that correspond both to real PLT entries, and those that
+	 happened to resolve to local symbols but need to be created
+	 to satisfy @pltoff relocations.  The .rela.lx.pltoff
+	 relocations for the real PLT should come at the end of the
+	 section, so that they can be indexed by plt entry at runtime.
+
+	 We emitted all of the relocations for the non-PLT @pltoff
+	 entries during relocate_section.  So we can consider the
+	 existing sec->reloc_count to be the base of the array of
+	 PLT relocations.  */
+
+      rel = (Elf32_External_Rela *)lx_info->rel_pltoff_sec->contents;
+      rel += lx_info->rel_pltoff_sec->reloc_count;
+
+      bfd_elf32_swap_reloca_out (output_bfd, &outrel, (bfd_byte *) (rel + index));
+    }
+
+  {
+    /* Create a COPY relocation, if required. */
+    struct elf_lx_link_hash_entry *lx_h = (struct elf_lx_link_hash_entry *)h;
+
+    if (lx_h->rel_dynbss_allocated)
+      elf_lx_install_dyn_reloc (output_bfd, info,
+				h->root.u.def.section,
+				lx_info->rel_dynbss_sec,
+				h->root.u.def.value,
+				R_LX_COPY,
+				h->dynindx,
+				0);
+  }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
+      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+static bfd_boolean
+elf_lx_finish_dynamic_sections (
+				bfd *abfd,
+				struct bfd_link_info *info)
+{
+  struct elf_lx_link_hash_table *lx_info;
+  bfd *dynobj;
+
+  lx_info = elf_lx_hash_table (info);
+  dynobj = lx_info->root.dynobj;
+
+  if (elf_hash_table (info)->dynamic_sections_created)
+    {
+      Elf32_External_Dyn *dyncon, *dynconend;
+      asection *sdyn;
+      bfd_vma gp_val;
+
+      sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+      BFD_ASSERT (sdyn != NULL);
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+
+      gp_val = _bfd_get_gp_value (abfd);
+
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    case DT_PLTGOT:
+	      dyn.d_un.d_ptr = gp_val;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      dyn.d_un.d_val = (lx_info->minplt_entries
+				* sizeof (Elf32_External_Rela));
+	      break;
+
+	    case DT_JMPREL:
+	      /* See the comment above in finish_dynamic_symbol.  */
+	      dyn.d_un.d_ptr = (lx_info->rel_pltoff_sec->output_section->vma
+				+ lx_info->rel_pltoff_sec->output_offset
+				+ (lx_info->rel_pltoff_sec->reloc_count
+				   * sizeof (Elf32_External_Rela)));
+	      break;
+
+	    case DT_RELASZ:
+	      /* Do not have RELASZ include JMPREL.  This makes things
+		 easier on ld.so.  This is not what the rest of BFD set up.  */
+	      dyn.d_un.d_val -= (lx_info->minplt_entries
+				 * sizeof (Elf32_External_Rela));
+	      break;
+	    }
+
+	  bfd_elf32_swap_dyn_out (abfd, &dyn, dyncon);
+	}
+
+      /* Initialize the PLT0 entry */
+      if (lx_info->plt_sec)
+	{
+	  bfd_byte *loc = lx_info->plt_sec->contents;
+	  int i;
+
+	  if (pic_abi_p (abfd))
+	    {
+	      const bfd_vma *template = (lx_mach_has_st240_encodings (abfd)
+					 ? pic_abi_plt_header_st240
+					 : pic_abi_plt_header_pre_st240);
+
+	      for (i = 0; i < (PLT_HEADER_SIZE / 4); i++)
+		bfd_put_32 (abfd, template[i], loc + (4 * i));
+	    }
+	  else
+	    { /* embedded ABI */
+	      if (info->shared)
+		{
+		  const bfd_vma *template = (lx_mach_has_st240_encodings (abfd)
+					     ? embedded_abi_plt_header_st240
+					     : embedded_abi_plt_header_pre_st240);
+
+		  for (i = 0; i < (PLT_HEADER_SIZE / 4); i++)
+		    bfd_put_32 (abfd, template[i], loc + (4 * i));
+		}
+	      else
+		{
+		  const bfd_vma *template =
+		    (lx_mach_has_st240_encodings (abfd)
+		     ? embedded_abi_absolute_plt_header_st240
+		     : embedded_abi_absolute_plt_header_pre_st240);
+
+		  for (i = 0; i < (PLT_HEADER_SIZE / 4); i++)
+		    {
+		      bfd_vma val = template[i];
+
+		      if (i == 0)
+			val |= ((gp_val + 4) >> 9) & 0x7fffff;
+		      else if (i == 1)
+			val |= ((gp_val + 4) & 0x1ff) << 12;
+		      else if (i == 3)
+			val |= (gp_val & 0x1ff) << 12;
+		      else if (i == 4)
+			val |= (gp_val >> 9) & 0x7fffff;
+		      bfd_put_32 (abfd, val, loc + (4 * i));
+		    }
+		}
+	    }
+	}
+    }
+
+  return TRUE;
+}
+
+void
+bfd_elf32_lx_set_transform_to_absolute (struct bfd_link_info *info,
+					bfd_boolean value)
+{
+  elf_lx_hash_table(info)->transform_to_absolute = value;
+}
+
+/* Return true if SYM represents a local label symbol. */
+
+static bfd_boolean
+lx_elf_is_local_label_name(
+			   bfd *abfd ATTRIBUTE_UNUSED,
+			   const char *name)
+{
+  return ((name[0] == '.' && name[1] == 'L') || 
+	  (name[0] == 'L' && name[1] == '?') ||
+	  (name[0] == '_' && name[1] == '?') ||
+	  (name[0] == '?') ||
+	  (name[0] == '$'));
+}
+
+/* Decide whether to attempt to turn absptr or lsda encodings in
+   shared libraries into pcrel within the given input section.  */
+
+static bfd_boolean
+elf_lx_use_relative_eh_frame
+(bfd *input_bfd ATTRIBUTE_UNUSED,
+ struct bfd_link_info *info ATTRIBUTE_UNUSED,
+ asection *eh_frame_section ATTRIBUTE_UNUSED)
+{
+  /* We don't use PC-relative encodings in rl_lib/shlib binaries, in general.  */
+  return FALSE;
+}
+
+
+/* 
+   Merge backend specific data from an object file to the output
+   object file when linking  -- we just use it to check object file
+ consistency -- we could also check lxbe vs. multiflow here 
+ see elf32-ppc.c for an example
+*/
+int first_core = 1;
+int first_cut = 1;
+int first_abi = 1;
+int first_osabi = 1;
+int first_code_generation_mode = 1;
+
+
+static bfd_boolean
+lx_elf_merge_private_bfd_data (
+			       bfd *ibfd,
+			       bfd *obfd)
+{
+  flagword input_flags;
+  flagword output_flags;
+  Elf_Internal_Ehdr * input_ehdrp;
+  Elf_Internal_Ehdr * output_ehdrp;
+
+  /* Check if we have the same endianess */
+
+  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
+      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
+/* (pp) allow linking with other formats */
+      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
+     )
+    {
+      (*_bfd_error_handler)
+	(_("%s: compiled for a %s endian system and target is %s endian"),
+	 bfd_get_filename (ibfd),
+	 bfd_big_endian (ibfd) ? "big" : "little",
+	 bfd_big_endian (obfd) ? "big" : "little");
+
+      bfd_set_error (bfd_error_wrong_format);
+      return FALSE;
+    }
+
+#if 0
+  lx_bfd_flags old_flags;
+  lx_bfd_flags new_flags;
+  new_flags.f = elf_elfheader (ibfd)->e_flags;
+  old_flags.f = elf_elfheader (obfd)->e_flags;
+  if (!elf_flags_init (obfd))	/* First call, no flags set */
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = new_flags.f;
+    }
+
+  else if (new_flags.f == old_flags.f)	
+  	/* Same flags: always ok */
+    ;
+  else 
+    {
+      unsigned int old_rta = old_flags.obj_compat.rta;
+      unsigned int new_rta = new_flags.obj_compat.rta;
+      if (old_rta && new_rta && old_rta != new_rta)
+        {
+          (*_bfd_error_handler)(
+	      _("%s: uses different e_flags [%x] (rta:%d) fields "
+	      "than previous modules [%x] (rta:%d)"),
+	      bfd_get_filename (ibfd), 
+	      new_flags.f, new_flags.obj_compat.rta, 
+	      old_flags.f, old_flags.obj_compat.rta);
+          bfd_set_error(bfd_error_bad_value);
+          return FALSE;
+        }
+    }
+#endif
+
+  input_flags = lx_elf_get_private_flags(ibfd);
+  output_flags = lx_elf_get_private_flags(obfd);
+  input_ehdrp = elf_elfheader (ibfd);
+  output_ehdrp = elf_elfheader (obfd);
+
+  if (!elf_flags_init (obfd)) {  /* First call, no flags set */
+    lx_elf_set_private_flags (obfd, input_flags);
+    output_ehdrp->e_ident[EI_ABIVERSION] = input_ehdrp->e_ident[EI_ABIVERSION] ;
+    output_ehdrp->e_ident[EI_OSABI] = input_ehdrp->e_ident[EI_OSABI] ;
+    return TRUE;
+  }
+ 
+  if (strcmp(core_printable_name(input_flags),core_printable_name(output_flags)))
+  {
+    flagword input_core;
+    flagword output_core;
+
+    (*_bfd_error_handler)("warning : mixing cores : %s (%s) and %s (%s)", bfd_get_filename (ibfd), core_printable_name(input_flags), bfd_get_filename (obfd), core_printable_name(output_flags) );  
+    /* take the highest machine number */
+    input_core = (input_flags & ELF_LX_CORE_MASK);
+    output_core = (output_flags & ELF_LX_CORE_MASK);
+    if (input_core > output_core)
+	output_core = input_core;
+      output_flags = ((output_flags | ELF_LX_CORE_MASK) & output_core);
+      lx_elf_set_private_flags (obfd, output_flags);
+  }
+
+  if (strcmp(cut_printable_name(input_flags),cut_printable_name(output_flags)))
+  {
+    (*_bfd_error_handler)("warning : mixing cuts : %s (%s) and %s (%s)", bfd_get_filename (ibfd), cut_printable_name(input_flags), bfd_get_filename (obfd), cut_printable_name(output_flags) );  
+  }
+
+  if (strcmp(abi_printable_name(input_flags, input_ehdrp),abi_printable_name(output_flags, output_ehdrp)))
+  {
+    (*_bfd_error_handler)("warning : mixing abis : %s (%s) and %s (%s)", bfd_get_filename (ibfd), abi_printable_name(input_flags, input_ehdrp), bfd_get_filename (obfd), abi_printable_name(output_flags, output_ehdrp) );  
+  }
+
+  if (strcmp(osabi_printable_name(input_ehdrp),osabi_printable_name(output_ehdrp)))
+  {
+    (*_bfd_error_handler)("warning : mixing osabis : %s (%s) and %s (%s)", bfd_get_filename (ibfd), osabi_printable_name(input_ehdrp), bfd_get_filename (obfd), osabi_printable_name(output_ehdrp) );  
+  }
+
+    if (strcmp(code_generation_mode_printable_name(input_ehdrp),code_generation_mode_printable_name(output_ehdrp)))
+  {
+    (*_bfd_error_handler)("warning : mixing code generation modes : %s (%s) and %s (%s)", bfd_get_filename (ibfd), osabi_printable_name(input_ehdrp), bfd_get_filename (obfd), osabi_printable_name(output_ehdrp) );  
+  }
+
+  return TRUE;
+}
+
+static bfd_boolean
+lx_elf_print_private_bfd_data (bfd *abfd, PTR farg)
+{
+  FILE *f = (FILE *) farg;
+
+  elf_lx_dump_secinit_table(abfd, f);
+  lx_elf_dump_target_info(abfd, f);
+  return _bfd_elf_print_private_bfd_data (abfd, farg);
+}
+
+static bfd_boolean
+lx_elf_set_mach_from_flags (
+			    bfd *abfd)
+{
+  flagword flags = elf_elfheader (abfd)->e_flags;
+
+  switch (flags & ELF_LX_CORE_MASK)
+    {
+    case ELF_LX_CORE_ST231:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st231);
+      break;
+    case ELF_LX_CORE_ST240:
+      bfd_default_set_arch_mach (abfd, bfd_arch_lx, bfd_mach_st240);
+      break;
+    default:
+      return FALSE;
+    }
+  return TRUE;
+}
+
+/* We set the machine architecture from flags
+   here.  */
+
+static bfd_boolean
+lx_elf_object_p (bfd *abfd)
+{
+  return lx_elf_set_mach_from_flags (abfd);
+}
+
+
+static bfd_boolean
+lx_mach_has_st240_encodings (bfd *abfd)
+{
+  unsigned long mach = bfd_get_mach (abfd);
+  return mach >= bfd_mach_st240;
+}
+
+static bfd_boolean
+lx_elf_set_flags_from_mach (
+			    bfd *abfd)
+{
+  flagword flags = elf_elfheader (abfd)->e_flags;
+  unsigned long mach = bfd_get_mach(abfd);
+
+  switch (mach)
+    {
+    case bfd_mach_st231:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST231);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    case bfd_mach_st240:
+      flags = ((flags | ELF_LX_CORE_MASK) & ELF_LX_CORE_ST240);
+      lx_elf_set_private_flags (abfd, flags);
+      break;
+    default:
+      return FALSE;
+    }
+  return TRUE;
+}
+
+/*
+ * Function to set private flags in
+ * BFD file
+ */
+static bfd_boolean
+lx_elf_set_private_flags (
+			  bfd *abfd,
+			  flagword flags)
+{
+/*  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags); */
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return lx_elf_set_mach_from_flags (abfd);
+}
+
+flagword 
+lx_elf_get_private_flags (bfd* abfd)
+{
+  flagword flags;
+  flags=elf_elfheader (abfd)->e_flags;
+  return flags;
+}
+
+bfd_boolean
+lx_elf_copy_private_flags (bfd* ibfd, bfd* obfd)
+{
+    if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour ||
+	bfd_get_flavour (obfd) != bfd_target_elf_flavour) {
+	if (bfd_external_binary_mach != 0) {
+	    /* objcopy has set this to the ELF machine number obtained from
+	     * the -B xxx option
+	     */
+	    bfd_set_arch_mach(obfd, bfd_external_binary_architecture, bfd_external_binary_mach);
+	    /* reset it */
+	    bfd_external_binary_mach = 0;
+	    return lx_elf_set_flags_from_mach(obfd);
+	} else
+	    return TRUE;
+    }
+	
+    return lx_elf_set_private_flags(obfd, lx_elf_get_private_flags(ibfd));
+}
+
+const char *
+core_printable_name(flagword flags)
+{
+      switch ( flags&ELF_LX_CORE_MASK )
+        {
+        case ELF_LX_CORE_ST231: return "st231";
+        case ELF_LX_CORE_ST240: return "st240";
+        default: return "undefined core";
+        }
+}
+
+const char *
+cut_printable_name(flagword flags)
+{
+      switch ( flags&ELF_LX_CUT_MASK )
+        {
+        case ELF_LX_CUT_0: return "cut0";
+        case ELF_LX_CUT_1: return "cut1";
+        case ELF_LX_CUT_2: return "cut2";
+        case ELF_LX_CUT_3: return "cut3";
+        case ELF_LX_CUT_4: return "cut4";
+        case ELF_LX_CUT_5: return "cut5";
+        default:  return "undefined cut";
+        }
+}
+
+const char *
+abi_printable_name(flagword flags, Elf_Internal_Ehdr * i_ehdrp)
+{
+  int temp;
+/* this is a bit tricky because on solaris, the previous implementation
+   of the assembler was storing in the high end bits instead of the low
+   end bits as was done on Win32 */
+
+  temp = (flags&ELF_LX_ABI_MASK)|(flags >> _ELF_LX_RTA_BIT);
+
+/* insure compatibility between .rta and assume directive */
+  temp = temp | ((i_ehdrp->e_ident[EI_ABIVERSION])&ELF_LX_ABI_MASK);
+
+      switch ( temp )
+        {
+        case ELF_LX_ABI_NO:  return "no-abi";
+        case ELF_LX_ABI_MULTI: return "old-multiflow-abi";
+        case ELF_LX_ABI_EMBED: return "lx-embedded-abi";
+        case ELF_LX_ABI_PIC: return "pic-abi";
+        case ELF_LX_ABI_GCC: return "gcc-abi";
+	case ELF_LX_ABI_RELOC_EMBED: return "relocatable-embedded-abi";
+        default: return "undefined abi";
+        }
+}
+
+const char *
+osabi_printable_name(Elf_Internal_Ehdr * i_ehdrp)
+{
+      switch ( i_ehdrp->e_ident[EI_OSABI] )
+        {
+        case ELFOSABI_NONE: return "bare-machine";
+        case ELFOSABI_LINUX: return "linux";
+        case ELFOSABI_OS21: return "os21";
+        default: return "undefined osabi";
+        }
+}
+
+const char *
+code_generation_mode_printable_name(Elf_Internal_Ehdr * i_ehdrp)
+{
+      switch ( (i_ehdrp->e_ident[EI_ABIVERSION])&ELF_LX_MODE_MASK )
+        {
+        case ELF_LX_MODE_USER: return " user";
+        case ELF_LX_MODE_KERNEL: return "kernel";
+        default: return "undefined code generation mode";
+        }
+}
+
+void
+lx_elf_dump_target_info(bfd *abfd, FILE *writer)
+{
+  Elf_Internal_Ehdr * i_ehdrp = elf_elfheader (abfd);
+ 
+  /* (pp) dump addtional flags for elf files only */
+  if ( strstr(abfd->xvec->name,"elf")!=NULL )  /* the test is a bit dirty... */
+    {                                          /* is it worth to clean it...? */
+      flagword flags = lx_elf_get_private_flags(abfd);
+      fprintf(writer,"eflags : %x -",flags);
+
+      /* (pp) consider core info */
+      fprintf(writer," %s", core_printable_name(flags));
+
+      /* (pp) consider cut info */
+      fprintf(writer," %s", cut_printable_name(flags));
+
+      /* (pp) consider abi info */
+      fprintf(writer," %s", abi_printable_name(flags, i_ehdrp));
+
+      /* (pp) consider osabi info */
+      fprintf(writer," %s", osabi_printable_name(i_ehdrp));
+
+      /* (pp) consider code generation mode info */
+      fprintf(writer," %s", code_generation_mode_printable_name(i_ehdrp));
+    }
+}
+
+typedef enum {
+  secinit_end_of_table_enum = 0x00,
+  secinit_memory_bss_enum   = 0x01,
+  secinit_memory_data_enum  = 0x02,
+  secinit_memory_compress_enum   = 0x03,
+  secinit_invalid_enum      = 0x04
+} secinit_enum_t;
+
+typedef struct _secinit_clear {
+  bfd_vma vma;
+  unsigned int size;
+  unsigned int status;
+} secinit_clear_t;
+
+typedef secinit_clear_t *secinit_clear_ptr;
+
+typedef struct _secinit_copy {
+  bfd_vma vma;
+  bfd_vma lma;
+  unsigned int size;
+  unsigned int status;
+} secinit_copy_t;
+
+typedef secinit_copy_t *secinit_copy_ptr;
+
+#define MAX_NAME_LEN 8
+
+typedef struct _secinit_compress {
+  bfd_vma vma;
+  bfd_vma lma;
+  unsigned int size;
+  unsigned int compressed_size;
+  char algo_name[MAX_NAME_LEN];
+//  int (*algo)(char *vma, char *lma, unsigned int compressed_size, unsigned int size);
+  bfd_vma algo;
+  unsigned int status;
+} secinit_compress_t;
+
+typedef secinit_compress_t *secinit_compress_ptr;
+
+typedef union _secinit_union {
+  secinit_clear_t clear;
+  secinit_copy_t copy;
+  secinit_compress_t compress;
+} secinit_union_t;
+
+typedef struct _secinit {
+  secinit_enum_t type;
+  secinit_union_t u;
+} secinit_t;
+
+typedef secinit_t *secinit_ptr;
+
+bfd_boolean
+elf_lx_get_secinit_table ( bfd *abfd, secinit_ptr *secinit_table, int *secinit_table_entry_nb);
+
+bfd_boolean
+elf_lx_set_secinit_table ( bfd *abfd, secinit_ptr secinit_table, int secinit_table_entry_nb);
+
+void
+elf_lx_dump_secinit_table(bfd *abfd, FILE *writer);
+
+bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd, bfd_boolean compress, char *library_name);
+
+
+
+bfd_boolean 
+elf_lx_set_secinit_table ( bfd *abfd,
+  secinit_ptr secinit_table,
+  int secinit_table_entry_nb)
+{
+  asection *sec;
+  bfd_byte *contents = NULL;
+  int sec_size;
+  int offset = 0;
+  int i = 0;
+  int j = 0;
+
+  sec = bfd_get_section_by_name (abfd, ".secinit");
+  if (!sec) goto error_return;
+  sec_size = bfd_section_size (abfd, sec);
+  if (elf_section_data (sec)->this_hdr.contents != NULL)
+    contents = elf_section_data (sec)->this_hdr.contents;
+  else
+    {
+      contents = (bfd_byte *) bfd_malloc (sec_size);
+      if (contents == NULL)
+        goto error_return;
+      if (! bfd_get_section_contents (abfd, sec, contents,
+                                      (file_ptr) 0, sec_size))
+        goto error_return;
+    }
+
+  bfd_put_32 (abfd, secinit_table_entry_nb, contents + offset);
+  offset += 4;
+
+  for (i=0; i < secinit_table_entry_nb; i ++) {
+    bfd_put_32 (abfd, secinit_table[i].type, contents + offset);
+      offset +=4;
+    switch (secinit_table[i].type) {
+    case secinit_memory_compress_enum:
+      bfd_put_32 (abfd, secinit_table[i].u.compress.vma, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.lma, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.size, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.compressed_size, 
+        contents + offset); offset +=4;
+      for (j=0;j<MAX_NAME_LEN;j++) {
+        bfd_put_8 (abfd, secinit_table[i].u.compress.algo_name[j], 
+          contents + offset); offset ++;
+      }
+      bfd_put_32 (abfd, secinit_table[i].u.compress.algo, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.compress.status, contents + offset);
+        offset +=4;
+      break;
+    case secinit_memory_data_enum:
+      bfd_put_32 (abfd, secinit_table[i].u.copy.vma, contents + offset );
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.copy.lma, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.copy.size, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.copy.status, contents + offset);
+        offset +=4;
+      break;
+    case secinit_memory_bss_enum:
+      bfd_put_32 (abfd, secinit_table[i].u.clear.vma, contents + offset );
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.clear.size, contents + offset);
+        offset +=4;
+      bfd_put_32 (abfd, secinit_table[i].u.clear.status, contents + offset);
+        offset +=4;
+      break;
+    default:
+      break;
+    }
+  }
+  if (! bfd_set_section_contents (abfd, sec, contents, (file_ptr) 0, sec_size))
+    goto error_return;
+
+  return TRUE;
+
+error_return:
+  if (contents != NULL) free (contents);
+  return FALSE;
+}
+
+bfd_boolean
+elf_lx_get_secinit_table (
+  bfd *abfd,
+  secinit_ptr *secinit_table_ptr,
+  int *secinit_table_entry_nb)
+{
+  asection *sec;
+  bfd_byte *contents = NULL;
+  int sec_size;
+  int offset = 0;
+  int i = 0;
+  int j = 0;
+  secinit_ptr secinit_table;
+
+  sec = bfd_get_section_by_name (abfd, ".secinit");
+  if (!sec) goto error_return;
+  sec_size = bfd_section_size (abfd, sec);
+  if (elf_section_data (sec)->this_hdr.contents != NULL)
+    contents = elf_section_data (sec)->this_hdr.contents;
+  else
+    {
+      contents = (bfd_byte *) bfd_malloc (sec_size);
+      if (contents == NULL)
+        goto error_return;
+      if (! bfd_get_section_contents (abfd, sec, contents,
+                                      (file_ptr) 0, sec_size))
+        goto error_return;
+    }
+
+  *secinit_table_entry_nb =  bfd_get_32 (abfd, contents+offset); offset+=4;
+
+  secinit_table = (secinit_ptr) bfd_malloc ((*secinit_table_entry_nb) * 
+                                             sizeof(*secinit_table));
+
+  for (i=0; i < *secinit_table_entry_nb; i ++) {
+    secinit_table[i].type = bfd_get_32 (abfd, contents+offset); offset+=4;
+    switch (secinit_table[i].type) {
+    case secinit_memory_compress_enum:
+      secinit_table[i].u.compress.vma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.lma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.compressed_size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      for (j=0;j<MAX_NAME_LEN;j++) {
+        secinit_table[i].u.compress.algo_name[j] = 
+          bfd_get_8 (abfd, contents+offset); offset++;
+      }
+      secinit_table[i].u.compress.algo = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.compress.status = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      break;
+    case secinit_memory_data_enum:
+      secinit_table[i].u.copy.vma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.copy.lma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.copy.size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.copy.status = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      break;
+    case secinit_memory_bss_enum:
+      secinit_table[i].u.clear.vma = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.clear.size = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      secinit_table[i].u.clear.status = 
+        bfd_get_32 (abfd, contents+offset); offset+=4;
+      break;
+    default:
+      break;
+    }
+  }
+  *secinit_table_ptr = secinit_table;
+
+  return TRUE;
+
+error_return:
+  if (contents != NULL) free (contents);
+  return FALSE;
+}
+
+void
+elf_lx_dump_secinit_table(bfd *abfd, FILE *writer)
+{
+  secinit_ptr secinit_table;
+  int secinit_table_entry_nb;
+  int i;
+
+  if (elf_lx_get_secinit_table(abfd, &secinit_table, &secinit_table_entry_nb)) {
+
+    fprintf(writer, "Secinit table size : %d\n", secinit_table_entry_nb);
+    for (i=0; i < secinit_table_entry_nb; i ++) {
+      switch (secinit_table[i].type) {
+      case secinit_memory_compress_enum:
+      fprintf(writer, "                %8s %8s %8s %8s %8s %8s %8s\n",
+	      "vma", "lma", "size", "c_size", "algo", "algo-@", "status");
+      fprintf(writer, "Entry compress: %08x %08x %08x %08x %8s %08x %08x\n",
+             (int) secinit_table[i].u.compress.vma,
+             (int) secinit_table[i].u.compress.lma,
+             secinit_table[i].u.compress.size,
+             secinit_table[i].u.compress.compressed_size,
+             secinit_table[i].u.compress.algo_name,
+             (int) secinit_table[i].u.compress.algo,
+             secinit_table[i].u.compress.status );
+        break;
+      case secinit_memory_data_enum:
+      fprintf(writer, "                %8s %8s %8s %8s\n",
+	      "vma", "lma", "size", "status");
+      fprintf(writer, "Entry data    : %08x %08x %08x %08x\n", 
+             (int) secinit_table[i].u.copy.vma,
+             (int) secinit_table[i].u.copy.lma,
+             secinit_table[i].u.copy.size, secinit_table[i].u.copy.status );
+        break;
+      case secinit_memory_bss_enum:
+      fprintf(writer, "                %8s %8s %8s\n",
+	      "vma", "size", "status");
+      fprintf(writer, "Entry bss     : %08x %08x %08x\n", 
+             (int) secinit_table[i].u.clear.vma,
+             secinit_table[i].u.clear.size, secinit_table[i].u.clear.status );
+        break;
+      default :
+        break;
+      }
+    }
+    fprintf(writer, "\n");
+  }
+}
+
+/*
+ * Function used by objcopy during second phase of compression 
+ * handling where sections lma addresses must be updated at ELF
+ * level, taking into account compressed section sizes.
+ * Input parameters: bfd and section to look for.
+ * Output parameters (if section in compact table):  initial_lma, compress_lma,
+ * initial_size, compress_size.
+ * Return Value: (-1) if section not found in compact table, 
+ *               (0) if section found in compact table.
+ */
+int
+elf_lx_get_compact_info (bfd *abfd ATTRIBUTE_UNUSED, sec_ptr sec, 
+			 bfd_vma *initial_lma, bfd_vma *compress_lma,
+			 bfd_size_type *initial_size, 
+			 bfd_size_type *compress_size) {
+    unsigned int i;
+
+    for (i = 0; i < elf_lx_cpt_tab_nb; i ++) {
+	if (!strcmp(elf_lx_cpt_tab[i]->sec_name, sec->name) &&
+	     (elf_lx_cpt_tab[i]->initial_lma == sec->lma) &&
+	     (elf_lx_cpt_tab[i]->initial_size == sec->size)) {
+	    *initial_lma = elf_lx_cpt_tab[i]->initial_lma;
+	    *compress_lma = elf_lx_cpt_tab[i]->compress_lma;
+	    *initial_size = elf_lx_cpt_tab[i]->initial_size;
+	    *compress_size = elf_lx_cpt_tab[i]->compress_size;
+
+	    return(0);
+	}
+    }
+    /* section not found in compact table */
+    return(-1);   
+}
+
+/* Sort sections by lma.  */
+int
+elf_lx_sort_sections_by_lma (const void *arg1, const void *arg2)
+{
+  const struct elf_lx_cpt *sec1 = 
+      *(const struct elf_lx_cpt **) arg1;
+  const struct elf_lx_cpt *sec2 = 
+      *(const struct elf_lx_cpt **) arg2;
+
+  if (sec1->initial_lma < sec2->initial_lma)
+    return -1;
+  else if (sec1->initial_lma > sec2->initial_lma)
+    return 1;
+
+  printf("Warning: Two sections with the same lma during section compression\n");
+  return -1;
+}
+
+#ifdef NO_COMPRESSION_SUPPORT
+bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd ATTRIBUTE_UNUSED,
+				      bfd_boolean compress ATTRIBUTE_UNUSED, 
+                                      char *library_name ATTRIBUTE_UNUSED)
+{
+  return FALSE;
+}
+#else
+#ifdef _WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <errno.h>
+#define dlopen(P,G) (void*)LoadLibrary(P)
+#define dlsym(D,F) (void*)GetProcAddress((HMODULE)(D),(F))
+#define dlclose(D) FreeLibrary((HMODULE)(D))
+__inline char* dlerror(void);
+__inline char* dlerror()
+{
+   static char szMsgBuf[256];
+   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+           NULL,
+           GetLastError(),
+           MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+           szMsgBuf,
+           sizeof szMsgBuf,
+           NULL);
+   return szMsgBuf;
+}
+#else
+#include <dlfcn.h>
+#endif /* _WIN32 */
+
+#if DEBUG_COMPRESSION
+static void 
+elf_lx_cpt_tab_dump(struct elf_lx_cpt **tab,
+		    unsigned int nb_entries,
+		    FILE *writer)
+{
+    unsigned int i;
+
+    fprintf(writer, "Section compaction table for compression: %d\n", nb_entries);
+    fprintf(writer, "%8s %8s %8s %8s\n", "lma", "c_lma", "size","c_size");
+    for (i = 0; i < nb_entries; i++) {
+	fprintf(writer, "%08x %08x %08x %08x   Section: %s (secinit index: %d)\n",
+		(int) tab[i]->initial_lma,
+		(int) tab[i]->compress_lma,
+		(int) tab[i]->initial_size,
+		(int) tab[i]->compress_size,
+		tab[i]->sec_name,
+		tab[i]->secinit_index);
+    }
+    
+    return;
+}
+#endif
+
+bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd, bfd_boolean compress, 
+                                      char *library_name)
+{
+  secinit_ptr secinit_table;
+  unsigned int secinit_table_entry_nb;
+  asection *sec;
+  bfd_byte *contents = NULL, *output_contents = NULL;
+  const char *sec_name;
+  unsigned int sec_size, size;
+  unsigned int i, shift;
+  void *p_handle = NULL;
+  char *p_error = NULL;
+  char *compress_name = NULL;
+  char *algo_name = NULL, *prefix = NULL;
+  void (*p_compress_or_decompress)(char * algo_name, int compress,
+                       const char * buff_in, unsigned int in_len,
+                       char * buff_out, unsigned int * p_out_len) = NULL;
+  void (*p_compress)(const char * buff_in, unsigned int in_len,
+		     char * buff_out, unsigned int * p_out_len) = NULL;
+
+  if (elf_lx_get_secinit_table(abfd,
+         &secinit_table, &secinit_table_entry_nb) ) {
+#if DEBUG_COMPRESSION
+    elf_lx_dump_secinit_table(abfd, stdout);
+#endif
+    if (!secinit_table_entry_nb) return TRUE;
+
+    if (library_name == NULL) {
+	/*	p_compress_or_decompress = &compress_or_decompress;*/
+	printf("Default compression algorithms not yet implemented!\n");
+	exit(1);
+    } else {
+	p_handle = dlopen(library_name,RTLD_LAZY);
+	if (!p_handle) {
+	    fputs (dlerror(), stderr);
+	    printf("\n");
+	    exit(1);
+	}
+    }
+
+    /* 
+     * Initialize the lma-ordered list of sections that have a lma != vma 
+     * We use a temporary table not ordered and allocated with the 
+     * number of entries in the secinit table.
+     */
+    elf_lx_cpt_tab_nb = 0;
+    elf_lx_cpt_tab_ = (struct elf_lx_cpt *) 
+	bfd_malloc(secinit_table_entry_nb * 
+		   sizeof(struct elf_lx_cpt));
+    if (elf_lx_cpt_tab_ == NULL) {
+	printf("Error: memory allocation failed\n");
+	goto error_return;
+    }
+
+    for (i = 0; i < secinit_table_entry_nb; i ++) {
+      for (sec = abfd->sections; sec != NULL; sec = sec->next) {
+        sec_size = bfd_section_size (abfd, sec);
+        sec_name = (char *) bfd_get_section_name(abfd, sec);
+
+        switch (secinit_table[i].type) {
+        case secinit_memory_compress_enum:
+        if (secinit_table[i].u.compress.lma == bfd_section_lma(abfd, sec) &&
+            secinit_table[i].u.compress.vma == bfd_section_vma(abfd, sec) ) {
+#if DEBUG_COMPRESSION
+	    if (compress)
+		printf("Found section to compress: %s \n", bfd_get_section_name(abfd, sec));
+	    else
+		printf("Found section to decompress: %s \n", bfd_get_section_name(abfd, sec));
+#endif
+          if (elf_section_data (sec)->this_hdr.contents != NULL)
+            contents = elf_section_data (sec)->this_hdr.contents;
+          else {
+            contents = (bfd_byte *) bfd_malloc (sec_size);
+            if (contents == NULL)
+              goto error_return;
+            if (! bfd_get_section_contents (abfd, sec, contents,
+                                      (file_ptr) 0, sec_size))
+              goto error_return;
+          }	  
+
+	  if (library_name != NULL) {
+	      if (compress)
+		  prefix = "__compress_";
+	      else
+		  prefix = "__decompress_";
+	      
+	      algo_name = secinit_table[i].u.compress.algo_name;
+	      compress_name = (char *) bfd_malloc(strlen (prefix) + 
+						  strlen(algo_name) + 1);
+	      if (compress_name == NULL) {
+		  printf("Error: memory allocation failed\n");
+		  goto error_return;
+	      }
+
+	      strcpy(compress_name, prefix);
+	      strcat(compress_name, algo_name);
+	      p_compress = dlsym(p_handle,compress_name);
+	      if ((p_error = dlerror()) != NULL)  {
+		  printf("Error looking for %s symbol in compression library: %s", algo_name, library_name);
+		  fputs(p_error, stderr);
+		  printf("\n");
+		  exit(1);
+	      }
+	  }
+
+          if (compress) {
+	      if (sec_size != secinit_table[i].u.compress.size)
+		  printf("Warning: Section size (%d) != Secinit recorded size (%d)!\n",
+			 sec_size, secinit_table[i].u.compress.size);
+	      if (secinit_table[i].u.compress.compressed_size == 0) {
+		  /* Allocate the output buffer, using the input size */
+		  output_contents = (bfd_byte *) bfd_malloc (sec_size);
+		  if (output_contents == NULL) {
+		      printf("Error: memory allocation failed\n");
+		      goto error_return;
+		  }
+
+		  if (library_name == NULL) {
+		      (*p_compress_or_decompress)(
+			   secinit_table[i].u.compress.algo_name, compress,
+			   contents, sec_size,
+			   output_contents, &size);
+		  } else {
+#if DEBUG_COMPRESSION
+		      printf("Before calling compression in shared lib: %s()\n", compress_name);
+#endif
+		      (*p_compress)(contents, sec_size, 
+				    output_contents, &size);
+#if DEBUG_COMPRESSION
+		      printf("After call to compression in shared lib: %s()\n", compress_name);
+#endif
+
+		  }
+		  if (size > sec_size)
+		      printf("Warning: Compressed size (%d) > Initial section size (%d)!\n", size, sec_size);
+
+		  secinit_table[i].u.compress.compressed_size = size;
+#if DEBUG_COMPRESSION
+		  printf("Compress section %s \n", sec_name);
+#endif
+
+		  /* Fill lma-ordered list of sections that have a lma != vma */
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name = 
+		      (char *) bfd_malloc(strlen (sec_name) + 1);
+		  if (elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name == NULL) {
+		      printf("Error: memory allocation failed\n");
+		      goto error_return;
+		  }
+		  strcpy(elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name, sec_name);
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].secinit_index = i;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_lma = 
+		      secinit_table[i].u.compress.lma;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_lma = 0;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_size = sec_size;
+		  elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_size = size;
+		  elf_lx_cpt_tab_nb++;
+
+	      } else {
+#if DEBUG_COMPRESSION
+		  printf("Section already compressed %s \n", sec_name);
+#endif
+	      }
+          } else {  /* decompress */
+	      if (secinit_table[i].u.compress.compressed_size) {
+		  if (sec_size != secinit_table[i].u.compress.compressed_size)
+		      printf("Warning: Section size (%d) != Secinit recorded compressed size (%d)!\n",
+			     sec_size, secinit_table[i].u.compress.compressed_size);
+
+		  /* Allocate the output buffer, using the uncompressed size */
+		  output_contents = (bfd_byte *) bfd_malloc (
+					     secinit_table[i].u.compress.size);
+		  if (output_contents == NULL) {
+		      printf("Error: memory allocation failed\n");
+		      goto error_return;
+		  }
+
+		  if (library_name == NULL) {
+		      (*p_compress_or_decompress)(
+			   secinit_table[i].u.compress.algo_name, compress,
+			   contents, sec_size, 
+			   output_contents, &size);
+		  } else {
+#if DEBUG_COMPRESSION
+		      printf("Before calling decompression in shared lib: %s()\n", compress_name);
+#endif
+		      (*p_compress)(contents, sec_size, 
+				    output_contents, &size);
+#if DEBUG_COMPRESSION
+		      printf("After call to decompression in shared lib: %s()\n", compress_name);
+#endif
+
+		  }
+		  if (size != secinit_table[i].u.compress.size)
+		      printf("Warning: Decompressed size (%d) != Initial section size in secinit (%d)!\n", size, secinit_table[i].u.compress.size);
+		  
+		  secinit_table[i].u.compress.compressed_size = 0;
+#if DEBUG_COMPRESSION
+		  printf("Decompress section %s \n", sec_name);
+#endif
+	      } else {
+#if DEBUG_COMPRESSION
+		  printf("Section not or already decompressed %s \n", sec_name);
+#endif
+	      }
+          }
+	  if ((output_contents == NULL) || 
+	      ! bfd_set_section_contents (abfd, sec, output_contents,
+					  (file_ptr) 0, size))
+		  goto error_return;
+        }
+          break;
+        case secinit_memory_data_enum:
+	    if (compress) {
+		if (secinit_table[i].u.copy.lma == bfd_section_lma(abfd, sec) &&
+		    secinit_table[i].u.copy.vma == bfd_section_vma(abfd, sec) ) {
+#if DEBUG_COMPRESSION
+		    printf("Found section to copy: %s \n", 
+			   bfd_get_section_name(abfd, sec));
+#endif
+
+		    /* Fill lma-ordered list of sections that have a lma != vma */
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name = 
+			(char *) bfd_malloc(strlen (sec_name) + 1);
+		    if (elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name == NULL) {
+			printf("Error: memory allocation failed\n");
+			goto error_return;
+		    }
+		    strcpy(elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].sec_name, sec_name);
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].secinit_index = i;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_lma = 
+			secinit_table[i].u.copy.lma;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_lma = 0;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].initial_size = sec_size;
+		    elf_lx_cpt_tab_[elf_lx_cpt_tab_nb].compress_size = sec_size;
+		    elf_lx_cpt_tab_nb++;
+		} 
+	    } else {
+		printf("Decompression not yet handled!\n");
+	    }
+	  break;
+        default:
+          break;
+        }
+      }
+    }
+
+    if (elf_lx_cpt_tab_nb == 0) {
+	/* Nothing to do */
+	return TRUE;
+    }
+
+    if (compress) {
+	/* Order list of sections that have a lma != vma */
+	elf_lx_cpt_tab = (struct elf_lx_cpt **) 
+	    bfd_malloc(elf_lx_cpt_tab_nb * 
+		       sizeof (struct elf_lx_cpt *));
+	if (elf_lx_cpt_tab == NULL) {
+	    printf("Error: memory allocation failed\n");
+	    goto error_return;
+	}
+
+	for (i = 0; i < elf_lx_cpt_tab_nb; i++) {
+	    elf_lx_cpt_tab[i] = &elf_lx_cpt_tab_[i];
+	}
+	
+	qsort (elf_lx_cpt_tab, (size_t) elf_lx_cpt_tab_nb,
+	       sizeof (struct elf_lx_cpt *), elf_lx_sort_sections_by_lma);
+	
+	/* 
+	 * Compute new lma addresses taking into account compressed 
+	 * sizes of sections.
+	 * Skip first section that cannot be impacted by previous 
+	 * compressed section.
+	 */
+	shift = 0;
+	elf_lx_cpt_tab[0]->compress_lma = elf_lx_cpt_tab[0]->initial_lma;
+	for (i = 1;  i < elf_lx_cpt_tab_nb; i++) {
+	    if (elf_lx_cpt_tab[i - 1]->initial_size >= 
+		elf_lx_cpt_tab[i - 1]->compress_size) {
+		shift += (elf_lx_cpt_tab[i - 1]->initial_size -
+			  elf_lx_cpt_tab[i - 1]->compress_size);
+		elf_lx_cpt_tab[i]->compress_lma =
+		    elf_lx_cpt_tab[i]->initial_lma - shift;
+	    } else {
+		printf("Error: compressed section size bigger than initial size\n");
+		goto error_return;
+	    }	  
+	}
+
+#if DEBUG_COMPRESSION
+	printf("\n");
+	elf_lx_cpt_tab_dump(elf_lx_cpt_tab, elf_lx_cpt_tab_nb, stdout);
+	printf("\n");
+#endif
+
+	/* Update the lma address in the secinit table */
+	for (i = 0; i < elf_lx_cpt_tab_nb; i ++) {
+	    int si_index = elf_lx_cpt_tab[i]->secinit_index;
+	    
+	    switch (secinit_table[si_index].type) {
+	    case secinit_memory_compress_enum:
+		secinit_table[si_index].u.compress.lma = 
+		    elf_lx_cpt_tab[i]->compress_lma;
+		break;
+	    case secinit_memory_data_enum:
+		secinit_table[si_index].u.copy.lma =
+		    elf_lx_cpt_tab[i]->compress_lma;
+		break;
+	    default:
+		break;
+	    }
+	}
+    }
+
+    elf_lx_set_secinit_table(abfd, secinit_table, secinit_table_entry_nb);
+#if DEBUG_COMPRESSION
+    elf_lx_dump_secinit_table(abfd, stdout);
+#endif
+  }
+
+  return TRUE;
+
+error_return:
+  printf("Error: Problem while compressing/decompressing \n");
+
+  return FALSE;
+}
+#endif /* ndef NO_COMPRESSION_SUPPORT */
+
+static enum elf_reloc_type_class
+elf_lx_reloc_type_class (
+			 const Elf_Internal_Rela *rela)
+{
+  switch ((int) ELF32_R_TYPE (rela->r_info))
+    {
+    case R_LX_REL32:
+      return reloc_class_relative;
+    case R_LX_IPLT:
+    case R_LX_JMP_SLOT:
+      return reloc_class_plt;
+    case R_LX_COPY:
+      return reloc_class_copy;
+    default:
+      return reloc_class_normal;
+    }
+}
+
+/* Merge non visibility st_other attributes. Ensure that the
+   STO_MOVEABLE and STO_USED flags for Binopt are copied into h->other, 
+   even if this is not a definiton of the symbol. */
+static void
+elf_lx_merge_symbol_attribute (struct elf_link_hash_entry *h,
+			       const Elf_Internal_Sym *isym,
+			       bfd_boolean definition,
+			       bfd_boolean dynamic ATTRIBUTE_UNUSED)
+{
+  if ((isym->st_other & ~ELF_ST_VISIBILITY (-1)) != 0)
+    {
+      unsigned char other;
+
+      other = (definition ? isym->st_other : h->other);
+      other &= ~ELF_ST_VISIBILITY (-1);
+      h->other = other | ELF_ST_VISIBILITY (h->other);
+
+      if (!definition
+	  && is_STO_MOVEABLE (isym->st_other))
+	  h->other |= STO_MOVEABLE;
+
+      if (!definition
+	  && is_STO_USED (isym->st_other))
+	  h->other |= STO_USED;
+    }
+}
+
+/*specific print_symbol  */
+static const char *
+lx_elf_print_symbol_all (
+			 bfd *abfd ATTRIBUTE_UNUSED,
+			 PTR filep,
+			 asymbol *symbol)
+{
+  if (symbol->name == NULL || symbol->name [0] == '\0')
+    /* Will be treated as if lx_elf_print_symbol_all were not defined */
+    return NULL;
+  else {
+    char *name;
+    size_t len;
+    unsigned char st_other;
+    bfd_print_symbol_vandf (abfd, (PTR) filep, symbol);
+    st_other = ((elf_symbol_type *) symbol)->internal_elf_sym.st_other;
+    len = strlen (symbol->name) + strlen(" (moveable)") + strlen (" (used)") + 1;
+    name = bfd_alloc (abfd, (bfd_size_type) len);
+    memcpy (name, symbol->name, strlen (symbol->name)+1);
+    if (is_STO_MOVEABLE(st_other)) {
+      sprintf (name, "%s (moveable)", name);
+    }
+    if (is_STO_USED(st_other)) {
+      sprintf (name, "%s (used)", name);
+    }
+    return name;
+  }
+}
+
+/* What to do when ld finds relocations against symbols defined in
+   discarded sections.  */
+
+static unsigned int
+elf_lx_action_discarded (asection *sec)
+{
+  if (strcmp (".profile_info", sec->name) == 0)
+    return 0;
+
+  return _bfd_elf_default_action_discarded (sec);
+}
+
+#ifndef ELF_ARCH
+#define TARGET_BIG_SYM		        bfd_elf32_lx_vec
+#define TARGET_BIG_NAME		        "elf32-lx"
+#define TARGET_LITTLE_SYM               bfd_elf32_littlelx_vec
+#define TARGET_LITTLE_NAME              "elf32-littlelx"
+#define ELF_ARCH			bfd_arch_lx
+#define ELF_MACHINE_CODE		EM_LX
+#define ELF_MACHINE_ALT1		EM_LX_OLD
+#define ELF_MAXPAGESIZE         	0x1
+#endif /* ELF_ARCH */
+
+#define elf_backend_object_p \
+        lx_elf_object_p
+#define bfd_elf32_bfd_is_local_label_name \
+        lx_elf_is_local_label_name
+#define elf_info_to_howto \
+	lx_info_to_howto
+#define elf_info_to_howto_rel \
+        lx_info_to_howto_rel	  
+#define elf_backend_relocate_section \
+        elf_lx_relocate_section
+#define elf_backend_output_arch_local_syms \
+        elf_lx_output_arch_local_syms
+#define bfd_elf32_bfd_set_private_flags	\
+        lx_elf_set_private_flags
+#define bfd_elf32_bfd_get_private_flags \
+        lx_elf_get_private_flags
+#define bfd_elf32_bfd_merge_private_bfd_data \
+        lx_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_print_private_bfd_data \
+        lx_elf_print_private_bfd_data
+#define bfd_elf32_bfd_link_hash_table_create \
+        elf_lx_hash_table_create
+#define bfd_elf32_bfd_link_hash_table_free \
+        elf_lx_hash_table_free
+#define bfd_elf32_bfd_relax_section \
+        elf_lx_relax_section
+#define elf_backend_create_dynamic_sections \
+        elf_lx_create_dynamic_sections
+#define elf_backend_check_relocs \
+        elf_lx_check_relocs
+#define elf_backend_gc_sweep_hook \
+        elf_lx_gc_sweep_hook
+#define elf_backend_adjust_dynamic_symbol \
+        elf_lx_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections \
+        elf_lx_size_dynamic_sections
+#define elf_backend_relocate_section \
+        elf_lx_relocate_section
+#define elf_backend_finish_dynamic_symbol \
+        elf_lx_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections \
+        elf_lx_finish_dynamic_sections
+#define elf_backend_merge_symbol_attribute \
+        elf_lx_merge_symbol_attribute
+#define elf_backend_action_discarded \
+        elf_lx_action_discarded
+
+#define elf_backend_plt_readonly	1
+#define elf_backend_want_plt_sym	0
+#define elf_backend_plt_alignment	5
+#define elf_backend_got_header_size	12
+#define elf_backend_plt_header_size	PLT_HEADER_SIZE
+#define elf_backend_want_got_plt	1
+#define elf_backend_may_use_rel_p	1
+#define elf_backend_may_use_rela_p	1
+#define elf_backend_default_use_rela_p	1
+#define elf_backend_want_dynbss		1
+#define elf_backend_copy_indirect_symbol elf_lx_hash_copy_indirect
+#define elf_backend_hide_symbol		elf_lx_hash_hide_symbol
+#define elf_backend_reloc_type_class	elf_lx_reloc_type_class
+#define elf_backend_rela_normal		1
+#define elf_backend_can_gc_sections	1
+
+#define bfd_elf32_bfd_copy_private_bfd_data    lx_elf_copy_private_flags
+
+#define elf_backend_print_symbol_all \
+  lx_elf_print_symbol_all
+
+#undef elf_backend_can_make_relative_eh_frame
+#define elf_backend_can_make_relative_eh_frame \
+		elf_lx_use_relative_eh_frame
+#undef elf_backend_can_make_lsda_relative_eh_frame
+#define elf_backend_can_make_lsda_relative_eh_frame \
+		elf_lx_use_relative_eh_frame
+
+#include "elf32-target.h"
+
+
+
diff --git a/bfd/elf32-lx.h b/bfd/elf32-lx.h
new file mode 100644
index 0000000..9d01398
--- /dev/null
+++ b/bfd/elf32-lx.h
@@ -0,0 +1,64 @@
+/* ELF/LX support
+
+   This file contains ELF/LX relocation support as specified
+   in the ST200 ELF Specification, 2004.
+
+   Copyright 2004
+   Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef _ELF32_LX_H
+#define _ELF32_LX_H
+
+#include "elf-bfd.h"
+#include "elf/lx.h"
+
+void lx_elf_init_stub_bfd
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+void elf_lx_next_input_section
+  PARAMS ((struct bfd_link_info *, asection *));
+
+int elf_lx_setup_section_lists
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+bfd_boolean elf_lx_size_stubs
+  PARAMS ((bfd *, bfd *, struct bfd_link_info *, bfd_signed_vma,
+	   asection * (*) PARAMS ((const char *, asection *)),
+	   void (*) PARAMS ((void))));
+
+bfd_boolean elf_lx_set_gp
+  PARAMS ((bfd *, struct bfd_link_info *));
+
+bfd_boolean elf_lx_build_stubs
+  PARAMS ((struct bfd_link_info *));
+
+bfd_boolean elf_lx_secinit_compress_or_decompress
+  PARAMS ((bfd *, bfd_boolean, char *));
+
+int elf_lx_get_compact_info 
+  PARAMS ((bfd *, sec_ptr, bfd_vma *, bfd_vma *,
+	   bfd_size_type *, bfd_size_type *));
+
+void lx_elf_dump_target_info
+PARAMS ((bfd *, FILE *));
+
+void
+bfd_elf32_lx_set_transform_to_absolute
+  PARAMS((struct bfd_link_info *, bfd_boolean value));
+#endif /* _ELF32_LX_H */
diff --git a/bfd/elflink.c b/bfd/elflink.c
index 3a00a51..cc37846 100644
--- a/bfd/elflink.c
+++ b/bfd/elflink.c
@@ -29,6 +29,39 @@
 #include "libiberty.h"
 #include "objalloc.h"
 
+#ifdef IPA_LINK
+#define SHN_IPA_TEXT     0xff01         /* Allocated text symbols.  */
+#define SHN_IPA_DATA     0xff02         /* Allocated data symbols.  */
+#endif
+
+#ifdef IPA_LINK
+extern int ipa_set_ndx(bfd *);
+int ld_set_ndx (bfd *);
+#pragma weak ld_set_ndx
+int
+ld_set_ndx (bfd *abfd)
+{
+#if 0
+    return 0;
+#else
+    return ipa_set_ndx(abfd);
+#endif
+}
+
+extern bfd_boolean is_ipa;
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+extern void
+ipa_process_whirl_in_archive ( bfd *, bfd *);
+
+#include "ipa_bfd.h" /* [CL] needed for symbol_comdat() */
+#include "elf-bfd.h" /* [CL] needed to support comdat: need to get ipa_indx */
+
+#endif /* IPA_LINK */
+
+
 /* Define a symbol in a dynamic linkage section.  */
 
 struct elf_link_hash_entry *
@@ -884,7 +917,18 @@ _bfd_elf_merge_symbol (bfd *abfd,
 
   /* This code is for coping with dynamic objects, and is only useful
      if we are doing an ELF link.  */
+#ifdef IPA_LINK
+  /* [CL] when linking with a Whirl object, we must
+   * handle the alternative target (ie opposite endianness)
+   * because Whirl objects are encoded using the host's endianness
+   * which may or may not be the target's one */
+  if ( (info->hash->creator != abfd->xvec) &&
+       ( is_ipa && ipa_is_whirl(abfd) &&
+	 (info->hash->creator != abfd->xvec->alternative_target) )
+       )
+#else
   if (info->output_bfd->xvec != abfd->xvec)
+#endif
     return TRUE;
 
   /* For merging, we only care about real symbols.  */
@@ -905,11 +949,28 @@ _bfd_elf_merge_symbol (bfd *abfd,
   if (h->root.type == bfd_link_hash_new)
     {
       h->non_elf = 0;
+#ifdef IPA_LINK
+      /*
+        For SGI intermediate WHIRL format we need to mark the
+        symbol.
+      */
+      h->ipa_indx = ld_set_ndx (abfd);
+      /* [CL] store current bfd for this symbol */
+      if (is_ipa && ipa_is_whirl(abfd))
+	h->root.ipa_bfd = abfd;
+      else
+	h->root.ipa_bfd = NULL;
+#endif
       return TRUE;
     }
 
   /* OLDBFD and OLDSEC are a BFD and an ASECTION associated with the
      existing symbol.  */
+#ifdef IPA_LINK
+  if (h->root.ipa_bfd) {
+    oldbfd = h->root.ipa_bfd;
+  } else {
+#endif
 
   switch (h->root.type)
     {
@@ -935,6 +996,9 @@ _bfd_elf_merge_symbol (bfd *abfd,
       oldsec = h->root.u.c.p->section;
       break;
     }
+#ifdef IPA_LINK
+  }
+#endif
 
   /* In cases involving weak versioned symbols, we may wind up trying
      to merge a symbol with itself.  Catch that here, to avoid the
@@ -955,12 +1019,20 @@ _bfd_elf_merge_symbol (bfd *abfd,
   olddyn = FALSE;
   if (oldbfd != NULL)
     olddyn = (oldbfd->flags & DYNAMIC) != 0;
-  else if (oldsec != NULL)
+  else {
+#ifdef IPA_LINK 
+    /* [CL] IPA sections do not contain information selected above,
+       so ignore it */
+    if (is_ipa && ipa_is_whirl(abfd))
+      oldsec = NULL;
+#endif
+    if (oldsec != NULL)
     {
       /* This handles the special SHN_MIPS_{TEXT,DATA} section
 	 indices used by MIPS ELF.  */
       olddyn = (oldsec->symbol->flags & BSF_DYNAMIC) != 0;
     }
+  }
 
   /* NEWDEF and OLDDEF indicate whether the new or old symbol,
      respectively, appear to be a definition rather than reference.  */
@@ -1543,6 +1615,14 @@ _bfd_elf_add_default_symbol (bfd *abfd,
 	      0, name, FALSE, collect, &bh)))
 	return FALSE;
       hi = (struct elf_link_hash_entry *) bh;
+#if 0 /* [SC] This code breaks glibc build. */
+#ifdef IPA_LINK
+      if ((flags & BSF_WEAK) != 0) {
+	hi->weakdef = h->weakdef;
+	weaks = hi;
+      }
+#endif // IPA_LINK
+#endif
     }
   else
     {
@@ -3844,6 +3924,12 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	     calls the value we call the alignment.  */
 	  value = isym->st_size;
 	}
+#ifdef IPA_LINK
+      else if (isym->st_shndx == SHN_IPA_TEXT)
+        sec = bfd_whirl_text_section_ptr;
+      else if (isym->st_shndx == SHN_IPA_DATA)
+        sec = bfd_whirl_data_section_ptr;
+#endif
       else
 	{
 	  /* Leave it up to the processor backend.  */
@@ -3884,6 +3970,36 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	    continue;
 	}
 
+#ifdef IPA_LINK
+      /* Handle the case of symbols in GNU LINK_ONCE sections
+       * in context of Open64-IPA. Without this code, a multiple
+       * define of linkonce symbols will occur.
+       */
+      if (! bfd_is_und_section (sec)) {
+	struct elf_link_hash_entry *old_h;
+	
+	old_h = elf_link_hash_lookup (elf_hash_table (info), 
+				      name, FALSE, FALSE, FALSE);
+	if (old_h != NULL) {
+	  asection *old_sec;
+	  
+	  if ((old_h->root.type == bfd_link_hash_defined) || 
+	      (old_h->root.type == bfd_link_hash_defweak)) {
+	    old_sec = old_h->root.u.def.section;
+
+	    /* [CL] support for linkonce attribute. */
+	    if (is_ipa && ipa_is_whirl(old_h->root.ipa_bfd) &&
+		(*p_symbol_linkonce)(old_h->ipa_indx)) {
+	      /* Previous symbol is in LINK ONCE section. 
+		 We discard it. */
+	      *sym_hash = old_h;
+	      continue;
+	    }
+	  }
+	}
+      }
+#endif /* IPA_LINK */
+
       /* Sanity check that all possibilities were handled.  */
       if (sec == NULL)
 	{
@@ -4268,6 +4384,9 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
 	    {
 	      if (! definition)
 		{
+#ifdef IPA_LINK
+                  if (!ipa_is_whirl(abfd))
+#endif
 		  h->ref_regular = 1;
 		  if (bind != STB_WEAK)
 		    h->ref_regular_nonweak = 1;
@@ -4953,8 +5072,13 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 	     something wrong with the archive.  */
 	  if (element->archive_pass != 0)
 	    {
+#ifdef IPA_LINK
+              /* Already got this obj, skip it and continue */
+              continue;
+#else
 	      bfd_set_error (bfd_error_bad_value);
 	      goto error_return;
+#endif
 	    }
 	  element->archive_pass = 1;
 
@@ -4965,7 +5089,16 @@ elf_link_add_archive_symbols (bfd *abfd, struct bfd_link_info *info)
 	    goto error_return;
 	  if (! bfd_link_add_symbols (element, info))
 	    goto error_return;
-
+#ifdef IPA_LINK
+	  /* [CL] support archive elements containing Whirl
+	     instead of plain object code */
+          if (is_ipa) {
+            ld_set_cur_obj(element);
+            if (ipa_is_whirl(element)) {
+              ipa_process_whirl_in_archive(abfd, element);
+            }
+          }
+#endif
 	  /* If there are any new undefined symbols, we need to make
 	     another pass through the archive in order to see whether
 	     they can be defined.  FIXME: This isn't perfect, because
diff --git a/bfd/ipa_bfd.c b/bfd/ipa_bfd.c
new file mode 100644
index 0000000..5df796a
--- /dev/null
+++ b/bfd/ipa_bfd.c
@@ -0,0 +1,626 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifdef IPA_LINK
+
+#if defined(__GNUC__)
+#include <stdio.h>		/* for sys_errlist */
+#endif
+#include <stdlib.h>		/* for getenv(3) */
+#include <unistd.h>		/* for unlink(2), rmdir(2), etc. */
+
+#if defined(__CYGWIN__) || defined(_WIN32) 
+#include "libiberty.h"		/* for basename(3) */
+#else
+#include <libgen.h>		/* for basename(3) */
+#endif
+
+#include <sys/stat.h>		/* for chmod(2) */
+
+#include <fcntl.h>		/* for open(2) */
+#if defined(sun) || defined(__CYGWIN__) || defined (_WIN32)
+#include <sys/types.h>
+#include <dirent.h>
+#else
+#include <sys/dir.h>		/* for opendir(2), readdir, closedir */
+#endif
+#include <signal.h>		/* for kill(2) */
+#include <limits.h>		/* for PATH_MAX */
+#include <errno.h>
+#include <string.h>
+
+
+#include "aout/ar.h"
+
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+
+#include "ipa_bfd.h"
+
+#include "strings.h"            /* for memcopy() */
+
+#if defined(__CYGWIN__)
+#include <sys/cygwin.h>         /* [CL] for cygwin_conv_to_full_posix_path */
+#endif
+
+extern bfd_boolean is_ipa;
+
+void *(*p_ipa_open_input)(char *, off_t *, int, char**) = NULL;
+void (*p_ipa_init_link_line)(int, char **) = NULL;
+void (*p_ipa_add_link_flag)(const char*) = NULL;
+void (*p_ipa_driver)(int, char **) = NULL;
+void (*p_process_whirl64)(void *, int, void *, int, const char *) = NULL;
+int  (*p_Count_elf_external_gots)(void) = NULL;
+void (*p_ipa_insert_whirl_marker)(void) = NULL;
+void (*p_Sync_symbol_attributes)(unsigned int, unsigned int, bfd_boolean, unsigned int) = NULL;
+bfd_boolean (*p_symbol_comdat)(unsigned int) = NULL;
+bfd_boolean (*p_symbol_linkonce)(unsigned int) = NULL;
+void (*p_ipa_initialize_external_symbols)(struct external_symbols_list*) = NULL;
+
+static mode_t cmask = 0;	    /* file creation mode mask */
+
+static string_t *tmp_list = 0;
+static int tmp_list_size = 0;
+static int tmp_list_max = 0;
+string_t tmpdir = 0;
+static int tmpdir_length = 0;
+
+static bfd *p_current_bfd = NULL;
+
+string_t outfilename = "./a.out";
+
+int ipa_argc = 0;
+char ** ipa_argv = NULL;
+
+LD_IPA_OPTION ld_ipa_opt[] = {
+/************************************************/
+/*  ld_ipa_option_enum	    flag	    set */
+/************************************************/
+    {LD_IPA_SHARABLE, 	    F_NON_SHARED,   F_NON_SHARED}, 
+    {LD_IPA_DEMANGLE, 	    0,		    0}, 
+    {LD_IPA_SHOW, 	    0,		    0}, 
+    {LD_IPA_HIDES, 	    0,		    0}, 
+    {LD_IPA_TARGOS, 	    TOS_IA64_64,    0}, 
+    {LD_IPA_VERBOSE,	    0,		    0},
+    {LD_IPA_KEEP_TEMPS,	    0,		    0},
+    {LD_IPA_ISA,	    0,		    0},
+    {LD_IPA_RELOCATABLE,    0,		    0},
+    {LD_IPA_EXPORTS, 	    0,		    0}, 
+    {LD_IPA_XXXX, 	    0,		    0}
+};
+
+
+string_t
+make_temp_file_with_suffix (string_t, char);
+void
+ipa_set_def_bfd(bfd *, struct bfd_link_hash_entry *);
+void
+ipa_process_whirl_in_archive ( bfd *archive, bfd *abfd);
+
+
+	/*******************************************************
+		Function: ipa_copy_of
+
+		Allocate for and copy given string into a copy.
+
+	 *******************************************************/
+char *
+ipa_copy_of (char *str)
+{
+    register int len;
+    register char *p;
+
+    len = strlen(str) + 1;
+    p = (char *) MALLOC (len);
+    MALLOC_ASSERT (p);
+    MEMCPY (p, str, len);
+    return p;
+} /* ipa_copy_of */
+
+
+	/*******************************************************
+		Function: concat_names
+
+		Create a new string by concating 2 other strings.
+
+	 *******************************************************/
+string_t
+concat_names(const string_t name1, const string_t name2)
+{
+    char *mangled_name = NULL;
+    int len = strlen(name1)+strlen(name2)+1;
+
+    mangled_name = (char *)MALLOC(len);
+    MALLOC_ASSERT(mangled_name);
+
+    strcpy(mangled_name, name1);
+    strcat(mangled_name, name2);
+
+    return(mangled_name);
+}
+
+
+
+	/*******************************************************
+		Function: add_to_tmp_file_list
+
+		Maintain list of temp. files created so they are all
+		removed on error or when done.  Assume the first entry
+		is "tmpdir".
+
+	 *******************************************************/
+void
+add_to_tmp_file_list (string_t path)
+{
+    if (tmp_list_max == 0) {
+	tmp_list_max = DEFAULT_TMP_LIST_SIZE;
+	tmp_list = (string_t *) MALLOC (tmp_list_max * sizeof(string_t));
+	MALLOC_ASSERT (tmp_list);
+    } else if (tmp_list_size >= tmp_list_max) {
+	tmp_list_max *= 2;
+	tmp_list = (string_t *)REALLOC (tmp_list, tmp_list_max * sizeof(string_t));
+	MALLOC_ASSERT (tmp_list);
+    }
+
+    tmp_list[tmp_list_size++] = path;
+
+} /* add_to_tmp_file_list */
+
+	/*******************************************************
+		Function: make_temp_file_with_suffix
+
+		Create a unique file
+
+	 *******************************************************/
+/* create a unique file */
+string_t
+make_temp_file_with_suffix (string_t name, char suffix)
+{
+    char path[PATH_MAX];
+    int len;
+    int count = 1;
+
+    len = strlen (name);
+    if (len+4 >= PATH_MAX) {
+	fprintf(stderr,"%s %s\n","path name too long:", name);
+	exit(1);
+    }
+
+    strcpy (path, name);
+
+    if (suffix && len >= 2) {
+	/* remove the original suffix */
+	if (path[len-2] == '.') {
+	    len -= 2;
+	    path[len] = 0;
+	}
+    }
+
+    if (suffix) {
+	path[len] = '.';
+	path[len+1] = suffix;
+	path[len+2] = 0;
+    }
+
+    if (access (path, F_OK) != 0)
+	return ipa_copy_of (path);
+
+    do {
+	if (suffix)
+	    sprintf (&(path[len]), ".%d.%c", count, suffix);
+	else
+	    sprintf (&(path[len]), "%d", count);
+	count++;
+    } while (access (path, F_OK) == 0);
+
+    return ipa_copy_of (path);
+
+} /* make_temp_file_with_suffix */
+
+/* ====================================================================
+ *
+ * create_tmpdir
+ *
+ * Create a temporary directory for (1) relocatable objects generated
+ * from the backend under IPA control, (2) IR objects extracted from an
+ * archive, and (3) IR objects generated by IPA.
+ *
+ * There are three cases.  If this is a directory to be kept, because
+ * either -keep or a trace flag is specified for an IPA build, then the
+ * directory is named <outfilename>.ipakeep, and if it already exists,
+ * all files are cleared from it.  If it is a temporary directory for
+ * an IPA build, a unique name is used with the template
+ * $TMPDIR/<outfilename_with_path_stripped>.ipaXXXXXX .  For a normal link, 
+ * a temporary directory
+ * is created in the DEFAULT_TMPDIR with the name template XXXXXX.
+ *
+ * ====================================================================
+ */
+
+int
+create_tmpdir ( int tracing )
+{
+    int fixedname = is_ipa && ( ld_ipa_opt[LD_IPA_KEEP_TEMPS].flag );
+
+    /* [CL] If we have already created tmpdir, return immediately:
+       this condition occurs when extracting Whirl files from an
+       archive; in this case, create_tmpdir() is called twice:
+       first when extracting from archive, second from ipa_driver()
+    */
+    if (tmpdir) return 0;
+
+    if ( is_ipa ) {
+	if ( fixedname ) {
+	    tmpdir = concat_names ( outfilename, ".ipakeep" );
+	} else {
+	    char *tmpdir_env_var;
+	    if ((tmpdir_env_var = getenv("TMPDIR")) != NULL) {
+		char *filename;
+	        tmpdir_env_var = concat_names ( tmpdir_env_var, "/");
+		if ((filename = strrchr(outfilename, '/')) != NULL)
+		    filename++;
+		else
+		    filename = outfilename;
+		
+	        tmpdir = concat_names ( tmpdir_env_var, filename);
+	    }
+	    else
+	        tmpdir = outfilename;
+	    tmpdir = concat_names ( tmpdir, ".ipaXXXXXX" );
+	}
+    } else {
+	tmpdir = concat_names ( DEFAULT_TMPDIR, "XXXXXX" );
+    }
+#if defined(__CYGWIN__)
+    char posix_driver_directory[_POSIX_PATH_MAX] ;
+    cygwin_conv_to_full_posix_path(tmpdir, posix_driver_directory) ;
+    tmpdir = ipa_copy_of(posix_driver_directory);
+#endif
+    if ( ! fixedname ) {
+	tmpdir = mktemp ( tmpdir );
+    }
+
+    tmpdir_length = strlen ( tmpdir );
+
+    if ( cmask == 0 ) {
+	cmask = umask (0);
+	(void) umask (cmask);
+    }
+
+    if ( MKDIR (tmpdir, 0777 & ~cmask) != 0 ) {
+	if ( errno == EEXIST && fixedname ) {
+	    /* We have an old instance of this directory -- clear it out: */
+	    DIR *dirp;
+#if defined(sun) || defined(__CYGWIN__) || defined (_WIN32)
+	    struct dirent *entryp;
+#else
+	    struct direct *entryp;
+#endif
+	    char *prefix;
+
+	    dirp = opendir ( tmpdir );
+	    if ( dirp != NULL ) {
+		prefix = concat_names ( tmpdir, "/" );
+		while ( ( entryp = readdir(dirp) ) != NULL ) {
+		    /* Don't bother with names of one or two characters, e.g. '.'
+		     * and '..', since we don't create temporary files with such
+		     * names:
+		     */
+#if defined(sun) || defined(__CYGWIN__) || defined (_WIN32)
+		  if ( strlen(entryp->d_name) > 2)
+#elif defined(_DIRENT_HAVE_D_NAMLEN)
+		  if ( entryp->d_namlen > 2 )
+#else
+		  if (_D_EXACT_NAMLEN(entryp) > 2)
+#endif
+		    {
+			string_t fname = concat_names ( prefix, entryp->d_name);
+			unlink (fname);
+			FREE (fname);
+		    }
+		}
+		FREE (prefix);
+		closedir ( dirp );
+	    }
+	} else {
+    	    perror("cannot create temporary directory for code generation");
+	    return -1;
+	}
+    }
+
+    add_to_tmp_file_list ( tmpdir );
+
+    if (tracing) {
+#if 0
+      printf("Created tmp dir %s\n", tmpdir);
+#endif
+    }
+    return 0;
+
+} /* create_tmpdir */
+
+	/*******************************************************
+		Function: create_unique_file
+
+		
+
+	 *******************************************************/
+string_t
+create_unique_file (const string_t path, char suffix)
+{
+    string_t p;
+    string_t base = basename (path);
+    string_t new_path;
+    int fd;
+
+    /* length of tmpdir + basename of path and '/' between the dir
+       and the basename + null terminator */
+    p = (string_t) MALLOC (strlen(tmpdir) + strlen(base) + 2);
+    MALLOC_ASSERT (p);
+    strcpy (p, tmpdir);
+    strcat (p, "/");
+    strcat (p, base);
+    new_path = make_temp_file_with_suffix (p, suffix);
+    FREE (p);
+
+    if ((fd = creat (new_path, 0666 & ~cmask)) == -1) {
+	perror(new_path);
+	exit(1);
+    }
+
+    CLOSE (fd);
+    
+    return new_path;
+
+} /* create_unique_file */
+
+
+	/*******************************************************
+		Function: create_unique_file_in_curdir
+                [CL] do not create file in tmpdir, but in
+                current directory. Useful for cleanup		
+
+	 *******************************************************/
+string_t
+create_unique_file_in_curdir (const string_t path, char suffix)
+{
+    string_t p;
+    string_t base = basename (path);
+    string_t new_path;
+    int fd;
+
+    /* length of tmpdir + basename of path and '/' between the dir
+       and the basename + null terminator */
+    p = (string_t) MALLOC (strlen(base) + 2);
+    MALLOC_ASSERT (p);
+    strcpy (p, base);
+    new_path = make_temp_file_with_suffix (p, suffix);
+    FREE (p);
+
+    if ((fd = creat (new_path, 0666 & ~cmask)) == -1) {
+	perror(new_path);
+	exit(1);
+    }
+
+    CLOSE (fd);
+    
+    return new_path;
+
+} /* create_unique_file_in_curdir */
+
+
+
+	/*******************************************************
+		Function: ipa_set_ndx
+
+		This field cannot be used beyond
+		the pass1 phase.
+	 *******************************************************/
+int
+ipa_set_ndx (bfd *abfd)
+{
+    if (ipa_is_whirl(abfd))
+      	return WHIRL_ST_IDX_UNINITIALIZED;
+    else
+      	return WHIRL_ST_IDX_NOT_AVAILABLE;
+}
+
+	/*******************************************************
+		Function: ipa_set_def_bfd
+
+
+	 *******************************************************/
+void
+ipa_set_def_bfd(bfd *abfd, struct bfd_link_hash_entry *p_bfd_hash)
+{
+    if (is_ipa)
+    	p_bfd_hash->u.def.section = (asection *)abfd;
+}
+
+	/*******************************************************
+		Function: ld_set_cur_bfd
+
+
+	 *******************************************************/
+void 
+ld_set_cur_obj(bfd *abfd)
+{
+    p_current_bfd = (bfd *)abfd;
+}
+
+
+
+	/*******************************************************
+		Function: ld_get_cur_bfd
+
+
+	 *******************************************************/
+void *
+ld_get_cur_obj(void)
+{
+    return p_current_bfd;
+}
+
+	/*******************************************************
+		Function: ipa_is_whirl
+
+
+	 *******************************************************/
+#define ET_SGI_IR   (ET_LOPROC + 0)
+
+bfd_boolean
+ipa_is_whirl(bfd *abfd)
+{
+    Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header, internal form */
+
+    i_ehdrp = elf_elfheader (abfd);
+
+    if (i_ehdrp->e_type == ET_SGI_IR) {
+    	    return(TRUE);
+    }
+
+    return(FALSE);
+}
+
+
+	/*******************************************************
+		Function: ipa_process_whirl
+
+		I need to read the WHIRL symbol table so the
+		internal mechanisms of IPA will have their 
+		data structures correctly filled out.
+		
+		Since IPA needs an mmapped view of the object
+		I'm trying to remap it here. It is not ready
+		for archives yet.
+		
+		I am overloading the usrdata field of the bfd
+		with the assumption that bfd is done with it.
+		
+	 *******************************************************/
+void
+ipa_process_whirl ( bfd *abfd) 
+{
+
+    off_t mapped_size;
+    abfd->usrdata = (PTR)(*p_ipa_open_input)((char *)abfd->filename, &mapped_size, ipa_argc, ipa_argv);
+    (*p_process_whirl64) ( 
+    	    	(void *)abfd, 
+    	    	elf_elfheader (abfd)->e_shnum, 
+		abfd->usrdata+elf_elfheader(abfd)->e_shoff,
+	        0, /* check_whirl_revision */
+		abfd->filename);
+}
+
+
+
+#define MAX_RBUF_SIZE 1*1024*1024
+	/*******************************************************
+		Function: ipa_process_whirl_in_archive
+
+	 *******************************************************/
+void
+ipa_process_whirl_in_archive ( bfd *archive, bfd *abfd) 
+{
+  FILE *fd = NULL, *tmp_fd = NULL;
+  int elem_size = arelt_size (abfd);
+  off_t mapped_size;
+  string_t input_path;
+  string_t file_name = (string_t)abfd->filename;
+  void *rbuf = NULL;
+  size_t size_buf = 0;
+  long cur_size = 0;
+  int seek_pos = 0;
+
+#define ARCHIVE_ERROR_MESSAGE " cannot process archive member "
+  int n=strlen(archive->filename) + strlen(abfd->filename) + strlen(ARCHIVE_ERROR_MESSAGE);
+  char archive_msg[n];
+  sprintf(archive_msg, "%s" ARCHIVE_ERROR_MESSAGE "%s",
+	  archive->filename, abfd->filename);
+
+  if ( (fd = fopen(archive->filename, "rb")) == NULL) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  if (elem_size > MAX_RBUF_SIZE) {
+      rbuf = (void *) MALLOC(MAX_RBUF_SIZE);
+      MALLOC_ASSERT(rbuf);
+      size_buf = MAX_RBUF_SIZE;
+  } else {
+      rbuf = (void *) malloc(elem_size);
+      size_buf = elem_size;
+  }
+
+  memset(rbuf, 0, size_buf);
+
+  /* Start copying from the begining of the current object file in the
+     archive */
+  seek_pos = fseek(fd, abfd->origin, SEEK_SET);
+  if (seek_pos != 0) {
+      perror(archive_msg);
+      exit(1);
+  }
+
+  /* Code borrowed from ld_compile() -- [CL] */
+    
+  if (tmpdir == 0)
+    if (create_tmpdir (FALSE) != 0) {
+      perror(archive_msg);
+      exit(1);
+    }
+
+  if ((input_path = create_unique_file (file_name, 'B')) == 0) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  tmp_fd = fopen (input_path, "wb");
+  if (tmp_fd == NULL) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  cur_size = elem_size;
+  while (cur_size > 0) {
+      size_t ret;
+
+      ret = fread (rbuf, 1, size_buf, fd);
+
+      if (ret > 0) {
+	  size_t w_ret;
+
+	  w_ret = fwrite(rbuf , 1, ret, tmp_fd);
+	  if ((w_ret == 0) || (w_ret != ret)) {
+	      perror(archive_msg);
+	      exit(1);
+	  }
+	  cur_size -= ret;
+
+	  /* [CL] If we read nothing, but cur_size is still > 0, it
+	     means there was an error */
+      } else if ((ret == 0) ) {
+	  perror(archive_msg);
+	  exit(1);
+      }
+  }
+
+  FREE(rbuf);
+  fclose (fd);
+  fclose (tmp_fd);
+
+  abfd->usrdata = (PTR)(*p_ipa_open_input)((char *)input_path, &mapped_size, ipa_argc, ipa_argv);
+  if ((long) abfd->usrdata == -1) {
+    perror(archive_msg);
+    exit(1);
+  }
+
+  (*p_process_whirl64) ( 
+    	    	(void *)abfd, 
+    	    	elf_elfheader (abfd)->e_shnum, 
+		abfd->usrdata+elf_elfheader(abfd)->e_shoff,
+	        0, /* check_whirl_revision */
+		abfd->filename);
+}
+
+#endif
diff --git a/bfd/ipa_bfd.h b/bfd/ipa_bfd.h
new file mode 100644
index 0000000..b335467
--- /dev/null
+++ b/bfd/ipa_bfd.h
@@ -0,0 +1,312 @@
+/* THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003 */
+
+#ifndef __IPA_BFD_H__
+#define __IPA_BFD_H__
+
+#define BCOPY(src, dst, len) \
+    bcopy((const void *)(src), (void *)(dst), (int)(len))    	       
+
+#define FREE(ptr) \
+    free((void *) (ptr))
+
+#define MALLOC_ASSERT(addr) \
+    if (addr == 0) { perror("malloc failed: "); exit(1);}
+
+#define MALLOC(nbytes) \
+    malloc((size_t)(nbytes))
+
+#define REALLOC(ptr, size) \
+    realloc((void *)(ptr), (size_t)(size))
+
+#define UNLINK(path) \
+    unlink((const char *)(path))
+
+#if defined (_WIN32)
+#define MKDIR(path, mode) \
+    mkdir((const char *)(path))
+#else /* _WIN32 */
+#define MKDIR(path, mode) \
+    mkdir((const char *)(path), (mode_t)(mode))
+#endif /* _WIN32 */
+
+#define RMDIR(path) \
+    rmdir((const char *)(path))	       
+
+#define OPEN(path, oflag, mode) \
+    open((char *)(path), (int)(oflag), (int)(mode))
+
+#define CLOSE(fid) \
+    close((int)(fid))
+
+#define READ(fildes, buf, nbyte) \
+    read((int) (fildes), (void *)(buf), (size_t) (nbyte))
+
+#define ALLOCA(size) \
+    alloca((unsigned int)(size))	       
+	       
+#define FCHMOD(fid, mode) \
+    fchmod((int)(fid), (mode_t)(mode))
+
+#define MMAP(addr, len, prot, flags, fd, off) \
+    mmap((void *)(addr), (int)(len), (int)(prot), (int)(flags), (int)(fd), \
+	 (off_t)(off))
+
+#define MUNMAP(addr, len) \
+    munmap((void *)(addr), (int)(len))
+
+#define MEMCPY(s1, s2, n) \
+    memcpy((void *)(s1), (void *)(s2), (size_t)(n))
+
+#define ELF_WORD int
+
+#define OBJ_ASSERT(EX, obj, str) \
+    if (!(EX)) {fprintf(stderr,"%s: %s\n", obj->filename, str); exit(1);}
+
+#define DEFAULT_TMP_LIST_SIZE 32
+#define DEFAULT_TMPDIR "./ldtmp"
+
+#define arch_eltdata(bfd) ((struct areltdata *)((bfd)->arelt_data))
+#define arch_hdr(_bfd) ((struct ar_hdr *)arch_eltdata(_bfd)->arch_header)
+
+#define FALSE 0
+#define TRUE 1
+
+typedef char *string_t;
+
+extern int ipa_argc;
+extern char **ipa_argv;
+
+/* These are taken from ipc_sumtab_merge.h in the ipa tree. */
+
+
+/*
+ * These are for passing option information from the
+ * static linker to ipa without involving the linkers
+ * internal option table. Any enumerated types defined
+ * here can be added to,  but not altered in any other
+ * way. This allows the linker to change without affecting
+ * ipa.
+ */
+
+typedef enum{
+    LD_IPA_SHARABLE, 
+    LD_IPA_DEMANGLE, 
+    LD_IPA_SHOW, 
+    LD_IPA_HIDES, 
+    LD_IPA_TARGOS, 
+    LD_IPA_VERBOSE, 
+    LD_IPA_KEEP_TEMPS, 
+    LD_IPA_ISA,
+    LD_IPA_RELOCATABLE, /* [CL] generate a relocatable file */
+    LD_IPA_EXPORTS,     /* [CL] all symbols are exported (-E)*/
+    LD_IPA_XXXX, 
+    MAX_LD_IPA
+}ld_ipa_option_enum;
+
+typedef struct ld_ipa_option {
+    ld_ipa_option_enum opt_ndx;
+    unsigned    flag		: 4;    /*  */
+    unsigned     set		: 4;    /*  */
+} LD_IPA_OPTION;
+
+extern LD_IPA_OPTION ld_ipa_opt[MAX_LD_IPA];
+
+#define HS_DEFAULT 0
+#define HS_HIDES 1
+#define HS_EXPORTS 2
+#define HS_IGNORE 3
+
+                 /* these are set to bit fields for */
+                 /* easy table initialization */
+#define          F_RELOCATABLE       1
+#define          F_NON_SHARED        2
+#define          F_CALL_SHARED       4
+#define          F_MAKE_SHARABLE     8
+#define          F_STATIC    (F_NON_SHARED | F_RELOCATABLE)
+#define          F_DYNAMIC   (~(F_STATIC))
+#define          F_MAIN      (F_NON_SHARED | F_CALL_SHARED)
+#define		 F_EXEC	     (~F_RELOCATABLE)
+#define          F_ALL       (F_STATIC | F_DYNAMIC)
+#define          F_CALL_SHARED_RELOC (F_RELOCATABLE | F_CALL_SHARED)
+
+typedef enum {
+	TOS_IA64_64,
+	TOS_IA64_32, 
+	TOS_MAX
+}targos_enum;
+
+extern string_t tos_string[TOS_MAX];
+extern string_t toolroot;
+extern string_t tmpdir;
+extern string_t outfilename;
+extern char * __Release_ID;
+
+extern void *(*p_ipa_open_input)(char *, off_t *, int, char**);
+extern void (*p_ipa_init_link_line)(int, char **);
+extern void (*p_ipa_add_link_flag)(const char*);
+extern void (*p_ipa_driver)(int, char **);
+extern void (*p_process_whirl64)(void *, int, void *, int, const char *);
+extern void (*p_ipa_insert_whirl_marker)(void);
+extern void (*p_Sync_symbol_attributes)(unsigned int, unsigned int, bfd_boolean, unsigned int);
+/* [CL] handle comdat attribute */
+extern bfd_boolean (*p_symbol_comdat)(unsigned int);
+/* [CL] handle comdat attribute */
+extern bfd_boolean (*p_symbol_linkonce)(unsigned int);
+
+/* [CL] pointers to external symbols used by ipa.so */
+typedef LD_IPA_OPTION ipa_option_array[MAX_LD_IPA];
+
+#define IPA_EXTERNAL_SYMBOLS_VERSION 1
+
+struct external_symbols_list {
+  /* Size and version of this struct, for sanity checks */
+    int size;
+    int version;
+
+    /* pass1.h */
+    unsigned int *used_gp_area;
+
+    /* ld_ipa_option.h */
+    ipa_option_array *ld_ipa_opt;
+/*     ipacom_flags */
+    string_t *WB_flags;
+    string_t *Y_flags;
+
+    /* error.h */
+/*     msg */
+
+    /* ext_tbl.h */
+    void (*merge_ext)(void*, char *, int, void*);
+/*     enter_mext */
+/*     slookup_mext */
+/*     slookup_mext_idx */
+/*     get_mext */
+/*     ext_tbl */
+    void* (*ld_slookup_mext)(char *, bfd_boolean);
+
+    /* obj_file.h */
+/*     num_ir */
+/*     get_next_ir */
+/*     is_archive_member */
+
+    /* process.h */
+    int (*create_tmpdir)(int);
+    string_t (*create_unique_file)(string_t, char);
+    string_t (*create_unique_file_in_curdir)(string_t, char);
+    void (*add_to_tmp_file_list)(string_t);
+    string_t *tmpdir;
+/*     get_command_line */
+/*     make_link */
+
+    /* ld_util.h */
+    string_t (*concat_names)(string_t, string_t);
+
+    /* ld_main.h */
+    int *arg_count;
+    char** *arg_vector;
+    char** *environ_vars;
+    int *max_gpa_size;
+
+    /* read.h */
+    void (*read_one_section)(int, void*);
+/*     read_headers */
+/*     unread_sections */
+/*     unread_obj */
+/*     objs_mapped_total_size */
+/*     copy_section */
+
+    /* dem.h */
+    char* (*always_demangle)(char *, char );
+
+    /* elfhash.h */
+/*     elfhash */
+
+    /* ld_ipa_interface.h */
+  unsigned long long (*ld_get_section_size) (void* pobj, int index);
+
+  char *(*ld_get_section_name) (void* pobj, int index);
+
+  char *(*ld_get_section_base) (void* pobj, int index);
+
+  void *(*ld_get_mmap_addr) (void* pobj);
+
+/* extern unsigned int */
+/* ld_get_sym_attr (void* pext); */
+
+/* extern int */
+/* ld_is_weak_symbol (void* pext); */
+
+/* extern ST_EXPORT */
+/* ld_get_export (void* pext); */
+
+  void (*ld_set_st_idx) (void* pext, int st_idx);
+
+  int (*ld_get_st_idx) (void* pext);
+
+  bfd_boolean (*ld_resolved_to_obj) (void* pext, void* pobj);
+
+/*   extern void */
+/*   cleanup_symtab_for_ipa (void); */
+
+  int (*Count_elf_external_gots) (void);
+
+  string_t *outfilename;
+};
+
+extern void (*p_ipa_initialize_external_symbols)(struct external_symbols_list*);
+
+
+/* Function declarations
+ */
+ 
+extern char *
+ipa_copy_of(char *);
+
+extern string_t
+concat_names(const string_t, const string_t);
+
+extern void
+add_to_tmp_file_list (string_t);
+
+extern int
+create_tmpdir ( int);
+
+extern string_t
+create_unique_file (const string_t, char);
+
+extern string_t
+create_unique_file_in_curdir (const string_t, char);
+
+extern int
+ipa_set_ndx (bfd *);
+
+extern void 
+ld_set_cur_obj(bfd *);
+
+void *
+ld_get_cur_obj(void);
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+extern void
+ipa_process_whirl ( bfd *);
+
+/* The following constant values are shared by both ld and ipa.  Each
+   symtab entry in ld's merged symbol table has an ST_IDX field pointing
+   back to the corresponding entry (if any) in the WHIRL merged symbol
+   table.  When a new entry is added to ld's merged symbol table, if the
+   symbol comes from an Elf object, we set the ST_IDX field to
+   WHIRL_ST_IDX_NOT_AVAILABLE because there is no corresponding ST entry in
+   the WHIRL merged symbol table. If the symbol comes from a WHIRL object,
+   we set the ST_IDX field to WHIRL_ST_IDX_UNINITIALIZED, which means that
+   there will be a corresponding entry in the WHIRL merged symtab but we
+   don't know the value yet.
+ */
+
+#define WHIRL_ST_IDX_UNINITIALIZED (0)
+#define WHIRL_ST_IDX_NOT_AVAILABLE (-1)
+
+
+
+#endif /* __IPA_BFD_H__ */
diff --git a/bfd/libbfd.h b/bfd/libbfd.h
index cfc364f..4416ed7 100644
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -1215,6 +1215,44 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
   "BFD_RELOC_PPC64_DTPREL16_HIGHESTA",
   "BFD_RELOC_I370_D12",
   "BFD_RELOC_CTOR",
+  "BFD_RELOC_LX_16",
+  "BFD_RELOC_LX_32",
+  "BFD_RELOC_LX_32_PCREL",
+  "BFD_RELOC_LX_23_PCREL",
+  "BFD_RELOC_LX_HI23",
+  "BFD_RELOC_LX_LO9",
+  "BFD_RELOC_LX_GPREL_HI23",
+  "BFD_RELOC_LX_GPREL_LO9",
+  "BFD_RELOC_LX_REL32",
+  "BFD_RELOC_LX_GOTOFF_HI23",
+  "BFD_RELOC_LX_GOTOFF_LO9",
+  "BFD_RELOC_LX_GOTOFFX_HI23",
+  "BFD_RELOC_LX_GOTOFFX_LO9",
+  "BFD_RELOC_LX_LTV32",
+  "BFD_RELOC_LX_SEGREL32",
+  "BFD_RELOC_LX_FPTR32",
+  "BFD_RELOC_LX_PLTOFF_HI23",
+  "BFD_RELOC_LX_PLTOFF_LO9",
+  "BFD_RELOC_LX_GOTOFF_FPTR_HI23",
+  "BFD_RELOC_LX_GOTOFF_FPTR_LO9",
+  "BFD_RELOC_LX_IPLT",
+  "BFD_RELOC_LX_NEG_GPREL_HI23",
+  "BFD_RELOC_LX_NEG_GPREL_LO9",
+  "BFD_RELOC_LX_COPY",
+  "BFD_RELOC_LX_JMP_SLOT",
+  "BFD_RELOC_LX_TPREL_HI23",
+  "BFD_RELOC_LX_TPREL_LO9",
+  "BFD_RELOC_LX_TPREL32",
+  "BFD_RELOC_LX_GOTOFF_TPREL_HI23",
+  "BFD_RELOC_LX_GOTOFF_TPREL_LO9",
+  "BFD_RELOC_LX_GOTOFF_DTPLDM_HI23",
+  "BFD_RELOC_LX_GOTOFF_DTPLDM_LO9",
+  "BFD_RELOC_LX_DTPREL_HI23",
+  "BFD_RELOC_LX_DTPREL_LO9",
+  "BFD_RELOC_LX_DTPMOD32",
+  "BFD_RELOC_LX_DTPREL32",
+  "BFD_RELOC_LX_GOTOFF_DTPNDX_HI23",
+  "BFD_RELOC_LX_GOTOFF_DTPNDX_LO9",
   "BFD_RELOC_ARM_PCREL_BRANCH",
   "BFD_RELOC_ARM_PCREL_BLX",
   "BFD_RELOC_THUMB_PCREL_BLX",
diff --git a/bfd/linker.c b/bfd/linker.c
index 327426e..3da199b 100644
--- a/bfd/linker.c
+++ b/bfd/linker.c
@@ -27,6 +27,16 @@
 #include "bfdlink.h"
 #include "genlink.h"
 
+#ifdef IPA_LINK
+#pragma weak ipa_is_whirl
+
+extern bfd_boolean
+ipa_is_whirl(bfd *);
+
+#include "ipa_bfd.h" /* [CL] needed for symbol_comdat() */
+#include "elf-bfd.h" /* [CL] needed to support comdat: need to get ipa_indx */
+#endif
+
 /*
 SECTION
 	Linker Functions
@@ -429,6 +439,19 @@ static bfd_boolean default_indirect_link_order
   (bfd *, struct bfd_link_info *, asection *, struct bfd_link_order *,
    bfd_boolean);
 
+#ifdef IPA_LINK
+
+/* The strong version is defined in ld. */
+#if 1
+bfd_boolean is_ipa = 0;
+#pragma weak is_ipa
+#else
+bfd_boolean __is_ipa = 0;
+#pragma weak is_ipa = __is_ipa
+#endif
+
+#endif
+
 /* The link hash table structure is defined in bfdlink.h.  It provides
    a base hash table which the backend specific hash tables are built
    upon.  */
@@ -1628,11 +1651,28 @@ _bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
 
 	    /* Define a symbol.  */
 	    oldtype = h->type;
+#ifdef IPA_LINK
+	    /* [CL] if we have DEFW from a non-Whirl symbol, don't
+	       propagate the weak attribute to the reference:
+	       otherwise, it makes the compiler generate a weak
+	       reference, which is not resolved by the final link
+	       stage */
+	    if (is_ipa && (action == DEFW) && !ipa_is_whirl(abfd)) {
+	      action = DEF;
+	    }
+#endif
 	    if (action == DEFW)
 	      h->type = bfd_link_hash_defweak;
 	    else
 	      h->type = bfd_link_hash_defined;
 	    h->u.def.section = section;
+#ifdef IPA_LINK
+            /* ipa_set_def_bfd(abfd,h); */
+            if (is_ipa) {
+	      /*              h->u.def.section = (asection *)abfd;*/
+	      h->ipa_bfd = abfd;
+	    }
+#endif
 	    h->u.def.value = value;
 
 	    /* If we have been asked to, we act like collect2 and
@@ -1832,6 +1872,16 @@ _bfd_generic_link_add_one_symbol (struct bfd_link_info *info,
 		  abort ();
 		}
 
+#ifdef IPA_LINK
+	      /* [CL] support comdat attribute: redefinition
+		 of a symbol with the comdat attribute is allowed.
+		 It will be fully resolved by the final link pass */
+	      if (is_ipa && ipa_is_whirl(abfd) &&
+		  (*p_symbol_comdat)(((struct elf_link_hash_entry*)h)->ipa_indx)) {
+		break;
+	      }
+#endif
+	      
 	      /* Ignore a redefinition of an absolute symbol to the
 		 same value; it's harmless.  */
 	      if (h->type == bfd_link_hash_defined
diff --git a/bfd/reloc.c b/bfd/reloc.c
index 027ede0..0ecfc2d 100644
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* BFD support for handling relocation entries.
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@@ -2733,6 +2737,85 @@ ENUMDOC
   It generally does map to one of the other relocation types.
 
 ENUM
+  BFD_RELOC_LX_16
+ENUMX
+  BFD_RELOC_LX_32
+ENUMX
+  BFD_RELOC_LX_32_PCREL
+ENUMX
+  BFD_RELOC_LX_23_PCREL
+ENUMX
+  BFD_RELOC_LX_HI23
+ENUMX
+  BFD_RELOC_LX_LO9
+ENUMX
+  BFD_RELOC_LX_GPREL_HI23
+ENUMX
+  BFD_RELOC_LX_GPREL_LO9
+ENUMX
+  BFD_RELOC_LX_REL32
+ENUMX
+  BFD_RELOC_LX_GOTOFF_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_LO9
+ENUMX
+  BFD_RELOC_LX_GOTOFFX_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFFX_LO9
+ENUMX
+  BFD_RELOC_LX_LTV32
+ENUMX
+  BFD_RELOC_LX_SEGREL32
+ENUMX
+  BFD_RELOC_LX_FPTR32
+ENUMX
+  BFD_RELOC_LX_PLTOFF_HI23
+ENUMX
+  BFD_RELOC_LX_PLTOFF_LO9
+ENUMX
+  BFD_RELOC_LX_GOTOFF_FPTR_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_FPTR_LO9
+ENUMX
+  BFD_RELOC_LX_IPLT
+ENUMX
+  BFD_RELOC_LX_NEG_GPREL_HI23
+ENUMX
+  BFD_RELOC_LX_NEG_GPREL_LO9
+ENUMX
+  BFD_RELOC_LX_COPY
+ENUMX
+  BFD_RELOC_JMP_SLOT
+ENUMX
+  BFD_RELOC_LX_TPREL_HI23
+ENUMX
+  BFD_RELOC_LX_TPREL_LO9
+ENUMX
+  BFD_RELOC_LX_TPREL32
+ENUMX
+  BFD_RELOC_LX_GOTOFF_TPREL_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_TPREL_LO9
+ENUMX
+  BFD_RELOC_LX_GOTOFF_DTPLDM_HI23
+ENUMX
+  BFD_RELOC_LX_GOTOFF_DTPLDM_LO9
+ENUMX
+  BFD_RELOC_LX_DTPREL_HI23
+ENUMX
+  BFD_RELOC_LX_DTPREL_LO9
+ENUMX
+  BFD_RELOC_LX_DTPMOD32
+ENUMX
+  BFD_RELOC_LX_DTPREL32
+ENUMX
+  BFD_RELOC_GOTOFF_DTPNDX_HI23
+ENUMX
+  BFD_RELOC_GOTOFF_DTPNDX_LO9
+ENUMDOC
+  LX relocations
+
+ENUM
   BFD_RELOC_ARM_PCREL_BRANCH
 ENUMDOC
   ARM 26 bit pc-relative branch.  The lowest two bits must be zero and are
diff --git a/bfd/section.c b/bfd/section.c
index cadba6b..52957ee 100644
--- a/bfd/section.c
+++ b/bfd/section.c
@@ -692,7 +692,11 @@ static const asymbol global_syms[] =
   GLOBAL_SYM_INIT (BFD_COM_SECTION_NAME, &bfd_com_section),
   GLOBAL_SYM_INIT (BFD_UND_SECTION_NAME, &bfd_und_section),
   GLOBAL_SYM_INIT (BFD_ABS_SECTION_NAME, &bfd_abs_section),
-  GLOBAL_SYM_INIT (BFD_IND_SECTION_NAME, &bfd_ind_section)
+  GLOBAL_SYM_INIT (BFD_IND_SECTION_NAME, &bfd_ind_section),
+#ifdef IPA_LINK
+  GLOBAL_SYM_INIT (BFD_WHD_SECTION_NAME, &bfd_whirl_data_section),
+  GLOBAL_SYM_INIT (BFD_WHT_SECTION_NAME, &bfd_whirl_text_section)
+#endif
 };
 
 #define STD_SECTION(SEC, FLAGS, NAME, IDX)				\
@@ -703,6 +707,10 @@ STD_SECTION (bfd_com_section, SEC_IS_COMMON, BFD_COM_SECTION_NAME, 0);
 STD_SECTION (bfd_und_section, 0, BFD_UND_SECTION_NAME, 1);
 STD_SECTION (bfd_abs_section, 0, BFD_ABS_SECTION_NAME, 2);
 STD_SECTION (bfd_ind_section, 0, BFD_IND_SECTION_NAME, 3);
+#ifdef IPA_LINK
+STD_SECTION (bfd_whirl_data_section, 0, BFD_WHD_SECTION_NAME, 4);
+STD_SECTION (bfd_whirl_text_section, 0, BFD_WHT_SECTION_NAME, 5);
+#endif /* IPA_LINK */
 #undef STD_SECTION
 
 /* Initialize an entry in the section hash table.  */
@@ -978,6 +986,12 @@ bfd_make_section_old_way (bfd *abfd, const char *name)
     newsect = bfd_und_section_ptr;
   else if (strcmp (name, BFD_IND_SECTION_NAME) == 0)
     newsect = bfd_ind_section_ptr;
+#ifdef IPA_LINK
+  else if (strcmp (name, BFD_WHD_SECTION_NAME) == 0)
+    newsect = bfd_whirl_data_section_ptr;
+  else if (strcmp (name, BFD_WHT_SECTION_NAME) == 0)
+    newsect = bfd_whirl_text_section_ptr;
+#endif
   else
     {
       struct section_hash_entry *sh;
diff --git a/bfd/targets.c b/bfd/targets.c
index dc644c2..ee1d5af 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* Generic target-file-type support for the BFD library.
    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@@ -611,6 +615,10 @@ extern const bfd_target bfd_elf32_littlearm_symbian_vec;
 extern const bfd_target bfd_elf32_littlearm_vxworks_vec;
 extern const bfd_target bfd_elf32_littlemips_vec;
 extern const bfd_target bfd_elf32_littlemips_vxworks_vec;
+extern const bfd_target bfd_elf32_lx_vec;
+extern const bfd_target bfd_elf32_lx_linux_vec;
+extern const bfd_target bfd_elf32_littlelx_vec;
+extern const bfd_target bfd_elf32_littlelx_linux_vec;
 extern const bfd_target bfd_elf32_m32c_vec;
 extern const bfd_target bfd_elf32_m32r_vec;
 extern const bfd_target bfd_elf32_m32rle_vec;
@@ -946,6 +954,9 @@ static const bfd_target * const _bfd_target_vector[] =
 	&bfd_elf32_littlearm_vxworks_vec,
 	&bfd_elf32_littlemips_vec,
 	&bfd_elf32_littlemips_vxworks_vec,
+	&bfd_elf32_lx_vec,
+	&bfd_elf32_littlelx_vec,
+	&bfd_elf32_littlelx_linux_vec,
 	&bfd_elf32_m32c_vec,
 	&bfd_elf32_m32r_vec,
         &bfd_elf32_m32rle_vec,
diff --git a/config.sub b/config.sub
index 6759825..5fd1030 100644
--- a/config.sub
+++ b/config.sub
@@ -1,4 +1,5 @@
 #! /bin/sh
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@@ -249,6 +250,7 @@ case $basic_machine in
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
 	| ip2k | iq2000 \
+	| lx \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
 	| maxq | mb | microblaze | mcore | mep \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
@@ -329,6 +331,7 @@ case $basic_machine in
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
 	| ip2k-* | iq2000-* \
+	| lx-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | maxq-* | mcore-* \
diff --git a/configure b/configure
index 1131e5a..4c9c91f 100644
--- a/configure
+++ b/configure
@@ -612,6 +612,17 @@ Try \`$0 --help' for more information." >&2
   esac
 done
 
+case "$host_alias" in
+  st2[0-9][0-9]-linux)
+  test -n "$host_alias" && host_alias=lx-linux
+  ;;
+esac
+case "$target_alias" in
+  st2[0-9][0-9]-linux)
+  test -n "$target_alias" && target_alias=lx-linux
+  ;;
+esac
+
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
   { echo "$as_me: error: missing argument to $ac_option" >&2
@@ -660,7 +671,20 @@ if test "x$host_alias" != x; then
 fi
 
 ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
+#test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+case "$host_alias" in
+  "lx-linux")
+  test -n "$host_alias" && ac_tool_prefix=st231-linux-
+  ;;
+*)
+  test -n "$host_alias" && ac_tool_prefix=$host_alias-
+  ;;
+esac
+
+
+
+
 
 test "$silent" = yes && exec 6>/dev/null
 
@@ -6383,6 +6407,12 @@ test -n "$host_alias" && ncn_tool_prefix=$host_alias-
 ncn_target_tool_prefix=
 test -n "$target_alias" && ncn_target_tool_prefix=$target_alias-
 
+case "$host_alias" in
+  "lx-linux")
+   test -n "$host_alias" && ncn_tool_prefix=st231-linux-
+   test -n "$target_alias" && ncn_target_tool_prefix=st231-linux-
+  ;;
+esac
 
 
 if test -n "$AR"; then
@@ -12173,7 +12203,7 @@ fi;
 
 
 
-
+CFLAGS="$CFLAGS -DTARGET_ST200"
 
 
           ac_config_files="$ac_config_files Makefile"
diff --git a/gdb/ChangeLog.sts-gdb b/gdb/ChangeLog.sts-gdb
new file mode 100644
index 0000000..b56a98f
--- /dev/null
+++ b/gdb/ChangeLog.sts-gdb
@@ -0,0 +1,742 @@
+2008-09-03  Antony King  <antony.king@st.com>
+
+	Fix INSbl29231:
+	* breakpoint.c (hw_breakpoint_used_count): Remove static.
+	(hw_watchpoint_used_count): Likewise. Return number of other
+	watchpoint types.
+	(watch_command_1): Update error message.
+	* breakpoint.h (hw_breakpoint_used_count): Add extern declaration.
+	(hw_watchpoint_used_count): Likewise.
+	* shtdi.c (shtdi_can_use_hw_breakpoint): Use hw_breakpoint_used_count
+	and hw_watchpoint_used_count.
+
+2008-09-02  Antony King  <antony.king@st.com>
+
+	* shtdi.c (shtdi_insert_watchpoint): Use SHTDI_HW_WATCHPOINT_LIMIT.
+	(shtdi_can_use_hw_breakpoint): Add missing watchpoint types.
+
+2008-09-01  Antony King  <antony.king@st.com>
+
+	Fix PR/2500:
+	* breakpoint.c (bpstat_stop_status): Always stop if
+	WP_VALUE_CHANGED.
+
+2008-08-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl29209:
+	* shtdi.c (shtdi_watch_data_address): New global variable.
+	(shtdi_stopped_data_address): New function.
+	(shtdi_wait): Add support for version 1.5 of the SHDEBUG
+	API (GetState).
+	(init_shtdi_ops): Set to_stopped_data_address to
+	shtdi_stopped_data_address.
+
+2008-08-29  Denis Pilat  <denis.pilat@st.com>
+
+	* breakpoint.c: Add missing Copyright notice.
+	* remote.c: Likewise.
+	* cli/cli-cmds.c(fork_escape): Add cast to the last argument of execlp
+	to remove GCC 4.1.1 warning "missing sentinel in function call".
+	* version.in: Set version to 6.8-ST-2.0.
+
+2008-08-27  Antony King  <antony.king@st.com>
+
+	* target.c (set_targetdebug): New function.
+	(initialize_targets): Update.
+
+	Fix INSbl29191:
+	* infrun.c (prepare_to_proceed): Switch to last stopped thread
+	if target unable to lock scheduler.
+	* shtdi.c (shtdi_resume): Report error for unsupported modes.
+
+2008-08-15  Antony King  <antony.king@st.com>
+
+	* breakpoint.c (update_watchpoint): Do not remove watchpoint
+	if not inserted.
+	* dwarf2-frame.c (execute_cfa_program): Fix incorrect merge
+	for DW_CFA_restore_extended.
+	* shtdi.c (shtdi_stopped_by_watchpoint_p): New global variable.
+	(shtdi_stopped_by_watchpoint): New function.
+	(shtdi_wait): Recognize H/W code and data breakpoint stop codes.
+	(init_shtdi_ops): Set to_stopped_by_watchpoint to
+	shtdi_stopped_by_watchpoint.
+
+2008-08-14  Antony King  <antony.king@st.com>
+
+	Fix INSbl29142:
+	* shtdi.c (shtdi_addrfromsymb): Return success or failure.
+	(shtdi_symbfromaddr) Likewise.
+
+2008-08-12  Antony King  <antony.king@st.com>
+
+	Import STS-GDB 6.8:
+	* config/sh/tm-sh.h: Remove.
+	* configure.ac (sh*-superh-elf): Add definitions for GDBINIT_FILENAME,
+	SHTDI_GDB_REGISTER_MAP, TARGET_HAS_RELOCATABLE_LIB, SOLIB_BKPT_NAME
+	and SHTDI_JOINT_HW_BREAK_LIMIT.
+	* configure: Regenerate.
+	* config.in: Likewise.
+	* shtdi.c (shtdi_init_simulator_hook): Add definition.
+	(SHTDI_GDB_REGISTER_MAP) Likewise.
+	* sh-tdep.c (SVR4_SHARED_LIBS): Remove and replace with
+	TARGET_HAS_RELOCATABLE_LIB.
+	(sh_default_register_type): Use builtin_type_void_func_ptr for PC
+	PR and SPC registers.
+	(sh_sh2a_register_type): Likewise.
+	(sh_sh3e_register_type): Likewise.
+	(sh_sh4_register_type): Likewise.
+	* remote.c (extended_remote_attach_1): Fix GCC 3.4 compilation
+	warning (Solaris).
+
+2008-07-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl26448:
+	* shtdi.c (do_script): New function.
+	(do_script_cleanup): Likewise.
+	(shtdi_callplugin): Call do_script (or execute_command) on result.
+	(set_command): Deprecate.
+
+2008-07-18  Denis Pilat  <denis.pilat@st.com>
+
+	* shtdi.c: Add an include to "sh/tm-sh.h" following 6.8 porting.
+
+2008-07-07  Denis Pilat  <denis.pilat@st.com>
+
+	* Modify all required files while porting to 6.8 version,
+	adding ChangeLog.st40 for Andrew&Antony's patches.
+	* version.in: Set version to 6.8-ST-1.0.
+
+2008-06-30  Antony King  <antony.king@st.com>
+
+	Fix INSbl28906:
+	* sh-tdep.c (sh_sh4_register_sim_regno): Replace erroneous use of
+	FPSCR_PR with FPSCR_FR.
+	(sh4_gdb_to_shtdi_regno): Likewise.
+
+2008-05-15  Antony King  <antony.king@st.com>
+
+	* sh-tdep.c (sh3_show_regs): Display bank registers.
+	(sh3e_show_regs): Likewise.
+	(sh4_show_regs): Likewise.
+	(sh4_nofpu_show_regs): Likewise.
+
+2008-05-02  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* main.h (batch_silent): Declare.
+	* event-top.c: Include main.h.
+	(gdb_setup_readline): Remove extern batch_silent declaration.
+	* infrun.c (normal_stop): Don't print source location when running in
+	--batch-silent mode.
+	* Makefile.in (event-top.o): Add main.h dependency.
+
+2008-04-23  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* printcmd.c: Define USE_PRINTF_I64 and PRINTF_HAS_LONG_LONG on MinGW.
+	(printf_command): Convert %lld to %I64d when USE_PRINTF_I64 set.
+	Allow 'l' (ell) modifier for %f.
+
+2008-04-07  Antony King  <antony.king@st.com>
+
+	Fix INSbl28523:
+	* shtdi.c (shtdi_maintenance_cmdlist): New global variable.
+	(rtos_reset_command): New function.
+	(maintenance_shtdi_command): Likewise.
+	(_initialize_shtdi): Added new maintenance shtdi subcommand.
+
+2008-04-04  Antony King  <antony.king@st.com>
+
+	Fix INSbl27793:
+	* frame.c (frame_find_by_id): Only return null frame for null id
+	when target has no stack and apply patch from
+	http://www.sourceware.org/ml/gdb-patches/2006-05/msg00018.html.
+
+2008-04-03  Antony King  <antony.king@st.com>
+
+	Fix INSbl28523:
+	* sh-tdep.c (sh4_gdb_to_shtdi_regno): Add regcache parameter and use
+	instead of current frame.
+	(sh_gdb_to_shtdi_regno): Likewise.
+	(sh_sh4_register_sim_regno): Use current regcache instead of current
+	frame.
+	* config/sh/tm-sh.h (SHTDI_GDB_REGISTER_MAP): Add regcache parameter.
+	* shtdi.c (shtdi_register_offset): Likewise.
+
+2008-04-01  Antony King  <antony.king@st.com>
+
+	* shtdi.c (SHDEBUGAPI_VERSION): Remove and replace with
+	SHDEBUGAPI_VERSION_MIN and SHDEBUGAPI_VERSION_MAX.
+	(shtdi_load_shdebug): Add support for version 1.3 of the
+	SHDEBUG API (RtosGetEventMonitor).
+	(shtdi_unload_shdebug): Likewise.
+
+	Fix INSbl28523:
+	* shtdi.c (shtdi_read_all_registers): New global variable.
+	(shtdi_rtos_thread_information): Likewise.
+	(shtdi_fetch_all_registers_data): Likewise.
+	(show_shtdi_read_all_registers): New function.
+	(show_shtdi_rtos_thread_information): Likewise.
+	(_initialize_shtdi): Add new set/show shtdi subcommands.
+	(rtos_extra_thread_info) Add support for version 1.4 of the
+	SHDEBUG API (RtosGetThreadInfo).
+	(shtdi_fetch_register): Rename to shtdi_fetch_register_1. Use
+	shtdi_fetch_all_registers_data as temporary registers cache.
+	(shtdi_fetch_register): New function.
+	(shtdi_fetch_register_cleanup): Likewise.
+
+2008-03-10  Antony King  <antony.king@st.com>
+
+	Fix INSbl21056:
+	* shtdi.c (remote_debug): Remove erroneous usage.
+	(interrupt_requested): Rename to target_interrupted.
+	(interrupt_pending): Rename to interrupt_requested.
+	(terminate_pending): Rename to terminate_requested.
+	(shtdi_wait): Call interrupt_stop if quit_flag set or timeout. Move
+	restoration of interrupt handler to cleanup function.
+	(shtdi_wait_cleanup): New function.
+	(terminate_disable): Fix race condition.
+	(shtdi_stop): Rename to interrupt_stop.
+	(interrupt_once): Replace target_stop with interrupt_stop.
+	(shtdi_stop): New function.
+
+2008-03-06  Antony King  <antony.king@st.com>
+
+	* Makefile.in (tracepoint.o): Remove format checking (MinGW GCC 3.4
+	compilation warning).
+	* shtdi.c (iointerrupt): Fix GCC 3.4 compilation warning.
+
+2008-03-05  Antony King  <antony.king@st.com>
+
+	* infcall.c (find_function_addr): Fix GCC 3.2 compilation warning.
+
+2008-03-04  Denis PILAT for Antony King  <antony.king@st.com>
+
+	Fix INSbl25564:
+	* dwarf2-frame.c (execute_cfa_program): Ignore CFI entries with
+	negative register numbers.
+
+2008-02-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl28432:
+	* shtdi.c (shtdi_wait): Report unknown signal on shdbg_GetState
+	error; replace explict signal codes with TARGET_SIGNAL_<code>;
+	call shtdi_kill on detach request from deprecated_ui_loop_hook.
+
+2008-02-19  Antony King  <antony.king@st.com>
+
+	Fix INSbl28103:
+	* shtdi.c (set_rtos_initialize_string): New global variable.
+	(shtdi_set_cmdlist, shtdi_show_cmdlist): Likewise.
+	(show_shtdi_rtos_initialize): New function.
+	(set_shtdi_cmd): Likewise.
+	(show_shtdi_cmd): Likewise.
+	(_initialize_shtdi): Add new set/show command plus re-factor
+	existing set/show commands under shtdi subcommand.
+	(shtdi_open): Check set_rtos_initialize_string before
+	calling rtos_init.
+	(shtdi_load): Likewise.
+	(shtdi_resume): Likewise.
+
+2008-02-14  Antony King  <antony.king@st.com>
+
+	Fix INSbl28103:
+	* shtdi.c (rtos_disable): Remove target status check.
+	(rtos_enable): Likewise.
+	(shtdi_open): Call rtos_check_symbols and rtos_init before
+	start_remote.
+	(shtdi_resume) Remove call to rtos_init.
+
+	* shtdi.c (ioconsole_open): Rename to ioconsole_init.
+	(ioconsole_launch): Rename to ioconsole_open.
+	(ioconsole_console_enable): Remove target status check.
+	(ioconsole_close): Likewise.
+
+2008-02-13  Antony King  <antony.king@st.com>
+
+	Fix INSbl28376:
+	* shtdi.c (interrupt_query): Remove.
+	(interrupt_twice): Likewise.
+	(interrupt_once): Replace interrupt_twice with interrupt_once.
+	(shtdi_stop): Remove call to interrupt_query and always call
+	iointerrupt.
+	(interrupt_request): New global variable to indicate if
+	shdbg_Interrupt has been called.
+	(shtdi_close_cleanup): Likewise.
+	(interrupt_check): Likewise.
+	(shtdi_wait): Likewise.
+	(interrupt_pending): Add missing volatile.
+	(terminate_pending): Likewise.
+
+2008-02-07  Antony King  <antony.king@st.com>
+
+	Fix INSbl28274:
+	* shtdi.c (ioconsole_launch): Add asynchonous pipe handle
+	to parameters for separate Posix console.
+	(ioconsole_close): Clean up asynchonous pipe handle.
+	(iointerrupt): Use asynchonous pipe instead of write pipe.
+
+2008-02-04  Antony King  <antony.king@st.com>
+
+	Fix INSbl28274:
+	* shtdi.c (shtdi_stop): Call iointerrupt.
+	(interrupt_check): Remove call to iointerrupt.
+
+2008-02-04  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.7-ST-1.50 (intermediate version).
+
+2008-01-31  Antony King  <antony.king@st.com>
+
+	Fix INSbl28301:
+	* shtdi.c (shtdi_close_cleanup): Remove unnecessary
+	disabling of RTOS awareness.
+
+2008-01-14  Denis Pilat  <denis.pilat@st.com>
+
+	Evaluate environment variables from the command line, using
+	the ${} syntax.
+	* top.c (evaluate_environment_from_string): new function.
+	(ENV_DELIMITER_BEGIN,ENV_DELIMITER_END): new defines.
+
+2007-12-19  Denis Pilat  <denis.pilat@st.com>
+
+	* tui/tui-data.h (MAX_LOCATOR_ELEMENT_LEN): Defined to a bigger
+	value or to PATH_MAX when possible.
+
+2007-12-19  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.7-ST-1.0.
+
+2007-11-22  Antony King  <antony.king@st.com>
+
+	Fix INSbl28139:
+	* shtdi.c (shtdi_create_inferior): Remove unnecessary
+	explicit load of executable file.
+
+2007-11-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl28123:
+	* shtdi.c (show_shtdi_break_timeout): New function.
+	(shtdi_wait): Use set option for timeouts.
+	(_initialize_shtdi): Add new set/show command.
+	(_initialize_shtdi): Change set/show shtdi-wait-timeout to
+	to zinteger.
+
+2007-11-09  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.ac (GDBRESOPTS): New substitution.
+	* configure: Regenerate.
+	* Makefile.in (gdbres.o): Add @GDBRESOPTS@ to build command.
+
+2007-10-29  Antony King  <antony.king@st.com>
+
+	Fix INSbl27972:
+	* shtdi.c (shtdi_close): Call target_mark_exited.
+	(shtdi_mourn_inferior): Remove call to target_mark_exited.
+
+2007-10-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl27972:
+	* shtdi.c (shtdi_mourn_inferior): Call target_mark_exited.
+
+2007-09-26  Antony King  <antony.king@st.com>
+
+	Fix INSbl27780:
+	* sh-tdep.c (sh_dbg_reg_to_regnum): New function.
+	(sh_gdbarch_init): Call set_gdbarch_dwarf_reg_to_regnum,
+	set_gdbarch_dwarf2_reg_to_regnum and set_gdbarch_stab_reg_to_regnum.
+	* sh-tdep.h: Change comment.
+
+2007-09-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl25905:
+	* sh-tdep.c (sh_type_align): New function.
+	(sh_treat_as_complex): Likewise.
+	(sh_use_struct_convention): Rewrite.
+	(sh_treat_as_flt_p): Likewise.
+	(sh_extract_return_value_nofpu): Remove limit on size of return
+	value type (for complex types).
+	(sh_use_struct_convention): Remove unused parameter.
+	(sh_return_value_nofpu): Likewise.
+	(sh_return_value_fpu): Likewise.
+
+2007-08-31  Antony King  <antony.king@st.com>
+
+	Fix INSbl26139:
+	* solib.c (solib_create_inferior_hook): Check if shared library
+	support is enabled.
+	(solib_add): Likewise.
+	(info_sharedlibrary_command): Likewise.
+	(disable_shared_libraries): New function.
+	(enable_shared_libraries): Likewise.
+	(_initialize_solib): Add enable and disable sharedlibrary commands.
+	* shtdi.c (ioconsole_console_disable): New function.
+	(ioconsole_console_enable): Likewise.
+	(info_ioconsole_console_command): Likewise.
+	(rtos_disable): Likewise.
+	(rtos_enable): Likewise.
+	(info_rtos_command): Likewise.
+	(ioconsole_console_command): Use ioconsole_console_disable(),
+	ioconsole_console_disable(), info_ioconsole_console_command().
+	(rtos_command): Use rtos_disable(), rtos_enable(),
+	info_rtos_command().
+	(_initialize_shtdi): Add enable, disable and info alternatives for
+	console and rtos commands.
+
+2007-08-24  Antony King  <antony.king@st.com>
+
+	Fix INSbl27529:
+	* configure.ac: Add check for -lthread.
+	* configure: Regenerate.
+
+2007-08-23  Antony King  <antony.king@st.com>
+
+	Fix INSbl25905:
+	* sh-tdep.c (sh_treat_as_flt_p): Add call to check_typedef()
+	when checking field types.
+	(sh_use_struct_convention): Likewise plus ABI change.
+
+2007-08-22  Antony King  <antony.king@st.com>
+
+	Fix INSbl26019:
+	* sh-tdep.c (sh_integer_to_address): New function.
+	(sh_gdbarch_init): Call set_gdbarch_integer_to_address.
+
+	Fix INSbl27304:
+	* shtdi.c (shtdi_crc32): Remove.
+	(shtdi_compare_sections): Add support for comparing VMA or LMA
+	addresses and for comparing with an offset. Replace CRC comparison
+	with memory compare and report first differing address and value.
+	(add_generic_cmds): Update compare-sections help.
+
+2007-08-21  Antony King  <antony.king@st.com>
+
+	Fix INSbl27308:
+	* shtdi.c (shtdi_open): Remove superfluous call to
+	solib_create_inferior_hook(). Replace erroneous manipulation of
+	target state with target_mark_exited()/target_mark_running().
+	(init_shtdi_ops): Update target capabilities to normal defaults.
+	(shtdi_kill): Replace call to shdbg_RtosClearState() with call
+	to target_mourn_inferior().
+	(shtdi_mourn_inferior): Add call to shdbg_RtosClearState().
+	(shtdi_set_exec_file): New function.
+	(shtdi_load): Simplified to use shtdi_set_exec_file().
+	(shtdi_create_inferior): Replace non-standard executable file
+	handling with standard behaviour using the load command. Add
+	missing inferior process initialisations.
+
+2007-08-20  Antony King  <antony.king@st.com>
+
+	Fix INSbl27434:
+	* sh-tdep.c (sh_use_struct_convention): Add missing check
+	for enum before checking field type.
+
+	Fix INSbl27488:
+	* valops.c (value_fetch_lazy): Ensure object is initialised
+	before reading from memory.
+
+	Fix INSbl27444:
+	* shtdi.c (show_shtdi_wait_timeout): New function.
+	(shtdi_wait): Use set option for timeouts.
+	(_initialize_shtdi): Add new set/show command.
+	(show_download_write_size): Fix string formatting.
+	(_initialize_shtdi): Likewise.
+
+	Fix INSbl24984:
+	* shtdi.c (shtdi_mourn_inferior): New function.
+	(init_shtdi_ops): Set to_mourn_inferior to shtdi_mourn_inferior.
+
+	Fix INSbl26433:
+	* shtdi.c (terminate_once): New function.
+	(disable_terminate): Likewise.
+	(enable_terminate): Likewise.
+	(SHDEBUGSymbol): Add SIGTERM protection.
+	(voidreturnSHDEBUGSymbol): Likewise.
+	(voidSHDEBUGSymbol): Likewise.
+
+2007-08-17  Antony King  <antony.king@st.com>
+
+	* utils.c (defaulted_query): Prevent query when
+	sourcing a script file.
+
+2007-08-16  Antony King  <antony.king@st.com>
+
+	Fix INSbl26938:
+	* sh-tdep.c (sh_show_regs_command): Remove sh_show_regs
+	hook (and replace with explicit architecture check).
+	(sh_gdbarch_init): Likewise.
+
+	Fix INSbl15403/INSbl27537:
+	* sh-tdep.h: Add missing registers.
+	(FP_LAST_REGNUM): Rename to FR_LAST_REGNUM.
+	* sh-tdep.c (FP0_REGNUM): Rename to FR0_REGNUM.
+	(FP_LAST_REGNUM): Rename to FR_LAST_REGNUM.
+	(sh_*_register_name): Return NULL for unknown registers.
+	(sh*_show_regs): Rename registers from FPn to FRn.
+	(sh_sh4_register_name): Add missing registers.
+	(sh_sh4_nofpu_register_name): Likewise.
+	(sh4_show_regs): Likewise.
+	(sh4_nofpu_show_regs): Likewise.
+	(sh_sh4_register_type): Likewise.
+	(sh_register_reggroup_p): Likewise.
+	(sh_register_convert_to_virtual): Likewise.
+	(sh_register_convert_to_raw): Likewise.
+	(dr_reg_base_num): Likewise.
+	(sh_pseudo_register_read): Likewise.
+	(sh_pseudo_register_write): Likewise.
+	(sh_dwarf2_frame_init_reg): Simplify.
+	(sh4_gdb_to_shtdi_regno): New function.
+	(sh_gdb_to_shtdi_regno): Likewise.
+	(sh_sh4_register_sim_regno): Likewise.
+	(sh_gdbarch_init): Increase pseudo registers for SH4 FPU targets
+	plus use sh_sh4_register_sim_regno for SH4 targets.
+	* config/sh/tm-sh.h (SHTDI_GDB_REGISTER_MAP): New macro.
+	* shtdi.c (shdbg_GetRegSize): Enable import of API.
+	(shtdi_register_offset): New function.
+	(shtdi_fetch_register): Use SHTDI_GDB_REGISTER_MAP if defined
+	and shdbg_GetRegSize to obtain register	size.
+	(shtdi_store_register): Likewise.
+
+2007-08-13  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Enable static build on Windows.
+
+	* Makefile.in (TCL_CFLAGS): Append @TCL_DEFS@.
+	(TK_CFLAGS): Append @TK_DEFS@.
+	(ITCL_CFLAGS): Append @ITCL_DEFS@.
+	(ITK_CFLAGS): Append @ITK_DEFS@.
+
+2007-08-01  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* symfile.c (struct load_section_data): Add use_vma field.
+	(load_progress_section_data): Likewise.
+	(load_progress): Output "vma" or "lma" as appropriate.
+	(load_section_callback): Use VMA, instead of LMA, if use_vma set.
+	Set use_vma in load_progress_section_data.
+	(generic_load): Handle the new lma or vma option.
+
+2007-02-06  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* shtdi.c (shtdi_create_inferior): Use execute command to run the
+	load command, instead of calling shtdi_load directly.
+
+2007-01-22  Denis Pilat  <denis.pilat@st.com>
+
+	In MI mode, after a step, this allows to print the stop reason a
+	string that represents the current frame identifier (optimization used
+	by STWorkbench):
+	* stack.c (print_frame_id): New global variable.
+	(show_print_frame_id): New function.
+	(print_frame): Print the frame-ID if print_frame_id set.
+	(initialize_stack): Add 'set print frame-id' command.
+
+2007-01-22  Denis Pilat  <denis.pilat@st.com>
+
+	This avoid printing frame information for "info threads" cli command:
+	* thread.c (info_threads_command): do not print stack frame information
+	if argument is nostackframe
+
+2007-01-19  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl26938:
+	* sh-tdep.c (sh_gdbarch_init): Integrate setting of sh_show_regs
+	with setting of everything else. Set sh_show_regs correctly for
+	all new architectures.
+
+2007-01-12  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl26678:
+	* shtdi.c (shtdi_create_inferior): Remove calls to continue_command.
+
+2006-12-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl26816:
+	* shtdi.c (shtdi_xfer_inferior_memory): Replace error message with
+	returning errno.
+
+2006-11-23  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* value.c (value_of_internalvar): Apply endian fix the float values.
+
+2006-11-09  Antony King  <antony.king@st.com>
+
+	Fix INSbl26654:
+	* shtdi.c: Added implementation of DllError() for reporting DLL
+	API errors.
+
+2006-11-08  Antony King  <antony.king@st.com>
+
+	* shtdi.c (shtdi_wait): Convert target signal from SIGTRAP
+	to SIGINT if user has interrupted the target.
+
+2006-10-27  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* shtdi.c (shtdi_close): Don't Deinitialize if not connected.
+
+2006-10-25  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* shtdi.c (shtdi_new_objfile): Don't inform the RTOS awareness when
+	relocatable libraries are loaded.
+
+2006-10-11  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.5-ST-1.0.50.
+
+2006-09-27  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-tdep.c (shtdi_init_simulator_hook): New function.
+	* shtdi.c: New file.
+	* symfile.c (download_write_size): Remove 'static'.
+	* symfile.h (download_write_size): New declaration.
+	* command.h (enum command_class): Add class_stm.
+	* cli/cli-cmds.c: Include windows.h, sys/time.h
+	(sleep_command): New function.
+	(init_cli_cmds): Add sleep command.
+	* config/sh/embed.mt (TDEPFILES): Add shtdi.o .
+	* config/sh/tm-sh.h (SHTDI_JOINT_HW_BREAK_LIMIT): New define.
+	(shtdi_init_simulator_hook): New prototype.
+
+2006-07-07  Denis Pilat  <denis.pilat@st.com>
+
+	* buildsym.c (start_subfile): convert cygwin path into standard windows
+	path for name and dirname parameters.
+
+2006-05-04  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	Fix INSbl15583:
+	* thread.c (valid_thread_id): Call thread_alive() to confirm that
+	the thread table is up to date.
+
+2006-03-20  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* Makefile.in (WIN32RES_OBS): New make variable.
+	(gdb, gdbtui, insight): Add WIN32RES_OBS to dependencies and link.
+	* configure.ac: Add a check for MinGW.
+	(WIN32RES_OBS): New substitution.
+	* configure: Regenerate.
+
+2006-03-17  Denis Pilat  <denis.pilat@st.com>
+
+	* inflow.c (gdb_has_a_terminal): always returns 1 in case of minGW host.
+	This fixes the problem of dir command that do not query user.
+
+2006-03-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* main.c (captured_main): Replace cygdrive support using the cygpath
+	routine now in libiberty.
+	* source.c (directory_command): Likewise.
+	* cli/cli-cmds.c (cd_command, source_command): Likewise.
+
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-tdep.c (sh_gdbarch_init): Add missing architectures to the switch
+	table so that the registers and such are correct.
+
+2006-03-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* value.c (keep_variable_command): New function.
+	(_initialize_values): Add keep-variable command.
+
+2006-03-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-tdep.c (backtrace_abi_sniffer): New variable.
+	(sh_frame_this_id): Do nothing if backtrace_abi_sniffer zero.
+	(sh_gdbarch_init): Add set/show abi-sniffer command.
+	* frame.c (set_backtrace_cmdlist): Remove static.
+	(show_backtrace_cmdlist): Likewise.
+	* frame.h (set_backtrace_cmdlist): Add extern declaration.
+	(show_backtrace_cmdlist): Likewise.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cli/cli-cmds.c: Include errno.h, fcntl.h
+	(fork_escape): New function.
+	(init_cli_cmds): Add fork command.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* embed.mt (TDEPFILES): Add solib.o solib-svr4.o.
+	* config/sh/tm-sh.h: (SOLIB_BKPT_NAME): Define.
+	(TARGET_HAS_RELOCATABLE_LIB): Define.
+	* sh-tdep.c (sh_gdbarch_init): Call
+	set_solib_svr4_fetch_link_map_offsets.
+	* solib-svr4.c (enable_break): Add support for
+	TARGET_HAS_RELOCATABLE_LIB.
+
+2006-03-03  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* config/sh/tm-sh.h (GDBINIT_FILENAME): Create to use .shgdbinit.
+
+2006-02-28  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: Set version to 6.4-ST-1.0.50.
+
+2006-02-28  Denis Pilat  <denis.pilat@st.com>
+
+	* configure.ac: add the "win" to the configdir variable in case of
+	mingw host. Fix the bug that prevented insight.exe from beeing built.
+	* configure: Regenerate.
+
+2006-02-23  Denis Pilat  <denis.pilat@st.com>
+
+	* configure.ac: add pdcurses/pdcurses.a library to be linked when sts-gdb
+	is built for mingw hosts. Include file "curses.h" must be found in pdcurses
+	directory during configure step.
+	* configure: Regenerate.
+	* Makefile.in (CLIBS, CDEPS): add $(LIB_PDCURSES) pdcurses library
+	(INTERNAL_WARN_CFLAGS): add $(PDCURSES_CFLAGS) to compile pdcurses library
+
+2006-02-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* cli/cli-cmds.c (cd_command, source_command): Add /cygdrive/ support
+	for use under MinGW.
+	* main.c (captured_main): Likewise.
+	* source.c (os_open): New function.
+	(openp, find_and_open_source): Use os_open() instead of open().
+	(directory_command): Add /cygdrive/ support for use under MinGW.
+
+2006-02-07  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* defs.h: Use MSDOS settings for MinGW.
+
+2006-01-25  Denis Pilat  <denis.pilat@st.com>
+
+	* version.in: set version to 6.4-ST-1.0.
+	* Makefile.in: generated version.c contains build date.
+
+2006-01-09  Denis Pilat  <denis.pilat@st.com>
+
+	* configure, configure.ac: remove win32-termcap that redefines
+	standard termcap function since we use pdcurses library
+	that redefine it for mingw32 host.
+
+2006-01-09  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* tui/tui-io.c (TUI_USE_PIPE_FOR_READLINE): Undefine.
+
+2006-01-09  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* configure.ac (curses test): Look for curses before ncurses when the
+	host is MinGW (prefer PDcurses over cygwin ncurses).
+	* configure: Regenerate.
+
+2006-01-06  Denis Pilat  <denis.pilat@st.com>
+
+	Apply the insight minGW patch
+	http://sourceforge.net/forum/forum.php?forum_id=511897 for the following:
+	* configure.ac: add kernel32 and psapi library in WIN32LIBS,
+	add configdir="win" for mingw32 host
+	* configure: Regenerate.
+	* configure.host: add mingw32 host support
+	* configure.tgt: add mingw32 host support for arm
+	* remote-rdp.c: for MINGW32 compilation only:
+	 - define WIN32_LEAN_AND_MEAN before includion of windows.h to
+	 - excludes useless headers from the build and reduces compile time.
+	 - add a 3 sec timer when error accessing the board thru RDP interface.
+	* win32-nat.c: windows porting, allow compilation on MSYS environment
+	* config/arm/mingw_embed.mt: add mingw32 host support for arm
+	* config/i386/mingw32.mh: added for mingw32 native compilation,
+	definitions for hosting on WIN32, building with MinGW.
+	* config/i386/mingw32.mt: Likewise.
+	* config/i386/nm-mingw32.h: Likewise.
+	* config/i386/tm-mingw32.h: Likewise.
+	* config/i386/xm-mingw32.h: Likewise.
diff --git a/gdb/Makefile.in b/gdb/Makefile.in
index 2373562..cb79ae4 100644
--- a/gdb/Makefile.in
+++ b/gdb/Makefile.in
@@ -1,6 +1,7 @@
 # Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
 # 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 # Free Software Foundation, Inc.
+# Copyright (c) 2007 STMicroelectronics
 
 # This file is part of GDB.
 
@@ -147,6 +148,7 @@ GDB_WARN_CFLAGS = $(WARN_CFLAGS)
 GDB_WERROR_CFLAGS = $(WERROR_CFLAGS)
 
 GDB_WARN_CFLAGS_NO_FORMAT = `echo " $(GDB_WARN_CFLAGS) " | sed "s/ -Wformat-nonliteral / /g"`
+GDB_WARN_CFLAGS_DISABLE_FORMAT = `echo " $(GDB_WARN_CFLAGS) " | sed "s/\(.* -Wall .*\)/\1-Wno-format /g"`
 
 # Where is the INTL library?  Typically in ../intl.
 INTL = @LIBINTL@
@@ -668,6 +670,7 @@ libbfd_h =	$(BFD_SRC)/libbfd.h
 remote_sim_h =	$(INCLUDE_DIR)/gdb/remote-sim.h
 demangle_h =    $(INCLUDE_DIR)/demangle.h
 obstack_h =     $(INCLUDE_DIR)/obstack.h
+opcode_lx_h = $(INCLUDE_DIR)/opcode/lx.h
 opcode_m68hc11_h = $(INCLUDE_DIR)/opcode/m68hc11.h
 readline_h = 	$(READLINE_SRC)/readline.h
 readline_tilde_h =	$(READLINE_SRC)/tilde.h
@@ -1485,7 +1488,7 @@ $(srcdir)/copying.c: @MAINTAINER_MODE_TRUE@ \
 version.c: Makefile version.in
 	rm -f version.c-tmp version.c
 	echo '#include "version.h"' >> version.c-tmp
-	echo 'const char version[] = "'"`sed q ${srcdir}/version.in`"'";' >> version.c-tmp
+	echo 'const char version[] = "'"`sed q ${srcdir}/version.in`" [build '"__DATE__"]";' >> version.c-tmp
 	echo 'const char host_name[] = "$(host_alias)";' >> version.c-tmp
 	echo 'const char target_name[] = "$(target_alias)";' >> version.c-tmp
 	mv version.c-tmp version.c
@@ -1637,6 +1640,10 @@ printcmd.o: $(srcdir)/printcmd.c
 	$(CC) -c $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS_NO_FORMAT) \
 	   $(GDB_WERROR_CFLAGS) $(srcdir)/printcmd.c
 
+tracepoint.o: $(srcdir)/tracepoint.c
+	$(CC) -c $(INTERNAL_CFLAGS_BASE) $(GDB_WARN_CFLAGS_DISABLE_FORMAT) \
+	   $(GDB_WERROR_CFLAGS) $(srcdir)/tracepoint.c
+
 # FIXME: Procfs.o gets -Wformat errors because things like pid_t don't
 # match output format strings.
 procfs.o: $(srcdir)/procfs.c
@@ -2084,7 +2091,7 @@ event-loop.o: event-loop.c $(defs_h) $(event_loop_h) $(event_top_h) \
 event-top.o: event-top.c $(defs_h) $(top_h) $(inferior_h) $(target_h) \
 	$(terminal_h) $(event_loop_h) $(event_top_h) $(interps_h) \
 	$(exceptions_h) $(cli_script_h) $(gdbcmd_h) $(readline_h) \
-	$(readline_history_h)
+	$(readline_history_h) $(main_h)
 exceptions.o: exceptions.c $(defs_h) $(exceptions_h) $(breakpoint_h) \
 	$(target_h) $(inferior_h) $(annotate_h) $(ui_out_h) $(gdb_assert_h) \
 	$(gdb_string_h) $(serial_h)
@@ -2709,7 +2716,7 @@ sh-tdep.o: sh-tdep.c $(defs_h) $(frame_h) $(frame_base_h) $(frame_unwind_h) \
 	$(value_h) $(dis_asm_h) $(inferior_h) $(gdb_string_h) \
 	$(gdb_assert_h) $(arch_utils_h) $(floatformat_h) $(regcache_h) \
 	$(doublest_h) $(osabi_h) $(sh_tdep_h) $(elf_bfd_h) $(solib_svr4_h) \
-	$(elf_sh_h) $(gdb_sim_sh_h) $(reggroups_h)
+	$(elf_sh_h) $(gdb_sim_sh_h) $(reggroups_h) $(sim_regno_h)
 sol2-tdep.o: sol2-tdep.c $(defs_h) $(frame_h) $(symtab_h) $(sol2_tdep_h)
 solib.o: solib.c $(defs_h) $(gdb_string_h) $(symtab_h) $(bfd_h) $(symfile_h) \
 	$(objfiles_h) $(exceptions_h) $(gdbcore_h) $(command_h) $(target_h) \
diff --git a/gdb/blockframe.c b/gdb/blockframe.c
index a1a4535..49d137b 100644
--- a/gdb/blockframe.c
+++ b/gdb/blockframe.c
@@ -1,3 +1,6 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Get info from stack frames; convert between frames, blocks,
    functions and pc values.
 
@@ -283,6 +286,17 @@ find_pc_partial_function (CORE_ADDR pc, char **name, CORE_ADDR *address,
      section, or the end of the section, as the end of the
      function.  */
 
+#ifdef TARGET_ST200
+  /* Get the symbol size */
+  if (MSYMBOL_INFO(msymbol)) 
+    {
+      cache_pc_function_high =
+      SYMBOL_VALUE_ADDRESS (msymbol) + (CORE_ADDR) MSYMBOL_INFO(msymbol);
+    } 
+  else 
+    {
+#endif
+
   if (MSYMBOL_SIZE (msymbol) != 0)
     cache_pc_function_high = cache_pc_function_low + MSYMBOL_SIZE (msymbol);
   else
@@ -307,6 +321,10 @@ find_pc_partial_function (CORE_ADDR pc, char **name, CORE_ADDR *address,
 	cache_pc_function_high = osect->endaddr;
     }
 
+#ifdef TARGET_ST200
+    }
+#endif
+
  return_cached_value:
 
   if (address)
diff --git a/gdb/breakpoint.c b/gdb/breakpoint.c
index 019f4c8..24806b2 100644
--- a/gdb/breakpoint.c
+++ b/gdb/breakpoint.c
@@ -1,8 +1,13 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* Everything about breakpoints, for GDB.
 
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -152,10 +157,6 @@ static void create_longjmp_breakpoint (char *);
 
 static void create_overlay_event_breakpoint (char *);
 
-static int hw_breakpoint_used_count (void);
-
-static int hw_watchpoint_used_count (enum bptype, int *);
-
 static void hbreak_command (char *, int);
 
 static void thbreak_command (char *, int);
@@ -846,7 +847,8 @@ update_watchpoint (struct breakpoint *b, int reparse)
   for (loc = b->loc; loc;)
     {
       struct bp_location *loc_next = loc->next;
-      remove_breakpoint (loc, mark_uninserted);
+      if (loc->inserted)
+	remove_breakpoint (loc, mark_uninserted);
       xfree (loc);
       loc = loc_next;
     }
@@ -2451,7 +2453,48 @@ watchpoints_triggered (struct target_waitstatus *ws)
   int stopped_by_watchpoint = STOPPED_BY_WATCHPOINT (*ws);
   CORE_ADDR addr;
   struct breakpoint *b;
+ 
+#ifdef TARGET_ST200
+  int other_type_used, used_wp;
+  int bp_watch_set = 0;
 
+  /* check wether any sw watchpoint has been set */
+  ALL_BREAKPOINTS (b)
+    if (b->type == bp_watchpoint) {
+        bp_watch_set = 1;
+        break;
+    }
+
+   used_wp = hw_watchpoint_used_count (bp_hardware_watchpoint, &other_type_used);
+   
+   if ((used_wp > 0) && (bp_watch_set > 0)) {
+  /*
+   * For targets having hw watchpoint facilities, requesting 
+   * watchpoints to gdb will cause hw watchpoints to be set
+   * until the target hardware limit is reached.
+   * Starting from next attempt to set watchpoints after the
+   * one which cause reaching target hardware limit automatically 
+   * results in setting sw watchpoints.
+   * Below condition checks whether a sw watchpoint has been set. 
+   * If we're doing this check it is very likely we already reached 
+   * the limit, that is, we also have a hw watchpoint to be reported.
+   * By the way, in this conditions gdb will step every instruction
+   * and, if target CANNOT_STEP_HW_WATCHPOINTS, also removes hw watchpoints 
+   * before each step. If an hardware watchpoint has been previously set 
+   * it will never hit.
+   * The workaround here is to artificially set stopped_by_watchpoint 
+   * (meaning hw watchpoints always triggered without signaling by 
+   * target), detect that no data address for this watchpoint is available
+   * (thus b->watchpoint_triggered = watch_triggered_unknown) and just 
+   * leave gdb doing the check on watched value changed as it would do 
+   * for any sw watchpoint.
+   * This is a way to allow hw + sw watchpoints to co-exist.
+   */
+       stopped_by_watchpoint = 1;
+   } else {
+       stopped_by_watchpoint = STOPPED_BY_WATCHPOINT (*ws);
+    }
+#endif
   if (!stopped_by_watchpoint)
     {
       /* We were not stopped by a watchpoint.  Mark all watchpoints
@@ -2797,15 +2840,7 @@ bpstat_stop_status (CORE_ADDR bp_addr, ptid_t ptid)
 		/* Stop.  */
 		break;
 	      case WP_VALUE_CHANGED:
-		if (b->type == bp_read_watchpoint)
-		  {
-		    /* Don't stop: read watchpoints shouldn't fire if
-		       the value has changed.  This is for targets
-		       which cannot set read-only watchpoints.  */
-		    bs->print_it = print_it_noop;
-		    bs->stop = 0;
-		    continue;
-		  }
+		/* Stop.  */
 		++(b->hit_count);
 		break;
 	      case WP_VALUE_NOT_CHANGED:
@@ -4597,7 +4632,7 @@ create_exec_event_catchpoint (int tempflag, char *cond_string)
   mention (b);
 }
 
-static int
+int
 hw_breakpoint_used_count (void)
 {
   struct breakpoint *b;
@@ -4612,7 +4647,7 @@ hw_breakpoint_used_count (void)
   return i;
 }
 
-static int
+int
 hw_watchpoint_used_count (enum bptype type, int *other_type_used)
 {
   struct breakpoint *b;
@@ -4628,7 +4663,7 @@ hw_watchpoint_used_count (enum bptype type, int *other_type_used)
 	else if ((b->type == bp_hardware_watchpoint ||
 		  b->type == bp_read_watchpoint ||
 		  b->type == bp_access_watchpoint))
-	  *other_type_used = 1;
+	  (*other_type_used)++;
       }
   }
   return i;
@@ -5765,7 +5800,8 @@ watch_command_1 (char *arg, int accessflag, int from_tty)
 	error (_("Target does not support this type of hardware watchpoint."));
 
       if (target_resources_ok < 0 && bp_type != bp_hardware_watchpoint)
-	error (_("Target can only support one kind of HW watchpoint at a time."));
+	error (_("\
+Target watch resources have been allocated for other watchpoints."));
     }
 
   /* Change the type of breakpoint to an ordinary watchpoint if a hardware
diff --git a/gdb/breakpoint.h b/gdb/breakpoint.h
index 41730c0..ff1aa26 100644
--- a/gdb/breakpoint.h
+++ b/gdb/breakpoint.h
@@ -1,6 +1,10 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Data structures associated with breakpoints in GDB.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
    2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -854,4 +858,11 @@ extern int deprecated_remove_raw_breakpoint (void *);
    target.  */
 int watchpoints_triggered (struct target_waitstatus *);
 
+/* Return number of H/W breakpoints in use.  */
+extern int hw_breakpoint_used_count (void);
+
+/* Return number of H/W watchpoints in use of given type and number of other
+   types of H/W watchpoint in use.  */
+extern int hw_watchpoint_used_count (enum bptype, int *);
+
 #endif /* !defined (BREAKPOINT_H) */
diff --git a/gdb/buildsym.c b/gdb/buildsym.c
index cccd769..aaca661 100644
--- a/gdb/buildsym.c
+++ b/gdb/buildsym.c
@@ -1,7 +1,12 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* Support routines for building symbol tables in GDB's internal format.
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -793,7 +798,16 @@ record_line (struct subfile *subfile, int line, CORE_ADDR pc)
 		   + (subfile->line_vector_length
 		      * sizeof (struct linetable_entry))));
     }
-
+/* 
+   The following code, coming from gdb 6.8,
+   removes some empty lines from the linetable,
+   so the lx_skip_prologue() function 
+   (see lx-tdep.c file line 935) fails when we put 
+   the breakpoint on an empty line. 
+   Probaly we need a better lx_skip_prologue()
+   implementation.   
+*/
+#ifndef TARGET_ST200
   pc = gdbarch_addr_bits_remove (current_gdbarch, pc);
 
   /* Normally, we treat lines as unsorted.  But the end of sequence
@@ -819,9 +833,14 @@ record_line (struct subfile *subfile, int line, CORE_ADDR pc)
 	}
     }
 
+#endif
   e = subfile->line_vector->item + subfile->line_vector->nitems++;
   e->line = line;
+#ifdef TARGET_ST200
+  e->pc = gdbarch_addr_bits_remove (current_gdbarch, pc);
+#else
   e->pc = pc;
+#endif
 }
 
 /* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */
@@ -1031,9 +1050,24 @@ end_symtab (CORE_ADDR end_addr, struct objfile *objfile, int section)
 	         scrambled in reordered executables.  Sort it if
 	         OBJF_REORDERED is true.  */
 	      if (objfile->flags & OBJF_REORDERED)
+#ifdef TARGET_ST200 /* MBTst20762 */
+              /* In ST200 context, the debug info for each source line
+                 consists of two entries in the line_vector table:
+                 .one entry with : line_number, start_address
+                 .another entry with: 0 , end_address
+                 The other targets would only provide the first entry.
+                 Those two entries make the default qsort call work
+                 improperply. Hence the different parameter passing in
+                 order to sort pairs of entries instead of individual
+                 entries. */
+		qsort (subfile->line_vector->item,
+		     subfile->line_vector->nitems / 2,
+		     2 * sizeof (struct linetable_entry), compare_line_numbers);
+#else
 		qsort (subfile->line_vector->item,
 		       subfile->line_vector->nitems,
 		     sizeof (struct linetable_entry), compare_line_numbers);
+#endif
 	    }
 
 	  /* Now, allocate a symbol table.  */
diff --git a/gdb/config.in b/gdb/config.in
index b6aba7d..1534afe 100644
--- a/gdb/config.in
+++ b/gdb/config.in
@@ -45,6 +45,12 @@
 /* Define to the default OS ABI for this configuration. */
 #undef GDB_OSABI_DEFAULT
 
+/* targetfile */
+#undef GDB_TM_FILE
+
+/* hostfile */
+#undef GDB_XM_FILE
+
 /* Define to 1 if you have `alloca', as a function or macro. */
 #undef HAVE_ALLOCA
 
@@ -107,12 +113,6 @@
 /* Define if ELF support should be included. */
 #undef HAVE_ELF
 
-/* Define to 1 if you have the <elf_hp.h> header file. */
-#undef HAVE_ELF_HP_H
-
-/* Define to 1 if your system has the etext variable. */
-#undef HAVE_ETEXT
-
 /* Define to 1 if you have the `fork' function. */
 #undef HAVE_FORK
 
@@ -503,9 +503,6 @@
 /* Define if the prfpregset_t type is broken. */
 #undef PRFPREGSET_T_BROKEN
 
-/* Define to 1 if the "%H, %D and %DD" formats work to print decfloats. */
-#undef PRINTF_HAS_DECFLOAT
-
 /* Define to 1 if the "%Lg" format works to print long doubles. */
 #undef PRINTF_HAS_LONG_DOUBLE
 
@@ -583,10 +580,6 @@
 /* Define if the simulator is being linked in. */
 #undef WITH_SIM
 
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-#undef WORDS_BIGENDIAN
-
 /* Define to 1 if on AIX 3.
    System headers sometimes define this.
    We just want to avoid a redefinition error message.  */
diff --git a/gdb/config/lx/Changes b/gdb/config/lx/Changes
new file mode 100644
index 0000000..0486476
--- /dev/null
+++ b/gdb/config/lx/Changes
@@ -0,0 +1,74 @@
+@(#)Changes	1.11 02/04/00 09:22:14
+
+1.1 Paolo Faraboschi 6/24/98 12:24:49
+
+    lx.mt
+    tm-lx.h
+
+    Initial version
+
+1.2 Geoff Brown 7/1/98 15:29:11
+
+    tm-lx.h
+
+    Defined gdb init file to be ".lxgdbinit" to
+    avoid conflict with the standard init file
+
+1.3 Geoff Brown 7/30/98 09:49:40
+
+    Added SIGTRAMP routine reference
+
+1.4 Richard Ford 8/20/98 14:27:48
+
+    tm-lx.h
+
+    Added support for up to 4 clusters.
+
+1.5 Geoff Brown 9/21/98 10:12:50
+
+    tm-lx.h
+
+    Fixed bug introduced by 1.4.  FP_REGNUM was previously
+    hardwired to 1.  This became a bug after 1.4 was introduced
+
+1.6 Giuseppe Desoli 3/2/99 09:01:26
+
+    tm-lx.h
+
+    introduced macros to support hw breakpoints
+
+1.7 Giuseppe Desoli 4/14/99 15:26:47
+
+    more macros to support hw data watchpoint and hw compatible single step
+    mode
+
+1.8 Geoff Brown 5/20/99 11:08:29
+
+    tm-lx.h
+
+    changed from TARGET_BYTE_ORDER BIG_ENDIAN
+    to           TARGET_BYTE_ORDER_SELECTABLE
+                 TARGET_BYTE_ORDER_DEFAULT BIG_ENDIAN
+
+1.9 Richard Ford 1/23/00 15:07:14
+
+    tm-lx.h
+
+    Some fundamental lx constants that were being defined here
+    have now been moved to <machine/lx1_arch_constants.h>.  In addition
+    <machine/reg_usage.h> is now used to know which registers
+    are used for arg0, etc.
+
+1.10 Paolo Faraboschi 1/28/00 18:21:01
+
+    tm-lx.h
+
+    Update constants to reflect changes in ptregs.h (RVP_REG, ARG*_REG,
+    etc.)
+
+1.11 Geoff Brown 2/4/00 09:21:48
+
+    tm-lx.h
+
+    Modified includes from /machine directory to reflect new
+    generated include files
diff --git a/gdb/config/lx/linux.mh b/gdb/config/lx/linux.mh
new file mode 100644
index 0000000..7639090
--- /dev/null
+++ b/gdb/config/lx/linux.mh
@@ -0,0 +1,10 @@
+# Host: ST200 running Linux
+
+NAT_FILE= nm-linux.h
+NATDEPFILES= inf-ptrace.o  fork-child.o corelow.o			\
+	core-regset.o st200-linux-nat.o					\
+	proc-service.o linux-nat.o linux-fork.o linux-thread-db.o
+
+# The dynamically loaded libthread_db needs access to symbols in the
+# gdb executable.
+LOADLIBES = -ldl -rdynamic
diff --git a/gdb/config/lx/nm-linux.h b/gdb/config/lx/nm-linux.h
new file mode 100644
index 0000000..3aa1b10
--- /dev/null
+++ b/gdb/config/lx/nm-linux.h
@@ -0,0 +1,35 @@
+/* Definitions to make GDB run on an ST200 based machine under GNU/Linux.
+   Copyright 2003 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef NM_ST200LINUX_H
+#define NM_ST200LINUX_H
+
+#include "nm-linux.h"
+
+#define FETCH_INFERIOR_REGISTERS
+
+/* Return sizeof user struct to callers in less machine dependent routines */
+#define KERNEL_U_SIZE kernel_u_size()
+extern int kernel_u_size (void);
+
+/* Offset of the registers within the user area.  */
+#define U_REGS_OFFSET 0
+
+#endif /* NM_ST200LINUX_H */
diff --git a/gdb/configure b/gdb/configure
index e0f36b2..73b9535 100644
--- a/gdb/configure
+++ b/gdb/configure
@@ -7786,7 +7786,6 @@ _ACEOF
 
 fi
 
-
 for ac_header in nlist.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
@@ -15702,7 +15701,6 @@ fi
 # ----------------------- #
 # Checks for structures.  #
 # ----------------------- #
-
 echo "$as_me:$LINENO: checking for struct stat.st_blocks" >&5
 echo $ECHO_N "checking for struct stat.st_blocks... $ECHO_C" >&6
 if test "${ac_cv_member_struct_stat_st_blocks+set}" = set; then
@@ -15836,7 +15834,8 @@ return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+ if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+
   (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
@@ -24435,6 +24434,9 @@ _ACEOF
   fi
 fi
 
+cat >>confdefs.h <<\_ACEOF
+#define WITH_SIM 1
+_ACEOF
 
 
 
@@ -24802,6 +24804,48 @@ _ACEOF
 
 
 
+case "$target" in
+sh*-superh-elf*)
+
+cat >>confdefs.h <<_ACEOF
+#define GDBINIT_FILENAME ".shgdbinit"
+#define SHTDI_GDB_REGISTER_MAP sh_gdb_to_shtdi_regno
+#define TARGET_HAS_RELOCATABLE_LIB 1
+#define SOLIB_BKPT_NAME "_r_debug_state"
+#define SHTDI_JOINT_HW_BREAK_LIMIT 3
+_ACEOF
+
+;;
+lx-*-elf*)
+
+cat >>confdefs.h <<_ACEOF
+#define GDBINIT_FILENAME ".lxgdbinit"
+#define TARGET_HAS_RELOCATABLE_LIB 1
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define SOLIB_BKPT_NAME "_r_debug_state"
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define SHTDI_HW_BREAKPOINT_LIMIT 0
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define SHTDI_HW_WATCHPOINT_LIMIT 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define CANNOT_STEP_HW_WATCHPOINTS 1
+_ACEOF
+
+;;
+esac
+
                     ac_config_files="$ac_config_files Makefile .gdbinit:gdbinit.in"
           ac_config_commands="$ac_config_commands default"
 cat >confcache <<\_ACEOF
diff --git a/gdb/configure.ac b/gdb/configure.ac
index 39246aa..a221a8a 100644
--- a/gdb/configure.ac
+++ b/gdb/configure.ac
@@ -1,7 +1,9 @@
+dnl THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
 dnl Autoconf configure script for GDB, the GNU debugger.
 dnl Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 dnl 2005, 2006
 dnl Free Software Foundation, Inc.
+dnl Copyright (C) 2007 STMicroelectronics
 dnl
 dnl This file is part of GDB.
 dnl 
@@ -1721,6 +1723,25 @@ AC_DEFINE(GDB_DEFAULT_HOST_CHARSET, "ISO-8859-1",
 
 AM_ICONV
 
+
+case "$target" in
+sh*-superh-elf*)
+  AC_DEFINE_UNQUOTED(GDBINIT_FILENAME, ".shgdbinit", [Name of the GDB initialization file. ])
+  AC_DEFINE_UNQUOTED(SHTDI_GDB_REGISTER_MAP, sh_gdb_to_shtdi_regno, [SHTDI to GDB register number mapping function. ])
+  AC_DEFINE(TARGET_HAS_RELOCATABLE_LIB, 1, [Define if the target supports relocatable libraries. ])
+  AC_DEFINE_UNQUOTED(SOLIB_BKPT_NAME, "_r_debug_state", [Shared library breakpoint hook. ])
+  AC_DEFINE(SHTDI_JOINT_HW_BREAK_LIMIT, 3, [Number of shared H/W code and data breakpoints. ])
+;;
+lx-*-elf*)
+  AC_DEFINE_UNQUOTED(GDBINIT_FILENAME, ".lxgdbinit", [Name of the GDB initialization file. ])
+  AC_DEFINE(TARGET_HAS_RELOCATABLE_LIB, 1, [Define if the target supports relocatable libraries. ])
+  AC_DEFINE_UNQUOTED(SOLIB_BKPT_NAME, "_r_debug_state", [Shared library breakpoint hook. ])
+  AC_DEFINE(SHTDI_HW_BREAKPOINT_LIMIT, 0, [Number of  H/W breakpoints. ])
+  AC_DEFINE(SHTDI_HW_WATCHPOINT_LIMIT, 1, [Number of  H/W watchpoints. ])
+  AC_DEFINE(CANNOT_STEP_HW_WATCHPOINTS, 1, [It will be necessary for GDB to step over the watchpoint.])
+;;
+esac
+
 AC_OUTPUT(Makefile .gdbinit:gdbinit.in,
 [
 dnl Autoconf doesn't provide a mechanism for modifying definitions 
diff --git a/gdb/configure.host b/gdb/configure.host
index 672920d..d7c5d4a 100644
--- a/gdb/configure.host
+++ b/gdb/configure.host
@@ -1,3 +1,4 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
 # Mapping of configurations into GDB host definitions.  This is
 # invoked from the autoconf generated configure script.
 
@@ -104,6 +105,8 @@ i[34567]86-*-cygwin*)	gdb_host=cygwin ;;
 
 ia64-*-linux*)		gdb_host=linux ;;
 
+lx-*-linux*)		gdb_host=linux ;;
+
 m68*-*-linux*)		gdb_host=linux ;;
 m68*-*-netbsdelf* | m68*-*-knetbsd*-gnu)
 			gdb_host=nbsdelf ;;
diff --git a/gdb/configure.tgt b/gdb/configure.tgt
index 1dcb833..d488223 100644
--- a/gdb/configure.tgt
+++ b/gdb/configure.tgt
@@ -1,3 +1,4 @@
+# THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
 # Mappings from configurations to GDB target definitions.  This is
 # invoked from the autoconf generated configure script.
 
@@ -171,6 +172,16 @@ i[34567]86-*-solaris2.1[0-9]*)
 			i386-sol2-tdep.o sol2-tdep.o \
 			corelow.o solib.o solib-svr4.o"
 	;;
+lx-*-elf*)		
+   # Target: ST231/ST240 running bare.
+   gdb_target_obs="lx-tdep.o shtdi.o solib.o solib-svr4.o"  
+   build_gdbserver=no  
+   ;;
+lx-*-linux*)	
+   # Target: ST231/ST240 running GNU/Linux
+   gdb_target_obs="lx-linux-tdep.o solib.o solib-svr4.o"
+   build_gdbserver=yes     
+   ;;
 i[34567]86-*-solaris*)
 	# Target: Solaris x86
 	gdb_target_obs="i386-tdep.o i387-tdep.o i386-sol2-tdep.o sol2-tdep.o \
@@ -385,6 +396,12 @@ sh*-*-openbsd*)
 	gdb_target_obs="sh-tdep.o sh64-tdep.o shnbsd-tdep.o \
 			corelow.o solib.o solib-svr4.o"
 	;;
+sh*-superh-elf*)
+	# Target: STMicroelectronics embedded Super-H
+	gdb_target_obs="sh-tdep.o sh64-tdep.o monitor.o dsrec.o \
+			shtdi.o solib.o solib-svr4.o"
+	gdb_sim=../sim/sh/libsim.a
+	;;
 sh64-*-elf*)
 	# Target: Renesas/Super-H 64 bit with simulator
 	gdb_target_obs="sh-tdep.o sh64-tdep.o"
diff --git a/gdb/defs.h b/gdb/defs.h
index 3486df8..7452243 100644
--- a/gdb/defs.h
+++ b/gdb/defs.h
@@ -1,8 +1,13 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* *INDENT-OFF* */ /* ATTR_FORMAT confuses indent, avoid running it for now */
 /* Basic, host-specific, and target-specific definitions for GDB.
    Copyright (C) 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,
    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics
 
    This file is part of GDB.
 
diff --git a/gdb/dfp.c b/gdb/dfp.c
index fff8288..f7f9d0a 100644
--- a/gdb/dfp.c
+++ b/gdb/dfp.c
@@ -1,3 +1,6 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Decimal floating point support for GDB.
 
    Copyright 2007, 2008 Free Software Foundation, Inc.
@@ -395,7 +398,12 @@ decimal_convert (const gdb_byte *from, int len_from, gdb_byte *to,
 		 int len_to)
 {
   decNumber number;
+  gdb_byte dec[16];
+  
+  match_endianness (from, len_from, dec);
+
+  decimal_to_number (dec, len_from, &number);
+  decimal_from_number (&number, dec, len_to);
 
-  decimal_to_number (from, len_from, &number);
-  decimal_from_number (&number, to, len_to);
+  match_endianness (dec, len_to, to);
 }
diff --git a/gdb/dwarf2-frame.c b/gdb/dwarf2-frame.c
index c4cd9f3..6eb1e43 100644
--- a/gdb/dwarf2-frame.c
+++ b/gdb/dwarf2-frame.c
@@ -1,6 +1,7 @@
 /* Frame unwinder for frames with DWARF Call Frame Information.
 
    Copyright (C) 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    Contributed by Mark Kettenis.
 
@@ -337,7 +338,8 @@ execute_cfa_program (gdb_byte *insn_ptr, gdb_byte *insn_end,
   while (insn_ptr < insn_end && fs->pc <= pc)
     {
       gdb_byte insn = *insn_ptr++;
-      ULONGEST utmp, reg;
+      int reg = 0;
+      ULONGEST ureg, utmp;
       LONGEST offset;
 
       if ((insn & 0xc0) == DW_CFA_advance_loc)
@@ -383,42 +385,87 @@ execute_cfa_program (gdb_byte *insn_ptr, gdb_byte *insn_end,
 	      break;
 
 	    case DW_CFA_offset_extended:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
 	      offset = utmp * fs->data_align;
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_offset_extended register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_restore_extended:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_restore_rule (gdbarch, reg, fs, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_restore_extended register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_restore_rule (gdbarch, reg, fs, eh_frame_p);
+		}
 	      break;
 
 	    case DW_CFA_undefined:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNDEFINED;
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_undefined register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_UNDEFINED;
+		}
 	      break;
 
 	    case DW_CFA_same_value:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAME_VALUE;
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_same_value register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAME_VALUE;
+		}
 	      break;
 
 	    case DW_CFA_register:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
-	      utmp = dwarf2_frame_adjust_regnum (gdbarch, utmp, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
-	      fs->regs.reg[reg].loc.reg = utmp;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_register register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  utmp = dwarf2_frame_adjust_regnum (gdbarch, utmp, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_REG;
+		  fs->regs.reg[reg].loc.reg = utmp;
+		}
 	      break;
 
 	    case DW_CFA_remember_state:
@@ -489,51 +536,96 @@ bad CFI data; mismatched DW_CFA_restore_state at 0x%s"), paddr (fs->pc));
 	      break;
 
 	    case DW_CFA_expression:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
-	      fs->regs.reg[reg].loc.exp = insn_ptr;
-	      fs->regs.reg[reg].exp_len = utmp;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_EXP;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_expression register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].loc.exp = insn_ptr;
+		  fs->regs.reg[reg].exp_len = utmp;
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_EXP;
+		}
 	      insn_ptr += utmp;
 	      break;
 
 	    case DW_CFA_offset_extended_sf:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
 	      offset *= fs->data_align;
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_extended_sf register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_val_offset:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
 	      offset = utmp * fs->data_align;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_val_offset register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_val_offset_sf:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_sleb128 (insn_ptr, insn_end, &offset);
 	      offset *= fs->data_align;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
-	      fs->regs.reg[reg].loc.offset = offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_val_offset_sf register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_OFFSET;
+		  fs->regs.reg[reg].loc.offset = offset;
+		}
 	      break;
 
 	    case DW_CFA_val_expression:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &utmp);
-	      fs->regs.reg[reg].loc.exp = insn_ptr;
-	      fs->regs.reg[reg].exp_len = utmp;
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_EXP;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_val_expression register number (%d)"), reg);
+		}
+	      else
+		{
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].loc.exp = insn_ptr;
+		  fs->regs.reg[reg].exp_len = utmp;
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_VAL_EXP;
+		}
 	      insn_ptr += utmp;
 	      break;
 
@@ -583,13 +675,22 @@ bad CFI data; mismatched DW_CFA_restore_state at 0x%s"), paddr (fs->pc));
 	      break;
 
 	    case DW_CFA_GNU_negative_offset_extended:
-	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &reg);
-	      reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &ureg);
+	      reg = ureg;
 	      insn_ptr = read_uleb128 (insn_ptr, insn_end, &offset);
 	      offset *= fs->data_align;
-	      dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
-	      fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
-	      fs->regs.reg[reg].loc.offset = -offset;
+	      if (reg < 0)
+		{
+		  complaint (&symfile_complaints, _("\
+invalid CFI data; illegal DW_CFA_GNU_negative_offset_extended register number (%d)"), reg);
+		}
+	      else
+		{
+		  reg = dwarf2_frame_adjust_regnum (gdbarch, reg, eh_frame_p);
+		  dwarf2_frame_state_alloc_regs (&fs->regs, reg + 1);
+		  fs->regs.reg[reg].how = DWARF2_FRAME_REG_SAVED_OFFSET;
+		  fs->regs.reg[reg].loc.offset = -offset;
+		}
 	      break;
 
 	    default:
@@ -1798,7 +1899,14 @@ decode_frame_entry_1 (struct comp_unit *unit, gdb_byte *start, int eh_frame_p)
 	      break;
 	    }
 	}
+   
+#ifdef TARGET_ST200 /* [CL] st200cc used to keep room for LSDA even if
+                      none was generated. This results in confusing
+                      this reader because it does not trust
+                      augmentation data length */
 
+      if (!cie->initial_instructions)
+#endif
       cie->initial_instructions = buf;
       cie->end = end;
 
diff --git a/gdb/dwarf2read.c b/gdb/dwarf2read.c
index af9585b..9265b23 100644
--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -1,3 +1,6 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* DWARF 2 debugging format support for GDB.
 
    Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
@@ -2820,12 +2823,26 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)
     }
   if (comp_dir != NULL)
     {
+
+#ifdef TARGET_ST200
+          /* skip the "<machine>:" from the compilation directory, 
+             avoid removing "DriveLetter:".  */
+          /* Please note: without this fix, we will have a ghost "file.c"
+             before the correct "/directory/file.c", so will be present 
+             two files rather then one */
+           
+	  char *cp = strchr (comp_dir, ':');
+	  if (cp && cp != comp_dir+1)
+	    comp_dir = cp + 1;
+#else
+
       /* Irix 6.2 native cc prepends <machine>.: to the compilation
 	 directory, get rid of it.  */
       char *cp = strchr (comp_dir, ':');
 
       if (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')
 	comp_dir = cp + 1;
+#endif
     }
 
   if (name == NULL)
diff --git a/gdb/elfread.c b/gdb/elfread.c
index c0dd7fb..dbe8bf1 100644
--- a/gdb/elfread.c
+++ b/gdb/elfread.c
@@ -1,3 +1,6 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Read ELF (Executable and Linking Format) object files for GDB.
 
    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
@@ -378,6 +381,11 @@ elf_symtab_read (struct objfile *objfile, int type,
 		   I encourage people to fix this in the assembler
 		   instead of adding checks here).  */
 		continue;
+#ifdef TARGET_ST200
+	      else if ((sym->name[0] == 'L')
+                       ||((sym->name[0] == '_') && (sym->name[1] == '?')))
+		continue;
+#endif
 	      else
 		{
 		  ms_type = mst_file_text;
diff --git a/gdb/frame.c b/gdb/frame.c
index ded9ae7..1380515 100644
--- a/gdb/frame.c
+++ b/gdb/frame.c
@@ -2,6 +2,7 @@
 
    Copyright (C) 1986, 1987, 1989, 1991, 1994, 1995, 1996, 1998, 2000, 2001,
    2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -397,9 +398,10 @@ frame_find_by_id (struct frame_id id)
 {
   struct frame_info *frame;
 
-  /* ZERO denotes the null frame, let the caller decide what to do
-     about it.  Should it instead return get_current_frame()?  */
-  if (!frame_id_p (id))
+  /* When target has no stack, null frame id most
+     likely means no frame at all.  Return NULL,
+     and let the caller decide what to do.  */
+  if (!target_has_stack && !frame_id_p (id))
     return NULL;
 
   for (frame = get_current_frame ();
@@ -407,6 +409,14 @@ frame_find_by_id (struct frame_id id)
        frame = get_prev_frame (frame))
     {
       struct frame_id this = get_frame_id (frame);
+#if 1
+      /* We use an invalid frame id to mean "could not unwind from
+	 here"!  This hack fixes the "value being assigned to is
+	 no longer active" problem.  This strongly suggests that
+	 we need to change the representation.  */
+      if (!frame_id_p (id) && !frame_id_p (this))
+	return frame;
+#endif
       if (frame_id_eq (id, this))
 	/* An exact match.  */
 	return frame;
@@ -1771,8 +1781,8 @@ frame_stop_reason_string (enum unwind_stop_reason reason)
 
 extern initialize_file_ftype _initialize_frame; /* -Wmissing-prototypes */
 
-static struct cmd_list_element *set_backtrace_cmdlist;
-static struct cmd_list_element *show_backtrace_cmdlist;
+struct cmd_list_element *set_backtrace_cmdlist;
+struct cmd_list_element *show_backtrace_cmdlist;
 
 static void
 set_backtrace_cmd (char *args, int from_tty)
diff --git a/gdb/frame.h b/gdb/frame.h
index 6d93596..7b433a5 100644
--- a/gdb/frame.h
+++ b/gdb/frame.h
@@ -1,8 +1,12 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Definitions for dealing with stack frames, for GDB, the GNU debugger.
 
    Copyright (C) 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997,
    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -721,4 +725,9 @@ extern void deprecated_update_frame_pc_hack (struct frame_info *frame,
 extern void deprecated_update_frame_base_hack (struct frame_info *frame,
 					       CORE_ADDR base);
 
+/* Export 'set backtrace' so that new subcommands may be added elsewhere. */
+
+extern struct cmd_list_element *set_backtrace_cmdlist;
+extern struct cmd_list_element *show_backtrace_cmdlist;
+
 #endif /* !defined (FRAME_H)  */
diff --git a/gdb/gdbarch.c b/gdb/gdbarch.c
index 613064c..0177e2e 100644
--- a/gdb/gdbarch.c
+++ b/gdb/gdbarch.c
@@ -1,3 +1,6 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* *INDENT-OFF* */ /* THIS FILE IS GENERATED */
 
 /* Dynamic architecture support for GDB, the GNU debugger.
@@ -53,6 +56,12 @@
 
 static void alloc_gdbarch_data (struct gdbarch *);
 
+/* #define ST200_BREAKPOINT_ADJUST 1 */
+
+#ifdef ST200_BREAKPOINT_ADJUST
+CORE_ADDR lx_adjust_breakpoint_address(struct gdbarch *gdbarch, CORE_ADDR pcptr);
+#endif
+
 /* Non-zero if we want to trace architecture code.  */
 
 #ifndef GDBARCH_DEBUG
@@ -431,6 +440,9 @@ gdbarch_alloc (const struct gdbarch_info *info,
   gdbarch->coff_make_msymbol_special = default_coff_make_msymbol_special;
   gdbarch->name_of_malloc = "malloc";
   gdbarch->register_reggroup_p = default_register_reggroup_p;
+#ifdef ST200_BREAKPOINT_ADJUST
+  gdbarch->adjust_breakpoint_address=lx_adjust_breakpoint_address;
+#endif
   /* gdbarch_alloc() */
 
   return gdbarch;
diff --git a/gdb/gdbserver/Makefile.in b/gdb/gdbserver/Makefile.in
index 2c7cb75..1d4c917 100644
--- a/gdb/gdbserver/Makefile.in
+++ b/gdb/gdbserver/Makefile.in
@@ -124,6 +124,7 @@ SFILES=	$(srcdir)/gdbreplay.c $(srcdir)/inferiors.c \
 	$(srcdir)/linux-crisv32-low.c $(srcdir)/linux-i386-low.c \
 	$(srcdir)/i387-fp.c \
 	$(srcdir)/linux-ia64-low.c $(srcdir)/linux-low.c \
+   $(srcdir)/linux-lx-low.c $(srcdir)/linux-lx-low.c \
 	$(srcdir)/linux-m32r-low.c \
 	$(srcdir)/linux-m68k-low.c $(srcdir)/linux-mips-low.c \
 	$(srcdir)/linux-ppc-low.c $(srcdir)/linux-ppc64-low.c \
@@ -219,7 +220,7 @@ clean:
 	rm -f gdbserver$(EXEEXT) gdbreplay$(EXEEXT) core make.log
 	rm -f reg-arm.c reg-i386.c reg-ia64.c reg-m32r.c reg-m68k.c
 	rm -f reg-ppc.c reg-sh.c reg-spu.c reg-x86-64.c reg-i386-linux.c
-	rm -f reg-cris.c reg-crisv32.c reg-x86-64-linux.c reg-xtensa.c
+	rm -f reg-cris.c reg-crisv32.c reg-x86-64-linux.c reg-xtensa.c reg-lx.c
 	rm -f arm-with-iwmmxt.c mips-linux.c mips64-linux.c
 	rm -f powerpc-32.c powerpc-64.c powerpc-e500.c
 	rm -f xml-builtin.c stamp-xml target.xml
@@ -301,6 +302,9 @@ linux_low_h = $(srcdir)/linux-low.h
 linux-low.o: linux-low.c $(linux_low_h) $(server_h)
 	$(CC) -c $(CPPFLAGS) $(INTERNAL_CFLAGS) $< @USE_THREAD_DB@
 
+linux-lx-low.o: linux-lx-low.c $(linux_low_h) $(server_h) \
+	$(gdb_proc_service_h)
+
 linux-arm-low.o: linux-arm-low.c $(linux_low_h) $(server_h) \
 	$(gdb_proc_service_h)
 linux-cris-low.o: linux-cris-low.c $(linux_low_h) $(server_h)
@@ -349,6 +353,9 @@ reg-i386-linux.c : $(srcdir)/../regformats/reg-i386-linux.dat $(regdat_sh)
 reg-ia64.o : reg-ia64.c $(regdef_h)
 reg-ia64.c : $(srcdir)/../regformats/reg-ia64.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/reg-ia64.dat reg-ia64.c
+reg-lx.o : reg-lx.c $(regdef_h)
+reg-lx.c : $(srcdir)/../regformats/reg-lx.dat $(regdat_sh)
+	sh $(regdat_sh) $(srcdir)/../regformats/reg-lx.dat reg-lx.c
 reg-m32r.o : reg-m32r.c $(regdef_h)
 reg-m32r.c : $(srcdir)/../regformats/reg-m32r.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/reg-m32r.dat reg-m32r.c
diff --git a/gdb/gdbserver/configure.srv b/gdb/gdbserver/configure.srv
index 4f1c22b..57adaef 100644
--- a/gdb/gdbserver/configure.srv
+++ b/gdb/gdbserver/configure.srv
@@ -73,6 +73,13 @@ case "${target}" in
 			srv_tgtobj="linux-low.o linux-ia64-low.o"
 			srv_linux_usrregs=yes
 			;;
+
+  lx*-*-linux*)		srv_regobj=reg-lx.o
+			srv_tgtobj="linux-low.o linux-lx-low.o"
+			srv_linux_usrregs=yes
+			srv_linux_regsets=yes
+			srv_linux_thread_db=yes
+         ;;
   m32r*-*-linux*)	srv_regobj=reg-m32r.o
 			srv_tgtobj="linux-low.o linux-m32r-low.o"
 			srv_linux_usrregs=yes
diff --git a/gdb/gdbserver/linux-lx-low.c b/gdb/gdbserver/linux-lx-low.c
new file mode 100644
index 0000000..754203b
--- /dev/null
+++ b/gdb/gdbserver/linux-lx-low.c
@@ -0,0 +1,183 @@
+/* GNU/Linux/ST200 specific low level interface, for the remote server for GDB.
+   Copyright 2005 ST Microelectronics R&D Ltd.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "server.h"
+#include "linux-low.h"
+
+#ifdef HAVE_SYS_REG_H
+#include <sys/reg.h>
+#endif
+
+#define lx_num_regs 74
+
+#include <asm/ptrace.h>
+
+static int lx_regmap[] =
+  {
+    PT_PC,
+    PT_PSW,
+    /* general registers */
+    PT_R(0) ,
+    PT_R(1) ,
+    PT_R(2) ,
+    PT_R(3) ,
+    PT_R(4) ,
+    PT_R(5) ,
+    PT_R(6) ,
+    PT_R(7) ,
+    PT_R(8) ,
+    PT_R(9) ,
+    PT_R(10) ,
+    PT_R(11) ,
+    PT_R(12) ,
+    PT_R(13) ,
+    PT_R(14) ,
+    PT_R(15) ,
+    PT_R(16) ,
+    PT_R(17) ,
+    PT_R(18) ,
+    PT_R(19) ,
+    PT_R(20) ,
+    PT_R(21) ,
+    PT_R(22) ,
+    PT_R(23) ,
+    PT_R(24) ,
+    PT_R(25) ,
+    PT_R(26) ,
+    PT_R(27) ,
+    PT_R(28) ,
+    PT_R(29) ,
+    PT_R(30) ,
+    PT_R(31) ,
+    PT_R(32) ,
+    PT_R(33) ,
+    PT_R(34) ,
+    PT_R(35) ,
+    PT_R(36) ,
+    PT_R(37) ,
+    PT_R(38) ,
+    PT_R(39) ,
+    PT_R(40) ,
+    PT_R(41) ,
+    PT_R(42) ,
+    PT_R(43) ,
+    PT_R(44) ,
+    PT_R(45) ,
+    PT_R(46) ,
+    PT_R(47) ,
+    PT_R(48) ,
+    PT_R(49) ,
+    PT_R(50) ,
+    PT_R(51) ,
+    PT_R(52) ,
+    PT_R(53) ,
+    PT_R(54) ,
+    PT_R(55) ,
+    PT_R(56) ,
+    PT_R(57) ,
+    PT_R(58) ,
+    PT_R(59) ,
+    PT_R(60) ,
+    PT_R(61) ,
+    PT_R(62) ,
+    PT_R(63) ,
+    /*  Branch registers */
+    PT_B(0) ,
+    PT_B(1) ,
+    PT_B(2) ,
+    PT_B(3) ,
+    PT_B(4) ,
+    PT_B(5) ,
+    PT_B(6) ,
+    PT_B(7) ,
+  };
+
+static int
+lx_cannot_store_register (int regno)
+{
+  return (regno >= lx_num_regs);
+}
+
+static int
+lx_cannot_fetch_register (int regno)
+{
+  return (regno >= lx_num_regs);
+}
+
+static CORE_ADDR
+lx_get_pc ()
+{
+  unsigned long pc;
+  collect_register_by_name ("pc", &pc);
+  return pc;
+}
+
+static void
+lx_set_pc (CORE_ADDR pc)
+{
+  unsigned long newpc = pc;
+  supply_register_by_name ("pc", &newpc);
+}
+
+static const unsigned long lx_breakpoint = 0x1fa00000; // little-endian only
+#define lx_breakpoint_len 4
+
+static int
+lx_breakpoint_at (CORE_ADDR where)
+{
+  unsigned long insn;
+
+  (*the_target->read_memory) (where, (char *) &insn, 4);
+  if (insn == lx_breakpoint)
+    return 1;
+
+  /* If necessary, recognize more trap instructions here.  GDB only uses the
+     one.  */
+  return 0;
+}
+
+/* Provide only a fill function for the general register set.  ps_lgetregs
+   will use this for NPTL support.  */
+
+static void lx_fill_gregset (void *buf)
+{
+  int i;
+
+  for (i = 0; i < 23; i++)
+    if (lx_regmap[i] != -1)
+      collect_register (i, (char *) buf + lx_regmap[i]);
+}
+
+struct regset_info target_regsets[] = {
+  { 0, 0, 0, GENERAL_REGS, lx_fill_gregset, NULL },
+  { 0, 0, -1, -1, NULL, NULL }
+};
+
+struct linux_target_ops the_low_target = {
+  lx_num_regs,
+  lx_regmap,
+  lx_cannot_fetch_register,
+  lx_cannot_store_register,
+  lx_get_pc,
+  lx_set_pc,
+  (const char *) &lx_breakpoint,
+  lx_breakpoint_len,
+  NULL,
+  0,
+  lx_breakpoint_at,
+};
diff --git a/gdb/infcall.c b/gdb/infcall.c
index 9242c46..9176fa2 100644
--- a/gdb/infcall.c
+++ b/gdb/infcall.c
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -194,7 +195,7 @@ find_function_addr (struct value *function, struct type **retval_type)
   struct type *ftype = check_typedef (value_type (function));
   enum type_code code = TYPE_CODE (ftype);
   struct type *value_type;
-  CORE_ADDR funaddr;
+  CORE_ADDR funaddr = 0;
 
   /* If it's a member function, just look at the function
      part of it.  */
@@ -619,7 +620,13 @@ call_function_by_hand (struct value *function, int nargs, struct value **args)
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	}
     }
-
+#if !defined(TARGET_ST200)
+/* [CL] fix bug #58016
+  http://codex.cro.st.com/tracker/?func=detail&aid=58016&atid=697&group_id=367
+  "gdb.cp/bs15503.exp has 2 failures". Fix a problem of
+  interpretation of the C++ Common Vendor ABI: for ST200, the
+  first, hidden parameter does not make the other parameters
+  shift.  */
   if (lang_struct_return)
     {
       struct value **new_args;
@@ -634,6 +641,7 @@ call_function_by_hand (struct value *function, int nargs, struct value **args)
       args_cleanup = make_cleanup (xfree, args);
     }
   else
+#endif
     args_cleanup = make_cleanup (null_cleanup, NULL);
 
   /* Create the dummy stack frame.  Pass in the call dummy address as,
@@ -641,8 +649,12 @@ call_function_by_hand (struct value *function, int nargs, struct value **args)
      return address should be pointed.  */
   sp = gdbarch_push_dummy_call (gdbarch, function, get_current_regcache (),
 				bp_addr, nargs, args,
-				sp, struct_return, struct_addr);
-
+#if defined(TARGET_ST200)
+   /* [CL] fix bug #58016.  */
+  sp, struct_return || lang_struct_return, struct_addr);
+#else
+  sp, struct_return, struct_addr);
+#endif
   do_cleanups (args_cleanup);
 
   /* Set up a frame ID for the dummy frame so we can pass it to
diff --git a/gdb/inflow.c b/gdb/inflow.c
index f7bf7d1..1d1c758 100644
--- a/gdb/inflow.c
+++ b/gdb/inflow.c
@@ -2,6 +2,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -108,6 +109,10 @@ gdb_has_a_terminal_flag = have_not_checked;
 int
 gdb_has_a_terminal (void)
 {
+#ifdef __MINGW32__
+  return 1;
+#endif
+
   switch (gdb_has_a_terminal_flag)
     {
     case yes:
diff --git a/gdb/infrun.c b/gdb/infrun.c
index c863736..71f9160 100644
--- a/gdb/infrun.c
+++ b/gdb/infrun.c
@@ -1,9 +1,13 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 2008-2009
+*/
 /* Target-struct-independent code to start (run) and stop an inferior
    process.
 
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -699,6 +703,16 @@ prepare_to_proceed (int step)
       return 0;
     }
 
+  /* Switch to WAIT_PID if target unable to control threads.  */
+  if (!ptid_equal (wait_ptid, minus_one_ptid)
+      && !ptid_equal (inferior_ptid, wait_ptid)
+      && !target_can_lock_scheduler)
+    {
+      printf_filtered (_("[Switching to %s]\n"),
+		       target_pid_to_str (wait_ptid));
+      switch_to_thread (wait_ptid);
+    }
+
   /* Switched over from WAIT_PID.  */
   if (!ptid_equal (wait_ptid, minus_one_ptid)
       && !ptid_equal (inferior_ptid, wait_ptid)
@@ -1853,8 +1867,11 @@ handle_inferior_event (struct execution_control_state *ecs)
 	 the inferior over it.  If we have non-steppable watchpoints,
 	 we must disable the current watchpoint; it's simplest to
 	 disable all watchpoints and breakpoints.  */
-	 
+#ifdef TARGET_ST200	 
+      if ((!HAVE_STEPPABLE_WATCHPOINT) && (STOPPED_BY_WATCHPOINT(ecs->ws)))
+#else
       if (!HAVE_STEPPABLE_WATCHPOINT)
+#endif
 	remove_breakpoints ();
       registers_changed ();
       target_resume (ecs->ptid, 1, TARGET_SIGNAL_0);	/* Single step */
@@ -3202,7 +3219,10 @@ Further execution is probably impossible.\n"));
          bpstat_print() contains the logic deciding in detail
          what to print, based on the event(s) that just occurred. */
 
-      if (stop_print_frame)
+      /* If --batch-silent is enabled then there's no need to print the current
+	 source location, and to try risks causing an error message about
+	 missing source files.  */
+      if (stop_print_frame && !batch_silent)
 	{
 	  int bpstat_ret;
 	  int source_flag;
diff --git a/gdb/lx-linux-tdep.c b/gdb/lx-linux-tdep.c
new file mode 100644
index 0000000..a9fdfff
--- /dev/null
+++ b/gdb/lx-linux-tdep.c
@@ -0,0 +1,1926 @@
+/*  lx-linux-tdep.c - Macro and function for GDB supporting lx
+(c) Copyright Hewlett-Packard Company 1999-2004
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+itunder the terms of the GNU General Public License as published by he
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING. If not, write to the
+Free Software Foundation,59 Temple Place -Suite 330, Boston, MA
+02111-1307, USA. */
+
+
+static char __attribute__((unused)) sccs_id[] = "@(#)lx-tdep.c	1.27 11/10/00 22:09:41";
+
+
+#include <stdio.h>
+#include "defs.h"
+#include "arch-utils.h"
+#include "frame.h"
+#include "obstack.h"
+#include "symtab.h"
+#include "symfile.h"
+#include "gdbtypes.h"
+#include "gdbcmd.h"
+#include "gdbcore.h"
+#include "value.h"
+#include "dis-asm.h"
+#include "inferior.h"		/* for BEFORE_TEXT_END etc. */
+#include "regcache.h"
+#include "gdb_string.h"
+#include "../include/opcode/lx.h"
+#include "lx-linux-tdep.h"
+#include "dwarf2-frame.h"
+#include "frame-base.h"
+#include "frame-unwind.h"
+#include "solib-svr4.h"
+
+static int lx_tdep_debug;
+
+inline CORE_ADDR lx_read_mem_word(CORE_ADDR a) {
+  CORE_ADDR word ;
+  read_memory (a, (char *) &word, sizeof(CORE_ADDR));
+#ifdef PM_DEBUG
+  printf_filtered("address:  0x%08X\n", (unsigned int)a);
+  printf_filtered("value  :  0x%08X\n", (unsigned int)word);
+#endif
+  word = BSWAP(word);
+#ifdef PM_DEBUG
+  printf_filtered("swap   :  0x%08X\n", (unsigned int)word);
+#endif
+  return word;
+}
+
+inline void lx_write_mem_word(CORE_ADDR a,CORE_ADDR word) {
+#ifdef PM_DEBUG
+  printf_filtered("address:  0x%08X\n", (unsigned int)a);
+  printf_filtered("value  :  0x%08X\n", (unsigned int)word);
+#endif
+  word = BSWAP(word);
+#ifdef PM_DEBUG
+  printf_filtered("swap   :  0x%08X\n", (unsigned int)word);
+#endif
+  write_memory (a, (char *) &word, sizeof(CORE_ADDR));
+}
+
+#define CORE_BUNDLE_STOP                 0x80000000 /** Bundle Stop Bit Mask  **/
+
+#include <machine/ptregs.h>
+
+/* This is a constant. If it get's dynamic, we can do
+   register_size(gdbarch, reg) */
+#define REGISTER_SIZE(reg) 4
+
+/* Get the type associated with the data stored in register
+   REGNUM. This data type is used for display purposes and to get the
+   size of the register. */
+static struct type *
+lx_register_type (struct gdbarch *gdbarch, int regnum)
+{
+  if (lx_tdep_debug>1) {
+    fprintf_unfiltered (gdb_stdlog, "%s regnum %d\n", __FUNCTION__, regnum);
+  }
+  
+  if (regnum == PC_REGNUM)
+    return builtin_type_void_func_ptr;
+
+  if (regnum == SP_REGNUM)
+    return builtin_type_void_data_ptr;
+
+  return builtin_type_int;
+}
+
+void
+shtdi_init_simulator_hook ()
+{
+  const char *envname = "ST200_SIM_PROFILE";
+  char *superh_sim_profile = getenv (envname);
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s superh_sim_profile %s\n", __FUNCTION__, superh_sim_profile);
+  }
+  if (!superh_sim_profile)
+    {
+      xasprintf (&superh_sim_profile, "%s=%s", envname,
+		 get_exec_file (0));
+      putenv (superh_sim_profile);
+    }
+}
+
+
+/* Fixme(al):
+ *    The following section corresponds to the glue gdb need to manage LX opcodes.
+ *    This glue was initially generated by machgen through lxopcodes.c that is no more maintained.
+ *    Think about implementation of an assert if archi is different from st231 or st240.
+*/
+/* ===========[ Start of machgen glue ]============== */
+
+static int lx_match_opc_entry(unsigned int inst, lxopc_t *entry)
+{
+   if (lx_tdep_debug) {
+     fprintf_unfiltered (gdb_stdlog, "%s inst %d\n", __FUNCTION__, inst);
+   }
+   return (inst & entry->mask) == entry->opcode;
+}
+
+/* Test whether an instruction matches a given gdb macro pattern. */
+static int lx_gdb_match(unsigned int inst, enum lx_gdb_patterns which)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s inst %d\n", __FUNCTION__, inst);
+  }
+  return lx_match_opc_entry(inst, &lx_gdb_pattern_tab[which]);
+}
+
+/*
+ * Given and address, fetch the stored instruction --
+ * a little care is needed to deal with the possibility
+ * that the given location has been overwritten with a breakpoint
+ */
+
+static unsigned int 
+lx_get_inst (CORE_ADDR memaddr, unsigned int *inst)
+{
+  unsigned int tmp;
+  int i = read_memory_nobpt (memaddr, ((char *) &tmp), 4);
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s i %d\n", __FUNCTION__, i);
+  }
+  tmp = BSWAP(tmp);
+  *inst = tmp;
+  return i ? 0 : 1;
+}
+
+/*
+ * Get an lx immediate -- should this be in the opcodes library ?
+ *
+ */
+
+static int 
+immval (unsigned int pc)
+{
+  unsigned int inst;
+  int imm;
+  int rimm;
+  int limm;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s pc %d\n", __FUNCTION__, pc);
+  }
+  lx_get_inst (pc, &inst);
+  imm = (inst >> 12) & 0x1ff;
+  lx_get_inst (pc - 4, &inst);
+  rimm = LXISIMMEXTR (inst) ? LXIMMVAL (inst) : 1;
+  lx_get_inst (pc + 4, &inst);
+  limm = LXISIMMEXTL (inst) ? LXIMMVAL (inst) : 1;
+  if (limm != 1)
+    {
+      return limm | imm;
+    }
+  else if (rimm != 1)
+    {
+      return rimm | imm;
+    }
+  else
+    {
+      return ((int) (imm << 23)) >> 23;
+    }
+}
+
+
+/* compute a REGNUM from the DWARF2 register number */
+static int
+lx_dwarf2_reg_to_regnum (struct gdbarch *gdbarch, int reg)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s reg %d\n", __FUNCTION__, reg);
+  }
+  return reg + NUM_CLUSTER_INDEP_REGS;
+}
+
+/* lx_push_dummy_call: This function replaces the deprecated
+   lx_push_arguments functions.
+*/
+static CORE_ADDR
+lx_push_dummy_call (struct gdbarch *gdbarch, 
+                    struct value *function,
+                    struct regcache *regcache,
+                    CORE_ADDR bp_addr,
+                    int nargs, struct value **args,
+                    CORE_ADDR sp,
+                    int struct_return, CORE_ADDR struct_addr)
+{
+  int argreg;
+  int argnum;
+  CORE_ADDR final_sp;
+  char move_to_stack=0;
+  int remaining_len = 0;
+  argreg = ARG0_REGNUM;
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "{ %s initial sp %s\n", __FUNCTION__, paddr(sp));
+  }
+
+  /* ensure the stack is on an 8 byte boundary */
+  if (sp % 8) {
+    sp >>= 3;
+    sp <<= 3;
+  }
+
+  if (struct_return)
+    regcache_cooked_write_unsigned (regcache, STRUCT_RETURN_REGNUM, struct_addr);
+
+  /* [CL] first, count how many arguments can go in registers */
+  for (argnum = 0; argnum < nargs && !move_to_stack; argnum++)
+    {
+      char *val;
+      struct value *arg = args[argnum];
+      struct type *arg_type = check_typedef (value_type (arg));
+      int len = TYPE_LENGTH (arg_type);
+      enum type_code typecode = TYPE_CODE (arg_type);
+
+      /* [CL] enforce ABI padding */
+      switch(typecode) {
+      case TYPE_CODE_STRUCT:
+      case TYPE_CODE_UNION:
+      case TYPE_CODE_ARRAY:
+	if (len < 4) {
+	  len = 4;
+	} else if (len > 4) {
+	  /* pad to a multiple of 32 bits */
+	  len += 3;
+	  len >>= 2;
+	  len <<= 2;
+	}
+	break;
+
+      case TYPE_CODE_PTR:
+      case TYPE_CODE_ENUM:
+      case TYPE_CODE_INT:
+      case TYPE_CODE_FLT:
+	if (len < 4) {
+	  len = 4;
+	}
+	break;
+
+      default:
+	break;
+      }
+
+      /* [CL] Enforce ABI alignment */
+      switch(typecode) {
+      case TYPE_CODE_STRUCT:
+      case TYPE_CODE_UNION:
+      case TYPE_CODE_ARRAY:
+	if (len > 4) {
+	  /* align aggregate to 8-byte boundary */
+	  if ((argreg <= ARGLAST_REGNUM) &&
+	      (argreg & 1)) {
+	    argreg++;
+	  }
+	}
+	if (argreg > ARGLAST_REGNUM) {
+	  move_to_stack=1;
+	}
+	break;
+
+      case TYPE_CODE_PTR:
+      case TYPE_CODE_ENUM:
+      case TYPE_CODE_INT:
+      case TYPE_CODE_FLT:
+	if (len > 4) {
+	  /* align 64 bit scalars to 8-byte boundary */
+	  if ((argreg <= ARGLAST_REGNUM) &&
+	      (argreg & 1)) {
+	    argreg++;
+	  }
+	}
+
+	if (argreg > ARGLAST_REGNUM) {
+	  move_to_stack=1;
+	}
+	break;
+      default:
+	break;
+      }
+
+      /* Copy the argument to general registers or the stack in
+         register-sized pieces.  Large arguments are split between
+         registers and stack.  */
+
+      while (len > 0 && !move_to_stack)
+	{
+	  int partial_len = len < 4 ? len : 4;
+
+	  if (argreg <= ARGLAST_REGNUM)
+	    {
+	      argreg++;
+	    }
+	  else
+	    {
+	      move_to_stack=1;
+	      break;
+	    }
+	  len -= partial_len;
+	  val += partial_len;
+	}
+      remaining_len = len;
+    }
+
+  /* Compute the required stack size. We have to reserve the space
+     necessary for the remaining arguments. The 16 bytes for the
+     scratch area are added at the end of this function */
+
+  if (move_to_stack) {
+    int stack_arg = argnum-1;
+    int stack_size = 0;
+
+    for(argnum = stack_arg; argnum < nargs; argnum++)
+      {
+	struct value *arg = args[argnum];
+	struct type *arg_type = check_typedef (value_type (arg));
+	int len = TYPE_LENGTH (arg_type);
+	enum type_code typecode = TYPE_CODE (arg_type);
+
+	/* [CL] enforce ABI padding */
+	switch(typecode) {
+	case TYPE_CODE_STRUCT:
+	case TYPE_CODE_UNION:
+	case TYPE_CODE_ARRAY:
+	  if (len < 4) {
+	    len = 4;
+	  } else if (len > 4) {
+	    /* pad to a multiple of 32 bits */
+	    len += 3;
+	    len >>= 2;
+	    len <<= 2;
+	  }
+	  break;
+
+	case TYPE_CODE_PTR:
+	case TYPE_CODE_ENUM:
+	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
+	  if (len < 4) {
+	    len = 4;
+	  }
+	  break;
+
+	default:
+	    break;
+	}
+
+	/* [CL] Enforce ABI alignment */
+	switch(typecode) {
+	case TYPE_CODE_STRUCT:
+	case TYPE_CODE_UNION:
+	case TYPE_CODE_ARRAY:
+	  if (len > 4) {
+	    /* align aggregate to 8-byte boundary */
+	    if (stack_size % 8) {
+	      stack_size += 4;
+	    }
+	  }
+	  break;
+
+	case TYPE_CODE_PTR:
+	case TYPE_CODE_ENUM:
+	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
+	  if (len > 4) {
+	    /* align 64 bit scalars to 8-byte boundary */
+	    if (stack_size % 8) {
+	      stack_size += 4;
+	    }
+	  }
+	  break;
+
+	default:
+	  break;
+	}
+
+	/* For the first argument going to the stack, substract the
+	   size of the part which is in registers */
+	if (argnum == stack_arg) {
+	  len = remaining_len;
+	}
+
+	stack_size += len;
+
+      if (lx_tdep_debug) {
+        fprintf_unfiltered (gdb_stdlog, "%s stack size after arg %d : %d\n", __FUNCTION__, argnum, stack_size);
+      }
+
+    }
+
+
+    sp -= stack_size;
+
+    /* keep the stack on an 8 byte boundary */
+    if (sp % 8) {
+      sp >>= 3;
+      sp <<= 3;
+    }
+  }
+
+  final_sp = sp;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s final sp after all args %s\n", __FUNCTION__, paddr(final_sp));
+  }
+
+  /* Finally perform the actual passing of arguments.
+     Start with registers then move to the stack if necessary */
+  argreg = ARG0_REGNUM;
+  for (argnum = 0; argnum < nargs; argnum++)
+    {
+      char *val;
+      struct value *arg = args[argnum];
+      struct type *arg_type = check_typedef (value_type (arg));
+      int len = TYPE_LENGTH (arg_type);
+      enum type_code typecode = TYPE_CODE (arg_type);
+      int swapped64bits = 0;
+      CORE_ADDR regval;
+      int padding;
+
+      val = (char *) value_contents (arg);
+      padding = 0;
+
+      /* [CL] enforce ABI padding */
+      switch(typecode) {
+      case TYPE_CODE_STRUCT:
+      case TYPE_CODE_UNION:
+      case TYPE_CODE_ARRAY:
+	if (len < 4) {
+	  padding = 4 - len;
+	  len = 4;
+	} else if (len > 4) {
+	  /* pad to a multiple of 32 bits */
+	  padding = len;
+	  len += 3;
+	  len >>= 2;
+	  len <<= 2;
+	  padding = len - padding;
+	}
+	break;
+
+      case TYPE_CODE_PTR:
+      case TYPE_CODE_ENUM:
+      case TYPE_CODE_INT:
+      case TYPE_CODE_FLT:
+	if (len < 4) {
+	  len = 4;
+	  padding = 4 - len;
+	}
+	break;
+
+      default:
+	break;
+      }
+
+      /* [CL] Enforce ABI alignment */
+      switch(typecode) {
+      case TYPE_CODE_STRUCT:
+      case TYPE_CODE_UNION:
+      case TYPE_CODE_ARRAY:
+	if (len > 4) {
+	  /* align aggregate to 8-byte boundary */
+	  if ((argreg <= ARGLAST_REGNUM) &&
+	      (argreg & 1)) {
+	    argreg++;
+	  }
+	  if ((argreg > ARGLAST_REGNUM) &&
+	      (sp % 8)) {
+	    sp += 4;
+	  }
+	}
+	break;
+
+      case TYPE_CODE_PTR:
+      case TYPE_CODE_ENUM:
+      case TYPE_CODE_INT:
+      case TYPE_CODE_FLT:
+	if (len > 4) {
+	  /* align 64 bit scalars to 8-byte boundary */
+	  if ((argreg <= ARGLAST_REGNUM) &&
+	      (argreg & 1)) {
+	    argreg++;
+	  }
+	  if ((argreg > ARGLAST_REGNUM) &&
+	      (sp % 8)) {
+	      sp += 4;
+	  }
+	}
+	break;
+
+      default:
+	break;
+      }
+
+      /* Copy the argument to general registers or the stack in
+         register-sized pieces.  Large arguments are split between
+         registers and stack.  */
+
+      if (padding > 0) {
+	/* Prepare padding : extract from memory only the supplied bits */
+	len = TYPE_LENGTH (arg_type);
+      }
+
+      while (len > 0)
+	{
+	  int partial_len = len < 4 ? len : 4;
+
+	  if (argreg <= ARGLAST_REGNUM)
+	    {
+	      regval = extract_unsigned_integer (val, partial_len);
+
+	      /* Handle padding */
+	      if ((len < 4) && (padding > 0)) {
+		switch(typecode) {
+		  /* Integral values smaller than 32 bits are padded
+		     on the left. Nothing to do, this is ensured by
+		     extract_address() */
+		case TYPE_CODE_PTR:
+		case TYPE_CODE_ENUM:
+		case TYPE_CODE_INT:
+		case TYPE_CODE_FLT:
+		  break;
+
+		  /* Aggregates are padded on the left in little
+		     endian mode, on the right in big endian */
+		case TYPE_CODE_STRUCT:
+		case TYPE_CODE_UNION:
+		case TYPE_CODE_ARRAY:
+		  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG) {
+		    regval <<= (padding * 8);
+		  }
+
+		  break;
+
+		default:
+		    break;
+		}
+		padding = 0;
+	      }
+
+	      /* It's a simple argument being passed in a general
+	         register.  */
+
+	      /* Handle special case of 64 bits integral or double
+		 floating point parameter in big-endian mode */
+	      if ( (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
+		   && (len == 8)
+		   && (typecode == TYPE_CODE_INT
+		       || typecode == TYPE_CODE_FLT) ) {
+		regcache_cooked_write_unsigned (regcache, argreg+1, regval);
+		swapped64bits = 1;
+	      } else {
+		regcache_cooked_write_unsigned (regcache, argreg, regval);
+		argreg++;
+		if (swapped64bits) {
+		  argreg++;
+		  swapped64bits = 0;
+		}
+	      }
+	    }
+	  else
+	    {
+	      /* Write this portion of the argument to the stack.  */
+	      partial_len = len;
+
+	      /* Handle padding */
+	      /* Padding applies to the last portion of the argument,
+		 so if padding is needing, split argument */
+	      if ((len > 4) && (padding > 0)) {
+		partial_len >>= 2;
+		partial_len <<= 2;
+	      }
+
+	      /* Integral values smaller than 32 bits are padded on
+		 the left (ie value is in the least significant
+		 bits). */
+	      /* No need to make a difference between integral and
+		 aggregates, as it turns out the be same padding */
+
+	      write_memory (sp, val, partial_len);
+	      sp += partial_len;
+
+	      /* In big endian, write padding after actual
+		 value */
+	      if ((len < 4) && (padding > 0))
+		{
+		  char pad[padding] ;
+		  write_memory (sp, pad, padding);
+		  sp += padding;
+		}
+	    }
+	  len -= partial_len;
+	  val += partial_len;
+	}
+    }
+
+
+  /* Store return address. */
+  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);
+
+  /* Update stack pointer.  */
+  regcache_cooked_write_unsigned (regcache, SP_REGNUM, 
+				  final_sp-SCRATCHAREASIZE);
+
+  /* Return adjusted stack pointer.  */
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s final sp %s }\n", __FUNCTION__, paddr(final_sp-SCRATCHAREASIZE));
+  }
+  
+  /* [FR] : This one was tricky to get right. 
+     Note that we don't return the value stored in the SP
+     register. That's because the returned value is used as the
+     stack_addr part of the frame_id generated by the dummy frame
+     machinery. All frame unwinders must agree on what this address
+     will be. The ST200 compiler now generates Dwarf frame information
+     where 
+          CFA = <function entry SP> + SCRATCHAREASIZE.
+     The CFA is the value the dwarf unwinder will use as the
+     stack_addr for the frames it'll unwind and thus every other
+     unwinder has to follow this rule if you want them to cooperate
+     gently. The dummy frame unwinder will just use the value we
+     return here.
+     As a consequence we return:
+          final_sp - SCRATCHAREASIZE + SCRATCHAREASIZE = final_sp
+  */
+
+  return final_sp;
+}
+
+/* 
+ * Function: extract_return_value
+ *  Find a function's return value in the appropriate 
+ * registers (in regbuf), and copy it into valbuf.  
+ *
+ * Doesn't deal with structure returns yet
+ */
+
+static void
+lx_extract_return_value (type, regcache, valbuf)
+     struct type *type;
+     struct regcache *regcache;
+     gdb_byte *valbuf;
+{
+  int len = TYPE_LENGTH (type);
+  enum type_code typecode = TYPE_CODE (type);
+  unsigned int i;
+  /* ret value is in r0.16, and r0.16 is in 18th position in regbuf;
+     hence offset is 18*4, i.e., 72
+  */
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s typecode %d \n", __FUNCTION__, typecode);
+  }
+  
+  if (len <= 4) 
+    {
+      
+      /* Aggregates are stored in the same way whatever the endianness is */
+      switch(typecode) 
+	{
+	case TYPE_CODE_STRUCT:
+	case TYPE_CODE_UNION:
+	case TYPE_CODE_ARRAY:
+	  regcache_raw_read_part(regcache, ARG0_REGNUM, 0, len, valbuf);
+	  break;
+	  /* Integral types are not stored on the same locations,
+	   * depending on the endianness */
+	case TYPE_CODE_PTR:
+	case TYPE_CODE_ENUM:
+	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
+	case TYPE_CODE_REF:
+	  regcache_raw_read_part(regcache, ARG0_REGNUM,
+				 gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE ? 0 : 4 - len, 
+				 len, valbuf);
+	  break;
+	case TYPE_CODE_BOOL:
+ 	  regcache_raw_read_part(regcache, ARG0_REGNUM,
+ 				 gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE ? 0 : 4 - len, 
+ 				 len, valbuf);
+ 	  break;
+	default:
+	  warning ("function return type not supported");
+	  break;
+	}
+    } 
+  else if (len <= 32) 
+    {
+      /* [CL] enforce ABI padding */
+      switch(typecode) 
+	{
+	case TYPE_CODE_STRUCT:
+	case TYPE_CODE_UNION:
+	case TYPE_CODE_ARRAY:
+	  /* pad to a multiple of 32 bits */
+	  len += 3;
+	  len >>= 2;
+	  len <<= 2;
+	  break;
+	  
+	case TYPE_CODE_PTR:
+	case TYPE_CODE_ENUM:
+	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
+	case TYPE_CODE_REF:
+	  /* These ones should be 64 bits, so no padding required */
+	  break;
+	default:
+		  warning ("function return type not supported");
+	  break;
+	}
+      
+      /* [CL] Handle special case of of 64 bits integral or double
+	 floating point in big-endian mode */
+      /* FIXME: handle complex values */
+      if ( (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
+	   && (typecode == TYPE_CODE_INT ||
+	       typecode == TYPE_CODE_FLT)
+	   && len == 8) {
+	regcache_raw_read(regcache, ARG0_REGNUM + 1,
+			    valbuf);
+	regcache_raw_read(regcache, ARG0_REGNUM,
+			    valbuf + REGISTER_SIZE(ARG0_REGNUM));
+      } else {
+
+	/* [FR] : FIXME : We may adjust the 'len' above. If we did this,
+	   we'll certainly write after the end of the passed value
+	   buffer, because the value has been constructed using what the
+	   type indicated. The old code wasn't using regcaches, but did
+	   the same (dangerous) assumption. If the value sometimes gets
+	   adjusted, we should use regcache_raw_read_part, but I don't
+	   know which end of the buffer should be truncated. */
+	for (i=0; i<len/REGISTER_SIZE(ARG0_REGNUM); i++) 
+	  {
+	    regcache_raw_read(regcache, ARG0_REGNUM + i,
+			      valbuf + i*REGISTER_SIZE(ARG0_REGNUM));
+	  }
+      }
+    } 
+  else 
+    {
+      error ("bad size for return value");
+    }
+}
+
+static void
+lx_value_to_register_buffer(int len,
+			    const gdb_byte *src,
+			    gdb_byte dest[4])
+{
+    int i;
+    dest[3] = dest[2] = dest[1] = dest[0] = 0;
+
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s TARGET_BYTE_ORDER %d \n", __FUNCTION__, gdbarch_byte_order (current_gdbarch));
+  }
+    
+    if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
+	{
+	    i = 4 - len;
+	    while (len--)
+		dest[i++] = *src++;
+	}
+    else
+	{
+	    i = 0;
+	    while (len--)
+		dest[i++] = *src++;
+	}
+	
+}
+
+/* I'm sure the following code could be factorized with the above
+   funtion. */
+/*
+ * Write into the appropriate registers a function return value stored
+   in VALBUF of type TYPE, given in virtual format.
+ */
+static
+void lx_store_return_value(struct type *type,
+			   struct regcache *regcache,
+			   const gdb_byte *valbuf)
+{
+  enum type_code typecode = TYPE_CODE (type);
+  int len = TYPE_LENGTH (type);
+  gdb_byte reg_buffer[4];
+  int i;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s typecode %d\n", __FUNCTION__, typecode);
+  }
+
+  if (len <= 4) 
+    {
+      /* Aggregates are stored in the same way whatever the endianness is */
+      switch(typecode) 
+	{
+	case TYPE_CODE_STRUCT:
+	case TYPE_CODE_UNION:
+	case TYPE_CODE_ARRAY:
+	  regcache_raw_write(regcache, ARG0_REGNUM, valbuf);
+	  break;
+	  /* Integral types are not stored on the same locations,
+	   * depending on the endianness */
+	case TYPE_CODE_PTR:
+	case TYPE_CODE_ENUM:
+	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
+	    /* This will take care of endianness and of the zeroing */
+	    lx_value_to_register_buffer(len, valbuf, reg_buffer);
+	    regcache_raw_write(regcache, ARG0_REGNUM, (char*)reg_buffer);
+	  break;
+
+	default:
+	  warning ("function return type not supported");
+	  break;
+	}
+    } 
+  else if (len <= 32) 
+    {
+      /* [CL] enforce ABI padding */
+      switch(typecode) 
+	{
+	case TYPE_CODE_STRUCT:
+	case TYPE_CODE_UNION:
+	case TYPE_CODE_ARRAY:
+	  /* pad to a multiple of 32 bits */
+	  len += 3;
+	  len >>= 2;
+	  len <<= 2;
+	  break;
+	  
+	case TYPE_CODE_PTR:
+	case TYPE_CODE_ENUM:
+	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
+	  /* These ones should be 64 bits, so no padding required */
+	    break;
+
+	default:
+	  warning ("function return type not supported");
+	  break;
+	}
+      
+      /* [CL] Handle special case of of 64 bits integral or double
+	 floating point in big-endian mode */
+      /* FIXME: handle complex values */
+      if ( (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
+	   && (typecode == TYPE_CODE_INT ||
+	       typecode == TYPE_CODE_FLT)
+	   && len == 8) {
+	regcache_raw_write(regcache, ARG0_REGNUM + 1,
+			    valbuf);
+	regcache_raw_write(regcache, ARG0_REGNUM,
+			    valbuf + REGISTER_SIZE(ARG0_REGNUM));
+      } else {
+
+	/* [FR] : FIXME : look at the same spot in
+	   lx_extract_return_value. The comment is also accurate here,
+	   but we'll read uninitialized memory in the value buffer
+	   instead of writing outside of a buffer. */
+	for (i=0; i<len/REGISTER_SIZE(ARG0_REGNUM); i++) 
+	  {
+	    regcache_raw_write(regcache, ARG0_REGNUM + i,
+			       valbuf + i*REGISTER_SIZE(ARG0_REGNUM));
+	  }
+      }
+    } 
+  else 
+    {
+      error ("bad size for return value");
+    } 
+}
+
+static enum return_value_convention
+lx_return_value (struct gdbarch *gdbarch, struct type *type,
+		 struct regcache *regcache, gdb_byte *readbuf,
+		 const gdb_byte *writebuf)
+{
+  int len = TYPE_LENGTH (type);
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s \n",  __FUNCTION__);
+  }
+  
+  if (readbuf)
+    lx_extract_return_value (type, regcache, readbuf);
+  if (writebuf)
+    lx_store_return_value (type, regcache, writebuf);
+  
+  if (len <= 32)
+    {
+      return RETURN_VALUE_REGISTER_CONVENTION;
+    }
+  
+  return RETURN_VALUE_STRUCT_CONVENTION;
+}
+
+static CORE_ADDR
+lx_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+#if 0
+  struct symtab_and_line sal;
+
+  struct symtab *s;
+  struct linetable *l;
+  struct linetable_entry *item, *lineinfo2;
+  struct blockvector *bv;
+  int len, i;
+#endif  
+  CORE_ADDR func_addr;
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n",  __FUNCTION__);
+  }
+
+  /* See if we can determine the end of the prologue via the symbol table.
+     If so, then return either PC, or the PC after the prologue, whichever
+     is greater.  */
+  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
+    {
+      CORE_ADDR post_prologue_pc = skip_prologue_using_sal (func_addr);
+      if (post_prologue_pc != 0)
+	return max (pc, post_prologue_pc);
+    }
+
+  return pc;
+#if 0
+  sal = find_pc_line (pc, 0);
+
+  if (sal.line == 0) /* there is no debug information available */
+    return pc;
+  
+  s = find_pc_sect_symtab (pc, 0);
+  
+  if (!s) 
+    return pc; 
+
+  bv = BLOCKVECTOR (s);
+
+  for (; s && BLOCKVECTOR (s) == bv; s = s->next) {
+      
+      lineinfo2 = NULL;
+      
+      /* Find the best line in this symtab */
+      l = LINETABLE (s);
+      
+      if (!l)
+         continue; 
+      
+      len = l->nitems;
+      
+      if (len <= 0) 
+         continue;	
+         
+      item = l->item;		/* Get first line info */
+                
+      if(len == 2) {
+      /* please see the MBTst34527 defect */
+      /* MBTst34527: Set breakpoint on main(), fails under certain conditions */
+         lineinfo2 = item;
+         break;
+      }  
+
+      for (i = 0; i < len; i++, item++)	{
+        /* We are sure to find two entries for our function:
+           -one which item->pc is actually the value passed to lx_skip_prologue
+           -the one following it, which item->pc is the first instruction after
+           the function's prologue.
+           Knowing that, we can test item->pc==pc and safely consider [item]
+           [item+1]
+        */
+	/* [CL] 2009-04-20: Accept only 'true' line info, ie one for
+	   which line!=0 */
+	if ((item->line != 0) && (item->pc == pc)) {
+           lineinfo2 = item+2;
+           break;
+         }
+      }
+
+      if (lineinfo2) 
+        break;
+   }
+
+   if (lineinfo2) 
+     return lineinfo2->pc; 
+   else 
+     return pc; 
+#endif
+}
+
+/* Define the maximum number of instructions which may be packed into a
+   bundle (LX instruction).  */
+static const int max_instrs_per_bundle = 4;
+
+/* Define the size (in bytes) of an LX instruction.  */
+static const int lx_instr_size = 4;
+
+/* Adjust a breakpoint's address to account for the LX architecture's
+   constraint that a break instruction must not appear as any but the
+   first instruction in the bundle.  */
+
+CORE_ADDR lx_adjust_breakpoint_address (struct gdbarch *gdbarch, CORE_ADDR bpaddr)
+{
+  int count = max_instrs_per_bundle;
+  CORE_ADDR addr = bpaddr - lx_instr_size;
+  CORE_ADDR func_start = get_pc_function_start (bpaddr);
+
+  /* Find the end of the previous packing sequence.  This will be indicated
+     by either attempting to access some inaccessible memory or by finding
+     an instruction word whose packing bit is set to one. */
+  while (count-- > 0 && addr >= func_start)
+    {
+      char instr[lx_instr_size];
+      int status;
+
+      status = read_memory_nobpt (addr, instr, sizeof instr);
+
+      if (status != 0)
+	      break;
+
+      /* In accord with the current endianess, 
+         the most significant bit of this byte is the
+         packing bit.  */
+      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG) {
+         if(instr[0] & 0x80) {
+            break;
+         }
+      } else {
+         if(instr[lx_instr_size-1] & 0x80) {
+            break;
+         }
+      }
+
+      addr -= lx_instr_size;
+    }
+
+  if (count > 0)
+    bpaddr = addr + lx_instr_size;
+
+  return bpaddr;
+}
+
+
+/* standard breakpoint insertion support function */
+static const unsigned char *
+lx_breakpoint_from_pc(struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
+{
+  static int lx_break_insn = 0;
+  int indx;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  if (lx_break_insn == 0) {
+    
+    lxopc_t *optab; 
+    const struct bfd_arch_info *bfdarch = gdbarch_bfd_arch_info (gdbarch);
+    
+    switch (bfdarch->mach) {
+      case bfd_mach_st231:
+        optab = st231_lxoptab;
+        lx_gdb_pattern_tab=lx_st231_gdb_pattern_tab;
+        break;
+      case bfd_mach_st240:
+        optab = st240_lxoptab;;
+        lx_gdb_pattern_tab=lx_st240_gdb_pattern_tab;
+        break;
+      default:
+        optab = NULL;
+    }
+
+    for (; optab->as_op != NULL; optab++) {
+      if (!strcmp(optab->as_op,LX_BREAKPOINT_INSTR)) {
+        lx_break_insn = BSWAP(optab->opcode | CORE_BUNDLE_STOP);
+        break;
+      }
+    }
+    
+    if (lx_break_insn == 0) 
+      printf_unfiltered("lx_breakpoint_from_pc: Can't find the \"%s\" opcode in the bsd library !\n",
+                                       LX_BREAKPOINT_INSTR); 
+  }
+
+  *lenptr = 4;
+  return (unsigned char *)&lx_break_insn;
+}
+
+/* Print a cluster of lx instructions. */
+static int 
+gdb_print_insn_lx(bfd_vma memaddr, disassemble_info * info)
+{
+  bfd_byte buffer[4];	        /* buffer for code       */
+  unsigned insn;              /* the instruction       */
+  bfd_vma memaddr0 = memaddr;
+  int delta;                  /* Change in address */
+  int done = 0;               /* Set nonzero when we find end of bundle. */
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+
+  while (!done && ((memaddr - memaddr0) < 64 /* MAX_BYTES_PER_BUNDLE */ )) {
+    /* read the instruction */
+
+    int status = (*info->read_memory_func) (memaddr, buffer, 4, info);
+    if (status != 0) {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;		/* Error */
+    }
+    if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG) {
+      insn = bfd_getb32 (buffer);
+      delta = print_insn_big_lx (memaddr, info);
+    } else {
+      insn = bfd_getl32 (buffer);
+      delta = print_insn_little_lx (memaddr, info);
+    }
+
+    done = (LXSTOP (insn) != 0);
+    if (delta <= 0)
+      return -1;		/* Error */
+
+    memaddr += delta;
+
+    /* For now, we just print one syllable and exit
+     * GDB trys to optimize buffer length and the
+     * code to print multiple syllables seems to break this
+     *
+     * GB
+     */
+
+    done = 1;
+
+    if (!done) {
+      /* We're going to print another syllable. Put out
+      address. */
+      (*info->fprintf_func) (info->stream, "\n");
+      (*info->print_address_func) (memaddr, info);
+      (*info->fprintf_func) (info->stream, ":\t");
+    }
+  }
+
+  return memaddr - memaddr0;
+}
+
+
+void
+lx_write_sp (struct regcache *regcache, CORE_ADDR val)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  regcache_cooked_write_unsigned (regcache, SP_REGNUM, val);
+}
+
+/* Here, enter the world of multi-arch gdb */
+
+static struct gdbarch *lx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches);
+static void lx_dump_tdep (struct gdbarch *, struct ui_file *);
+/* Return the name of a register.  */
+
+static const char *
+lx_register_name (struct gdbarch *gdbarch, int i)
+{
+  static char *names[] = REGISTER_NAMES; /* from tm-lx.h; must be brought here some day, because tm-lx.h is to be suppressed with multi-arch gdb */
+ 
+  if (lx_tdep_debug>1) {
+    fprintf_unfiltered (gdb_stdlog, "%s i %d\n" , __FUNCTION__,i);
+  }
+  
+  if (i < 0 || i >= (sizeof (names) / sizeof (*names)))
+    return NULL;
+  else
+    return names[i];
+}
+
+static int
+lx_pc_in_sigtramp (CORE_ADDR pc, char *name)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s name %s\n" , __FUNCTION__,name);
+  }
+
+  return (name && (strcmp ("_sys_save_core", name) == 0));
+}
+
+#define LX_NUM_SAVED_REGS 10 /* r1..r7,r13,r14,r63 */
+
+struct lx_frame_cache
+{
+  /* Base address. This is the SP at the entry of the frame's
+     function. */
+  /* [FR] : in fact, the above is only true after the cache is
+     initialized. During the cache initialization, the stored value is
+     the current frame SP. Look at lx_frame_cache() */
+  CORE_ADDR base;
+  /* This is the beginning pc of the frame's function, not the frame's
+     pc. It's used in the frame_id building to get a stable code
+     address for a frame. */
+  CORE_ADDR pc;
+
+  /* Frame size */
+  int frame_size;
+
+  /* Saved registers.  */
+  CORE_ADDR saved_regs[LX_NUM_SAVED_REGS];
+};
+
+/* Return the index at which regnum may be stored in saved_regs[]
+   or -1 if not saved */
+static int save_reg_idx(int regnum) {
+  
+  if (lx_tdep_debug>1) {
+    fprintf_unfiltered (gdb_stdlog, "%s regnum %d\n" , __FUNCTION__,regnum);
+  }
+  
+  switch(regnum) {
+  case R0_REGNUM+1:
+  case R0_REGNUM+2:
+  case R0_REGNUM+3:
+  case R0_REGNUM+4:
+  case R0_REGNUM+5:
+  case R0_REGNUM+6:
+  case R0_REGNUM+7:
+    return regnum-(R0_REGNUM+1);
+  case R0_REGNUM+13:
+  case R0_REGNUM+14:
+    return regnum-(R0_REGNUM+1)-(13-7+1);
+  case PR_REGNUM:
+    return LX_NUM_SAVED_REGS-1;
+  }
+  return -1;
+}
+
+
+/* Allocate and initialize a frame cache.  */
+
+static struct lx_frame_cache *
+lx_alloc_frame_cache (void)
+{
+  struct lx_frame_cache *cache;
+  int i;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+
+  cache = FRAME_OBSTACK_ZALLOC (struct lx_frame_cache);
+
+  /* Base address.  */
+  cache->base = 0;
+  cache->pc = 0;
+
+  cache->frame_size = 0;
+
+  /* Saved registers.  We initialize these to -1 since zero is a valid
+     offset (that's where %ebp is supposed to be stored).  */
+  for (i = 0; i < LX_NUM_SAVED_REGS; i++)
+    cache->saved_regs[i] = -1;
+
+  return cache;
+}
+
+/* Check whether PC points at code that saves registers on the stack.
+   If so, it updates CACHE and returns the address of the first
+   instruction after the register saves or CURRENT_PC, whichever is
+   smaller.  Otherwise, return PC.  */
+/* [FR] : FIXME : prologue scanners should be very careful when
+   dealing with control flow. The code might be totally correct, I
+   don't know enough about ST200 to tell. For example if the
+   compiler can generate more than one instruction per function
+   matching the two patterns tested, the code will surely give wrong
+   results. */
+static CORE_ADDR
+lx_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
+			   struct lx_frame_cache *cache)
+{
+  int stack_dec_found_first = 0;
+  int link_spill_found_first = 0;
+  int link_spill_offset = 0;
+
+  CORE_ADDR tmp;
+  unsigned int inst;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s pc %s\n" , __FUNCTION__,paddr(pc));
+  }
+
+  if (pc >= current_pc)
+    return current_pc;
+
+  for(tmp = pc; tmp < current_pc; tmp += 4) {
+    /*  scan for link spill code */
+
+    lx_get_inst (tmp, &inst);
+    if (!link_spill_found_first
+	&& lx_gdb_match (inst, gdb_link_spill_pattern)) {
+
+      /* link is spilled */
+      link_spill_offset = immval (tmp);
+      cache->saved_regs[save_reg_idx(PR_REGNUM)] = link_spill_offset;
+
+      if (!stack_dec_found_first) {
+	link_spill_found_first = 1;
+	continue;
+      }
+    }
+    if (!stack_dec_found_first
+	&& lx_gdb_match (inst, gdb_stack_dec_pattern)) {
+
+      int size = immval(tmp);
+      if (size <= 0) 
+        /* stack is decremented */
+        cache->frame_size = size;
+
+      if (link_spill_found_first) {
+	/* if the stack is decremented after the spill,
+	   take it into account now */
+	cache->saved_regs[save_reg_idx(PR_REGNUM)] =
+	  link_spill_offset - cache->frame_size;
+      } else {
+	/* if the stack is decremented before the spill, just remember it */
+	stack_dec_found_first = 1;
+      }
+    }
+  }
+
+return pc;
+}
+
+/* Do a full analysis of the prologue at PC and update CACHE
+   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
+   address where the analysis stopped.
+*/
+
+static CORE_ADDR
+lx_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
+		     struct lx_frame_cache *cache)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s pc %s\n" , __FUNCTION__,paddr(pc));
+  }
+  
+  return lx_analyze_register_saves (pc, current_pc, cache);
+}
+
+/* Normal frames.  */
+
+static struct lx_frame_cache *
+lx_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  struct lx_frame_cache *cache;
+  int i;
+  
+  if (lx_tdep_debug>1) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = lx_alloc_frame_cache ();
+  *this_cache = cache;
+
+  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
+  if (cache->pc != 0)
+    lx_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
+
+  /* [FR] : We init BASE to the current value of SP. I think
+     lx_analyze_register_saves assumes it has this value. */
+  cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
+
+  if (cache->base == 0)
+    return cache;
+
+  /* Adjust all the saved registers such that they contain addresses
+     instead of offsets.  */
+  for (i = 0; i < LX_NUM_SAVED_REGS; i++) {
+    if (cache->saved_regs[i] != -1) {
+      cache->saved_regs[i] += cache->base;
+    }
+  }
+
+  /* [FR] : We give its final value to BASE. This is the value SP had
+     upon function entry. */
+  cache->base -= cache->frame_size;
+
+  return cache;
+}
+
+static void
+lx_frame_this_id (struct frame_info *next_frame, void **this_cache,
+		  struct frame_id *this_id)
+{
+  struct lx_frame_cache *cache = lx_frame_cache (next_frame, this_cache);
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  /* This marks the outermost frame.  */
+  if (cache->base == 0)
+    return;
+
+  /* All ST200 unwinders must use <entry SP> + SCRATCHAREASIZE as
+     stack addr for frame_ids */
+  (*this_id) = frame_id_build (cache->base + SCRATCHAREASIZE, cache->pc);
+}
+
+static void
+lx_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+			int regnum, int *optimizedp,
+			enum lval_type *lvalp, CORE_ADDR *addrp,
+			int *realnump, gdb_byte *valuep)
+{
+  struct lx_frame_cache *cache;/* = lx_frame_cache (next_frame, this_cache);*/
+  int save_reg_id;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s regnum %d\n" , __FUNCTION__,regnum);
+  }
+
+  cache = lx_frame_cache (next_frame, this_cache);
+  /* The PC of the previous frame is stored in the PR register of
+     the current frame.  Frob regnum so that we pull the value from
+     the correct place.  */
+  if (regnum == PC_REGNUM)
+    regnum = PR_REGNUM;
+
+  save_reg_id = save_reg_idx(regnum);
+
+  if (regnum == SP_REGNUM) {
+    *optimizedp = 0;
+    *lvalp = lval_register;
+    *realnump = -1;
+    if (valuep) {
+	/* [FR] : Don't forget to swap bytes if needed ! */
+	*(CORE_ADDR*)valuep = BSWAP(cache->base);
+    }
+    return;
+  }
+
+
+  if (save_reg_id < LX_NUM_SAVED_REGS && save_reg_id != -1
+      && cache->saved_regs[save_reg_id] != -1)
+    {
+      *optimizedp = 0;
+      *lvalp = lval_memory;
+      *addrp = cache->saved_regs[save_reg_id];
+      *realnump = -1;
+      if (valuep)
+	{
+	    /* Read the value in from memory.  */
+	    read_memory (*addrp, valuep,
+			 register_size (current_gdbarch, regnum));
+	}
+      return;
+    }
+
+  frame_register_unwind (next_frame, regnum,
+			 optimizedp, lvalp, addrp, realnump, valuep);
+}
+
+/* The default init_reg function (in dwarf2-frame.c) implies that
+   SP contains the CFA. It is not the case on ST200, because
+   of the scratch area. */
+
+static void
+lx_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
+			  struct dwarf2_frame_state_reg *reg,
+			  struct frame_info *next_frame)
+{
+
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s regnum %d\n" , __FUNCTION__,regnum);
+  }
+  
+  if (regnum == PC_REGNUM)
+    reg->how = DWARF2_FRAME_REG_RA;
+  else if (regnum == SP_REGNUM) {
+    reg->how = DWARF2_FRAME_REG_CFA_OFFSET;
+    reg->loc.offset = -SCRATCHAREASIZE;
+  }
+}
+
+/* sentinel frames  */
+
+static void
+lx_sentinel_frame_this_id (struct frame_info *next_frame, void **this_cache,
+			   struct frame_id *this_id)
+{
+
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  (*this_id) = null_frame_id;
+}
+
+
+/* Signal trampolines.  */
+
+static void
+lx_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
+			   struct frame_id *this_id)
+{
+    /* [FR] : FIXME : This is a dummy implementation which is
+       certainly false. I don't know what a sigtramp frame looks like.
+       Someone with more knowledge of this should take care of
+       it.
+       
+       The problem that could arise with this implementation is that
+       the frame_id generated below clashes with one from another frame. 
+    */
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  (*this_id) = frame_id_build (frame_sp_unwind(next_frame), 
+			       frame_func_unwind(next_frame, SIGTRAMP_FRAME));
+}
+
+static void
+lx_sigtramp_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+				 int regnum, int *optimizedp,
+				 enum lval_type *lvalp, CORE_ADDR *addrp,
+				 int *realnump, gdb_byte *valuep)
+{
+  /* find saved registers */
+  
+    /* [FR] : FIXME : This was extracted from the old code. No way to test, so
+       it's certainly wrong. (I tried to keep the old behavour, so in
+       fact this may work :) ) */
+    
+  struct sigcontext_struct *sc;
+  struct saved_regs *sr;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  sc = (struct sigcontext_struct *) (frame_sp_unwind(next_frame)+SCRATCHAREASIZE);
+  sr = (struct saved_regs *) lx_read_mem_word((CORE_ADDR) (&sc->regs));
+
+  /* [FR] : FIXME : This could be extended to all registers */
+  if (regnum == PC_REGNUM
+      || regnum == SP_REGNUM)
+    {
+      *optimizedp = 0;
+      *lvalp = not_lval;
+      *addrp = 0;
+      *realnump = -1;
+      if (valuep)
+	{
+	  /* Store the value.  */
+	  if (regnum == PC_REGNUM)
+	    {
+	      store_typed_address (valuep, 
+				   builtin_type_void_func_ptr, 
+				   lx_read_mem_word((CORE_ADDR) (&sr->pc)));
+	    }
+	  else
+	    {
+	      store_typed_address (valuep, 
+				   builtin_type_void_data_ptr,
+				   lx_read_mem_word((CORE_ADDR) (&sr->reg_r12)));
+	    }
+	}
+    }
+  else
+    {
+      *optimizedp = 1;
+      *lvalp = not_lval;
+      *addrp = 0;
+      *realnump = -1;
+      get_frame_register(next_frame, regnum, valuep);
+    }
+}
+
+static const struct frame_unwind lx_frame_unwind =
+{
+  NORMAL_FRAME,
+  lx_frame_this_id,
+  lx_frame_prev_register
+};
+
+static const struct frame_unwind lx_sentinel_frame_unwind =
+{
+  SENTINEL_FRAME,
+  lx_sentinel_frame_this_id,
+  lx_frame_prev_register
+};
+
+static const struct frame_unwind lx_signal_frame_unwind =
+{
+  SIGTRAMP_FRAME,
+  lx_sigtramp_frame_this_id,
+  lx_sigtramp_frame_prev_register
+};
+
+static const struct frame_unwind *
+lx_frame_sniffer (struct frame_info *next_frame)
+{  
+    CORE_ADDR pc = frame_pc_unwind (next_frame);
+    char *name;
+    
+    if (lx_tdep_debug) {
+      fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+    }
+  
+    find_pc_partial_function (pc, &name, NULL, NULL);
+
+    if (lx_pc_in_sigtramp(pc, name))
+	{
+	    return &lx_signal_frame_unwind;
+	}
+
+    if (name && (strcmp ("_start", name) == 0))
+	{
+	    return &lx_sentinel_frame_unwind;
+	}
+    
+    return &lx_frame_unwind;
+}
+
+/* Given THIS_FRAME, find the previous frame's resume PC (which will
+   be used to construct the previous frame's ID, after looking up the
+   containing function).  */
+static CORE_ADDR
+lx_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+    CORE_ADDR res;
+    
+    if (lx_tdep_debug) {
+      fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+    }
+  
+    res = frame_unwind_register_unsigned (next_frame, PC_REGNUM);
+    return res;
+}
+
+/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that
+   dummy frame.  The frame ID's base needs to match the TOS value
+   saved by save_dummy_frame_tos() and returned from
+   arm_push_dummy_call, and the PC needs to match the dummy frame's
+   breakpoint.  */
+static struct frame_id
+lx_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+    CORE_ADDR stack_addr = frame_unwind_register_unsigned (next_frame,
+							   SP_REGNUM);
+    if (lx_tdep_debug) {
+      fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+    }
+  
+    /* All unwinders must agree on the stack_addr value. This one will
+       be compared to the one returned by lx_push_dummy_call(). The
+       additon is required so that frame_inner works correctly when
+       comparing dummy frames with real ones. */
+    stack_addr += SCRATCHAREASIZE;
+    return frame_id_build (stack_addr,
+			   frame_pc_unwind (next_frame));
+}
+
+/* The epilogue is defined here as the area either on the `return'
+   (aka `goto $r63') instruction itself or an instruction just after
+   the one which destroys the function's stack frame.
+
+   Currently, we support only the 'return' instruction; we only need
+   to check the instruction at 'pc' as 'return' must be the first
+   syllabe of a bundle.
+
+   We do not assume that the epilogue is at the end of a function as we can
+   also have return sequences in the middle of a function.  */
+static int
+lx_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
+{
+  unsigned long status;
+  unsigned int inst;
+
+  status = lx_get_inst (pc, &inst);
+  if (status == 0)
+    return 0;
+
+  /* On ST220, we can have several nops between the destruction of the
+     function's stack frame and the return instruction. Eat them, and
+     check if we are facing a series of nops followed by a return.  */
+  while (lx_gdb_match (inst, gdb_nop_pattern))
+    {
+      pc += 4;
+      status = lx_get_inst (pc, &inst);
+      if (status == 0)
+	return 0;
+    }
+
+  /* On ST220/ST231, 'return' is actually an alias to 'goto $r63'.
+     On ST240, 'return' and 'goto $r63' are actually two different
+     instructions.  */
+  if (lx_gdb_match (inst, gdb_igoto_pattern)
+      || lx_gdb_match (inst, gdb_return_pattern))
+    {
+      return 1;
+    }
+
+  return 0;
+}
+
+
+/*
+ * DON'T CHANGE PROTOTYPE !!
+ *    This is automatically extracted in build
+ *    For now the only initialization is to set
+ *    up disassembler hook
+ */
+
+void
+_initialize_lx_tdep ()
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  /* Hook us into the gdbarch mechanism.  */
+  gdbarch_register (bfd_arch_lx, lx_gdbarch_init, lx_dump_tdep);
+}
+
+/* (MC) new ON_STACK policy for dummy calls */
+static CORE_ADDR
+lx_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s sp %s\n" , __FUNCTION__,paddr(sp));
+  }
+  return sp & ~3;
+}
+
+static struct gdbarch *
+lx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  /* Find a candidate among the list of pre-declared architectures. */
+  arches = gdbarch_list_lookup_by_info (arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+  
+  /* None found: is the request for a lx architecture? */
+  if (info.bfd_arch_info->arch != bfd_arch_lx)
+    return NULL;	/* No; then it's not for us.  */
+   
+  /* Yes: create a new gdbarch for the specified machine type.  */
+  gdbarch = gdbarch_alloc (&info, NULL /* tdep */);
+  
+  /* Registers */
+  set_gdbarch_register_name (gdbarch, lx_register_name);
+  set_gdbarch_num_regs (gdbarch, NUM_REGS);
+  set_gdbarch_register_type (gdbarch, lx_register_type);
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, lx_dwarf2_reg_to_regnum);
+  set_gdbarch_sp_regnum (gdbarch, SP_REGNUM);
+  set_gdbarch_pc_regnum (gdbarch, PC_REGNUM);
+
+  /* Breakpoints */
+  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
+  set_gdbarch_frame_align (gdbarch, lx_frame_align);
+  set_gdbarch_breakpoint_from_pc (gdbarch, lx_breakpoint_from_pc);
+  set_gdbarch_decr_pc_after_break (gdbarch, (CORE_ADDR) 0);
+
+  set_gdbarch_have_nonsteppable_watchpoint(gdbarch,1);
+  
+  /* Types */
+  set_gdbarch_long_double_bit(gdbarch, 64);
+  set_gdbarch_believe_pcc_promotion(gdbarch, 1);
+
+  /* Frames */
+  set_gdbarch_inner_than(gdbarch, core_addr_lessthan);
+  set_gdbarch_unwind_pc (gdbarch, lx_unwind_pc);
+  dwarf2_frame_set_init_reg (gdbarch, lx_dwarf2_frame_init_reg);
+  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
+  frame_unwind_append_sniffer (gdbarch, lx_frame_sniffer);
+
+  /* Function calls */
+  set_gdbarch_unwind_dummy_id(gdbarch, lx_unwind_dummy_id);
+  set_gdbarch_push_dummy_call(gdbarch, lx_push_dummy_call);
+  set_gdbarch_return_value (gdbarch, lx_return_value);
+
+  /* Disassembly. */
+  set_gdbarch_print_insn (gdbarch, gdb_print_insn_lx);
+  set_gdbarch_skip_prologue(gdbarch, lx_skip_prologue);
+
+  set_gdbarch_in_function_epilogue_p (gdbarch,
+				      lx_in_function_epilogue_p);
+
+  /* SHARED LIB support */
+  set_solib_svr4_fetch_link_map_offsets(gdbarch, svr4_ilp32_fetch_link_map_offsets);
+
+  return gdbarch;
+}
+
+static void
+lx_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s tdep 0x%lx\n" , __FUNCTION__,(long)tdep);
+  }
+  
+
+  if (tdep == NULL)
+    return;
+
+  fprintf_unfiltered (file, "lx_dump_tdep: %s\n", "no specific tdep data for lx archs");
+
+}
+
+#ifdef __ST200__
+/* CL: added from gdb-5.1 */
+int
+lx_check_watch_resources (int type, int cnt, int ot)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  if (type == bp_hardware_breakpoint)
+    {
+      if (TARGET_HW_BREAK_LIMIT == 0)
+	return 0;
+      else if (cnt <= TARGET_HW_BREAK_LIMIT)
+	return 1;
+    }
+  else
+    {
+      if (TARGET_HW_WATCH_LIMIT == 0)
+	return 0;
+      else if (ot)
+	return -1;
+      else if (cnt <= TARGET_HW_WATCH_LIMIT)
+	return 1;
+    }
+  return -1;
+}
+
+/* N.B. all control register bit and mask are endian dependent */
+
+int
+lx_stopped_by_watchpoint ()
+{
+/*  (FG)Access to LXEXCAUSE triggers problem  */
+/* (In fact it is not the access to this memory */
+/* , but the way gdb read memory : 16 byte per 16 byte */
+/* And it is one of the word after LXEXCAUSE that causes troubles )*/
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+#if 0 
+  CORE_ADDR exc;
+  read_memory ((CORE_ADDR) LXEXCAUSE, (char *) &exc, 4);
+  return exc & BSWAP (EXC_DBREAK);
+#else
+  return 0 ;
+#endif
+}
+
+int
+lx_insert_hw_watchpoint (CORE_ADDR addr, int len, int type)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  fprintf(stderr, "lx_insert_hw_watchpoint not implemented\n");
+  return -1;
+}
+
+int
+lx_remove_hw_watchpoint (CORE_ADDR addr, int len, int type)
+{
+  if (lx_tdep_debug) {
+    fprintf_unfiltered (gdb_stdlog, "%s\n" , __FUNCTION__);
+  }
+  
+  fprintf(stderr, "lx_remove_hw_watchpoint not implemented\n");
+  return -1;
+}
+
+/* CL: end added from gdb-5.1 */
+#endif
+
diff --git a/gdb/lx-linux-tdep.h b/gdb/lx-linux-tdep.h
new file mode 100644
index 0000000..02da80b
--- /dev/null
+++ b/gdb/lx-linux-tdep.h
@@ -0,0 +1,223 @@
+/*  lx-linux-tdep.h - Macro and function for GDB supporting lx
+(c) Copyright Hewlett-Packard Company 1999-2004
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+itunder the terms of the GNU General Public License as published by he
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING. If not, write to the
+Free Software Foundation,59 Temple Place -Suite 330, Boston, MA
+02111-1307, USA. */
+
+#ifndef LX_LINUX_TDEP_H
+#define LX_LINUX_TDEP_H
+
+#define LINK_REG 63
+#define RVP_REG 15
+#define STACK_PTR_REG 12
+#define PSW_REGNUM 	1 /* used to be in infrun.c before 6.0 */
+
+
+
+#ifdef __STDC__
+struct frame_info;
+struct frame_saved_regs;
+struct value;
+struct type;
+#endif
+
+void shtdi_init_simulator_hook (void);
+
+#undef  GDBINIT_FILENAME
+#define GDBINIT_FILENAME ".lxgdbinit"
+
+/* Say how much memory is needed to store a copy of the register set */
+/* NUM_REGS is redefine because NUM_REGS defined in archcore.h is not the value we use */
+/* We use the real number of register in one cluster rather the total number of register  */
+/* available for further cluster (archcore.h) */
+#undef NUM_REGS
+#define NUM_REGS 74
+
+#define NUM_CLUSTER_INDEP_REGS 2
+
+/* Initializer for an array of names of registers.
+   Entries beyond the first NUM_REGS are ignored.
+   Organize these so registers in the same cluster are
+   together.  This is the order they will be dumped in.
+   Put cluster-independent registers first.
+*/
+
+#define REGISTER_NAMES			   		        \
+  {  "pc", "psw",						\
+  "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",		\
+  "r8", "r9", "r10",  "r11",  "r12",  "r13",  "r14", "r15",	\
+  "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22", "r23",	\
+  "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30", "r31",	\
+  "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38", "r39",	\
+  "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46", "r47",	\
+  "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54", "r55",	\
+  "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62", "r63",	\
+  "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7" }
+
+#define GDI_REGISTER_NAMES								\
+  {  "unmapped-REG_PC", "REG_PSW",									\
+  "REG_C0_R0", "REG_C0_R1", "REG_C0_R2", "REG_C0_R3", "REG_C0_R4", "REG_C0_R5", "REG_C0_R6", "REG_C0_R7",		\
+  "REG_C0_R8", "REG_C0_R9", "REG_C0_R10",  "REG_C0_R11",  "REG_C0_R12",  "REG_C0_R13",  "REG_C0_R14", "REG_C0_R15",	\
+  "REG_C0_R16",  "REG_C0_R17",  "REG_C0_R18",  "REG_C0_R19",  "REG_C0_R20",  "REG_C0_R21",  "REG_C0_R22", "REG_C0_R23",	\
+  "REG_C0_R24",  "REG_C0_R25",  "REG_C0_R26",  "REG_C0_R27",  "REG_C0_R28",  "REG_C0_R29",  "REG_C0_R30", "REG_C0_R31",	\
+  "REG_C0_R32",  "REG_C0_R33",  "REG_C0_R34",  "REG_C0_R35",  "REG_C0_R36",  "REG_C0_R37",  "REG_C0_R38", "REG_C0_R39",	\
+  "REG_C0_R40",  "REG_C0_R41",  "REG_C0_R42",  "REG_C0_R43",  "REG_C0_R44",  "REG_C0_R45",  "REG_C0_R46", "REG_C0_R47",	\
+  "REG_C0_R48",  "REG_C0_R49",  "REG_C0_R50",  "REG_C0_R51",  "REG_C0_R52",  "REG_C0_R53",  "REG_C0_R54", "REG_C0_R55",	\
+  "REG_C0_R56",  "REG_C0_R57",  "REG_C0_R58",  "REG_C0_R59",  "REG_C0_R60",  "REG_C0_R61",  "REG_C0_R62", "REG_C0_R63",	\
+  "REG_C0_B0", "REG_C0_B1", "REG_C0_B2", "REG_C0_B3", "REG_C0_B4", "REG_C0_B5", "REG_C0_B6", "REG_C0_B7"}
+
+/* Register numbers of various important registers.  Note that some of
+   these values are "real" register numbers, and correspond to the
+   general registers of the machine, and some are "phony" register
+   numbers which are too large to be actual register numbers as far as
+   the user is concerned but do serve to get the desired values when
+   passed to read_register.  */
+
+#define R0_REGNUM	NUM_CLUSTER_INDEP_REGS
+#define STRUCT_RETURN_REGNUM (R0_REGNUM + RVP_REG)
+#define ARG0_REGNUM     (R0_REGNUM + ARG0_REG)
+#define ARGLAST_REGNUM  (R0_REGNUM + ARG7_REG)
+#define SP_REGNUM 	(R0_REGNUM + STACK_PTR_REG)
+#define DEPRECATED_FP_REGNUM       SP_REGNUM
+#define PC_REGNUM 	0
+#define PR_REGNUM 	(R0_REGNUM + LINK_REG)
+
+#define NUM_REALREGS	NUM_REGS
+
+#ifndef LX_BREAKPOINT_INSTR
+#define LX_BREAKPOINT_INSTR "sbrk"
+#endif
+
+/* Add below materials for data breakpoints */
+
+/* When a hardware watchpoint fires off the PC will be left at the
+   instruction which caused the watchpoint.  It will be necessary for
+   GDB to step over the watchpoint. */
+#define CANNOT_STEP_HW_WATCHPOINTS 1
+#define HAVE_NONSTEPPABLE_WATCHPOINT  1
+
+/* Fiddle with this when we have hardware watchpoints implemented */
+#define TARGET_HW_BREAK_LIMIT 0
+#define TARGET_HW_WATCH_LIMIT 0
+
+#define SOLIB_BKPT_NAME		         LITTLE_ENDIAN
+
+#ifndef __ST200__ /* [CL] handle the cross-debugger case */
+#if defined (i386) /* host is little endian */
+#define BSWAP(s) (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG ? ((((s) & 0xff) << 24) | \
+               (((s) & 0xff00) << 8) | \
+               (((s) & 0xff0000) >> 8) | \
+               (((s) >> 24) & 0xff)) : (s))
+#elif defined (sparc) /* host is big endian */
+#define BSWAP(s)(gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE ?((((s) & 0xff) << 24) | \
+               (((s) & 0xff00) << 8) | \
+               (((s) & 0xff0000) >> 8) | \
+               (((s) >> 24) & 0xff)) : (s))
+#else
+#error "Host unsupported"
+#endif
+#else /* [CL] handle native ST200 debugger */
+
+#define BSWAP(s) (s)
+
+#endif
+
+/* ===========[ Start of machgen glue; see al's comment in lx-tdep.c ]============== */
+
+/* An enumeration of GDB patterns which we implement as macros.
+ * Values of this enumeration are used to index into the arrays of gdb macros or opc * tables. */
+enum lx_gdb_patterns {
+  /* Reserve slot 0 so we can use 0 to terminate lists. */
+  gdb_illegal_pattern=0,
+  /* Match instruction that spills link register to stack:
+     val[sp] = $r0.63 */
+  gdb_link_spill_pattern,
+
+   /* Match instruction that saves link register to a register:
+       mov $rxx=$r63 */
+  gdb_link_save_pattern,
+
+  /* Match a stack decrement instruction.
+       add r0.1 = r0.1 - val */
+  gdb_stack_dec_pattern,
+
+
+  /* The following are for recognizing individual flow of control
+     instructions which we then combine. */
+  gdb_call_pattern,
+  gdb_icall_pattern,
+  gdb_goto_pattern,
+  gdb_igoto_pattern,
+  gdb_return_pattern,
+  gdb_rfi_pattern,
+  gdb_branch_pattern,
+  gdb_branch_false_pattern,
+  /* Match nop.  */
+   gdb_nop_pattern,
+
+  /* The number of patterns, excluding the terminating 0 */
+  gdb_num_patterns
+};
+
+/* GDB Pattern Macro tables */
+
+lxopc_t *lx_gdb_pattern_tab;
+
+/* st231 */
+lxopc_t lx_st231_gdb_pattern_tab[] = {{0},
+	{"link_spill", 0x25000fcc, 0x3fe00fff, 0,0, {0 }, "STORE", ""},
+   {"link_save", 0x00000fc0, 0x3ffc0fff, 0,0, {0 }, "ALU", ""},
+	{"stack_dec", 0x0800030c, 0x3fe00fff, 0,0, {0 }, "ALU", ""},
+	{"call", 0x30000000, 0x3f800000, 4,0 , {0 }, "CALL", ""},
+	{"icall", 0x30800000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"goto", 0x31000000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"igoto", 0x31800000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"return", 0x31800000, 0x3f800000, 4,0, {0 }, "CALL", ""}, /* if arch <= st231, return is an alias to igoto */
+	{"rfi", 0x32000000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"br", 0x38000000, 0x3c000000, 4,0, {0 }, "BRANCH", ""},
+	{"brf", 0x3c000000, 0x3c000000, 4,0, {0 }, "BRANCH", ""},
+    {"nop", 0x00000000, 0x3fffffff, 0,0, {0 }, "ALU", ""},   
+            {0}};
+/*st240 */
+lxopc_t lx_st240_gdb_pattern_tab[] = {{0},
+	{"link_spill", 0x29000fcc, 0x3fe00fff, 0,0, {0 }, "STORE", ""},
+   {"link_save", 0x00000fc0, 0x3fff0fff, 0,0, {0 }, "ALU", ""},
+	{"stack_dec", 0x0800030c, 0x3fe00fff, 0,0, {0 }, "ALU", ""},
+	{"call", 0x30000000, 0x3f800000, 4,0 , {0 }, "CALL", ""},
+	{"icall", 0x30800000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"goto", 0x31000000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"igoto", 0x31800000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"igoto", 0x33800000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"rfi", 0x32000000, 0x3f800000, 4,0, {0 }, "CALL", ""},
+	{"br", 0x38000000, 0x3c000000, 4,0, {0 }, "BRANCH", ""},
+	{"brf", 0x3c000000, 0x3c000000, 4,0, {0 }, "BRANCH", ""},
+    {"nop", 0x00000000, 0x3fffffff, 0,0, {0 }, "ALU", ""},
+            {0}};
+
+
+enum lx_gdb_patterns flow_insts[] = {
+  gdb_call_pattern,
+  gdb_icall_pattern,
+  gdb_goto_pattern,
+  gdb_igoto_pattern,
+  gdb_rfi_pattern,
+  gdb_branch_pattern,
+  gdb_branch_false_pattern,
+  0};
+
+#endif 
+
diff --git a/gdb/main.h b/gdb/main.h
index d513575..2f09053 100644
--- a/gdb/main.h
+++ b/gdb/main.h
@@ -1,6 +1,10 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Main interface for GDB, the GNU debugger.
 
    Copyright (C) 2002, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (c) 2007 STMicroelectronics 
 
    This file is part of GDB.
 
@@ -33,5 +37,6 @@ extern int gdb_main (struct captured_main_args *);
 /* From main.c.  */
 extern int return_child_result;
 extern int return_child_result_value;
+extern int batch_silent;
 
 #endif
diff --git a/gdb/po/gdb.pot b/gdb/po/gdb.pot
index cba3dcf..6a7617e 100644
--- a/gdb/po/gdb.pot
+++ b/gdb/po/gdb.pot
@@ -8,7 +8,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: \n"
-"POT-Creation-Date: 2008-03-27 18:27+0000\n"
+"POT-Creation-Date: 2008-03-29 17:17-0700\n"
 "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
 "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
@@ -668,26 +668,26 @@ msgstr ""
 msgid "Invalid character '%s' in expression."
 msgstr ""
 
-#: ada-lex.l:321
+#: ada-lex.l:322
 #, possible-c-format
 msgid "Invalid base: %d."
 msgstr ""
 
-#: ada-lex.l:332 ada-lex.l:339
+#: ada-lex.l:333 ada-lex.l:340
 msgid "Integer literal out of range"
 msgstr ""
 
-#: ada-lex.l:334
+#: ada-lex.l:335
 #, possible-c-format
 msgid "Invalid digit `%c' in based literal"
 msgstr ""
 
-#: ada-lex.l:579
+#: ada-lex.l:580
 #, possible-c-format
 msgid "ambiguous attribute name: `%s'"
 msgstr ""
 
-#: ada-lex.l:582
+#: ada-lex.l:583
 #, possible-c-format
 msgid "unrecognized attribute: `%s'"
 msgstr ""
@@ -2961,6 +2961,54 @@ msgid ""
 "charset'<TAB>"
 msgstr ""
 
+#: cli/cli-setshow.c:58
+msgid "\"on\", \"off\" or \"auto\" expected."
+msgstr ""
+
+#: cli/cli-setshow.c:87
+msgid "\"on\" or \"off\" expected."
+msgstr ""
+
+#: cli/cli-setshow.c:191
+msgid "filename to set it to."
+msgstr ""
+
+#: cli/cli-setshow.c:211 cli/cli-setshow.c:220 cli/cli-setshow.c:232
+msgid "integer to set it to."
+msgstr ""
+
+#: cli/cli-setshow.c:225
+#, possible-c-format
+msgid "integer %u out of range"
+msgstr ""
+
+#: cli/cli-setshow.c:261
+#, possible-c-format
+msgid "Requires an argument. Valid arguments are %s."
+msgstr ""
+
+#: cli/cli-setshow.c:289
+#, possible-c-format
+msgid "Undefined item: \"%s\"."
+msgstr ""
+
+#: cli/cli-setshow.c:292
+#, possible-c-format
+msgid "Ambiguous item \"%s\"."
+msgstr ""
+
+#: cli/cli-setshow.c:298 cli/cli-setshow.c:367
+msgid "gdb internal error: bad var_type in do_setshow_command"
+msgstr ""
+
+#: cli/cli-setshow.c:343
+msgid "do_setshow_command: invalid var_auto_boolean"
+msgstr ""
+
+#: cli/cli-setshow.c:391
+msgid "gdb internal error: bad cmd_type in do_setshow_command"
+msgstr ""
+
 #: cli/cli-cmds.c:190
 #, possible-c-format
 msgid "Argument required (%s)."
@@ -3426,23 +3474,109 @@ msgstr ""
 msgid "When 'on', each command is displayed as it is executed."
 msgstr ""
 
-#: cli/cli-decode.c:1200
+#: cli/cli-script.c:85
+msgid "if/while commands require arguments."
+msgstr ""
+
+#: cli/cli-script.c:119
+msgid "Error reading in canned sequence of commands."
+msgstr ""
+
+#: cli/cli-script.c:294
+msgid "Max user call depth exceeded -- command aborted."
+msgstr ""
+
+#: cli/cli-script.c:313
+msgid "Error executing canned sequence of commands."
+msgstr ""
+
+#: cli/cli-script.c:532
+msgid "Invalid control type in canned commands structure."
+msgstr ""
+
+#: cli/cli-script.c:586
+msgid "arg_cleanup called with no user args.\n"
+msgstr ""
+
+#: cli/cli-script.c:625
 #, possible-c-format
-msgid "Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."
+msgid "user defined function may only have %d arguments."
 msgstr ""
 
-#: cli/cli-decode.c:1233
+#: cli/cli-script.c:722
 #, possible-c-format
-msgid "Lack of needed %scommand"
+msgid "Missing argument %d in user function."
 msgstr ""
 
-#: cli/cli-decode.c:1297
+#: cli/cli-script.c:821
+msgid "Control nesting too deep!"
+msgstr ""
+
+#: cli/cli-script.c:944
+msgid "Recursed on a simple control type."
+msgstr ""
+
+#: cli/cli-script.c:947
+msgid "Allocated body is smaller than this command type needs."
+msgstr ""
+
+#: cli/cli-script.c:1204
+msgid "name of command to define"
+msgstr ""
+
+#: cli/cli-script.c:1210
 #, possible-c-format
-msgid "Ambiguous %scommand \"%s\": %s."
+msgid "Junk in argument list: \"%s\""
 msgstr ""
 
-#: cli/cli-decode.c:1665
-msgid "Invalid command"
+#: cli/cli-script.c:1255
+#, possible-c-format
+msgid "Redefine command \"%s\"? "
+msgstr ""
+
+#: cli/cli-script.c:1257
+#, possible-c-format
+msgid "Really redefine built-in command \"%s\"? "
+msgstr ""
+
+#: cli/cli-script.c:1259
+#, possible-c-format
+msgid "Command \"%s\" not redefined."
+msgstr ""
+
+#: cli/cli-script.c:1286
+#, possible-c-format
+msgid "Your new `%s' command does not hook any existing command."
+msgstr ""
+
+#. Should never come here as hookc would be 0.
+#: cli/cli-script.c:1328 complaints.c:299 exceptions.c:151 exceptions.c:168
+#: exceptions.c:194 exceptions.c:254 hppa-tdep.c:3131 hppa-tdep.c:3144
+#: infcall.c:560 infcmd.c:1192 infrun.c:1324 language.c:883 language.c:909
+#: mi/mi-out.c:321 mi/mi-out.c:339 mips-tdep.c:277 mips-tdep.c:336
+#: mips-tdep.c:1261 mips-tdep.c:3782 mips-tdep.c:4750 mn10300-tdep.c:88
+#: reggroups.c:214 remote.c:4600 utils.c:747 utils.c:766
+msgid "bad switch"
+msgstr ""
+
+#: cli/cli-script.c:1346
+#, possible-c-format
+msgid "Command \"%s\" is built-in."
+msgstr ""
+
+#: cli/cli-script.c:1418
+msgid "called with NULL file pointer!"
+msgstr ""
+
+#: cli/cli-script.c:1445
+#, possible-c-format
+msgid ""
+"%s:%d: Error in sourced command file:\n"
+"%s"
+msgstr ""
+
+#: cli/cli-script.c:1448
+msgid "bad reason"
 msgstr ""
 
 #: cli/cli-dump.c:95
@@ -3644,6 +3778,25 @@ msgid ""
 "(file relative) will be restored to target memory."
 msgstr ""
 
+#: cli/cli-decode.c:1200
+#, possible-c-format
+msgid "Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."
+msgstr ""
+
+#: cli/cli-decode.c:1233
+#, possible-c-format
+msgid "Lack of needed %scommand"
+msgstr ""
+
+#: cli/cli-decode.c:1297
+#, possible-c-format
+msgid "Ambiguous %scommand \"%s\": %s."
+msgstr ""
+
+#: cli/cli-decode.c:1665
+msgid "Invalid command"
+msgstr ""
+
 #: cli/cli-logging.c:43
 #, possible-c-format
 msgid "The current logfile is \"%s\".\n"
@@ -3757,159 +3910,6 @@ msgstr ""
 msgid "Disable logging."
 msgstr ""
 
-#: cli/cli-script.c:85
-msgid "if/while commands require arguments."
-msgstr ""
-
-#: cli/cli-script.c:119
-msgid "Error reading in canned sequence of commands."
-msgstr ""
-
-#: cli/cli-script.c:294
-msgid "Max user call depth exceeded -- command aborted."
-msgstr ""
-
-#: cli/cli-script.c:313
-msgid "Error executing canned sequence of commands."
-msgstr ""
-
-#: cli/cli-script.c:532
-msgid "Invalid control type in canned commands structure."
-msgstr ""
-
-#: cli/cli-script.c:586
-msgid "arg_cleanup called with no user args.\n"
-msgstr ""
-
-#: cli/cli-script.c:625
-#, possible-c-format
-msgid "user defined function may only have %d arguments."
-msgstr ""
-
-#: cli/cli-script.c:722
-#, possible-c-format
-msgid "Missing argument %d in user function."
-msgstr ""
-
-#: cli/cli-script.c:821
-msgid "Control nesting too deep!"
-msgstr ""
-
-#: cli/cli-script.c:944
-msgid "Recursed on a simple control type."
-msgstr ""
-
-#: cli/cli-script.c:947
-msgid "Allocated body is smaller than this command type needs."
-msgstr ""
-
-#: cli/cli-script.c:1204
-msgid "name of command to define"
-msgstr ""
-
-#: cli/cli-script.c:1210
-#, possible-c-format
-msgid "Junk in argument list: \"%s\""
-msgstr ""
-
-#: cli/cli-script.c:1255
-#, possible-c-format
-msgid "Redefine command \"%s\"? "
-msgstr ""
-
-#: cli/cli-script.c:1257
-#, possible-c-format
-msgid "Really redefine built-in command \"%s\"? "
-msgstr ""
-
-#: cli/cli-script.c:1259
-#, possible-c-format
-msgid "Command \"%s\" not redefined."
-msgstr ""
-
-#: cli/cli-script.c:1286
-#, possible-c-format
-msgid "Your new `%s' command does not hook any existing command."
-msgstr ""
-
-#. Should never come here as hookc would be 0.
-#: cli/cli-script.c:1328 complaints.c:299 exceptions.c:151 exceptions.c:168
-#: exceptions.c:194 exceptions.c:254 hppa-tdep.c:3131 hppa-tdep.c:3144
-#: infcall.c:560 infcmd.c:1192 infrun.c:1324 language.c:883 language.c:909
-#: mi/mi-out.c:321 mi/mi-out.c:339 mips-tdep.c:277 mips-tdep.c:336
-#: mips-tdep.c:1261 mips-tdep.c:3782 mips-tdep.c:4750 mn10300-tdep.c:88
-#: reggroups.c:214 remote.c:4600 utils.c:747 utils.c:766
-msgid "bad switch"
-msgstr ""
-
-#: cli/cli-script.c:1346
-#, possible-c-format
-msgid "Command \"%s\" is built-in."
-msgstr ""
-
-#: cli/cli-script.c:1418
-msgid "called with NULL file pointer!"
-msgstr ""
-
-#: cli/cli-script.c:1445
-#, possible-c-format
-msgid ""
-"%s:%d: Error in sourced command file:\n"
-"%s"
-msgstr ""
-
-#: cli/cli-script.c:1448
-msgid "bad reason"
-msgstr ""
-
-#: cli/cli-setshow.c:58
-msgid "\"on\", \"off\" or \"auto\" expected."
-msgstr ""
-
-#: cli/cli-setshow.c:87
-msgid "\"on\" or \"off\" expected."
-msgstr ""
-
-#: cli/cli-setshow.c:191
-msgid "filename to set it to."
-msgstr ""
-
-#: cli/cli-setshow.c:211 cli/cli-setshow.c:220 cli/cli-setshow.c:232
-msgid "integer to set it to."
-msgstr ""
-
-#: cli/cli-setshow.c:225
-#, possible-c-format
-msgid "integer %u out of range"
-msgstr ""
-
-#: cli/cli-setshow.c:261
-#, possible-c-format
-msgid "Requires an argument. Valid arguments are %s."
-msgstr ""
-
-#: cli/cli-setshow.c:289
-#, possible-c-format
-msgid "Undefined item: \"%s\"."
-msgstr ""
-
-#: cli/cli-setshow.c:292
-#, possible-c-format
-msgid "Ambiguous item \"%s\"."
-msgstr ""
-
-#: cli/cli-setshow.c:298 cli/cli-setshow.c:367
-msgid "gdb internal error: bad var_type in do_setshow_command"
-msgstr ""
-
-#: cli/cli-setshow.c:343
-msgid "do_setshow_command: invalid var_auto_boolean"
-msgstr ""
-
-#: cli/cli-setshow.c:391
-msgid "gdb internal error: bad cmd_type in do_setshow_command"
-msgstr ""
-
 #: coffread.c:579
 #, possible-c-format
 msgid "\"%s\": error reading line numbers."
@@ -9948,34 +9948,6 @@ msgstr ""
 msgid "target memory map"
 msgstr ""
 
-#: mi/mi-cmd-break.c:129
-msgid "mi_cmd_break_insert: Missing <location>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:131
-msgid "mi_cmd_break_insert: Garbage following <location>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:156
-msgid "mi_cmd_break_insert: Unsupported tempoary regexp breakpoint"
-msgstr ""
-
-#: mi/mi-cmd-break.c:164
-msgid "mi_cmd_break_insert: Bad switch."
-msgstr ""
-
-#: mi/mi-cmd-break.c:222
-msgid "mi_cmd_break_watch: Missing <expression>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:224
-msgid "mi_cmd_break_watch: Garbage following <expression>"
-msgstr ""
-
-#: mi/mi-cmd-break.c:240
-msgid "mi_cmd_break_watch: Unknown watchpoint type."
-msgstr ""
-
 #: mi/mi-cmd-disas.c:138
 msgid "mi_cmd_disassemble: Mixed_mode argument must be 0 or 1."
 msgstr ""
@@ -9992,28 +9964,13 @@ msgstr ""
 msgid "mi_cmd_disassemble: No function contains specified address"
 msgstr ""
 
-#: mi/mi-cmd-env.c:71
-msgid "mi_cmd_env_pwd: No arguments required"
-msgstr ""
-
-#: mi/mi-cmd-env.c:92
-msgid "mi_cmd_env_cd: Usage DIRECTORY"
-msgstr ""
-
-#: mi/mi-cmd-env.c:261
-msgid "mi_cmd_inferior_tty_show: Usage: No args"
-msgstr ""
-
-#: mi/mi-cmd-file.c:39
-msgid "mi_cmd_file_list_exec_source_file: Usage: No args"
-msgstr ""
-
-#: mi/mi-cmd-file.c:49
-msgid "mi_cmd_file_list_exec_source_file: No symtab"
+#: mi/mi-common.c:50
+msgid "async_reason_string_lookup is inconsistent"
 msgstr ""
 
-#: mi/mi-cmd-file.c:75
-msgid "mi_cmd_file_list_exec_source_files: Usage: No args"
+#: mi/mi-cmds.c:243
+#, possible-c-format
+msgid "command `%s' appears to be duplicated"
 msgstr ""
 
 #: mi/mi-cmd-stack.c:50
@@ -10055,16 +10012,70 @@ msgstr ""
 msgid "mi_cmd_stack_info_frame: No arguments required"
 msgstr ""
 
-#: mi/mi-cmd-target.c:40
-msgid "mi_cmd_target_file_get: Usage: REMOTE_FILE LOCAL_FILE"
+#: mi/mi-cmd-file.c:39
+msgid "mi_cmd_file_list_exec_source_file: Usage: No args"
 msgstr ""
 
-#: mi/mi-cmd-target.c:66
-msgid "mi_cmd_target_file_put: Usage: LOCAL_FILE REMOTE_FILE"
+#: mi/mi-cmd-file.c:49
+msgid "mi_cmd_file_list_exec_source_file: No symtab"
 msgstr ""
 
-#: mi/mi-cmd-target.c:92
-msgid "mi_cmd_target_file_delete: Usage: REMOTE_FILE"
+#: mi/mi-cmd-file.c:75
+msgid "mi_cmd_file_list_exec_source_files: Usage: No args"
+msgstr ""
+
+#: mi/mi-cmd-env.c:71
+msgid "mi_cmd_env_pwd: No arguments required"
+msgstr ""
+
+#: mi/mi-cmd-env.c:92
+msgid "mi_cmd_env_cd: Usage DIRECTORY"
+msgstr ""
+
+#: mi/mi-cmd-env.c:261
+msgid "mi_cmd_inferior_tty_show: Usage: No args"
+msgstr ""
+
+#: mi/mi-cmd-break.c:129
+msgid "mi_cmd_break_insert: Missing <location>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:131
+msgid "mi_cmd_break_insert: Garbage following <location>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:156
+msgid "mi_cmd_break_insert: Unsupported tempoary regexp breakpoint"
+msgstr ""
+
+#: mi/mi-cmd-break.c:164
+msgid "mi_cmd_break_insert: Bad switch."
+msgstr ""
+
+#: mi/mi-cmd-break.c:222
+msgid "mi_cmd_break_watch: Missing <expression>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:224
+msgid "mi_cmd_break_watch: Garbage following <expression>"
+msgstr ""
+
+#: mi/mi-cmd-break.c:240
+msgid "mi_cmd_break_watch: Unknown watchpoint type."
+msgstr ""
+
+#: mi/mi-getopt.c:35
+msgid "mi_getopt_long: optind out of bounds"
+msgstr ""
+
+#: mi/mi-getopt.c:61
+#, possible-c-format
+msgid "%s: Option %s requires an argument"
+msgstr ""
+
+#: mi/mi-getopt.c:73
+#, possible-c-format
+msgid "%s: Unknown option ``%s''"
 msgstr ""
 
 #. mi_error_message = xstrprintf ("mi_cmd_var_create: Usage:
@@ -10221,47 +10232,36 @@ msgstr ""
 msgid "mi_cmd_var_update: Variable object not found"
 msgstr ""
 
-#: mi/mi-cmds.c:243
-#, possible-c-format
-msgid "command `%s' appears to be duplicated"
-msgstr ""
-
-#: mi/mi-common.c:50
-msgid "async_reason_string_lookup is inconsistent"
-msgstr ""
-
-#: mi/mi-console.c:66
-msgid "mi_console_file_delete: bad magic number"
+#: mi/mi-symbol-cmds.c:39
+msgid "mi_cmd_symbol_list_lines: Usage: SOURCE_FILENAME"
 msgstr ""
 
-#: mi/mi-console.c:94
-msgid "mi_console_file_transform: bad magic number"
+#: mi/mi-symbol-cmds.c:45
+msgid "mi_cmd_symbol_list_lines: Unknown source file name."
 msgstr ""
 
-#: mi/mi-console.c:120
-msgid "mi_console_file_flush: bad magic number"
+#: mi/mi-cmd-target.c:40
+msgid "mi_cmd_target_file_get: Usage: REMOTE_FILE LOCAL_FILE"
 msgstr ""
 
-#: mi/mi-getopt.c:35
-msgid "mi_getopt_long: optind out of bounds"
+#: mi/mi-cmd-target.c:66
+msgid "mi_cmd_target_file_put: Usage: LOCAL_FILE REMOTE_FILE"
 msgstr ""
 
-#: mi/mi-getopt.c:61
-#, possible-c-format
-msgid "%s: Option %s requires an argument"
+#: mi/mi-cmd-target.c:92
+msgid "mi_cmd_target_file_delete: Usage: REMOTE_FILE"
 msgstr ""
 
-#: mi/mi-getopt.c:73
-#, possible-c-format
-msgid "%s: Unknown option ``%s''"
+#: mi/mi-console.c:66
+msgid "mi_console_file_delete: bad magic number"
 msgstr ""
 
-#: mi/mi-symbol-cmds.c:39
-msgid "mi_cmd_symbol_list_lines: Usage: SOURCE_FILENAME"
+#: mi/mi-console.c:94
+msgid "mi_console_file_transform: bad magic number"
 msgstr ""
 
-#: mi/mi-symbol-cmds.c:45
-msgid "mi_cmd_symbol_list_lines: Unknown source file name."
+#: mi/mi-console.c:120
+msgid "mi_console_file_flush: bad magic number"
 msgstr ""
 
 #: mips-linux-nat.c:66 mips-linux-nat.c:101
@@ -14460,13 +14460,6 @@ msgid ""
 "directory as the binary, then in the `"
 msgstr ""
 
-#: symfile.c:4180
-msgid ""
-"' subdirectory,\n"
-"and lastly at the path of the directory of the binary with\n"
-"the global debug-file directory prepended."
-msgstr ""
-
 #: symfile-mem.c:76
 msgid "add-symbol-file-from-memory not supported for this target"
 msgstr ""
@@ -15552,34 +15545,6 @@ msgstr ""
 msgid "Register %s not available"
 msgstr ""
 
-#: tui/tui-file.c:78
-msgid "tui_file_delete: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:125
-msgid "tui_file_isatty: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:138
-msgid "tui_file_rewind: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:150
-msgid "tui_file_put: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:186
-msgid "tui_file_get_strbuf: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:200
-msgid "tui_file_adjust_strbuf: bad magic number"
-msgstr ""
-
-#: tui/tui-file.c:227
-msgid "tui_file_flush: bad magic number"
-msgstr ""
-
 #: tui/tui-hooks.c:82
 msgid "(y or n) "
 msgstr ""
@@ -15588,97 +15553,6 @@ msgstr ""
 msgid "Please answer y or n.\n"
 msgstr ""
 
-#: tui/tui-interp.c:113
-msgid "tui_exec called"
-msgstr ""
-
-#: tui/tui-layout.c:381
-msgid ""
-"Change the layout of windows.\n"
-"Usage: layout prev | next | <layout_name> \n"
-"Layout names are:\n"
-"   src   : Displays source and command windows.\n"
-"   asm   : Displays disassembly and command windows.\n"
-"   split : Displays source, disassembly and command windows.\n"
-"   regs  : Displays register window. If existing layout\n"
-"           is source/command or assembly/command, the \n"
-"           register window is displayed. If the\n"
-"           source/assembly/command (split) is displayed, \n"
-"           the register window is displayed with \n"
-"           the window that has current logical focus.\n"
-msgstr ""
-
-#: tui/tui-layout.c:396
-msgid "Toggle between Source/Command and Disassembly/Command layouts.\n"
-msgstr ""
-
-#: tui/tui-layout.c:398
-msgid ""
-"Toggle between Source/Command or Disassembly/Command and \n"
-"Source/Disassembly/Command layouts.\n"
-msgstr ""
-
-#: tui/tui-layout.c:433
-msgid "Ambiguous command input."
-msgstr ""
-
-#: tui/tui-layout.c:600
-#, possible-c-format
-msgid ""
-"Invalid layout specified.\n"
-"%s"
-msgstr ""
-
-#: tui/tui-regs.c:601
-msgid "\"tui reg\" must be followed by the name of a tui reg command.\n"
-msgstr ""
-
-#: tui/tui-regs.c:614
-msgid "TUI commands to control the register window."
-msgstr ""
-
-#: tui/tui-regs.c:619
-msgid "Display only floating point registers."
-msgstr ""
-
-#: tui/tui-regs.c:622
-msgid "Display only general registers."
-msgstr ""
-
-#: tui/tui-regs.c:625
-msgid "Display only system registers."
-msgstr ""
-
-#: tui/tui-regs.c:628
-msgid "Display next register group."
-msgstr ""
-
-#: tui/tui-regs.c:634
-msgid "Display only floating point registers\n"
-msgstr ""
-
-#: tui/tui-regs.c:636
-msgid "Display only general registers\n"
-msgstr ""
-
-#: tui/tui-regs.c:638
-msgid "Display only special registers\n"
-msgstr ""
-
-#: tui/tui-regs.c:640
-msgid "Scroll the registers window forward\n"
-msgstr ""
-
-#: tui/tui-regs.c:642
-msgid "Scroll the register window backward\n"
-msgstr ""
-
-#: tui/tui-stack.c:417
-msgid ""
-"Update the source window and locator to display the current execution "
-"point.\n"
-msgstr ""
-
 #: tui/tui-win.c:211
 #, possible-c-format
 msgid "The attribute mode to use for the active TUI window border is \"%s\".\n"
@@ -15858,6 +15732,125 @@ msgid ""
 "%s"
 msgstr ""
 
+#: tui/tui-stack.c:417
+msgid ""
+"Update the source window and locator to display the current execution "
+"point.\n"
+msgstr ""
+
+#: tui/tui-layout.c:381
+msgid ""
+"Change the layout of windows.\n"
+"Usage: layout prev | next | <layout_name> \n"
+"Layout names are:\n"
+"   src   : Displays source and command windows.\n"
+"   asm   : Displays disassembly and command windows.\n"
+"   split : Displays source, disassembly and command windows.\n"
+"   regs  : Displays register window. If existing layout\n"
+"           is source/command or assembly/command, the \n"
+"           register window is displayed. If the\n"
+"           source/assembly/command (split) is displayed, \n"
+"           the register window is displayed with \n"
+"           the window that has current logical focus.\n"
+msgstr ""
+
+#: tui/tui-layout.c:396
+msgid "Toggle between Source/Command and Disassembly/Command layouts.\n"
+msgstr ""
+
+#: tui/tui-layout.c:398
+msgid ""
+"Toggle between Source/Command or Disassembly/Command and \n"
+"Source/Disassembly/Command layouts.\n"
+msgstr ""
+
+#: tui/tui-layout.c:433
+msgid "Ambiguous command input."
+msgstr ""
+
+#: tui/tui-layout.c:600
+#, possible-c-format
+msgid ""
+"Invalid layout specified.\n"
+"%s"
+msgstr ""
+
+#: tui/tui-interp.c:113
+msgid "tui_exec called"
+msgstr ""
+
+#: tui/tui-file.c:78
+msgid "tui_file_delete: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:125
+msgid "tui_file_isatty: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:138
+msgid "tui_file_rewind: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:150
+msgid "tui_file_put: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:186
+msgid "tui_file_get_strbuf: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:200
+msgid "tui_file_adjust_strbuf: bad magic number"
+msgstr ""
+
+#: tui/tui-file.c:227
+msgid "tui_file_flush: bad magic number"
+msgstr ""
+
+#: tui/tui-regs.c:601
+msgid "\"tui reg\" must be followed by the name of a tui reg command.\n"
+msgstr ""
+
+#: tui/tui-regs.c:614
+msgid "TUI commands to control the register window."
+msgstr ""
+
+#: tui/tui-regs.c:619
+msgid "Display only floating point registers."
+msgstr ""
+
+#: tui/tui-regs.c:622
+msgid "Display only general registers."
+msgstr ""
+
+#: tui/tui-regs.c:625
+msgid "Display only system registers."
+msgstr ""
+
+#: tui/tui-regs.c:628
+msgid "Display next register group."
+msgstr ""
+
+#: tui/tui-regs.c:634
+msgid "Display only floating point registers\n"
+msgstr ""
+
+#: tui/tui-regs.c:636
+msgid "Display only general registers\n"
+msgstr ""
+
+#: tui/tui-regs.c:638
+msgid "Display only special registers\n"
+msgstr ""
+
+#: tui/tui-regs.c:640
+msgid "Scroll the registers window forward\n"
+msgstr ""
+
+#: tui/tui-regs.c:642
+msgid "Scroll the register window backward\n"
+msgstr ""
+
 #: typeprint.c:262
 msgid "internal error: unhandled type in print_type_scalar"
 msgstr ""
diff --git a/gdb/regformats/reg-lx.dat b/gdb/regformats/reg-lx.dat
new file mode 100644
index 0000000..974d538
--- /dev/null
+++ b/gdb/regformats/reg-lx.dat
@@ -0,0 +1,78 @@
+name:lx
+expedite:pc,r12,r14,r63
+32:pc
+32:psw
+32:r0
+32:r1
+32:r2
+32:r3
+32:r4
+32:r5
+32:r6
+32:r7
+32:r8
+32:r9
+32:r10
+32:r11
+32:r12
+32:r13
+32:r14
+32:r15
+32:r16
+32:r17
+32:r18
+32:r19
+32:r20
+32:r21
+32:r22
+32:r23
+32:r24
+32:r25
+32:r26
+32:r27
+32:r28
+32:r29
+32:r30
+32:r31
+32:r32
+32:r33
+32:r34
+32:r35
+32:r36
+32:r37
+32:r38
+32:r39
+32:r40
+32:r41
+32:r42
+32:r43
+32:r44
+32:r45
+32:r46
+32:r47
+32:r48
+32:r49
+32:r50
+32:r51
+32:r52
+32:r53
+32:r54
+32:r55
+32:r56
+32:r57
+32:r58
+32:r59
+32:r60
+32:r61
+32:r62
+32:r63
+
+32:b0
+32:b1
+32:b2
+32:b3
+32:b4
+32:b5
+32:b6
+32:b7
+
diff --git a/gdb/remote.c b/gdb/remote.c
index 3f50ff2..44db335 100644
--- a/gdb/remote.c
+++ b/gdb/remote.c
@@ -3,6 +3,7 @@
    Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
    1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -2856,7 +2857,7 @@ extended_remote_attach_1 (struct target_ops *target, char *args, int from_tty)
   if (remote_protocol_packets[PACKET_vAttach].support == PACKET_DISABLE)
     error (_("This target does not support attaching to a process"));
 
-  sprintf (rs->buf, "vAttach;%x", pid);
+  sprintf (rs->buf, "vAttach;%x", (unsigned int) pid);
   putpkt (rs->buf);
   getpkt (&rs->buf, &rs->buf_size, 0);
 
diff --git a/gdb/sh-tdep.c b/gdb/sh-tdep.c
index 6aeb0e8..8c941b8 100644
--- a/gdb/sh-tdep.c
+++ b/gdb/sh-tdep.c
@@ -2,6 +2,7 @@
 
    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
    2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2007 STMicroelectronics
 
    This file is part of GDB.
 
@@ -43,6 +44,7 @@
 #include "doublest.h"
 #include "osabi.h"
 #include "reggroups.h"
+#include "sim-regno.h"
 
 #include "sh-tdep.h"
 
@@ -54,9 +56,7 @@
 /* registers numbers shared with the simulator */
 #include "gdb/sim-sh.h"
 
-static void (*sh_show_regs) (struct frame_info *);
-
-#define SH_NUM_REGS 67
+#define SH_NUM_REGS 109
 
 struct sh_frame_cache
 {
@@ -80,13 +80,6 @@ sh_sh_register_name (struct gdbarch *gdbarch, int reg_nr)
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -102,13 +95,12 @@ sh_sh3_register_name (struct gdbarch *gdbarch, int reg_nr)
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     "ssr", "spc",
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
-    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1"
-    "", "", "", "", "", "", "", "",
+    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
   };
   if (reg_nr < 0)
     return NULL;
@@ -130,7 +122,6 @@ sh_sh3e_register_name (struct gdbarch *gdbarch, int reg_nr)
     "ssr", "spc",
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
     "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -149,10 +140,6 @@ sh_sh2e_register_name (struct gdbarch *gdbarch, int reg_nr)
     "fpul", "fpscr",
     "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
     "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
-    "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -176,7 +163,7 @@ sh_sh2a_register_name (struct gdbarch *gdbarch, int reg_nr)
     "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
     "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
     /* 41, 42 */
-    "", "",
+    NULL, NULL,
     /* 43 - 62.  Banked registers.  The bank number used is determined by
        the bank register (63). */
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
@@ -185,13 +172,20 @@ sh_sh2a_register_name (struct gdbarch *gdbarch, int reg_nr)
     /* 63: register bank number, not a real register but used to
        communicate the register bank currently get/set.  This register
        is hidden to the user, who manipulates it using the pseudo
-       register called "bank" (67).  See below.  */
-    "",
+       register called "bank" (109).  See below.  */
+    NULL,
     /* 64 - 66 */
     "ibcr", "ibnr", "tbr",
-    /* 67: register bank number, the user visible pseudo register.  */
+    /* 67 - 108 */
+    NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    /* 109: register bank number, the user visible pseudo register.  */
     "bank",
-    /* double precision (pseudo) 68 - 75 */
+    /* double precision (pseudo) 110 - 117 */
     "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
   };
   if (reg_nr < 0)
@@ -211,12 +205,12 @@ sh_sh2a_nofpu_register_name (struct gdbarch *gdbarch, int reg_nr)
     /* 16 - 22 */
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
     /* 23, 24 */
-    "", "",
+    NULL, NULL,
     /* floating point registers 25 - 40 */
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     /* 41, 42 */
-    "", "",
+    NULL, NULL,
     /* 43 - 62.  Banked registers.  The bank number used is determined by
        the bank register (63). */
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
@@ -225,14 +219,19 @@ sh_sh2a_nofpu_register_name (struct gdbarch *gdbarch, int reg_nr)
     /* 63: register bank number, not a real register but used to
        communicate the register bank currently get/set.  This register
        is hidden to the user, who manipulates it using the pseudo
-       register called "bank" (67).  See below.  */
-    "",
+       register called "bank" (109).  See below.  */
+    NULL,
     /* 64 - 66 */
     "ibcr", "ibnr", "tbr",
-    /* 67: register bank number, the user visible pseudo register.  */
+    /* 67 - 108 */
+    NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    /* 109: register bank number, the user visible pseudo register.  */
     "bank",
-    /* double precision (pseudo) 68 - 75 */
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -248,13 +247,11 @@ sh_sh_dsp_register_name (struct gdbarch *gdbarch, int reg_nr)
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "dsr",
+    NULL, "dsr",
     "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
-    "y0", "y1", "", "", "", "", "", "mod",
-    "", "",
-    "rs", "re", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    "y0", "y1", NULL, NULL, NULL, NULL, NULL, "mod",
+    NULL, NULL,
+    "rs", "re",
   };
   if (reg_nr < 0)
     return NULL;
@@ -270,14 +267,12 @@ sh_sh3_dsp_register_name (struct gdbarch *gdbarch, int reg_nr)
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "dsr",
+    NULL, "dsr",
     "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
-    "y0", "y1", "", "", "", "", "", "mod",
+    "y0", "y1", NULL, NULL, NULL, NULL, NULL, "mod",
     "ssr", "spc",
-    "rs", "re", "", "", "", "", "", "",
+    "rs", "re", NULL, NULL, NULL, NULL, NULL, NULL,
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -297,7 +292,7 @@ sh_sh4_register_name (struct gdbarch *gdbarch, int reg_nr)
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
     /* 23, 24 */
     "fpul", "fpscr",
-    /* floating point registers 25 - 40 */
+    /* floating point 25 - 40 */
     "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
     "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
     /* 41, 42 */
@@ -306,15 +301,25 @@ sh_sh4_register_name (struct gdbarch *gdbarch, int reg_nr)
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
     /* bank 1 51 - 58 */
     "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
-    "", "", "", "", "", "", "", "",
-    /* pseudo bank register. */
-    "",
-    /* double precision (pseudo) 59 - 66 */
+    /* 59, 60 */
+    "dbr", "sgr",
+    /* extended floating point 61 - 76 */
+    "xf0", "xf1", "xf2", "xf3", "xf4", "xf5", "xf6", "xf7",
+    "xf8", "xf9", "xf10", "xf11", "xf12", "xf13", "xf14", "xf15",
+    /* floating point bank 0 77 - 92 */
+    "fr0b0", "fr1b0", "fr2b0", "fr3b0", "fr4b0", "fr5b0", "fr6b0", "fr7b0",
+    "fr8b0", "fr9b0", "fr10b0", "fr11b0", "fr12b0", "fr13b0", "fr14b0", "fr15b0",
+    /* floating point bank 1 93 - 108 */
+    "fr0b1", "fr1b1", "fr2b1", "fr3b1", "fr4b1", "fr5b1", "fr6b1", "fr7b1",
+    "fr8b1", "fr9b1", "fr10b1", "fr11b1", "fr12b1", "fr13b1", "fr14b1", "fr15b1",
+    /* 109 */
+    NULL,
+    /* double precision (pseudo) 110 - 117 */
     "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
-    /* vectors (pseudo) 67 - 70 */
+    /* extended double precision (pseudo) 118 - 125 */
+    "xd0", "xd2", "xd4", "xd6", "xd8", "xd10", "xd12", "xd14",
+    /* vectors (pseudo) 126 - 129 */
     "fv0", "fv4", "fv8", "fv12",
-    /* FIXME: missing XF 71 - 86 */
-    /* FIXME: missing XD 87 - 94 */
   };
   if (reg_nr < 0)
     return NULL;
@@ -333,23 +338,18 @@ sh_sh4_nofpu_register_name (struct gdbarch *gdbarch, int reg_nr)
     /* 16 - 22 */
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
     /* 23, 24 */
-    "", "",
+    NULL, NULL,
     /* floating point registers 25 - 40 -- not for nofpu target */
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
     /* 41, 42 */
     "ssr", "spc",
     /* bank 0 43 - 50 */
     "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
     /* bank 1 51 - 58 */
     "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
-    "", "", "", "", "", "", "", "",
-    /* pseudo bank register. */
-    "",
-    /* double precision (pseudo) 59 - 66 -- not for nofpu target */
-    "", "", "", "", "", "", "", "",
-    /* vectors (pseudo) 67 - 70 -- not for nofpu target */
-    "", "", "", "",
+    /* 59, 60 */
+    "dbr", "sgr",
   };
   if (reg_nr < 0)
     return NULL;
@@ -365,14 +365,12 @@ sh_sh4al_dsp_register_name (struct gdbarch *gdbarch, int reg_nr)
     "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
     "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
     "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
-    "", "dsr",
+    NULL, "dsr",
     "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
-    "y0", "y1", "", "", "", "", "", "mod",
+    "y0", "y1", NULL, NULL, NULL, NULL, NULL, "mod",
     "ssr", "spc",
-    "rs", "re", "", "", "", "", "", "",
+    "rs", "re", NULL, NULL, NULL, NULL, NULL, NULL,
     "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
-    "", "", "", "", "", "", "", "",
-    "", "", "", "", "", "", "", "",
   };
   if (reg_nr < 0)
     return NULL;
@@ -419,33 +417,33 @@ sh_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
    Actually it can be more complicated than this but that's it, basically.
  */
 
-#define GET_SOURCE_REG(x)  	(((x) >> 4) & 0xf)
-#define GET_TARGET_REG(x)  	(((x) >> 8) & 0xf)
+#define GET_SOURCE_REG(x)	(((x) >> 4) & 0xf)
+#define GET_TARGET_REG(x)	(((x) >> 8) & 0xf)
 
 /* JSR @Rm         0100mmmm00001011 */
 #define IS_JSR(x)		(((x) & 0xf0ff) == 0x400b)
 
 /* STS.L PR,@-r15  0100111100100010
    r15-4-->r15, PR-->(r15) */
-#define IS_STS(x)  		((x) == 0x4f22)
+#define IS_STS(x)		((x) == 0x4f22)
 
 /* STS.L MACL,@-r15  0100111100010010
    r15-4-->r15, MACL-->(r15) */
-#define IS_MACL_STS(x)  	((x) == 0x4f12)
+#define IS_MACL_STS(x)		((x) == 0x4f12)
 
 /* MOV.L Rm,@-r15  00101111mmmm0110
    r15-4-->r15, Rm-->(R15) */
-#define IS_PUSH(x) 		(((x) & 0xff0f) == 0x2f06)
+#define IS_PUSH(x)		(((x) & 0xff0f) == 0x2f06)
 
 /* MOV r15,r14     0110111011110011
    r15-->r14  */
-#define IS_MOV_SP_FP(x)  	((x) == 0x6ef3)
+#define IS_MOV_SP_FP(x)		((x) == 0x6ef3)
 
 /* ADD #imm,r15    01111111iiiiiiii
    r15+imm-->r15 */
-#define IS_ADD_IMM_SP(x) 	(((x) & 0xff00) == 0x7f00)
+#define IS_ADD_IMM_SP(x)	(((x) & 0xff00) == 0x7f00)
 
-#define IS_MOV_R3(x) 		(((x) & 0xff00) == 0x1a00)
+#define IS_MOV_R3(x)		(((x) & 0xff00) == 0x1a00)
 #define IS_SHLL_R3(x)		((x) == 0x4300)
 
 /* ADD r3,r15      0011111100111100
@@ -485,16 +483,19 @@ sh_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
 /* SUB Rn,R15                 00111111nnnn1000 */
 #define IS_SUB_REG_FROM_SP(x)	(((x) & 0xff0f) == 0x3f08)
 
+#define SR_RB			(1 << 29)
+#define FPSCR_PR		(1 << 19)
 #define FPSCR_SZ		(1 << 20)
+#define FPSCR_FR		(1 << 21)
 
 /* The following instructions are used for epilogue testing. */
 #define IS_RESTORE_FP(x)	((x) == 0x6ef6)
 #define IS_RTS(x)		((x) == 0x000b)
-#define IS_LDS(x)  		((x) == 0x4f26)
-#define IS_MACL_LDS(x)  	((x) == 0x4f16)
-#define IS_MOV_FP_SP(x)  	((x) == 0x6fe3)
+#define IS_LDS(x)		((x) == 0x4f26)
+#define IS_MACL_LDS(x)		((x) == 0x4f16)
+#define IS_MOV_FP_SP(x)		((x) == 0x6fe3)
 #define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
-#define IS_ADD_IMM_FP(x) 	(((x) & 0xff00) == 0x7e00)
+#define IS_ADD_IMM_FP(x)	(((x) & 0xff00) == 0x7e00)
 
 /* Disassemble an instruction.  */
 static int
@@ -584,12 +585,12 @@ sh_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
 	    }
 	}
       else if (IS_MOVI20 (inst))
-        {
+	{
 	  if (sav_reg < 0)
 	    {
 	      reg = GET_TARGET_REG (inst);
 	      if (reg < 14)
-	        {
+		{
 		  sav_reg = reg;
 		  sav_offset = GET_SOURCE_REG (inst) << 16;
 		  /* MOVI20 is a 32 bit instruction! */
@@ -770,7 +771,7 @@ sh_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
    the return value from foo() will be in memory, not
    in R0, because there is no 3-byte integer type.
 
-   Similarly, in 
+   Similarly, in
 
    struct s { char c[2]; } wibble;
    struct s foo(void) {  return wibble; }
@@ -783,31 +784,80 @@ sh_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
 */
 
 static int
-sh_use_struct_convention (int gcc_p, struct type *type)
+sh_type_align (struct type *type)
 {
   int len = TYPE_LENGTH (type);
-  int nelem = TYPE_NFIELDS (type);
 
-  /* Non-power of 2 length types and types bigger than 8 bytes (which don't
-     fit in two registers anyway) use struct convention.  */
-  if (len != 1 && len != 2 && len != 4 && len != 8)
-    return 1;
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_STRUCT:
+    case TYPE_CODE_UNION:
+      {
+	int i, align = 1;
+	for (i = 0; i < TYPE_NFIELDS (type); i++)
+	  {
+	    int falign = sh_type_align (TYPE_FIELD_TYPE (type, i));
+	    if (falign > align)
+	      align = falign;
+	  }
+	return align;
+      }
+    case TYPE_CODE_ARRAY:
+    case TYPE_CODE_COMPLEX:
+      return sh_type_align (TYPE_TARGET_TYPE (type));
+    case TYPE_CODE_TYPEDEF:
+      return sh_type_align (check_typedef (type));
+    }
 
-  /* Scalar types and aggregate types with exactly one field are aligned
-     by definition.  They are returned in registers.  */
-  if (nelem <= 1)
-    return 0;
+  /* Assume scalar type with maximum alignment of 4 bytes.  */
+  return (len > 4) ? 4 : len;
+}
 
-  /* If the first field in the aggregate has the same length as the entire
-     aggregate type, the type is returned in registers.  */
-  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == len)
-    return 0;
+static int
+sh_treat_as_complex (struct type *type)
+{
+  switch (TYPE_CODE (type))
+    {
+    /* Complex int types are represented as simple int types.  */
+    case TYPE_CODE_INT:
+    case TYPE_CODE_COMPLEX:
+      return 1;
+    case TYPE_CODE_STRUCT:
+      /* Structs with one member maybe treated as complex.  */
+      if (TYPE_NFIELDS (type) == 1)
+	return sh_treat_as_complex (TYPE_FIELD_TYPE (type, 0));
+      break;
+    case TYPE_CODE_ARRAY:
+      /* Arrays with one element maybe treated as complex.  */
+      if (TYPE_LENGTH (type) == TYPE_LENGTH (TYPE_TARGET_TYPE (type)))
+	return sh_treat_as_complex (TYPE_TARGET_TYPE (type));
+      break;
+    case TYPE_CODE_TYPEDEF:
+      return sh_treat_as_complex (check_typedef (type));
+    }
 
-  /* If the size of the aggregate is 8 bytes and the first field is
-     of size 4 bytes its alignment is equal to long long's alignment,
-     so it's returned in registers.  */
-  if (len == 8 && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)
-    return 0;
+  /* Otherwise it's not treated as complex.  */
+  return 0;
+}
+
+static int
+sh_use_struct_convention (struct type *type)
+{
+  int len = TYPE_LENGTH (type);
+  int align = sh_type_align (type);
+
+  /* Check for register convention.  */
+  switch (len)
+    {
+    case 1:
+    case 2:
+    case 4:
+      return (align != len);
+    case 8:
+      return (align != 4);
+    case 16:
+      return (align != 4) || !sh_treat_as_complex (type);
+    }
 
   /* Otherwise use struct convention.  */
   return 1;
@@ -832,16 +882,16 @@ sh_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
    manner, but using FP registers instead of GP registers.
 
    Arguments that are smaller than 4 bytes will still take up a whole
-   register or a whole 32-bit word on the stack, and will be 
+   register or a whole 32-bit word on the stack, and will be
    right-justified in the register or the stack word.  This includes
    chars, shorts, and small aggregate types.
 
-   Arguments that are larger than 4 bytes may be split between two or 
+   Arguments that are larger than 4 bytes may be split between two or
    more registers.  If there are not enough registers free, an argument
    may be passed partly in a register (or registers), and partly on the
-   stack.  This includes doubles, long longs, and larger aggregates. 
-   As far as I know, there is no upper limit to the size of aggregates 
-   that will be passed in this way; in other words, the convention of 
+   stack.  This includes doubles, long longs, and larger aggregates.
+   As far as I know, there is no upper limit to the size of aggregates
+   that will be passed in this way; in other words, the convention of
    passing a pointer to a large aggregate instead of a copy is not used.
 
    MVS: The above appears to be true for the SH variants that do not
@@ -850,24 +900,24 @@ sh_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
    if it is larger than 16 bytes (four GP registers).
 
    An exceptional case exists for struct arguments (and possibly other
-   aggregates such as arrays) if the size is larger than 4 bytes but 
-   not a multiple of 4 bytes.  In this case the argument is never split 
+   aggregates such as arrays) if the size is larger than 4 bytes but
+   not a multiple of 4 bytes.  In this case the argument is never split
    between the registers and the stack, but instead is copied in its
-   entirety onto the stack, AND also copied into as many registers as 
-   there is room for.  In other words, space in registers permitting, 
+   entirety onto the stack, AND also copied into as many registers as
+   there is room for.  In other words, space in registers permitting,
    two copies of the same argument are passed in.  As far as I can tell,
-   only the one on the stack is used, although that may be a function 
+   only the one on the stack is used, although that may be a function
    of the level of compiler optimization.  I suspect this is a compiler
-   bug.  Arguments of these odd sizes are left-justified within the 
-   word (as opposed to arguments smaller than 4 bytes, which are 
+   bug.  Arguments of these odd sizes are left-justified within the
+   word (as opposed to arguments smaller than 4 bytes, which are
    right-justified).
 
-   If the function is to return an aggregate type such as a struct, it 
-   is either returned in the normal return value register R0 (if its 
+   If the function is to return an aggregate type such as a struct, it
+   is either returned in the normal return value register R0 (if its
    size is no greater than one byte), or else the caller must allocate
    space into which the callee will copy the return value (if the size
-   is greater than one byte).  In this case, a pointer to the return 
-   value location is passed into the callee in register R2, which does 
+   is greater than one byte).  In this case, a pointer to the return
+   value location is passed into the callee in register R2, which does
    not displace any of the other arguments passed in via registers R4
    to R7.   */
 
@@ -916,7 +966,7 @@ sh_init_flt_argreg (void)
 
 /* This function returns the next register to use for float arg passing.
    It returns either a valid value between FLOAT_ARG0_REGNUM and
-   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns 
+   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns
    FLOAT_ARGLAST_REGNUM + 1 to indicate that no register is available.
 
    Note that register number 0 in flt_argreg_array corresponds with the
@@ -984,6 +1034,8 @@ sh_next_flt_argreg (struct gdbarch *gdbarch, int len)
 
      double d;
 
+   The same is also true for arrays of float type with exactly one element.
+
    As a result, arguments of these struct types are pushed into floating point
    registers exactly as floats or doubles, using the same decision algorithm.
 
@@ -994,21 +1046,28 @@ sh_next_flt_argreg (struct gdbarch *gdbarch, int len)
 static int
 sh_treat_as_flt_p (struct type *type)
 {
-  int len = TYPE_LENGTH (type);
+  switch (TYPE_CODE (type))
+    {
+    case TYPE_CODE_FLT:
+      /* Ordinary float types are obviously treated as float.  */
+      return 1;
+    case TYPE_CODE_STRUCT:
+      /* Structs with one member maybe treated as float.  */
+      if (TYPE_NFIELDS (type) == 1)
+	return sh_treat_as_flt_p (TYPE_FIELD_TYPE (type, 0));
+      break;
+    case TYPE_CODE_ARRAY:
+      /* Arrays with one element maybe treated as float.  */
+      if (TYPE_LENGTH (type) == TYPE_LENGTH (TYPE_TARGET_TYPE (type)))
+	return sh_treat_as_flt_p (TYPE_TARGET_TYPE (type));
+      break;
+    case TYPE_CODE_COMPLEX:
+      /* Complex types maybe treated as float.  */
+      return sh_treat_as_flt_p (TYPE_TARGET_TYPE (type));
+    case TYPE_CODE_TYPEDEF:
+      return sh_treat_as_flt_p (check_typedef (type));
+    }
 
-  /* Ordinary float types are obviously treated as float.  */
-  if (TYPE_CODE (type) == TYPE_CODE_FLT)
-    return 1;
-  /* Otherwise non-struct types are not treated as float.  */
-  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)
-    return 0;
-  /* Otherwise structs with more than one memeber are not treated as float.  */
-  if (TYPE_NFIELDS (type) != 1)
-    return 0;
-  /* Otherwise if the type of that member is float, the whole type is
-     treated as float.  */
-  if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT)
-    return 1;
   /* Otherwise it's not treated as float.  */
   return 0;
 }
@@ -1056,7 +1115,7 @@ sh_push_dummy_call_fpu (struct gdbarch *gdbarch,
       val = sh_justify_value_in_reg (gdbarch, args[argnum], len);
 
       /* Some decisions have to be made how various types are handled.
-         This also differs in different ABIs. */
+	 This also differs in different ABIs. */
       pass_on_stack = 0;
 
       /* Find out the next register to use for a floating point value. */
@@ -1073,7 +1132,7 @@ sh_push_dummy_call_fpu (struct gdbarch *gdbarch,
 	{
 	  if ((treat_as_flt && flt_argreg > FLOAT_ARGLAST_REGNUM)
 	      || (!treat_as_flt && (argreg > ARGLAST_REGNUM
-	                            || pass_on_stack)))
+				    || pass_on_stack)))
 	    {
 	      /* The data goes entirely on the stack, 4-byte aligned. */
 	      reg_size = (len + 3) & ~3;
@@ -1086,15 +1145,15 @@ sh_push_dummy_call_fpu (struct gdbarch *gdbarch,
 	      reg_size = register_size (gdbarch, flt_argreg);
 	      regval = extract_unsigned_integer (val, reg_size);
 	      /* In little endian mode, float types taking two registers
-	         (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
+		 (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
 		 be stored swapped in the argument registers.  The below
 		 code first writes the first 32 bits in the next but one
 		 register, increments the val and len values accordingly
 		 and then proceeds as normal by writing the second 32 bits
 		 into the next register. */
 	      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE
-	          && TYPE_LENGTH (type) == 2 * reg_size)
-	        {
+		  && TYPE_LENGTH (type) == 2 * reg_size)
+		{
 		  regcache_cooked_write_unsigned (regcache, flt_argreg + 1,
 						  regval);
 		  val += reg_size;
@@ -1167,7 +1226,7 @@ sh_push_dummy_call_nofpu (struct gdbarch *gdbarch,
 	  if (argreg > ARGLAST_REGNUM)
 	    {
 	      /* The remainder of the data goes entirely on the stack,
-	         4-byte aligned. */
+		 4-byte aligned. */
 	      reg_size = (len + 3) & ~3;
 	      write_memory (sp + stack_offset, val, reg_size);
 	      stack_offset += reg_size;
@@ -1206,24 +1265,20 @@ sh_extract_return_value_nofpu (struct type *type, struct regcache *regcache,
 			       void *valbuf)
 {
   int len = TYPE_LENGTH (type);
-  int return_register = R0_REGNUM;
-  int offset;
 
   if (len <= 4)
     {
-      ULONGEST c;
+      ULONGEST val;
 
-      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &c);
-      store_unsigned_integer (valbuf, len, c);
+      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &val);
+      store_unsigned_integer (valbuf, len, val);
     }
-  else if (len == 8)
+  else
     {
       int i, regnum = R0_REGNUM;
       for (i = 0; i < len; i += 4)
 	regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
     }
-  else
-    error (_("bad size for return value"));
 }
 
 static void
@@ -1234,7 +1289,7 @@ sh_extract_return_value_fpu (struct type *type, struct regcache *regcache,
   if (sh_treat_as_flt_p (type))
     {
       int len = TYPE_LENGTH (type);
-      int i, regnum = gdbarch_fp0_regnum (gdbarch);
+      int i, regnum = FR0_REGNUM;
       for (i = 0; i < len; i += 4)
 	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
 	  regcache_raw_read (regcache, regnum++, (char *) valbuf + len - 4 - i);
@@ -1248,18 +1303,19 @@ sh_extract_return_value_fpu (struct type *type, struct regcache *regcache,
 /* Write into appropriate registers a function return value
    of type TYPE, given in virtual format.
    If the architecture is sh4 or sh3e, store a function's return value
-   in the R0 general register or in the FP0 floating point register,
+   in the R0 general register or in the FR0 floating point register,
    depending on the type of the return value. In all the other cases
    the result is stored in r0, left-justified. */
 static void
 sh_store_return_value_nofpu (struct type *type, struct regcache *regcache,
 			     const void *valbuf)
 {
-  ULONGEST val;
   int len = TYPE_LENGTH (type);
 
   if (len <= 4)
     {
+      ULONGEST val;
+
       val = extract_unsigned_integer (valbuf, len);
       regcache_cooked_write_unsigned (regcache, R0_REGNUM, val);
     }
@@ -1279,7 +1335,7 @@ sh_store_return_value_fpu (struct type *type, struct regcache *regcache,
   if (sh_treat_as_flt_p (type))
     {
       int len = TYPE_LENGTH (type);
-      int i, regnum = gdbarch_fp0_regnum (gdbarch);
+      int i, regnum = FR0_REGNUM;
       for (i = 0; i < len; i += 4)
 	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
 	  regcache_raw_write (regcache, regnum++,
@@ -1296,7 +1352,7 @@ sh_return_value_nofpu (struct gdbarch *gdbarch, struct type *type,
 		       struct regcache *regcache,
 		       gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  if (sh_use_struct_convention (0, type))
+  if (sh_use_struct_convention (type))
     return RETURN_VALUE_STRUCT_CONVENTION;
   if (writebuf)
     sh_store_return_value_nofpu (type, regcache, writebuf);
@@ -1310,7 +1366,7 @@ sh_return_value_fpu (struct gdbarch *gdbarch, struct type *type,
 		     struct regcache *regcache,
 		     gdb_byte *readbuf, const gdb_byte *writebuf)
 {
-  if (sh_use_struct_convention (0, type))
+  if (sh_use_struct_convention (type))
     return RETURN_VALUE_STRUCT_CONVENTION;
   if (writebuf)
     sh_store_return_value_fpu (type, regcache, writebuf);
@@ -1364,6 +1420,9 @@ sh_generic_show_regs (struct frame_info *frame)
 static void
 sh3_show_regs (struct frame_info *frame)
 {
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
@@ -1403,16 +1462,26 @@ sh3_show_regs (struct frame_info *frame)
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
+  printf_filtered
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
 }
 
 static void
 sh2e_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
@@ -1451,53 +1520,37 @@ sh2e_show_regs (struct frame_info *frame)
      (long) get_frame_register_unsigned (frame, 15));
 
   printf_filtered
-    ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
-  printf_filtered
-    ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+    ("FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
+  printf_filtered
+    ("FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
 }
 
 static void
 sh2a_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
-  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;
+  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & FPSCR_PR;
 
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
@@ -1538,42 +1591,26 @@ sh2a_show_regs (struct frame_info *frame)
 
   printf_filtered
     (pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
+	: "FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
   printf_filtered
     (pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+	: "FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
   printf_filtered
     ("BANK=%-3d\n", (int) get_frame_register_unsigned (frame, BANK_REGNUM));
   printf_filtered
@@ -1607,8 +1644,6 @@ sh2a_show_regs (struct frame_info *frame)
 static void
 sh2a_nofpu_show_regs (struct frame_info *frame)
 {
-  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;
-
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
@@ -1685,11 +1720,14 @@ sh2a_nofpu_show_regs (struct frame_info *frame)
 static void
 sh3e_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
@@ -1726,43 +1764,37 @@ sh3e_show_regs (struct frame_info *frame)
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
-
   printf_filtered
-    ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
-  printf_filtered
-    ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
+
+  printf_filtered
+    ("FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
+  printf_filtered
+    ("FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
 }
 
 static void
@@ -1832,26 +1864,32 @@ sh3_dsp_show_regs (struct frame_info *frame)
 static void
 sh4_show_regs (struct frame_info *frame)
 {
-  struct gdbarch *gdbarch = get_frame_arch (frame);
-  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & FPSCR_PR;
 
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
-					 gdbarch_pc_regnum (gdbarch))),
+					 gdbarch_pc_regnum
+					   (get_frame_arch (frame)))),
      (long) get_frame_register_unsigned (frame, SR_REGNUM),
      (long) get_frame_register_unsigned (frame, PR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
 
   printf_filtered
-    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
+    ("     GBR %08lx      VBR %08lx      DBR %08lx     MACL %08lx\n",
      (long) get_frame_register_unsigned (frame, GBR_REGNUM),
      (long) get_frame_register_unsigned (frame, VBR_REGNUM),
+     (long) get_frame_register_unsigned (frame, DBR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACL_REGNUM));
   printf_filtered
-    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
+    ("     SSR %08lx      SPC %08lx      SGR %08lx\n",
      (long) get_frame_register_unsigned (frame, SSR_REGNUM),
      (long) get_frame_register_unsigned (frame, SPC_REGNUM),
+     (long) get_frame_register_unsigned (frame, SGR_REGNUM));
+  printf_filtered
+    ("    FPUL %08lx    FPSCR %08lx\n",
      (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
      (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));
 
@@ -1875,50 +1913,70 @@ sh4_show_regs (struct frame_info *frame)
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
+  printf_filtered
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
 
   printf_filtered
     (pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
+	: "FR0-FR7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 7));
   printf_filtered
     (pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
-	: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
-     (long) get_frame_register_unsigned
-	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
+	: "FR8-FR15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, FR0_REGNUM + 15));
+
+  printf_filtered
+    (pr ? "XD0-XD6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
+        : "XF0-XF7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 0),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 1),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 2),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 3),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 4),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 5),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 6),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 7));
+  printf_filtered
+    (pr ? "XD8-XD14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
+        : "XF8-XF15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 8),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 9),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 10),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 11),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 12),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 13),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 14),
+     (long) get_frame_register_unsigned (frame, XF0_REGNUM + 15));
 }
 
 static void
 sh4_nofpu_show_regs (struct frame_info *frame)
 {
+  int r0bank = (get_frame_register_unsigned (frame, SR_REGNUM) & SR_RB)
+	       ? R0_BANK0_REGNUM : R0_BANK0_REGNUM + 8;
+
   printf_filtered
     ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
      paddr (get_frame_register_unsigned (frame,
@@ -1929,16 +1987,16 @@ sh4_nofpu_show_regs (struct frame_info *frame)
      (long) get_frame_register_unsigned (frame, MACH_REGNUM));
 
   printf_filtered
-    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
+    ("     GBR %08lx      VBR %08lx      DBR %08lx     MACL %08lx\n",
      (long) get_frame_register_unsigned (frame, GBR_REGNUM),
      (long) get_frame_register_unsigned (frame, VBR_REGNUM),
+     (long) get_frame_register_unsigned (frame, DBR_REGNUM),
      (long) get_frame_register_unsigned (frame, MACL_REGNUM));
   printf_filtered
-    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
+    ("     SSR %08lx      SPC %08lx      SGR %08lx\n",
      (long) get_frame_register_unsigned (frame, SSR_REGNUM),
      (long) get_frame_register_unsigned (frame, SPC_REGNUM),
-     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
-     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));
+     (long) get_frame_register_unsigned (frame, SGR_REGNUM));
 
   printf_filtered
     ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
@@ -1960,6 +2018,16 @@ sh4_nofpu_show_regs (struct frame_info *frame)
      (long) get_frame_register_unsigned (frame, 13),
      (long) get_frame_register_unsigned (frame, 14),
      (long) get_frame_register_unsigned (frame, 15));
+  printf_filtered
+    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
+     (long) get_frame_register_unsigned (frame, r0bank + 0),
+     (long) get_frame_register_unsigned (frame, r0bank + 1),
+     (long) get_frame_register_unsigned (frame, r0bank + 2),
+     (long) get_frame_register_unsigned (frame, r0bank + 3),
+     (long) get_frame_register_unsigned (frame, r0bank + 4),
+     (long) get_frame_register_unsigned (frame, r0bank + 5),
+     (long) get_frame_register_unsigned (frame, r0bank + 6),
+     (long) get_frame_register_unsigned (frame, r0bank + 7));
 }
 
 static void
@@ -2023,18 +2091,81 @@ sh_dsp_show_regs (struct frame_info *frame)
 static void
 sh_show_regs_command (char *args, int from_tty)
 {
-  if (sh_show_regs)
-    (*sh_show_regs) (get_current_frame ());
+  struct frame_info *frame = get_current_frame ();
+
+  switch (gdbarch_bfd_arch_info (get_frame_arch (frame))->mach)
+    {
+    case bfd_mach_sh2e:
+      sh2e_show_regs (frame);
+      break;
+
+    case bfd_mach_sh2a:
+      sh2a_show_regs (frame);
+      break;
+
+    case bfd_mach_sh2a_nofpu:
+      sh2a_nofpu_show_regs (frame);
+      break;
+
+    case bfd_mach_sh_dsp:
+      sh_dsp_show_regs (frame);
+      break;
+
+    case bfd_mach_sh3:
+    case bfd_mach_sh3_nommu:
+    case bfd_mach_sh2a_nofpu_or_sh3_nommu:
+      sh3_show_regs (frame);
+      break;
+
+    case bfd_mach_sh3e:
+    case bfd_mach_sh2a_or_sh3e:
+      sh3e_show_regs (frame);
+      break;
+
+    case bfd_mach_sh3_dsp:
+    case bfd_mach_sh4al_dsp:
+      sh3_dsp_show_regs (frame);
+      break;
+
+    case bfd_mach_sh4:
+    case bfd_mach_sh4a:
+    case bfd_mach_st40_300:
+    case bfd_mach_st40_300_or_sh4a:
+      sh4_show_regs (frame);
+      break;
+
+    case bfd_mach_sh4_nofpu:
+    case bfd_mach_sh4a_nofpu:
+    case bfd_mach_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_or_sh4:
+    case bfd_mach_st40_300_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh2a_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh4a_nofpu:
+      sh4_nofpu_show_regs (frame);
+      break;
+
+    case bfd_mach_sh5:
+      sh64_show_regs (frame);
+      break;
+
+    default:
+      sh_generic_show_regs (frame);
+      break;
+    }
 }
 
 static struct type *
 sh_sh2a_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
-       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
+  if ((reg_nr >= FR0_REGNUM && reg_nr <= FR_LAST_REGNUM)
+      || (reg_nr == FPUL_REGNUM))
     return builtin_type_float;
   else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
     return builtin_type_double;
+  else if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
   else
     return builtin_type_int;
 }
@@ -2044,9 +2175,12 @@ sh_sh2a_register_type (struct gdbarch *gdbarch, int reg_nr)
 static struct type *
 sh_sh3e_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
-       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
+  if ((reg_nr >= FR0_REGNUM && reg_nr <= FR_LAST_REGNUM)
+      || (reg_nr == FPUL_REGNUM))
     return builtin_type_float;
+  else if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
   else
     return builtin_type_int;
 }
@@ -2063,13 +2197,20 @@ sh_sh4_build_float_register_type (int high)
 static struct type *
 sh_sh4_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
-       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
+  if ((reg_nr >= FR0_REGNUM && reg_nr <= FR_LAST_REGNUM)
+      || (reg_nr >= XF0_REGNUM && reg_nr <= XF_LAST_REGNUM)
+      || (reg_nr >= FR0_BANK0_REGNUM && reg_nr <= FR_BANK0_LAST_REGNUM)
+      || (reg_nr >= FR0_BANK1_REGNUM && reg_nr <= FR_BANK1_LAST_REGNUM)
+      || (reg_nr == FPUL_REGNUM))
     return builtin_type_float;
-  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+  else if ((reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+	   || (reg_nr >= XD0_REGNUM && reg_nr <= XD_LAST_REGNUM))
     return builtin_type_double;
   else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
-    return sh_sh4_build_float_register_type (3);
+    return sh_sh4_build_float_register_type (FV_LAST_REGNUM - FV0_REGNUM);
+  else if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
   else
     return builtin_type_int;
 }
@@ -2077,7 +2218,11 @@ sh_sh4_register_type (struct gdbarch *gdbarch, int reg_nr)
 static struct type *
 sh_default_register_type (struct gdbarch *gdbarch, int reg_nr)
 {
-  return builtin_type_int;
+  if (reg_nr == gdbarch_pc_regnum (gdbarch)
+      || reg_nr == PR_REGNUM || reg_nr == SPC_REGNUM)
+    return builtin_type_void_func_ptr;
+  else
+    return builtin_type_int;
 }
 
 /* Is a register in a reggroup?
@@ -2092,9 +2237,7 @@ sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
       || *gdbarch_register_name (gdbarch, regnum) == '\0')
     return 0;
 
-  if (reggroup == float_reggroup
-      && (regnum == FPUL_REGNUM
-	  || regnum == FPSCR_REGNUM))
+  if (reggroup == float_reggroup && regnum == FPSCR_REGNUM)
     return 1;
 
   if (regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM)
@@ -2106,8 +2249,10 @@ sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
     }
 
   if (regnum == VBR_REGNUM
+      || regnum == DBR_REGNUM
       || regnum == SR_REGNUM
       || regnum == FPSCR_REGNUM
+      || regnum == SGR_REGNUM
       || regnum == SSR_REGNUM
       || regnum == SPC_REGNUM)
     {
@@ -2124,9 +2269,9 @@ sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
 /* On the sh4, the DRi pseudo registers are problematic if the target
    is little endian. When the user writes one of those registers, for
    instance with 'ser var $dr0=1', we want the double to be stored
-   like this: 
-   fr0 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f 
-   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
+   like this:
+   fr0 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f
+   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
 
    This corresponds to little endian byte order & big endian word
    order.  However if we let gdb write the register w/o conversion, it
@@ -2134,7 +2279,7 @@ sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
    fr0 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
    fr1 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f
    because it will consider fr0 and fr1 as a single LE stretch of memory.
-   
+
    To achieve what we want we must force gdb to store things in
    floatformat_ieee_double_littlebyte_bigword (which is defined in
    include/floatformat.h and libiberty/floatformat.c.
@@ -2142,7 +2287,7 @@ sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
    In case the target is big endian, there is no problem, the
    raw bytes will look like:
    fr0 = 0x3f 0xf0 0x00 0x00 0x00 0x00 0x00
-   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
+   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
 
    The other pseudo registers (the FVs) also don't pose a problem
    because they are stored as 4 individual FP elements. */
@@ -2151,7 +2296,8 @@ static void
 sh_register_convert_to_virtual (int regnum, struct type *type,
 				char *from, char *to)
 {
-  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+  if ((regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+      || (regnum >= XD0_REGNUM && regnum <= XD_LAST_REGNUM))
     {
       DOUBLEST val;
       floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
@@ -2167,7 +2313,8 @@ static void
 sh_register_convert_to_raw (struct type *type, int regnum,
 			    const void *from, void *to)
 {
-  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+  if ((regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
+      || (regnum >= XD0_REGNUM && regnum <= XD_LAST_REGNUM))
     {
       DOUBLEST val = extract_typed_floating (from, type);
       floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword,
@@ -2181,22 +2328,24 @@ sh_register_convert_to_raw (struct type *type, int regnum,
 static int
 fv_reg_base_num (struct gdbarch *gdbarch, int fv_regnum)
 {
-  int fp_regnum;
+  int fr_regnum;
 
-  fp_regnum = gdbarch_fp0_regnum (gdbarch)
-	      + (fv_regnum - FV0_REGNUM) * 4;
-  return fp_regnum;
+  fr_regnum = FR0_REGNUM + (fv_regnum - FV0_REGNUM) * 4;
+  return fr_regnum;
 }
 
 /* For double precision floating point registers, i.e 2 fp regs.*/
 static int
 dr_reg_base_num (struct gdbarch *gdbarch, int dr_regnum)
 {
-  int fp_regnum;
+  int fr_regnum;
 
-  fp_regnum = gdbarch_fp0_regnum (gdbarch)
-	      + (dr_regnum - DR0_REGNUM) * 2;
-  return fp_regnum;
+  if (dr_regnum >= DR0_REGNUM && dr_regnum <= DR_LAST_REGNUM)
+    fr_regnum = FR0_REGNUM + (dr_regnum - DR0_REGNUM) * 2;
+  else
+    fr_regnum = XF0_REGNUM + (dr_regnum - XD0_REGNUM) * 2;
+
+  return fr_regnum;
 }
 
 static void
@@ -2208,8 +2357,8 @@ sh_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
 
   if (reg_nr == PSEUDO_BANK_REGNUM)
     regcache_raw_read (regcache, BANK_REGNUM, buffer);
-  else
-  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+  else if ((reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+	   || (reg_nr >= XD0_REGNUM && reg_nr <= XD_LAST_REGNUM))
     {
       base_regnum = dr_reg_base_num (gdbarch, reg_nr);
 
@@ -2248,16 +2397,17 @@ sh_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
   if (reg_nr == PSEUDO_BANK_REGNUM)
     {
       /* When the bank register is written to, the whole register bank
-         is switched and all values in the bank registers must be read
+	 is switched and all values in the bank registers must be read
 	 from the target/sim again. We're just invalidating the regcache
 	 so that a re-read happens next time it's necessary.  */
       int bregnum;
 
       regcache_raw_write (regcache, BANK_REGNUM, buffer);
       for (bregnum = R0_BANK0_REGNUM; bregnum < MACLB_REGNUM; ++bregnum)
-        regcache_invalidate (regcache, bregnum);
+	regcache_invalidate (regcache, bregnum);
     }
-  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+  else if ((reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
+	   || (reg_nr >= XD0_REGNUM && reg_nr <= XD_LAST_REGNUM))
     {
       base_regnum = dr_reg_base_num (gdbarch, reg_nr);
 
@@ -2309,29 +2459,76 @@ sh_sh2a_register_sim_regno (struct gdbarch *gdbarch, int nr)
   switch (nr)
     {
       case TBR_REGNUM:
-        return SIM_SH_TBR_REGNUM;
+	return SIM_SH_TBR_REGNUM;
       case IBNR_REGNUM:
-        return SIM_SH_IBNR_REGNUM;
+	return SIM_SH_IBNR_REGNUM;
       case IBCR_REGNUM:
-        return SIM_SH_IBCR_REGNUM;
+	return SIM_SH_IBCR_REGNUM;
       case BANK_REGNUM:
-        return SIM_SH_BANK_REGNUM;
+	return SIM_SH_BANK_REGNUM;
       case MACLB_REGNUM:
-        return SIM_SH_BANK_MACL_REGNUM;
+	return SIM_SH_BANK_MACL_REGNUM;
       case GBRB_REGNUM:
-        return SIM_SH_BANK_GBR_REGNUM;
+	return SIM_SH_BANK_GBR_REGNUM;
       case PRB_REGNUM:
-        return SIM_SH_BANK_PR_REGNUM;
+	return SIM_SH_BANK_PR_REGNUM;
       case IVNB_REGNUM:
-        return SIM_SH_BANK_IVN_REGNUM;
+	return SIM_SH_BANK_IVN_REGNUM;
       case MACHB_REGNUM:
-        return SIM_SH_BANK_MACH_REGNUM;
+	return SIM_SH_BANK_MACH_REGNUM;
       default:
-        break;
+	break;
     }
   return legacy_register_sim_regno (gdbarch, nr);
 }
 
+static int
+sh_sh4_register_sim_regno (struct gdbarch *gdbarch, int nr)
+{
+  if (legacy_register_sim_regno (gdbarch, nr) < 0)
+    return legacy_register_sim_regno (gdbarch, nr);
+  if (nr >= XF0_REGNUM && nr <= XF_LAST_REGNUM)
+    return nr - XF0_REGNUM + SIM_SH_XF0_REGNUM;
+  if (nr == DBR_REGNUM)
+    return SIM_SH_DBR_REGNUM;
+  if (nr == SGR_REGNUM)
+    return SIM_SH_SGR_REGNUM;
+  if (nr >= FR0_BANK0_REGNUM && nr <= FR_BANK0_LAST_REGNUM)
+    {
+      ULONGEST val;
+      struct regcache *regcache = get_current_regcache ();
+
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return nr - FR0_BANK0_REGNUM + SIM_SH_XF0_REGNUM;
+      else
+	return nr - FR0_BANK0_REGNUM + SIM_SH_FR0_REGNUM;
+    }
+  if (nr >= FR0_BANK1_REGNUM && nr <= FR_BANK1_LAST_REGNUM)
+    {
+      ULONGEST val;
+      struct regcache *regcache = get_current_regcache ();
+
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return nr - FR0_BANK1_REGNUM + SIM_SH_FR0_REGNUM;
+      else
+	return nr - FR0_BANK1_REGNUM + SIM_SH_XF0_REGNUM;
+    }
+  if (nr >= SIM_SH4_NUM_REGS)
+    return LEGACY_SIM_REGNO_IGNORE;
+  return nr;
+}
+
+static int
+sh_dbg_reg_to_regnum (struct gdbarch *gdbarch, int nr)
+{
+  /* Fixup pseudo XD register numbers in debug information.  */
+  if ((nr >= 87) && (nr <= 94))
+    return (nr - 87) + XD0_REGNUM;
+  return nr;
+}
+
 /* Set up the register unwinding such that call-clobbered registers are
    not displayed in frames >0 because the true value is not certain.
    The 'undefined' registers will show up as 'not available' unless the
@@ -2341,7 +2538,7 @@ sh_sh2a_register_sim_regno (struct gdbarch *gdbarch, int nr)
 
 static void
 sh_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
-                          struct dwarf2_frame_state_reg *reg,
+			  struct dwarf2_frame_state_reg *reg,
 			  struct frame_info *next_frame)
 {
   /* Mark the PC as the destination for the return address.  */
@@ -2355,32 +2552,16 @@ sh_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
   /* The above was taken from the default init_reg in dwarf2-frame.c
      while the below is SH specific.  */
 
-  /* Caller save registers.  */
-  else if ((regnum >= R0_REGNUM && regnum <= R0_REGNUM+7)
-	   || (regnum >= FR0_REGNUM && regnum <= FR0_REGNUM+11)
-	   || (regnum >= DR0_REGNUM && regnum <= DR0_REGNUM+5)
-	   || (regnum >= FV0_REGNUM && regnum <= FV0_REGNUM+2)
-	   || (regnum == MACH_REGNUM)
-	   || (regnum == MACL_REGNUM)
-	   || (regnum == FPUL_REGNUM)
-	   || (regnum == SR_REGNUM))
-    reg->how = DWARF2_FRAME_REG_UNDEFINED;
-
   /* Callee save registers.  */
   else if ((regnum >= R0_REGNUM+8 && regnum <= R0_REGNUM+15)
 	   || (regnum >= FR0_REGNUM+12 && regnum <= FR0_REGNUM+15)
-	   || (regnum >= DR0_REGNUM+6 && regnum <= DR0_REGNUM+8)
-	   || (regnum == FV0_REGNUM+3))
+	   || (regnum >= DR0_REGNUM+6 && regnum <= DR0_REGNUM+7)
+	   || (regnum == FV0_REGNUM+3)
+	   || (regnum == PR_REGNUM))
     reg->how = DWARF2_FRAME_REG_SAME_VALUE;
 
-  /* Other registers.  These are not in the ABI and may or may not
-     mean anything in frames >0 so don't show them.  */
-  else if ((regnum >= R0_BANK0_REGNUM && regnum <= R0_BANK0_REGNUM+15)
-	   || (regnum == GBR_REGNUM)
-	   || (regnum == VBR_REGNUM)
-	   || (regnum == FPSCR_REGNUM)
-	   || (regnum == SSR_REGNUM)
-	   || (regnum == SPC_REGNUM))
+  /* Other, so assume undefined and don't show them.  */
+  else
     reg->how = DWARF2_FRAME_REG_UNDEFINED;
 }
 
@@ -2445,12 +2626,12 @@ sh_frame_cache (struct frame_info *next_frame, void **this_cache)
   if (!cache->uses_fp)
     {
       /* We didn't find a valid frame, which means that CACHE->base
-         currently holds the frame pointer for our calling frame.  If
-         we're at the start of a function, or somewhere half-way its
-         prologue, the function's frame probably hasn't been fully
-         setup yet.  Try to reconstruct the base address for the stack
-         frame by looking at the stack pointer.  For truly "frameless"
-         functions this might work too.  */
+	 currently holds the frame pointer for our calling frame.  If
+	 we're at the start of a function, or somewhere half-way its
+	 prologue, the function's frame probably hasn't been fully
+	 setup yet.  Try to reconstruct the base address for the stack
+	 frame by looking at the stack pointer.  For truly "frameless"
+	 functions this might work too.  */
       cache->base = frame_unwind_register_unsigned
 		    (next_frame,
 		     gdbarch_sp_regnum (get_frame_arch (next_frame)));
@@ -2523,12 +2704,18 @@ sh_frame_prev_register (struct frame_info *next_frame, void **this_cache,
     frame_unwind_register (next_frame, (*realnump), valuep);
 }
 
+static int backtrace_abi_sniffer = 1;
+
 static void
 sh_frame_this_id (struct frame_info *next_frame, void **this_cache,
 		  struct frame_id *this_id)
 {
   struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);
 
+  /* Is this sniffer enabled? */
+  if (!backtrace_abi_sniffer)
+    return;
+
   /* This marks the outermost frame.  */
   if (cache->base == 0)
     return;
@@ -2596,9 +2783,9 @@ sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
     {
       ULONGEST inst;
       /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
-         for a nop and some fixed data (e.g. big offsets) which are
-         unfortunately also treated as part of the function (which
-         means, they are below func_end. */
+	 for a nop and some fixed data (e.g. big offsets) which are
+	 unfortunately also treated as part of the function (which
+	 means, they are below func_end. */
       CORE_ADDR addr = func_end - 28;
       if (addr < func_addr + 4)
 	addr = func_addr + 4;
@@ -2613,8 +2800,8 @@ sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 	return 0;
 
       /* At this point we should find a mov.l @r15+,r14 instruction,
-         either before or after the rts.  If not, then the function has
-         probably no "normal" epilogue and we bail out here. */
+	 either before or after the rts.  If not, then the function has
+	 probably no "normal" epilogue and we bail out here. */
       inst = read_memory_unsigned_integer (addr - 2, 2);
       if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2)))
 	addr -= 2;
@@ -2645,7 +2832,7 @@ sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 	}
 
       /* Now check for FP adjustments, using add #imm,r14 or add rX, r14
-         instructions. */
+	 instructions. */
       while (addr > func_addr + 4
 	     && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
 	{
@@ -2654,10 +2841,10 @@ sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
 	}
 
       /* On SH2a check if the previous instruction was perhaps a MOVI20.
-         That's allowed for the epilogue.  */
+	 That's allowed for the epilogue.  */
       if ((gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a
-           || gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu)
-          && addr > func_addr + 6
+	   || gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu)
+	  && addr > func_addr + 6
 	  && IS_MOVI20 (read_memory_unsigned_integer (addr - 4, 2)))
 	addr -= 4;
 
@@ -2666,57 +2853,136 @@ sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
     }
   return 0;
 }
-
 
-static struct gdbarch *
-sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+/* Convert an integer into an address.  Extracting the value unsigned
+   prevents the 32 bit address getting sign-extended in 64 bit CORE_ADDR.  */
+static CORE_ADDR
+sh_integer_to_address (struct gdbarch *gdbarch,
+		       struct type *type, const gdb_byte *buf)
 {
-  struct gdbarch *gdbarch;
+  return (CORE_ADDR) extract_unsigned_integer (buf, TYPE_LENGTH (type));
+}
 
-  sh_show_regs = sh_generic_show_regs;
-  switch (info.bfd_arch_info->mach)
+void
+shtdi_init_simulator_hook ()
+{
+  const char *envname = "SUPERH_SIM_PROFILE";
+  char *superh_sim_profile = getenv (envname);
+  if (!superh_sim_profile)
     {
-    case bfd_mach_sh2e:
-      sh_show_regs = sh2e_show_regs;
-      break;
-    case bfd_mach_sh2a:
-      sh_show_regs = sh2a_show_regs;
-      break;
-    case bfd_mach_sh2a_nofpu:
-      sh_show_regs = sh2a_nofpu_show_regs;
-      break;
-    case bfd_mach_sh_dsp:
-      sh_show_regs = sh_dsp_show_regs;
-      break;
+      xasprintf (&superh_sim_profile, "%s=%s", envname,
+		 get_exec_file (0));
+      putenv (superh_sim_profile);
+    }
+}
 
-    case bfd_mach_sh3:
-      sh_show_regs = sh3_show_regs;
-      break;
+/*
+ * SHTDI register layout:
+ *
+ *   R0B0, ..., R7B0
+ *   R0B1, ..., R7B1
+ *   R8, ..., R15
+ *   SR, PC, PR, DBR, GBR, VBR, MACH, MACL, SGR, SSR, SPC
+ *   FR0B0, ..., FR15B0
+ *   FR0B1, ..., FR15B1
+ *   FPSCR, FPUL
+ *
+ * GDB register layout:
+ *
+ *   R0, ..., R15
+ *   PC, PR, GBR, VBR, MACH, MACL, SR, FPUL, FPSCR
+ *   FR0, ..., FR15
+ *   SSR, SPC
+ *   R0B0, ..., R7B0
+ *   R0B1, ..., R7B1
+ *   DBR, SGR
+ *   XF0, ..., XF15
+ *   FR0B0, ..., FR15B0
+ *   FR0B1, ..., FR15B1
+ */
+static int
+sh4_gdb_to_shtdi_regno (struct regcache *regcache, int regno)
+{
+  static const int register_map[SH_NUM_REGS] = {
+    -1, -1, -1, -1, -1, -1, -1, -1, 16, 17, 18, 19, 20, 21, 22, 23,
+    25, 26, 28, 29, 30, 31, 24, 68, 67,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    33, 34,
+     0,  1,  2,  3,  4,  5,  6,  7,
+     8,  9, 10, 11, 12, 13, 14, 15,
+    27, 32,
+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
+    35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
+    51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66
+  };
 
-    case bfd_mach_sh3e:
-      sh_show_regs = sh3e_show_regs;
-      break;
+  if ((regno >= R0_REGNUM) && (regno < (R0_REGNUM + 8)))
+    {
+      ULONGEST val;
 
-    case bfd_mach_sh3_dsp:
-    case bfd_mach_sh4al_dsp:
-      sh_show_regs = sh3_dsp_show_regs;
-      break;
+      regcache_cooked_read_unsigned (regcache, SR_REGNUM, &val);
+      if (val & SR_RB)
+	return (regno - R0_REGNUM) + 8; /* bank 1 */
+      else
+	return (regno - R0_REGNUM) + 0; /* bank 0 */
+    }
+  else if ((regno >= FR0_REGNUM) && (regno < (FR0_REGNUM + 16)))
+    {
+      ULONGEST val;
+
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return (regno - FR0_REGNUM) + 51; /* bank 1 */
+      else
+	return (regno - FR0_REGNUM) + 35; /* bank 0 */
+    }
+  else if ((regno >= XF0_REGNUM) && (regno < (XF0_REGNUM + 16)))
+    {
+      ULONGEST val;
 
+      regcache_cooked_read_unsigned (regcache, FPSCR_REGNUM, &val);
+      if (val & FPSCR_FR)
+	return (regno - XF0_REGNUM) + 35; /* bank 0 */
+      else
+	return (regno - XF0_REGNUM) + 51; /* bank 1 */
+    }
+  else if ((regno >= 0) && (regno < SH_NUM_REGS))
+    return register_map[regno];
+  else
+    return -1; /* invalid */
+}
+
+int
+sh_gdb_to_shtdi_regno (struct regcache *regcache, int regno)
+{
+  switch (gdbarch_bfd_arch_info (get_regcache_arch (regcache))->mach)
+    {
     case bfd_mach_sh4:
     case bfd_mach_sh4a:
-      sh_show_regs = sh4_show_regs;
-      break;
-
+    case bfd_mach_st40_300:
+    case bfd_mach_st40_300_or_sh4a:
     case bfd_mach_sh4_nofpu:
     case bfd_mach_sh4a_nofpu:
-      sh_show_regs = sh4_nofpu_show_regs;
+    case bfd_mach_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
+    case bfd_mach_sh2a_or_sh4:
+    case bfd_mach_st40_300_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh2a_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh4a_nofpu:
+      return sh4_gdb_to_shtdi_regno (regcache, regno);
       break;
-
-    case bfd_mach_sh5:
-      sh_show_regs = sh64_show_regs;
-      /* SH5 is handled entirely in sh64-tdep.c */
-      return sh64_gdbarch_init (info, arches);
     }
+  return regno;
+}
+
+static struct gdbarch *
+sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+
+  if (info.bfd_arch_info->mach == bfd_mach_sh5)
+    /* SH5 is handled entirely in sh64-tdep.c */
+    return sh64_gdbarch_init (info, arches);
 
   /* If there is already a candidate, use it.  */
   arches = gdbarch_list_lookup_by_info (arches, &info);
@@ -2736,6 +3002,8 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
   set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
 
+  set_gdbarch_integer_to_address (gdbarch, sh_integer_to_address);
+
   set_gdbarch_num_regs (gdbarch, SH_NUM_REGS);
   set_gdbarch_sp_regnum (gdbarch, 15);
   set_gdbarch_pc_regnum (gdbarch, 16);
@@ -2750,6 +3018,10 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh);
   set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);
 
+  set_gdbarch_dwarf_reg_to_regnum (gdbarch, sh_dbg_reg_to_regnum);
+  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, sh_dbg_reg_to_regnum);
+  set_gdbarch_stab_reg_to_regnum (gdbarch, sh_dbg_reg_to_regnum);
+
   set_gdbarch_return_value (gdbarch, sh_return_value_nofpu);
 
   set_gdbarch_skip_prologue (gdbarch, sh_skip_prologue);
@@ -2785,7 +3057,7 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
 
       set_gdbarch_register_name (gdbarch, sh_sh2e_register_name);
       set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
-      set_gdbarch_fp0_regnum (gdbarch, 25);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
       set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
       set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
       break;
@@ -2795,7 +3067,7 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
       set_gdbarch_register_type (gdbarch, sh_sh2a_register_type);
       set_gdbarch_register_sim_regno (gdbarch, sh_sh2a_register_sim_regno);
 
-      set_gdbarch_fp0_regnum (gdbarch, 25);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
       set_gdbarch_num_pseudo_regs (gdbarch, 9);
       set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
       set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
@@ -2830,7 +3102,7 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
 
       set_gdbarch_register_name (gdbarch, sh_sh3e_register_name);
       set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
-      set_gdbarch_fp0_regnum (gdbarch, 25);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
       set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
       set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
       break;
@@ -2842,10 +3114,13 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
 
     case bfd_mach_sh4:
     case bfd_mach_sh4a:
+    case bfd_mach_st40_300:
+    case bfd_mach_st40_300_or_sh4a:
       set_gdbarch_register_name (gdbarch, sh_sh4_register_name);
       set_gdbarch_register_type (gdbarch, sh_sh4_register_type);
-      set_gdbarch_fp0_regnum (gdbarch, 25);
-      set_gdbarch_num_pseudo_regs (gdbarch, 13);
+      set_gdbarch_register_sim_regno (gdbarch, sh_sh4_register_sim_regno);
+      set_gdbarch_fp0_regnum (gdbarch, FR0_REGNUM);
+      set_gdbarch_num_pseudo_regs (gdbarch, 21);
       set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
       set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
       set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
@@ -2857,7 +3132,11 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
     case bfd_mach_sh4_nommu_nofpu:
     case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
     case bfd_mach_sh2a_or_sh4:
+    case bfd_mach_st40_300_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh2a_nofpu:
+    case bfd_mach_st40_300_nofpu_or_sh4a_nofpu:
       set_gdbarch_register_name (gdbarch, sh_sh4_nofpu_register_name);
+      set_gdbarch_register_sim_regno (gdbarch, sh_sh4_register_sim_regno);
       break;
 
     case bfd_mach_sh4al_dsp:
@@ -2876,6 +3155,22 @@ sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
   frame_unwind_append_sniffer (gdbarch, sh_frame_sniffer);
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+  set_solib_svr4_fetch_link_map_offsets (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+#endif
+
+  add_setshow_boolean_cmd ("abi-sniffer", class_obscure,
+			   &backtrace_abi_sniffer, "\
+Set whether backtraces should use the ABI where there is no debug info.", "\
+Show whether backtraces should use the ABI where there is no debug info.", "\
+Normally there is debug information from which to construct a backtrace\n\
+but sometimes is is not available (e.g. in assembly code). In this case the\n\
+ABI sniffer can attempt to construct a backtrace. It is disabled by default\n\
+because it can cause inconvenient errors. Note that it does not disable the\n\
+Dwarf debug information sniffer.",
+			   NULL, NULL, &set_backtrace_cmdlist,
+			   &show_backtrace_cmdlist);
+
   return gdbarch;
 }
 
diff --git a/gdb/sh-tdep.h b/gdb/sh-tdep.h
index 7ea452e..142fe2e 100644
--- a/gdb/sh-tdep.h
+++ b/gdb/sh-tdep.h
@@ -22,7 +22,21 @@
 
 /* Contributed by Steve Chamberlain sac@cygnus.com */
 
-/* Registers for all SH variants.  Used also by sh3-rom.c. */
+/* Registers for all SH variants.
+
+   For reference, GCC register allocation (as of GCC 4.2.1):
+     0 to 15  = R0 to R15
+     16       = PC (linux only)
+     17       = PR
+     18       = GBR (previously 19)
+     20       = MACH
+     21       = MACL
+     22       = SR (linux only)
+     22       = SR.T (previously 18)
+     23       = FPUL
+     24       = FPSCR
+     25 to 40 = FR0 to FR15
+     87 to 94 = XD0 to XD7  */
 enum
   {
     R0_REGNUM = 0,
@@ -36,16 +50,29 @@ enum
     MACH_REGNUM = 20,
     MACL_REGNUM = 21,
     SR_REGNUM = 22,
-    FPUL_REGNUM = 23,
     /* Floating point registers */
+    FPUL_REGNUM = 23,
     FPSCR_REGNUM = 24,
     FR0_REGNUM = 25,
     FLOAT_ARG0_REGNUM = 29,
     FLOAT_ARGLAST_REGNUM = 36,
-    FP_LAST_REGNUM = 40,
+    FR_LAST_REGNUM = 40,
     /* sh3,sh4 registers */
     SSR_REGNUM = 41,
     SPC_REGNUM = 42,
+    /*
+    R0_BANK0_REGNUM = 43,
+    R0_BANK1_REGNUM = 51,
+    */
+    /* sh4 registers */
+    DBR_REGNUM = 59,
+    SGR_REGNUM = 60,
+    XF0_REGNUM = 61,
+    XF_LAST_REGNUM = 76,
+    FR0_BANK0_REGNUM = 77,
+    FR_BANK0_LAST_REGNUM = 92,
+    FR0_BANK1_REGNUM = 93,
+    FR_BANK1_LAST_REGNUM = 108,
     /* DSP registers */
     DSR_REGNUM = 24,
     A0G_REGNUM = 25,
@@ -74,12 +101,14 @@ enum
     IBCR_REGNUM = 64,
     IBNR_REGNUM = 65,
     TBR_REGNUM = 66,
-    PSEUDO_BANK_REGNUM = 67,
+    PSEUDO_BANK_REGNUM = 109,
     /* Floating point pseudo registers */
-    DR0_REGNUM = 68,
-    DR_LAST_REGNUM = 75,
-    FV0_REGNUM = 76,
-    FV_LAST_REGNUM = 79
+    DR0_REGNUM = 110,
+    DR_LAST_REGNUM = 117,
+    XD0_REGNUM = 118,
+    XD_LAST_REGNUM = 125,
+    FV0_REGNUM = 126,
+    FV_LAST_REGNUM = 129
   };
 
 extern gdbarch_init_ftype sh64_gdbarch_init;
diff --git a/gdb/solib-svr4.c b/gdb/solib-svr4.c
index d71f177..768bd74 100644
--- a/gdb/solib-svr4.c
+++ b/gdb/solib-svr4.c
@@ -1,7 +1,11 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
 /* Handle SVR4 shared libraries for GDB, the GNU Debugger.
 
    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,
    2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -370,9 +374,25 @@ scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)
      from memory later.  */
   sect_size = bfd_section_size (abfd, sect);
   buf = bufstart = alloca (sect_size);
+
+#ifdef TARGET_ST200
+  if (dyntag == DT_DEBUG)
+    {
+      if (target_read_memory (dyn_addr, buf, sect_size))
+        return 0;
+    } 
+  else 
+    {
+      if (!bfd_get_section_contents (abfd, sect,
+				 buf, 0, sect_size))
+        return 0;
+    }
+#else
   if (!bfd_get_section_contents (abfd, sect,
 				 buf, 0, sect_size))
     return 0;
+#endif
+
 
   /* Iterate over BUF and scan for DYNTAG.  If found, set PTR and return.  */
   step = (arch_size == 32) ? sizeof (Elf32_External_Dyn)
@@ -403,7 +423,13 @@ scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)
 	   {
 	     gdb_byte ptr_buf[8];
 	     CORE_ADDR ptr_addr;
-
+#ifdef TARGET_ST200
+         if (dyntag == DT_DEBUG)
+           {
+             *ptr = dyn_ptr;
+             return 1;
+           }   
+#endif
 	     ptr_addr = dyn_addr + (buf - bufstart) + arch_size / 8;
 	     if (target_read_memory (ptr_addr, ptr_buf, arch_size / 8) == 0)
 	       dyn_ptr = extract_typed_address (ptr_buf,
@@ -466,13 +492,13 @@ elf_locate_base (void)
   /* Find DT_DEBUG.  */
   if (scan_dyntag (DT_DEBUG, exec_bfd, &dyn_ptr))
     return dyn_ptr;
-
+#ifndef TARGET_ST200
   /* This may be a static executable.  Look for the symbol
      conventionally named _r_debug, as a last resort.  */
   msymbol = lookup_minimal_symbol ("_r_debug", NULL, symfile_objfile);
   if (msymbol != NULL)
     return SYMBOL_VALUE_ADDRESS (msymbol);
-
+#endif
   /* DT_DEBUG entry not found.  */
   return 0;
 }
@@ -977,6 +1003,10 @@ enable_break (void)
   asection *interp_sect;
   CORE_ADDR sym_addr;
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+  asection *dyn_sect;
+#endif
+
   /* First, remove all the solib event breakpoints.  Their addresses
      may have changed since the last time we ran the program.  */
   remove_solib_event_breakpoints ();
@@ -1061,6 +1091,13 @@ enable_break (void)
       bfd_get_section_contents (exec_bfd, interp_sect,
 				buf, 0, interp_sect_size);
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+      /* [CL] in the case of the relocatable library, the .interp
+         section is "RL_LIB", so that we know that we must revert to the
+         "bkpt_at_symbol mechanism, without emitting a warning */
+      if (strcmp (buf, "RL_LIB") == 0) goto rlib_check_dyn;
+#endif
+
       /* Now we need to figure out where the dynamic linker was
          loaded so that we can load its symbols and place a breakpoint
          in the dynamic linker itself.
@@ -1184,6 +1221,18 @@ enable_break (void)
                "and track explicitly loaded dynamic code."));
     }
 
+#ifdef TARGET_HAS_RELOCATABLE_LIB
+ rlib_check_dyn:
+  /* Find the .dynamic section; if not found, it means this is
+     a static executable, so don't bother anymore.
+     Otherwise, we end up setting multiple breakpoints in _start
+     which makes execution stall */
+  dyn_sect = bfd_get_section_by_name (exec_bfd, ".dynamic");
+  if (!dyn_sect) { 
+    return 1;
+  }
+#endif
+
   /* Scan through the lists of symbols, trying to look up the symbol and
      set a breakpoint there.  Terminate loop when we/if we succeed.  */
 
diff --git a/gdb/solib.c b/gdb/solib.c
index 69680b4..4da520f 100644
--- a/gdb/solib.c
+++ b/gdb/solib.c
@@ -87,6 +87,8 @@ struct target_so_ops *current_target_so_ops;
 
 static struct so_list *so_list_head;	/* List of known shared objects */
 
+static int solib_enabled = 1;		/* Shared libraries enabled ? */
+
 /* Local function prototypes */
 
 /* If non-empty, this is a search path for loading non-absolute shared library
@@ -674,7 +676,8 @@ solib_add (char *pattern, int from_tty, struct target_ops *target, int readsyms)
 	error (_("Invalid regexp: %s"), re_err);
     }
 
-  update_solib_list (from_tty, target);
+  if (solib_enabled)
+    update_solib_list (from_tty, target);
 
   /* Walk the list of currently loaded shared libraries, and read
      symbols for any that match the pattern --- or any whose symbols
@@ -743,7 +746,8 @@ info_sharedlibrary_command (char *ignore, int from_tty)
   /* "0x", a little whitespace, and two hex digits per byte of pointers.  */
   addr_width = 4 + (gdbarch_ptr_bit (current_gdbarch) / 4);
 
-  update_solib_list (from_tty, 0);
+  if (solib_enabled)
+    update_solib_list (from_tty, 0);
 
   for (so = so_list_head; so; so = so->next)
     {
@@ -775,7 +779,14 @@ info_sharedlibrary_command (char *ignore, int from_tty)
     }
   if (so_list_head == NULL)
     {
-      printf_unfiltered (_("No shared libraries loaded at this time.\n"));
+      if (solib_enabled)
+	{
+	  printf_unfiltered (_("No shared libraries loaded at this time.\n"));
+	}
+      else
+	{
+	  printf_unfiltered (_("Shared library support is disabled.\n"));
+	}
     }
 }
 
@@ -881,7 +892,8 @@ void
 solib_create_inferior_hook (void)
 {
   struct target_so_ops *ops = solib_ops (current_gdbarch);
-  ops->solib_create_inferior_hook();
+  if (solib_enabled)
+    ops->solib_create_inferior_hook();
 }
 
 /* GLOBAL FUNCTION
@@ -963,6 +975,39 @@ show_auto_solib_add (struct ui_file *file, int from_tty,
 		    value);
 }
 
+/* LOCAL FUNCTION
+
+   disable_shared_libraries -- handle command to disable shared library
+   support.
+
+   DESCRIPTION
+
+   Implements the command "disable sharedlibrary".  */
+
+static void
+disable_shared_libraries (char *ignored, int from_tty)
+{
+  solib_enabled = 0;
+  remove_solib_event_breakpoints ();
+  no_shared_libraries (NULL, from_tty);
+}
+
+/* LOCAL FUNCTION
+
+   enable_shared_libraries -- handle command to enable shared library
+   support.
+
+   DESCRIPTION
+
+   Implements the command "enable sharedlibrary".  */
+
+static void
+enable_shared_libraries (char *ignored, int from_tty)
+{
+  solib_enabled = 1;
+  solib_create_inferior_hook ();
+  solib_add (NULL, from_tty, NULL, auto_solib_add);
+}
 
 /* Handler for library-specific lookup of global symbol NAME in OBJFILE.  Call
    the library-specific handler if it is installed for the current target.  */
@@ -1035,4 +1080,12 @@ This takes precedence over the environment variables PATH and LD_LIBRARY_PATH.")
 				     reload_shared_libraries,
 				     show_solib_search_path,
 				     &setlist, &showlist);
+
+  add_cmd ("sharedlibrary", class_support, disable_shared_libraries, _("\
+Disable shared library support."),
+	   &disablelist);
+
+  add_cmd ("sharedlibrary", class_support, enable_shared_libraries, _("\
+Enable shared library support."),
+	   &enablelist);
 }
diff --git a/gdb/source.c b/gdb/source.c
index 4ed4ec0..72ed1cb 100644
--- a/gdb/source.c
+++ b/gdb/source.c
@@ -2,6 +2,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2007 STMicroelectronics
 
    This file is part of GDB.
 
diff --git a/gdb/st200-linux-nat.c b/gdb/st200-linux-nat.c
new file mode 100644
index 0000000..919fc49
--- /dev/null
+++ b/gdb/st200-linux-nat.c
@@ -0,0 +1,239 @@
+/* GNU/Linux on ARM native support.
+   Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "defs.h"
+#include "inferior.h"
+#include "gdbcore.h"
+#include "gdb_string.h"
+#include "regcache.h"
+#include "target.h"
+#include "linux-nat.h"
+#include "target-descriptions.h"
+#include "xml-support.h"
+
+
+#include <sys/user.h>
+#include <sys/ptrace.h>
+#include <sys/utsname.h>
+#include <sys/procfs.h>
+
+#include <asm/ptrace.h>
+
+/* Prototypes for supply_gregset etc. */
+#include "gregset.h"
+
+/* Defines ps_err_e, struct ps_prochandle.  */
+#include "gdb_proc_service.h"
+
+#undef NUM_REGS
+#define NUM_REGS 74
+
+
+/* The following variables are used to determine the version of the
+   underlying GNU/Linux operating system.  Examples:
+
+   GNU/Linux 2.0.35             GNU/Linux 2.2.12
+   os_version = 0x00020023      os_version = 0x0002020c
+   os_major = 2                 os_major = 2
+   os_minor = 0                 os_minor = 2
+   os_release = 35              os_release = 12
+
+   Note: os_version = (os_major << 16) | (os_minor << 8) | os_release
+
+   These are initialized using get_linux_version() from
+   _initialize_arm_linux_nat().  */
+
+static unsigned int os_version, os_major, os_minor, os_release;
+
+
+/* On GNU/Linux, threads are implemented as pseudo-processes, in which
+   case we may be tracing more than one process at a time.  In that
+   case, inferior_ptid will contain the main process ID and the
+   individual thread (process) ID.  get_thread_id () is used to get
+   the thread id if it's available, and the process id otherwise.  */
+
+static int get_thread_id (ptid_t ptid)
+{
+  int tid = TIDGET (ptid);
+  if (0 == tid)
+    tid = PIDGET (ptid);
+  return tid;
+}
+#define GET_THREAD_ID(PTID)     get_thread_id (PTID)
+
+
+/* Fetch a general register of the process and store into
+   regcache.  */
+
+static void lx_linux_fetch_inferior_registers(struct regcache *regcache, int regno)
+{
+  int ret, tid;
+  elf_gregset_t regs;
+  unsigned long *regp = (unsigned long *) &regs;
+  int i;
+
+  /* Get the thread id for the ptrace call.  */
+  tid = GET_THREAD_ID (inferior_ptid);
+
+  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
+  if (ret < 0)
+    {
+      warning (_("Unable to fetch general register."));
+      return;
+    }
+
+  if(regno >= 0 && regno < NUM_REGS) {
+	  regcache_raw_supply(regcache, regno, regp + regno);
+  } else  {
+	  if(regno == -1) {
+		  for(i = 0; i < NUM_REGS; i++) {
+			 regcache_raw_supply(regcache, i, regp + i);
+		  }
+	  }
+  }
+
+}
+
+
+/* Store all general registers of the process from the values in
+   regcache.  */
+
+static void lx_linux_store_inferior_registers(const struct regcache *regcache, int regno)
+{
+  int ret, tid, i;
+  elf_gregset_t regs;
+  unsigned long *regp = (unsigned long *) &regs;
+
+
+#if 0
+  if (!regcache_valid_p (regcache, regno))
+    return;
+#endif
+
+  /* Get the thread id for the ptrace call.  */
+  tid = GET_THREAD_ID (inferior_ptid);
+
+  /* Get the general registers from the process.  */
+  ret = ptrace (PTRACE_GETREGS, tid, 0, &regs);
+  if (ret < 0)
+    {
+      warning (_("Unable to fetch general registers."));
+      return;
+    }
+
+  if(regno >= 0 && regno < NUM_REGS) {
+	  regcache_raw_collect(regcache, regno, regp + regno);
+  } else if(regno == -1) {
+		  for(i = 0; i< NUM_REGS; i++) {
+			  regcache_raw_collect(regcache, i, regp + i);
+		  }
+  }
+
+  ret = ptrace (PTRACE_SETREGS, tid, 0, &regs);
+  if (ret < 0)
+    {
+      warning (_("Unable to store general register."));
+      return;
+    }
+}
+
+/* Wrapper functions for the standard regset handling, used by
+   thread debugging.  */
+
+void
+fill_gregset (const struct regcache *regcache,
+	      gdb_gregset_t *gregsetp, int regno)
+{
+	int i;
+	unsigned long *regp = (unsigned long *) gregsetp;
+
+	if(regno >=0 && regno <= NUM_REGS) {
+		regcache_raw_collect(regcache, regno, regp + regno);
+	} else if(regno == -1) {
+		for(i = 0; i < NUM_REGS; i++) {
+			regcache_raw_collect(regcache, i, regp + i);
+		}
+	}
+}
+
+void
+supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)
+{
+	int i;
+	unsigned long *regp = (unsigned long *) gregsetp;
+
+	for(i = 0; i < NUM_REGS; i++) {
+		regcache_raw_supply(regcache, i, regp + i);
+	}
+}
+
+/* Nothing to do here as no floating point registers on ST200 */
+void
+fill_fpregset (const struct regcache *regcache,
+	       gdb_fpregset_t *fpregsetp, int regno)
+{
+}
+
+void
+supply_fpregset (struct regcache *regcache, const gdb_fpregset_t *fpregsetp)
+{
+}
+
+static unsigned int
+get_linux_version (unsigned int *vmajor,
+		   unsigned int *vminor,
+		   unsigned int *vrelease)
+{
+  struct utsname info;
+  char *pmajor, *pminor, *prelease, *tail;
+
+  if (-1 == uname (&info))
+    {
+      warning (_("Unable to determine GNU/Linux version."));
+      return -1;
+    }
+
+  pmajor = strtok (info.release, ".");
+  pminor = strtok (NULL, ".");
+  prelease = strtok (NULL, ".");
+
+  *vmajor = (unsigned int) strtoul (pmajor, &tail, 0);
+  *vminor = (unsigned int) strtoul (pminor, &tail, 0);
+  *vrelease = (unsigned int) strtoul (prelease, &tail, 0);
+
+  return ((*vmajor << 16) | (*vminor << 8) | *vrelease);
+}
+void
+
+_initialize_arm_linux_nat (void)
+{
+  struct target_ops *t;
+
+  os_version = get_linux_version (&os_major, &os_minor, &os_release);
+
+  /* Fill in the generic GNU/Linux methods.  */
+  t = linux_target ();
+
+  /* Add our register access methods.  */
+  t->to_fetch_registers = lx_linux_fetch_inferior_registers;
+  t->to_store_registers = lx_linux_store_inferior_registers;
+
+  /* Register the target.  */
+  linux_nat_add_target (t);
+}
diff --git a/gdb/stack.c b/gdb/stack.c
index 374848b..66e0a6a 100644
--- a/gdb/stack.c
+++ b/gdb/stack.c
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -75,6 +76,13 @@ static void print_frame (struct frame_info *frame, int print_level,
 int annotation_level = 0;
 
 
+int print_frame_id = 0;
+static void
+show_print_frame_id (struct ui_file *file, int from_tty,
+		    struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("Display of the frame id when stepping is %s.\n"), value);
+}
 struct print_stack_frame_args
 {
   struct frame_info *frame;
@@ -732,12 +740,35 @@ print_frame (struct frame_info *frame, int print_level,
 	}
     }
 
-  /* do_cleanups will call ui_out_tuple_end() for us.  */
-  do_cleanups (list_chain);
-  ui_out_text (uiout, "\n");
-  do_cleanups (old_chain);
-}
-
+
+  /* Print a string that represents the frame_id. This could be used by the UI
+     for comparison with the previous frame_id.
+     This is printed only on MI output for step stop reason and when the 
+     "set print frame-id" command is on.  */
+  if (print_frame_id && ui_out_is_mi_like_p (uiout) && stop_step)
+    {
+      struct frame_id this_frame_id;
+      struct cleanup *frame_id_list_chain;
+
+      frame_id_list_chain = make_cleanup_ui_out_tuple_begin_end (uiout, "id");
+      this_frame_id= get_frame_id (frame);
+
+      ui_out_field_string (uiout, "stack", this_frame_id.stack_addr_p ? 
+        paddr (this_frame_id.stack_addr) : "false");
+      ui_out_field_string (uiout, "code", this_frame_id.code_addr_p ? 
+        paddr (this_frame_id.code_addr) : "false");
+      ui_out_field_string (uiout, "special", this_frame_id.special_addr_p ? 
+        paddr (this_frame_id.special_addr) : "false");
+
+      do_cleanups (frame_id_list_chain);
+    }
+    /* do_cleanups will call ui_out_tuple_end() for us.  */
+    do_cleanups (list_chain);
+    ui_out_text (uiout, "\n");
+    do_cleanups (old_chain);
+} 
+
+
 /* Show the frame info.  If this is the tui, it will be shown in the
    source display otherwise, nothing is done.  */
 
@@ -2097,4 +2128,15 @@ Usage: func <name>\n"));
   add_info ("backtrace-limit", backtrace_limit_info, _("\
 The maximum number of frames for \"backtrace\" to print by default."));
 #endif
+
+  add_setshow_boolean_cmd ("frame-id", class_stack, &print_frame_id, _("\
+Set the frame id MI printing mode."), _("\
+Show the frame id MI printing mode."), _("\
+Set the printing of the frame ID into the MI output.\n\
+The frame id is printed only if stop reason is end-stepping-range."),
+			   NULL,
+			   show_print_frame_id,
+			   &setprintlist, &showprintlist);
+
+
 }
diff --git a/gdb/symfile.c b/gdb/symfile.c
index 5e554fe..e104283 100644
--- a/gdb/symfile.c
+++ b/gdb/symfile.c
@@ -1787,6 +1787,7 @@ add_section_size_callback (bfd *abfd, asection *asec, void *data)
 struct load_section_data {
   unsigned long load_offset;
   struct load_progress_data *progress_data;
+  int use_vma;
   VEC(memory_write_request_s) *requests;
 };
 
@@ -1807,6 +1808,7 @@ struct load_progress_section_data {
   ULONGEST section_sent;
   ULONGEST section_size;
   CORE_ADDR lma;
+  int use_vma;
   gdb_byte *buffer;
 };
 
@@ -1829,8 +1831,9 @@ load_progress (ULONGEST bytes, void *untyped_arg)
     {
       /* The write is just starting.  Let the user know we've started
 	 this section.  */
-      ui_out_message (uiout, 0, "Loading section %s, size 0x%s lma 0x%s\n",
+      ui_out_message (uiout, 0, "Loading section %s, size 0x%s %s 0x%s\n",
 		      args->section_name, paddr_nz (args->section_size),
+		      args->use_vma ? "vma" : "lma",
 		      paddr_nz (args->lma));
       return;
     }
@@ -1896,7 +1899,8 @@ load_section_callback (bfd *abfd, asection *asec, void *data)
 			       args->requests, NULL);
   memset (new_request, 0, sizeof (struct memory_write_request));
   section_data = xcalloc (1, sizeof (struct load_progress_section_data));
-  new_request->begin = bfd_section_lma (abfd, asec) + args->load_offset;
+  new_request->begin = (args->use_vma ? bfd_section_vma (abfd, asec)
+			   : bfd_section_lma (abfd, asec)) + args->load_offset;
   new_request->end = new_request->begin + size; /* FIXME Should size be in instead?  */
   new_request->data = xmalloc (size);
   new_request->baton = section_data;
@@ -1907,6 +1911,7 @@ load_section_callback (bfd *abfd, asection *asec, void *data)
   section_data->section_name = sect_name;
   section_data->section_size = size;
   section_data->lma = new_request->begin;
+  section_data->use_vma = args->use_vma;
   section_data->buffer = buffer;
 
   bfd_get_section_contents (abfd, asec, buffer, 0, size);
@@ -1943,6 +1948,7 @@ generic_load (char *args, int from_tty)
 
   CORE_ADDR entry;
   char **argv;
+  int i = 1;
 
   memset (&cbdata, 0, sizeof (cbdata));
   memset (&total_progress, 0, sizeof (total_progress));
@@ -1960,18 +1966,32 @@ generic_load (char *args, int from_tty)
   filename = tilde_expand (argv[0]);
   make_cleanup (xfree, filename);
 
-  if (argv[1] != NULL)
+  if (argv[i] != NULL)
+    {
+      if (strcasecmp (argv[i], "vma") == 0)
+	{
+	  i++;
+	  cbdata.use_vma = 1;
+	}
+      else if (strcasecmp (argv[i], "lma") == 0)
+	{
+	  i++;
+	  cbdata.use_vma = 0;
+	}
+    }
+
+  if (argv[i] != NULL)
     {
       char *endptr;
 
-      cbdata.load_offset = strtoul (argv[1], &endptr, 0);
+      cbdata.load_offset = strtoul (argv[i], &endptr, 0);
 
       /* If the last word was not a valid number then
          treat it as a file name with spaces in.  */
-      if (argv[1] == endptr)
-        error (_("Invalid download offset:%s."), argv[1]);
+      if (argv[i] == endptr)
+        error (_("Invalid download offset:%s."), argv[i]);
 
-      if (argv[2] != NULL)
+      if (argv[i+1] != NULL)
 	error (_("Too many parameters."));
     }
 
diff --git a/gdb/target.c b/gdb/target.c
index 87ddf24..b0e0577 100644
--- a/gdb/target.c
+++ b/gdb/target.c
@@ -3,6 +3,7 @@
    Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2008 STMicroelectronics 
 
    Contributed by Cygnus Support.
 
@@ -42,6 +43,8 @@
 
 static void target_info (char *, int);
 
+static void update_current_target (void);
+
 static void maybe_kill_then_attach (char *, int);
 
 static void kill_or_be_killed (int);
@@ -206,6 +209,13 @@ static int trust_readonly = 0;
 /* Non-zero if we want to see trace of target level stuff.  */
 
 static int targetdebug = 0;
+
+static void
+set_targetdebug (char *args, int from_tty, struct cmd_list_element *c)
+{
+  update_current_target ();
+}
+
 static void
 show_targetdebug (struct ui_file *file, int from_tty,
 		  struct cmd_list_element *c, const char *value)
@@ -2783,7 +2793,7 @@ Show target debugging."), _("\
 When non-zero, target debugging is enabled.  Higher numbers are more\n\
 verbose.  Changes do not take effect until the next \"run\" or \"target\"\n\
 command."),
-			    NULL,
+			    set_targetdebug,
 			    show_targetdebug,
 			    &setdebuglist, &showdebuglist);
 
diff --git a/gdb/target.h b/gdb/target.h
index 4a2236c..2d79719 100644
--- a/gdb/target.h
+++ b/gdb/target.h
@@ -1066,7 +1066,7 @@ extern char *normal_pid_to_str (ptid_t ptid);
 
 #ifndef TARGET_CAN_USE_HARDWARE_WATCHPOINT
 #define TARGET_CAN_USE_HARDWARE_WATCHPOINT(TYPE,CNT,OTHERTYPE) \
- (*current_target.to_can_use_hw_breakpoint) (TYPE, CNT, OTHERTYPE);
+ (*current_target.to_can_use_hw_breakpoint) (TYPE, CNT, OTHERTYPE)
 #endif
 
 #ifndef TARGET_REGION_OK_FOR_HW_WATCHPOINT
diff --git a/gdb/testsuite/config/lx-linux.exp b/gdb/testsuite/config/lx-linux.exp
new file mode 100644
index 0000000..912d309
--- /dev/null
+++ b/gdb/testsuite/config/lx-linux.exp
@@ -0,0 +1,55 @@
+# lx.exp  -  Handle access to st200 target (shtdi like execution machine)
+# Copyright  2006, 2007 STMicroelectronics. All Rights Reserved.
+
+# This file is part of GDB.
+
+# This program is free software; you can redistribute it and/or modify
+# itunder the terms of the GNU General Public License as published by he
+# Free Software Foundation; either version 2, or (at your option) any
+# later version.
+
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING. If not, write to the
+# Free Software Foundation,59 Temple Place -Suite 330, Boston, MA
+# 02111-1307, USA. 
+
+set verbose 0
+
+load_generic_config "gdbserver"
+
+process_multilib_options ""
+
+set_board_info protocol                    standard
+set_board_info gdb_protocol                remote
+set_board_info sockethost                  "st231sim:"
+set_board_info hostname                    st231sim
+
+set_board_info username                    racitin
+
+set_board_info rsh_prog                    /usr/local/bin/ssh
+set_board_info rcp_prog                    /usr/local/bin/scp
+set_board_info gdb_server_prog             /image/bin/lx-linux-gdbserver
+
+set_board_info gdb,socketport              "4004"
+set_board_info gdb,start_symbol            _start
+set_board_info gdb,no_hardware_watchpoints 1
+set_board_info gdb,noinferiorio            1
+set_board_info gdb,noargs                  1
+set_board_info gdb,do_reload_on_run        1
+set_board_info gdb,use_gdb_stub            1
+set_board_info gdb,skip_huge_test          1
+
+#set_board_info debug_flags                "-g -O0"
+
+
+set CC_FOR_TARGET "/opt/STM/STLinux-2.3/devkit/st231/bin/st231-linux-gcc"
+set CXX_FOR_TARGET "/opt/STM/STLinux-2.3/devkit/st231/bin/st231-linux-c++filt"
+#set CFLAGS_FOR_TARGET "-DPROTOTYPES -mcore=$mcore -msoc=$msoc -mboard=$mboard -$mendian"
+
+
+load_lib ../config/gdbserver.exp
diff --git a/gdb/testsuite/config/lx.exp b/gdb/testsuite/config/lx.exp
new file mode 100644
index 0000000..6b3eddc
--- /dev/null
+++ b/gdb/testsuite/config/lx.exp
@@ -0,0 +1,278 @@
+# lx.exp  -  Handle access to st200 target (shtdi like execution machine)
+# Copyright  2006, 2007 STMicroelectronics. All Rights Reserved.
+
+# This file is part of GDB.
+
+# This program is free software; you can redistribute it and/or modify
+# itunder the terms of the GNU General Public License as published by he
+# Free Software Foundation; either version 2, or (at your option) any
+# later version.
+
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING. If not, write to the
+# Free Software Foundation,59 Temple Place -Suite 330, Boston, MA
+# 02111-1307, USA. 
+
+set verbose 0
+
+global tcl_platform
+
+# On Windows we have some timeout problems... 
+if {[istarget "lx-*"] && $tcl_platform(platform) == "windows"} {
+   set timeout [expr "$timeout + 60"]
+}
+
+# No signals.
+set_board_info gdb,nosignals 1
+
+#	This tells the rest of the test suite not to do things
+#	like "run" which don't work well on remote targets.
+set_board_info use_gdb_stub 1
+
+#we want to pass all the "dummy calls" tests
+unset_board_info gdb,cannot_call_functions
+
+set_board_info gdb_shtdi_target       "$shtdi_target"
+set_board_info gdb_shtdi_target_addr  "$shtdi_target_addr"
+
+set_board_info gdb,do_reload_on_run   1
+
+set_board_info gdb,start_symbol   "__start"
+
+set_board_info gdb_protocol           "shtdi"
+set_board_info gdb_commands_dir       "$st200root/lx-elf32/stdcmd"
+#set_board_info debug_flags             "-g -O0"
+
+set_board_info gdb,skip_huge_test 1
+
+# Ctrl-c destroys runtest on win32, so don't test interrupt on win32
+#
+if [string match "i686-pc-cygwin" $host_triplet] {
+  set_board_info gdb,nointerrupts 1
+}
+
+set CC_FOR_TARGET "$st200root/bin/st200cc$exeext"
+set CXX_FOR_TARGET "$st200root/bin/st200c++$exeext"
+set CFLAGS_FOR_TARGET "-DPROTOTYPES -mcore=$mcore -msoc=$msoc -mboard=$mboard -$mendian"
+ 
+proc gdb_reinitialize_dir { subdir } {
+    global gdb_prompt
+    global gdb_dirs_command
+    global tcl_platform
+	
+	set sep ":"
+
+    if [is_remote host] {
+	return "";
+    }
+
+    if { $tcl_platform(platform) == "windows" } {
+      set sep  ";"
+    }
+
+
+    send_gdb "dir\n"
+    gdb_expect 60 {
+	-re "Reinitialize source path to empty.*y or n. " {
+	    send_gdb "y\n"
+	    gdb_expect 60 {
+		-re "Source directories searched.*$gdb_prompt $" {
+		    send_gdb "dir [target_info gdb_commands_dir]$sep$subdir\n"
+		    gdb_expect 60 {
+			-re "Source directories searched.*$gdb_prompt $" {
+			    verbose "Dir set to $subdir"
+			}
+			-re "$gdb_prompt $" {
+			    perror "Dir \"$subdir\" failed."
+			}
+		    }
+		}
+		-re "$gdb_prompt $" {
+		    perror "Dir \"$subdir\" failed."
+		}
+	    }
+	}
+	-re "$gdb_prompt $" {
+	    perror "Dir \"$subdir\" failed."
+	}
+    }
+}
+#
+# SHTDI connect and load command sequence
+#
+proc shtdi_connect_and_load {} {
+  global gdb_prompt
+  
+  shtdi_connect
+     
+  send_gdb "load\n";
+  gdb_expect 30 {
+    -re ".*$gdb_prompt $" { }
+    default {
+      perror "load for target failed";
+      return -1;
+    }     
+  }
+  return 0;
+}
+
+#
+# SHTDI connect command sequence
+#
+proc shtdi_connect {} {
+  global gdb_prompt
+  global tcl_platform
+  
+  if [target_info exists gdb_shtdi_target] {
+    send_gdb "[target_info gdb_shtdi_target] [target_info gdb_shtdi_target_addr]\n";
+    gdb_expect 30 {
+      -re "The target is assumed to be .*$gdb_prompt $" { }
+      -re "(The target endianness is set automatically .currently )(big|little)( endian.*)$gdb_prompt $" { }
+      default {
+       perror "gdb_shtdi_target for target failed";
+       return -1;
+      }
+    }
+  }
+  return 0;
+}
+
+#
+# Generic run command.
+#
+# The second pattern below matches up to the first newline *only*.
+# Using ``.*$'' could swallow up output that we attempt to match
+# elsewhere.
+#
+proc gdb_run_cmd {args} {
+    global gdb_prompt
+
+  if { $args != "" } {
+    send_gdb "set args $args\n";
+  }
+
+  if [target_info exists gdb,do_reload_on_run] {
+    if { [shtdi_connect_and_load] != 0 } {
+      return;
+    }
+  }
+  
+  send_gdb "continue\n";
+  gdb_expect 60 {
+    -re "Continu\[^\r\n\]*\[\r\n\]" {}
+    default {}
+  }
+  return;
+}
+#
+# gdb_load -- load a file into the debugger.
+# Many files in config/.exp override this procedure.
+#
+proc gdb_load { arg } {
+    global gdb_prompt
+
+    set res [gdb_file_cmd $arg]
+    
+    if { [shtdi_connect_and_load] != 0 } {
+      return -1;
+    }
+
+  return 0;
+}
+
+proc gdb_file_cmd { arg } {
+    global gdb_prompt
+    global verbose
+    global GDB
+
+    # Set whether debug info was found.
+    # Default to "fail".
+    global gdb_file_cmd_debug_info
+    set gdb_file_cmd_debug_info "fail"
+
+    if [is_remote host] {
+	set arg [remote_download host $arg]
+	if { $arg == "" } {
+	    perror "download failed"
+	    return -1
+	}
+    }
+
+    # The file command used to kill the remote target.  For the benefit
+    # of the testsuite, preserve this behavior.
+    send_gdb "kill\n"
+    gdb_expect 20 {
+	-re "Kill the program being debugged. .y or n. $" {
+	    send_gdb "y\n"
+	    verbose "\t\tKilling previous program being debugged"
+	    exp_continue
+	}
+        # THIS HAS BEEN ADDED FOR ST200 SIMULTAOR SUPPORT - BEGIN
+	-re "In Remote STMicroelectronics host-target debug interface,\r\n#0.*\r\n.*$gdb_prompt $" {
+	    # OK.
+	}
+        # THIS HAS BEEN ADDED FOR ST200 SIMULTAOR SUPPORT - END
+	-re "$gdb_prompt $" {
+	    # OK.
+	}
+    }
+
+    send_gdb "file $arg\n"
+    gdb_expect 20 {
+        # THIS HAS BEEN ADDED FOR ST200 SIMULTAOR SUPPORT - BEGIN
+	-re "A program is being debugged already..*Are you sure you want to change the file.*y or n. $" {
+	    send_gdb "y\n"
+            verbose "\t\tKilling previous program being debugged"
+	    exp_continue
+	}
+        # THIS HAS BEEN ADDED FOR ST200 SIMULTAOR SUPPORT - END
+	-re "Reading symbols from.*no debugging symbols found.*done.*$gdb_prompt $" {
+	    verbose "\t\tLoaded $arg into the $GDB with no debugging symbols"
+	    set gdb_file_cmd_debug_info "nodebug"
+	    return 0
+	}
+        -re "Reading symbols from.*done.*$gdb_prompt $" {
+            verbose "\t\tLoaded $arg into the $GDB"
+	    set gdb_file_cmd_debug_info "debug"
+	    return 0
+        }
+        -re "Load new symbol table from \".*\".*y or n. $" {
+            send_gdb "y\n"
+            gdb_expect 20 {
+                -re "Reading symbols from.*done.*$gdb_prompt $" {
+                    verbose "\t\tLoaded $arg with new symbol table into $GDB"
+		    set gdb_file_cmd_debug_info "debug"
+		    return 0
+                }
+                timeout {
+                    perror "(timeout) Couldn't load $arg, other program already loaded."
+		    return -1
+                }
+            }
+	}
+        -re "No such file or directory.*$gdb_prompt $" {
+            perror "($arg) No such file or directory"
+	    return -1
+        }
+        -re "$gdb_prompt $" {
+            perror "couldn't load $arg into $GDB."
+	    return -1
+            }
+        timeout {
+            perror "couldn't load $arg into $GDB (timed out)."
+	    return -1
+        }
+        eof {
+            # This is an attempt to detect a core dump, but seems not to
+            # work.  Perhaps we need to match .* followed by eof, in which
+            # gdb_expect does not seem to have a way to do that.
+            perror "couldn't load $arg into $GDB (end of file)."
+	    return -1
+        }
+    }
+}
diff --git a/gdb/testsuite/lib/gdbserver-support.exp b/gdb/testsuite/lib/gdbserver-support.exp
index 6fbaa22..a991e6b 100644
--- a/gdb/testsuite/lib/gdbserver-support.exp
+++ b/gdb/testsuite/lib/gdbserver-support.exp
@@ -179,8 +179,8 @@ proc gdbserver_download { } {
 
 proc gdbserver_start { options arguments } {
     global portnum
-
-    # Port id -- either specified in baseboard file, or managed here.
+    
+     # Port id -- either specified in baseboard file, or managed here.
     if [target_info exists gdb,socketport] {
 	set portnum [target_info gdb,socketport]
     } else {
@@ -216,16 +216,21 @@ proc gdbserver_start { options arguments } {
     if { $arguments != "" } {
 	append gdbserver_command " $arguments"
     }
+   
+   set server_spawn_id [remote_spawn target $gdbserver_command]
 
-    set server_spawn_id [remote_spawn target $gdbserver_command]
-
+   # nunzio
+   # clone_output "gdbserver_start target $gdbserver_command $server_spawn_id"
+   # after 20000
+   
     # Wait for the server to open its TCP socket, so that GDB can connect.
     expect {
 	-i $server_spawn_id
 	-notransfer
+
 	-re "Listening on" { }
     }
-
+   #-re ".*password.*$" {  send_gdb "_spero" }
     # We can't just call close, because if gdbserver is local then that means
     # that it will get a SIGHUP.  Doing it this way could also allow us to
     # get at the inferior's input or output if necessary, and means that we
@@ -249,7 +254,7 @@ proc gdbserver_start { options arguments } {
 
 proc gdbserver_spawn { child_args } {
     set target_exec [gdbserver_download]
-
+    
     # Fire off the debug agent.  This flavour of gdbserver takes as
     # arguments the port information, the name of the executable file to
     # be debugged, and any arguments.
@@ -281,11 +286,14 @@ proc gdbserver_run { child_args } {
 	    # OK.
 	}
     }
-
+    
     set res [gdbserver_spawn $child_args]
     set gdbserver_protocol [lindex $res 0]
     set gdbserver_gdbport [lindex $res 1]
 
+
+    clone_output "gdbserver_run: gdb_target_cmd $gdbserver_protocol $gdbserver_gdbport"
+    
     return [gdb_target_cmd $gdbserver_protocol $gdbserver_gdbport]
 }
 
diff --git a/gdb/thread.c b/gdb/thread.c
index 40b7b3d..8850806 100644
--- a/gdb/thread.c
+++ b/gdb/thread.c
@@ -2,6 +2,7 @@
 
    Copyright (C) 1986, 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
    2000, 2001, 2002, 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    Contributed by Lynx Real-Time Systems, Inc.  Los Gatos, CA.
 
@@ -221,7 +222,7 @@ valid_thread_id (int num)
   struct thread_info *tp;
 
   for (tp = thread_list; tp; tp = tp->next)
-    if (tp->num == num)
+    if (tp->num == num && thread_alive (tp))
       return 1;
 
   return 0;
@@ -441,9 +442,14 @@ info_threads_command (char *arg, int from_tty)
       if (extra_info)
 	printf_filtered (" (%s)", extra_info);
       puts_filtered ("  ");
-      /* That switch put us at the top of the stack (leaf frame).  */
-      switch_to_thread (tp->ptid);
-      print_stack_frame (get_selected_frame (NULL), 0, LOCATION);
+      if ( arg && strcmp(arg, "nostackframe") == 0 )
+        puts_filtered ("\n");
+      else
+        { 
+          /* That switch put us at the top of the stack (leaf frame).  */
+          switch_to_thread (tp->ptid);
+          print_stack_frame (get_selected_frame (NULL), 0, LOCATION);
+        }
     }
 
   /* Restores the current thread and the frame selected before
diff --git a/gdb/top.c b/gdb/top.c
index 9ad2f54..c2bac24 100644
--- a/gdb/top.c
+++ b/gdb/top.c
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
    2008 Free Software Foundation, Inc.
+   Copyright (C) 2008 STMicroelectronics
 
    This file is part of GDB.
 
@@ -364,6 +365,50 @@ do_chdir_cleanup (void *old_dir)
 }
 #endif
 
+
+#define ENV_DELIMITER_BEGIN  "${"
+#define ENV_DELIMITER_END  "}"
+static char*
+evaluate_environment_from_string (char* input)
+{
+  char *p1, *p2, *output, *env_var, *env_var_value;
+  int env_var_len, delimiter_begin_len, delimiter_end_len;
+
+  p1 = (char *) strstr (input, ENV_DELIMITER_BEGIN);
+  if (p1 == NULL)
+    return input;
+
+  p2 = (char *) strstr (p1+1, ENV_DELIMITER_END);
+  if (p2 == NULL)
+    return input;
+
+  delimiter_begin_len = strlen (ENV_DELIMITER_BEGIN);
+  delimiter_end_len = strlen (ENV_DELIMITER_END);
+  /* get the env var.  */
+  env_var_len = p2 - p1 - delimiter_begin_len;
+  env_var = xmalloc (env_var_len + 1);
+  strncpy (env_var, p1 + delimiter_begin_len, env_var_len);
+  env_var[env_var_len] = 0;
+
+  /* get its value.  */
+  env_var_value = getenv (env_var);
+  if (env_var_value == NULL) {
+    xfree (env_var);
+    return input;
+  }
+
+  /* replace this value into the original string.  */
+  output = xmalloc (strlen (input) + strlen (env_var_value) - env_var_len 
+                    - delimiter_begin_len - delimiter_end_len + 1);
+  strncpy (output, input, p1-input);
+  strcpy (output+(p1-input), env_var_value);
+  strcat (output+(p1-input), p2 + delimiter_end_len);
+  
+  xfree (env_var);
+  return evaluate_environment_from_string (output);
+}
+
+ 
 /* Execute the line P as a command.
    Pass FROM_TTY as second argument to the defining function.  */
 
@@ -374,7 +419,6 @@ execute_command (char *p, int from_tty)
   enum language flang;
   static int warned = 0;
   char *line;
-  
   free_all_values ();
 
   /* Force cleanup of any alloca areas if using C alloca instead of
@@ -385,6 +429,7 @@ execute_command (char *p, int from_tty)
   if (p == NULL)
     return;
 
+  p = evaluate_environment_from_string (p);
   target_log_command (p);
 
   while (*p == ' ' || *p == '\t')
diff --git a/gdb/ui-out.c b/gdb/ui-out.c
index dfdb61d..2943ff4 100644
--- a/gdb/ui-out.c
+++ b/gdb/ui-out.c
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* Output generating routines for GDB.
 
    Copyright (C) 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008
@@ -279,10 +283,29 @@ ui_out_table_begin (struct ui_out *uiout, int nbrofcols,
 		    int nr_rows,
 		    const char *tblid)
 {
+    /* MBTst19858: we don't bother anymore with this check.
+       It would have been far better to implement a kind of ui_out_table_abort
+       service, but is it worth it?
+    */
   if (uiout->table.flag)
+#ifndef TARGET_ST200
     internal_error (__FILE__, __LINE__,
 		    _("tables cannot be nested; table_begin found before \
 previous table_end."));
+#else
+    /* we just do as in ui_out_table_end */ 
+    {
+      uiout->table.entry_level = 0;
+      uiout->table.body_flag = 0;
+      uiout->table.flag = 0;
+
+      uo_table_end (uiout);
+
+      if (uiout->table.id)
+        xfree (uiout->table.id);
+      clear_header_list (uiout);  
+    }
+#endif
 
   uiout->table.flag = 1;
   uiout->table.body_flag = 0;
diff --git a/gdb/valops.c b/gdb/valops.c
index 69ebb15..4957724 100644
--- a/gdb/valops.c
+++ b/gdb/valops.c
@@ -574,11 +574,10 @@ value_fetch_lazy (struct value *val)
   CORE_ADDR addr = VALUE_ADDRESS (val) + value_offset (val);
   int length = TYPE_LENGTH (value_enclosing_type (val));
 
-  struct type *type = value_type (val);
+  set_value_lazy (val, 0);
   if (length)
     read_memory (addr, value_contents_all_raw (val), length);
 
-  set_value_lazy (val, 0);
   return 0;
 }
 
diff --git a/gdb/value.c b/gdb/value.c
index e620550..92b1d6c 100644
--- a/gdb/value.c
+++ b/gdb/value.c
@@ -3,6 +3,7 @@
    Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
    1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008
    Free Software Foundation, Inc.
+   Copyright (c) 2006 STMicroelectronics
 
    This file is part of GDB.
 
@@ -826,6 +827,7 @@ value_of_internalvar (struct internalvar *var)
       switch (TYPE_CODE (type))
 	{
 	case TYPE_CODE_INT:
+	case TYPE_CODE_FLT:
 	case TYPE_CODE_PTR:
 	  /* Reverse the bytes.  */
 	  for (i = 0, j = TYPE_LENGTH (type) - 1; i < j; i++, j--)
@@ -1739,6 +1741,12 @@ value_initialized (struct value *val)
   return val->initialized;
 }
 
+/* This is just for backwards compatibility.  */
+static void
+keep_variable_command (char *ignored, int from_tty)
+{
+}
+
 void
 _initialize_values (void)
 {
@@ -1762,4 +1770,7 @@ init-if-undefined VARIABLE = EXPRESSION\n\
 Set an internal VARIABLE to the result of the EXPRESSION if it does not\n\
 exist or does not contain a value.  The EXPRESSION is not evaluated if the\n\
 VARIABLE is already initialized."));
+
+  add_com ("keep-variable", no_class, keep_variable_command,
+	   _("Ignored. Kept for backwards compatibility."));
 }
diff --git a/gdb/version.in b/gdb/version.in
index 21afad3..acc9228 100644
--- a/gdb/version.in
+++ b/gdb/version.in
@@ -1 +1 @@
-6.8
+6.8-STLinux-2.3
diff --git a/include/ChangeLog.sts-gdb b/include/ChangeLog.sts-gdb
new file mode 100644
index 0000000..e5dc247
--- /dev/null
+++ b/include/ChangeLog.sts-gdb
@@ -0,0 +1,7 @@
+2006-03-20  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* libiberty.h: Fix build failure with -Werror when NOT on Windows.
+
+2006-03-16  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* libiberty.h: Add definition for cygpath.c.
diff --git a/include/bfdlink.h b/include/bfdlink.h
index bcd4b4f..a615b2f 100644
--- a/include/bfdlink.h
+++ b/include/bfdlink.h
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* bfdlink.h -- header file for BFD link routines
    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
    2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@@ -151,6 +155,13 @@ struct bfd_link_hash_entry
 	  bfd_size_type size;	/* Common symbol size.  */
 	} c;
     } u;
+
+#ifdef IPA_LINK
+  /* [CL] Remember the bfd associated with this symbol.
+   * For Whirl sections, there is no bfd owner,
+   * so we need to store it here */
+  bfd* ipa_bfd;
+#endif
 };
 
 /* This is the link hash table.  It is a derived class of
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 40afe17..445de85 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* Interface between the opcode library and its callers.
 
    Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
@@ -237,6 +241,8 @@ extern int print_insn_i860		(bfd_vma, disassemble_info *);
 extern int print_insn_i960		(bfd_vma, disassemble_info *);
 extern int print_insn_ia64		(bfd_vma, disassemble_info *);
 extern int print_insn_ip2k		(bfd_vma, disassemble_info *);
+extern int print_insn_little_lx         (bfd_vma, disassemble_info *);
+extern int print_insn_big_lx  	        (bfd_vma, disassemble_info *);
 extern int print_insn_iq2000		(bfd_vma, disassemble_info *);
 extern int print_insn_little_arm	(bfd_vma, disassemble_info *);
 extern int print_insn_little_mips	(bfd_vma, disassemble_info *);
diff --git a/include/elf/ChangeLog.sts-gdb b/include/elf/ChangeLog.sts-gdb
new file mode 100644
index 0000000..6c2bd6b
--- /dev/null
+++ b/include/elf/ChangeLog.sts-gdb
@@ -0,0 +1,3 @@
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh.h: Add st40-300 variants.
diff --git a/include/elf/common.h b/include/elf/common.h
index b6d981f..fc0c88c 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* ELF support for BFD.
    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
    2001, 2002, 2003, 2004, 2005, 2006, 2007
@@ -74,6 +78,7 @@
 #define ELFOSABI_OPENVMS     13	/* OpenVMS */
 #define ELFOSABI_NSK	     14	/* Hewlett-Packard Non-Stop Kernel */
 #define ELFOSABI_AROS	     15	/* Amiga Research OS */
+#define ELFOSABI_OS21	     64	/* OS 21 */
 #define ELFOSABI_ARM	     97	/* ARM */
 #define ELFOSABI_STANDALONE 255	/* Standalone (embedded) application */
 
@@ -285,6 +290,9 @@
 
 /* See the above comment before you add a new EM_* value here.  */
 
+#define EM_LX 0x64
+#define EM_LX_OLD 0x1064
+
 /* Values for e_version.  */
 
 #define EV_NONE		0		/* Invalid ELF version */
diff --git a/include/elf/lx.h b/include/elf/lx.h
new file mode 100644
index 0000000..a6a6c90
--- /dev/null
+++ b/include/elf/lx.h
@@ -0,0 +1,173 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003 
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+*** 
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License 
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**/
+
+/* LX ELF support for BFD.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file holds definitions specific to the PPC ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_LX_H
+#define _ELF_LX_H
+
+#include "bfd.h"
+#include "elf-bfd.h"
+
+#include "elf/reloc-macros.h"
+
+/*
+ * Typedef relating to bfd library
+ *
+ *   rta = 0 : catch all
+ *   rta = 1 : multiflow register assignment
+ *   rta = 2 : lxbe embedded
+ *   rta = 3 : lxbe PIC
+ */
+
+typedef union {
+  struct {
+    unsigned rta : 4;  
+  } obj_compat;
+  unsigned int f;
+} lx_bfd_flags;
+
+/* (pp) core */
+#define _ELF_LX_CORE_BIT	(8)                      /* 1st bit position in byte */
+#define ELF_LX_CORE_MASK	(0xff<<_ELF_LX_CORE_BIT)           /* mask */
+#define ELF_LX_CORE_ST210	(0x0<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST220	(0x1<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST230	(0x2<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST231	(0x3<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST235	(0x4<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST239	(0x5<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_ST240	(0x6<<_ELF_LX_CORE_BIT)
+#define ELF_LX_CORE_UNDEF	(0x7<<_ELF_LX_CORE_BIT)
+#define _ELF_LX_CHECK_CORE(m) ((m&ELF_LX_CORE_MASK)==m)
+
+/* (pp) cut */
+#define _ELF_LX_CUT_BIT	(16)                             /* 1st bit position in byte */
+#define ELF_LX_CUT_MASK		(0xf<<_ELF_LX_CUT_BIT)           /* mask */
+#define ELF_LX_CUT_0		(0x0<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_1		(0x1<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_2		(0x2<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_3		(0x3<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_4		(0x4<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_5		(0x5<<_ELF_LX_CUT_BIT)
+#define ELF_LX_CUT_UNDEF	(0x6<<_ELF_LX_CUT_BIT)
+#define _ELF_LX_CHECK_CUT(m) ((m&ELF_LX_CUT_MASK)==m)
+
+/* (pp) abi */
+#define _ELF_LX_ABI_BIT	(0)                             /* 1st bit position in byte */
+#define ELF_LX_ABI_MASK		(0x7f<<_ELF_LX_ABI_BIT)           /* mask */
+#define ELF_LX_ABI_NO		(0x0<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_MULTI	(0x1<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_EMBED	(0x2<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_PIC		(0x3<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_GCC		(0x4<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_UNDEF	(0x5<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_RELOC_EMBED  (0x6<<_ELF_LX_ABI_BIT)
+#define _ELF_LX_CHECK_ABI(m) ((m&ELF_LX_ABI_MASK)==m)
+
+/* compatibility with rta directive on solaris : rta bits where writen in the bits 28:31 on Solaris */
+#define _ELF_LX_RTA_BIT	(28)                             /* 1st bit position in byte */
+
+/* (pp) code generation mode */
+#define _ELF_LX_MODE_BIT (7)                             /* 1st bit position in byte */
+#define ELF_LX_MODE_MASK	(0x1<<_ELF_LX_MODE_BIT)           /* mask */
+#define ELF_LX_MODE_USER	(0x0<<_ELF_LX_MODE_BIT)
+#define ELF_LX_MODE_KERNEL	(0x1<<_ELF_LX_MODE_BIT)
+#define _ELF_LX_CHECK_MODE(m) ((m&ELF_LX_MODE_MASK)==m)
+
+const char * core_printable_name(flagword flags);
+const char * cut_printable_name(flagword flags);
+const char * abi_printable_name(flagword flags, Elf_Internal_Ehdr * i_ehdrp);
+const char * osabi_printable_name(Elf_Internal_Ehdr * i_ehdrp);
+const char * code_generation_mode_printable_name(Elf_Internal_Ehdr * i_ehdrp);
+flagword lx_elf_get_private_flags (bfd* abfd);
+void lx_elf_dump_target_info(bfd *abfd, FILE *writer);
+
+/* (pp) say wether a function can be moved by icacheopt or not */
+#define STO_FUNC_NATURE_BIT (4)
+#define STO_FUNC_NATURE_MASK   (0x1 << STO_FUNC_NATURE_BIT)
+#define STO_MOVEABLE  (0x1 << STO_FUNC_NATURE_BIT)
+#define is_STO_MOVEABLE(o) (((o)&STO_FUNC_NATURE_MASK)==STO_MOVEABLE)
+
+/* (tb) say wether a symbol has used attribute (mean not to be deleted by binopt tool */
+#define STO_SYMB_USED_BIT (5)
+#define STO_SYMB_USED_MASK   (0x1 << STO_SYMB_USED_BIT)
+#define STO_USED  (0x1 << STO_SYMB_USED_BIT)
+#define is_STO_USED(o) (((o)&STO_SYMB_USED_MASK)==STO_USED)
+
+#define ELF_STRING_lx_pltoff ".lx.pltoff"
+
+START_RELOC_NUMBERS (elf_lx_reloc_type)
+     RELOC_NUMBER (R_LX_NONE,                 0)
+     RELOC_NUMBER (R_LX_16,                   1)
+     RELOC_NUMBER (R_LX_32,                   2)
+     RELOC_NUMBER (R_LX_32_PCREL,             3)
+     RELOC_NUMBER (R_LX_23_PCREL,             4)
+     RELOC_NUMBER (R_LX_HI23,                 5)
+     RELOC_NUMBER (R_LX_LO9,                  6)
+     RELOC_NUMBER (R_LX_GPREL_HI23,           7)
+     RELOC_NUMBER (R_LX_GPREL_LO9,            8)
+     RELOC_NUMBER (R_LX_REL32,                9)
+     RELOC_NUMBER (R_LX_GOTOFF_HI23,         10)
+     RELOC_NUMBER (R_LX_GOTOFF_LO9,          11)
+     RELOC_NUMBER (R_LX_GOTOFFX_HI23,        12)
+     RELOC_NUMBER (R_LX_GOTOFFX_LO9,         13)
+     RELOC_NUMBER (R_LX_LTV32,               14)
+     RELOC_NUMBER (R_LX_SEGREL32,            15)
+     RELOC_NUMBER (R_LX_FPTR32,              16)
+     RELOC_NUMBER (R_LX_PLTOFF_HI23,         17)
+     RELOC_NUMBER (R_LX_PLTOFF_LO9,          18)
+     RELOC_NUMBER (R_LX_GOTOFF_FPTR_HI23,    19)
+     RELOC_NUMBER (R_LX_GOTOFF_FPTR_LO9,     20)
+     RELOC_NUMBER (R_LX_IPLT,                21)
+     RELOC_NUMBER (R_LX_NEG_GPREL_HI23,      22)
+     RELOC_NUMBER (R_LX_NEG_GPREL_LO9,       23)
+     RELOC_NUMBER (R_LX_COPY,                24)
+     RELOC_NUMBER (R_LX_JMP_SLOT,            25)
+     RELOC_NUMBER (R_LX_TPREL_HI23,          26)
+     RELOC_NUMBER (R_LX_TPREL_LO9,           27)
+     RELOC_NUMBER (R_LX_TPREL32,             28)
+     RELOC_NUMBER (R_LX_GOTOFF_TPREL_HI23,   29)
+     RELOC_NUMBER (R_LX_GOTOFF_TPREL_LO9,    30)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPLDM_HI23,  31)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPLDM_LO9,   32)
+     RELOC_NUMBER (R_LX_DTPREL_HI23,         33)
+     RELOC_NUMBER (R_LX_DTPREL_LO9,          34)
+     RELOC_NUMBER (R_LX_DTPMOD32,            35)
+     RELOC_NUMBER (R_LX_DTPREL32,            36)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPNDX_HI23,  37)
+     RELOC_NUMBER (R_LX_GOTOFF_DTPNDX_LO9,   38)
+END_RELOC_NUMBERS (R_LX_max)
+
+#endif
diff --git a/include/elf/sh.h b/include/elf/sh.h
index deb7a9d..fa52def 100644
--- a/include/elf/sh.h
+++ b/include/elf/sh.h
@@ -1,5 +1,6 @@
 /* SH ELF support for BFD.
    Copyright 1998, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of BFD, the Binary File Descriptor library.
 
@@ -22,7 +23,7 @@
 
 /* Processor specific flags for the ELF header e_flags field.  */
 
-#define EF_SH_MACH_MASK	0x1f
+#define EF_SH_MACH_MASK	0x3f
 #define EF_SH_UNKNOWN	   0 /* For backwards compatibility.  */
 #define EF_SH1		   1
 #define EF_SH2		   2
@@ -47,6 +48,12 @@
 #define EF_SH2A_SH4        23
 #define EF_SH2A_SH3E       24
 
+#define EF_ST40_300_SH2A_NOFPU 50
+#define EF_ST40_300_SH4A_NOFPU 51
+#define EF_ST40_300_NOFPU      52
+#define EF_ST40_300_SH4A       53
+#define EF_ST40_300            54
+
 /* This one can only mix in objects from other EF_SH5 objects.  */
 #define EF_SH5		  10
 
@@ -77,7 +84,15 @@
 /* EF_SH2A_SH4_NOFPU    */ bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu, \
 /* EF_SH2A_SH3_NOFPU    */ bfd_mach_sh2a_nofpu_or_sh3_nommu, \
 /* EF_SH2A_SH4          */ bfd_mach_sh2a_or_sh4 , \
-/* EF_SH2A_SH3E         */ bfd_mach_sh2a_or_sh3e
+/* EF_SH2A_SH3E         */ bfd_mach_sh2a_or_sh3e, \
+/* 25 - 29              */ 0, 0, 0, 0, 0, \
+/* 30 - 39              */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+/* 40 - 49              */ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+/* EF_ST40_300_SH2A_NOFPU */ bfd_mach_st40_300_nofpu_or_sh2a_nofpu, \
+/* EF_ST40_300_SH4A_NOFPU */ bfd_mach_st40_300_nofpu_or_sh4a_nofpu, \
+/* EF_ST40_300_NOFPU    */ bfd_mach_st40_300_nofpu, \
+/* EF_ST40_300_SH4A     */ bfd_mach_st40_300_or_sh4a, \
+/* EF_ST40_300          */ bfd_mach_st40_300
 
 /* Convert arch_sh* into EF_SH*.  */
 int sh_find_elf_flags (unsigned int arch_set);
diff --git a/include/halpm.h b/include/halpm.h
new file mode 100644
index 0000000..525b3be
--- /dev/null
+++ b/include/halpm.h
@@ -0,0 +1,265 @@
+ /*  halpm.h - Architectural information automatically extracted from xml file
+Copyright  2001, 2002, 2003, 2004 STMicroelectronics. All Rights Reserved.
+
+This file is part of GDB.
+
+This program is free software; you can redistribute it and/or modify
+itunder the terms of the GNU General Public License as published by he
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+This program is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING. If not, write to the
+Free Software Foundation,59 Temple Place -Suite 330, Boston, MA
+02111-1307, USA. */
+
+
+
+#ifndef __HALPM_H
+#define __HALPM_H
+
+
+/* C++ support */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Common macros to handle bitfields
+ */
+#define BIT(x)                      (1<<(x))
+#define MASK(start,len)             ((BIT(len)-1)<<(start))
+
+
+/*
+ * Macro for Control register base address and
+ * Peripheral base address.
+ */
+#define CREG_BASE 	            0xffff0000
+#define HAL_PERIPHERAL_BASE_OFF         0xffb0
+#define HAL_PERIPHERAL_BASE         (CREG_BASE + HAL_PERIPHERAL_BASE_OFF)
+
+#define HAL_DSR0_OFF     0x3000
+
+#define HAL_DSR0_CORE_LEN       8
+#define HAL_DSR0_CORE_POS  	16
+#define HAL_DSR0_CORE_MASK 	MASK(HAL_DSR0_CORE_POS,HAL_DSR0_CORE_LEN)
+
+#define HAL_DSR0_CORE_FGET(_dsr0_) (((_dsr0_) & HAL_DSR0_CORE_MASK) >> HAL_DSR0_CORE_POS)
+
+/*
+ * The ST230 provides a hardware instrumentation system which consists of a control register (PM_CR), a clock counter (PM_PCLK) and four event counters (PM_CNTi, i= 0, 1, 2, 3).
+ */
+#define HAL_PM_OFF  	0xf800
+#define HAL_PM_BASE 	(CREG_BASE + HAL_PM_OFF)
+
+
+
+/*
+ *  Register name: HAL_PM_CR
+ */
+#define HAL_PM_CR      	(HAL_PM_BASE + HAL_PM_CR_OFF)
+#define HAL_PM_CR_OFF  	0x0
+/*
+ *  Field name: HAL_PM_CR_ENB
+ */
+#define HAL_PM_CR_ENB_LEN 	1
+#define HAL_PM_CR_ENB_POS  	0
+#define HAL_PM_CR_ENB_MASK 	MASK(HAL_PM_CR_ENB_POS,HAL_PM_CR_ENB_LEN)
+#define HAL_PM_CR_ENB_FGET(reg) (((reg) & HAL_PM_CR_ENB_MASK) >> HAL_PM_CR_ENB_POS)
+#define HAL_PM_CR_ENB_FBLD(reg,val) 	(((reg) & (~HAL_PM_CR_ENB_MASK)) |\
+					(((val) << HAL_PM_CR_ENB_POS) & HAL_PM_CR_ENB_MASK))
+
+/*
+ *  Field name: HAL_PM_CR_RST
+ */
+#define HAL_PM_CR_RST_LEN 	1
+#define HAL_PM_CR_RST_POS  	1
+#define HAL_PM_CR_RST_MASK 	MASK(HAL_PM_CR_RST_POS,HAL_PM_CR_RST_LEN)
+#define HAL_PM_CR_RST_FGET(reg) (((reg) & HAL_PM_CR_RST_MASK) >> HAL_PM_CR_RST_POS)
+#define HAL_PM_CR_RST_FBLD(reg,val) 	(((reg) & (~HAL_PM_CR_RST_MASK)) |\
+					(((val) << HAL_PM_CR_RST_POS) & HAL_PM_CR_RST_MASK))
+
+/*
+ *  Field name: HAL_PM_CR_IDLE
+ */
+#define HAL_PM_CR_IDLE_LEN 	1
+#define HAL_PM_CR_IDLE_POS  	2
+#define HAL_PM_CR_IDLE_MASK 	MASK(HAL_PM_CR_IDLE_POS,HAL_PM_CR_IDLE_LEN)
+#define HAL_PM_CR_IDLE_FGET(reg) (((reg) & HAL_PM_CR_IDLE_MASK) >> HAL_PM_CR_IDLE_POS)
+#define HAL_PM_CR_IDLE_FBLD(reg,val) 	(((reg) & (~HAL_PM_CR_IDLE_MASK)) |\
+					(((val) << HAL_PM_CR_IDLE_POS) & HAL_PM_CR_IDLE_MASK))
+
+/*
+ *  Field name: HAL_PM_CR_EVENT0
+ */
+#define HAL_PM_CR_EVENT0_LEN 	5
+#define HAL_PM_CR_EVENT0_POS  	12
+#define HAL_PM_CR_EVENT0_MASK 	MASK(HAL_PM_CR_EVENT0_POS,HAL_PM_CR_EVENT0_LEN)
+#define HAL_PM_CR_EVENT0_FGET(reg) (((reg) & HAL_PM_CR_EVENT0_MASK) >> HAL_PM_CR_EVENT0_POS)
+#define HAL_PM_CR_EVENT0_FBLD(reg,val) (((reg) & (~HAL_PM_CR_EVENT0_MASK)) |\
+				       (((val) << HAL_PM_CR_EVENT0_POS) & HAL_PM_CR_EVENT0_MASK))
+
+/*
+ *  Field name: HAL_PM_CR_EVENT1
+ */
+#define HAL_PM_CR_EVENT1_LEN 	5
+#define HAL_PM_CR_EVENT1_POS  	17
+#define HAL_PM_CR_EVENT1_MASK 	MASK(HAL_PM_CR_EVENT1_POS,HAL_PM_CR_EVENT1_LEN)
+#define HAL_PM_CR_EVENT1_FGET(reg) (((reg) & HAL_PM_CR_EVENT1_MASK) >> HAL_PM_CR_EVENT1_POS)
+#define HAL_PM_CR_EVENT1_FBLD(reg,val) (((reg) & (~HAL_PM_CR_EVENT1_MASK)) |\
+				       (((val) << HAL_PM_CR_EVENT1_POS) & HAL_PM_CR_EVENT1_MASK))
+
+/*
+ *  Field name: HAL_PM_CR_EVENT2
+ */
+#define HAL_PM_CR_EVENT2_LEN 	5
+#define HAL_PM_CR_EVENT2_POS  	22
+#define HAL_PM_CR_EVENT2_MASK 	MASK(HAL_PM_CR_EVENT2_POS,HAL_PM_CR_EVENT2_LEN)
+#define HAL_PM_CR_EVENT2_FGET(reg) (((reg) & HAL_PM_CR_EVENT2_MASK) >> HAL_PM_CR_EVENT2_POS)
+#define HAL_PM_CR_EVENT2_FBLD(reg,val) 	(((reg) & (~HAL_PM_CR_EVENT2_MASK)) |\
+					(((val) << HAL_PM_CR_EVENT2_POS) & HAL_PM_CR_EVENT2_MASK))
+
+/*
+ *  Field name: HAL_PM_CR_EVENT3
+ */
+#define HAL_PM_CR_EVENT3_LEN 	5
+#define HAL_PM_CR_EVENT3_POS  	27
+#define HAL_PM_CR_EVENT3_MASK 	MASK(HAL_PM_CR_EVENT3_POS,HAL_PM_CR_EVENT3_LEN)
+#define HAL_PM_CR_EVENT3_FGET(reg) (((reg) & HAL_PM_CR_EVENT3_MASK) >> HAL_PM_CR_EVENT3_POS)
+#define HAL_PM_CR_EVENT3_FBLD(reg,val) 	(((reg) & (~HAL_PM_CR_EVENT3_MASK)) |\
+					(((val) << HAL_PM_CR_EVENT3_POS) & HAL_PM_CR_EVENT3_MASK))
+
+/*
+ * EVENT table
+ */
+#define HAL_PM_EVENT_DHIT  0
+#define HAL_PM_EVENT_DMISS  1
+#define HAL_PM_EVENT_DMISSCYCLES  2
+#define HAL_PM_EVENT_PFTISSUED  3
+#define HAL_PM_EVENT_PFTHITS  4
+#define HAL_PM_EVENT_WBHITS  5
+#define HAL_PM_EVENT_IHIT  6
+#define HAL_PM_EVENT_IMISS  7
+#define HAL_PM_EVENT_IMISSCYCLES  8
+#define HAL_PM_EVENT_IBUFINVALID  9
+#define HAL_PM_EVENT_BUNDLES  10
+#define HAL_PM_EVENT_LDST  11
+#define HAL_PM_EVENT_TAKENBR  12
+#define HAL_PM_EVENT_NOTTAKENBR  13
+#define HAL_PM_EVENT_EXCEPTIONS  14
+#define HAL_PM_EVENT_INTERRUPTS  15
+#define HAL_PM_EVENT_BUSREADS  16
+#define HAL_PM_EVENT_BUSWRITES  17
+#define HAL_PM_EVENT_OPERATIONS  18
+#define HAL_PM_EVENT_WBMISSES  19
+#define HAL_PM_EVENT_NOPBUNDLES  20
+#define HAL_PM_EVENT_LONGIMM  21
+#define HAL_PM_EVENT_ITLBMISS  22
+#define HAL_PM_EVENT_DTLBMISS  23
+#define HAL_PM_EVENT_UTLBHIT  24
+#define HAL_PM_EVENT_ITLBWAITCYC  25
+#define HAL_PM_EVENT_DTLBWAITCYCLES  26
+#define HAL_PM_EVENT_UTLBARBITRATIONCYCLES  27
+
+unsigned char *description[] = {"The number of load and stores that hit the cache",
+                                "The number of load and stores that miss the cache",
+                                "The number of cycles the core is stalled due to the data cache beign busy",
+                                "The number of prefetches that are sent to the bus",
+                                "The number of cached loads that hit the prefetch buffer",
+                                "The number of cached writes that hit the write buffer",
+                                "The number of accesses the instruction buffer made that hit the instruction cache",
+                                "The number of accesses the instruction buffer made that missed the instruction cache",
+                                "The number of cycles the instruction cache was stalled for",
+                                "Duration where IBuffer is not able to issue bundles to the pipeline",
+                                "Bundles executed",
+                                "Load/Store instructions executed",
+                                "Number of taken branches",
+                                "Number of not taken branches",
+                                "Number of exceptions and debug interrupts",
+                                "Number of interrupts",
+                                "Number of architectural read transactions issued to the bus",
+                                "Number of architectural write transactions issued to the bus",
+                                "Number of completed operations",
+                                "Number of cached writes that missed the cache and misses the write buffer",
+                                "Number of completed bundles that were empty or contained only nops",
+                                "Number of long immediates in completed bundles",
+                                "The number of instruction cache fills that missed the ITLB",
+                                "The number of load/store operations that missed the DTLB when TLB is enabled",
+                                "The number of accessed to the UTLB which were hits",
+                                "Number of cycles the instruction cache spends waiting for the ITLB to fill",
+                                "Number of cycles the data cache spends waiting for the ITLB to fill",
+                                "Number of cycles where the ITLB or DTLB was waiting for access to the UTLB because the UTLB was busy servicing a request"};
+
+unsigned char *events[] = {"DHIT",
+                           "DMISS",
+                           "DMISSCYCLES",
+                           "PFTISSUED",
+                           "PFTHITS",
+                           "WBHITS",
+                           "IHIT",
+                           "IMISS",
+                           "IMISSCYCLES",
+                           "IBUFINVALID",
+                           "BUNDLES",
+                           "LDST",
+                           "TAKENBR",
+                           "NOTTAKENBR",
+                           "EXCEPTIONS",
+                           "INTERRUPTS",
+                           "BUSREADS",
+                           "BUSWRITES",
+                           "OPERATIONS",
+                           "WBMISSES",
+                           "NOPBUNDLES",
+                           "LONGIMM",
+                           "ITLBMISS",
+                           "DTLBMISS",
+                           "UTLBHIT",
+                           "ITLBWAITCYC",
+                           "DTLBWAITCYCLES",
+                           "UTLBARBITRATIONCYCLES"};
+
+/*******************************************************************/
+
+/*
+ *  Register name: HAL_PM_CNT0
+ */
+#define HAL_PM_CNT0_OFF  	0x8
+#define HAL_PM_CNT0      	(HAL_PM_BASE + HAL_PM_CNT0_OFF)
+/*
+ *  Register name: HAL_PM_CNT1
+ */
+#define HAL_PM_CNT1_OFF  	0x10
+#define HAL_PM_CNT1      	(HAL_PM_BASE + HAL_PM_CNT1_OFF)
+/*
+ *  Register name: HAL_PM_CNT2
+ */
+#define HAL_PM_CNT2_OFF  	0x18
+#define HAL_PM_CNT2      	(HAL_PM_BASE + HAL_PM_CNT2_OFF)
+
+/*
+ *  Register name: HAL_PM_CNT3
+ */
+#define HAL_PM_CNT3_OFF  	0x20
+#define HAL_PM_CNT3      	(HAL_PM_BASE + HAL_PM_CNT3_OFF)
+
+/*
+ *  Register name: HAL_PM_PCLK
+ */
+#define HAL_PM_PCLK      	(HAL_PM_BASE + HAL_PM_PCLK_OFF)
+#define HAL_PM_PCLK_OFF  	0x28
+
+
+/* C++ support */
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HALPM_H */
+
diff --git a/include/machine/ptregs.h b/include/machine/ptregs.h
new file mode 100644
index 0000000..b8cc54d
--- /dev/null
+++ b/include/machine/ptregs.h
@@ -0,0 +1,164 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+#ifndef __PTREGS_INCLUDED
+#define __PTREGS_INCLUDED
+
+/**
+*** Structure describing the Lx context layout.
+**/
+
+/*
+** static char sccs_id[] = "@(#)ptregs.h	1.8 01/28/00 18:15:37";
+*/
+
+/**
+*** Authors: Geoffrey Brown and Paolo Faraboschi
+**/
+
+#include <sys/types.h>
+#include <machine/reg_usage.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef __MINGW32__
+typedef unsigned int uint;
+#endif
+
+#ifdef __STDC__
+#define NAMECAT(a,b) a##b
+#else
+#define NAMECAT(a,b)a/**/b
+#endif
+#define REG(n) NAMECAT(reg_r,n)
+
+/**
+*** Macros to access the register context structure
+***
+***	(uint) RNOFF(REG)
+***		Returns the offset of the field named reg_<REG> in the
+***		regcontext structure. Used by lx_debug for random access 
+***		to a reg (with a variable number)
+***
+***	(uint*) USER_REGS(context* p)
+***		Returns a pointer to the the beginning of the 
+***		user register space in the regcontext
+***		structure pointed to by p
+***
+**/
+#define RNOFF(reg)   ( (uint) &(((regcontext*)0)->REG(reg)) )
+#define USER_REGS(p) ( (uint *) ((uint)(p) + RNOFF(USER0_REG)) )
+
+typedef struct saved_regs {
+
+  /**
+  *** Registers saved and restored in a "core" context switch
+  **/
+
+  uint REG(STACK_PTR_REG);	/* stack pointer (must be first) */
+  uint pc;									/* program counter */
+  uint REG(LINK_REG); 			/* link register */
+  uint bbits;    						/* branch bits */
+  uint psw;      						/* psw  */
+
+  uint REG(KERN0_REG);
+  uint REG(KERN1_REG);
+  uint REG(KERN2_REG);
+  uint REG(KERN3_REG);
+  uint REG(KERN4_REG);
+  uint REG(KERN5_REG);
+  uint REG(KERN6_REG);
+  uint REG(KERN7_REG);
+  uint REG(KERN8_REG);
+  uint REG(KERN9_REG);
+  uint REG(KERN10_REG);
+  uint REG(KERN11_REG);
+  uint REG(KERN12_REG);
+  uint REG(KERN13_REG);
+
+  /**
+  *** Registers saved and restored in a "long" context switch
+  **/
+
+  uint REG(USER0_REG);
+  uint REG(USER1_REG);
+  uint REG(USER2_REG);
+  uint REG(USER3_REG);
+  uint REG(USER4_REG);
+  uint REG(USER5_REG);
+  uint REG(USER6_REG);
+  uint REG(USER7_REG);
+  uint REG(USER8_REG);
+  uint REG(USER9_REG);
+
+  uint REG(USER10_REG);
+  uint REG(USER11_REG);
+  uint REG(USER12_REG);
+  uint REG(USER13_REG);
+  uint REG(USER14_REG);
+  uint REG(USER15_REG);
+  uint REG(USER16_REG);
+  uint REG(USER17_REG);
+  uint REG(USER18_REG);
+  uint REG(USER19_REG);
+
+  uint REG(USER20_REG);
+  uint REG(USER21_REG);
+  uint REG(USER22_REG);
+  uint REG(USER23_REG);
+  uint REG(USER24_REG);
+  uint REG(USER25_REG);
+  uint REG(USER26_REG);
+  uint REG(USER27_REG);
+  uint REG(USER28_REG);
+  uint REG(USER29_REG);
+
+  uint REG(USER30_REG);
+  uint REG(USER31_REG);
+  uint REG(USER32_REG);
+  uint REG(USER33_REG);
+  uint REG(USER34_REG);
+  uint REG(USER35_REG);
+  uint REG(USER36_REG);
+  uint REG(USER37_REG);
+  uint REG(USER38_REG);
+  uint REG(USER39_REG);
+
+  uint REG(USER40_REG);
+  uint REG(USER41_REG);
+  uint REG(USER42_REG);
+  uint REG(USER43_REG);
+  uint REG(USER44_REG);
+  uint REG(USER45_REG);
+  uint REG(USER46_REG);
+/* <PB> */
+/* added to allow call of _sys_do_exception from OS21 */
+	uint REG(LX_SAVED_SAVED_PSW_REG);
+	uint REG(LX_SAVED_SAVED_PC_REG);
+	uint REG(LX_EXCAUSE_REG);
+	uint REG(LX_EXADDRESS_REG);
+	uint REG(LX_TLBCAUSE_REG);
+/* </PB> */
+
+} regcontext;
+
+typedef struct sigcontext_struct {
+  struct saved_regs *regs;       /* pointer to register structure    */
+  int signr;                     /* signal number                    */
+  uint excause;          	/* machine exception cause          */
+  uint exaddress;        	/* machine exception exaddress;     */
+  uint oldmask;          	/* old signal mask                  */
+  /*  uint trampoline[2]; */   /* here's where the tramp code goes */
+} sigcontext;
+
+extern regcontext* _current_wptr;  /* defined in crt0.c */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PTREGS_INCLUDED */
+
diff --git a/include/machine/reg_usage.h b/include/machine/reg_usage.h
new file mode 100644
index 0000000..f02a6c4
--- /dev/null
+++ b/include/machine/reg_usage.h
@@ -0,0 +1,322 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+***
+*** --------------------------------------------------
+***                *** DO NOT EDIT ***
+***  This file was automatically generated by machgen
+*** --------------------------------------------------
+**/
+/**
+*** Runtime architecture definitions (register usage, etc.)
+*** Compatibility: LxBE
+*** Model: Embedded (non-PIC)
+**/
+
+#ifndef __LX_RTA_INCLUDED
+#define __LX_RTA_INCLUDED
+
+/* Special registers */
+#define STACK_PTR_REG 12
+#define STACK_PTR_RG $r0.12
+#define LINK_REG 63
+#define LINK_RG $r0.63
+#define RVP_REG 15
+#define RVP_RG $r0.15
+
+/* Branch Registers */
+#define BR0_REG 0
+#define BR0_RG $b0.0
+#define BR1_REG 1
+#define BR1_RG $b0.1
+#define BR2_REG 2
+#define BR2_RG $b0.2
+#define BR3_REG 3
+#define BR3_RG $b0.3
+#define BR4_REG 4
+#define BR4_RG $b0.4
+#define BR5_REG 5
+#define BR5_RG $b0.5
+#define BR6_REG 6
+#define BR6_RG $b0.6
+#define BR7_REG 7
+#define BR7_RG $b0.7
+
+/* Argument registers */
+#define ARG0_REG 16
+#define ARG0_RG $r0.16
+#define ARG1_REG 17
+#define ARG1_RG $r0.17
+#define ARG2_REG 18
+#define ARG2_RG $r0.18
+#define ARG3_REG 19
+#define ARG3_RG $r0.19
+#define ARG4_REG 20
+#define ARG4_RG $r0.20
+#define ARG5_REG 21
+#define ARG5_RG $r0.21
+#define ARG6_REG 22
+#define ARG6_RG $r0.22
+#define ARG7_REG 23
+#define ARG7_RG $r0.23
+
+/* Other Scratch (Non Argument) Registers */
+#define SCR0_REG 8
+#define SCR0_RG $r0.8
+#define SCR1_REG 9
+#define SCR1_RG $r0.9
+#define SCR2_REG 10
+#define SCR2_RG $r0.10
+#define SCR3_REG 11
+#define SCR3_RG $r0.11
+#define SCR4_REG 24
+#define SCR4_RG $r0.24
+#define SCR5_REG 25
+#define SCR5_RG $r0.25
+#define SCR6_REG 26
+#define SCR6_RG $r0.26
+#define SCR7_REG 27
+#define SCR7_RG $r0.27
+#define SCR8_REG 28
+#define SCR8_RG $r0.28
+#define SCR9_REG 29
+#define SCR9_RG $r0.29
+#define SCR10_REG 30
+#define SCR10_RG $r0.30
+#define SCR11_REG 31
+#define SCR11_RG $r0.31
+#define SCR12_REG 32
+#define SCR12_RG $r0.32
+#define SCR13_REG 33
+#define SCR13_RG $r0.33
+#define SCR14_REG 34
+#define SCR14_RG $r0.34
+#define SCR15_REG 35
+#define SCR15_RG $r0.35
+#define SCR16_REG 36
+#define SCR16_RG $r0.36
+#define SCR17_REG 37
+#define SCR17_RG $r0.37
+#define SCR18_REG 38
+#define SCR18_RG $r0.38
+#define SCR19_REG 39
+#define SCR19_RG $r0.39
+#define SCR20_REG 40
+#define SCR20_RG $r0.40
+#define SCR21_REG 41
+#define SCR21_RG $r0.41
+#define SCR22_REG 42
+#define SCR22_RG $r0.42
+#define SCR23_REG 43
+#define SCR23_RG $r0.43
+#define SCR24_REG 44
+#define SCR24_RG $r0.44
+#define SCR25_REG 45
+#define SCR25_RG $r0.45
+#define SCR26_REG 46
+#define SCR26_RG $r0.46
+#define SCR27_REG 47
+#define SCR27_RG $r0.47
+#define SCR28_REG 48
+#define SCR28_RG $r0.48
+#define SCR29_REG 49
+#define SCR29_RG $r0.49
+#define SCR30_REG 50
+#define SCR30_RG $r0.50
+#define SCR31_REG 51
+#define SCR31_RG $r0.51
+#define SCR32_REG 52
+#define SCR32_RG $r0.52
+#define SCR33_REG 53
+#define SCR33_RG $r0.53
+#define SCR34_REG 54
+#define SCR34_RG $r0.54
+#define SCR35_REG 55
+#define SCR35_RG $r0.55
+#define SCR36_REG 56
+#define SCR36_RG $r0.56
+#define SCR37_REG 57
+#define SCR37_RG $r0.57
+#define SCR38_REG 58
+#define SCR38_RG $r0.58
+#define SCR39_REG 59
+#define SCR39_RG $r0.59
+#define SCR40_REG 60
+#define SCR40_RG $r0.60
+#define SCR41_REG 61
+#define SCR41_RG $r0.61
+#define SCR42_REG 62
+#define SCR42_RG $r0.62
+
+/* Preserved Registers */
+#define PRE0_REG 1
+#define PRE0_RG $r0.1
+#define PRE1_REG 2
+#define PRE1_RG $r0.2
+#define PRE2_REG 3
+#define PRE2_RG $r0.3
+#define PRE3_REG 4
+#define PRE3_RG $r0.4
+#define PRE4_REG 5
+#define PRE4_RG $r0.5
+#define PRE5_REG 6
+#define PRE5_RG $r0.6
+#define PRE6_REG 7
+#define PRE6_RG $r0.7
+#define PRE7_REG 13
+#define PRE7_RG $r0.13
+#define PRE8_REG 14
+#define PRE8_RG $r0.14
+#define PRE_REG_COUNT 9
+    /* Preserved: 9 */
+
+/* Kernel/User mode registers */
+#define USER0_REG 1
+#define USER0_RG $r0.1
+#define USER1_REG 2
+#define USER1_RG $r0.2
+#define USER2_REG 3
+#define USER2_RG $r0.3
+#define USER3_REG 4
+#define USER3_RG $r0.4
+#define USER4_REG 5
+#define USER4_RG $r0.5
+#define USER5_REG 6
+#define USER5_RG $r0.6
+#define USER6_REG 7
+#define USER6_RG $r0.7
+#define USER7_REG 8
+#define USER7_RG $r0.8
+#define USER8_REG 9
+#define USER8_RG $r0.9
+#define USER9_REG 10
+#define USER9_RG $r0.10
+#define USER10_REG 11
+#define USER10_RG $r0.11
+#define USER11_REG 13
+#define USER11_RG $r0.13
+#define KERN0_REG 14
+#define KERN0_RG $r0.14
+#define KERN1_REG 15
+#define KERN1_RG $r0.15
+#define KERN2_REG 16
+#define KERN2_RG $r0.16
+#define KERN3_REG 17
+#define KERN3_RG $r0.17
+#define KERN4_REG 18
+#define KERN4_RG $r0.18
+#define KERN5_REG 19
+#define KERN5_RG $r0.19
+#define KERN6_REG 20
+#define KERN6_RG $r0.20
+#define KERN7_REG 21
+#define KERN7_RG $r0.21
+#define KERN8_REG 22
+#define KERN8_RG $r0.22
+#define KERN9_REG 23
+#define KERN9_RG $r0.23
+#define KERN10_REG 24
+#define KERN10_RG $r0.24
+#define KERN11_REG 25
+#define KERN11_RG $r0.25
+#define KERN12_REG 26
+#define KERN12_RG $r0.26
+#define KERN13_REG 27
+#define KERN13_RG $r0.27
+#define USER12_REG 28
+#define USER12_RG $r0.28
+#define USER13_REG 29
+#define USER13_RG $r0.29
+#define USER14_REG 30
+#define USER14_RG $r0.30
+#define USER15_REG 31
+#define USER15_RG $r0.31
+#define USER16_REG 32
+#define USER16_RG $r0.32
+#define USER17_REG 33
+#define USER17_RG $r0.33
+#define USER18_REG 34
+#define USER18_RG $r0.34
+#define USER19_REG 35
+#define USER19_RG $r0.35
+#define USER20_REG 36
+#define USER20_RG $r0.36
+#define USER21_REG 37
+#define USER21_RG $r0.37
+#define USER22_REG 38
+#define USER22_RG $r0.38
+#define USER23_REG 39
+#define USER23_RG $r0.39
+#define USER24_REG 40
+#define USER24_RG $r0.40
+#define USER25_REG 41
+#define USER25_RG $r0.41
+#define USER26_REG 42
+#define USER26_RG $r0.42
+#define USER27_REG 43
+#define USER27_RG $r0.43
+#define USER28_REG 44
+#define USER28_RG $r0.44
+#define USER29_REG 45
+#define USER29_RG $r0.45
+#define USER30_REG 46
+#define USER30_RG $r0.46
+#define USER31_REG 47
+#define USER31_RG $r0.47
+#define USER32_REG 48
+#define USER32_RG $r0.48
+#define USER33_REG 49
+#define USER33_RG $r0.49
+#define USER34_REG 50
+#define USER34_RG $r0.50
+#define USER35_REG 51
+#define USER35_RG $r0.51
+#define USER36_REG 52
+#define USER36_RG $r0.52
+#define USER37_REG 53
+#define USER37_RG $r0.53
+#define USER38_REG 54
+#define USER38_RG $r0.54
+#define USER39_REG 55
+#define USER39_RG $r0.55
+#define USER40_REG 56
+#define USER40_RG $r0.56
+#define USER41_REG 57
+#define USER41_RG $r0.57
+#define USER42_REG 58
+#define USER42_RG $r0.58
+#define USER43_REG 59
+#define USER43_RG $r0.59
+#define USER44_REG 60
+#define USER44_RG $r0.60
+#define USER45_REG 61
+#define USER45_RG $r0.61
+#define USER46_REG 62
+#define USER46_RG $r0.62
+#define KERN_REG_COUNT 14
+#define USER_REG_COUNT 47
+    /* Kernel: 14, User: 47 */
+
+/* Other Misc stuff */
+#define ZERO_REG 0
+#define ZERO_RG $r0.0
+#define WHICH_SYSCALL_REG 62
+#define WHICH_SYSCALL_RG $r0.62
+#define SYSCALL_TRAMP_REG 15
+#define SYSCALL_TRAMP_RG $r0.15
+#define SCRATCHAREASIZE 16
+
+#endif /* __LX_RTA_INCLUDED */
diff --git a/include/opcode/lx.h b/include/opcode/lx.h
new file mode 100644
index 0000000..5b63e6a
--- /dev/null
+++ b/include/opcode/lx.h
@@ -0,0 +1,1968 @@
+/**
+*** (c) Copyright STMicroelectronics, Inc. 1999-2005.
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+***
+*** --------------------------------------------------
+***                *** DO NOT EDIT ***
+***  This file was automatically generated by the
+***  Machine Description System (MDS) of STMicroelectronics, Inc.
+*** --------------------------------------------------
+**/
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+*/
+
+#ifndef OPCODE_LX_H
+#define OPCODE_LX_H
+
+#define LXMAXOPERANDS 5
+
+#define LXMAXBUNDLESIZE 4
+
+#define ST200_NCORES 4
+
+#define LXNUMBUNDLINGS 9
+
+#define st200_RESERVED_30_1_fld(x) (int)(((unsigned int)(x) >> 30) & 0x1)
+#define st200_RESERVED_21_2_fld(x) (int)(((unsigned int)(x) >> 21) & 0x3)
+#define st200_RESERVED_18_3_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_RESERVED_12_6_fld(x) (int)(((unsigned int)(x) >> 12) & 0x3f)
+#define st200_RESERVED_9_3_fld(x) (int)(((unsigned int)(x) >> 9) & 0x7)
+#define st200_RESERVED_0_21_fld(x) (int)((unsigned int)(x) & 0x1fffff)
+#define st200_STOPBIT_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_CMP_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_I_fld(x) (int)(((unsigned int)(x) >> 27) & 0x1)
+#define st200_B_fld(x) (int)(((unsigned int)(x) >> 25) & 0x1)
+#define st200_D_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1)
+#define st200_LNK_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1)
+#define st200_FMT_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_INT3_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x1f)
+#define st200_MONADIC_OPCODE_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_CMP3_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0xf)
+#define st200_IMMX_OPCODE_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_SLCT_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0x7)
+#define st200_CGEN_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0xf)
+#define st200_SYSOP_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_SBREAK_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_LOAD_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0xf)
+#define st200_STORE_OPCODE_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_CALL_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0x7)
+#define st200_BRANCH_OPCODE_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_BCOND_fld(x) (int)(((unsigned int)(x) >> 23) & 0x7)
+#define st200_BDEST_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_BDEST2_fld(x) (int)(((unsigned int)(x) >> 12) & 0x7)
+#define st200_BTARG_fld(x) (int)((unsigned int)(x) & 0x7fffff)
+#define st200_DEST_fld(x) (int)(((unsigned int)(x) >> 12) & 0x3f)
+#define st200_IBDEST_fld(x) (int)(((unsigned int)(x) >> 6) & 0x7)
+#define st200_IDEST_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_ISRC2_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_IMM_fld(x) (int)((unsigned int)(x) & 0x7fffff)
+#define st200_SCOND_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7)
+#define st200_SRC1_fld(x) (int)((unsigned int)(x) & 0x3f)
+#define st200_SRC2_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_SBRKNUM_fld(x) (int)((unsigned int)(x) & 0x1fffff)
+#define st200_IMMX_fld(x) (int)((unsigned int)(x) & 0x7fffff)
+#define st200_ENCODE_0_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_0_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_0_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_0_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_ENCODE_1_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_1_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_1_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_1_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_ENCODE_2_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_2_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_2_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_2_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_ENCODE_3_fld(x) (int)((unsigned int)(x) & 0x7fffffff)
+#define st200_STOPBIT_3_fld(x) (int)(((unsigned int)(x) >> 31) & 0x1)
+#define st200_FMT_3_fld(x) (int)(((unsigned int)(x) >> 28) & 0x3)
+#define st200_IMMX_OPCODE_3_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1f)
+#define st200_RESERVED_12_9_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_LOADL_OPCODE_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_STOREC_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0xf)
+#define st200_STOREL_OPCODE_fld(x) (int)(((unsigned int)(x) >> 15) & 0x3f)
+#define st200_LS_SUBOPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7)
+#define st200_MUL64_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x1f)
+#define st200_SYSTEM_OPCODE_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1ff)
+#define st200_RESERVED_15_3_fld(x) (int)(((unsigned int)(x) >> 15) & 0x7)
+#define st200_RESERVED_12_1_fld(x) (int)(((unsigned int)(x) >> 12) & 0x1)
+#define st200_RESERVED_6_6_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_RESERVED_3_9_fld(x) (int)(((unsigned int)(x) >> 3) & 0x1ff)
+#define st200_RESERVED_3_3_fld(x) (int)(((unsigned int)(x) >> 3) & 0x7)
+#define st200_PACKED_fld(x) (int)(((unsigned int)(x) >> 25) & 0x1)
+#define st200_PACKED_HALF_fld(x) (int)(((unsigned int)(x) >> 24) & 0x1)
+#define st200_FLOAT_FIXED0_fld(x) (int)(((unsigned int)(x) >> 26) & 0x3)
+#define st200_FLOAT_FIXED1_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_CMP3R_FIXED_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_BREAK_FIXED_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_SLCT_FIXED_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_WIDE_OPS_FIXED_fld(x) (int)(((unsigned int)(x) >> 26) & 0x1)
+#define st200_ASM_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7f)
+#define st200_SIMD_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x7)
+#define st200_INT3R_OPCODE_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_BDEST_OPCODE_fld(x) (int)(((unsigned int)(x) >> 15) & 0x3f)
+#define st200_IMMX_ISRIGHT_fld(x) (int)(((unsigned int)(x) >> 23) & 0x1)
+#define st200_SLCT_OPCODE3_fld(x) (int)(((unsigned int)(x) >> 24) & 0x3)
+#define st200_SLCT_OPCODE2_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_WIDE_OPS_OPCODE_fld(x) (int)(((unsigned int)(x) >> 24) & 0x3)
+#define st200_BREAK_OPCODE_fld(x) (int)(((unsigned int)(x) >> 18) & 0x7)
+#define st200_MEMSUB_OPCODE_fld(x) (int)(((unsigned int)(x) >> 6) & 0x3f)
+#define st200_FLOAT_OPCODE_fld(x) (int)(((unsigned int)(x) >> 21) & 0x1f)
+#define st200_BSRC1_fld(x) (int)((unsigned int)(x) & 0x7)
+#define st200_BSRC2_fld(x) (int)(((unsigned int)(x) >> 6) & 0x7)
+#define st200_BRKNUM_fld(x) (int)((unsigned int)(x) & 0xfff)
+
+#define st200_bcond_opd(w) (((unsigned int)(w) >> 23) & 0x7)
+#define st200_bdest_opd(w) (((unsigned int)(w) >> 18) & 0x7)
+#define st200_bdest2_opd(w) (((unsigned int)(w) >> 12) & 0x7)
+#define st200_btarg_opd(w) ((unsigned int)(w) & 0x7fffff)
+#define st200_dest_opd(w) (((unsigned int)(w) >> 12) & 0x3f)
+#define st200_nldest_opd(w) (((unsigned int)(w) >> 12) & 0x3f)
+#define st200_ibdest_opd(w) (((unsigned int)(w) >> 6) & 0x7)
+#define st200_idest_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_nlidest_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_isrc2_opd(w) (((unsigned int)(w) >> 12) & 0x1ff)
+#define st200_imm_opd(w) ((unsigned int)(w) & 0x7fffff)
+#define st200_scond_opd(w) (((unsigned int)(w) >> 21) & 0x7)
+#define st200_src1_opd(w) ((unsigned int)(w) & 0x3f)
+#define st200_src2_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_sbrknum_opd(w) ((unsigned int)(w) & 0x1fffff)
+#define st200_xsrc2_opd(w0,w1) ((((unsigned int)(w1) & 0x7fffff) << 9) | (((unsigned int)(w0) >> 12) & 0x1ff))
+#define st200_bsrc1_opd(w) ((unsigned int)(w) & 0x7)
+#define st200_bsrc2_opd(w) (((unsigned int)(w) >> 6) & 0x7)
+#define st200_idestp_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_pcond_opd(w) (((unsigned int)(w) >> 21) & 0x7)
+#define st200_src2p_opd(w) (((unsigned int)(w) >> 6) & 0x3f)
+#define st200_brknum_opd(w) ((unsigned int)(w) & 0xfff)
+
+
+#define st231_add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00000000)
+#define st231_add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st231_add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st231_addcg_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x12000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_addcg_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x12000000)
+#define st231_and_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_and_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01200000)
+#define st231_and_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_and_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st231_and_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_and_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_and_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st231_andc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_andc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01400000)
+#define st231_andc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_andc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st231_andc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_andc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_andc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st231_andl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_andl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05400000)
+#define st231_andl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07400000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_andl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07400000)
+#define st231_andl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_andl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d400000)
+#define st231_andl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_andl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f400000)
+#define st231_andl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_andl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_andl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d400000)
+#define st231_andl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_andl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_andl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f400000)
+#define st231_asm_0_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_0_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c000000)
+#define st231_asm_1_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_1_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c200000)
+#define st231_asm_2_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_2_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c400000)
+#define st231_asm_3_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_3_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c600000)
+#define st231_asm_4_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2c800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_4_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2c800000)
+#define st231_asm_5_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2ca00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_5_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2ca00000)
+#define st231_asm_6_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2cc00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_6_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2cc00000)
+#define st231_asm_7_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2ce00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_7_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2ce00000)
+#define st231_asm_8_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_8_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d000000)
+#define st231_asm_9_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_9_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d200000)
+#define st231_asm_10_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_10_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d400000)
+#define st231_asm_11_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_11_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d600000)
+#define st231_asm_12_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2d800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_12_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2d800000)
+#define st231_asm_13_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2da00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_13_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2da00000)
+#define st231_asm_14_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2dc00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_14_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2dc00000)
+#define st231_asm_15_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x2de00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_asm_15_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x2de00000)
+#define st231_asm_16_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_16_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e000000)
+#define st231_asm_16_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_16_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_16_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e000000)
+#define st231_asm_17_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_17_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e200000)
+#define st231_asm_17_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_17_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_17_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e200000)
+#define st231_asm_18_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_18_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e400000)
+#define st231_asm_18_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_18_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_18_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e400000)
+#define st231_asm_19_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_19_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e600000)
+#define st231_asm_19_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_19_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_19_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e600000)
+#define st231_asm_20_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2e800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_20_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e800000)
+#define st231_asm_20_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2e800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_20_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_20_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2e800000)
+#define st231_asm_21_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ea00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_21_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ea00000)
+#define st231_asm_21_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ea00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_21_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_21_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ea00000)
+#define st231_asm_22_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ec00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_22_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ec00000)
+#define st231_asm_22_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ec00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_22_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_22_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ec00000)
+#define st231_asm_23_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ee00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_23_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ee00000)
+#define st231_asm_23_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ee00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_23_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_23_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ee00000)
+#define st231_asm_24_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_24_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f000000)
+#define st231_asm_24_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_24_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_24_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f000000)
+#define st231_asm_25_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_25_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f200000)
+#define st231_asm_25_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_25_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_25_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f200000)
+#define st231_asm_26_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_26_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f400000)
+#define st231_asm_26_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_26_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_26_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f400000)
+#define st231_asm_27_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_27_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f600000)
+#define st231_asm_27_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_27_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_27_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f600000)
+#define st231_asm_28_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2f800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_28_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f800000)
+#define st231_asm_28_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2f800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_28_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_28_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2f800000)
+#define st231_asm_29_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fa00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_29_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st231_asm_29_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fa00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_29_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_29_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st231_asm_30_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2fc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_30_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fc00000)
+#define st231_asm_30_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2fc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_30_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_30_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fc00000)
+#define st231_asm_31_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_asm_31_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st231_asm_31_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_asm_31_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_asm_31_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st231_br_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x38000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_br_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x38000000)
+#define is_st231_break_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x1fe00000)
+#define st231_brf_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x3c000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_brf_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x3c000000)
+#define st231_bswap_idest_src1_insn(idest,src1) (unsigned int)(0x09c02000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_bswap_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c02000)
+#define st231_call_btarg_insn(btarg) (unsigned int)(0x30000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_call_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x30000000)
+#define is_st231_icall_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x30800000)
+#define st231_clz_idest_src1_insn(idest,src1) (unsigned int)(0x09c04000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_clz_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c04000)
+#define st231_cmpeq_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpeq_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04000000)
+#define st231_cmpeq_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06000000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpeq_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06000000)
+#define st231_cmpeq_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpeq_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st231_cmpeq_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpeq_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st231_cmpeq_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpeq_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpeq_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st231_cmpeq_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpeq_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpeq_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st231_cmpge_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpge_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st231_cmpge_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06400000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpge_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06400000)
+#define st231_cmpge_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpge_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st231_cmpge_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpge_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st231_cmpge_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpge_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpge_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st231_cmpge_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpge_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpge_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st231_cmpgeu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgeu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04600000)
+#define st231_cmpgeu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06600000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgeu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06600000)
+#define st231_cmpgeu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgeu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st231_cmpgeu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgeu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st231_cmpgeu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgeu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgeu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st231_cmpgeu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgeu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgeu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st231_cmpgt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st231_cmpgt_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgt_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06800000)
+#define st231_cmpgt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st231_cmpgt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st231_cmpgt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st231_cmpgt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st231_cmpgtu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgtu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04a00000)
+#define st231_cmpgtu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06a00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpgtu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06a00000)
+#define st231_cmpgtu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgtu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st231_cmpgtu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpgtu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st231_cmpgtu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgtu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgtu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st231_cmpgtu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpgtu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpgtu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st231_cmple_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmple_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st231_cmple_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06c00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmple_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06c00000)
+#define st231_cmple_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmple_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st231_cmple_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmple_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st231_cmple_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmple_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmple_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st231_cmple_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmple_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmple_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st231_cmpleu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpleu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st231_cmpleu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06e00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpleu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06e00000)
+#define st231_cmpleu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpleu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st231_cmpleu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpleu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st231_cmpleu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpleu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpleu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st231_cmpleu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpleu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpleu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st231_cmplt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmplt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st231_cmplt_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07000000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmplt_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07000000)
+#define st231_cmplt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmplt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st231_cmplt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmplt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st231_cmplt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmplt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmplt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st231_cmplt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmplt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmplt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st231_cmpltu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpltu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st231_cmpltu_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07200000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpltu_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07200000)
+#define st231_cmpltu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpltu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st231_cmpltu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpltu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st231_cmpltu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpltu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpltu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st231_cmpltu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpltu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpltu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st231_cmpne_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpne_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04200000)
+#define st231_cmpne_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x06200000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_cmpne_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x06200000)
+#define st231_cmpne_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpne_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st231_cmpne_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_cmpne_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st231_cmpne_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpne_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpne_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st231_cmpne_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_cmpne_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_cmpne_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st231_divs_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x14000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_divs_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x14000000)
+#define st231_goto_btarg_insn(btarg) (unsigned int)(0x31000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st231_goto_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x31000000)
+#define is_st231_igoto_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st231_imml_imm_insn(imm) (unsigned int)(0x15000000 | ((int)(imm) & 0x7fffff))
+#define is_st231_imml_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15000000)
+#define st231_immr_imm_insn(imm) (unsigned int)(0x15800000 | ((int)(imm) & 0x7fffff))
+#define is_st231_immr_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15800000)
+#define st231_ldb_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldb_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st231_ldb_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldb_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldb_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st231_ldb_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldb_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23800000)
+#define st231_ldb_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldb_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldb_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23800000)
+#define st231_ldbu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldbu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st231_ldbu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldbu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldbu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st231_ldbu_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldbu_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24800000)
+#define st231_ldbu_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldbu_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldbu_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24800000)
+#define st231_ldh_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x21000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldh_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st231_ldh_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldh_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldh_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st231_ldh_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x21800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldh_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21800000)
+#define st231_ldh_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x21800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldh_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldh_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21800000)
+#define st231_ldhu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldhu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st231_ldhu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldhu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldhu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st231_ldhu_d_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22800000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldhu_d_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22800000)
+#define st231_ldhu_d_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22800000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldhu_d_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldhu_d_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22800000)
+#define st231_ldw_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldw_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st231_ldw_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldw_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldw_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st231_ldw_d_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x20800000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_ldw_d_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20800000)
+#define st231_ldw_d_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x20800000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_ldw_d_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_ldw_d_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20800000)
+#define st231_ldwl_idest_src1_insn(idest,src1) (unsigned int)(0x2fe05000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_ldwl_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x2fe05000)
+#define st231_max_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_max_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02000000)
+#define st231_max_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_max_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st231_max_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_max_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_max_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st231_maxu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_maxu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02200000)
+#define st231_maxu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_maxu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st231_maxu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_maxu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_maxu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st231_min_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_min_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02400000)
+#define st231_min_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_min_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st231_min_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_min_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_min_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st231_minu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_minu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02600000)
+#define st231_minu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_minu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st231_minu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_minu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_minu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st231_mulh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02e00000)
+#define st231_mulh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ae00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ae00000)
+#define st231_mulh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ae00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ae00000)
+#define st231_mulhh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03a00000)
+#define st231_mulhh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ba00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ba00000)
+#define st231_mulhh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ba00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ba00000)
+#define st231_mulhhs_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhhs_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02800000)
+#define st231_mulhhs_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhhs_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st231_mulhhs_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhhs_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhhs_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st231_mulhhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03c00000)
+#define st231_mulhhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0bc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0bc00000)
+#define st231_mulhhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0bc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0bc00000)
+#define st231_mulhs_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhs_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03e00000)
+#define st231_mulhs_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhs_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st231_mulhs_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhs_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhs_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st231_mulhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03000000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03000000)
+#define st231_mulhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b000000)
+#define st231_mulhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b000000)
+#define st231_mull_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mull_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02a00000)
+#define st231_mull_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0aa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mull_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0aa00000)
+#define st231_mull_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0aa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mull_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mull_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0aa00000)
+#define st231_mullh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03600000)
+#define st231_mullh_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullh_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b600000)
+#define st231_mullh_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullh_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullh_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b600000)
+#define st231_mullhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03800000)
+#define st231_mullhu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullhu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b800000)
+#define st231_mullhu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullhu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullhu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b800000)
+#define st231_mullhus_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x01e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullhus_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01e00000)
+#define st231_mullhus_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullhus_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st231_mullhus_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullhus_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullhus_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st231_mulll_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulll_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03200000)
+#define st231_mulll_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulll_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st231_mulll_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulll_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulll_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st231_mulllu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03400000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulllu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03400000)
+#define st231_mulllu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulllu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st231_mulllu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulllu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulllu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st231_mullu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mullu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02c00000)
+#define st231_mullu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mullu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st231_mullu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mullu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mullu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st231_mul32_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x05c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mul32_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05c00000)
+#define st231_mul32_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0dc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mul32_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0dc00000)
+#define st231_mul32_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0dc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mul32_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mul32_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0dc00000)
+#define st231_mul64h_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x05e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mul64h_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05e00000)
+#define st231_mul64h_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0de00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mul64h_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0de00000)
+#define st231_mul64h_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0de00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mul64h_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mul64h_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0de00000)
+#define st231_mul64hu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x07c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mul64hu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x07c00000)
+#define st231_mul64hu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0fc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mul64hu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fc00000)
+#define st231_mul64hu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0fc00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mul64hu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mul64hu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fc00000)
+#define st231_mulfrac_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x07e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mulfrac_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x07e00000)
+#define st231_mulfrac_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0fe00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mulfrac_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fe00000)
+#define st231_mulfrac_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0fe00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mulfrac_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mulfrac_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0fe00000)
+#define st231_nandl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_nandl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05600000)
+#define st231_nandl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07600000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_nandl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07600000)
+#define st231_nandl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_nandl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d600000)
+#define st231_nandl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_nandl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f600000)
+#define st231_nandl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_nandl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_nandl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d600000)
+#define st231_nandl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_nandl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_nandl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f600000)
+#define st231_norl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_norl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05a00000)
+#define st231_norl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07a00000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_norl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07a00000)
+#define st231_norl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_norl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0da00000)
+#define st231_norl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0fa00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_norl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0fa00000)
+#define st231_norl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_norl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_norl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0da00000)
+#define st231_norl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0fa00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_norl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_norl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0fa00000)
+#define st231_or_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_or_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01600000)
+#define st231_or_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_or_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st231_or_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_or_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_or_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st231_orc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_orc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01800000)
+#define st231_orc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_orc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09800000)
+#define st231_orc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_orc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_orc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09800000)
+#define st231_orl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_orl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05800000)
+#define st231_orl_bdest_src1_src2_insn(bdest,src1,src2) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_orl_bdest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe3f000) == 0x07800000)
+#define st231_orl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_orl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d800000)
+#define st231_orl_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_orl_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f800000)
+#define st231_orl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_orl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_orl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d800000)
+#define st231_orl_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_orl_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_orl_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f800000)
+#define st231_pft_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x26800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_pft_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x26800000)
+#define st231_pft_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x26800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_pft_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_pft_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x26800000)
+#define st231_prgadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x27000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_prgadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27000000)
+#define st231_prgadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x27000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_prgadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_prgadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27000000)
+#define is_st231_prgins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x1f800000)
+#define st231_prginspg_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x28800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_prginspg_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x28800000)
+#define st231_prginspg_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x28800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_prginspg_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_prginspg_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x28800000)
+#define st231_prgset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x27800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_prgset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27800000)
+#define st231_prgset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x27800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_prgset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_prgset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x27800000)
+#define st231_pswclr_src2_insn(src2) (unsigned int)(0x29800000 | (((int)(src2) & 0x3f) << 6))
+#define is_st231_pswclr_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffff03f) == 0x29800000)
+#define st231_pswset_src2_insn(src2) (unsigned int)(0x29000000 | (((int)(src2) & 0x3f) << 6))
+#define is_st231_pswset_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffff03f) == 0x29000000)
+#define is_st231_rfi_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x32000000)
+#define st231_sbrk_sbrknum_insn(sbrknum) (unsigned int)(0x9fa00000 | ((int)(sbrknum) & 0x1fffff))
+#define is_st231_sbrk_sbrknum_insn(x) (int)(((unsigned int)(x) & 0xffe00000) == 0x9fa00000)
+#define st231_sh1add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh1add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00a00000)
+#define st231_sh1add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh1add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st231_sh1add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh1add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh1add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st231_sh2add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh2add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00c00000)
+#define st231_sh2add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh2add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st231_sh2add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh2add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh2add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st231_sh3add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh3add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00e00000)
+#define st231_sh3add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh3add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st231_sh3add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh3add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh3add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st231_sh4add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sh4add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01000000)
+#define st231_sh4add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_sh4add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09000000)
+#define st231_sh4add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_sh4add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sh4add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09000000)
+#define st231_shl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_shl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00400000)
+#define st231_shl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_shl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st231_shl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_shl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_shl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st231_shr_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_shr_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00600000)
+#define st231_shr_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_shr_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st231_shr_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_shr_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_shr_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st231_shru_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_shru_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00800000)
+#define st231_shru_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_shru_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st231_shru_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_shru_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_shru_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st231_slct_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x10000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_slct_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x10000000)
+#define st231_slct_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x18000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_slct_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x18000000)
+#define st231_slct_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x18000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_slct_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_slct_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x18000000)
+#define st231_slctf_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x11000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_slctf_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x11000000)
+#define st231_slctf_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x19000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_slctf_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x19000000)
+#define st231_slctf_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x19000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_slctf_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_slctf_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x19000000)
+#define st231_stb_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x26000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_stb_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x26000000)
+#define st231_stb_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x26000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st231_stb_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_stb_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x26000000)
+#define st231_sth_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x25800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_sth_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25800000)
+#define st231_sth_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x25800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st231_sth_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sth_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25800000)
+#define st231_stw_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x25000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_stw_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st231_stw_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x25000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st231_stw_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_stw_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st231_stwl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x2ff00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_stwl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x2ff00000)
+#define st231_sub_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x00200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_sub_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00200000)
+#define st231_sub_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st231_sub_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st231_sub_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st231_sub_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_sub_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st231_sxtb_idest_src1_insn(idest,src1) (unsigned int)(0x09c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_sxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c00000)
+#define st231_sxth_idest_src1_insn(idest,src1) (unsigned int)(0x09c01000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_sxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c01000)
+#define is_st231_sync_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x28000000)
+#define st231_syscall_sbrknum_insn(sbrknum) (unsigned int)(0x1fc00000 | ((int)(sbrknum) & 0x1fffff))
+#define is_st231_syscall_sbrknum_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1fc00000)
+#define is_st231_wmb_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe03000)
+#define st231_xor_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_xor_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01a00000)
+#define st231_xor_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_xor_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st231_xor_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_xor_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_xor_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st231_zxth_idest_src1_insn(idest,src1) (unsigned int)(0x09c03000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_zxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c03000)
+#define st231_convbi_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_convbi_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st231_convib_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st231_convib_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define st231_mov_bsrc_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_mov_bsrc_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st231_mov_bdest_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st231_mov_bdest_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define is_st231_nop_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x00000000)
+#define st231_mov_dest_src2_insn(dest,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6))
+#define is_st231_mov_dest_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc003f) == 0x00000000)
+#define st231_mov_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st231_mov_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st231_mov_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st231_mov_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st231_mov_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st231_mtb_bdest_src1_insn(bdest,src1) (unsigned int)(0x07800000 | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f))
+#define is_st231_mtb_bdest_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe3ffc0) == 0x07800000)
+#define st231_mfb_idest_scond_insn(idest,scond) (unsigned int)(0x19001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st231_mfb_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x19001000)
+#define st231_zxtb_idest_src1_insn(idest,src1) (unsigned int)(0x092ff000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st231_zxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x092ff000)
+#define is_st231_syncins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x29000000)
+#define is_st231_idle_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31000000)
+#define is_st231_return_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st240_add_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_add_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13040000)
+#define st240_adds_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02b00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_adds_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02b00000)
+#define st240_abss_ph_dest_src1_insn(dest,src1) (unsigned int)(0x13240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_abss_ph_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x13240000)
+#define st240_max_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13440000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_max_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13440000)
+#define st240_min_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13640000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_min_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13640000)
+#define st240_mul_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13840000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13840000)
+#define st240_muladd_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13a40000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_muladd_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13a40000)
+#define st240_mulfracadds_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13680000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfracadds_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13680000)
+#define st240_mulfracrm_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13c40000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfracrm_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13c40000)
+#define st240_mulfracrne_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13e40000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfracrne_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13e40000)
+#define st240_shl_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shl_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13000000)
+#define st240_shl_ph_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x1b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shl_ph_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b000000)
+#define st240_shl_ph_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x1b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shl_ph_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shl_ph_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b000000)
+#define st240_shls_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shls_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13200000)
+#define st240_shls_ph_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x1b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shls_ph_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b200000)
+#define st240_shls_ph_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x1b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shls_ph_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shls_ph_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b200000)
+#define st240_shr_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shr_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13400000)
+#define st240_shr_ph_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x1b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shr_ph_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b400000)
+#define st240_shr_ph_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x1b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shr_ph_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shr_ph_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b400000)
+#define st240_shrrnp_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shrrnp_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13600000)
+#define st240_shrrnp_ph_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x1b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shrrnp_ph_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b600000)
+#define st240_shrrnp_ph_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x1b600000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shrrnp_ph_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shrrnp_ph_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b600000)
+#define st240_shrrne_ph_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x13800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shrrne_ph_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13800000)
+#define st240_shrrne_ph_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x1b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shrrne_ph_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b800000)
+#define st240_shrrne_ph_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x1b800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shrrne_ph_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shrrne_ph_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1b800000)
+#define st240_sub_ph_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x13480000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sub_ph_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13480000)
+#define st240_subs_ph_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02d00000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_subs_ph_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02d00000)
+#define st240_shuff_pbh_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_pbh_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12040000)
+#define st240_shuff_pbl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_pbl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12240000)
+#define st240_shuff_phh_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13080000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_phh_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13080000)
+#define st240_shuff_phl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13280000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuff_phl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13280000)
+#define st240_shuffodd_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12440000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuffodd_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12440000)
+#define st240_shuffeve_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12640000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shuffeve_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12640000)
+#define st240_perm_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_perm_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12000000)
+#define st240_perm_pb_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x1a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_perm_pb_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1a000000)
+#define st240_perm_pb_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x1a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_perm_pb_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_perm_pb_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x1a000000)
+#define st240_ext1_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12840000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_ext1_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12840000)
+#define st240_ext2_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12a40000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_ext2_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12a40000)
+#define st240_ext3_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12c40000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_ext3_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12c40000)
+#define st240_packsu_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12e40000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_packsu_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12e40000)
+#define st240_pack_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12680000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_pack_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12680000)
+#define st240_packrnp_phh_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13c80000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_packrnp_phh_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13c80000)
+#define st240_packs_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13e80000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_packs_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13e80000)
+#define st240_cmpeq_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05040000)
+#define st240_cmpgt_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgt_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05240000)
+#define st240_sadu_pb_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x12080000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sadu_pb_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12080000)
+#define st240_absubu_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x12280000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_absubu_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12280000)
+#define st240_muladdus_pb_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x12480000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_muladdus_pb_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x12480000)
+#define st240_avg4u_pb_nldest_scond_src1_src2_insn(nldest,scond,src1,src2) (unsigned int)(0x17140000 | (((int)(nldest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_avg4u_pb_nldest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x17140000)
+#define st240_avgu_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x17100000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_avgu_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x17100000)
+#define st240_cmpeq_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04040000)
+#define st240_cmpgtu_pb_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04440000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtu_pb_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04440000)
+#define st240_slct_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x16000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_slct_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16000000)
+#define st240_slct_pb_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1e000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slct_pb_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x1e000000)
+#define st240_slct_pb_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1e000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slct_pb_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slct_pb_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x1e000000)
+#define st240_slctf_pb_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1f000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slctf_pb_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1f000000)
+#define st240_slctf_pb_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1f000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slctf_pb_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slctf_pb_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1f000000)
+#define st240_cmpeq_ph_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07040000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_ph_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07040000)
+#define st240_cmpeq_pb_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06040000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_pb_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06040000)
+#define st240_cmpgt_ph_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07240000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgt_ph_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07240000)
+#define st240_cmpgtu_pb_bdest_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06240000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtu_pb_bdest_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06240000)
+#define st240_mov_bdest_bdest2_src1_insn(bdest2,src1) (unsigned int)(0x07c00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_mov_bdest_bdest2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8fc0) == 0x07c00000)
+#define st240_mov_bsrc_dest_scond_insn(dest,scond) (unsigned int)(0x17040000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21))
+#define is_st240_mov_bsrc_dest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1c0fff) == 0x17040000)
+#define st240_extl_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x17080000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_extl_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x17080000)
+#define st240_extr_pb_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x170c0000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_extr_pb_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x170c0000)
+#define st240_add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00000000)
+#define st240_add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st240_add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08000000)
+#define st240_addcg_dest_bdest_src1_src2_scond_insn(dest,bdest,src1,src2,scond) (unsigned int)(0x14000000 | (((int)(dest) & 0x3f) << 12) | (((int)(bdest) & 0x7) << 18) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st240_addcg_dest_bdest_src1_src2_scond_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x14000000)
+#define st240_addf_n_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02080000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_addf_n_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02080000)
+#define st240_addpc_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_addpc_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x09000000)
+#define st240_addpc_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x09000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_addpc_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_addpc_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x09000000)
+#define st240_adds_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02100000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_adds_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02100000)
+#define st240_addso_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x03100000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_addso_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03100000)
+#define st240_and_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_and_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01200000)
+#define st240_and_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_and_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st240_and_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_and_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_and_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09200000)
+#define st240_andl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06008000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_andl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06008000)
+#define st240_andc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_andc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01400000)
+#define st240_andc_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_andc_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st240_andc_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_andc_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_andc_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09400000)
+#define st240_andl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_andl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05400000)
+#define st240_andl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07400000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_andl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07400000)
+#define st240_asm_0_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_0_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26000000)
+#define st240_asm_1_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_1_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26200000)
+#define st240_asm_2_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_2_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26400000)
+#define st240_asm_3_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_3_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26600000)
+#define st240_asm_4_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_4_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26800000)
+#define st240_asm_5_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_5_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26a00000)
+#define st240_asm_6_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_6_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26c00000)
+#define st240_asm_7_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x26e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_7_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x26e00000)
+#define st240_asm_8_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_8_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27000000)
+#define st240_asm_9_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_9_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27200000)
+#define st240_asm_10_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_10_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27400000)
+#define st240_asm_11_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_11_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27600000)
+#define st240_asm_12_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_12_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27800000)
+#define st240_asm_13_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_13_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27a00000)
+#define st240_asm_14_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_14_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27c00000)
+#define st240_asm_15_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x27e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_asm_15_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x27e00000)
+#define st240_asm_16_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_16_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b000000)
+#define st240_asm_16_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_16_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_16_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b000000)
+#define st240_asm_17_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_17_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b200000)
+#define st240_asm_17_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_17_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_17_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b200000)
+#define st240_asm_18_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_18_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b400000)
+#define st240_asm_18_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_18_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_18_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b400000)
+#define st240_asm_19_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_19_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b600000)
+#define st240_asm_19_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_19_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_19_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b600000)
+#define st240_asm_20_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2b800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_20_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b800000)
+#define st240_asm_20_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2b800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_20_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_20_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2b800000)
+#define st240_asm_21_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2ba00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_21_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ba00000)
+#define st240_asm_21_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2ba00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_21_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_21_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2ba00000)
+#define st240_asm_22_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2bc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_22_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2bc00000)
+#define st240_asm_22_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2bc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_22_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_22_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2bc00000)
+#define st240_asm_23_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_23_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st240_asm_23_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2be00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_23_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_23_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2be00000)
+#define st240_asm_24_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_24_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d000000)
+#define st240_asm_24_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_24_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_24_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d000000)
+#define st240_asm_25_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_25_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d200000)
+#define st240_asm_25_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_25_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_25_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d200000)
+#define st240_asm_26_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_26_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d400000)
+#define st240_asm_26_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_26_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_26_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d400000)
+#define st240_asm_27_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_27_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d600000)
+#define st240_asm_27_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_27_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_27_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d600000)
+#define st240_asm_28_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_28_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d800000)
+#define st240_asm_28_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2d800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_28_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_28_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2d800000)
+#define st240_asm_29_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_29_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2da00000)
+#define st240_asm_29_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2da00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_29_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_29_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2da00000)
+#define st240_asm_30_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2dc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_30_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2dc00000)
+#define st240_asm_30_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2dc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_30_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_30_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2dc00000)
+#define st240_asm_31_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x2de00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_asm_31_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2de00000)
+#define st240_asm_31_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x2de00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_asm_31_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_asm_31_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2de00000)
+#define st240_br_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x38000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_br_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x38000000)
+#define is_st240_break_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe0b000)
+#define st240_brf_bcond_btarg_insn(bcond,btarg) (unsigned int)(0x3c000000 | (((int)(bcond) & 0x7) << 23) | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_brf_bcond_btarg_insn(x) (int)(((unsigned int)(x) & 0x7c000000) == 0x3c000000)
+#define st240_call_btarg_insn(btarg) (unsigned int)(0x30000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_call_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x30000000)
+#define is_st240_icall_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x30800000)
+#define st240_clz_idest_src1_insn(idest,src1) (unsigned int)(0x09c04000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_clz_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x09c04000)
+#define st240_cmpeq_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04000000)
+#define st240_cmpeq_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpeq_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st240_cmpeq_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06000000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeq_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06000000)
+#define st240_cmpeq_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpeq_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st240_cmpeq_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpeq_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpeq_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c000000)
+#define st240_cmpeq_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpeq_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpeq_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e000000)
+#define st240_cmpeqf_n_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeqf_n_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04600000)
+#define st240_cmpeqf_n_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06600000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpeqf_n_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06600000)
+#define st240_cmpge_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpge_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st240_cmpge_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpge_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st240_cmpge_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpge_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpge_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c400000)
+#define st240_cmpge_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e400000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpge_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpge_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e400000)
+#define st240_cmpgef_n_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgef_n_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st240_cmpgef_n_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06400000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgef_n_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06400000)
+#define st240_cmpgeu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgeu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st240_cmpgeu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgeu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st240_cmpgeu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgeu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgeu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c600000)
+#define st240_cmpgeu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e600000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgeu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgeu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e600000)
+#define st240_cmpgt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st240_cmpgt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st240_cmpgt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c800000)
+#define st240_cmpgt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e800000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e800000)
+#define st240_cmpgtf_n_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtf_n_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st240_cmpgtf_n_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpgtf_n_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06800000)
+#define st240_cmpgtu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgtu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st240_cmpgtu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpgtu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st240_cmpgtu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ca00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgtu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgtu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ca00000)
+#define st240_cmpgtu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ea00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpgtu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpgtu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ea00000)
+#define st240_cmple_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmple_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st240_cmple_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmple_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st240_cmple_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06c00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmple_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06c00000)
+#define st240_cmple_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmple_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st240_cmple_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0cc00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmple_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmple_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0cc00000)
+#define st240_cmple_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ec00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmple_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmple_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ec00000)
+#define st240_cmpleu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpleu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st240_cmpleu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpleu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st240_cmpleu_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06e00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpleu_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06e00000)
+#define st240_cmpleu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpleu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st240_cmpleu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0ce00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpleu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpleu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ce00000)
+#define st240_cmpleu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0ee00000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpleu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpleu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0ee00000)
+#define st240_cmplt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmplt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st240_cmplt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmplt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st240_cmplt_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07000000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmplt_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07000000)
+#define st240_cmplt_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmplt_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st240_cmplt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmplt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmplt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d000000)
+#define st240_cmplt_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f000000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmplt_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmplt_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f000000)
+#define st240_cmpltu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpltu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st240_cmpltu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpltu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st240_cmpltu_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07200000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpltu_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07200000)
+#define st240_cmpltu_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpltu_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st240_cmpltu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0d200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpltu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpltu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0d200000)
+#define st240_cmpltu_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0f200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpltu_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpltu_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0f200000)
+#define st240_cmpne_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x04200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpne_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04200000)
+#define st240_cmpne_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpne_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st240_cmpne_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x06200000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_cmpne_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06200000)
+#define st240_cmpne_ibdest_src1_isrc2_insn(ibdest,src1,isrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_cmpne_ibdest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st240_cmpne_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0c200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpne_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpne_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0c200000)
+#define st240_cmpne_ibdest_src1_xsrc2_insn_0(ibdest,src1,xsrc2) (unsigned int)(0x0e200000 | (((int)(ibdest) & 0x7) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_cmpne_ibdest_src1_xsrc2_insn_1(ibdest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_cmpne_ibdest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00e00) == 0x0e200000)
+#define st240_convfi_n_nldest_src1_insn(nldest,src1) (unsigned int)(0x02880000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_convfi_n_nldest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x02880000)
+#define st240_convif_n_nldest_src1_insn(nldest,src1) (unsigned int)(0x02680000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_convif_n_nldest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x02680000)
+#define st240_dbgsbrk_brknum_insn(brknum) (unsigned int)(0xafe08000 | ((int)(brknum) & 0xfff))
+#define is_st240_dbgsbrk_brknum_insn(x) (int)(((unsigned int)(x) & 0xfffff000) == 0xafe08000)
+#define is_st240_dib_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe06000)
+#define st240_div_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03080000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_div_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03080000)
+#define st240_divu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03480000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_divu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03480000)
+#define st240_extract_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extract_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18600000)
+#define st240_extract_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extract_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extract_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18600000)
+#define st240_extractu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extractu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18800000)
+#define st240_extractu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extractu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extractu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18800000)
+#define st240_extractl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x19600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extractl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19600000)
+#define st240_extractl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x19600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extractl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extractl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19600000)
+#define st240_extractlu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x19800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_extractlu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19800000)
+#define st240_extractlu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x19800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_extractlu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_extractlu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x19800000)
+#define st240_flushadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f800000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_flushadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800000)
+#define st240_flushadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f800000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_flushadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_flushadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800000)
+#define st240_flushadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f800040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_flushadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800040)
+#define st240_flushadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f800040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_flushadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_flushadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f800040)
+#define st240_goto_btarg_insn(btarg) (unsigned int)(0x31000000 | (((int)(btarg) << 2) & 0x7fffff))
+#define is_st240_goto_btarg_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x31000000)
+#define is_st240_igoto_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31800000)
+#define st240_imml_imm_insn(imm) (unsigned int)(0x15000000 | ((int)(imm) & 0x7fffff))
+#define is_st240_imml_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15000000)
+#define st240_immr_imm_insn(imm) (unsigned int)(0x15800000 | ((int)(imm) & 0x7fffff))
+#define is_st240_immr_imm_insn(x) (int)(((unsigned int)(x) & 0x7f800000) == 0x15800000)
+#define st240_invadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2fc00000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_invadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00000)
+#define st240_invadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2fc00000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_invadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_invadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00000)
+#define st240_invadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2fc00040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_invadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00040)
+#define st240_invadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2fc00040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_invadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_invadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2fc00040)
+#define st240_ldb_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldb_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st240_ldb_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldb_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldb_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x24000000)
+#define st240_ldbc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldbc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x24000000)
+#define st240_ldbc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x24000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldbc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldbc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x24000000)
+#define st240_ldbu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldbu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st240_ldbu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldbu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldbu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x25000000)
+#define st240_ldbuc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldbuc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x25000000)
+#define st240_ldbuc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x25000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldbuc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldbuc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x25000000)
+#define st240_ldh_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldh_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st240_ldh_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldh_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldh_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x22000000)
+#define st240_ldhc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldhc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x22000000)
+#define st240_ldhc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x22000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldhc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldhc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x22000000)
+#define st240_ldhu_nlidest_isrc2_src1_insn(nlidest,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldhu_nlidest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st240_ldhu_nlidest_xsrc2_src1_insn_0(nlidest,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldhu_nlidest_xsrc2_src1_insn_1(nlidest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldhu_nlidest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x23000000)
+#define st240_ldhuc_nlidest_pcond_isrc2_src1_insn(nlidest,pcond,isrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldhuc_nlidest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x23000000)
+#define st240_ldhuc_nlidest_pcond_xsrc2_src1_insn_0(nlidest,pcond,xsrc2,src1) (unsigned int)(0x23000000 | (((int)(nlidest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldhuc_nlidest_pcond_xsrc2_src1_insn_1(nlidest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldhuc_nlidest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x23000000)
+#define st240_ldl_idestp_isrc2_src1_insn(idestp,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldl_idestp_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st240_ldl_idestp_xsrc2_src1_insn_0(idestp,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldl_idestp_xsrc2_src1_insn_1(idestp,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldl_idestp_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x20000000)
+#define st240_ldlc_idestp_pcond_isrc2_src1_insn(idestp,pcond,isrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldlc_idestp_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x20000000)
+#define st240_ldlc_idestp_pcond_xsrc2_src1_insn_0(idestp,pcond,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(idestp) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldlc_idestp_pcond_xsrc2_src1_insn_1(idestp,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldlc_idestp_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x20000000)
+#define st240_ldw_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldw_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st240_ldw_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldw_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldw_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x21000000)
+#define st240_ldwc_idest_pcond_isrc2_src1_insn(idest,pcond,isrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_ldwc_idest_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x21000000)
+#define st240_ldwc_idest_pcond_xsrc2_src1_insn_0(idest,pcond,xsrc2,src1) (unsigned int)(0x21000000 | (((int)(idest) & 0x3f) << 6) | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_ldwc_idest_pcond_xsrc2_src1_insn_1(idest,pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_ldwc_idest_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x21000000)
+#define st240_ldwl_idest_src1_insn(idest,src1) (unsigned int)(0x2fe05000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_ldwl_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x2fe05000)
+#define st240_max_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02000000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_max_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02000000)
+#define st240_max_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_max_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st240_max_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a000000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_max_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_max_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a000000)
+#define st240_maxu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02200000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_maxu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02200000)
+#define st240_maxu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_maxu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st240_maxu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a200000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_maxu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_maxu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a200000)
+#define st240_min_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_min_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02400000)
+#define st240_min_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_min_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st240_min_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_min_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_min_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a400000)
+#define st240_minu_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x02600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_minu_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02600000)
+#define st240_minu_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_minu_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st240_minu_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x0a600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_minu_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_minu_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a600000)
+#define st240_mov_bsrc_bdest_bdest2_bsrc1_insn(bdest2,bsrc1) (unsigned int)(0x06010000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7))
+#define is_st240_mov_bsrc_bdest_bdest2_bsrc1_insn(x) (int)(((unsigned int)(x) & 0x7fff8ff8) == 0x06010000)
+#define st240_mulf_n_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02480000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulf_n_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02480000)
+#define st240_mulfrac_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulfrac_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03e00000)
+#define st240_mulfrac_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mulfrac_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st240_mulfrac_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0be00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mulfrac_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mulfrac_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0be00000)
+#define st240_mulh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02e00000)
+#define st240_mulhh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulhh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03a00000)
+#define st240_mulhhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulhhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03c00000)
+#define st240_mull_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02a00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mull_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02a00000)
+#define st240_mullh_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03600000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mullh_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03600000)
+#define st240_mullhu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mullhu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03800000)
+#define st240_mulll_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulll_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03200000)
+#define st240_mulll_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mulll_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st240_mulll_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mulll_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mulll_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b200000)
+#define st240_mulllu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03400000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mulllu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03400000)
+#define st240_mulllu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mulllu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st240_mulllu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0b400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mulllu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mulllu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0b400000)
+#define st240_mul32_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02c00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul32_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02c00000)
+#define st240_mul32_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mul32_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st240_mul32_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mul32_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mul32_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st240_mul64h_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x01e00000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul64h_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01e00000)
+#define st240_mul64h_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mul64h_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st240_mul64h_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x09e00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mul64h_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mul64h_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09e00000)
+#define st240_mul64hu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02800000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mul64hu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02800000)
+#define st240_mul64hu_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mul64hu_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st240_mul64hu_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0a800000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mul64hu_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mul64hu_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0a800000)
+#define st240_nandl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06208000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_nandl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06208000)
+#define st240_nandl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_nandl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05600000)
+#define st240_nandl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07600000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_nandl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07600000)
+#define st240_norl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06608000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_norl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06608000)
+#define st240_norl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_norl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05a00000)
+#define st240_norl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07a00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_norl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07a00000)
+#define st240_or_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_or_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01600000)
+#define st240_or_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_or_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st240_or_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_or_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_or_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09600000)
+#define st240_orl_bdest_bdest2_bsrc1_bsrc2_insn(bdest2,bsrc1,bsrc2) (unsigned int)(0x06408000 | (((int)(bdest2) & 0x7) << 12) | ((int)(bsrc1) & 0x7) | (((int)(bsrc2) & 0x7) << 6))
+#define is_st240_orl_bdest_bdest2_bsrc1_bsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fff8e38) == 0x06408000)
+#define st240_orc_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_orc_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01800000)
+#define st240_orl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x05800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_orl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05800000)
+#define st240_orl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x07800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_orl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07800000)
+#define st240_pft_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x20000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_pft_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x20000000)
+#define st240_pft_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x20000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_pft_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_pft_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x20000000)
+#define st240_pftc_pcond_isrc2_src1_insn(pcond,isrc2,src1) (unsigned int)(0x20000000 | (((int)(pcond) & 0x7) << 21) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_pftc_pcond_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000fc0) == 0x20000000)
+#define st240_pftc_pcond_xsrc2_src1_insn_0(pcond,xsrc2,src1) (unsigned int)(0x20000000 | (((int)(pcond) & 0x7) << 21) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_pftc_pcond_xsrc2_src1_insn_1(pcond,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_pftc_pcond_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f000fc0) == 0x20000000)
+#define st240_prgadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000000)
+#define st240_prgadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000000)
+#define st240_prgadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f000040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000040)
+#define st240_prgadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f000040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f000040)
+#define st240_prginsadd_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f400000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsadd_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400000)
+#define st240_prginsadd_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f400000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsadd_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsadd_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400000)
+#define st240_prginsadd_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f400040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsadd_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400040)
+#define st240_prginsadd_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f400040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsadd_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsadd_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f400040)
+#define st240_prginsset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f600000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600000)
+#define st240_prginsset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f600000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600000)
+#define st240_prginsset_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f600040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prginsset_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600040)
+#define st240_prginsset_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f600040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prginsset_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prginsset_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f600040)
+#define st240_prgset_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f200000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgset_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200000)
+#define st240_prgset_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f200000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgset_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgset_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200000)
+#define st240_prgset_l1_isrc2_src1_insn(isrc2,src1) (unsigned int)(0x2f200040 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_prgset_l1_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200040)
+#define st240_prgset_l1_xsrc2_src1_insn_0(xsrc2,src1) (unsigned int)(0x2f200040 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_prgset_l1_xsrc2_src1_insn_1(xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_prgset_l1_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00fc0) == 0x2f200040)
+#define st240_pswmask_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x2fa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_pswmask_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st240_pswmask_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x2fa00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_pswmask_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_pswmask_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2fa00000)
+#define st240_rem_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03280000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_rem_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03280000)
+#define st240_remu_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x03680000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_remu_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03680000)
+#define is_st240_retention_insn(x) (int)(((unsigned int)(x) & 0xffffffff) == 0xafe0c000)
+#define is_st240_return_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x33800000)
+#define is_st240_rfi_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x32000000)
+#define st240_rotl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x10e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_rotl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10e00000)
+#define st240_rotl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_rotl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18e00000)
+#define st240_rotl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_rotl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_rotl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18e00000)
+#define st240_sats_dest_src1_insn(dest,src1) (unsigned int)(0x02900000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_sats_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x02900000)
+#define st240_satso_dest_src1_insn(dest,src1) (unsigned int)(0x03900000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_satso_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x03900000)
+#define st240_sbrk_brknum_insn(brknum) (unsigned int)(0xafe09000 | ((int)(brknum) & 0xfff))
+#define is_st240_sbrk_brknum_insn(x) (int)(((unsigned int)(x) & 0xfffff000) == 0xafe09000)
+#define st240_sh1add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sh1add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00a00000)
+#define st240_sh1add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sh1add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st240_sh1add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sh1add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sh1add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08a00000)
+#define st240_sh1adds_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02500000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1adds_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02500000)
+#define st240_sh1addso_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x03500000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1addso_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03500000)
+#define st240_sh1subs_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02700000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1subs_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02700000)
+#define st240_sh1subso_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x03700000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sh1subso_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03700000)
+#define st240_sh2add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sh2add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00c00000)
+#define st240_sh2add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sh2add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st240_sh2add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sh2add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sh2add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08c00000)
+#define st240_sh3add_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00e00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sh3add_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00e00000)
+#define st240_sh3add_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sh3add_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st240_sh3add_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08e00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sh3add_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sh3add_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08e00000)
+#define st240_shl_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00400000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shl_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00400000)
+#define st240_shl_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shl_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st240_shl_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08400000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shl_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shl_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08400000)
+#define st240_shls_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x10000000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shls_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10000000)
+#define st240_shls_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x18000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shls_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18000000)
+#define st240_shls_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x18000000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shls_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shls_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18000000)
+#define st240_shlso_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x10200000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shlso_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10200000)
+#define st240_shlso_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x18200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shlso_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18200000)
+#define st240_shlso_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x18200000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shlso_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shlso_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18200000)
+#define st240_shr_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00600000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shr_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00600000)
+#define st240_shr_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shr_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st240_shr_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08600000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shr_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shr_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08600000)
+#define st240_shrrnp_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x18400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shrrnp_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18400000)
+#define st240_shrrnp_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x18400000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shrrnp_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shrrnp_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18400000)
+#define st240_shru_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x00800000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_shru_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00800000)
+#define st240_shru_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_shru_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st240_shru_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x08800000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_shru_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_shru_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08800000)
+#define st240_slct_rsrc_dest_scond_src1_src2_insn(dest,scond,src1,src2) (unsigned int)(0x16040000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_slct_rsrc_dest_scond_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16040000)
+#define st240_slct_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1c000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slct_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1c000000)
+#define st240_slct_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1c000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slct_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slct_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1c000000)
+#define st240_slctf_idest_scond_src1_isrc2_insn(idest,scond,src1,isrc2) (unsigned int)(0x1d000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_slctf_idest_scond_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1d000000)
+#define st240_slctf_idest_scond_src1_xsrc2_insn_0(idest,scond,src1,xsrc2) (unsigned int)(0x1d000000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_slctf_idest_scond_src1_xsrc2_insn_1(idest,scond,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_slctf_idest_scond_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x1d000000)
+#define st240_stb_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x2c000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stb_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2c000000)
+#define st240_stb_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x2c000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st240_stb_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stb_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2c000000)
+#define st240_stbc_isrc2_src1_pcond_src2_insn(isrc2,src1,pcond,src2) (unsigned int)(0x2c000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stbc_isrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2c000000)
+#define st240_stbc_xsrc2_src1_pcond_src2_insn_0(xsrc2,src1,pcond,src2) (unsigned int)(0x2c000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define st240_stbc_xsrc2_src1_pcond_src2_insn_1(xsrc2,src1,pcond,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stbc_xsrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2c000000)
+#define st240_sth_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x2a000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sth_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2a000000)
+#define st240_sth_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x2a000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st240_sth_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sth_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x2a000000)
+#define st240_sthc_isrc2_src1_pcond_src2_insn(isrc2,src1,pcond,src2) (unsigned int)(0x2a000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sthc_isrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2a000000)
+#define st240_sthc_xsrc2_src1_pcond_src2_insn_0(xsrc2,src1,pcond,src2) (unsigned int)(0x2a000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define st240_sthc_xsrc2_src1_pcond_src2_insn_1(xsrc2,src1,pcond,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sthc_xsrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x2a000000)
+#define st240_stl_isrc2_src1_src2p_insn(isrc2,src1,src2p) (unsigned int)(0x28000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2p) & 0x3f) << 6))
+#define is_st240_stl_isrc2_src1_src2p_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x28000000)
+#define st240_stl_xsrc2_src1_src2p_insn_0(xsrc2,src1,src2p) (unsigned int)(0x28000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2p) & 0x3f) << 6))
+#define st240_stl_xsrc2_src1_src2p_insn_1(xsrc2,src1,src2p) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stl_xsrc2_src1_src2p_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x28000000)
+#define st240_stlc_isrc2_src1_pcond_src2p_insn(isrc2,src1,pcond,src2p) (unsigned int)(0x28000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2p) & 0x3f) << 6))
+#define is_st240_stlc_isrc2_src1_pcond_src2p_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x28000000)
+#define st240_stlc_xsrc2_src1_pcond_src2p_insn_0(xsrc2,src1,pcond,src2p) (unsigned int)(0x28000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2p) & 0x3f) << 6))
+#define st240_stlc_xsrc2_src1_pcond_src2p_insn_1(xsrc2,src1,pcond,src2p) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stlc_xsrc2_src1_pcond_src2p_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x28000000)
+#define st240_stw_isrc2_src1_src2_insn(isrc2,src1,src2) (unsigned int)(0x29000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stw_isrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x29000000)
+#define st240_stw_xsrc2_src1_src2_insn_0(xsrc2,src1,src2) (unsigned int)(0x29000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define st240_stw_xsrc2_src1_src2_insn_1(xsrc2,src1,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stw_xsrc2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x29000000)
+#define st240_stwc_isrc2_src1_pcond_src2_insn(isrc2,src1,pcond,src2) (unsigned int)(0x29000000 | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stwc_isrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x29000000)
+#define st240_stwc_xsrc2_src1_pcond_src2_insn_0(xsrc2,src1,pcond,src2) (unsigned int)(0x29000000 | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f) | (((int)(pcond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6))
+#define st240_stwc_xsrc2_src1_pcond_src2_insn_1(xsrc2,src1,pcond,src2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_stwc_xsrc2_src1_pcond_src2_insn(x) (int)(((unsigned int)(x) & 0x7f000000) == 0x29000000)
+#define st240_stwl_bdest2_src1_src2_insn(bdest2,src1,src2) (unsigned int)(0x2ff00000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_stwl_bdest2_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x2ff00000)
+#define st240_sub_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x00200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sub_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x00200000)
+#define st240_sub_idest_isrc2_src1_insn(idest,isrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_sub_idest_isrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st240_sub_idest_xsrc2_src1_insn_0(idest,xsrc2,src1) (unsigned int)(0x08200000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12) | ((int)(src1) & 0x3f))
+#define st240_sub_idest_xsrc2_src1_insn_1(idest,xsrc2,src1) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sub_idest_xsrc2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x08200000)
+#define st240_subf_n_nldest_src1_src2_insn(nldest,src1,src2) (unsigned int)(0x02280000 | (((int)(nldest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_subf_n_nldest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02280000)
+#define st240_subs_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x02300000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_subs_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x02300000)
+#define st240_subso_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x03300000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_subso_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x03300000)
+#define st240_sxt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x10a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_sxt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10a00000)
+#define st240_sxt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_sxt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18a00000)
+#define st240_sxt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_sxt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_sxt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18a00000)
+#define is_st240_sync_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe02000)
+#define is_st240_syncins_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe00000)
+#define st240_syscall_brknum_insn(brknum) (unsigned int)(0x2fe0a000 | ((int)(brknum) & 0xfff))
+#define is_st240_syscall_brknum_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x2fe0a000)
+#define is_st240_waitl_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe04000)
+#define is_st240_wmb_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x2fe03000)
+#define st240_xor_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x01a00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_xor_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x01a00000)
+#define st240_xor_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_xor_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st240_xor_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x09a00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_xor_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_xor_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x09a00000)
+#define st240_zxt_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x10c00000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_zxt_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x10c00000)
+#define st240_zxt_idest_src1_isrc2_insn(idest,src1,isrc2) (unsigned int)(0x18c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_zxt_idest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18c00000)
+#define st240_zxt_idest_src1_xsrc2_insn_0(idest,src1,xsrc2) (unsigned int)(0x18c00000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_zxt_idest_src1_xsrc2_insn_1(idest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_zxt_idest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x18c00000)
+#define st240_bswap_idest_src1_insn(idest,src1) (unsigned int)(0x1a01b000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_bswap_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x1a01b000)
+#define st240_convbi_idest_scond_insn(idest,scond) (unsigned int)(0x1d001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st240_convbi_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x1d001000)
+#define st240_convib_bdest2_src1_insn(bdest2,src1) (unsigned int)(0x07800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_convib_bdest2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8fc0) == 0x07800000)
+#define st240_cmpge_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04c00000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpge_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04c00000)
+#define st240_cmpge_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06c00000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpge_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06c00000)
+#define st240_cmpgeu_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04e00000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgeu_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04e00000)
+#define st240_cmpgeu_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06e00000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgeu_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06e00000)
+#define st240_cmpgt_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x05000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgt_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05000000)
+#define st240_cmpgt_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x07000000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgt_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07000000)
+#define st240_cmpgtu_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x05200000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgtu_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x05200000)
+#define st240_cmpgtu_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x07200000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpgtu_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x07200000)
+#define st240_cmplef_n_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04400000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmplef_n_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04400000)
+#define st240_cmplef_n_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06400000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmplef_n_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06400000)
+#define st240_cmpltf_n_dest_src2_src1_insn(dest,src2,src1) (unsigned int)(0x04800000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpltf_n_dest_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x04800000)
+#define st240_cmpltf_n_bdest2_src2_src1_insn(bdest2,src2,src1) (unsigned int)(0x06800000 | (((int)(bdest2) & 0x7) << 12) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_cmpltf_n_bdest2_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8000) == 0x06800000)
+#define is_st240_idle_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x31000000)
+#define st240_mfb_idest_scond_insn(idest,scond) (unsigned int)(0x1d001000 | (((int)(idest) & 0x3f) << 6) | (((int)(scond) & 0x7) << 21))
+#define is_st240_mfb_idest_scond_insn(x) (int)(((unsigned int)(x) & 0x7f1ff03f) == 0x1d001000)
+#define st240_mov_dest_src2_insn(dest,src2) (unsigned int)(0x00000000 | (((int)(dest) & 0x3f) << 12) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_mov_dest_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc003f) == 0x00000000)
+#define st240_mov_idest_isrc2_insn(idest,isrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mov_idest_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st240_mov_idest_xsrc2_insn_0(idest,xsrc2) (unsigned int)(0x08000000 | (((int)(idest) & 0x3f) << 6) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mov_idest_xsrc2_insn_1(idest,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mov_idest_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe0003f) == 0x08000000)
+#define st240_mtb_bdest2_src1_insn(bdest2,src1) (unsigned int)(0x07800000 | (((int)(bdest2) & 0x7) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_mtb_bdest2_src1_insn(x) (int)(((unsigned int)(x) & 0x7fff8fc0) == 0x07800000)
+#define st240_mull_nlidest_src1_isrc2_insn(nlidest,src1,isrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | (((int)(isrc2) & 0x1ff) << 12))
+#define is_st240_mull_nlidest_src1_isrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define st240_mull_nlidest_src1_xsrc2_insn_0(nlidest,src1,xsrc2) (unsigned int)(0x0ac00000 | (((int)(nlidest) & 0x3f) << 6) | ((int)(src1) & 0x3f) | ((((int)(xsrc2) >> 23) & 0x1ff) << 12))
+#define st240_mull_nlidest_src1_xsrc2_insn_1(nlidest,src1,xsrc2) (unsigned int)(((int)(xsrc2) & 0x7fffff))
+#define is_st240_mull_nlidest_src1_xsrc2_insn(x) (int)(((unsigned int)(x) & 0x7fe00000) == 0x0ac00000)
+#define is_st240_nop_insn(x) (int)(((unsigned int)(x) & 0x7fffffff) == 0x00000000)
+#define st240_slctf_dest_scond_src2_src1_insn(dest,scond,src2,src1) (unsigned int)(0x16040000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_slctf_dest_scond_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16040000)
+#define st240_sxtb_idest_src1_insn(idest,src1) (unsigned int)(0x18a08000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x18a08000)
+#define st240_sxth_idest_src1_insn(idest,src1) (unsigned int)(0x18a10000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_sxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x18a10000)
+#define st240_zxtb_idest_src1_insn(idest,src1) (unsigned int)(0x092ff000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_zxtb_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x092ff000)
+#define st240_zxth_idest_src1_insn(idest,src1) (unsigned int)(0x18c10000 | (((int)(idest) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_zxth_idest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffff000) == 0x18c10000)
+#define st240_slctf_pb_dest_scond_src2_src1_insn(dest,scond,src2,src1) (unsigned int)(0x16000000 | (((int)(dest) & 0x3f) << 12) | (((int)(scond) & 0x7) << 21) | (((int)(src2) & 0x3f) << 6) | ((int)(src1) & 0x3f))
+#define is_st240_slctf_pb_dest_scond_src2_src1_insn(x) (int)(((unsigned int)(x) & 0x7f1c0000) == 0x16000000)
+#define st240_unpacku_pbh_dest_src1_insn(dest,src1) (unsigned int)(0x12040000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_unpacku_pbh_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x12040000)
+#define st240_unpacku_pbl_dest_src1_insn(dest,src1) (unsigned int)(0x12240000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f))
+#define is_st240_unpacku_pbl_dest_src1_insn(x) (int)(((unsigned int)(x) & 0x7ffc0fc0) == 0x12240000)
+#define st240_pack_ph_dest_src1_src2_insn(dest,src1,src2) (unsigned int)(0x13280000 | (((int)(dest) & 0x3f) << 12) | ((int)(src1) & 0x3f) | (((int)(src2) & 0x3f) << 6))
+#define is_st240_pack_ph_dest_src1_src2_insn(x) (int)(((unsigned int)(x) & 0x7ffc0000) == 0x13280000)
+
+/*
+ * The following macros are provided for compatibility with old
+ * code.  They should not be used in new code.
+ */
+#define LXSTOP(x)      st200_STOPBIT_fld(x)
+#define LXCLUSTER(x)   (int)(((unsigned int)(x) & 0x40000000) != 0)
+#define LXISIMMEXTR(x) is_st231_immr_imm_insn(x)
+#define LXISIMMEXTL(x) is_st231_imml_imm_insn(x)
+#define LXIMMVAL(x)    (int)st200_xsrc2_opd(0,x)
+
+enum {
+  Method_st200_ERROR,
+  Immediate_st200_brknum,
+  Immediate_st200_btarg,
+  Immediate_st200_imm,
+  Immediate_st200_isrc2,
+  Immediate_st200_sbrknum,
+  Immediate_st200_xsrc2,
+  RegClass_st200_branch,
+  RegClass_st200_general,
+  RegClass_st200_link,
+  RegClass_st200_nolink,
+  RegClass_st200_nzpaired,
+  RegClass_st200_nzpairedfirst,
+  RegClass_st200_nzpairedsecond,
+  RegClass_st200_paired,
+  RegClass_st200_pairedfirst,
+  RegClass_st200_pairedsecond,
+  RegClass_st200_predicate
+};
+
+/***********************************************/
+/*       DATA TYPES                            */
+/***********************************************/
+
+/*  Operand definition -- used in building     */
+/*  format table                               */
+
+struct lx_operand
+{
+  char *tname;        /* operand type name     */
+  int type;           /* type of operand       */
+  int bits;           /* number of bits        */
+  int shift;          /* amount to shift       */
+  int flags;          /*                       */
+};
+
+typedef struct lx_operand lxbfield;
+
+/* some flags for lx_operand                                 */
+/* lxSIGNED    : is this operand treated as signed ?         */
+/* lxCANEXTEND : can this operand have an extension syllable */
+
+#define lxSIGNED  1
+#define lxCANEXTEND 2
+
+/* Opcode definition.                          */
+
+struct lxopc_s {
+  char     *as_op;                      /* asm name                       */
+  unsigned opcode;                      /* the opcode                     */
+  unsigned mask;                        /* disassembly mask               */
+  int      bundlings;                   /* user specific flags            */
+  int      reservation;                 /* reservation table index        */
+  lxbfield *format[LXMAXOPERANDS + 1];  /* 0 terminated                   */
+                                        /*list of operands                */
+  char     *rclass;                     /* resource class                 */
+  char     *fmtstring;                  /* formating string               */
+};
+typedef struct lxopc_s lxopc_t;
+
+struct lx_core_info_s
+  {
+    const char *name;
+    lxopc_t *optab;
+    const int *resources;
+    int elf_core;
+    int supported;
+  };
+
+typedef struct lx_core_info_s Lx_Core_Info;
+
+typedef int Bundling;
+
+struct bundletype_s
+  {
+    int entries;
+    int bias, base;
+    int nnops;
+    Bundling bundling[LXMAXBUNDLESIZE];
+    int nops[LXMAXBUNDLESIZE];
+  };
+
+typedef struct bundletype_s BundleType;
+
+struct bundlematchtype_s { int entries; int entry[4]; };
+
+typedef struct bundlematchtype_s BundleMatchType;
+
+extern BundleType bundle_types[];
+extern short bundlematch_table_size;
+extern short bundlematch_table[];
+extern BundleMatchType canonical_table[];
+
+extern const int st200_resource_max;
+
+extern const int st200_reservation_table_lines;
+extern const int *st200_reservation_table_table[];
+extern const char *st200_resource_names[];
+
+extern const int st231_resources[];
+extern lxopc_t st231_lxoptab[];
+extern const Lx_Core_Info st231_core_info;
+extern const int st240_resources[];
+extern lxopc_t st240_lxoptab[];
+extern const Lx_Core_Info st240_core_info;
+
+extern const Lx_Core_Info *st200_core_info_table[];
+
+#endif /* OPCODE_LX_H */
diff --git a/include/secinit.h b/include/secinit.h
new file mode 100644
index 0000000..b220213
--- /dev/null
+++ b/include/secinit.h
@@ -0,0 +1,65 @@
+typedef enum {
+  secinit_end_of_table_enum = 0x00,
+  secinit_memory_bss_enum   = 0x01,
+  secinit_memory_data_enum  = 0x02,
+  secinit_memory_compress_enum   = 0x03,
+  secinit_invalid_enum      = 0x04
+} secinit_enum_t;
+
+typedef struct _secinit_clear {
+  bfd_vma vma;
+  unsigned int size;
+  unsigned int status;
+} secinit_clear_t;
+
+typedef secinit_clear_t *secinit_clear_ptr;
+
+typedef struct _secinit_copy {
+  bfd_vma vma;
+  bfd_vma lma;
+  unsigned int size;
+  unsigned int status;
+} secinit_copy_t;
+
+typedef secinit_copy_t *secinit_copy_ptr;
+
+#define MAX_NAME_LEN 8
+
+typedef struct _secinit_compress {
+  bfd_vma vma;
+  bfd_vma lma;
+  unsigned int size;
+  unsigned int compressed_size;
+  char algo_name[MAX_NAME_LEN];
+//  int (*algo)(char *vma, char *lma, unsigned int compressed_size, unsigned int size);
+  bfd_vma algo;
+  unsigned int status;
+} secinit_compress_t;
+
+typedef secinit_compress_t *secinit_compress_ptr;
+
+typedef union _secinit_union {
+  secinit_clear_t clear;
+  secinit_copy_t copy;
+  secinit_compress_t compress;
+} secinit_union_t;
+
+typedef struct _secinit {
+  secinit_enum_t type;
+  secinit_union_t u;
+} secinit_t;
+
+typedef secinit_t *secinit_ptr;
+
+bfd_boolean
+elf_lx_get_secinit_table ( bfd *abfd, secinit_ptr *secinit_table, int *secinit_table_entry_nb);
+
+bfd_boolean
+elf_lx_set_secinit_table ( bfd *abfd, secinit_ptr secinit_table, int secinit_table_entry_nb);
+
+void
+elf_lx_dump_secinit_table(bfd *abfd, FILE *writer);
+
+bfd_boolean
+elf_lx_secinit_compress_or_decompress(bfd *abfd, bfd_boolean compress, char *library_name);
+
diff --git a/include/sys/bitfields.h b/include/sys/bitfields.h
new file mode 100644
index 0000000..68a58e4
--- /dev/null
+++ b/include/sys/bitfields.h
@@ -0,0 +1,31 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
+/* bitfields.h - Declaration for accessing bitfields. 
+   static char sccs_id[] = "@(#)bitfields.h	1.4 02/07/00 12:08:11";
+
+   Author: Richard L. Ford
+   Modified by: Geoffrey Brown
+
+   Most of this file is gone. 
+
+*/
+
+#ifndef INCLUDED_BITFIELDS_H
+#define INCLUDED_BITFIELDS_H
+
+     /* cast an address to a dereferenced unsigned int pointer */
+
+#define VOLUINT(address) (*((volatile unsigned int*)(address)))
+
+#ifndef POW2
+#define POW2(i) (1<<(i))
+#endif
+
+    /* Round x up to the next multiple of n where n must be a
+       power of 2. */
+
+#define ROUNDUP(x,n)  ((((x)) + ((n) - 1)) & (~((n) - 1)))
+
+#endif /* INCLUDED_BITFIELDS_H */
diff --git a/libdecnumber/ChangeLog b/libdecnumber/ChangeLog
index 8e8cf1a..a89179b 100644
--- a/libdecnumber/ChangeLog
+++ b/libdecnumber/ChangeLog
@@ -1,3 +1,35 @@
+2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.in ($(srcdir)/aclocal.m4): Update dependencies.
+	* configure: Regenerate.
+
+2008-06-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* Makefile.in (datarootdir): New variable.
+
+2008-06-10  Joseph Myers  <joseph@codesourcery.com>
+
+	* dconfig.h: New.
+	* decContext.c, decExcept.c, decExcept.h, decLibrary.c,
+	decNumber.c, decNumberLocal.h, decRound.c, dpd/decimal128.c,
+	dpd/decimal32.c, dpd/decimal64.c: Include dconfig.h not config.h.
+	* dpd/decimal128Local.h (decimal128SetSign, decimal128ClearSign,
+	decimal128FlipSign): Use WORDS_BIGENDIAN not
+	FLOAT_WORDS_BIG_ENDIAN.
+	* bid/host-ieee128.c: Include dconfig.h.
+	(__host_to_ieee_128, __ieee_to_host_128): Swap 64-bit halves of
+	value if WORDS_BIGENDIAN.
+
+2008-04-18  Paolo Bonzini  <bonzini@gnu.org>
+
+	PR bootstrap/35457
+	* aclocal.m4: Regenerate.
+	* configure: Regenerate.
+
+2008-04-18  Ben Elliston  <bje@au.ibm.com>
+
+	* Makefile.in (distclean): Add gstdint.h.
+
 2008-01-25  Janis Johnson  <janis187@us.ibm.com>
 
 	* decCommonSymbols.h: Commit.
diff --git a/libdecnumber/Makefile.in b/libdecnumber/Makefile.in
index 00b16b2..5e1cabf 100644
--- a/libdecnumber/Makefile.in
+++ b/libdecnumber/Makefile.in
@@ -44,6 +44,7 @@ PACKAGE = @PACKAGE@
 RANLIB = @RANLIB@
 SHELL = @SHELL@
 
+datarootdir = @datarootdir@
 datadir = @datadir@
 exec_prefix = @prefix@
 libdir = @libdir@
@@ -95,7 +96,7 @@ $(srcdir)/configure: @MAINT@ $(srcdir)/aclocal.m4
 	cd $(srcdir) && $(AUTOCONF)
 
 $(srcdir)/aclocal.m4: @MAINT@ $(srcdir)/../config/stdint.m4 \
-	$(srcdir)/../config/warnings.m4 \
+	$(srcdir)/../config/warnings.m4 $(srcdir)/../config/override.m4 \
 	$(srcdir)/configure.ac
 	cd $(srcdir) && $(ACLOCAL) -I ../config
 
@@ -151,7 +152,7 @@ clean: mostlyclean
 distclean: clean
 	-rm -f config.h stamp-h1 config.status config.cache config.log \
 	  configure.lineno configure.status.lineno Makefile localedir.h \
-	  localedir.hs
+	  localedir.hs gstdint.h
 
 maintainer-clean: distclean
 	@echo "This command is intended for maintainers to use"
diff --git a/libdecnumber/aclocal.m4 b/libdecnumber/aclocal.m4
index f35b363..86be19d 100644
--- a/libdecnumber/aclocal.m4
+++ b/libdecnumber/aclocal.m4
@@ -11,5 +11,6 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+m4_include([../config/override.m4])
 m4_include([../config/stdint.m4])
 m4_include([../config/warnings.m4])
diff --git a/libdecnumber/bid/host-ieee128.c b/libdecnumber/bid/host-ieee128.c
index 6d493e5..12632c8 100644
--- a/libdecnumber/bid/host-ieee128.c
+++ b/libdecnumber/bid/host-ieee128.c
@@ -29,20 +29,35 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
 
 #include <string.h>
 
+#include "dconfig.h"
 #include "bid-dpd.h"
 #include "decimal128.h"
 
 void __host_to_ieee_128 (_Decimal128 in, decimal128 *out);
 void __ieee_to_host_128 (decimal128 in, _Decimal128 *out);
 
+/* The code for converting 128-bit values between DPD and BID presumes
+   that the 64-bit halves of the 128-bit value are in little-endian
+   order, so they need swapping on big-endian hosts.  */
+
 void
 __host_to_ieee_128 (_Decimal128 in, decimal128 *out)
 {
+#if WORDS_BIGENDIAN
+  memcpy ((char *) out, (char *) &in + 8, 8);
+  memcpy ((char *) out + 8, (char *) &in, 8);
+#else
   memcpy ((char *) out, (char *) &in, 16);
+#endif
 }
 
 void
 __ieee_to_host_128 (decimal128 in, _Decimal128 *out)
 {
+#if WORDS_BIGENDIAN
+  memcpy ((char *) out, (char *) &in + 8, 8);
+  memcpy ((char *) out + 8, (char *) &in, 8);
+#else
   memcpy ((char *) out, (char *) &in, 16);
+#endif
 }
diff --git a/libdecnumber/configure b/libdecnumber/configure
index 19ece0f..9ff3a5e 100644
--- a/libdecnumber/configure
+++ b/libdecnumber/configure
@@ -313,6 +313,7 @@ ac_includes_default="\
 
 ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS SET_MAKE CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT RANLIB ac_ct_RANLIB ACLOCAL AUTOCONF AUTOHEADER WARN_CFLAGS WARN_PEDANTIC WERROR CPP EGREP MAINT build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os enable_decimal_float ADDITIONAL_OBJS LIBOBJS LTLIBOBJS'
 ac_subst_files=''
+ac_pwd=`pwd`
 
 # Initialize some variables set by options.
 ac_init_help=
@@ -1252,13 +1253,22 @@ echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
-	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
+        # differences in whitespace do not lead to failure.
+        ac_old_val_w=`echo x $ac_old_val`
+        ac_new_val_w=`echo x $ac_new_val`
+        if test "$ac_old_val_w" != "$ac_new_val_w"; then
+          { echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
 echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
-echo "$as_me:   former value:  $ac_old_val" >&2;}
-	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
-echo "$as_me:   current value: $ac_new_val" >&2;}
-	ac_cache_corrupted=:
+          ac_cache_corrupted=:
+        else
+          { echo "$as_me:$LINENO: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+          eval $ac_var=\$ac_old_val
+        fi
+        { echo "$as_me:$LINENO:   former value:  \`$ac_old_val'" >&5
+echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+        { echo "$as_me:$LINENO:   current value: \`$ac_new_val'" >&5
+echo "$as_me:   current value: \`$ac_new_val'" >&2;}
       fi;;
   esac
   # Pass precious variables to config.status.
@@ -1275,6 +1285,8 @@ echo "$as_me:   current value: $ac_new_val" >&2;}
   fi
 done
 if $ac_cache_corrupted; then
+  { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
 echo "$as_me: error: changes in the environment can compromise the build" >&2;}
   { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
@@ -1315,6 +1327,9 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
+
+
+
 case ../config in
   [\\/]* | ?:[\\/]* ) ac_macro_dir=../config         ;;
   *)                      ac_macro_dir=$srcdir/../config ;;
@@ -1666,11 +1681,13 @@ fi
 fi
 
 
-test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
+test -z "$CC" && { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&5
 echo "$as_me: error: no acceptable C compiler found in \$PATH
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 
 # Provide some information about the compiler.
 echo "$as_me:$LINENO:" \
@@ -1756,11 +1773,13 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: C compiler cannot create executables
 See \`config.log' for more details." >&5
 echo "$as_me: error: C compiler cannot create executables
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
+   { (exit 77); exit 77; }; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
@@ -1785,13 +1804,15 @@ if test "$cross_compiling" != yes; then
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
+	{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'.
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
     fi
   fi
 fi
@@ -1829,11 +1850,13 @@ for ac_file in conftest.exe conftest conftest.*; do
   esac
 done
 else
-  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
@@ -1880,11 +1903,13 @@ else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute suffix of object files: cannot compile
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
@@ -2872,11 +2897,13 @@ rm -f conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then
   :
 else
-  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&5
 echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 
 ac_ext=c
@@ -4313,19 +4340,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_void_p=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (void *), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -4383,11 +4414,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (void *), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -4731,19 +4764,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_long=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -4801,11 +4838,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5149,19 +5188,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -5219,11 +5262,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5563,19 +5608,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_short=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -5633,11 +5682,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -5977,19 +6028,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_char=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (char), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -6047,11 +6102,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (char), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -6637,19 +6694,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -6707,11 +6768,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
@@ -7051,19 +7114,23 @@ rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_long=$ac_lo;;
-'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
+'') { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; } ;;
+   { (exit 1); exit 1; }; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+  { { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
+{ { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot run test program while cross compiling
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -7121,11 +7188,13 @@ echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
+{ { echo "$as_me:$LINENO: error: in \`$ac_pwd':" >&5
+echo "$as_me: error: in \`$ac_pwd':" >&2;}
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
+   { (exit 1); exit 1; }; }; }
 fi
 rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
diff --git a/libdecnumber/dconfig.h b/libdecnumber/dconfig.h
new file mode 100644
index 0000000..ffbad25
--- /dev/null
+++ b/libdecnumber/dconfig.h
@@ -0,0 +1,52 @@
+/* Configure decNumber for either host or target.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2, or (at your option) any later
+   version.
+
+   In addition to the permissions in the GNU General Public License,
+   the Free Software Foundation gives you unlimited permission to link
+   the compiled version of this file into combinations with other
+   programs, and to distribute those combinations without any
+   restriction coming from the use of this file.  (The General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into a combine executable.)
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING.  If not, write to the Free
+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifdef IN_LIBGCC2
+
+#include "tconfig.h"
+#include "coretypes.h"
+#include "tm.h"
+
+#ifndef LIBGCC2_WORDS_BIG_ENDIAN
+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN
+#endif
+
+#ifndef LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
+#define LIBGCC2_FLOAT_WORDS_BIG_ENDIAN LIBGCC2_WORDS_BIG_ENDIAN
+#endif
+
+#if LIBGCC2_FLOAT_WORDS_BIG_ENDIAN
+#define WORDS_BIGENDIAN 1
+#endif
+
+#else
+
+#include "config.h"
+
+#endif
diff --git a/libdecnumber/decContext.c b/libdecnumber/decContext.c
index 0774193..d2e3bed 100644
--- a/libdecnumber/decContext.c
+++ b/libdecnumber/decContext.c
@@ -37,7 +37,7 @@
 
 #include <string.h>	      /* for strcmp */
 #include <stdio.h>	      /* for printf if DECCHECK */
-#include "config.h"	      /* for GCC definitions */
+#include "dconfig.h"	      /* for GCC definitions */
 #include "decContext.h"	      /* context and base types */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
 
diff --git a/libdecnumber/decExcept.c b/libdecnumber/decExcept.c
index 6821702..a111aee 100644
--- a/libdecnumber/decExcept.c
+++ b/libdecnumber/decExcept.c
@@ -28,7 +28,7 @@
    02110-1301, USA.  */
 
 #include <fenv.h>
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 #include "decExcept.h"
 
diff --git a/libdecnumber/decExcept.h b/libdecnumber/decExcept.h
index 12ba87d..5dc1ebb 100644
--- a/libdecnumber/decExcept.h
+++ b/libdecnumber/decExcept.h
@@ -28,7 +28,7 @@
    02110-1301, USA.  */
 
 #include <fenv.h>
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 
 #define DFP_EXCEPTIONS_ENABLED 1
diff --git a/libdecnumber/decLibrary.c b/libdecnumber/decLibrary.c
index 7e5e928..86daedd 100644
--- a/libdecnumber/decLibrary.c
+++ b/libdecnumber/decLibrary.c
@@ -27,7 +27,7 @@
    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 #include "decimal128.h"
 #include "decimal64.h"
diff --git a/libdecnumber/decNumber.c b/libdecnumber/decNumber.c
index c5e223c..f9a624a 100644
--- a/libdecnumber/decNumber.c
+++ b/libdecnumber/decNumber.c
@@ -170,7 +170,7 @@
 #include <stdio.h>		   /* for printf [if needed] */
 #include <string.h>		   /* for strcpy */
 #include <ctype.h>		   /* for lower */
-#include "config.h"		   /* for GCC definitions */
+#include "dconfig.h"		   /* for GCC definitions */
 #include "decNumber.h"		   /* base number library */
 #include "decNumberLocal.h"	   /* decNumber local types, etc. */
 
diff --git a/libdecnumber/decNumberLocal.h b/libdecnumber/decNumberLocal.h
index c07e8cd..809eaa4 100644
--- a/libdecnumber/decNumberLocal.h
+++ b/libdecnumber/decNumberLocal.h
@@ -44,7 +44,7 @@
 
   #include <stdlib.h>	      /* for abs			      */
   #include <string.h>	      /* for memset, strcpy		      */
-  #include "config.h"	      /* for WORDS_BIGENDIAN                  */
+  #include "dconfig.h"	      /* for WORDS_BIGENDIAN                  */
 
   /* Conditional code flag -- set this to match hardware platform     */
   /* 1=little-endian, 0=big-endian	                              */
diff --git a/libdecnumber/decRound.c b/libdecnumber/decRound.c
index 6e51eb6..26740bf 100644
--- a/libdecnumber/decRound.c
+++ b/libdecnumber/decRound.c
@@ -28,7 +28,7 @@
    Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301, USA.  */
 
-#include "config.h"
+#include "dconfig.h"
 #include "decContext.h"
 #include "decRound.h"
 
diff --git a/libdecnumber/dpd/decimal128.c b/libdecnumber/dpd/decimal128.c
index 0e32ceb..54191aa 100644
--- a/libdecnumber/dpd/decimal128.c
+++ b/libdecnumber/dpd/decimal128.c
@@ -42,7 +42,7 @@
 #include <string.h>	      /* [for memset/memcpy] */
 #include <stdio.h>	      /* [for printf] */
 
-#include "config.h"	      /* GCC definitions */
+#include "dconfig.h"	      /* GCC definitions */
 #define	 DECNUMDIGITS 34      /* make decNumbers with space for 34 */
 #include "decNumber.h"	      /* base number library */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
diff --git a/libdecnumber/dpd/decimal128Local.h b/libdecnumber/dpd/decimal128Local.h
index b4130b5..9765427 100644
--- a/libdecnumber/dpd/decimal128Local.h
+++ b/libdecnumber/dpd/decimal128Local.h
@@ -34,14 +34,14 @@
 
 /* Set sign; this assumes the sign was previously zero.  */
 #define decimal128SetSign(d,b) \
-  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] |= ((unsigned) (b) << 7); }
+  { (d)->bytes[WORDS_BIGENDIAN ? 0 : 15] |= ((unsigned) (b) << 7); }
 
 /* Clear sign.  */
 #define decimal128ClearSign(d) \
-  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] &= ~0x80; }
+  { (d)->bytes[WORDS_BIGENDIAN ? 0 : 15] &= ~0x80; }
 
 /* Flip sign.  */
 #define decimal128FlipSign(d) \
-  { (d)->bytes[FLOAT_WORDS_BIG_ENDIAN ? 0 : 15] ^= 0x80; }
+  { (d)->bytes[WORDS_BIGENDIAN ? 0 : 15] ^= 0x80; }
 
 #endif
diff --git a/libdecnumber/dpd/decimal32.c b/libdecnumber/dpd/decimal32.c
index 42bddf1..d8e3f59 100644
--- a/libdecnumber/dpd/decimal32.c
+++ b/libdecnumber/dpd/decimal32.c
@@ -42,7 +42,7 @@
 #include <string.h>	      /* [for memset/memcpy] */
 #include <stdio.h>	      /* [for printf] */
 
-#include "config.h"	      /* GCC definitions */
+#include "dconfig.h"	      /* GCC definitions */
 #define	 DECNUMDIGITS  7      /* make decNumbers with space for 7 */
 #include "decNumber.h"	      /* base number library */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
diff --git a/libdecnumber/dpd/decimal64.c b/libdecnumber/dpd/decimal64.c
index c3617c4..474eb7c 100644
--- a/libdecnumber/dpd/decimal64.c
+++ b/libdecnumber/dpd/decimal64.c
@@ -42,7 +42,7 @@
 #include <string.h>	      /* [for memset/memcpy] */
 #include <stdio.h>	      /* [for printf] */
 
-#include "config.h"	      /* GCC definitions */
+#include "dconfig.h"	      /* GCC definitions */
 #define	 DECNUMDIGITS 16      /* make decNumbers with space for 16 */
 #include "decNumber.h"	      /* base number library */
 #include "decNumberLocal.h"   /* decNumber local types, etc. */
diff --git a/libiberty/configure b/libiberty/configure
index e444bd3..6b46411 100644
--- a/libiberty/configure
+++ b/libiberty/configure
@@ -3696,6 +3696,7 @@ case "${host}" in
   *-*-freebsd2.2.[012])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[34567]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [ -n "${frag}" ]; then
diff --git a/libiberty/configure.ac b/libiberty/configure.ac
index 864db17..6fc793b 100644
--- a/libiberty/configure.ac
+++ b/libiberty/configure.ac
@@ -184,6 +184,7 @@ case "${host}" in
   *-*-freebsd2.2.[[012]])	frag=mh-fbsd21 ;;
   i370-*-opened*)       frag=mh-openedition ;;
   i[[34567]]86-*-windows*)	frag=mh-windows ;;
+  *-*-mingw*)		frag=mh-mingw ;;
 esac
 
 if [[ -n "${frag}" ]]; then
diff --git a/opcodes/ChangeLog.sts-gdb b/opcodes/ChangeLog.sts-gdb
new file mode 100644
index 0000000..bdc646d
--- /dev/null
+++ b/opcodes/ChangeLog.sts-gdb
@@ -0,0 +1,4 @@
+2006-03-08  Andrew Stubbs  <andrew.stubbs@st.com>
+
+	* sh-opc.h: Add st40-300 variants.
+	* sh-dis.c: Likewise.
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 8cd2be1..d870fba 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -123,6 +123,8 @@ CFILES = \
 	iq2000-dis.c \
 	iq2000-ibld.c \
 	iq2000-opc.c \
+	lx-opc.c \
+	lx-dis.c \
 	m32c-asm.c \
 	m32c-desc.c \
 	m32c-dis.c \
@@ -265,6 +267,8 @@ ALL_MACHINES = \
 	iq2000-dis.lo \
 	iq2000-ibld.lo \
 	iq2000-opc.lo \
+	lx-opc.lo \
+	lx-dis.lo \
 	m32c-asm.lo \
 	m32c-desc.lo \
 	m32c-dis.lo \
@@ -900,6 +904,8 @@ iq2000-opc.lo: iq2000-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   iq2000-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
   $(INCDIR)/symcat.h $(INCDIR)/opcode/cgen-bitset.h iq2000-opc.h \
   $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h
+lx-opc.lo: lx-opc.c $(INCDIR)/ansidecl.h ../include/opcode/lx.h $(BFD_H)
+lx-dis.lo: lx-dis.c $(INCDIR)/ansidecl.h ../include/opcode/lx.h $(BFD_H)
 m32c-asm.lo: m32c-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h $(INCDIR)/symcat.h \
   m32c-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 73642f1..904eb97 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -352,6 +352,8 @@ CFILES = \
 	iq2000-dis.c \
 	iq2000-ibld.c \
 	iq2000-opc.c \
+	lx-opc.c \
+	lx-dis.c \
 	m32c-asm.c \
 	m32c-desc.c \
 	m32c-dis.c \
@@ -494,6 +496,8 @@ ALL_MACHINES = \
 	iq2000-dis.lo \
 	iq2000-ibld.lo \
 	iq2000-opc.lo \
+	lx-opc.lo \
+	lx-dis.lo \
 	m32c-asm.lo \
 	m32c-desc.lo \
 	m32c-dis.lo \
@@ -1452,6 +1456,8 @@ iq2000-opc.lo: iq2000-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   iq2000-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
   $(INCDIR)/symcat.h $(INCDIR)/opcode/cgen-bitset.h iq2000-opc.h \
   $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h
+lx-opc.lo: lx-opc.c $(INCDIR)/ansidecl.h ../include/opcode/lx.h $(BFD_H)
+lx-dis.lo: lx-dis.c $(INCDIR)/ansidecl.h ../include/opcode/lx.h $(BFD_H)
 m32c-asm.lo: m32c-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h $(INCDIR)/symcat.h \
   m32c-desc.h $(INCDIR)/opcode/cgen-bitset.h $(INCDIR)/opcode/cgen.h \
diff --git a/opcodes/configure b/opcodes/configure
index 80b1a74..27c9de4 100644
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -11541,6 +11541,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ia64_arch)		ta="$ta ia64-dis.lo ia64-opc.lo" ;;
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
         bfd_iq2000_arch)        ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+ 	bfd_lx_arch)            ta="$ta lx-opc.lo lx-dis.lo" ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
diff --git a/opcodes/configure.in b/opcodes/configure.in
index 08011be..262f4d5 100644
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -1,3 +1,5 @@
+dnl THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+
 dnl Process this file with autoconf to produce a configure script.
 dnl
 
@@ -195,6 +197,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_ia64_arch)		ta="$ta ia64-dis.lo ia64-opc.lo" ;;
 	bfd_ip2k_arch)		ta="$ta ip2k-asm.lo ip2k-desc.lo ip2k-dis.lo ip2k-ibld.lo ip2k-opc.lo" using_cgen=yes ;;
         bfd_iq2000_arch)        ta="$ta iq2000-asm.lo iq2000-desc.lo iq2000-dis.lo iq2000-ibld.lo iq2000-opc.lo" using_cgen=yes ;;
+ 	bfd_lx_arch)            ta="$ta lx-opc.lo lx-dis.lo" ;;
 	bfd_m32c_arch)		ta="$ta m32c-asm.lo m32c-desc.lo m32c-dis.lo m32c-ibld.lo m32c-opc.lo" using_cgen=yes ;;
 	bfd_m32r_arch)		ta="$ta m32r-asm.lo m32r-desc.lo m32r-dis.lo m32r-ibld.lo m32r-opc.lo m32r-opinst.lo" using_cgen=yes ;;
 	bfd_m68hc11_arch)	ta="$ta m68hc11-dis.lo m68hc11-opc.lo" ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 66850a7..b7a3d0e 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -1,3 +1,7 @@
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2003
+*/
+
 /* Select disassembly routine for specified architecture.
    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
    2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@@ -35,6 +39,7 @@
 #define ARCH_d30v
 #define ARCH_dlx
 #define ARCH_fr30
+#define ARCH_lx
 #define ARCH_frv
 #define ARCH_h8300
 #define ARCH_h8500
@@ -223,6 +228,18 @@ disassembler (abfd)
       disassemble = print_insn_fr30;
       break;
 #endif
+#ifdef ARCH_lx 
+    case bfd_arch_lx:
+      if (bfd_big_endian (abfd))
+        {
+          disassemble = print_insn_big_lx;
+        }
+      else
+        {
+          disassemble = print_insn_little_lx;
+        }
+      break; 
+#endif
 #ifdef ARCH_m32r
     case bfd_arch_m32r:
       disassemble = print_insn_m32r;
diff --git a/opcodes/lx-dis.c b/opcodes/lx-dis.c
new file mode 100644
index 0000000..a4505f0
--- /dev/null
+++ b/opcodes/lx-dis.c
@@ -0,0 +1,314 @@
+/**
+*** (c) Copyright Hewlett-Packard Company 1999-2003
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**/
+
+/**
+*** static char sccs_id[] = "@(#)lx-dis.c	1.6 12/13/99 09:13:48";
+**/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "ansidecl.h"
+#include "sysdep.h"
+#include "dis-asm.h"
+#include "opcode/lx.h"
+#include "elf/lx.h"
+
+extern struct gdbarch *current_gdbarch;
+extern struct bfd_arch_info * gdbarch_bfd_arch_info (struct gdbarch *gdbarch);
+
+/* Things to do 
+ *     -- immext is handled as a bit of a hack
+ *     -- bit extraction and insertion should be handled in
+ *        lx-opc.c
+ *     -- handle bundles, cluster info
+ *
+ */
+
+/* Extra info passed by objdump (DUPLICATED from objdump.c !!!) */
+struct objdump_disasm_info {
+  bfd *abfd;
+  asection *sec;
+  bfd_boolean require_sec;
+};
+
+static int
+print_insn_lx (bfd_vma memaddr, struct disassemble_info *info, int bigendian)
+{
+  lxopc_t *op;         /* operation table index */
+  bfd_byte buffer[4];  /* buffer for code       */
+  unsigned insn;       /* the instruction       */
+  unsigned extension = 0;  /* immediate extension   */
+  int hasextension = 0;/* flag for imm. ext.    */
+  int status;          /* temp                  */
+  int extnstop = 0;
+  int extnclusterstop = 0;
+  static int cluster = 0;
+  char *fmtp;
+  int ch;
+  lxopc_t *opc_table = NULL;
+
+  /* The CompilerTeamApproach doesn't work (tested using binutils 2.18) */ 
+  /* please note: info->application_data is "NULL" now                    */
+#ifdef CompilerTeamApproach 
+  struct objdump_disasm_info *aux;
+  flagword elf_private_flags = 0;
+  int lx_core = 0;
+  
+  /* check that tables are initialized */
+
+  /*  lx_init_asm_table(); */
+  /* Get the enconding table to use (.../st231/...) */
+  aux = (struct objdump_disasm_info *) info->application_data;
+  elf_private_flags = lx_elf_get_private_flags(aux->abfd);
+  lx_core = elf_private_flags & ELF_LX_CORE_MASK;
+  switch (lx_core) {
+  case ELF_LX_CORE_ST231:
+      opc_table = st231_lxoptab;
+      break;
+  case ELF_LX_CORE_ST240:
+      opc_table = st240_lxoptab;
+      break;
+  default:
+      /* Core not supported */
+      (*info->fprintf_func)(info->stream, "disassembling not supported for this ST2xx core!");
+      return -1;
+  }
+#else 
+
+  struct bfd_arch_info  *ainfo;
+  ainfo = gdbarch_bfd_arch_info(current_gdbarch); /* Please see: mcdtgr_gdb/gdb/gdbarch.h */
+  
+  switch (ainfo->mach) {
+
+  case bfd_mach_st231:
+      opc_table = st231_lxoptab;
+      break;
+  case bfd_mach_st240:
+      opc_table = st240_lxoptab;
+      break;
+  default:
+      /* Core not supported */
+      (*info->fprintf_func)(info->stream, "disassembling not supported for this ST2xx core!");
+      return -1;
+  }
+#endif
+
+  if (opc_table == NULL) {
+      fprintf(stderr, "error: uninitialized ST2xx opcode table\n");
+      exit(-1);
+  }
+
+  /* read the instruction */
+
+  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
+  if (bigendian)
+    insn = bfd_getb32 (buffer);
+  else
+    insn = bfd_getl32 (buffer);
+
+  if ((LXISIMMEXTL(insn)) || (LXISIMMEXTR(insn)))
+    {
+      (*info->fprintf_func) (info->stream, "");
+      return 4;
+    }
+
+  /* read ahead/back one word if possible   */
+  /* check this for extension syllable */
+
+  if ((memaddr & 4)) /* instruction is odd aligned */
+    {
+
+      /* check for extension to right       */
+      /* iff this is not the end of bundle */
+
+      if (!LXSTOP(insn))
+	{
+	  status = (*info->read_memory_func) (memaddr + 4, buffer, 4, info);
+
+	  if (status == 0)
+	    {
+	      if (bigendian)
+		extension = bfd_getb32 (buffer);
+	      else
+		extension = bfd_getl32 (buffer);
+	      if (LXISIMMEXTL(extension))
+		{
+		  hasextension = 1;
+		  extnstop = LXSTOP(extension);
+		  extnclusterstop = LXCLUSTER(extension);
+		  extension = LXIMMVAL(extension);
+		};
+	    }
+	}
+
+      /* check for extension to left */
+
+      if (!hasextension) 
+	{
+	  status = (*info->read_memory_func) (memaddr - 4, buffer, 4, info);
+	  
+	  if (status == 0)
+	    {
+	      if (bigendian)
+		extension = bfd_getb32 (buffer);
+	      else
+		extension = bfd_getl32 (buffer);
+	      if (!LXSTOP(extension) && LXISIMMEXTR(extension))
+		{
+		  hasextension = 1;
+		  extension = LXIMMVAL(extension);
+		};
+	    }
+	}
+    }
+
+  for (op = opc_table; op->as_op; op++)  /* find the format of this inst */
+    {
+      if ((op->mask & insn) == op->opcode)
+	{
+	  int i;
+
+	  /* print the opcode   */
+
+	  (*info->fprintf_func) (info->stream, "%s ", op->as_op);
+
+	  /* print the operands using the instructions format string. */
+
+	  fmtp = op->fmtstring;
+
+	  for (i = 0; op->format[i]; i++)
+	    {
+	      /* if (op->format[i]) */
+		{
+		  int shift = op->format[i]->shift;
+		  int bits  = op->format[i]->bits;
+		  int type  = op->format[i]->type;
+		  int flags = op->format[i]->flags;
+		  int value;
+		  int ch;
+
+		  /* Print characters in the format string up to the following
+		     % or nul. */
+		  while((ch=*fmtp) && ch != '%')
+		    {
+		      (*info->fprintf_func)(info->stream, "%c", ch);
+		      fmtp++;
+		    }
+
+		  /* Skip past %s */
+		  if(ch == '%')
+		    {
+		      ch=*fmtp++;
+		      /* if(ch != 's')
+			 give error message */
+		      fmtp++;
+		    }
+		  
+		  value = (insn >> shift) & ~(-1 << bits);
+		  if (flags & lxSIGNED)
+		    {
+		      int signbit = 1 << (bits -1);
+		      value = (value ^ signbit) - signbit;
+		    };
+		  switch (type)
+		    {
+		    case RegClass_st200_general :
+		    case RegClass_st200_nolink :
+		      (*info->fprintf_func)(info->stream,"$r%d", value);
+		      break;
+		    case RegClass_st200_paired :
+		    case RegClass_st200_nzpaired :
+		      (*info->fprintf_func)(info->stream,"$p%d", value);
+		      break;
+		    case RegClass_st200_branch :
+		    case RegClass_st200_predicate :
+		      (*info->fprintf_func)(info->stream,"$b%d", value);
+		      break;
+		    case RegClass_st200_link :
+		      (*info->fprintf_func)(info->stream,"$r63");
+		      break;
+		    case Immediate_st200_brknum:
+		    case Immediate_st200_imm:
+		    case Immediate_st200_isrc2:
+		    case Immediate_st200_sbrknum:
+		    case Immediate_st200_xsrc2:
+		      if (hasextension)
+			value = (value & ~(-1 << bits)) | extension;
+		      (*info->fprintf_func)(info->stream,"%d (0x%x)", value, value);
+		      break;
+		    case Immediate_st200_btarg:
+		      (*info->print_address_func)((value * 4) + memaddr, info);
+		      break;
+		    case RegClass_st200_pairedfirst:
+		    case RegClass_st200_pairedsecond:
+		    default:
+		      fprintf(stderr, "error: unexpected operand type (%d)\n", type);
+		      exit(-1);
+		    };
+		}
+		/*else
+		break;*/
+	    }
+
+	  /* Print trailing characters in the format string, if any */
+	  while((ch=*fmtp))
+	    {
+	      (*info->fprintf_func)(info->stream, "%c", ch);
+	      fmtp++;
+	    }
+
+#if MULTI_CLUSTERS_SUPPORTED
+	  if (LXCLUSTER(insn) || extnclusterstop)
+	    cluster++;
+#else
+	  if (LXCLUSTER(insn) || extnclusterstop)
+	       (*info->fprintf_func)(info->stream, 
+				     "(*** warning: Cluster Bit set!)");
+#endif	  
+	  if (LXSTOP(insn) || extnstop)
+	    {
+	      (*info->fprintf_func)(info->stream, ";;");
+	      cluster = 0;
+	    }
+	  return 4;
+	};
+    }
+  
+  /* couldn't find the opcode, skip this word */
+  
+  (*info->fprintf_func) (info->stream, "*** warning: invalid opcode");
+  return 4;
+}
+
+
+int 
+print_insn_big_lx (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_lx (memaddr, info, 1);
+}
+
+int
+print_insn_little_lx (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_lx (memaddr, info, 0);
+}
diff --git a/opcodes/lx-opc.c b/opcodes/lx-opc.c
new file mode 100644
index 0000000..ff4ae7e
--- /dev/null
+++ b/opcodes/lx-opc.c
@@ -0,0 +1,1691 @@
+/**
+*** (c) Copyright STMicroelectronics, Inc. 1999-2005.
+***
+*** This program is free software; you can redistribute it and/or
+*** modify it under the terms of the GNU General Public License
+*** as published by the Free Software Foundation; either version
+*** 2 of the License, or (at your option) any later version.
+***
+*** This program is distributed in the hope that it will be useful,
+*** but WITHOUT ANY WARRANTY; without even the implied warranty of
+*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+*** General Public License for more details.
+***
+*** You should have received a copy of the GNU General Public License
+*** along with this program; if not, write to the Free Software
+*** Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+***
+*** --------------------------------------------------
+***                *** DO NOT EDIT ***
+***  This file was automatically generated by the
+***  Machine Description System (MDS) of STMicroelectronics, Inc.
+*** --------------------------------------------------
+**/
+/*
+  THIS FILE HAS BEEN MODIFIED OR ADDED BY STMicroelectronics, Inc. 1999-2005
+*/
+
+#include <stddef.h>
+#include <stdio.h>
+#include <opcode/lx.h>
+#include <elf/lx.h>
+
+static lxbfield bcond = {"bcond", RegClass_st200_branch, 3, 23, 0};
+static lxbfield bdest = {"bdest", RegClass_st200_branch, 3, 18, 0};
+static lxbfield bdest2 = {"bdest2", RegClass_st200_branch, 3, 12, 0};
+static lxbfield brknum = {"brknum", Immediate_st200_brknum, 12, 0, 0};
+static lxbfield bsrc1 = {"bsrc1", RegClass_st200_branch, 3, 0, 0};
+static lxbfield bsrc2 = {"bsrc2", RegClass_st200_branch, 3, 6, 0};
+static lxbfield btarg = {"btarg", Immediate_st200_btarg, 23, 0, lxSIGNED};
+static lxbfield dest = {"dest", RegClass_st200_general, 6, 12, 0};
+static lxbfield ibdest = {"ibdest", RegClass_st200_branch, 3, 6, 0};
+static lxbfield idest = {"idest", RegClass_st200_general, 6, 6, 0};
+static lxbfield idestp = {"idestp", RegClass_st200_nzpaired, 6, 6, 0};
+static lxbfield imm = {"imm", Immediate_st200_imm, 23, 0, lxSIGNED};
+static lxbfield isrc2 = {"isrc2", Immediate_st200_isrc2, 9, 12, lxSIGNED | lxCANEXTEND};
+static lxbfield nldest = {"nldest", RegClass_st200_nolink, 6, 12, 0};
+static lxbfield nlidest = {"nlidest", RegClass_st200_nolink, 6, 6, 0};
+static lxbfield pcond = {"pcond", RegClass_st200_predicate, 3, 21, 0};
+static lxbfield sbrknum = {"sbrknum", Immediate_st200_sbrknum, 21, 0, 0};
+static lxbfield scond = {"scond", RegClass_st200_branch, 3, 21, 0};
+static lxbfield src1 = {"src1", RegClass_st200_general, 6, 0, 0};
+static lxbfield src2 = {"src2", RegClass_st200_general, 6, 6, 0};
+static lxbfield src2p = {"src2p", RegClass_st200_paired, 6, 6, 0};
+static lxbfield link = {"link", RegClass_st200_link, 0, 0, 0};
+
+#define Bundling_st200_ANY 1
+#define Bundling_st200_ANYX 2
+#define Bundling_st200_FIRST 3
+#define Bundling_st200_EVEN 4
+#define Bundling_st200_MEM 5
+#define Bundling_st200_MEMX 6
+#define Bundling_st200_ODD 7
+#define Bundling_st200_ALONE 8
+#define Bundling_st200_ALONEX 9
+
+BundleType bundle_types[] = {
+#define Bundle_st200_EVEN_ANY_MEM_0_8 0
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_MEM_4_8 1
+  { 3, 4, 8, 1, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_MEM }, { 2, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_MEM_4_8 2
+  { 3, 4, 8, 1, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_MEM }, { 2, -1 } }, 
+#define Bundle_st200_FIRST_MEM_EVEN_0_16 3
+  { 3, 0, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_MEM_ANY_0_8 4
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_MEM_4_8 5
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_MEM_ANY_0_8 6
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ANY_MEM_4_8 7
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_MEM_4_8 8
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_EVEN_ANY_0_16 9
+  { 4, 0, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_MEM_4_8 10
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_EVEN_ODD_0_16 11
+  { 4, 0, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_EVEN_0_16 12
+  { 2, 0, 16, 0, { Bundling_st200_MEMX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_MEMX_4_16 13
+  { 2, 4, 16, 1, { Bundling_st200_EVEN, Bundling_st200_MEMX }, { 0, -1 } }, 
+#define Bundle_st200_EVEN_MEMX_8_16 14
+  { 2, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_MEMX_EVEN_12_16 15
+  { 2, 12, 16, 1, { Bundling_st200_MEMX, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_MEMX_EVEN_ANY_0_16 16
+  { 3, 0, 16, 0, { Bundling_st200_MEMX, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_MEMX_4_16 17
+  { 3, 4, 16, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_EVEN_MEMX_ANY_8_16 18
+  { 3, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_EVEN_12_16 19
+  { 3, 12, 16, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_MEMX_EVEN_ODD_0_16 20
+  { 3, 0, 16, 0, { Bundling_st200_MEMX, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_MEMX_4_16 21
+  { 3, 4, 16, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_EVEN_MEMX_ODD_8_16 22
+  { 3, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_MEMX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_ODD_EVEN_12_16 23
+  { 3, 12, 16, 0, { Bundling_st200_MEMX, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_MEM_0_16 24
+  { 3, 0, 16, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEM_EVEN_ANYX_4_16 25
+  { 3, 4, 16, 0, { Bundling_st200_MEM, Bundling_st200_EVEN, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_EVEN_ANYX_MEM_8_16 26
+  { 3, 8, 16, 0, { Bundling_st200_EVEN, Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEM_ANYX_EVEN_12_16 27
+  { 3, 12, 16, 0, { Bundling_st200_MEM, Bundling_st200_ANYX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_0_4 28
+  { 1, 0, 4, 0, { Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_0_4 29
+  { 1, 0, 4, 0, { Bundling_st200_FIRST }, { -1 } }, 
+#define Bundle_st200_MEM_0_4 30
+  { 1, 0, 4, 0, { Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ALONE_0_4 31
+  { 1, 0, 4, 0, { Bundling_st200_ALONE }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_0_4 32
+  { 2, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_0_4 33
+  { 2, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_MEM_0_4 34
+  { 2, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_0_4 35
+  { 2, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_ANY_0_4 36
+  { 3, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ANY_0_4 37
+  { 3, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEM_ANY_ANY_0_4 38
+  { 3, 0, 4, 0, { Bundling_st200_MEM, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_ANY_0_4 39
+  { 3, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_ANY_ANY_0_4 40
+  { 4, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ANY_ANY_0_4 41
+  { 4, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ANY_ANY_MEM_0_4 42
+  { 4, 0, 4, 0, { Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ANY_MEM_0_4 43
+  { 4, 0, 4, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_0_8 44
+  { 1, 0, 8, 0, { Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_4_8 45
+  { 1, 4, 8, 1, { Bundling_st200_EVEN }, { 0, -1 } }, 
+#define Bundle_st200_ANY_ODD_0_8 46
+  { 2, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_4_8 47
+  { 2, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_0_8 48
+  { 2, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_4_8 49
+  { 2, 4, 8, 1, { Bundling_st200_FIRST, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_EVEN_ODD_0_8 50
+  { 2, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_4_8 51
+  { 2, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_MEM_ODD_0_8 52
+  { 2, 0, 8, 0, { Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_MEM_4_8 53
+  { 2, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_0_8 54
+  { 2, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_4_8 55
+  { 2, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_ANY_0_8 56
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_4_8 57
+  { 3, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_ANY_0_8 58
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ANY_4_8 59
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_EVEN_0_8 60
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_4_8 61
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_EVEN_0_8 62
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_4_8 63
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_EVEN_0_8 64
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_EVEN_4_8 65
+  { 3, 4, 8, 1, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_EVEN }, { 2, -1 } }, 
+#define Bundle_st200_EVEN_ODD_EVEN_0_8 66
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_EVEN_4_8 67
+  { 3, 4, 8, 1, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_EVEN }, { 2, -1 } }, 
+#define Bundle_st200_EVEN_ODD_MEM_0_8 68
+  { 3, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_MEM_4_8 69
+  { 3, 4, 8, 1, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_MEM }, { 2, -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_0_8 70
+  { 3, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_ANY_4_8 71
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_0_8 72
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ODD_4_8 73
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_MEM_0_8 74
+  { 3, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_MEM_4_8 75
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_MEM_0_8 76
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_ODD_4_8 77
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_ANY_0_8 78
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_ANY_ANY_4_8 79
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_ANY_ANY_0_8 80
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ANY_ANY_4_8 81
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_ODD_0_8 82
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_ODD_ANY_4_8 83
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_EVEN_ODD_0_8 84
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_ANY_4_8 85
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_ANY_0_8 86
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_ODD_ANY_4_8 87
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_EVEN_ANY_0_8 88
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_ANY_4_8 89
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_ODD_0_8 90
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_EVEN_ODD_0_8 91
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_EVEN_ANY_0_8 92
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ODD_EVEN_4_8 93
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_EVEN_ODD_0_8 94
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_EVEN_4_8 95
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ANY_MEM_0_8 96
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ODD_ANY_MEM_ANY_4_8 97
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_MEM_ODD_0_8 98
+  { 4, 0, 8, 0, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_MEM_ODD_ANY_4_8 99
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_MEM_ODD_0_8 100
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_MEM_4_8 101
+  { 4, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_ANY_ANY_0_8 102
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_ANY_4_8 103
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANY_EVEN_ANY_0_8 104
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_ANY_4_8 105
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_EVEN_ANY_EVEN_ANY_0_8 106
+  { 4, 0, 8, 0, { Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANY_EVEN_ANY_EVEN_4_8 107
+  { 4, 4, 8, 0, { Bundling_st200_ANY, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_ANY_MEM_0_8 108
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_MEM_ODD_ANY_4_8 109
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEM, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ODD_MEM_ODD_0_8 110
+  { 4, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_ANY_0_8 111
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_ANY_4_8 112
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_ODD_0_8 113
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_ANY_4_8 114
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_ANY_0_8 115
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_ANY_4_8 116
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_ODD_0_8 117
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_ANY_0_8 118
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_EVEN_4_8 119
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_ODD_0_8 120
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_EVEN_4_8 121
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_MEM_0_8 122
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANYX_MEM_ANY_4_8 123
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_MEM_ODD_0_8 124
+  { 3, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_MEM_4_8 125
+  { 3, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_ANY_0_8 126
+  { 3, 0, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_ANY_4_8 127
+  { 3, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_ODD_0_8 128
+  { 3, 0, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_ODD_ANY_4_8 129
+  { 3, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ODD, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_ANY_0_8 130
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_ANY_4_8 131
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_ODD_0_8 132
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_MEM_0_8 133
+  { 3, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_MEM_4_8 134
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_0_8 135
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_ANYX_ANY_4_8 136
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_0_8 137
+  { 2, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_4_8 138
+  { 2, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_0_8 139
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_EVEN_4_8 140
+  { 2, 4, 8, 1, { Bundling_st200_ANYX, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_ANYX_MEM_0_8 141
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_ANYX_MEM_4_8 142
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEM }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_0_8 143
+  { 2, 0, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_MEMX_ANY_4_8 144
+  { 2, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ANY }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_0_8 145
+  { 2, 0, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_4_8 146
+  { 2, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_ANYX_0_8 147
+  { 1, 0, 8, 0, { Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_4_8 148
+  { 1, 4, 8, 0, { Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_MEMX_0_8 149
+  { 1, 0, 8, 0, { Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_MEMX_4_8 150
+  { 1, 4, 8, 0, { Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_ALONEX_0_8 151
+  { 1, 0, 8, 0, { Bundling_st200_ALONEX }, { -1 } }, 
+#define Bundle_st200_ALONEX_4_8 152
+  { 1, 4, 8, 0, { Bundling_st200_ALONEX }, { -1 } }, 
+#define Bundle_st200_ANYX_ANYX_0_8 153
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_ANYX_4_8 154
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ANYX }, { -1 } }, 
+#define Bundle_st200_ANYX_MEMX_0_8 155
+  { 2, 0, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_ANYX_MEMX_4_8 156
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_EVEN_MEM_0_8 157
+  { 2, 0, 8, 1, { Bundling_st200_EVEN, Bundling_st200_MEM }, { 1, -1 } }, 
+#define Bundle_st200_EVEN_MEM_4_8 158
+  { 2, 4, 8, 2, { Bundling_st200_EVEN, Bundling_st200_MEM }, { 0, 2, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_MEMX_4_16 159
+  { 3, 4, 16, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_MEMX }, { -1 } }, 
+#define Bundle_st200_FIRST_MEMX_EVEN_12_16 160
+  { 3, 12, 16, 0, { Bundling_st200_FIRST, Bundling_st200_MEMX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ODD_0_8 161
+  { 1, 0, 8, 1, { Bundling_st200_ODD }, { 0, -1 } }, 
+#define Bundle_st200_ODD_4_8 162
+  { 1, 4, 8, 0, { Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_0_8 163
+  { 2, 0, 8, 1, { Bundling_st200_FIRST, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_4_8 164
+  { 2, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANY_ODD_ODD_0_8 165
+  { 3, 0, 8, 1, { Bundling_st200_ANY, Bundling_st200_ODD, Bundling_st200_ODD }, { 2, -1 } }, 
+#define Bundle_st200_ODD_ANY_ODD_4_8 166
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_ANY, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_ODD_ODD_0_8 167
+  { 3, 0, 8, 1, { Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_ODD }, { 2, -1 } }, 
+#define Bundle_st200_ODD_EVEN_ODD_4_8 168
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_EVEN, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_ODD_MEM_ODD_0_8 169
+  { 3, 0, 8, 1, { Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { 0, -1 } }, 
+#define Bundle_st200_ODD_MEM_ODD_4_8 170
+  { 3, 4, 8, 0, { Bundling_st200_ODD, Bundling_st200_MEM, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ANY_EVEN_4_8 171
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ANY, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_EVEN_ODD_EVEN_4_8 172
+  { 4, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_ODD, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_FIRST_ANYX_EVEN_4_8 173
+  { 3, 4, 8, 0, { Bundling_st200_FIRST, Bundling_st200_ANYX, Bundling_st200_EVEN }, { -1 } }, 
+#define Bundle_st200_ANYX_ODD_0_8 174
+  { 2, 0, 8, 1, { Bundling_st200_ANYX, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_ANYX_ODD_4_8 175
+  { 2, 4, 8, 0, { Bundling_st200_ANYX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_MEMX_ODD_0_8 176
+  { 2, 0, 8, 1, { Bundling_st200_MEMX, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_MEMX_ODD_4_8 177
+  { 2, 4, 8, 0, { Bundling_st200_MEMX, Bundling_st200_ODD }, { -1 } }, 
+#define Bundle_st200_EVEN_EVEN_0_8 178
+  { 2, 0, 8, 1, { Bundling_st200_EVEN, Bundling_st200_EVEN }, { 1, -1 } }, 
+#define Bundle_st200_EVEN_EVEN_4_8 179
+  { 2, 4, 8, 2, { Bundling_st200_EVEN, Bundling_st200_EVEN }, { 0, 2, -1 } }, 
+#define Bundle_st200_ODD_ODD_0_8 180
+  { 2, 0, 8, 2, { Bundling_st200_ODD, Bundling_st200_ODD }, { 0, 2, -1 } }, 
+#define Bundle_st200_ODD_ODD_4_8 181
+  { 2, 4, 8, 1, { Bundling_st200_ODD, Bundling_st200_ODD }, { 1, -1 } }, 
+#define Bundle_st200_FIRST_ODD_ODD_0_8 182
+  { 3, 0, 8, 1, { Bundling_st200_FIRST, Bundling_st200_ODD, Bundling_st200_ODD }, { 2, -1 } }, 
+#define Bundle_st200_FIRST_EVEN_EVEN_4_8 183
+  { 3, 4, 8, 1, { Bundling_st200_FIRST, Bundling_st200_EVEN, Bundling_st200_EVEN }, { 2, -1 } }, 
+  { -1, 0, 0, 0, {}, {} }};
+
+short bundlematch_table_size = 3391;
+short bundlematch_table[3391 + 1] = { 
+ /*     0 */    -1,    0,    1,    2,    3,    4,    5,    6,    7,    8,
+ /*    10 */     9,   10,   11,   12,   13,   14,   15,   -1,   -1,   -1,
+ /*    20 */    16,   17,   18,   19,   20,   21,   -1,   -1,   -1,   -1,
+ /*    30 */    -1,   22,   23,   24,   25,   -1,   -1,   -1,   -1,   -1,
+ /*    40 */    26,   27,   28,   29,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    50 */    -1,   -1,   30,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    60 */    -1,   31,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    70 */    32,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    80 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*    90 */    -1,   33,   34,   35,   36,   37,   38,   39,   -1,   -1,
+ /*   100 */    -1,   -1,   40,   41,   42,   -1,   43,   -1,   -1,   -1,
+ /*   110 */    -1,   -1,   44,   45,   46,   47,   -1,   -1,   -1,   -1,
+ /*   120 */    -1,   48,   49,   50,   51,   -1,   -1,   -1,   -1,   -1,
+ /*   130 */    -1,   -1,   -1,   52,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   140 */    -1,   -1,   53,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   150 */    -1,   54,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   190 */    -1,   -1,   -1,   55,   56,   -1,   57,   -1,   -1,   -1,
+ /*   200 */    -1,   -1,   -1,   58,   -1,   59,   -1,   -1,   -1,   -1,
+ /*   210 */    -1,   -1,   -1,   -1,   60,   -1,   -1,   -1,   -1,   -1,
+ /*   220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   280 */    -1,   -1,   -1,   61,   62,   63,   64,   -1,   -1,   -1,
+ /*   290 */    -1,   -1,   -1,   -1,   -1,   65,   -1,   -1,   -1,   -1,
+ /*   300 */    -1,   -1,   -1,   -1,   66,   -1,   -1,   -1,   -1,   -1,
+ /*   310 */    -1,   -1,   -1,   67,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   68,   -1,   -1,
+ /*   370 */    -1,   -1,   -1,   -1,   -1,   -1,   69,   -1,   -1,   -1,
+ /*   380 */    -1,   -1,   -1,   -1,   -1,   70,   -1,   -1,   -1,   -1,
+ /*   390 */    -1,   -1,   -1,   -1,   71,   -1,   -1,   -1,   -1,   -1,
+ /*   400 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   410 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   420 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   430 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   440 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   450 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   460 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   470 */    -1,   -1,   -1,   -1,   -1,   72,   -1,   -1,   -1,   -1,
+ /*   480 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   490 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   500 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   510 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   520 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   530 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   540 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   550 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   560 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   570 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   580 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   590 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   600 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   610 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   620 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   630 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   640 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   650 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   660 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   670 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   680 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   690 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   700 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   710 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   720 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   730 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   740 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   750 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   760 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   770 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   780 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   790 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   800 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   810 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   820 */    73,   -1,   74,   75,   76,   -1,   77,   -1,   -1,   -1,
+ /*   830 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   840 */    -1,   78,   79,   -1,   80,   -1,   -1,   -1,   -1,   -1,
+ /*   850 */    81,   82,   -1,   83,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   860 */    -1,   -1,   84,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   870 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   880 */    85,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   890 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   900 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   910 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   920 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   930 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   940 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   950 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   960 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   970 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   980 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*   990 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1000 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1010 */    -1,   -1,   86,   87,   -1,   88,   -1,   -1,   -1,   -1,
+ /*  1020 */    -1,   -1,   -1,   -1,   89,   -1,   -1,   -1,   -1,   -1,
+ /*  1030 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1040 */    -1,   -1,   90,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1050 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1060 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1070 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1080 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1090 */    -1,   -1,   -1,   -1,   -1,   -1,   91,   -1,   -1,   -1,
+ /*  1100 */    -1,   -1,   -1,   -1,   -1,   92,   -1,   -1,   -1,   -1,
+ /*  1110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1120 */    -1,   -1,   -1,   93,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1130 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1140 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1150 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1190 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1200 */    -1,   -1,   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,
+ /*  1210 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1280 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1290 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1300 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1310 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1370 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1380 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1390 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1400 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1410 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1420 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1430 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1440 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1450 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1460 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1470 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1480 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1490 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1500 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1510 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1520 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1530 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1540 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1550 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1560 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1570 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1580 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1590 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1600 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1610 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1620 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1630 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1640 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1650 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1660 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1670 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1680 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1690 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1700 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1710 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1720 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1730 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1740 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1750 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1760 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1770 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1780 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1790 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1800 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1810 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1820 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1830 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1840 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1850 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1860 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1870 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1880 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1890 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1900 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1910 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1920 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1930 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1940 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1950 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1960 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1970 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1980 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  1990 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2000 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2010 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2020 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2030 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2040 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2050 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2060 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2070 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2080 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2090 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2100 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2120 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2130 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2140 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2150 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2190 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2200 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2210 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2280 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2290 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2300 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2310 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2370 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2380 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2390 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2400 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2410 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2420 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2430 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2440 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2450 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2460 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2470 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2480 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2490 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2500 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2510 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2520 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2530 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2540 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2550 */    -1,   -1,   -1,   -1,   95,   -1,   -1,   -1,   -1,   -1,
+ /*  2560 */    -1,   -1,   -1,   96,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2570 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2580 */    -1,   97,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2590 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2600 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2610 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2620 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2630 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2640 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2650 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2660 */    -1,   -1,   98,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2670 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2680 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2690 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2700 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2710 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2720 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2730 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2740 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2750 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2760 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2770 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2780 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2790 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2800 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2810 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2820 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2830 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2840 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2850 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2860 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2870 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2880 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2890 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2900 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2910 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2920 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2930 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2940 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2950 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2960 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2970 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2980 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  2990 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3000 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3010 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3020 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3030 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3040 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3050 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3060 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3070 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3080 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3090 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3100 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3110 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3120 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3130 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3140 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3150 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3160 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3170 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3180 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3190 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3200 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3210 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3220 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3230 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3240 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3250 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3260 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3270 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3280 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3290 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3300 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3310 */    99,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3320 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3330 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3340 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3350 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3360 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3370 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3380 */    -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+ /*  3390 */    -1,  100,};
+
+BundleMatchType canonical_table[101] = {
+  { 1, { Bundle_st200_ANY_0_4 } },
+  { 2, { Bundle_st200_ANYX_0_8, Bundle_st200_ANYX_4_8 } },
+  { 1, { Bundle_st200_FIRST_0_4 } },
+  { 2, { Bundle_st200_EVEN_0_8, Bundle_st200_EVEN_4_8 } },
+  { 1, { Bundle_st200_MEM_0_4 } },
+  { 2, { Bundle_st200_MEMX_0_8, Bundle_st200_MEMX_4_8 } },
+  { 2, { Bundle_st200_ODD_0_8, Bundle_st200_ODD_4_8 } },
+  { 1, { Bundle_st200_ALONE_0_4 } },
+  { 2, { Bundle_st200_ALONEX_0_8, Bundle_st200_ALONEX_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_ANYX_ANY_0_8, Bundle_st200_ANYX_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANY_0_4 } },
+  { 2, { Bundle_st200_EVEN_ANY_0_8, Bundle_st200_ANY_EVEN_4_8 } },
+  { 1, { Bundle_st200_ANY_MEM_0_4 } },
+  { 2, { Bundle_st200_MEMX_ANY_0_8, Bundle_st200_MEMX_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_0_8, Bundle_st200_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_ANYX_ANYX_0_8, Bundle_st200_ANYX_ANYX_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANYX_0_8, Bundle_st200_FIRST_ANYX_4_8 } },
+  { 2, { Bundle_st200_ANYX_EVEN_0_8, Bundle_st200_ANYX_EVEN_4_8 } },
+  { 2, { Bundle_st200_ANYX_MEM_0_8, Bundle_st200_ANYX_MEM_4_8 } },
+  { 2, { Bundle_st200_ANYX_MEMX_0_8, Bundle_st200_ANYX_MEMX_4_8 } },
+  { 2, { Bundle_st200_ANYX_ODD_0_8, Bundle_st200_ANYX_ODD_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_0_8, Bundle_st200_FIRST_EVEN_4_8 } },
+  { 1, { Bundle_st200_FIRST_MEM_0_4 } },
+  { 2, { Bundle_st200_FIRST_MEMX_0_8, Bundle_st200_FIRST_MEMX_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_0_8, Bundle_st200_FIRST_ODD_4_8 } },
+  { 2, { Bundle_st200_EVEN_EVEN_0_8, Bundle_st200_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_MEM_0_8, Bundle_st200_EVEN_MEM_4_8 } },
+  { 4, { Bundle_st200_MEMX_EVEN_0_16, Bundle_st200_EVEN_MEMX_4_16, Bundle_st200_EVEN_MEMX_8_16, Bundle_st200_MEMX_EVEN_12_16 } },
+  { 2, { Bundle_st200_EVEN_ODD_0_8, Bundle_st200_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_MEM_ODD_0_8, Bundle_st200_ODD_MEM_4_8 } },
+  { 2, { Bundle_st200_MEMX_ODD_0_8, Bundle_st200_MEMX_ODD_4_8 } },
+  { 2, { Bundle_st200_ODD_ODD_0_8, Bundle_st200_ODD_ODD_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_ANYX_ANY_ANY_0_8, Bundle_st200_ANYX_ANY_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_EVEN_ANY_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_4_8 } },
+  { 1, { Bundle_st200_MEM_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_MEMX_ANY_ANY_0_8, Bundle_st200_MEMX_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_0_8, Bundle_st200_ODD_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANYX_ANY_0_8, Bundle_st200_FIRST_ANYX_ANY_4_8 } },
+  { 2, { Bundle_st200_ANYX_EVEN_ANY_0_8, Bundle_st200_ANYX_ANY_EVEN_4_8 } },
+  { 2, { Bundle_st200_ANYX_ANY_MEM_0_8, Bundle_st200_ANYX_MEM_ANY_4_8 } },
+  { 2, { Bundle_st200_ANYX_ANY_ODD_0_8, Bundle_st200_ANYX_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANY_EVEN_0_8, Bundle_st200_FIRST_EVEN_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_MEM_ANY_0_4 } },
+  { 2, { Bundle_st200_FIRST_MEMX_ANY_0_8, Bundle_st200_FIRST_MEMX_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_ANY_0_8, Bundle_st200_FIRST_ANY_ODD_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_EVEN_0_8, Bundle_st200_ANY_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_MEM_0_8, Bundle_st200_ANY_EVEN_MEM_4_8 } },
+  { 4, { Bundle_st200_MEMX_EVEN_ANY_0_16, Bundle_st200_ANY_EVEN_MEMX_4_16, Bundle_st200_EVEN_MEMX_ANY_8_16, Bundle_st200_MEMX_ANY_EVEN_12_16 } },
+  { 2, { Bundle_st200_EVEN_ODD_ANY_0_8, Bundle_st200_ODD_EVEN_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_MEM_0_8, Bundle_st200_ODD_ANY_MEM_4_8 } },
+  { 2, { Bundle_st200_MEMX_ANY_ODD_0_8, Bundle_st200_MEMX_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ODD_0_8, Bundle_st200_ODD_ANY_ODD_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANYX_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANYX_MEM_0_8, Bundle_st200_FIRST_ANYX_MEM_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANYX_ODD_0_8 } },
+  { 4, { Bundle_st200_ANYX_EVEN_MEM_0_16, Bundle_st200_MEM_EVEN_ANYX_4_16, Bundle_st200_EVEN_ANYX_MEM_8_16, Bundle_st200_MEM_ANYX_EVEN_12_16 } },
+  { 2, { Bundle_st200_ANYX_EVEN_ODD_0_8, Bundle_st200_ANYX_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_ANYX_MEM_ODD_0_8, Bundle_st200_ANYX_ODD_MEM_4_8 } },
+  { 1, { Bundle_st200_FIRST_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_MEM_4_8, Bundle_st200_FIRST_MEM_EVEN_0_16 } },
+  { 2, { Bundle_st200_FIRST_EVEN_MEMX_4_16, Bundle_st200_FIRST_MEMX_EVEN_12_16 } },
+  { 2, { Bundle_st200_FIRST_ODD_EVEN_0_8, Bundle_st200_FIRST_EVEN_ODD_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_MEM_0_8, Bundle_st200_FIRST_MEM_ODD_4_8 } },
+  { 1, { Bundle_st200_FIRST_MEMX_ODD_0_8 } },
+  { 1, { Bundle_st200_FIRST_ODD_ODD_0_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_EVEN_0_8, Bundle_st200_ODD_EVEN_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_MEM_0_8, Bundle_st200_ODD_EVEN_MEM_4_8 } },
+  { 4, { Bundle_st200_MEMX_EVEN_ODD_0_16, Bundle_st200_ODD_EVEN_MEMX_4_16, Bundle_st200_EVEN_MEMX_ODD_8_16, Bundle_st200_MEMX_ODD_EVEN_12_16 } },
+  { 2, { Bundle_st200_EVEN_ODD_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_4_8 } },
+  { 2, { Bundle_st200_ODD_MEM_ODD_0_8, Bundle_st200_ODD_MEM_ODD_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_ANY_ANY_0_4 } },
+  { 1, { Bundle_st200_FIRST_ANY_ANY_ANY_0_4 } },
+  { 2, { Bundle_st200_EVEN_ANY_ANY_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_ANY_4_8 } },
+  { 1, { Bundle_st200_ANY_ANY_ANY_MEM_0_4 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_ANY_0_8, Bundle_st200_ODD_ANY_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ANY_EVEN_ANY_0_8, Bundle_st200_FIRST_EVEN_ANY_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ANY_ANY_MEM_0_4 } },
+  { 2, { Bundle_st200_FIRST_ODD_ANY_ANY_0_8, Bundle_st200_FIRST_ANY_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_EVEN_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ANY_MEM_ANY_0_8, Bundle_st200_ANY_EVEN_ANY_MEM_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_ANY_ANY_0_8, Bundle_st200_ODD_EVEN_ANY_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_MEM_0_8, Bundle_st200_ODD_ANY_MEM_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_ANY_ODD_0_8, Bundle_st200_ODD_ANY_ODD_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_EVEN_ANY_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_ANY_MEM_4_8, Bundle_st200_FIRST_MEM_EVEN_ANY_0_16 } },
+  { 2, { Bundle_st200_FIRST_ODD_EVEN_ANY_0_8, Bundle_st200_FIRST_EVEN_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_FIRST_ODD_ANY_MEM_0_8, Bundle_st200_FIRST_MEM_ODD_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_ODD_ANY_ODD_0_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_EVEN_ANY_0_8, Bundle_st200_ANY_EVEN_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_MEM_ANY_0_8, Bundle_st200_ODD_EVEN_ANY_MEM_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_EVEN_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_ANY_4_8 } },
+  { 2, { Bundle_st200_ANY_ODD_MEM_ODD_0_8, Bundle_st200_ODD_MEM_ODD_ANY_4_8 } },
+  { 1, { Bundle_st200_FIRST_EVEN_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_FIRST_EVEN_ODD_MEM_4_8, Bundle_st200_FIRST_MEM_EVEN_ODD_0_16 } },
+  { 1, { Bundle_st200_FIRST_ODD_EVEN_ODD_0_8 } },
+  { 1, { Bundle_st200_FIRST_ODD_MEM_ODD_0_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_EVEN_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_EVEN_4_8 } },
+  { 2, { Bundle_st200_EVEN_ODD_MEM_ODD_0_8, Bundle_st200_ODD_EVEN_ODD_MEM_4_8 } },
+};
+
+#define Resource_st200_ISSUE 0
+#define Resource_st200_MEM 1
+#define Resource_st200_CTL 2
+#define Resource_st200_ODD 3
+#define Resource_st200_EVEN 4
+#define Resource_st200_LANE0 5
+#define RESOURCE_MAX 6
+const int st200_resource_max = RESOURCE_MAX;
+
+const char *st200_resource_names[RESOURCE_MAX] = {
+  "ISSUE",
+  "MEM",
+  "CTL",
+  "ODD",
+  "EVEN",
+  "LANE0"
+};
+
+const int st231_resources[RESOURCE_MAX] = { 4,1,1,2,2,2};
+const int st240_resources[RESOURCE_MAX] = { 4,1,1,2,2,2};
+
+
+#define Reservation_st231_ALL 10
+#define Reservation_st231_ALU 11
+#define Reservation_st231_ALUX 12
+#define Reservation_st231_CTL 13
+#define Reservation_st231_ODD 14
+#define Reservation_st231_ODDX 15
+#define Reservation_st231_MEM 16
+#define Reservation_st231_MEMX 17
+#define Reservation_st231_PSW 18
+#define Reservation_st231_EVEN 19
+#define Reservation_st240_ALL 20
+#define Reservation_st240_ALU 21
+#define Reservation_st240_ALUX 22
+#define Reservation_st240_CTL 23
+#define Reservation_st240_ODD 24
+#define Reservation_st240_ODDX 25
+#define Reservation_st240_MEM 26
+#define Reservation_st240_MEMX 27
+#define Reservation_st240_PSW 28
+#define Reservation_st240_EVEN 29
+
+
+#define RESERVATION_TABLE_LINES 1
+const int st200_reservation_table_lines = RESERVATION_TABLE_LINES;
+
+
+static const int Reservation_st231_ALL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  4 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ALU_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ALUX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_CTL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_EVEN_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_MEM_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_MEMX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ODD_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_ODDX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st231_PSW_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ALL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  4 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ALU_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ALUX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_CTL_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_EVEN_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  1 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_MEM_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  0 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  1 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_MEMX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  2 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ODD_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  0 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_ODDX_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  2 /* cyc.0 Resource:st200:ISSUE */,
+  0 /* cyc.0 Resource:st200:MEM */,
+  0 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+static const int Reservation_st240_PSW_table[RESERVATION_TABLE_LINES * RESOURCE_MAX] = {
+  1 /* cyc.0 Resource:st200:ISSUE */,
+  1 /* cyc.0 Resource:st200:MEM */,
+  1 /* cyc.0 Resource:st200:CTL */,
+  1 /* cyc.0 Resource:st200:ODD */,
+  1 /* cyc.0 Resource:st200:EVEN */,
+  0 /* cyc.0 Resource:st200:LANE0 */
+};
+
+const int *st200_reservation_table_table[] = {
+
+  Reservation_st231_ALL_table,
+  Reservation_st231_ALU_table,
+  Reservation_st231_ALUX_table,
+  Reservation_st231_CTL_table,
+  Reservation_st231_ODD_table,
+  Reservation_st231_ODDX_table,
+  Reservation_st231_MEM_table,
+  Reservation_st231_MEMX_table,
+  Reservation_st231_PSW_table,
+  Reservation_st231_EVEN_table,
+  Reservation_st240_ALL_table,
+  Reservation_st240_ALU_table,
+  Reservation_st240_ALUX_table,
+  Reservation_st240_CTL_table,
+  Reservation_st240_ODD_table,
+  Reservation_st240_ODDX_table,
+  Reservation_st240_MEM_table,
+  Reservation_st240_MEMX_table,
+  Reservation_st240_PSW_table,
+  Reservation_st240_EVEN_table
+};
+
+
+lxopc_t st231_lxoptab[] = {
+	{"nop", 0x00000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {0}, "", ""},
+	{"mov", 0x00000000, 0x7ffc003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src2, 0}, "", "%s = %s"},
+	{"add", 0x00000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x00200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x00400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x00600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x00800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x00a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x00c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x00e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh4add", 0x01000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"and", 0x01200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x01400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"or", 0x01600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x01800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x01a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullhus", 0x01e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max", 0x02000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x02200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"min", 0x02400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x02600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhs", 0x02800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x02a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullu", 0x02c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x02e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhu", 0x03000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x03200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x03400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x03600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x03800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhh", 0x03a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x03c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhs", 0x03e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x04000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x04200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x04400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x04600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x04800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x04a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x04c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x04e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x05000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x05200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x05400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x05600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x05800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x05a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x05c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul64h", 0x05e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x06000000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x06200000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x06400000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x06600000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x06800000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x06a00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x06c00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x06e00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x07000000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x07200000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x07400000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x07600000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convib", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"mov", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"mtb", 0x07800000, 0x7fe3ffc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, 0}, "", "%s = %s"},
+	{"orl", 0x07800000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x07a00000, 0x7fe3f000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&bdest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x07c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x07e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x08000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"add", 0x08000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x08200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &isrc2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x08400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x08600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x08800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x08a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x08c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x08e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh4add", 0x09000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"zxtb", 0x092ff000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"and", 0x09200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x09400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"or", 0x09600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x09800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x09a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sxtb", 0x09c00000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxth", 0x09c01000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"bswap", 0x09c02000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"zxth", 0x09c03000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"clz", 0x09c04000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"mullhus", 0x09e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"max", 0x0a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x0a200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"min", 0x0a400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x0a600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhhs", 0x0a800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x0aa00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullu", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x0ae00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhu", 0x0b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x0b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x0b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x0b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x0b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhh", 0x0ba00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x0bc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulhs", 0x0be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0c000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0c200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0c400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0c600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0c800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ca00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0cc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ce00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x0d400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x0d600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x0d800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x0da00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x0dc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul64h", 0x0de00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0e000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0e200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0e400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0e600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0e800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ea00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0ec00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ee00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0f000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0f200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x0f400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x0f600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x0f800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x0fa00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x0fc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x0fe00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"slct", 0x10000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf", 0x11000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"addcg", 0x12000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"divs", 0x14000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"imml", 0x15000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&imm, 0}, "", "%s"},
+	{"immr", 0x15800000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&imm, 0}, "", "%s"},
+	{"slct", 0x18000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"convbi", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mov", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mfb", 0x19001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"slctf", 0x19000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"prgins", 0x1f800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st231_ALL, {0}, "", ""},
+	{"sbrk", 0x9fa00000, 0xffe00000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&sbrknum, 0}, "", "%s"},
+	{"syscall", 0x1fc00000, 0x7fe00000, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st231_ALL, {&sbrknum, 0}, "", "%s"},
+	{"break", 0x1fe00000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {0}, "", ""},
+	{"ldw", 0x20000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldw.d", 0x20800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldh", 0x21000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldh.d", 0x21800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhu", 0x22000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhu.d", 0x22800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldb", 0x23000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldb.d", 0x23800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbu", 0x24000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbu.d", 0x24800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"stw", 0x25000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"sth", 0x25800000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stb", 0x26000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"pft", 0x26800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgadd", 0x27000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset", 0x27800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"sync", 0x28000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {0}, "", ""},
+	{"prginspg", 0x28800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st231_MEMX << 8) | (int)Reservation_st231_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"syncins", 0x29000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {0}, "", ""},
+	{"pswset", 0x29000000, 0x7ffff03f, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {&src2, 0}, "", "%s"},
+	{"pswclr", 0x29800000, 0x7ffff03f, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {&src2, 0}, "", "%s"},
+	{"asm_31", 0x2be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_0", 0x2c000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_1", 0x2c200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_2", 0x2c400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_3", 0x2c600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_4", 0x2c800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_5", 0x2ca00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_6", 0x2cc00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_7", 0x2ce00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st231_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_8", 0x2d000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_9", 0x2d200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_10", 0x2d400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_11", 0x2d600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st231_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_12", 0x2d800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_13", 0x2da00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_14", 0x2dc00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_15", 0x2de00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st231_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_16", 0x2e000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_17", 0x2e200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_18", 0x2e400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_19", 0x2e600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_20", 0x2e800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_21", 0x2ea00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_22", 0x2ec00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_23", 0x2ee00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_24", 0x2f000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_25", 0x2f200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_26", 0x2f400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_27", 0x2f600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st231_ALUX << 8) | (int)Reservation_st231_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_28", 0x2f800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_29", 0x2fa00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_30", 0x2fc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st231_ODDX << 8) | (int)Reservation_st231_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"wmb", 0x2fe03000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {0}, "", ""},
+	{"ldwl", 0x2fe05000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {&idest, &src1, 0}, "", "%s = [%s]"},
+	{"stwl", 0x2ff00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st231_MEM, {&bdest2, &src1, &src2, 0}, "", "%s, [%s] = %s"},
+	{"call", 0x30000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, &btarg, 0}, "", "%s = %s"},
+	{"call", 0x30800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, &link, 0}, "", "%s = %s"},
+	{"idle", 0x31000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {0}, "", ""},
+	{"goto", 0x31000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&btarg, 0}, "", "%s"},
+	{"goto", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, 0}, "", "%s"},
+	{"return", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&link, 0}, "", "%s"},
+	{"rfi", 0x32000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_PSW, {0}, "", ""},
+	{"br", 0x38000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+	{"brf", 0x3c000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st231_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+/* Number of instructions : 218 */
+	{"", 0, 0, 0, 0, {0}, "", ""}};
+
+const Lx_Core_Info st231_core_info = { "st231", st231_lxoptab, st231_resources, ELF_LX_CORE_ST231, TRUE };
+
+lxopc_t st240_lxoptab[] = {
+	{"nop", 0x00000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {0}, "", ""},
+	{"mov", 0x00000000, 0x7ffc003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src2, 0}, "", "%s = %s"},
+	{"add", 0x00000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x00200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x00400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x00600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x00800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x00a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x00c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x00e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"and", 0x01200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x01400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"or", 0x01600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orc", 0x01800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x01a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul64h", 0x01e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max", 0x02000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"addf.n", 0x02080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"adds", 0x02100000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x02200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subf.n", 0x02280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subs", 0x02300000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"min", 0x02400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulf.n", 0x02480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1adds", 0x02500000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"minu", 0x02600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convif.n", 0x02680000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, 0}, "", "%s = %s"},
+	{"sh1subs", 0x02700000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x02800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convfi.n", 0x02880000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&nldest, &src1, 0}, "", "%s = %s"},
+	{"sats", 0x02900000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"mull", 0x02a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"adds.ph", 0x02b00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x02c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subs.ph", 0x02d00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mulh", 0x02e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"div", 0x03080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"addso", 0x03100000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x03200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"rem", 0x03280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"subso", 0x03300000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x03400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"divu", 0x03480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1addso", 0x03500000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mullh", 0x03600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"remu", 0x03680000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sh1subso", 0x03700000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"mullhu", 0x03800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"satso", 0x03900000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"mulhh", 0x03a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulhhu", 0x03c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x03e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x04000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq.pb", 0x04040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x04200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgef.n", 0x04400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplef.n", 0x04400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpgtu.pb", 0x04440000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeqf.n", 0x04600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtf.n", 0x04800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltf.n", 0x04800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x04c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x04c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x04e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x04e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x05000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x05000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpeq.ph", 0x05040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x05200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x05200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpgt.ph", 0x05240000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x05400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x05600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"orl", 0x05800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x05a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x06000000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x06008000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x06010000, 0x7fff8ff8, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, 0}, "", "%s = %s"},
+	{"cmpeq.pb", 0x06040000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x06200000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x06208000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu.pb", 0x06240000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgef.n", 0x06400000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmplef.n", 0x06400000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"orl", 0x06408000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeqf.n", 0x06600000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x06608000, 0x7fff8e38, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &bsrc1, &bsrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtf.n", 0x06800000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltf.n", 0x06800000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x06c00000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x06c00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x06e00000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x06e00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x07000000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x07000000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpeq.ph", 0x07040000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x07200000, 0x7fff8000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x07200000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"cmpgt.ph", 0x07240000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"andl", 0x07400000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"nandl", 0x07600000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"convib", 0x07800000, 0x7fff8fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, 0}, "", "%s = %s"},
+	{"mtb", 0x07800000, 0x7fff8fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, 0}, "", "%s = %s"},
+	{"orl", 0x07800000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"norl", 0x07a00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mov", 0x07c00000, 0x7fff8fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&bdest2, &src1, 0}, "", "%s = %s"},
+	{"mov", 0x08000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"add", 0x08000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sub", 0x08200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &isrc2, &src1, 0}, "", "%s = %s, %s"},
+	{"shl", 0x08400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr", 0x08600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shru", 0x08800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh1add", 0x08a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh2add", 0x08c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sh3add", 0x08e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"addpc", 0x09000000, 0x7fe0003f, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &isrc2, 0}, "", "%s = %s"},
+	{"zxtb", 0x092ff000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"and", 0x09200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"andc", 0x09400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"or", 0x09600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"xor", 0x09a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"clz", 0x09c04000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"mul64h", 0x09e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"max", 0x0a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"maxu", 0x0a200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"min", 0x0a400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"minu", 0x0a600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul64hu", 0x0a800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mul32", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mull", 0x0ac00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulll", 0x0b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulllu", 0x0b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"mulfrac", 0x0be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0c000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0c200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0c400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0c600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0c800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ca00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0cc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ce00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpeq", 0x0e000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpne", 0x0e200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpge", 0x0e400000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgeu", 0x0e600000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgt", 0x0e800000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpgtu", 0x0ea00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmple", 0x0ec00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpleu", 0x0ee00000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmplt", 0x0f000000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"cmpltu", 0x0f200000, 0x7fe00e00, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&ibdest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shls", 0x10000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shlso", 0x10200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sxt", 0x10a00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"zxt", 0x10c00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"rotl", 0x10e00000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"perm.pb", 0x12000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"unpacku.pbh", 0x12040000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"shuff.pbh", 0x12040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sadu.pb", 0x12080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"unpacku.pbl", 0x12240000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"shuff.pbl", 0x12240000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"absubu.pb", 0x12280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shuffodd.pb", 0x12440000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"muladdus.pb", 0x12480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shuffeve.pb", 0x12640000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"pack.pb", 0x12680000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"ext1.pb", 0x12840000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"ext2.pb", 0x12a40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"ext3.pb", 0x12c40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"packsu.pb", 0x12e40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shl.ph", 0x13000000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"add.ph", 0x13040000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shuff.phh", 0x13080000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shls.ph", 0x13200000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"abss.ph", 0x13240000, 0x7ffc0fc0, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, 0}, "", "%s = %s"},
+	{"shuff.phl", 0x13280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"pack.ph", 0x13280000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shr.ph", 0x13400000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"max.ph", 0x13440000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"sub.ph", 0x13480000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src2, &src1, 0}, "", "%s = %s, %s"},
+	{"shrrnp.ph", 0x13600000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"min.ph", 0x13640000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfracadds.ph", 0x13680000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"shrrne.ph", 0x13800000, 0x7ffc0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mul.ph", 0x13840000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"muladd.ph", 0x13a40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfracrm.ph", 0x13c40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"packrnp.phh", 0x13c80000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"mulfracrne.ph", 0x13e40000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&nldest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"packs.ph", 0x13e80000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"addcg", 0x14000000, 0x7f000000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &bdest, &src1, &src2, &scond, 0}, "", "%s, %s = %s, %s, %s"},
+	{"imml", 0x15000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&imm, 0}, "", "%s"},
+	{"immr", 0x15800000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&imm, 0}, "", "%s"},
+	{"slct.pb", 0x16000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf.pb", 0x16000000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src2, &src1, 0}, "", "%s = %s, %s, %s"},
+	{"slct", 0x16040000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf", 0x16040000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src2, &src1, 0}, "", "%s = %s, %s, %s"},
+	{"mov", 0x17040000, 0x7f1c0fff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, 0}, "", "%s = %s"},
+	{"extl.pb", 0x17080000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"extr.pb", 0x170c0000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"avgu.pb", 0x17100000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"avg4u.pb", 0x17140000, 0x7f1c0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&nldest, &scond, &src1, &src2, 0}, "", "%s = %s, %s, %s"},
+	{"shls", 0x18000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shlso", 0x18200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shrrnp", 0x18400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extract", 0x18600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extractu", 0x18800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"sxtb", 0x18a08000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxth", 0x18a10000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"sxt", 0x18a00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"zxth", 0x18c10000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"zxt", 0x18c00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"rotl", 0x18e00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extractl", 0x19600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"extractlu", 0x19800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"bswap", 0x1a01b000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &src1, 0}, "", "%s = %s"},
+	{"perm.pb", 0x1a000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shl.ph", 0x1b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shls.ph", 0x1b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shr.ph", 0x1b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shrrnp.ph", 0x1b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"shrrne.ph", 0x1b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"slct", 0x1c000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"convbi", 0x1d001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"mfb", 0x1d001000, 0x7f1ff03f, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&idest, &scond, 0}, "", "%s = %s"},
+	{"slctf", 0x1d000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"slct.pb", 0x1e000000, 0x7f1c0000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"slctf.pb", 0x1f000000, 0x7f000000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &scond, &src1, &isrc2, 0}, "", "%s = %s, %s, %s"},
+	{"pft", 0x20000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"pftc", 0x20000000, 0x7f000fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&pcond, &isrc2, &src1, 0}, "", "%s, %s[%s]"},
+	{"ldl", 0x20000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idestp, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldlc", 0x20000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idestp, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldw", 0x21000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldwc", 0x21000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&idest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldh", 0x22000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhc", 0x22000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldhu", 0x23000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldhuc", 0x23000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldb", 0x24000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbc", 0x24000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"ldbu", 0x25000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &isrc2, &src1, 0}, "", "%s = %s[%s]"},
+	{"ldbuc", 0x25000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &pcond, &isrc2, &src1, 0}, "", "%s = %s, %s[%s]"},
+	{"asm_0", 0x26000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_1", 0x26200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_2", 0x26400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_3", 0x26600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_4", 0x26800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_5", 0x26a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_6", 0x26c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_7", 0x26e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_8", 0x27000000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_9", 0x27200000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_10", 0x27400000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_11", 0x27600000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_EVEN, ((int)0 << 8) | (int)Reservation_st240_EVEN, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_12", 0x27800000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_13", 0x27a00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_14", 0x27c00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"asm_15", 0x27e00000, 0x7ffc0000, ((int)0 << 8) | (int)Bundling_st200_ODD, ((int)0 << 8) | (int)Reservation_st240_ODD, {&dest, &src1, &src2, 0}, "", "%s = %s, %s"},
+	{"stl", 0x28000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2p, 0}, "", "%s[%s] = %s"},
+	{"stlc", 0x28000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2p, 0}, "", "%s[%s] = %s, %s"},
+	{"stw", 0x29000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stwc", 0x29000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2, 0}, "", "%s[%s] = %s, %s"},
+	{"sth", 0x2a000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"sthc", 0x2a000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2, 0}, "", "%s[%s] = %s, %s"},
+	{"asm_16", 0x2b000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_17", 0x2b200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_18", 0x2b400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_19", 0x2b600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_20", 0x2b800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_21", 0x2ba00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_22", 0x2bc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_23", 0x2be00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"stb", 0x2c000000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &src2, 0}, "", "%s[%s] = %s"},
+	{"stbc", 0x2c000000, 0x7f000000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, &pcond, &src2, 0}, "", "%s[%s] = %s, %s"},
+	{"asm_24", 0x2d000000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_25", 0x2d200000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_26", 0x2d400000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_27", 0x2d600000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ANY, ((int)Reservation_st240_ALUX << 8) | (int)Reservation_st240_ALU, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_28", 0x2d800000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_29", 0x2da00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_30", 0x2dc00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"asm_31", 0x2de00000, 0x7fe00000, ((int)Bundling_st200_ANYX << 8) | (int)Bundling_st200_ODD, ((int)Reservation_st240_ODDX << 8) | (int)Reservation_st240_ODD, {&idest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"prgadd", 0x2f000000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgadd.l1", 0x2f000040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset", 0x2f200000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prgset.l1", 0x2f200040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsadd", 0x2f400000, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsadd.l1", 0x2f400040, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsset", 0x2f600000, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"prginsset.l1", 0x2f600040, 0x7fe00fc0, ((int)Bundling_st200_ALONEX << 8) | (int)Bundling_st200_ALONE, ((int)Reservation_st240_ALL << 8) | (int)Reservation_st240_ALL, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"flushadd", 0x2f800000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"flushadd.l1", 0x2f800040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"pswmask", 0x2fa00000, 0x7fe00000, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&nlidest, &src1, &isrc2, 0}, "", "%s = %s, %s"},
+	{"invadd", 0x2fc00000, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"invadd.l1", 0x2fc00040, 0x7fe00fc0, ((int)Bundling_st200_MEMX << 8) | (int)Bundling_st200_MEM, ((int)Reservation_st240_MEMX << 8) | (int)Reservation_st240_MEM, {&isrc2, &src1, 0}, "", "%s[%s]"},
+	{"syncins", 0x2fe00000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_PSW, {0}, "", ""},
+	{"sync", 0x2fe02000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"wmb", 0x2fe03000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"waitl", 0x2fe04000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"ldwl", 0x2fe05000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&idest, &src1, 0}, "", "%s = [%s]"},
+	{"dib", 0x2fe06000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {0}, "", ""},
+	{"dbgsbrk", 0xafe08000, 0xfffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&brknum, 0}, "", "%s"},
+	{"sbrk", 0xafe09000, 0xfffff000, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {&brknum, 0}, "", "%s"},
+	{"syscall", 0x2fe0a000, 0x7ffff000, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st240_ALL, {&brknum, 0}, "", "%s"},
+	{"break", 0x2fe0b000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_ANY, ((int)0 << 8) | (int)Reservation_st240_ALU, {0}, "", ""},
+	{"retention", 0xafe0c000, 0xffffffff, ((int)0 << 8) | (int)Bundling_st200_ALONE, ((int)0 << 8) | (int)Reservation_st240_ALL, {0}, "", ""},
+	{"stwl", 0x2ff00000, 0x7fff8000, ((int)0 << 8) | (int)Bundling_st200_MEM, ((int)0 << 8) | (int)Reservation_st240_MEM, {&bdest2, &src1, &src2, 0}, "", "%s, [%s] = %s"},
+	{"call", 0x30000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, &btarg, 0}, "", "%s = %s"},
+	{"call", 0x30800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, &link, 0}, "", "%s = %s"},
+	{"idle", 0x31000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {0}, "", ""},
+	{"goto", 0x31000000, 0x7f800000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&btarg, 0}, "", "%s"},
+	{"goto", 0x31800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, 0}, "", "%s"},
+	{"rfi", 0x32000000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_PSW, {0}, "", ""},
+	{"return", 0x33800000, 0x7fffffff, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&link, 0}, "", "%s"},
+	{"br", 0x38000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+	{"brf", 0x3c000000, 0x7c000000, ((int)0 << 8) | (int)Bundling_st200_FIRST, ((int)0 << 8) | (int)Reservation_st240_CTL, {&bcond, &btarg, 0}, "", "%s, %s"},
+/* Number of instructions : 319 */
+	{"", 0, 0, 0, 0, {0}, "", ""}};
+
+const Lx_Core_Info st240_core_info = { "st240", st240_lxoptab, st240_resources, ELF_LX_CORE_ST240, TRUE };
+
+const Lx_Core_Info *st200_core_info_table[] = 
+{
+  & st231_core_info,
+  & st240_core_info
+};
+
diff --git a/opcodes/sh-dis.c b/opcodes/sh-dis.c
index 57c1aa7..23e7497 100644
--- a/opcodes/sh-dis.c
+++ b/opcodes/sh-dis.c
@@ -1,6 +1,7 @@
 /* Disassemble SH instructions.
    Copyright 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
    2007  Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of the GNU opcodes library.
 
@@ -692,6 +693,15 @@ print_insn_sh (bfd_vma memaddr, struct disassemble_info *info)
 	    case A_R0:
 	      fprintf_fn (stream, "r0");
 	      break;
+	    case A_R1:
+	      fprintf_fn (stream, "r1");
+	      break;
+	    case A_R2:
+	      fprintf_fn (stream, "r2");
+	      break;
+	    case A_R3:
+	      fprintf_fn (stream, "r3");
+	      break;
 	    case A_REG_N:
 	      fprintf_fn (stream, "r%d", rn);
 	      break;
diff --git a/opcodes/sh-opc.h b/opcodes/sh-opc.h
index 62e290e..1bb550d 100644
--- a/opcodes/sh-opc.h
+++ b/opcodes/sh-opc.h
@@ -1,6 +1,7 @@
 /* Definitions for SH opcodes.
    Copyright 1993, 1994, 1995, 1997, 1999, 2000, 2001, 2002, 2003, 2004,
    2005, 2007 Free Software Foundation, Inc.
+   Copyright (c) 2006  STMicroelectronics.
 
    This file is part of the GNU opcodes library.
 
@@ -121,6 +122,12 @@ typedef enum
     A_MACL,
     A_PR,
     A_R0,
+ /* For use of the ST40-300 EXPERIMENTAL mulr instructions.
+    Not for submission to the netsources.  */
+    A_R1,
+    A_R2,
+    A_R3,
+ /* End of experimental.  */
     A_R0_GBR,
     A_REG_M,
     A_REG_N,
@@ -215,7 +222,10 @@ sh_dsp_reg_nums;
 #define arch_sh4_base	    (1 << 5)
 #define arch_sh4a_base	    (1 << 6)
 #define arch_sh2a_base      (1 << 7)
-#define arch_sh_base_mask   MASK (0, 7)
+#define arch_st40_300_base  (1 << 8)
+#define arch_sh4a_st40_300_base (1 << 9)
+#define arch_st40_300_sh2a_base (1 << 10)
+#define arch_sh_base_mask   MASK (0, 10)
 
 /* Bits 8 ... 24 are currently free.  */
 
@@ -255,6 +265,11 @@ sh_dsp_reg_nums;
 #define arch_sh2a_nofpu_or_sh3_nommu       (arch_sh2a_sh3_base|arch_sh_no_mmu |arch_sh_no_co)
 #define arch_sh2a_or_sh3e                  (arch_sh2a_sh4_base|arch_sh_no_mmu |arch_sh_sp_fpu)
 #define arch_sh2a_or_sh4                   (arch_sh2a_sh4_base|arch_sh_no_mmu |arch_sh_dp_fpu)
+#define arch_st40_300                      (arch_st40_300_base|arch_sh_has_mmu|arch_sh_dp_fpu)
+#define arch_st40_300_or_sh4a              (arch_sh4a_st40_300_base|arch_sh_has_mmu|arch_sh_dp_fpu)
+#define arch_st40_300_nofpu                (arch_st40_300_base|arch_sh_has_mmu|arch_sh_no_co)
+#define arch_st40_300_nofpu_or_sh4a_nofpu  (arch_sh4a_st40_300_base|arch_sh_has_mmu|arch_sh_no_co)
+#define arch_st40_300_nofpu_or_sh2a_nofpu  (arch_st40_300_sh2a_base|arch_sh_no_mmu |arch_sh_no_co)
 
 #define SH_MERGE_ARCH_SET(SET1, SET2) ((SET1) & (SET2))
 #define SH_VALID_BASE_ARCH_SET(SET) (((SET) & arch_sh_base_mask) != 0)
@@ -296,22 +311,32 @@ SH-DSP          SH3-nommu/SH2A-nofpu               SH2E
  |               |          |`--------------------. |
  |               |          |                      \|
  |              SH3-nommu  SH4-nm-nf/SH2A-nofpu    SH3E/SH2A
- |               |\         |          |      \     |    |
- |               | `------. |     SH2A-nofpu   `----+---.|
- |               |         \|            \          |   SH4/SH2A
- |              SH3     SH4-nommu-nofpu   `---------+--. |   |
- |              /|\         |                       |   \|   |
- | .-----------' | `--------+---------------------. |  SH2A  |
- |/              |          /                      \|        |
- |               | .-------'                        |        |
- |               |/                                 |        |
-SH3-dsp         SH4-nofpu                          SH3E      |
- |               |`-------------------------------. | .-----'
- |               |                                 \|/
- |              SH4A-nofpu                         SH4
- | .------------' `-------------------------------. |
- |/                                                \|
-SH4AL-dsp                                          SH4A
+ |               |\         |          |    `-----. |    |
+ |               | \        | ST40-300-nf/SH2A-nf | |    |
+ |               |  \       |     |       |       `-+--. |
+ |               |   `----. |     |      SH2A-nofpu |   \|
+ |               |         \|     `----.   \        |   SH4/SH2A
+ |              SH3  SH4-nommu-nofpu    \   `-------+--. |   |
+ |              /|\         |            \          |   \|   |
+ | .-----------' | `--------+-------------+-------. |  SH2A  |
+ |/              |          |             |        \|        |
+ |               | .--------'             |         |        |
+ |               |/                       |         |        |
+SH3-dsp         SH4-nofpu                 |        SH3E      |
+ |               |`-----------------------+-------. | .------'
+ |               |                        |        \|/
+ |               |                        |        SH4
+ |              SH4A-nofpu/ST40-300-nofpu |         | 
+ |               |`.        | .-----------'         |
+ |               | |        |/                      |
+ |               | |       ST40-300-nofpu           |
+ |               | |        `-----------------------+------------.
+ |               | `------------------------------. |            |
+ |               |                                 \|            |
+ |              SH4A-nofpu                         SH4A/ST40-300 |
+ | .------------' `-------------------------------. |    | .-----'
+ |/                                                \|    |/
+SH4AL-dsp                                          SH4A ST40-300
 */
 
 /* Central branches.  */
@@ -326,9 +351,12 @@ SH4AL-dsp                                          SH4A
 		| arch_sh2a_or_sh3e_up \
 		| arch_sh3_nommu_up)
 #define arch_sh2a_nofpu_or_sh4_nommu_nofpu_up  (arch_sh2a_nofpu_or_sh4_nommu_nofpu \
-		| arch_sh2a_nofpu_up \
+		| arch_st40_300_nofpu_or_sh2a_nofpu_up \
 		| arch_sh2a_or_sh4_up \
 		| arch_sh4_nommu_nofpu_up)
+#define arch_st40_300_nofpu_or_sh2a_nofpu_up   (arch_st40_300_nofpu_or_sh2a_nofpu \
+		| arch_sh2a_nofpu_up \
+		| arch_st40_300_nofpu_up)
 #define arch_sh2a_nofpu_up                     (arch_sh2a_nofpu \
 		| arch_sh2a_up)
 #define arch_sh3_nommu_up                      (arch_sh3_nommu \
@@ -342,7 +370,13 @@ SH4AL-dsp                                          SH4A
 		| arch_sh4_nofpu_up)
 #define arch_sh4_nofpu_up                      (arch_sh4_nofpu \
 		| arch_sh4_up \
+		| arch_st40_300_nofpu_or_sh4a_nofpu_up)
+#define arch_st40_300_nofpu_or_sh4a_nofpu_up   (arch_st40_300_nofpu_or_sh4a_nofpu \
+		| arch_st40_300_nofpu_up \
+		| arch_st40_300_or_sh4a_up \
 		| arch_sh4a_nofpu_up)
+#define arch_st40_300_nofpu_up                 (arch_st40_300_nofpu \
+		| arch_st40_300_up)
 #define arch_sh4a_nofpu_up                     (arch_sh4a_nofpu \
 		| arch_sh4a_up \
 		| arch_sh4al_dsp_up)
@@ -360,8 +394,12 @@ SH4AL-dsp                                          SH4A
 #define arch_sh3e_up                           (arch_sh3e \
 		| arch_sh4_up)
 #define arch_sh4_up                            (arch_sh4 \
-		| arch_sh4a_up)
+		| arch_st40_300_or_sh4a_up)
+#define arch_st40_300_or_sh4a_up               (arch_st40_300_or_sh4a \
+		| arch_sh4a_up \
+		| arch_st40_300_up)
 #define arch_sh4a_up                           (arch_sh4a)
+#define arch_st40_300_up                       (arch_st40_300)
 
 /* Left branch.  */
 #define arch_sh_dsp_up                         (arch_sh_dsp  \
@@ -452,7 +490,7 @@ const sh_opcode_info sh_table[] =
 
 /* 0110nnnnmmmm1101 extu.w <REG_M>,<REG_N>*/{"extu.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_D}, arch_sh_up},
 
-/* 0000nnnn11100011 icbi @<REG_N>       */{"icbi",{A_IND_N},{HEX_0,REG_N,HEX_E,HEX_3}, arch_sh4a_nofpu_up},
+/* 0000nnnn11100011 icbi @<REG_N>       */{"icbi",{A_IND_N},{HEX_0,REG_N,HEX_E,HEX_3}, arch_st40_300_nofpu_or_sh4a_nofpu_up},
 
 /* 0100nnnn00101011 jmp @<REG_N>        */{"jmp",{A_IND_N},{HEX_4,REG_N,HEX_2,HEX_B}, arch_sh_up},
 
@@ -840,7 +878,7 @@ const sh_opcode_info sh_table[] =
 
 /* 0110nnnnmmmm1001 swap.w <REG_M>,<REG_N>*/{"swap.w",{ A_REG_M,A_REG_N},{HEX_6,REG_N,REG_M,HEX_9}, arch_sh_up},
 
-/* 0000000010101011 synco               */{"synco",{0},{HEX_0,HEX_0,HEX_A,HEX_B}, arch_sh4a_nofpu_up},
+/* 0000000010101011 synco               */{"synco",{0},{HEX_0,HEX_0,HEX_A,HEX_B}, arch_st40_300_nofpu_or_sh4a_nofpu_up},
 
 /* 0100nnnn00011011 tas.b @<REG_N>      */{"tas.b",{A_IND_N},{HEX_4,REG_N,HEX_1,HEX_B}, arch_sh_up},
 
@@ -1118,7 +1156,7 @@ const sh_opcode_info sh_table[] =
 /* 1111nnnn01001101 fneg <F_REG_N>     */{"fneg",{F_REG_N},{HEX_F,REG_N,HEX_4,HEX_D}, arch_sh2e_up},
 /* 1111nnn001001101 fneg <D_REG_N>     */{"fneg",{D_REG_N},{HEX_F,REG_N,HEX_4,HEX_D}, arch_sh2a_or_sh4_up},
 
-/* 1111011111111101 fpchg               */{"fpchg",{0},{HEX_F,HEX_7,HEX_F,HEX_D}, arch_sh4a_up},
+/* 1111011111111101 fpchg               */{"fpchg",{0},{HEX_F,HEX_7,HEX_F,HEX_D}, arch_st40_300_or_sh4a_up},
 
 /* 1111101111111101 frchg               */{"frchg",{0},{HEX_F,HEX_B,HEX_F,HEX_D}, arch_sh4_up},
 
@@ -1167,7 +1205,14 @@ const sh_opcode_info sh_table[] =
   /* 0100mmmm11110000 movml.l <REG_M>,@-R15 */ {"movmu.l",{A_REG_M,A_DEC_R15},{HEX_4,REG_M,HEX_F,HEX_0}, arch_sh2a_nofpu_up},
   /* 0100mmmm11110100 movml.l @R15+,<REG_M> */ {"movmu.l",{A_INC_R15,A_REG_M},{HEX_4,REG_M,HEX_F,HEX_4}, arch_sh2a_nofpu_up},
   /* 0000nnnn00111001 movrt <REG_N> */         {"movrt",{A_REG_N},{HEX_0,REG_N,HEX_3,HEX_9}, arch_sh2a_nofpu_up},
-  /* 0100nnnn10000000 mulr R0,<REG_N> */       {"mulr",{A_R0,A_REG_N},{HEX_4,REG_N,HEX_8,HEX_0}, arch_sh2a_nofpu_up},
+  /* 0100nnnn10000000 mulr R0,<REG_N> */       {"mulr",{A_R0,A_REG_N},{HEX_4,REG_N,HEX_8,HEX_0}, arch_st40_300_nofpu_or_sh2a_nofpu_up},
+
+/* Experimental ST40-300 instructions. Not for submission to the netsources.  */
+  /* 0100nnnn10010000 mulr R1,<REG_N> */       {"mulr",{A_R1,A_REG_N},{HEX_4,REG_N,HEX_9,HEX_0}, arch_st40_300_nofpu_up},
+  /* 0100nnnn10100000 mulr R2,<REG_N> */       {"mulr",{A_R2,A_REG_N},{HEX_4,REG_N,HEX_A,HEX_0}, arch_st40_300_nofpu_up},
+  /* 0100nnnn10110000 mulr R3,<REG_N> */       {"mulr",{A_R3,A_REG_N},{HEX_4,REG_N,HEX_B,HEX_0}, arch_st40_300_nofpu_up},
+/* End of experimental.  */
+
   /* 0000000001101000 nott */                  {"nott",{A_END},{HEX_0,HEX_0,HEX_6,HEX_8}, arch_sh2a_nofpu_up},
   /* 0000000001011011 resbank */               {"resbank",{A_END},{HEX_0,HEX_0,HEX_5,HEX_B}, arch_sh2a_nofpu_up},
   /* 0000000001101011 rts/n */                 {"rts/n",{A_END},{HEX_0,HEX_0,HEX_6,HEX_B}, arch_sh2a_nofpu_up},
