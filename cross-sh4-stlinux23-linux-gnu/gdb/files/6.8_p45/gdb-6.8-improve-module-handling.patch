Index: gdb-6.8-sh/gdb/linux-awareness.c
===================================================================
--- gdb-6.8-sh.orig/gdb/linux-awareness.c
+++ gdb-6.8-sh/gdb/linux-awareness.c
@@ -322,7 +322,7 @@ struct lm_info {
     unsigned int shnum;
     struct {
 	unsigned int nameidx;
-	char name[32];
+	char *name;
 	CORE_ADDR addr;
     } * sections;
 
@@ -393,7 +393,6 @@ struct waited_exe *waited_exes;
 static const char *fallback_tmpdirs[] = { "/tmp", "/var/tmp", "." };
 static const char *tmpdir = NULL;
 
-static unsigned int resetting_bps_after_init;
 static enum kernel_autodetection autodetection = NOT_LINUX;
 
 static void (*deprecated_call_command_chain) (struct cmd_list_element *c,
@@ -683,6 +682,7 @@ get_module_section_layout (struct lm_inf
 	if (info->sections[i].addr == 0)
 	    continue;
 
+	info->sections[i].name = xmalloc(32);
 	read_memory (strtab + info->sections[i].nameidx,
 		     info->sections[i].name, 32);
     }
@@ -733,6 +733,7 @@ layout_sections (bfd* file, struct lm_in
 
     unsigned long core_size = 0;
     unsigned long init_size = 0;
+    unsigned long base = lm_info->module_init;
     unsigned int sec_count = file->section_count;
     asection *bfd_sec;
     Elf_Internal_Shdr **sechdrs = elf_elfsections (file);
@@ -774,6 +775,9 @@ layout_sections (bfd* file, struct lm_in
 
     lm_info->computed_core_size = core_size;
 
+    if (base == 0)
+	base = lm_info->module_core + core_size;
+
     DEBUG (MODULE, 4, "Init section allocation\n");
     for (m = 0; m < ARRAY_SIZE(masks); ++m) {
 	for (i = 0; i < hdr->e_shnum; ++i) {
@@ -785,11 +789,13 @@ layout_sections (bfd* file, struct lm_in
 		|| offsets[i] != ~0UL
 		|| strncmp(name, ".init", 5) != 0)
 		continue;
-	    offsets[i] = get_offset(&init_size, s) + lm_info->module_init;
+	    offsets[i] = get_offset(&init_size, s) + base;
 	}
     }
 
     lm_info->computed_init_size = init_size;
+    if (init_size && !lm_info->module_init)
+	lm_info->module_init = base;
 
     if (lm_info->computed_core_size != lm_info->core_size) {
 	CORE_ADDR current_pc = read_pc ();
@@ -825,7 +831,7 @@ module load time to handle such cacses."
 	    char *name = bfd_elf_string_from_elf_section (file, ix, s->sh_name);
 	    if (offsets[i] != ~0UL) {
 		lm_info->sections[i].addr = offsets[i];
-		strncpy(lm_info->sections[i].name, name, 32);
+		lm_info->sections[i].name = savestring(name, strlen(name));
 	    }
 	}
     }
@@ -1286,23 +1292,20 @@ static void
 make_shlib_bps_pending ()
 {
     struct breakpoint *bp;
+    int warned = 0;
 
     ALL_BREAKPOINTS (bp)
-	if (bp->loc == NULL || bp->loc->shlib_disabled ) {
-	    bp->enable_state = bp_enabled;
-	} else if (bp->loc->address == ~(CORE_ADDR)0) {
-	    /* Here we totally disable the breakpoint. This is
-	       necessary for breakpoints in init sections: as long as
-	       the corresponding module stays loaded, the debug info
-	       is still present (mangled to ~(CORE_ADDR)0, but still
-	       present). With the debug info present, each module load
-	       will cause the pending breakpoint to be resolved and
-	       will print misleading messages.
-
-	       The breakpoints get re-enabled when their
-	       corresponding module is loaded again. See _wait()
-	       function. */
-	    bp->enable_state = bp_disabled;
+	if (bp->loc
+	    && bp->loc->address == ~(CORE_ADDR)0
+	    && !bp->loc->shlib_disabled) {
+
+	    bp->loc->shlib_disabled = 1;
+	    if (!warned) {
+		warning("\
+Disabling breakpoints that are in .init section (they will be re-set\n \
+if you reload that module)");
+		warned = 1;
+	    }
 	}
 }
 
@@ -1445,7 +1448,8 @@ get_module_section_addr (struct lm_info 
     unsigned int i;
 
     for (i = 0; i < info->shnum; ++i) {
-	if (strcmp (name, info->sections[i].name) == 0)
+	if (info->sections[i].name != NULL
+	    && strcmp (name, info->sections[i].name) == 0)
 	    return info->sections[i].addr;
     }
 
@@ -1461,9 +1465,6 @@ set_section_offsets (bfd *abfd, asection
     addr = get_module_section_addr (info, bfd_get_section_name (abfd, sectp));
 
     if (addr != 0) {
-	DEBUG (MODULE, 2, "Setting vma of %s to %s\n",
-	       bfd_get_section_name (abfd, sectp), paddr(addr));
-
 	/*  We want the file we create to be totally relocated with a
 	    base address of 0. Find the lowest section which will be
 	    one of init or core and substract it here. This way the
@@ -1472,9 +1473,13 @@ set_section_offsets (bfd *abfd, asection
 	    this base address. */
 	base = info->module_core;
 
-	if (info->module_init < base)
+	if (info->module_init && info->module_init < base)
 	    base = info->module_init;
 	bfd_set_section_vma (abfd, sectp, addr - base);
+
+	DEBUG (MODULE, 2, "Setting vma of %s to %s (%s)\n",
+	       bfd_get_section_name (abfd, sectp),
+	       paddr(addr), paddr(addr-base));
     }
 }
 
@@ -1492,8 +1497,9 @@ create_sections (bfd *abfd, asection *se
     if (strcmp (bfd_get_section_name (abfd, sectp), ".modinfo") == 0)
 	return;
 
-    DEBUG (MODULE, 3, "Adding section %s to new file.\n",
-	   bfd_get_section_name (abfd, sectp));
+    DEBUG (MODULE, 3, "Adding section %s to new file at %s.\n",
+	   bfd_get_section_name (abfd, sectp),
+	   paddr(bfd_get_section_vma(abfd, sectp)));
     sec = bfd_make_section (info->new, bfd_get_section_name (abfd, sectp));
     /* We'll get rid of relocations. */
     bfd_set_section_flags (info->new, sec, flags & ~SEC_RELOC);
@@ -1709,7 +1715,7 @@ make_temporary_bfd (bfd *abfd, struct lm
 	m->next = NULL;
 	m->p_type = PT_LOAD;
 	for (i = 0, j = 0, hdrpp = info.new->sections; i < bfd_count_sections(info.new); i++, hdrpp = hdrpp->next)
-	    if (bfd_get_section_flags(info.new, hdrpp) & SEC_LOAD)
+	    if (bfd_get_section_flags(info.new, hdrpp) & SEC_ALLOC)
 		m->sections[j++] = hdrpp;
 	m->count = j;
 
@@ -2083,7 +2089,7 @@ debugging session. Please move that file
 	/* Just do as if our handcrafted file was a real shared
 	   library. */
 	CORE_ADDR base = so->lm_info->module_core;
-	if (base > so->lm_info->module_init)
+	if (so->lm_info->module_init && base > so->lm_info->module_init)
 	    base = so->lm_info->module_init;
 
 	sec->endaddr += base;
@@ -2114,9 +2120,14 @@ debugging session. Please move that file
 static void
 linux_aware_free_lm_info (struct lm_info *info)
 {
+    int i;
+
+    for (i = 0; i < info->shnum; ++i)
+	xfree(info->sections[i].name);
     xfree (info->sections);
+
     if (info->relocated_file != NULL)
-	unlink (info->relocated_file);
+    	unlink (info->relocated_file);
     /* No need to free info->relocated_file, the BFD structure will point to
        it, and it'll be freed by the solib framework. */
     xfree (info->real_file);
@@ -2125,6 +2136,9 @@ linux_aware_free_lm_info (struct lm_info
 	info->mod->lm_info = NULL;
 
     xfree (info);
+
+    if (last_loaded == info)
+	last_loaded = NULL;
 }
 
 static void
@@ -2244,6 +2258,7 @@ linux_aware_special_symbol_handling (voi
 
 		if (info->computed_init_size
 		    && !info->init_size) {
+		    struct partial_symtab *psymtab;
 
 		    /* This combination means that we've loaded the
 		       debug information after the init step of the
@@ -2253,9 +2268,16 @@ linux_aware_special_symbol_handling (voi
 
 		    DEBUG (MODULE, 2, "Relocating symbols for %s\n",
 			   info->module_name);
+		    for (psymtab = info->mod->objfile->psymtabs;
+			 psymtab != NULL;
+			 psymtab = psymtab->next)
+			{
+			    psymtab_to_symtab (psymtab);
+			}
 		    linux_aware_objfile_relocate (info->mod->objfile,
-						  0,
-						  info->computed_init_size,
+						  info->module_init,
+						  info->module_init
+						  + info->computed_init_size,
 						  info->module_core,
 						  info->module_core
 						  + info->core_size);
@@ -2542,10 +2564,7 @@ linux_aware_objfile_relocate (struct obj
   }
 
   /* Relocate breakpoints as necessary, after things are relocated. */
-  resetting_bps_after_init = 1;
   breakpoint_re_set ();
-  resetting_bps_after_init = 0;
-  seen_module_unload = 1;
 }
 
 /* This comment holds for all the solib code in here: _Things should be
@@ -2593,19 +2612,6 @@ linux_aware_current_sos (void)
 	    add_module_from_struct_module (ptr, &lm_infos);
 	    last_loaded = lm_infos->info;
 
-	    /* We just loaded a module. Enable all the breakpoints
-	       that were located in this module and that got disabled
-	       when it was first unloaded. We abuse the dll_pathname
-	       field to remember what module a breakpoint corresponds
-	       to. This gets set in _breakpoint_create_hook(). */
-	    ALL_BREAKPOINTS (bp)
-		if(bp->enable_state == bp_disabled
-		   && bp->loc->address == ~(CORE_ADDR)0
-		   && bp->dll_pathname
-		   && !strcmp(bp->dll_pathname, last_loaded->module_name)) {
-		    bp->enable_state = bp_enabled;
-		}
-
 	    if (lm_infos
 		&& lm_infos->info->this_module == ptr
 		&& lm_infos->info->module_init
@@ -2652,6 +2658,8 @@ linux_aware_current_sos (void)
 					  info->module_init+info->init_size,
 					  info->module_core,
 					  info->module_core+info->core_size);
+
+	    seen_module_unload = 1;
 	}
 	last_loaded = NULL;
 	return so_list_from_lm_infos ();
@@ -5388,35 +5396,16 @@ linux_aware_create_breakpoint_hook (stru
 {
     struct lm_info *info;
 
-    /* When this hook is called from breakpoint_re_set_one, the
-       enable_state will be reset by the aforementioned
-       function. There's no point in chnaging it. */
-
     if (bpt->loc
 	&& bpt->loc->address == ~(CORE_ADDR)0) {
-	if (! resetting_bps_after_init) {
-	    warning("\
-You've inserted a breakpoint on a location that isn't currently\n\
-mapped to memory (it's flagged as __init code and the initialization\n\
-phase of its module is over). The breakpoint will be re-set if you\n\
+	warning("\
+You've inserted a breakpoint on a location that isn't currently\n \
+mapped to memory (it's flagged as __init code and the initialization\n \
+phase of its module is over). The breakpoint will be re-set if you\n \
 reload that module:");
-	} else if (resetting_bps_after_init == 1) {
-	    warning("\
-Disabling breakpoints that are in .init section (they will be re-set if\n\
-you reload that module):");
-	    resetting_bps_after_init = 2;
-	    /* Don't mark the breakpoint as pending here, or it will
-	       get resolved immediately and generate wrong mesages. */
-
-	    /* Store the corresponding module name so that the
-	       breakpoint can get re-enabled at the right time. See
-	       _wait() and make_shlib_bps_pending(). */
-	    if (last_loaded != NULL) {
-		bpt->dll_pathname = xstrdup(last_loaded->module_name);
-	    }
-	}
 	/* Display correct breakpoint info */
 	bpt->ops = &init_breakpoints_ops;
+	bpt->loc->shlib_disabled = 1;
     } else if (bpt->loc
 	       && bpt->loc->address
 	       && bpt->loc->loc_type == bp_loc_software_breakpoint
