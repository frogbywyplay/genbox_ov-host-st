2008-03-11  Christian Bruel  <christian.bruel@st.com>

    INSbl/28482
    * struct-equiv.c (insns_match_p): Test registers in same regclass.

See DDTS INSbl28482

Index: gcc-4.2.1/gcc/struct-equiv.c
===================================================================
--- gcc-4.2.1.orig/gcc/struct-equiv.c
+++ gcc-4.2.1/gcc/struct-equiv.c
@@ -1,12 +1,13 @@
 /* Control flow optimization code for GNU compiler.
    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
+   Free Software Foundation, Inc.
 
 This file is part of GCC.
 
 GCC is free software; you can redistribute it and/or modify it under
 the terms of the GNU General Public License as published by the Free
-Software Foundation; either version 2, or (at your option) any later
+Software Foundation; either version 3, or (at your option) any later
 version.
 
 GCC is distributed in the hope that it will be useful, but WITHOUT ANY
@@ -15,9 +16,8 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING.  If not, write to the Free
-Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301, USA.  */
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
 
 /* Try to match two basic blocks - or their ends - for structural equivalence.
    We scan the blocks from their ends backwards, and expect that insns are
@@ -916,12 +916,30 @@ insns_match_p (rtx i1, rtx i2, struct eq
     }
   else if (INSN_P (i1))
     {
+      rtx s1 = single_set (i1);
+      rtx s2 = single_set (i2);
+
       if (! set_dest_equiv_p (PATTERN (i1), PATTERN (i2), info))
 	{
 	  cancel_changes (0);
 	  return false;
 	}
+
+      if (reload_completed && s1 && s2)
+	{
+	  s1 = SET_SRC (s1);
+	  s2 = SET_SRC (s2);
+
+	  if (REG_P (s1) && REG_P (s2)) {
+	    unsigned x_regno = REGNO (s1);
+	    unsigned y_regno = REGNO (s2);
+
+	    if (REGNO_REG_CLASS (x_regno) != REGNO_REG_CLASS(y_regno))
+	      return false;
+	  }
+	}
     }
+
   rvalue_change_start = num_validated_changes ();
   struct_equiv_make_checkpoint (&before_rvalue_change, info);
   /* Check death_notes_match_p *after* the inputs have been processed,
