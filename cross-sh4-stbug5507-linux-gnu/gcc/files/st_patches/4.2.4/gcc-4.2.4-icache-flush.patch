Index: gcc/gcc/config/sh/lib1funcs.asm
===================================================================
--- gcc.orig/gcc/config/sh/lib1funcs.asm	2009-01-29 11:11:05.000000000 +0000
+++ gcc/gcc/config/sh/lib1funcs.asm	2009-02-06 16:56:26.000000000 +0000
@@ -2069,18 +2069,51 @@
 	ENDFUNC(GLOBAL(ic_invalidate))
 #elif defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__) || (defined(__SH4_NOFPU__) && !defined(__SH5__))
 	/* For system code, we use ic_invalidate_line_i, but user code
-	   needs a different mechanism.  A kernel call is generally not
-	   available, and it would also be slow.  Different SH4 variants use
-	   different sizes and associativities of the Icache.  We use a small
-	   bit of dispatch code that can be put hidden in every shared object,
-	   which calls the actual processor-specific invalidation code in a
-	   separate module.
-	   Or if you have operating system support, the OS could mmap the
-	   procesor-specific code from a single page, since it is highly
-	   repetitive.  */
+	 * needs a different mechanism.  There are a number of ways of doing
+	 * this:
+	 *	1.  A kernel syscall (generally not available, slow but supports multiple arch variants)
+	 *	2.  A kernel vsyscall (optimum solution, supports multiple arch variants)
+	 *	3.  A jump table (supports 1 arch variant)
+	 * For 3, different SH4 variants use different sizes and associativities
+	 * of the Icache.  We use a small bit of dispatch code that can be put
+	 * hidden in every shared object, which calls the actual processor-specific
+	 * invalidation code in a separate module.
+	 */
+
 	.global GLOBAL(ic_invalidate)
 	HIDDEN_FUNC(GLOBAL(ic_invalidate))
 GLOBAL(ic_invalidate):
+
+/* By default we will now use the syscall as it supports multiple */
+/* i-cache architectures and let the kernel hide the differences  */
+#if !defined(ICACHE_VSYSCALL) || !defined(ICACHE_TABLE)
+#define ICACHE_SYSCALL
+#endif
+
+#if defined (ICACHE_SYSCALL)
+#warning Using ICACHE_SYSCALL method
+#undef L_ic_invalidate_array
+#include <asm/unistd.h>
+#include <asm/cachectl.h>
+	mov.l	1f, r6
+	mov.l	2f, r3
+	mov	#32, r5 /* cacheline size in bytes */
+	trapa	#0x13
+	rts
+	 nop
+	.balign 4
+1:	.long (CACHEFLUSH_D_WB | CACHEFLUSH_I)
+2:	.long __NR_cacheflush
+
+#elif defined (ICACHE_VSYSCALL)
+#error Not implemented yet!
+
+#else
+	/*
+	 * Jump table method
+	 */
+#warning Using ICACHE_TABLE method
+
 	mov.l	0f,r1
 #ifdef __pic__
 	mova	0f,r0
@@ -2102,8 +2135,9 @@
 	/* ??? Why won't the assembler allow to add these two constants?  */
 0:	.long   _GLOBAL_OFFSET_TABLE_
 1:	.long   GLOBAL(ic_invalidate_array)@GOT
-	ENDFUNC(GLOBAL(ic_invalidate))
 #endif /* __pic__ */
+#endif /* ICACHE_SYSCALL */
+	ENDFUNC(GLOBAL(ic_invalidate))
 #endif /* SH4 */
 #endif /* L_ic_invalidate */
 
@@ -2130,6 +2164,7 @@
 #define WAY_SIZE 0x4000
 #endif
 #if WAYS == 1
+#warning WAYS == 1
 	.rept	WAY_SIZE * WAYS / 32
 	rts
 	nop
@@ -2138,6 +2173,7 @@
 	.endr
 	.endr
 #elif WAYS <= 6
+#warning 6 >= WAYS > 1
 	.rept	WAY_SIZE * WAYS / 32
 	braf	r0
 	add	#-8,r0
