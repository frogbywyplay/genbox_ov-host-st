Patch from Frédéric Riss <frederic.riss@st.com> 

This patch makes gdb shared set breakpoints on thread creation and deletion
and shared library events, which allows gdb to reuse the thread and shared 
library lists if they haven't changed.

This patch goes a long way to addressing the issue of stepping speed
when gdb is being driven by Eclipse.

Signed-off-by: Chris Smith <chris.smith@st.com>
Index: gdb-6.5/gdb/linux-awareness.c
===================================================================
--- gdb-6.5.orig/gdb/linux-awareness.c	2007-10-08 15:39:22.000000000 +0100
+++ gdb-6.5/gdb/linux-awareness.c	2007-10-08 15:40:30.000000000 +0100
@@ -188,7 +188,8 @@
     VM_COMMITTED_SPACE,
     SYSCTL_OVERCOMMIT_RATIO,
     VMLIST,
-    NR_HUGE_PAGES
+    NR_HUGE_PAGES,
+    LAST_PID
 };
 
 struct addr_info linux_addrs[] = {
@@ -227,6 +228,7 @@
     [SYSCTL_OVERCOMMIT_RATIO]  = { "sysctl_overcommit_ratio" },
     [VMLIST]                   = { "vmlist" },
     [NR_HUGE_PAGES]            = { "nr_huge_pages" },
+    [LAST_PID]                 = { "last_pid" },
     {0}
 };
 
@@ -501,6 +503,9 @@
 
 static CORE_ADDR last_warned;
 
+static int last_pid;
+static int thread_list_needs_clearing;
+
 struct process {
     struct process *next;
     CORE_ADDR       task_struct_address;
@@ -526,6 +531,7 @@
     struct command_line *cmds;
 };
 
+static int has_userspace_breakpoint;
 struct debugged_user_process *user_processes;
 struct debugged_user_process *current_user_process;
 struct process *current_process;
@@ -1810,8 +1816,17 @@
     }
 
     if (!force_hw_singlestep || waiting_on_bp) {
+	if (!has_userspace_breakpoint
+	    && thread_list_needs_clearing
+	    && thread_event_do_exit_bp != NULL) {
+	    delete_breakpoint(thread_event_do_exit_bp);
+	    thread_event_do_exit_bp = NULL;
+	}
+
+	if (thread_list_needs_clearing)
+	    thread_list_clear_cache ();
+
 	linux_awareness_ops->lo_clear_cache ();
-	thread_list_clear_cache ();
     }
 
     stick_to_kernelspace = 0;
@@ -2866,8 +2881,13 @@
 	return so_list_from_lm_infos ();
     }
 
-    DEBUG (MODULE, 1, "Reading module list\n");
-    linux_read_module_list ();
+    /* Reread only if the current list is empty. Either, there's no
+       module and it will go fast, or the user just cleaned the list
+       (using for example 'set module-search-path').  */
+    if (lm_infos == NULL) {
+	DEBUG (MODULE, 1, "Reading module list\n");
+	linux_read_module_list ();
+    }
     return so_list_from_lm_infos ();
 }
 
@@ -2978,6 +2998,8 @@
 	xfree (current_process);
 	current_process = NULL;
     }
+
+    thread_list_needs_clearing = 0;
 }
 
 static struct process **
@@ -3022,6 +3044,13 @@
     if (processes != NULL)
 	return processes;
 
+    if (thread_event_do_exit_bp == NULL) {
+	if (HAS_ADDR (DO_EXIT))
+	    thread_event_do_exit_bp = create_thread_event_breakpoint (ADDR (DO_EXIT));
+	else
+	    warning ("'do_exit' wasn't found.");
+    }
+
     get_thread_list_helper(current_struct_task, ps);
 
     if (processes && processes->next == NULL) {
@@ -3224,7 +3253,7 @@
 	}
 
 	if (!has_bp) {
-	    if (thread_event_do_exit_bp != NULL) {
+	    if (processes == NULL && thread_event_do_exit_bp != NULL) {
 		delete_breakpoint(thread_event_do_exit_bp);
 		thread_event_do_exit_bp = NULL;
 	    }
@@ -3232,6 +3261,7 @@
 		delete_breakpoint(thread_event_low_mem_bp);
 		thread_event_low_mem_bp = NULL;
 	    }
+	    has_userspace_breakpoint = 0;
 	}
     }
 }
@@ -3259,6 +3289,15 @@
 	CORE_ADDR task_struct = linux_awareness_ops->lo_current_task_struct_address ();
 	unsigned int pid = read_unsigned_field (task_struct, TASK_STRUCT__PID);
 	ptid_t ptid = linux_aware_pid_to_ptid (pid);
+	int new_last_pid = -1;
+
+	if (HAS_ADDR(LAST_PID))
+	    new_last_pid = read_memory_integer(ADDR(LAST_PID), 4);
+
+	if (new_last_pid != last_pid) {
+	    last_pid = new_last_pid;
+	    thread_list_clear_cache();
+	}
 
 	DEBUG (TASK, 3,"linux_aware_wait : getting current process\n");
 	if ((shlib_event_load_bp && pc == shlib_event_load_bp->loc->address)
@@ -3298,6 +3337,7 @@
 	    DEBUG (USER, 2, "Process has ended (pid %i)\n",
 		   PIDGET (current_ptid));
 	    delete_user_process (thread_id);
+	    thread_list_needs_clearing = 1;
 	} else if (thread_event_low_mem_bp != NULL
 		   && pc == thread_event_low_mem_bp->loc->address) {
 	    disable_userspace_breakpoints();
@@ -5473,6 +5513,7 @@
 	    }
 
 	    /* Read module list. */
+	    linux_read_module_list();
 	    solib_add (NULL, from_tty, (struct target_ops *) 0, 1);
 	    /* Let the linux-awareness target part believe that we've run. */
 	    linux_awareness_ops->lo_clear_cache ();
@@ -5513,6 +5554,8 @@
 	    set_nopage_watchpoint (bpt, addr);
 	}
 
+	has_userspace_breakpoint = 1;
+
 	if (HAS_ADDR (DO_EXIT)) {
 	    if (thread_event_do_exit_bp == NULL)
 		thread_event_do_exit_bp = create_thread_event_breakpoint (ADDR (DO_EXIT));
