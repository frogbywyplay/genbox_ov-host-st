--- gdb-6.4.orig/gdb/config/sh/linux.mt 2006-08-10 10:55:49.000000000 +0100
+++ gdb-6.4/gdb/config/sh/linux.mt      2006-08-10 10:56:48.000000000 +0100
@@ -2,7 +2,7 @@
 TDEPFILES= sh-tdep.o sh64-tdep.o sh-linux-tdep.o \
 	monitor.o sh3-rom.o remote-e7000.o ser-e7kpc.o dsrec.o \
 	shtdi.o solib.o solib-svr4.o symfile-mem.o linux-awareness.o \
-	linux-awareness-sh4.o
+	linux-awareness-sh4.o linux-tdep.o
 DEPRECATED_TM_FILE= tm-linux.h
 
 SIM_OBS =
diff -Naur gdb-6.4.orig/gdb/annotate.c gdb-6.4/gdb/annotate.c
--- gdb-6.4.orig/gdb/annotate.c	2006-08-10 10:20:53.000000000 +0100
+++ gdb-6.4/gdb/annotate.c	2006-08-10 10:22:23.000000000 +0100
@@ -453,6 +453,13 @@
 }
 
 void
+annotate_context_entry (void)
+{
+  if (annotation_level == 2)
+    printf_filtered ("\n\032\032context-switch\n");
+}
+
+void
 annotate_frame_address (void)
 {
   if (annotation_level == 2)
diff -Naur gdb-6.4.orig/gdb/annotate.h gdb-6.4/gdb/annotate.h
--- gdb-6.4.orig/gdb/annotate.h	2006-08-10 10:20:53.000000000 +0100
+++ gdb-6.4/gdb/annotate.h	2006-08-10 10:22:23.000000000 +0100
@@ -81,6 +81,7 @@
 extern void annotate_frame_begin (int, CORE_ADDR);
 extern void annotate_function_call (void);
 extern void annotate_signal_handler_caller (void);
+extern void annotate_context_entry (void);
 extern void annotate_frame_address (void);
 extern void annotate_frame_address_end (void);
 extern void annotate_frame_function_name (void);
diff -Naur gdb-6.4.orig/gdb/frame.h gdb-6.4/gdb/frame.h
--- gdb-6.4.orig/gdb/frame.h	2006-08-10 10:20:53.000000000 +0100
+++ gdb-6.4/gdb/frame.h	2006-08-10 10:22:23.000000000 +0100
@@ -385,7 +385,10 @@
   SIGTRAMP_FRAME,
   /* Sentinel or registers frame.  This frame obtains register values
      direct from the inferior's registers.  */
-  SENTINEL_FRAME
+  SENTINEL_FRAME,
+  /* Kernel context switch frame. Shouldn't be printed in info threads
+   * listing. */
+  CONTEXT_FRAME
 };
 extern enum frame_type get_frame_type (struct frame_info *);
 
diff -Naur gdb-6.4.orig/gdb/linux-tdep.c gdb-6.4/gdb/linux-tdep.c
--- gdb-6.4.orig/gdb/linux-tdep.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.4/gdb/linux-tdep.c	2006-08-10 10:22:23.000000000 +0100
@@ -0,0 +1,127 @@
+/* Target-dependent code for Linux kernel.
+
+   Copyright 2004 LinSysSoft Technologies Pvt. Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+  
+#include "defs.h"
+#include "frame.h"
+#include "gdbarch.h"
+#include "frame-unwind.h"
+#include "gdb_assert.h"
+#include "symtab.h"
+#include "objfiles.h"
+#include "linux-tdep.h"
+
+/* Identifier for a context frame is composed of simply the sp and pc derived
+ * from next frame, which is a sentinel frame */
+static void
+linux_context_frame_this_id (struct frame_info *next_frame, void **this_cache,
+		      struct frame_id *this_id)
+{
+  int optimized;
+  enum lval_type lvalp;
+  CORE_ADDR addr;
+  int realnum;
+  CORE_ADDR spaddr;
+  struct minimal_symbol *s;
+  struct context_unwind_data *unwind_data = (struct context_unwind_data *)
+			linux_context_frame_unwinder.unwind_data;
+
+  frame_register_unwind(next_frame, SP_REGNUM, &optimized, &lvalp, &addr,
+			&realnum, &spaddr);
+  spaddr += unwind_data->spshift;
+  s = lookup_minimal_symbol("__switch_to_begin", NULL, symfile_objfile);
+  (*this_id) = frame_id_build(spaddr, SYMBOL_VALUE_ADDRESS(s));
+}
+
+/*
+ * The pc of the frame previous to a context frame is reported at the
+ * instruction just past the last instruction of switch_to kernel macro. The
+ * sp may also need some adjustments because the switch_to macro may contain
+ * code that changes sp
+ */
+static void
+linux_context_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+			    int regnum, int *optimizedp,
+			    enum lval_type *lvalp, CORE_ADDR *addrp,
+			    int *realnump, void *valuep)
+{
+  struct minimal_symbol *s;
+  struct context_unwind_data *unwind_data = (struct context_unwind_data *)
+			linux_context_frame_unwinder.unwind_data;
+  frame_register_unwind(next_frame, regnum, optimizedp, lvalp, addrp,
+			realnump, valuep);
+  if (regnum == PC_REGNUM)
+    {
+      *addrp = 0;
+      s = lookup_minimal_symbol("__switch_to_end", NULL, symfile_objfile);
+      (*(CORE_ADDR*)valuep) = SYMBOL_VALUE_ADDRESS(s);
+    }
+  else if (regnum == SP_REGNUM)
+    {
+      *addrp = 0;
+      if (valuep)
+	(*(CORE_ADDR*)valuep) += unwind_data->spshift;
+    }
+}
+
+/* If pc is in the section .sched.text and if the next frame is a sentinel
+ * frame, it has to be a context switch call frame */
+static const struct frame_unwind *
+linux_context_frame_sniffer (struct frame_unwind *self,
+			 struct frame_info *next_frame,
+			 void **this_prologue_cache)
+{
+  CORE_ADDR pc;
+  struct minimal_symbol *s;
+
+  extern int debugkernel;
+  if (!debugkernel)
+      return NULL;
+
+  if (get_frame_type(next_frame) == SENTINEL_FRAME)
+    {
+      pc = frame_pc_unwind(next_frame);
+      s = lookup_minimal_symbol("__switch_to_begin", NULL, symfile_objfile);
+      if (!s || pc < SYMBOL_VALUE_ADDRESS(s))
+	return NULL;
+      s = lookup_minimal_symbol("__switch_to_end", NULL, symfile_objfile);
+      if (!s || pc >= SYMBOL_VALUE_ADDRESS(s))
+	return NULL;
+      return &linux_context_frame_unwinder;
+    }
+  return NULL;
+}
+
+static struct context_unwind_data linux_context_unwind_data;
+
+const struct frame_unwind linux_context_frame_unwinder =
+{
+  CONTEXT_FRAME,
+  linux_context_frame_this_id,
+  linux_context_frame_prev_register,
+  (struct frame_data *)&linux_context_unwind_data,
+  linux_context_frame_sniffer
+};
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern void _initialize_linux_tdep (void);
+
+void
+_initialize_linux_tdep (void)
+{
+}
diff -Naur gdb-6.4.orig/gdb/linux-tdep.h gdb-6.4/gdb/linux-tdep.h
--- gdb-6.4.orig/gdb/linux-tdep.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.4/gdb/linux-tdep.h	2006-08-10 10:22:23.000000000 +0100
@@ -0,0 +1,38 @@
+/* Target-dependent code for Linux kernel.
+
+   Copyright 2004 LinSysSoft Technologies Pvt. Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+  
+#ifndef LINUX_TDEP_H
+#define LINUX_TDEP_H
+
+/* CONTEXT_FRAME unwind data */
+struct context_unwind_data
+{
+	/* These two fields record the difference between pc and sp of context
+	 * and the previous frame (the schedule kernel function)
+	 * We use these fields and the pc and sp of the frame next to the
+	 * context frame (sentinel frame) to figure out the pc and sp of the
+	 * schedule function frame.
+	 */
+	int pcshift;
+	int spshift;
+};
+
+extern const struct frame_unwind linux_context_frame_unwinder;
+
+#endif /* #ifndef LINUX_TDEP_H */
diff -Naur gdb-6.4.orig/gdb/sh-linux-tdep.c gdb-6.4/gdb/sh-linux-tdep.c
--- gdb-6.4.orig/gdb/sh-linux-tdep.c	2006-08-10 10:20:53.000000000 +0100
+++ gdb-6.4/gdb/sh-linux-tdep.c	2006-08-10 10:22:23.000000000 +0100
@@ -37,6 +37,7 @@
 #include "solib-svr4.h"
 #include "symtab.h"
 #include "osabi.h"
+#include "linux-tdep.h"
 
 #include "sh-tdep.h"
 #include "glibc-tdep.h"
@@ -475,6 +476,7 @@
 		    struct gdbarch *gdbarch)
 {
   int i;
+  struct context_unwind_data *unwind_data;
 
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
@@ -488,6 +490,13 @@
   set_gdbarch_register_name (gdbarch, sh_linux_register_name);
 
   frame_unwind_append_sniffer (gdbarch, sh_linux_sigtramp_frame_sniffer);
+
+  unwind_data = (struct context_unwind_data *)
+		linux_context_frame_unwinder.unwind_data;
+  /* From kernel/include/asm-sh/system.h  */
+  unwind_data->pcshift = 0;
+  unwind_data->spshift = 9*4;
+  frame_unwind_prepend_unwinder (gdbarch, &linux_context_frame_unwinder);
 }
 
 void
diff -Naur gdb-6.4.orig/gdb/stack.c gdb-6.4/gdb/stack.c
--- gdb-6.4.orig/gdb/stack.c	2006-08-10 10:20:53.000000000 +0100
+++ gdb-6.4/gdb/stack.c	2006-08-10 10:29:00.000000000 +0100
@@ -4,6 +4,8 @@
    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
    Free Software Foundation, Inc.
 
+   Copyright 2004 LinSysSoft Technologies Pvt. Ltd.
+
    This file is part of GDB.
 
    This program is free software; you can redistribute it and/or modify
@@ -45,6 +47,7 @@
 #include "regcache.h"
 #include "solib.h"
 #include "valprint.h"
+#include "objfiles.h"
 
 #include "gdb_assert.h"
 #include <ctype.h>
@@ -405,9 +408,14 @@
   struct symtab_and_line sal;
   int source_print;
   int location_print;
+  CORE_ADDR pc;
+  struct frame_id fid;
+  struct minimal_symbol *schedbegin;
+  struct minimal_symbol *schedend;
 
   if (get_frame_type (frame) == DUMMY_FRAME
-      || get_frame_type (frame) == SIGTRAMP_FRAME)
+      || get_frame_type (frame) == SIGTRAMP_FRAME
+      || (get_frame_type (frame) == CONTEXT_FRAME && print_level != 0))
     {
       struct cleanup *uiout_cleanup
 	= make_cleanup_ui_out_tuple_begin_end (uiout, "frame");
@@ -440,6 +448,12 @@
 	  annotate_signal_handler_caller ();
           ui_out_field_string (uiout, "func", "<signal handler called>");
         }
+      else if (get_frame_type (frame) == CONTEXT_FRAME)
+        {
+	  annotate_context_entry ();
+	  ui_out_field_string (uiout, "func", "<context switch>");
+        }
+
       ui_out_text (uiout, "\n");
       annotate_frame_end ();
 
@@ -447,6 +461,28 @@
       return;
     }
 
+    /* Don't print context switch and scheduler frames if we are at level 0.  */
+    if (get_frame_type (frame) == CONTEXT_FRAME)
+      {
+        schedbegin = lookup_minimal_symbol("__sched_text_start", NULL,
+                                         symfile_objfile);
+        schedend = lookup_minimal_symbol("__sched_text_end", NULL,
+                                       symfile_objfile);
+        if (schedbegin && schedend)
+        while ((frame = get_prev_frame(frame)) != NULL)
+          {
+            fid = get_frame_id(frame);
+            pc = 0;
+            if (!fid.code_addr_p)
+              break;
+            pc = get_frame_id(frame).code_addr; 
+             if (SYMBOL_VALUE_ADDRESS(schedbegin) >= pc)
+              break;
+            if (SYMBOL_VALUE_ADDRESS(schedend) <= pc)
+              break;
+          }
+      }
+
   /* If FRAME is not the innermost frame, that normally means that
      FRAME->pc points to *after* the call instruction, and we want to
      get the line containing the call, never the next line.  But if
