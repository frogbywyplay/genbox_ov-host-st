diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/a.out.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/a.out.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/a.out.h	2005-02-10 09:26:44.000000000 +0000
@@ -0,0 +1,20 @@
+#ifndef _ASM_ST200_A_OUT_H__
+#define _ASM_ST200_A_OUT_H__
+
+struct exec
+{
+  unsigned long a_info;		/* Use macros N_MAGIC, etc for access */
+  unsigned a_text;		/* length of text, in bytes */
+  unsigned a_data;		/* length of data, in bytes */
+  unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+  unsigned a_syms;		/* length of symbol table data in file, in bytes */
+  unsigned a_entry;		/* start address */
+  unsigned a_trsize;		/* length of relocation info for text, in bytes */
+  unsigned a_drsize;		/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#endif /* _ASM_ST200_A_OUT_H__ */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/atomic.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/atomic.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/atomic.h	2005-05-31 15:37:21.828001000 +0100
@@ -0,0 +1,207 @@
+/*
+ *  include/asm-st200/atomic.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_ATOMIC_H
+#define _ASM_ST200_ATOMIC_H
+
+#include <asm/system.h>
+
+#ifndef typecheck
+/* Gross Hack time. linux/kernel.h now includes bitops.h.
+ * which has the definition of typecheck in it. Unfortunately
+ * we need it for the local_save_flags etc below. Rather than
+ * get rid of the typecheck macro in local_save_flags, I've stuck
+ * it in here, because when I figure out why using the atomic rollback
+ * technique causes failure
+ */
+
+#define typecheck(type,x) \
+({     type __dummy; \
+       typeof(x) __dummy2; \
+       (void)(&__dummy == &__dummy2); \
+       1; \
+})
+#endif
+
+#define save_and_cli(x)  do { local_save_flags(x); local_irq_disable(); } while (0)
+#define restore_flags(x) local_irq_restore(x)
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ *
+ */
+
+/*
+ * Make sure gcc doesn't try to be clever and move things around
+ * on us. We need to use _exactly_ the address the user gave us,
+ * not some alias that contains the same information.
+ */
+typedef struct { volatile int counter; } atomic_t;
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+/**
+ * atomic_read - read atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically reads the value of @v.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_read(v)		((v)->counter)
+
+/**
+ * atomic_set - set atomic variable
+ * @v: pointer of type atomic_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_set(v,i)		((v)->counter = (i))
+
+/**
+ * atomic_add - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ *
+ * Atomically adds @i to @v.  Note that the guaranteed useful range
+ * of an atomic_t is only 24 bits.
+ */
+static __inline__ void atomic_add(int i, atomic_t * v)
+{
+	unsigned long flags;
+
+	save_and_cli(flags);
+	*(long *)v += i;
+	restore_flags(flags);
+}
+
+/**
+ * atomic_sub - subtract the atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+static __inline__ void atomic_sub(int i, atomic_t *v)
+{
+	unsigned long flags;
+
+	save_and_cli(flags);
+	*(long *)v -= i;
+	restore_flags(flags);
+}
+
+/* Helper function */
+static __inline__ int __atomic_add_return(int i, atomic_t * v)
+{
+	unsigned long temp, flags;
+
+	save_and_cli(flags);
+	temp = *(long *)v;
+	temp += i;
+	*(long *)v = temp;
+	restore_flags(flags);
+
+	return temp;
+}
+
+/* Helper function */
+static __inline__ int __atomic_sub_return(int i, atomic_t * v)
+{
+	unsigned long temp, flags;
+
+	save_and_cli(flags);
+	temp = *(long *)v;
+	temp -= i;
+	*(long *)v = temp;
+	restore_flags(flags);
+
+	return temp;
+}
+
+/**
+ * atomic_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ *
+ * Atomically subtracts @i from @v and returns
+ * true if the result is zero, or false for all
+ * other cases.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_sub_and_test(i,v) (__atomic_sub_return((i), (v)) == 0)
+
+/**
+ * atomic_inc - increment atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_inc(v) atomic_add(1,(v))
+
+/**
+ * atomic_dec - decrement atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_dec(v) atomic_sub(1,(v))
+
+/**
+ * atomic_dec_and_test - decrement and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically decrements @v by 1 and
+ * returns true if the result is 0, or false for all other
+ * cases.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_dec_and_test(v) (__atomic_sub_return(1, (v)) == 0)
+
+/**
+ * atomic_inc_and_test - increment and test
+ * @v: pointer of type atomic_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_inc_and_test(v) (__atomic_add_return(1, (v)) == 0)
+
+/**
+ * atomic_add_negative - add and test if negative
+ * @v: pointer of type atomic_t
+ * @i: integer value to add
+ *
+ * Atomically adds @i to @v and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+#define atomic_add_negative(i, v) (__atomic_add_return(i, (v)) < 0)
+
+/* Helper functions for semaphores */
+#define atomic_dec_return(v)	__atomic_sub_return (1, (v))
+#define atomic_inc_return(v)	__atomic_add_return (1, (v))
+
+/* Atomic operations are already serializing */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#undef save_and_cli
+#undef restore_flags
+
+#endif /* _ASM_ST200_ATOMIC_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/bitops.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/bitops.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/bitops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/bitops.h	2005-05-31 15:38:34.427003000 +0100
@@ -0,0 +1,528 @@
+/*
+ *  include/asm-st200/bitops.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BITOPS_H
+#define _ASM_ST200_BITOPS_H
+
+#include "unimplemented.h"
+
+#include <asm/system.h>
+
+
+#ifndef typecheck
+
+/* Gross Hack time. linux/kernel.h now includes bitops.h.
+ * which has the definition of typecheck in it. Unfortunately
+ * we need it for the local_save_flags etc below. Rather than
+ * get rid of the typecheck macro in local_save_flags, I've stuck
+ * it in here, because when I figure out why using the atomic rollback
+ * technique causes failure
+ */
+
+#define typecheck(type,x) \
+({     type __dummy; \
+       typeof(x) __dummy2; \
+       (void)(&__dummy == &__dummy2); \
+       1; \
+})
+#endif
+
+
+#define save_and_cli(x)  do { local_save_flags(x); local_irq_disable(); } while (0)
+#define restore_flags(x) local_irq_restore(x)
+
+/*
+ * All bit operations return 0 if the bit was cleared before the
+ * operation and != 0 if it was not.
+ *
+ * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
+ */
+
+/**
+ * set_bit - Atomically set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * This function is atomic and may not be reordered.  See __set_bit()
+ * if you do not require the atomic guarantees.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void set_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask;
+	volatile unsigned long *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli(flags);
+	*a |= mask;
+	restore_flags(flags);
+}
+
+/**
+ * __set_bit - Set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * Unlike set_bit(), this function is non-atomic and may be reordered.
+ * If it's called on the same region of memory simultaneously, the effect
+ * may be that only one operation succeeds.
+ */
+static __inline__ void __set_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask;
+	volatile unsigned long *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a |= mask;
+}
+
+/**
+ * clear_bit - Clears a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * clear_bit() is atomic and may not be reordered.  However, it does
+ * not contain a memory barrier, so if it is used for locking purposes,
+ * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
+ * in order to ensure changes are visible on other processors.
+ */
+static __inline__ void clear_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask;
+	volatile unsigned long *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli(flags);
+	*a &= ~mask;
+	restore_flags(flags);
+}
+
+static __inline__ void __clear_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask;
+	volatile unsigned long *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a &= ~mask;
+}
+
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+/**
+ * change_bit - Toggle a bit in memory
+ * @nr: Bit to change
+ * @addr: Address to start counting from
+ *
+ * change_bit() is atomic and may not be reordered.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void change_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask;
+	volatile unsigned long *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli(flags);
+	*a ^= mask;
+	restore_flags(flags);
+}
+
+/**
+ * __change_bit - Toggle a bit in memory
+ * @nr: the bit to change
+ * @addr: the address to start counting from
+ *
+ * Unlike change_bit(), this function is non-atomic and may be reordered.
+ * If it's called on the same region of memory simultaneously, the effect
+ * may be that only one operation succeeds.
+ */
+static __inline__ void __change_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask;
+	volatile unsigned long *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	*a ^= mask;
+}
+
+/**
+ * test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_set_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask, retval;
+	volatile unsigned long *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli(flags);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+	restore_flags(flags);
+
+	return retval;
+}
+
+/**
+ * __test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is non-atomic and can be reordered.  
+ * If two examples of this operation race, one can appear to succeed
+ * but actually fail.  You must protect multiple accesses with a lock.
+ */
+static __inline__ int __test_and_set_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask, retval;
+	volatile unsigned long *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a |= mask;
+
+	return retval;
+}
+
+/**
+ * test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to clear
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_clear_bit(int nr, volatile unsigned long * addr)
+{
+	int	mask, retval;
+	volatile unsigned long *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli(flags);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+	restore_flags(flags);
+
+	return retval;
+}
+
+/**
+ * __test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to clear
+ * @addr: Address to count from
+ *
+ * This operation is non-atomic and can be reordered.  
+ * If two examples of this operation race, one can appear to succeed
+ * but actually fail.  You must protect multiple accesses with a lock.
+ */
+static __inline__ int __test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+	int	mask, retval;
+	volatile unsigned long *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a &= ~mask;
+
+	return retval;
+}
+
+/**
+ * test_and_change_bit - Change a bit and return its new value
+ * @nr: Bit to change
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_change_bit(int nr, volatile unsigned long* addr)
+{
+	int	mask, retval;
+	volatile unsigned long *a = addr;
+	unsigned long flags;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	save_and_cli(flags);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+	restore_flags(flags);
+
+	return retval;
+}
+
+/* WARNING: non atomic and it can be reordered! */
+static __inline__ int __test_and_change_bit(int nr, volatile unsigned long *addr)
+{
+	int	mask, retval;
+	volatile unsigned long *a = addr;
+
+	a += nr >> 5;
+	mask = 1 << (nr & 0x1f);
+	retval = (mask & *a) != 0;
+	*a ^= mask;
+
+	return retval;
+}
+
+/**
+ * test_bit - Determine whether a bit is set
+ * @nr: bit number to test
+ * @addr: Address to start counting from
+ */
+static __inline__ int test_bit(int nr, const volatile void *addr)
+{
+	return 1UL & (((const volatile unsigned int *) addr)[nr >> 5] >> (nr & 31));
+}
+
+/**
+ * ffz - find first zero in word.
+ * @word: The word to search
+ *
+ * Undefined if no zero exists, so code should check against ~0UL first.
+ */
+static __inline__ unsigned long ffz(unsigned long word)
+{
+	int k;
+
+	word = ~word;
+	k = 31;
+	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
+	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
+	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
+	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
+	if (word & 0x40000000) { k -= 1; }
+	return k;
+}
+
+/**
+ * __ffs - find first bit in word.
+ * @word: The word to search
+ *
+ * Undefined if no bit exists, so code should check against 0 first.
+ */
+static __inline__ unsigned long __ffs(unsigned long word)
+{
+	int k;
+
+	k = 31;
+	if (word & 0x0000ffff) { k -= 16; word <<= 16; }
+	if (word & 0x00ff0000) { k -= 8;  word <<= 8;  }
+	if (word & 0x0f000000) { k -= 4;  word <<= 4;  }
+	if (word & 0x30000000) { k -= 2;  word <<= 2;  }
+	if (word & 0x40000000) { k -= 1; }
+        return k;
+}
+
+#define fls(x) generic_fls(x)
+
+/**
+ * find_next_zero_bit - find the first zero bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The maximum size to search
+ */
+static __inline__ int find_next_zero_bit(unsigned long * addr, int size, int offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *(p++);
+		tmp |= ~0UL >> (32-offset);
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp |= ~0UL << size;
+found_middle:
+	return result + ffz(tmp);
+}
+
+/**
+ * find_next_bit - find the first set bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The maximum size to search
+ */
+static __inline__ int find_next_bit(unsigned long *addr, int size, int offset)
+{
+	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
+	unsigned int result = offset & ~31UL;
+	unsigned int tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *p++;
+		tmp &= ~0UL << offset;
+		if (size < 32)
+			goto found_first;
+		if (tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size >= 32) {
+		if ((tmp = *p++) != 0)
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp &= ~0UL >> (32 - size);
+	if (tmp == 0UL)        /* Are any bits set? */
+		return result + size; /* Nope. */
+found_middle:
+	return result + __ffs(tmp);
+}
+
+/**
+ * find_first_zero_bit - find the first zero bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit-number of the first zero bit, not the number of the byte
+ * containing a bit.
+ */
+static __inline__ int find_first_zero_bit(unsigned long * addr, unsigned size)
+{
+        return find_next_zero_bit(addr, size, 0);
+}
+
+/**
+ * find_first_bit - find the first set bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit-number of the first set bit, not the number of the byte
+ * containing a bit.
+ */
+static __inline__ int find_first_bit(unsigned long * addr, unsigned size)
+{
+	return find_next_bit(addr, size, 0);
+}
+
+/*
+ * Every architecture must define this function. It's the fastest
+ * way of searching a 140-bit bitmap where the first 100 bits are
+ * unlikely to be set. It's guaranteed that at least one of the 140
+ * bits is cleared.
+ */
+static inline int sched_find_first_bit(unsigned long *b)
+{
+	if (unlikely(b[0]))
+		return __ffs(b[0]);
+	if (unlikely(b[1]))
+		return __ffs(b[1]) + 32;
+	if (unlikely(b[2]))
+		return __ffs(b[2]) + 64;
+	if (b[3])
+		return __ffs(b[3]) + 96;
+	return __ffs(b[4]) + 128;
+}
+
+/**
+ * ffs - find first bit set
+ * @x: the word to search
+ *
+ * This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+static __inline__ int ffs(int x)
+{
+	unimplemented(__FUNCTION__);
+	return 0;
+}
+
+/**
+ * hweightN - returns the hamming weight of a N-bit word
+ * @x: the word to weigh
+ *
+ * The Hamming Weight of a number is the total number of bits set in it.
+ */
+
+#define hweight32(x) generic_hweight32(x)
+#define hweight16(x) generic_hweight16(x)
+#define hweight8(x) generic_hweight8(x)
+
+
+#define ext2_set_bit(nr,addr) \
+	__test_and_set_bit((nr),(unsigned long*)addr)
+#define ext2_set_bit_atomic(lock,nr,addr) \
+        test_and_set_bit((nr),(unsigned long*)addr)
+#define ext2_clear_bit(nr, addr) \
+	__test_and_clear_bit((nr),(unsigned long*)addr)
+#define ext2_clear_bit_atomic(lock,nr, addr) \
+                test_and_clear_bit((nr),(unsigned long*)addr)
+#define ext2_test_bit(nr, addr)      test_bit((nr),(unsigned long*)addr)
+#define ext2_find_first_zero_bit(addr, size) \
+	find_first_zero_bit((unsigned long*)addr, size)
+#define ext2_find_next_zero_bit(addr, size, off) \
+	find_next_zero_bit((unsigned long*)addr, size, off)
+
+/* Bitmap functions for the minix filesystem.  */
+#define minix_test_and_set_bit(nr,addr) __test_and_set_bit(nr,(void*)addr)
+#define minix_set_bit(nr,addr) __set_bit(nr,(void*)addr)
+#define minix_test_and_clear_bit(nr,addr) __test_and_clear_bit(nr,(void*)addr)
+#define minix_test_bit(nr,addr) test_bit(nr,(void*)addr)
+#define minix_find_first_zero_bit(addr,size) \
+	find_first_zero_bit((void*)addr,size)
+
+#undef save_and_cli
+#undef restore_flags
+
+#endif /* _ASM_ST200_BITOPS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/bug.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/bug.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/bug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/bug.h	2005-02-10 11:52:41.000000000 +0000
@@ -0,0 +1,35 @@
+/*
+ *  include/asm-st200/io.h
+ *
+ *  Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BUG_H
+#define _ASM_ST200_BUG_H
+
+/*
+ * Tell the user there is some problem.
+ * The offending file and line are encoded after the "officially
+ * undefined" opcode for parsing in the trap handler.
+ */
+
+#define BUG() do { \
+	printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
+} while (0)
+
+#define BUG_ON(condition) do { if (unlikely((condition)!=0)) BUG(); } while(0)
+
+#define PAGE_BUG(page) do {		\
+	BUG();				\
+} while (0)
+
+#define WARN_ON(condition) do { \
+        if (unlikely((condition)!=0)) { \
+                printk("Badness in %s at %s:%d\n", __FUNCTION__, __FILE__, __LINE__); \
+                dump_stack(); \
+        } \
+} while (0)
+
+#endif /* _ASM_ST200_BUG_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/byteorder.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/byteorder.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/byteorder.h	2005-02-10 09:40:10.000000000 +0000
@@ -0,0 +1,14 @@
+/*
+ *  include/asm-st200/byteorder.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_BYTEORDER_H
+#define _ASM_ST200_BYTEORDER_H
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _ASM_ST200_BYTEORDER_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/cacheflush.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/cacheflush.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/cacheflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/cacheflush.h	2004-10-12 14:21:36.000000000 +0100
@@ -0,0 +1,77 @@
+/*
+ * include/asm-st200/cacheflush.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_CACHEFLUSH_H
+#define _ASM_ST200_CACHEFLUSH_H
+
+#include <linux/mm.h>
+
+/*
+ * This is called when changing a kernel virtual to physical mapping.
+ * Called from ioremap, vmalloc and vmap.
+ */
+#define flush_cache_all()			do { } while (0)
+
+/*
+ * The next three calls are used when changing a user space virtual
+ * to physical mapping, before the call to flush_tlb_...().
+ * For example:
+ *	flush_cache_mm		called from fork and exit.
+ *	flush_cache_range	called from mmap, mprotect, mremap and msync.
+ *	flush_cache_page	called when copying COW page, swapping pages
+ *				out, while generating core dumps and ptrace.
+ */
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr)		do { } while (0)
+#define flush_cache_vmap(start, end)            do { } while (0)
+#define flush_cache_vunmap(start, end)          do { } while (0)
+
+/*
+ * DEPRECATED.
+ * page is about to be mapped into user address space.
+ */
+#define flush_page_to_ram(page)			do { } while (0)
+
+/*
+ * Called when page is first assigned to a pte.
+ * Called when faulting or swapping in a page.
+ */
+#define flush_icache_page(vma, page)		do { } while (0)
+
+/*
+ * Used to synchronise the user mapping of a page and the page cache
+ * version. Called after the kernel has written to the page OR the
+ * user has potentially written to it and the kernel needs to read it.
+ */
+void flush_dcache_page(struct page *page);
+
+#define flush_dcache_mmap_lock(mapping)         do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)       do { } while (0)
+
+/*
+ * Used when the kernel has modified memory it is going to execute.
+ * Used when loading a kernel module or binfmt_flat files in uCLinux.
+ */
+void flush_icache_range(unsigned long start, unsigned long end);
+
+/*
+ * Used when the kernel has modified a user page via the kernel mapping.
+ * Currently only used by ptrace.
+ */
+void flush_icache_user_range(struct vm_area_struct *vma,
+			     struct page *page, unsigned long addr, int len);
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+do { memcpy(dst, src, len); \
+     flush_icache_user_range(vma, page, vaddr, len); \
+} while (0)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+        memcpy(dst, src, len)
+
+#endif /* _ASM_ST200_CACHEFLUSH_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/cache.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/cache.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/cache.h	2005-02-10 11:55:23.000000000 +0000
@@ -0,0 +1,17 @@
+/*
+ * include/asm-st200/cache.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+#ifndef _ASM_ST200_CACHE_H
+#define _ASM_ST200_CACHE_H
+
+/* L1 cache line size */
+#define L1_CACHE_SHIFT	5
+#define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
+
+#define L1_CACHE_SHIFT_MAX L1_CACHE_SHIFT	/* largest L1 which this arch supports */
+
+#endif /* _ASM_ST200_CACHE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/checksum.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/checksum.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/checksum.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/checksum.h	2004-10-12 14:21:36.000000000 +0100
@@ -0,0 +1,112 @@
+/*
+ * include/asm-st200/checksum.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef __ASM_ST200_CHECKSUM_H
+#define __ASM_ST200_CHECKSUM_H
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+unsigned int csum_partial(const unsigned char * buff, int len, unsigned int sum);
+
+/*
+ *	Note: when you get a NULL pointer exception here this means someone
+ *	passed in an incorrect kernel address to one of these functions. 
+ *	
+ *	If you use these functions directly please don't forget the 
+ *	verify_area().
+ */
+
+
+unsigned int
+csum_partial_copy_nocheck(const char *src, char *dst, int len, unsigned int sum);
+
+unsigned int csum_partial_copy_from_user ( const char *src, char *dst,
+					   int len, int sum, int *err_ptr);
+
+/*
+ * These are the old (and unsafe) way of doing checksums, a warning message will be
+ * printed if they are used and an exeption occurs.
+ *
+ * these functions should go away after some time.
+ */
+
+#define csum_partial_copy_fromuser csum_partial_copy
+
+unsigned int csum_partial_copy( const char *src, char *dst, int len, unsigned int sum);
+
+/*
+ *	Fold a partial checksum
+ */
+static inline unsigned short csum_fold(unsigned int sum)
+{
+        sum = (sum & 0xffff) + (sum >> 16);
+        sum = (sum & 0xffff) + (sum >> 16);
+        return ~(sum);
+}
+
+unsigned short ip_fast_csum(unsigned char * iph, unsigned int ihl);
+
+unsigned long csum_tcpudp_nofold(unsigned long saddr,
+			         unsigned long daddr,
+				 unsigned short len,
+				 unsigned short proto,
+				 unsigned int sum);
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+static __inline__ unsigned short int csum_tcpudp_magic(unsigned long saddr,
+						       unsigned long daddr,
+						       unsigned short len,
+						       unsigned short proto,
+						       unsigned int sum) 
+{
+  unsigned short int x;
+  x = csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
+  return x;
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+
+static __inline__ unsigned short ip_compute_csum(unsigned char * buff, int len)
+{
+    return csum_fold (csum_partial(buff, len, 0));
+}
+
+#endif /* __ASM_SHMEDIA_CHECKSUM_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ctrlregdef-230.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ctrlregdef-230.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ctrlregdef-230.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ctrlregdef-230.h	2004-10-12 14:21:36.000000000 +0100
@@ -0,0 +1,153 @@
+/*
+ * include/asm-st200/ctrlregdef-230.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Control register defintions for ST230
+ */
+
+#ifndef _ASM_ST200_CTRLREGDEFS_230_H
+#define _ASM_ST200_CTRLREGDEFS_230_H
+
+/* Exception cause as an integer, indicating the cause of the last trap. */
+#define EXCAUSENO	CTRL_ADDR(0xff88)
+
+
+/* TLB related control registers */
+#define TLB_INDEX	CTRL_ADDR(0xff80)	/* Index of the TLB entry pointed to by TLB_ENTRYx */
+#define TLB_ENTRY0	CTRL_ADDR(0xff78)	/* TLB entry bits  [31:00] */
+#define TLB_ENTRY1	CTRL_ADDR(0xff70)	/* TLB entry bits  [63:32] */
+#define TLB_ENTRY2	CTRL_ADDR(0xff68)	/* TLB entry bits  [95:64] */
+#define TLB_ENTRY3	CTRL_ADDR(0xff60)	/* TLB entry bits [127:96] */
+#define TLB_EXCAUSE	CTRL_ADDR(0xff58)	/* Cause of the TLB related exception */
+#define TLB_CONTROL	CTRL_ADDR(0xff50)	/* Control bits for TLB */
+#define TLB_REPLACE	CTRL_ADDR(0xff48)	/* Replacement pointer */
+#define TLB_ASID	CTRL_ADDR(0xff40)	/* Current address space ID */
+
+#define SCU_BASE0	CTRL_ADDR(0xd000)	/* SCU base 0. */
+#define SCU_LIMIT0	CTRL_ADDR(0xd008)	/* SCU limit 0. */
+#define SCU_BASE1	CTRL_ADDR(0xd010)	/* SCU base 1. */
+#define SCU_LIMIT1	CTRL_ADDR(0xd018)	/* SCU limit 1. */
+#define SCU_BASE2	CTRL_ADDR(0xd020)	/* SCU base 2. */
+#define SCU_LIMIT2	CTRL_ADDR(0xd028)	/* SCU limit 2. */
+#define SCU_BASE3	CTRL_ADDR(0xd030)	/* SCU base 3. */
+#define SCU_LIMIT3	CTRL_ADDR(0xd038)	/* SCU limit 3. */
+#define SCU_BASE(n)     CTRL_ADDR(0xd000+(0x10*(n)))  /* SCU base n */
+#define SCU_LIMIT(n)    CTRL_ADDR(0xd008+(0x10*(n)))  /* SCU limit n */
+#define SCU_NUM_ENTRIES 4
+
+#define SCU_SHIFT	13
+
+/************ PSW bit definitions ************/
+#define PSW_USER_MODE			(1<< 0)	/* When 1 the core is in user mode, otherwise supervisor mode. */
+#define PSW_INT_ENABLE			(1<< 1)	/* When 1 external interrupts are enabled. */
+#define PSW_TLB_ENABLE			(1<< 2)	/* When 1 address translation is enabled. */
+#define PSW_TLB_DYNAMIC			(1<< 3)	/* When 1 purges and speculative loads which miss the TLB cause TLB_NO_MAPPING exceptions. */
+#define PSW_SPECLOAD_MALIGNTRAP_EN	(1<< 4)	/* When 1 enables exceptions on speculative load misalignment errors. */
+#define PSW_DBREAK_ENABLE		(1<< 8)	/* When 1 data breakpoints are enabled. */
+#define PSW_IBREAK_ENABLE		(1<< 9)	/* When 1 instruction breakpoints are enabled. */
+#define PSW_DEBUG_MODE			(1<<12)	/* When 1 the core is in debug mode. */
+
+/* These are the default things we always stick in the PSW, separated out for
+ * user and kernel. Done like this for uclinux, which doesn't appreciate 
+ * having the TLB turned on!
+ */
+#define PSW_KERNEL_NOSPEC	(PSW_TLB_ENABLE|PSW_SPECLOAD_MALIGNTRAP_EN)
+#define PSW_KERNEL_DEFAULT	(PSW_TLB_ENABLE|PSW_SPECLOAD_MALIGNTRAP_EN|PSW_TLB_DYNAMIC)
+#define PSW_USER_DEFAULT	(PSW_TLB_ENABLE|PSW_TLB_DYNAMIC|PSW_USER_MODE)
+
+/* TLB bit definitions */
+#define TLB_ENTRY0_ASID_MASK		0xff
+#define TLB_ENTRY0_SHARED		(1<< 8)	/* Page shared by multiple processes (ASID ignored). */
+#define TLB_ENTRY0_PROT_SUPER_X		(1<< 9)
+#define TLB_ENTRY0_PROT_SUPER_R		(2<< 9)
+#define TLB_ENTRY0_PROT_SUPER_W		(4<< 9)
+#define TLB_ENTRY0_PROT_SUPER_RWX	\
+	(TLB_ENTRY0_PROT_SUPER_X | TLB_ENTRY0_PROT_SUPER_R | TLB_ENTRY0_PROT_SUPER_W)
+#define TLB_ENTRY0_PROT_USER_X		(1<<12)
+#define TLB_ENTRY0_PROT_USER_R		(2<<12)
+#define TLB_ENTRY0_PROT_USER_W		(4<<12)
+#define TLB_ENTRY0_PROT_USER_RWX	\
+	(TLB_ENTRY0_PROT_USER_X | TLB_ENTRY0_PROT_USER_R | TLB_ENTRY0_PROT_USER_W)
+#define TLB_ENTRY0_DIRTY		(1<<15)	/* Page is dirty. When this bit is 0 write accesses to this page (when write permission is allowed) cause a TLB_WRITE_TO_CLEAN exception. When this bit is 1 writes to this page (when write permission is allowed) are permitted. */
+#define TLB_ENTRY0_POLICY_MASK		(15<<16)
+#define TLB_ENTRY0_POLICY_UNCACHED	(0<<16)	/* Non cached */
+#define TLB_ENTRY0_POLICY_CACHED	(1<<16)	/* Cached */
+#define TLB_ENTRY0_POLICY_WCUNCACHED	(2<<16)	/* Write combining */
+#define TLB_ENTRY0_SIZE_MASK		(7<<20)
+#define TLB_ENTRY0_SIZE_DISABLED	(0<<20)	/* Disabled */
+#define TLB_ENTRY0_SIZE_8K		(1<<20)	/* 8Kb */
+#define TLB_ENTRY0_SIZE_4M		(2<<20)	/* 4MB */
+#define TLB_ENTRY0_SIZE_256M		(3<<20)	/* 256MB */
+
+#define TLB_ENTRY1_VADDR_MASK		0x0007ffff	/* For 8K pages */
+#define TLB_ENTRY1_VADDR_SHIFT		13
+
+#define TLB_ENTRY2_PADDR_MASK		0x0007ffff	/* For 8K pages */
+#define TLB_ENTRY2_PADDR_SHIFT		13
+
+/* TLB_REPLACE masks */
+#define TLB_REPLACE_LFSR_MASK		0xffff
+#define TLB_REPLACE_LIMIT_SHIFT		16
+
+/* TLB_CONTROL masks */
+#define TLB_CONTROL_ITLB_FLUSH		(1<<0)
+#define TLB_CONTROL_DTLB_FLUSH		(1<<1)
+
+/* TLB_ASID masks */
+#define TLB_ASID_ASID_MASK		0xff
+
+/* TLB_EXCAUSE bit defintions */
+#define TLB_EXCAUSE_INDEX_MASK		0x3f
+#define TLB_EXCAUSE_CAUSE_MASK			(3<<16)
+#define TLB_EXCAUSE_CAUSE_NO_MAPPING		(0<<16)
+#define TLB_EXCAUSE_CAUSE_PROT_VIOLATION	(1<<16)
+#define TLB_EXCAUSE_CAUSE_WRITE_TO_CLEAN	(2<<16)
+#define TLB_EXCAUSE_CAUSE_MULTI_MAPPING		(3<<16)
+#define TLB_EXCAUSE_SPEC	(1<<18)
+#define TLB_EXCAUSE_WRITE	(1<<19)
+#define TLB_EXCAUSE_IN_UTLB	(1<<20)
+
+/* EXCAUSENO definitions */
+#define EXCAUSENO_STBUS_IC_ERROR	 0	/* The Instruction Cache caused a bus error. */
+#define EXCAUSENO_STBUS_DC_ERROR	 1	/* The Data Cache caused a bus error. */
+#define EXCAUSENO_EXTERN_INT		 2	/* There was an external interrupt. */
+#define EXCAUSENO_IBREAK		 3	/* An instruction address breakpoint has occured. */
+#define EXCAUSENO_ITLB			 4	/* Instruction side TLB exception */
+#define EXCAUSENO_SBREAK		 5	/* A software breakpoint was found. */
+#define EXCAUSENO_ILL_INST		 6	/* The bundle could not be decoded into legal sequence of operations or a privileged operation is being issued in user mode. */
+#define EXCAUSENO_SYSCALL		 7	/* A syscall instruction was found */
+#define EXCAUSENO_DBREAK		 8	/* The DPU has triggered a breakpoint on a data address. */
+#define EXCAUSENO_MISALIGNED_TRAP	 9	/* The address is misaligned and misaligned accesses are not supported. */
+#define EXCAUSENO_CREG_NO_MAPPING	10	/* The load or store address was in control register space, but no control register exists at that exact address. */
+#define EXCAUSENO_CREG_ACCESS_VIOLATION	11	/* A store to a control register was attempted whilst in user mode. */
+#define EXCAUSENO_DTLB			12	/* Data side TLB exception */
+#define EXCAUSENO_SDI_TIMEOUT		14	/* One of the SDI interfaces timed out while being accessed. */
+
+/* EXCAUSE bit definitions */
+#define EXCAUSE_STBUS_IC_ERROR		(1<<EXCAUSENO_STBUS_IC_ERROR)
+#define EXCAUSE_STBUS_DC_ERROR		(1<<EXCAUSENO_STBUS_DC_ERROR)
+#define EXCAUSE_EXTERN_INT		(1<<EXCAUSENO_EXTERN_INT)
+#define EXCAUSE_IBREAK			(1<<EXCAUSENO_IBREAK)
+#define EXCAUSE_ITLB			(1<<EXCAUSENO_ITLB)
+#define EXCAUSE_SBREAK			(1<<EXCAUSENO_SBREAK)
+#define EXCAUSE_ILL_INST		(1<<EXCAUSENO_ILL_INST)
+#define EXCAUSE_SYSCALL			(1<<EXCAUSENO_SYSCALL)
+#define EXCAUSE_DBREAK			(1<<EXCAUSENO_DBREAK)
+#define EXCAUSE_MISALIGNED_TRAP		(1<<EXCAUSENO_MISALIGNED_TRAP)
+#define EXCAUSE_CREG_NO_MAPPING		(1<<EXCAUSENO_CREG_NO_MAPPING)
+#define EXCAUSE_CREG_ACCESS_VIOLATION	(1<<EXCAUSENO_CREG_ACCESS_VIOLATION)
+#define EXCAUSE_DTLB			(1<<EXCAUSENO_DTLB)
+#define EXCAUSE_SDI_TIMEOUT		(1<<EXCAUSENO_SDI_TIMEOUT)
+
+/* Additional performance monitoring events */
+#define PM_EVENT_LONGIMM		21	/* Number of long immediates in completed bundles. */
+#define PM_EVENT_ITLBMISS		22	/* The number of instruction cache fills that missed the ITLB. */
+#define PM_EVENT_DTLBMISS		23	/* The number of load/store operations that missed the DTLB when the TLB is enabled. */
+#define PM_EVENT_UTLBHIT		24	/* The number of accesses to the UTLB which were hits. */
+#define PM_EVENT_ITLBWAITCYCLES		25	/* Number of cycles the instruction cache spends waiting for the ITLB to fill. */
+#define PM_EVENT_DTLBWAITCYCLES		26	/* Number of cycles the data cache spends waiting for the ITLB to fill. */
+#define PM_EVENT_UTLBARBITRATIONCYCLES	27	/* Number of cycles where the ITLB or DTLB was waiting for access to the UTLB because the UTLB was busy servicing a request. */
+
+#endif /* _ASM_ST200_CTRLREGDEFS_230_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ctrlregdef.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ctrlregdef.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ctrlregdef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ctrlregdef.h	2005-05-31 15:45:15.540000000 +0100
@@ -0,0 +1,101 @@
+/*
+ * include/asm-st200/ctrlregdef.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Control register defintions for generic ST200
+ */
+
+#ifndef _ASM_ST200_CTRLREGDEFS_H
+#define _ASM_ST200_CTRLREGDEFS_H
+
+#include "ctrlregdef-230.h"
+
+#define CTRL_REG_BASE 0xffff0000
+
+#define CTRL_ADDR(offset) (CTRL_REG_BASE+(offset))
+
+/* Saved Program Counter, written by hardware on exception. */
+#define SAVED_PC	CTRL_ADDR(0xffe8)
+
+/* Saved PSW, written by hardware on exception. */
+#define SAVED_PSW	CTRL_ADDR(0xfff0)
+
+/* The Program Status Word. */
+#define PSW		CTRL_ADDR(0xfff8)
+
+/* Exception handler defines */
+
+/* The address of the exception handler code. */
+#define HANDLER_PC CTRL_ADDR(0xffe0)
+
+/* A one hot vector of trap (exception/interrupt) types
+   indicating the cause of the last trap. Written by the hardware on a trap. */
+#define EXCAUSE CTRL_ADDR(0xffd8)
+
+/* This will be the data effective address in the case of 
+    either a DPU, CREG, DBREAK, or MISALIGNED_TRAP exception. 
+    For other exception types this register will be zero. */
+#define EXADDRESS CTRL_ADDR(0xffd0)
+
+#define SCRATCH1 CTRL_ADDR(0xffa8)
+#define SCRATCH2 CTRL_ADDR(0xffa0)
+
+/* Performance register defintions */
+
+#define PM_EVENT_DHIT		0	/* The number of load and stores that hit the cache. This includes uncached accesses that hit the cache. */
+#define PM_EVENT_DMISS		1	/* The number of load and stores that miss the cache. This includes stores that miss the cache and are send to the write buffer. Uncached accesses are not included in this count. */
+#define PM_EVENT_DMISSCYCLES	2	/* The number of cycles the core is stalled due to the data cache being busy. */
+#define PM_EVENT_PFTISSUED	3	/* The number of prefetches */
+#define PM_EVENT_PFTHITS	4	/* The number of cached loads that hit the prefetch buffer. */
+#define PM_EVENT_WBHITS		5	/* The number of cached writes that hit the write buffer. */
+#define PM_EVENT_IHIT		6	/* The number of accesses the instruction buffer made that hit the instruction cache. */
+#define PM_EVENT_IMISS		7	/* The number of accesses the instruction buffer made that missed the instruction cache. */
+#define PM_EVENT_IMISSCYCLES	8	/* The number of cycles the instruction cache was stalled for. */
+#define PM_EVENT_IBUFINVALID	9	/* Duration where IBuffer is not able to issue bundles to the pipeline. */
+#define PM_EVENT_BUNDLES	10	/* Bundles executed. */
+#define PM_EVENT_LDST		11	/* Load/Store instructions executed. */
+#define PM_EVENT_TAKENBR	12	/* Number of taken branches (br and brf), rfis,goto sandcall s.  */
+#define PM_EVENT_NOTTAKENBR	13	/* Number of not taken branches (br and brf). */
+#define PM_EVENT_EXCEPTIONS	14	/* Number of exceptions and Debug interrupts. */
+#define PM_EVENT_INTERRUPTS	15	/* Number of interrupts. */
+#define PM_EVENT_BUSREADS	16	/* Number of architectural read transactions issued to the bus. This is the number of uncached reads, I & D cache refills and prefetches issued to the bus. */
+#define PM_EVENT_BUSWRITES	17	/* Number of architectural write transactions issued to the bus. This is the number of write buffer lines evicted and the number of uncached writes issued to the bus. */
+#define PM_EVENT_OPERATIONS	18	/* Number of completed operations. Includes nops in the instruction stream but not those added dynamically. This counter excludes long immediates. */
+#define PM_EVENT_WBMISSES	19	/* Number of cached writes that missed the cache and misses the write buffer. This excludes cache line evictions. */
+#define PM_EVENT_NOPBUNDLES	20	/* Number of completed bundles that were empty or contained only nops. This includes nop bundles generated by instruction buffer stalls and interlocking stalls. It excludes pipeline stalls due to load/stores and control register/sdi accesses. */
+
+#define PM_CR		CTRL_ADDR(0xf800)	/* Performance monitoring control. */
+#define PM_CNT0		CTRL_ADDR(0xf808)	/* Performance monitor counter 0 value. */
+#define PM_CNT1		CTRL_ADDR(0xf810)	/* Performance monitor counter 1 value. */
+#define PM_CNT2		CTRL_ADDR(0xf818)	/* Performance monitor counter 2 value. */
+#define PM_CNT3		CTRL_ADDR(0xf820)	/* Performance monitor counter 3 value. */
+#define PM_PCLK		CTRL_ADDR(0xf828)	/* Performance monitor core cycle counter. */
+
+#define PM_CR_ENB	0 	/* When 1, counting is enabled. When 0 counting is disabled. */
+#define PM_CR_RST	1	/* When a 1 is written all the counters (PM_CNT0-3 and PM_PCLK) are set to zero. If a 0 is written it is ignored. This field does not retain its value and so always reads as 0. */
+#define PM_CR_EVENT0	12	/* 5-bit field specifying the event being monitored for this counter. */
+#define PM_CR_EVENT1	17	/* 5-bit field specifying the event being monitored for this counter. */
+#define PM_CR_EVENT2	22	/* 5-bit field specifying the event being monitored for this counter. */
+#define PM_CR_EVENT3	27	/* 5-bit field specifying the event being monitored for this counter. */
+
+/* Debug related registers */
+
+#define DBREAK_LOWER	CTRL_ADDR(0xfe80)	/* Data breakpoint lower address. */
+#define DBREAK_UPPER	CTRL_ADDR(0xfe78)	/* Data breakpoint upper address. */
+#define DBREAK_CONTROL	CTRL_ADDR(0xfe70)	/* Data breakpoint control. */
+
+#define IBREAK_LOWER	CTRL_ADDR(0xfdd0)	/* Instruction breakpoint lower address. */
+#define IBREAK_UPPER	CTRL_ADDR(0xfdc8)	/* Instruction breakpoint upper address. */
+#define IBREAK_CONTROL	CTRL_ADDR(0xfdc0)	/* Instruction breakpoint control. */
+
+#define BREAK_CONTROL_BRK_IN_RANGE	(1<<0)	/* Break if address >= lower && address <=upper. */
+#define BREAK_CONTROL_BRK_OUT_RANGE	(1<<1)	/* Break if address < lower || address > upper. */
+#define BREAK_CONTROL_BRK_EITHER	(1<<2)	/* Break if address == lower || address == upper. */
+#define BREAK_CONTROL_BRK_MASKED	(1<<3)	/* Break if address & upper == lower. */
+
+#define SAVED_SAVED_PSW	CTRL_ADDR(0xffc0)	/* PSW saved by debug unit interrupt. */
+#define SAVED_SAVED_PC	CTRL_ADDR(0xffb8)	/* PC saved by debug unit interrupt. */
+
+#endif /* _ASM_ST200_CTRLREGDEFS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/current.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/current.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/current.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/current.h	2004-10-12 14:21:36.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ *  include/asm-st200/current.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_CURRENT_H
+#define _ASM_ST200_CURRENT_H
+
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static inline struct task_struct * get_current(void)
+{
+	return current_thread_info()->task;
+}
+
+#define current get_current()
+
+#endif /* _ASM_ST200_CURRENT_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/debugregs.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/debugregs.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/debugregs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/debugregs.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * include/asm-st200/debugregs.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+/* Arguments to PT_DEBUG to get the offset of registers into struct user */
+
+#ifndef _ASM_ST200_DEBUGREGS_H
+#define _ASM_ST200_DEBUGREGS_H
+
+#define DR_DBREAK_CONTROL	0
+#define DR_DBREAK_LOWER		1
+#define DR_DBREAK_UPPER		2
+#define DR_IBREAK_CONTROL	3
+#define DR_IBREAK_LOWER		4
+#define DR_IBREAK_UPPER		5
+
+#define DR_TRACE		6
+
+/* Values for DR_[DI]BREAK_CONTROL */
+
+#define DR_BRK_IN_RANGE		(1<<0)
+#define DR_BRK_OUT_RANGE	(1<<1)
+#define DR_BRK_EITHER		(1<<2)
+#define DR_BRK_MASKED		(1<<3)
+
+#endif /* _ASM_ST200_DEBUGREGS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/delay.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/delay.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/delay.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/delay.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,22 @@
+/*
+ *  include/asm-st200/delay.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_DELAY_H
+#define _ASM_ST200_DELAY_H
+
+extern void __bad_udelay(void);
+
+extern void __udelay(unsigned long usecs);
+extern void __const_udelay(unsigned long usecs);
+extern void __delay(unsigned long loops);
+
+#define udelay(n) (__builtin_constant_p(n) ? \
+	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 0x10c6ul)) : \
+	__udelay(n))
+
+#endif /* _ASM_ST200_DELAY_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/dma.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/dma.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/dma.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,27 @@
+/*
+ *  include/asm-st200/dma.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_DMA_H
+#define _ASM_ST200_DMA_H
+
+#include <asm/io.h>
+
+/* The maximum address that we can perform a DMA transfer to on this platform */
+#define MAX_DMA_ADDRESS      (0xFFFFFFFF)
+
+/* These are in kernel/dma.c: */
+extern int request_dma(unsigned int dmanr, const char * device_id);	/* reserve a DMA channel */
+extern void free_dma(unsigned int dmanr);	/* release it again */
+
+#ifdef CONFIG_PCI
+extern int isa_dma_bridge_buggy;
+#else
+#define isa_dma_bridge_buggy 	(0)
+#endif
+
+#endif /* _ASM_ST200_DMA_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/dma-mapping.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/dma-mapping.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/dma-mapping.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/dma-mapping.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,166 @@
+#ifndef _ASM_ST200_DMA_MAPPING_H
+#define _ASM_ST200_DMA_MAPPING_H
+
+#include <linux/mm.h>
+#include <asm/cache.h>
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+
+/* These should really allocate some cached memory */
+#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
+#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
+
+void *dma_alloc_coherent(struct device *dev, size_t size,
+			   dma_addr_t *dma_handle, int flag);
+
+void dma_free_coherent(struct device *dev, size_t size,
+			 void *vaddr, dma_addr_t dma_handle);
+
+extern void st200_flush_dcache_range(unsigned long addr,unsigned long size);
+
+
+static inline dma_addr_t
+dma_map_single(struct device *dev, void *ptr, size_t size,
+	       enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+
+	st200_flush_dcache_range(ptr,size);
+	return virt_to_phys(ptr);
+}
+
+static inline void
+dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
+		 enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+}
+
+static inline int
+dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	   enum dma_data_direction direction)
+{
+	int i;
+	void set_watchpoint(void);
+
+	BUG_ON(direction == DMA_NONE);
+
+        for (i=0; i<nents; i++) {
+                st200_flush_dcache_range(page_address(sg[i].page) + sg[i].offset, sg[i].length);
+                sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
+        }
+
+	return nents;
+}
+
+static inline dma_addr_t
+dma_map_page(struct device *dev, struct page *page, unsigned long offset,
+	     size_t size, enum dma_data_direction direction)
+{
+	return dma_map_single(dev, page_address(page) + offset, size,direction);
+}
+
+static inline void
+dma_unmap_page(struct device *dev, dma_addr_t dma_handle, size_t size,
+	       enum dma_data_direction direction)
+{
+	dma_unmap_single(dev, dma_handle, size,direction);
+}
+
+
+static inline void
+dma_unmap_sg(struct device *dev, struct scatterlist *sg, int nhwentries,
+	     enum dma_data_direction direction)
+{
+	BUG_ON(direction == DMA_NONE);
+}
+
+static inline void
+dma_sync_single_for_cpu(struct device *dev, dma_addr_t dma_handle, size_t size,
+		enum dma_data_direction direction)
+{
+	st200_flush_dcache_range(phys_to_virt(dma_handle),size);
+}
+
+static inline void
+dma_sync_single_for_device(struct device *dev, dma_addr_t dma_handle, size_t size,
+		enum dma_data_direction direction)
+{
+	st200_flush_dcache_range(phys_to_virt(dma_handle),size);
+}
+
+static inline void
+dma_sync_single_range_for_cpu(struct device *dev, dma_addr_t dma_handle,
+		      unsigned long offset, size_t size,
+		      enum dma_data_direction direction)
+{
+	st200_flush_dcache_range(phys_to_virt(dma_handle)+offset,size);
+}
+
+static inline void
+dma_sync_single_range_for_device(struct device *dev, dma_addr_t dma_handle,
+		      unsigned long offset, size_t size,
+		      enum dma_data_direction direction)
+{
+	st200_flush_dcache_range(phys_to_virt(dma_handle)+offset,size);
+}
+
+
+static inline void
+dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nelems,
+		 enum dma_data_direction direction)
+{
+        int i;
+
+        for (i = 0; i < nelems; i++) {
+                st200_flush_dcache_range(page_address(sg[i].page) + sg[i].offset, sg[i].length);
+        }
+}
+
+
+static inline void
+dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nelems,
+		 enum dma_data_direction direction)
+{
+        int i;
+
+        for (i = 0; i < nelems; i++) {
+                st200_flush_dcache_range(page_address(sg[i].page) + sg[i].offset, sg[i].length);
+        }
+}
+
+static inline int
+dma_supported(struct device *dev, u64 mask)
+{
+	return 1;
+}
+
+static inline int
+dma_set_mask(struct device *dev, u64 mask)
+{
+	if(!dev->dma_mask || !dma_supported(dev, mask))
+		return -EIO;
+
+	*dev->dma_mask = mask;
+
+	return 0;
+}
+
+static inline int
+dma_get_cache_alignment(void)
+{
+	/* no easy way to get cache size on all x86, so return the
+	 * maximum possible, to be safe */
+	return (1 << L1_CACHE_SHIFT_MAX);
+}
+
+#define dma_is_consistent(d)	(0)
+
+static inline void
+dma_cache_sync(void *vaddr, size_t size,
+	       enum dma_data_direction direction)
+{
+	st200_flush_dcache_range(vaddr,size);
+}
+
+#endif /*_ASM_ST200_DMA_MAPPING_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/elf.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/elf.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/elf.h	2005-06-01 12:35:13.676000000 +0100
@@ -0,0 +1,103 @@
+#ifndef __ASM_ST200_ELF_H
+#define __ASM_ST200_ELF_H
+
+/*
+ * st200 ELF relocation types
+ */
+#define KR_LX_32                2       /* Simple 32 bit relocation -- for data */
+#define KR_LX_23_PCREL          4       /* A PC Relative 24-bit relocation, shifted by 2 right container */
+#define KR_LX_HI23              5       /* A HI part of a 32 bit absolute relocation */
+#define KR_LX_LO9               6       /* low part of a 32 immediate */
+
+/*
+ * ELF register definitions..
+ */
+
+#include <asm/ptrace.h>
+#include <asm/user.h>
+#include <asm/processor.h>
+
+#include <linux/utsname.h>
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG	(sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct { } elf_fpregset_t;
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) ((x)->e_machine == EM_ST200)
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#define ELF_DATA	ELFDATA2LSB
+#define ELF_ARCH	EM_ST200
+
+/* $r0.1 is set by ld.so to a pointer to a function which might be 
+   registered using atexit.  This provides a mean for the dynamic
+   linker to call DT_FINI functions for shared libraries that have
+   been loaded before the code runs.
+
+   So that we can use the same startup file with static executables,
+   we start programs with a value of 0 to indicate that there is no
+   such function.  */
+#define ELF_PLAT_INIT(_r, load_addr) do	\
+	_r->r16 = 0;			\
+while (0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	8192
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+
+
+/* The registers are layed out in pt_regs for efficient syscalling.
+   Re-order them for the linear elf_gregset_t. */
+
+struct pt_regs; /* forward declaration... */
+extern void
+st200_elf_core_copy_regs (struct pt_regs *regs, elf_gregset_t dst);
+#define ELF_CORE_COPY_REGS(dst, regs) \
+	st200_elf_core_copy_regs(regs, dst);
+
+/* Similar, but for a thread other than current.  */
+
+extern int
+st200_elf_core_copy_task_regs(struct task_struct *task, elf_gregset_t *dst);
+#define ELF_CORE_COPY_TASK_REGS(task, dst) \
+        st200_elf_core_copy_task_regs(task, dst)
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this CPU supports.  This could be done in user space,
+   but it's not easy, and we've already done it here.  */
+
+#define ELF_HWCAP	0
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.
+
+   For the moment, we have only optimizations for the Intel generations,
+   but that could change... */
+
+#define ELF_PLATFORM  (system_utsname.machine)
+
+#define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
+#define ELF_CORE_COPY_FPREGS(t, fpu) (0)
+
+#ifdef CONFIG_SMP
+extern void dump_smp_unlazy_fpu(void);
+#define ELF_CORE_SYNC dump_smp_unlazy_fpu
+#endif
+
+#endif /* _ASM_ST200_ELF_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/errno.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/errno.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/errno.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/errno.h	2005-06-01 10:36:29.308005000 +0100
@@ -0,0 +1,12 @@
+/*
+ *  include/asm-st200/errno.h
+ */
+
+#ifndef __ASM_ST200_ERRNO_H
+#define __ASM_ST200_ERRNO_H
+
+#ifndef _LINUX_ERRNO_H
+ #include <linux/errno.h>
+#endif
+
+#endif /* __ASM_ST200_ERRNO_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/fcntl.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/fcntl.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/fcntl.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,96 @@
+/*
+ *  include/asm-st200/fcntl.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_FCNTL_H
+#define _ASM_ST200_FCNTL_H
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define FASYNC		 020000	/* fcntl, for BSD compatibility */
+#define O_DIRECT	 040000	/* direct disk access hint */
+#define O_LARGEFILE	0100000
+#define O_DIRECTORY	0200000	/* must be a directory */
+#define O_NOFOLLOW	0400000 /* don't follow links */
+#define O_NOATIME	01000000
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+#define F_GETLK		5
+#define F_SETLK		6
+#define F_SETLKW	7
+
+#define F_SETOWN	8	/*  for sockets. */
+#define F_GETOWN	9	/*  for sockets. */
+#define F_SETSIG	10	/*  for sockets. */
+#define F_GETSIG	11	/*  for sockets. */
+
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* for leases */
+#define F_INPROGRESS	16
+
+/* operations for bsd flock(), also used by the kernel implementation */
+#define LOCK_SH		1	/* shared lock */
+#define LOCK_EX		2	/* exclusive lock */
+#define LOCK_NB		4	/* or'd with one of the above to prevent
+				   blocking */
+#define LOCK_UN		8	/* remove lock */
+
+#define LOCK_MAND	32	/* This is a mandatory flock */
+#define LOCK_READ	64	/* ... Which allows concurrent read operations */
+#define LOCK_WRITE	128	/* ... Which allows concurrent write operations */
+#define LOCK_RW		192	/* ... Which allows concurrent read & write ops */
+
+struct flock {
+	short l_type;
+	short l_whence;
+	off_t l_start;
+	off_t l_len;
+	pid_t l_pid;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
+};
+
+#define F_LINUX_SPECIFIC_BASE	1024
+
+#endif /* _ASM_ST200_FCNTL_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/flat.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/flat.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/flat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/flat.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,14 @@
+/*
+ *  include/asm-st200/flat.h
+ *
+ *  Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Philippe Guillaume <philippe.guillaume@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_FLAT_H_
+#define _ASM_ST200_FLAT_H_
+
+#define flat_argvp_envp_on_stack()  0
+
+#endif /* _ASM_ST200_FLAT_H_ */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/hardirq.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/hardirq.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/hardirq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/hardirq.h	2005-05-31 15:53:14.267001000 +0100
@@ -0,0 +1,28 @@
+#ifndef _ST200_HARDIRQ_H
+#define _ST200_HARDIRQ_H
+
+#include <linux/threads.h>
+#include <linux/cache.h>
+
+/* entry.S is sensitive to the offsets of these fields */
+typedef struct {
+	unsigned long __softirq_pending;
+	unsigned int __syscall_count;
+	unsigned long idle_timestamp;
+	struct task_struct * __ksoftirqd_task;
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+#define HARDIRQ_BITS	12
+
+/*
+ * The hardirq mask has to be large enough to have
+ * space for potentially nestable IRQ sources in the system
+ * to nest on a single CPU
+ */
+#if (1 << HARDIRQ_BITS) < 16
+#error HARDIRQ_BITS is too low!
+#endif
+
+#endif /* _ST200_HARDIRQ_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/hw_irq.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/hw_irq.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/hw_irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/hw_irq.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __ASM_ST200_HW_IRQ_H
+#define __ASM_ST200_HW_IRQ_H
+static __inline__ void st200_do_profile (unsigned long pc) {/*Not implemented yet*/}
+
+static __inline__ void hw_resend_irq(struct hw_interrupt_type *h, unsigned int i) { /* Nothing to do */ }
+#endif /* __ASM_ST200_HW_IRQ_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ioctl.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ioctl.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ioctl.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ *  include/asm-st200/ioctl.h
+ *
+ *  copied from include/asm-alpha/ioctl.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+#ifndef _ASM_ST200_IOCTL_H
+#define _ASM_ST200_IOCTL_H
+
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	13
+#define _IOC_DIRBITS	3
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits _IOC_NONE could be 0, but OSF/1 gives it a bit.
+ * And this turns out useful to catch old ioctl numbers in header
+ * files for us.
+ */
+#define _IOC_NONE	1U
+#define _IOC_READ	2U
+#define _IOC_WRITE	4U
+
+#define _IOC(dir,type,nr,size)			\
+	((unsigned int)				\
+	 (((dir)  << _IOC_DIRSHIFT) |		\
+	  ((type) << _IOC_TYPESHIFT) |		\
+	  ((nr)	  << _IOC_NRSHIFT) |		\
+	  ((size) << _IOC_SIZESHIFT)))
+
+/* used to create ioctl numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_ST200_IOCTL_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ioctls.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ioctls.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ioctls.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ioctls.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,126 @@
+/*
+ * include/asm-st200/cacheflush.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_IOCTLS_H
+#define _ASM_ST200_IOCTLS_H
+
+#include <asm/ioctl.h>
+
+#define FIOCLEX		_IO('f', 1)
+#define FIONCLEX	_IO('f', 2)
+#define FIOASYNC	_IOW('f', 125, int)
+#define FIONBIO		_IOW('f', 126, int)
+#define FIONREAD	_IOR('f', 127, int)
+#define TIOCINQ		FIONREAD
+#define FIOQSIZE	_IOR('f', 128, loff_t)
+
+#if 0 /* depricated */
+#define TIOCGETP	_IOR('t', 8, struct sgttyb)
+#define TIOCSETP	_IOW('t', 9, struct sgttyb)
+#define TIOCSETN	_IOW('t', 10, struct sgttyb)	/* TIOCSETP wo flush */
+#define TIOCSETC	_IOW('t', 17, struct tchars)
+#define TIOCGETC	_IOR('t', 18, struct tchars)
+#endif
+
+#define TCGETS		_IOR('t', 19, struct termios)
+#define TCSETS		_IOW('t', 20, struct termios)
+#define TCSETSW		_IOW('t', 21, struct termios)
+#define TCSETSF		_IOW('t', 22, struct termios)
+
+#define TCGETA		_IOR('t', 23, struct termio)
+#define TCSETA		_IOW('t', 24, struct termio)
+#define TCSETAW		_IOW('t', 25, struct termio)
+#define TCSETAF		_IOW('t', 28, struct termio)
+
+#define TCSBRK		_IO('t', 29)
+#define TCXONC		_IO('t', 30)
+#define TCFLSH		_IO('t', 31)
+
+#define TIOCSWINSZ	_IOW('t', 103, struct winsize)
+#define TIOCGWINSZ	_IOR('t', 104, struct winsize)
+#define	TIOCSTART	_IO('t', 110)		/* start output, like ^Q */
+#define	TIOCSTOP	_IO('t', 111)		/* stop output, like ^S */
+#define TIOCOUTQ        _IOR('t', 115, int)     /* output queue size */
+
+#if 0 /* depricated */
+#define TIOCGLTC	_IOR('t', 116, struct ltchars)
+#define TIOCSLTC	_IOW('t', 117, struct ltchars)
+#endif
+#define TIOCSPGRP	_IOW('t', 118, int)
+#define TIOCGPGRP	_IOR('t', 119, int)
+
+#define TIOCEXCL	_IO('T', 12)
+#define TIOCNXCL	_IO('T', 13)
+#define TIOCSCTTY	_IO('T', 14)
+
+#define TIOCSTI		_IOW('T', 18, char)
+#define TIOCMGET	_IOR('T', 21, int)
+#define TIOCMBIS	_IOW('T', 22, int)
+#define TIOCMBIC	_IOW('T', 23, int)
+#define TIOCMSET	_IOW('T', 24, int)
+# define TIOCM_LE	0x001
+# define TIOCM_DTR	0x002
+# define TIOCM_RTS	0x004
+# define TIOCM_ST	0x008
+# define TIOCM_SR	0x010
+# define TIOCM_CTS	0x020
+# define TIOCM_CAR	0x040
+# define TIOCM_RNG	0x080
+# define TIOCM_DSR	0x100
+# define TIOCM_CD	TIOCM_CAR
+# define TIOCM_RI	TIOCM_RNG
+# define TIOCM_OUT1	0x2000
+# define TIOCM_OUT2	0x4000
+# define TIOCM_LOOP	0x8000
+
+#define TIOCGSOFTCAR	_IOR('T', 25, int)
+#define TIOCSSOFTCAR	_IOW('T', 26, int)
+#define TIOCLINUX	_IOWR('T', 28, char)
+#define TIOCCONS	_IO('T', 29)
+#define TIOCGSERIAL	_IOR('T', 30, struct serial_struct)
+#define TIOCSSERIAL	_IOW('T', 31, struct serial_struct)
+#define TIOCPKT		_IOW('T', 32, int)
+# define TIOCPKT_DATA		 0
+# define TIOCPKT_FLUSHREAD	 1
+# define TIOCPKT_FLUSHWRITE	 2
+# define TIOCPKT_STOP		 4
+# define TIOCPKT_START		 8
+# define TIOCPKT_NOSTOP		16
+# define TIOCPKT_DOSTOP		32
+
+
+#define TIOCNOTTY	_IO('T', 34)
+#define TIOCSETD	_IOW('T', 35, int)
+#define TIOCGETD	_IOR('T', 36, int)
+#define TCSBRKP		_IOW('T', 37, int)	/* Needed for POSIX tcsendbreak() */
+#define TIOCTTYGSTRUCT	_IOR('T', 38, struct tty_struct)  /* For debugging only */
+#define TIOCSBRK	_IO('T', 39)		/* BSD compatibility */
+#define TIOCCBRK	_IO('T', 40)		/* BSD compatibility */
+#define TIOCGSID	_IOR('T', 41, pid_t)	/* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T', 48, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T', 49, int)	/* Lock/unlock Pty */
+
+#define TIOCSERCONFIG	_IO('T', 83)
+#define TIOCSERGWILD	_IOR('T', 84,  int)
+#define TIOCSERSWILD	_IOW('T', 85,  int)
+#define TIOCGLCKTRMIOS	_IOR('T', 86, struct termios)
+#define TIOCSLCKTRMIOS	_IOW('T', 86, struct termios)
+#define TIOCSERGSTRUCT	_IOR('T', 88, struct async_struct)	/* For debugging only */
+#define TIOCSERGETLSR	_IOR('T', 89, unsigned int)	/* Get line status register */
+  /* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+# define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#define TIOCSERGETMULTI	_IOR('T', 90, struct serial_multiport_struct)	/* Get multiport config  */
+#define TIOCSERSETMULTI	_IOW('T', 91, struct serial_multiport_struct)	/* Set multiport config */
+
+#define TIOCMIWAIT	_IO('T', 92)	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	_IOR('T', 93, struct async_icount)	/* read serial port inline interrupt counts */
+#define TIOCGHAYESESP	_IOR('T', 94, struct hayes_esp_config)	/* Get Hayes ESP configuration */
+#define TIOCSHAYESESP	_IOW('T', 94, struct hayes_esp_config)	/* Set Hayes ESP configuration */
+
+#endif /* _ASM_ST200_IOCTLS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/io.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/io.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/io.h	2005-05-31 15:55:02.075000000 +0100
@@ -0,0 +1,3 @@
+#warning "You should include <sys/io.h>"
+#include <sys/io.h>
+
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ipcbuf.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ipcbuf.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ipcbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ipcbuf.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,32 @@
+/*
+ * include/asm-st200/ipcbuf.h
+ */
+
+#ifndef _ASM_ST200_IPCBUF_H
+#define _ASM_ST200_IPCBUF_H
+
+/*
+ * The ipc64_perm structure for ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		seq;
+	unsigned short		__pad1;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* _ASM_ST200_IPCBUF_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/irq.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/irq.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/irq.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,23 @@
+/*
+ * include/asm-st200/irq.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_IRQ_H
+#define _ASM_ST200_IRQ_H
+
+#define NR_IRQS 64
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	return irq;
+}
+
+extern void disable_irq(unsigned int);
+extern void disable_irq_nosync(unsigned int);
+extern void enable_irq(unsigned int);
+
+#endif /* _ASM_ST200_IRQ_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/irq_ilc.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/irq_ilc.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/irq_ilc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/irq_ilc.h	2005-05-31 15:57:07.686000000 +0100
@@ -0,0 +1,59 @@
+/*
+ * include/asm-st200/irq_ilc.h
+ *
+ * Copyright (C) 2005 STMicroelectronics Limited
+ * Author: Henry Bell <henry.bell@st.com>
+ *       : David Mckay <david.mckay@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Interrupt handling for ST40 Interrupt Level Controler (ILC).
+ */
+
+#ifndef __ASM_ST200_IRQ_ILC_H
+#define __ASM_ST200_IRQ_ILC_H
+
+/* Global pointer. I don't like this, but I can't be bothered changing 
+ * all these macros 
+ */
+extern void * ilc_base;
+
+#define _ILC_BIT(_int)		     (1 << ((_int) % 32))
+#define _ILC_REG_OFF(_int)	     (sizeof(int) * ((_int) / 32))
+
+#define ILC_BASE (ilc_base)
+
+#define ILC_INTERRUPT_REG(_int)      (ILC_BASE + 0x080 + _ILC_REG_OFF(_int))
+#define ILC_STATUS_REG(_int)         (ILC_BASE + 0x200 + _ILC_REG_OFF(_int))
+#define ILC_CLR_STATUS_REG(_int)     (ILC_BASE + 0x280 + _ILC_REG_OFF(_int))
+#define ILC_ENABLE_REG(_int)         (ILC_BASE + 0x400 + _ILC_REG_OFF(_int)) 
+#define ILC_CLR_ENABLE_REG(_int)     (ILC_BASE + 0x480 + _ILC_REG_OFF(_int)) 
+#define ILC_SET_ENABLE_REG(_int)     (ILC_BASE + 0x500 + _ILC_REG_OFF(_int))
+#define ILC_EXT_WAKEUP_EN_REG        (ILC_BASE + 0x600)
+#define ILC_EXT_WAKPOL_EN_REG        (ILC_BASE + 0x680)
+#define ILC_PRIORITY_REG(_int)       (ILC_BASE + 0x800 + (8 * (_int)))
+#define ILC_TRIGMODE_REG(_int)       (ILC_BASE + 0x804 + (8 * (_int)))
+
+
+
+/*
+ * Macros to get/set/clear ILC registers
+ */
+#define ILC_SET_ENABLE(_int)     writel(_ILC_BIT(_int), ILC_SET_ENABLE_REG(_int))
+#define ILC_CLR_ENABLE(_int)     writel(_ILC_BIT(_int), ILC_CLR_ENABLE_REG(_int))
+#define ILC_GET_ENABLE(_int)     (inl(ILC_ENABLE_REG(_int)) & _ILC_BIT(_int))
+#define ILC_CLR_STATUS(_int)     writel(_ILC_BIT(_int), ILC_CLR_STATUS_REG(_int))
+#define ILC_GET_STATUS(_int)     (inl(ILC_STATUS_REG(_int)) & _ILC_BIT(_int))
+#define ILC_SET_PRI(_int, _pri)  writel((_pri), ILC_PRIORITY_REG(_int))
+
+#define ILC_SET_TRIGMODE(_int, _mod) writel((_mod), ILC_TRIGMODE_REG(_int))
+
+#define ILC_TRIGGERMODE_HIGH	1
+#define ILC_TRIGGERMODE_LOW	2
+
+
+int __init init_ilc(unsigned long ilc_addr);
+void __init ilc_route_external(int ilc_irq,int ext_out,int invert);
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/kmap_types.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/kmap_types.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/kmap_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/kmap_types.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef _ASM_ST200_KMAP_TYPES_H
+#define _ASM_ST200_TYPES_H
+
+/*
+ * This is the "bare minimum".  AIO seems to require this.
+ */
+enum km_type {
+	KM_IRQ0,
+	KM_USER1
+};
+
+#endif /* _ASM_ST200_TYPES_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/linkage.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/linkage.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/linkage.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/linkage.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+/* Nothing to see here... */
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/mman.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/mman.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/mman.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,43 @@
+#ifndef _ASM_ST200_MMAN_H
+#define _ASM_ST200_MMAN_H
+
+#define PROT_READ	0x1		/* page can be read */
+#define PROT_WRITE	0x2		/* page can be written */
+#define PROT_EXEC	0x4		/* page can be executed */
+#define PROT_SEM	0x8		/* page may be used for atomic ops */
+#define PROT_NONE	0x0		/* page can not be accessed */
+#define PROT_GROWSDOWN  0x01000000      /* mprotect flag: extend change to start of growsdown vma */
+#define PROT_GROWSUP    0x02000000      /* mprotect flag: extend change to end of growsup vma */
+
+#define MAP_SHARED	0x01		/* Share changes */
+#define MAP_PRIVATE	0x02		/* Changes are private */
+#define MAP_TYPE	0x0f		/* Mask for type of mapping */
+#define MAP_FIXED	0x10		/* Interpret addr exactly */
+#define MAP_ANONYMOUS	0x20		/* don't use a file */
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+
+#define MS_ASYNC	1		/* sync memory asynchronously */
+#define MS_INVALIDATE	2		/* invalidate the caches */
+#define MS_SYNC		4		/* synchronous memory sync */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#define MADV_NORMAL	0x0		/* default page-in behavior */
+#define MADV_RANDOM	0x1		/* page-in minimum required */
+#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
+#define MADV_WILLNEED	0x3		/* pre-fault pages */
+#define MADV_DONTNEED	0x4		/* discard these pages */
+
+/* compatibility flags */
+#define MAP_ANON	MAP_ANONYMOUS
+#define MAP_FILE	0
+
+#endif /* _ASM_ST200_MMAN_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/mmu_context.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/mmu_context.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/mmu_context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/mmu_context.h	2005-02-10 11:57:56.000000000 +0000
@@ -0,0 +1,131 @@
+/*
+ * include/asm-st200/mmu_context.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Derived from include/asm-mips/mmu_context.h which is:
+ *	Copyright (C) 1996, 1997, 1998, 1999 by Ralf Baechle
+ *	Copyright (C) 1999 Silicon Graphics, Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+#ifndef _ASM_ST200_MMU_CONTEXT_MMU_H
+#define _ASM_ST200_MMU_CONTEXT_MMU_H
+
+#include <linux/slab.h>
+#include <asm/pgalloc.h>
+#include <asm/system.h>
+#include <asm/ctrlregdef.h>
+#include <asm/io.h>
+
+extern unsigned long asid_cache;
+extern pgd_t *current_pgd[];
+
+#define ASID_INC	0x1
+#define ASID_MASK	0xff
+
+extern inline void set_asid(unsigned long asid)
+{
+	ctrl_outl(asid & ASID_MASK, TLB_ASID);
+}
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+}
+
+/*
+ *  All unused by hardware upper bits will be considered
+ *  as a software asid extension.
+ */
+#define ASID_VERSION_MASK  ((unsigned long)~ASID_MASK)
+#define ASID_FIRST_VERSION ((unsigned long)(~ASID_VERSION_MASK) + 1)
+
+extern inline void
+get_new_mmu_context(struct mm_struct *mm, unsigned long asid)
+{
+	/* gross hack to avoid having to include tlbflush.h */
+	extern void flush_tlb_all(void);
+
+	if (! ((asid += ASID_INC) & ASID_MASK) ) {
+		flush_tlb_all(); /* start new asid cycle */
+		if (!asid)      /* fix version if needed */
+			asid = ASID_FIRST_VERSION;
+	}
+	mm->context = asid_cache = asid;
+}
+
+/*
+ * Initialize the context related info for a new mm_struct
+ * instance.
+ */
+extern inline int
+init_new_context(struct task_struct *tsk, struct mm_struct *mm)
+{
+#ifndef CONFIG_SMP
+	mm->context = 0;
+#else
+	mm->context = (unsigned long)kmalloc(smp_num_cpus * 
+				sizeof(unsigned long), GFP_KERNEL);
+	/*
+ 	 * Init the "context" values so that a tlbpid allocation 
+	 * happens on the first switch.
+ 	 */
+	if (mm->context == 0)
+		return -ENOMEM;
+	memset((void *)mm->context, 0, smp_num_cpus * sizeof(unsigned long));
+#endif
+	return 0;
+}
+
+/*
+ * Check that the specified context is part of the current cycle.
+ */
+extern inline int
+context_valid(unsigned long context)
+{
+	return !((context ^ asid_cache) & ASID_VERSION_MASK);
+}
+
+extern inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
+                             struct task_struct *tsk)
+{
+	unsigned long asid = asid_cache;
+
+	/* Check if our ASID is of an older version and thus invalid */
+	if ((next->context ^ asid) & ASID_VERSION_MASK)
+		get_new_mmu_context(next, asid);
+
+	current_pgd[smp_processor_id()] = next->pgd;
+	set_asid(next->context);
+}
+
+/*
+ * Destroy context related info for an mm_struct that is about
+ * to be put to rest.
+ */
+extern inline void destroy_context(struct mm_struct *mm)
+{
+	/* Nothing to do.  */
+}
+
+/*
+ * After we have set current->mm to a new value, this activates
+ * the context for the new mm so we see the new mappings.
+ */
+extern inline void
+activate_mm(struct mm_struct *prev, struct mm_struct *next)
+{
+	/* Unconditionally get a new ASID.  */
+	get_new_mmu_context(next, asid_cache);
+
+	current_pgd[smp_processor_id()] = next->pgd;
+	set_asid(next->context);
+}
+
+#define deactivate_mm(tsk,mm)	do { } while (0)
+
+#endif /* _ASM_ST200_MMU_CONTEXT_MMU_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/mmu.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/mmu.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/mmu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/mmu.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef __MMU_H
+#define __MMU_H
+
+#ifdef CONFIG_MMU
+/* Default "unsigned long" context */
+typedef unsigned long mm_context_t;
+#else
+struct mm_rblock_struct {
+        int     size;
+        int     refcount;
+        void    *kblock;
+};
+
+struct mm_tblock_struct {
+        struct mm_rblock_struct *rblock;
+        struct mm_tblock_struct *next;
+};
+
+typedef struct {
+        struct mm_tblock_struct tblock;
+        unsigned long           end_brk;
+} mm_context_t;
+
+#endif
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/module.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/module.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/module.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/module.h	2005-05-31 16:05:19.642000000 +0100
@@ -0,0 +1,15 @@
+#ifndef _ASM_ST200_MODULE_H
+#define _ASM_ST200_MODULE_H
+
+/* ST200 is simple */
+struct mod_arch_specific
+{
+	unsigned long stub_offset, stub_count, stub_max;
+	unsigned long init_stub_offset, init_stub_count, init_stub_max;
+};
+
+#define Elf_Shdr Elf32_Shdr
+#define Elf_Sym Elf32_Sym
+#define Elf_Ehdr Elf32_Ehdr
+
+#endif /* _ASM_ST200_MODULE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/msgbuf.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/msgbuf.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/msgbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/msgbuf.h	2005-05-31 16:07:23.904001000 +0100
@@ -0,0 +1,32 @@
+#ifndef _ASM_ST200_MSGBUF_H
+#define _ASM_ST200_MSGBUF_H
+
+/* 
+ * The msqid64_ds structure for ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 2 miscellaneous 64-bit values
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long   __unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long   __unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long   __unused3;
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* _ASM_ST200_MSGBUF_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/namei.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/namei.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/namei.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/namei.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef _ASM_ST200_NAMEI_H
+#define _ASM_ST200_NAMEI_H
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif /* _ASM_ST200_NAMEI_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/page.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/page.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/page.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/page.h	2005-05-31 16:14:04.678001000 +0100
@@ -0,0 +1,120 @@
+/*
+ *  include/asm-st200/io.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PAGE_H
+#define _ASM_ST200_PAGE_H
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	13
+#define PAGE_SIZE	(1 << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#define PAGE_SHIFT_256M		28
+#define PAGE_SIZE_256M		(1<<PAGE_SHIFT_256M)
+#define PAGE_MASK_256M		(~(PAGE_SIZE_256M-1))
+
+#define clear_page(page)	memset((void *)(page), 0, PAGE_SIZE)
+#define copy_page(to,from)	memcpy((void *)(to), (void *)(from), PAGE_SIZE)
+
+#define clear_user_page(to, vaddr, page)	\
+do {						\
+	clear_page(to);				\
+	flush_dcache_page(page);		\
+} while (0)
+#define copy_user_page(to, from, vaddr, page)	\
+do {						\
+	copy_page(to, from);			\
+	flush_dcache_page(page);		\
+} while (0)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((x).pmd)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x) ((pte_t) { (x) } )
+#define __pmd(x) ((pmd_t) { (x) } )
+#define __pgd(x) ((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+/* Start of kernel address space */
+#ifdef CONFIG_MMU
+#define __PAGE_OFFSET		(0x80000000)
+#else
+#define __PAGE_OFFSET		(0x0)
+#endif
+
+#define CONTROL_START		(0xffff0000)
+
+#define BIG_PAGE_SIZE           (256*1024*1024)
+#define _MEMORY_START		CONFIG_MEMORY_START
+#define _MEMORY_SIZE		CONFIG_MEMORY_SIZE
+
+#define _MEMORY_OFFSET          (CONFIG_MEMORY_START%BIG_PAGE_SIZE)
+#define _MEMORY_PAGES           ((CONFIG_MEMORY_START/BIG_PAGE_SIZE)*BIG_PAGE_SIZE)
+
+/*
+ * PFNs start at physical 0, while pages start at _MEMORY_START
+ */
+#define PFN_OFFSET		(_MEMORY_START >> PAGE_SHIFT)
+
+
+extern unsigned long last_user_utlb_entry;
+#define UTLB_USER_START		0
+#define UTLB_USER_LAST		last_user_utlb_entry
+#define UTLB_USER_ENTRIES	(UTLB_USER_LAST - UTLB_USER_START + 1)
+#define UTLB_KERNEL_ENTRY	(UTLB_USER_LAST + 1)
+
+/* Pure 2^n version of get_order */
+static __inline__ int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size-1) >> (PAGE_SHIFT-1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+	return order;
+}
+
+
+#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
+
+#define __pa(x)                 (((unsigned long)(x)-PAGE_OFFSET)+_MEMORY_PAGES)
+#define __va(x)                 ((void *)(((unsigned long)(x)-_MEMORY_PAGES)+ PAGE_OFFSET)
+		
+#define pfn_to_page(pfn)	(mem_map + ((pfn) - PFN_OFFSET))
+#define page_to_pfn(page)	((unsigned long)((page)-mem_map) + PFN_OFFSET)
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_valid(pfn)		(((pfn) - PFN_OFFSET) < max_mapnr)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+/*
+ * Default vma flags for stack and anonymous pages
+ * Note we do not have execute permission.
+ */
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+/* Is this physical address RAM or not? */
+int phys_is_ram(unsigned long physaddr);
+
+#endif /* _ASM_ST200_PAGE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/param.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/param.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/param.h	2005-02-10 10:05:44.000000000 +0000
@@ -0,0 +1,24 @@
+/*
+ * include/asm-st200/param.h
+ */
+
+#ifndef _ASM_ST200_PARAM_H
+#define _ASM_ST200_PARAM_H
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	8192
+
+#ifndef NGROUPS
+#define NGROUPS		32
+#endif
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _ASM_ST200_PARAM_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/pci.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/pci.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/pci.h	2005-06-01 10:39:07.267000000 +0100
@@ -0,0 +1,18 @@
+#ifndef _ASM_ST200_PCI_H
+#define _ASM_ST200_PCI_H
+
+#include <linux/mm.h>
+#include <asm/scatterlist.h>
+
+#define pcibios_assign_all_busses()     1
+
+#define PCIBIOS_MIN_IO          0x1000
+#define PCIBIOS_MIN_MEM         0x80000000
+
+/* The PCI address space does equal the physical memory
+ * address space.  The networking and block device layers use
+ * this boolean for bounce buffer decisions.
+ */
+#define PCI_DMA_BUS_IS_PHYS     (1)
+
+#endif /* _ASM_ST200_PCI_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/pgalloc.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/pgalloc.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/pgalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/pgalloc.h	2005-02-10 12:04:18.000000000 +0000
@@ -0,0 +1,88 @@
+#ifndef _ASM_ST200_PGALLOC_H
+#define _ASM_ST200_PGALLOC_H
+
+#include <linux/mm.h>
+
+/*      
+ * Allocate and free page tables. The xxx_kernel() versions are
+ * used to allocate a kernel page table.
+ */
+
+static inline void
+pmd_populate(struct mm_struct *mm, pmd_t *pmd, struct page *page)
+{
+	set_pmd(pmd, __pmd((unsigned long) __va(page_to_pfn(page) << PAGE_SHIFT)));
+}
+
+static inline void
+pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmd, pte_t *pte)
+{
+	set_pmd(pmd, __pmd((unsigned long)pte));
+}
+
+static inline void
+pgd_populate(struct mm_struct *mm, pgd_t *pgd, pmd_t *pmd)
+{
+	BUG();
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	unsigned int pgd_size = (PTRS_PER_PGD * sizeof(pgd_t));
+	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL);
+
+	if (pgd) {
+		memset(pgd, 0, USER_PTRS_PER_PGD * sizeof(pgd_t));
+		memcpy(pgd + USER_PTRS_PER_PGD,
+		       swapper_pg_dir + USER_PTRS_PER_PGD,
+		       (PTRS_PER_PGD - USER_PTRS_PER_PGD) * sizeof(pgd_t));
+	}
+
+	return pgd;
+}
+
+static inline void
+pgd_free(pgd_t *pgd)
+{
+	free_page((unsigned long)pgd);
+}
+
+#define __pmd_free_tlb(tlb,x) do { } while (0)
+
+static inline pmd_t *
+pmd_alloc_one(struct mm_struct *mm, unsigned long address)
+{
+	BUG();
+	return (pmd_t *)1;
+}
+
+static inline void
+pmd_free(pmd_t *pmd)
+{
+}
+
+extern pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long addr);
+
+static inline void
+pte_free_kernel(pte_t *pte)
+{
+	free_page((unsigned long)pte);
+}
+
+static inline struct page *
+pte_alloc_one(struct mm_struct *mm, unsigned long addr)
+{
+	return virt_to_page(pte_alloc_one_kernel(mm, addr));
+}
+
+static inline void
+pte_free(struct page *page)
+{
+	__free_page(page);
+}
+
+#define __pte_free_tlb(tlb,pte) tlb_remove_page((tlb),(pte))
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif /* _ASM_ST200_PGALLOC_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/pgtable.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/pgtable.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/pgtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/pgtable.h	2005-06-01 10:49:10.624001000 +0100
@@ -0,0 +1,388 @@
+/*
+ * include/asm-st200/pgtable-mmu.h
+ *
+ * Copyright (C) 2002-3 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PGTABLE_H
+#define _ASM_ST200_PGTABLE_H
+
+#include <linux/config.h>
+#include <asm/page.h>
+
+/*
+ * The Linux memory management assumes a three-level page table setup. On
+ * the ST200, we use that, but "fold" the mid level into the top-level page
+ * table.
+ *
+ * Given a virtual address:
+ * - the lowest PAGE_SHIFT bits determine offset into the page
+ * - the next higher PAGE_SHIFT-2 bits determine the pte# in the pagetable
+ *   directory (the -2 is from the 4 byte ptes, and each page table is a
+ *   single page long).
+ * - the remaining bits determine pgd#.
+ *
+ * Pictorially (assuming an 8K page):
+ *
+ *        pgd#                  pte#                page offset
+ * +----------------+----------------------+--------------------------+
+ * |31            24|23                  13|12                       0|
+ * +----------------+----------------------+--------------------------+
+ */
+
+/* PMD_SHIFT determines the size of the area a second-level page table can map */
+#define PMD_SHIFT       (PAGE_SHIFT + (PAGE_SHIFT-2))
+#define PMD_SIZE        (1UL << PMD_SHIFT)
+#define PMD_MASK        (~(PMD_SIZE-1))
+
+/* PGDIR_SHIFT determines what a third-level page table entry can map */
+#define PGDIR_SHIFT	PMD_SHIFT
+#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE-1))
+
+/* Entries per page directory level: we use two-level, so
+ * we don't really have any PMD directory physically.
+ */
+#define PTRS_PER_PTE    (PAGE_SIZE >> 2)
+#define PTRS_PER_PMD    1
+#define PTRS_PER_PGD    (1<<(32 - PGDIR_SHIFT))
+
+#define USER_PTRS_PER_PGD       (TASK_SIZE/PGDIR_SIZE)
+#define FIRST_USER_PGD_NR       0
+
+#ifdef UNKNOWN
+#define USER_PGD_PTRS (PAGE_OFFSET >> PGDIR_SHIFT)
+#define KERNEL_PGD_PTRS (PTRS_PER_PGD-USER_PGD_PTRS)
+#endif
+
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
+#define pmd_ERROR(e) \
+	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
+
+/*
+ * Align vmalloc and boot time mappings on a 16M boundary, to try and make
+ * best use of pte directories.
+ * We also leave a gap between physical memory, vmalloc, boot mappings
+ * and control registers to try and catch any out-of-bounds memory accesses.
+ * The allocation routines leave a page sized hole between each allocated
+ * area for the same reason. ;)
+ */
+#define VMALLOC_OFFSET	(16*1024*1024)
+#define VMALLOC_START	(0xc0000000                         & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_END	((CONTROL_START-(5*VMALLOC_OFFSET)) & ~(VMALLOC_OFFSET-1))
+#define IOBASE_START	((CONTROL_START-(4*VMALLOC_OFFSET)) & ~(VMALLOC_OFFSET-1))
+#define IOBASE_END	((CONTROL_START-(3*VMALLOC_OFFSET)) & ~(VMALLOC_OFFSET-1))
+#define GATE_START	((CONTROL_START-(2*VMALLOC_OFFSET)) & ~(VMALLOC_OFFSET-1))
+#define GATE_END	((CONTROL_START-   VMALLOC_OFFSET)  & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+
+/* TLB_ENTRY2 */
+#define _PAGE_PADDR_MASK	0x0007ffff
+
+/* TLB_ENTRY0 */
+#define _PAGE_BIT_SHARED	19
+
+#define _PAGE_SHARED		(1 << _PAGE_BIT_SHARED)
+
+/* Software flags */
+#define _PAGE_BIT_ACCESSED	20
+#define _PAGE_BIT_SOFT_USER_X	21
+
+#define _PAGE_ACCESSED		(1 << _PAGE_BIT_ACCESSED)
+#define _PAGE_SOFT_USER_X	(1 << _PAGE_BIT_SOFT_USER_X)
+
+/* TLB_ENTRY0 */
+#define _PAGE_BIT_PROT_USER_X	23
+#define _PAGE_BIT_PROT_USER_R	24
+#define _PAGE_BIT_PROT_USER_W	25
+#define _PAGE_BIT_DIRTY		26
+#define _PAGE_BIT_POLICY0	27
+#define _PAGE_BIT_POLICY1	28
+#define _PAGE_BIT_UNUSED	29	/* when pte_present */
+#define _PAGE_BIT_FILE		29	/* when !pte_present */
+#define _PAGE_BIT_SIZE0		30
+#define _PAGE_BIT_SIZE1		31
+
+#define _PAGE_PROT_USER_X	(1 << _PAGE_BIT_PROT_USER_X)
+#define _PAGE_PROT_USER_R	(1 << _PAGE_BIT_PROT_USER_R)
+#define _PAGE_PROT_USER_W	(1 << _PAGE_BIT_PROT_USER_W)
+#define _PAGE_DIRTY		(1 << _PAGE_BIT_DIRTY)
+#define _PAGE_POLICY_NC		(0 << _PAGE_BIT_POLICY0)
+#define _PAGE_POLICY_C		(1 << _PAGE_BIT_POLICY0)
+#define _PAGE_POLICY_NCWC	(2 << _PAGE_BIT_POLICY0)
+#define _PAGE_POLICY_MASK	(3 << _PAGE_BIT_POLICY0)
+#define _PAGE_FILE		(1 << _PAGE_BIT_FILE)
+#define _PAGE_SIZE_DISABLED	(0 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_8K		(1 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_4M		(2 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_256M		(3 << _PAGE_BIT_SIZE0)
+#define _PAGE_SIZE_MASK		(3 << _PAGE_BIT_SIZE0)
+
+/* Masks and shifts to convert pte's to TLB entries */
+#define _PAGE_TLB_ENTRY2_MASK		_PAGE_PADDR_MASK
+#define _PAGE_TLB_ENTRY0_0_MASK		0x1F880000
+#define _PAGE_TLB_ENTRY0_0_SHIFT	11
+#define _PAGE_TLB_ENTRY0_1_MASK		0xc0000000
+#define _PAGE_TLB_ENTRY0_1_SHIFT	10
+
+/* Extra bits which need to be ORed into TLB_ENTRY0 */
+#define TLB_ENTRY0_EXTRABITS	TLB_ENTRY0_PROT_SUPER_RWX
+
+/* Bits which are not modified when changing a pte's permissions */
+#define _PAGE_CHG_MASK	(_PAGE_PADDR_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)
+
+/* Bits which are set for a 'normal' page */
+#define _PAGE_NORMAL		(_PAGE_SIZE_8K | _PAGE_ACCESSED | _PAGE_POLICY_C)
+#define _PAGE_NORMAL_NC		((_PAGE_NORMAL & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NC)
+#define _PAGE_NORMAL_NCWC	((_PAGE_NORMAL & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NCWC)
+
+#ifndef __ASSEMBLY__
+
+/*
+ * All the normal masks have the "page accessed" bits on, as any time
+ * they are used, the page is accessed. They are cleared only by the
+ * page-out routines.
+ *
+ * PAGE_COPY is used for the stack, so usually has the execute bit set.
+ * However we are trying to avoid this, so don't for now, and see
+ * what breaks.
+ *
+ * Note we use _PAGE_SIZE_DISABLED to mark pages which are not present,
+ * so we set _PAGE_SIZE_8K even for PAGE_NONE.
+ */
+#define PAGE_NONE	__pgprot(_PAGE_NORMAL)
+#define PAGE_SHARED	__pgprot(_PAGE_NORMAL | _PAGE_PROT_USER_R | _PAGE_PROT_USER_W)
+#define PAGE_COPY	__pgprot(_PAGE_NORMAL | _PAGE_PROT_USER_R)
+#define PAGE_READONLY	__pgprot(_PAGE_NORMAL | _PAGE_PROT_USER_R)
+#define PAGE_KERNEL	__pgprot(_PAGE_NORMAL | _PAGE_SHARED | _PAGE_DIRTY)
+#define PAGE_KERNEL_NC	__pgprot(_PAGE_NORMAL_NC | _PAGE_SHARED | _PAGE_DIRTY)
+#define PAGE_KERNEL_NCWC	__pgprot(_PAGE_NORMAL_NCWC | _PAGE_SHARED | _PAGE_DIRTY)
+#define PAGE_GATE	__pgprot(_PAGE_NORMAL | _PAGE_SHARED | \
+					_PAGE_PROT_USER_R | _PAGE_PROT_USER_X)
+
+#define _PAGE_P(x) __pgprot(_PAGE_NORMAL | ((x) & (~_PAGE_PROT_USER_W)))
+#define _PAGE_S(x) __pgprot(_PAGE_NORMAL | (x))
+
+	/* xwr */
+#define __P000	_PAGE_P(0)
+#define __P001	_PAGE_P(_PAGE_PROT_USER_R)
+#define __P010	_PAGE_P(_PAGE_PROT_USER_W)
+#define __P011	_PAGE_P(_PAGE_PROT_USER_W | _PAGE_PROT_USER_R)
+#define __P100	_PAGE_P(_PAGE_SOFT_USER_X)
+#define __P101	_PAGE_P(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_R)
+#define __P110	_PAGE_P(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_W)
+#define __P111	_PAGE_P(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_W | _PAGE_PROT_USER_R)
+
+#define __S000	_PAGE_S(0)
+#define __S001	_PAGE_S(_PAGE_PROT_USER_R)
+#define __S010	_PAGE_S(_PAGE_PROT_USER_W)
+#define __S011	_PAGE_S(_PAGE_PROT_USER_W | _PAGE_PROT_USER_R)
+#define __S100	_PAGE_S(_PAGE_SOFT_USER_X)
+#define __S101	_PAGE_S(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_R)
+#define __S110	_PAGE_S(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_W)
+#define __S111	_PAGE_S(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_W | _PAGE_PROT_USER_R)
+
+/*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ *
+ * pmds are folded into pgds so set_pmd doesnt get actually called,
+ * but the define is needed for a generic inline function.
+ */
+void set_pte(pte_t *ptep, pte_t pte);
+#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
+#define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+
+static inline unsigned long pte_pfn(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_PADDR_MASK;
+}
+static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
+{
+	return __pte(pfn | pgprot_val(prot));
+}
+static inline unsigned long pmd_pfn(pmd_t pmd)
+{
+	return __pa(pmd_val(pmd)) >> PAGE_SHIFT;
+}
+
+/* returns the "struct page *" corresponding to the pte/pmd */
+#define pte_page(pte)		pfn_to_page(pte_pfn(pte))
+#define pmd_page(pmd)		pfn_to_page(pmd_pfn(pmd))
+
+#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
+
+/*
+ * Remember pte_none() and pte_present() must work without checking
+ * the other first. We use _PAGE_SIZE_DISABLED to mark pages not
+ * present (and keep these bits free in swp_entry_t). pte_none will
+ * always fail for present pages (because the _PAGE_SIZE bits will be
+ * set), and for not present pages, because the offset cannot be zero.
+ */
+extern inline int pte_none(pte_t pte)		{ return !pte_val(pte); }
+extern inline int pte_present(pte_t pte)	{ return (pte_val(pte) & _PAGE_SIZE_MASK) != _PAGE_SIZE_DISABLED; }
+extern inline void pte_clear(pte_t *ptep)	{ set_pte(ptep, __pte(0)); }
+
+extern inline int pmd_none(pmd_t pmd)		{ return !pmd_val(pmd); }
+extern void * high_memory;
+extern inline int pmd_bad(pmd_t pmd)		{ return (pmd_val(pmd) > (unsigned long)high_memory) ||
+							 (pmd_val(pmd) < (PAGE_OFFSET + _MEMORY_OFFSET)); }
+extern inline int pmd_present(pmd_t pmd)	{ return pmd_val(pmd); }
+extern inline void pmd_clear(pmd_t * pmdp)	{ set_pmd(pmdp, __pmd(0)); }
+
+/*
+ * The "pgd_xxx()" functions here are trivial for a folded two-level
+ * setup: the pgd is never bad, and a pmd always exists (as it's folded
+ * into the pgd entry)
+ */
+extern inline int pgd_none(pgd_t pgd)		{ return 0; }
+extern inline int pgd_bad(pgd_t pgd)		{ return 0; }
+extern inline int pgd_present(pgd_t pgd)	{ return 1; }
+extern inline void pgd_clear(pgd_t * pgdp)	{ }
+
+#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))
+
+/*
+ * The following only work if pte_present() is true.
+ * Undefined behaviour if not..
+ */
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_PROT_USER_R; }
+static inline int pte_exec(pte_t pte)		{ return pte_val(pte) & _PAGE_SOFT_USER_X; }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_PROT_USER_W; }
+
+static inline pte_t pte_rdprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_PROT_USER_R; return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ pte_val(pte) &= ~(_PAGE_SOFT_USER_X | _PAGE_PROT_USER_X); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ pte_val(pte) &= ~_PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ pte_val(pte) &= ~_PAGE_ACCESSED; return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ pte_val(pte) &= ~_PAGE_PROT_USER_W; return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ pte_val(pte) |= _PAGE_PROT_USER_R; return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ pte_val(pte) |= _PAGE_SOFT_USER_X; return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ pte_val(pte) |= _PAGE_DIRTY; return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ pte_val(pte) |= _PAGE_ACCESSED; return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ pte_val(pte) |= _PAGE_PROT_USER_W; return pte; }
+
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	return __pte((pte_val(pte) & _PAGE_CHG_MASK) | pgprot_val(newprot));
+}
+
+/* to find an entry in a page-table-directory. */
+#define pgd_index(address) (( address >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pgd_offset(mm, address) ((mm)->pgd+pgd_index(address))
+
+/* to find an entry in a kernel page-table-directory */
+#define pgd_offset_k(address) pgd_offset(&init_mm, address)
+
+/* Find an entry in the second-level page table.. */
+/* Trivial for the folded page table */
+extern inline pmd_t * pmd_offset(pgd_t * dir, unsigned long address)
+{
+	return (pmd_t *) dir;
+}
+
+/* Find an entry in the third-level page table.. */
+extern inline pte_t * pte_offset_kernel(pmd_t *pmdp, unsigned long address)
+{
+	return (pte_t *)pmd_val(*pmdp) +
+		((address >> PAGE_SHIFT) & (PTRS_PER_PTE - 1));
+}
+
+#define pte_offset_map		pte_offset_kernel
+#define pte_offset_map_nested	pte_offset_kernel
+#define pte_unmap(pte)		do { } while (0)
+#define pte_unmap_nested(pte)	do { } while (0)
+
+typedef pte_t *pte_addr_t;
+
+extern void update_mmu_cache(struct vm_area_struct * vma,
+			     unsigned long address, pte_t pte);
+
+
+/* Handling of pte entries which represent not_present() pages. */
+/* We use _PAGE_SIZE_DISABLED (which is fortunatly zero) to flag pages
+ * which are not present, so:
+ *  bits 31-30	present flag (0)
+ *  bit     29  file
+ *  bits 28- 8	offset
+ *  bits  7- 0	type
+ */
+
+/* Encode and de-code a swap entry */
+#define __swp_type(x)			((x).val & 0xff)
+#define __swp_offset(x)			(((x).val & 0x1fffffff) >> 8) 
+#define __swp_entry(type, offset)	((swp_entry_t) { ((type) | ((offset) << 8)) & 0x1fffffff })
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
+
+/* File offset in PTE support. */
+#define pte_file(pte)		(pte_val(pte) & _PAGE_FILE)
+#define pte_to_pgoff(pte)	(pte_val(pte) & 0x1fffffff)
+#define pgoff_to_pte(off)	(__pte((off) | _PAGE_FILE))
+#define PTE_FILE_MAX_BITS	(29UL) /* We reserve 3 bits in total */
+
+#endif /* !__ASSEMBLY__ */
+
+#ifndef __ASSEMBLY__
+
+extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
+extern void paging_init(void);
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE/sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+#endif /* !__ASSEMBLY__ */
+
+#ifndef CONFIG_DISCONTIGMEM
+/*
+ * kern_addr_valid(ADDR) tests if ADDR is pointing to valid kernel
+ * memory.  For the return value to be meaningful, ADDR must be >=
+ * PAGE_OFFSET.  This operation can be relatively expensive (e.g.,
+ * require a hash-, or multi-level tree-lookup or something of that
+ * sort) but it guarantees to return TRUE only if accessing the page
+ * at that address does not cause an error.  Note that there may be
+ * addresses for which kern_addr_valid() returns FALSE even though an
+ * access would not cause an error (e.g., this is typically true for
+ * memory mapped I/O regions.
+ *
+ * XXX Need to implement this for ST200.
+ */
+#define kern_addr_valid(addr)	(1)
+#endif /* !CONFIG_DISCONTIGMEM */
+
+#ifndef __ASSEMBLY__
+
+/*
+ * remap a physical address `phys' of size `size' with page protection `prot'
+ * into virtual address `from'
+ */
+#define io_remap_page_range(vma,from,phys,size,prot) \
+		remap_pfn_range(vma, from, (phys) >> PAGE_SHIFT, size, prot)
+
+/*
+ * Change the page cache policy.
+ */
+#define pgprot_noncached(prot)		\
+	__pgprot((pgprot_val(prot) & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NC)
+#define pgprot_writecombine(prot)	\
+	__pgprot((pgprot_val(prot) & ~_PAGE_POLICY_MASK) | _PAGE_POLICY_NCWC)
+
+/*
+ * No page table caches to initialise
+ */
+#define pgtable_cache_init() do { } while (0)
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_ST200_PGTABLE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/poll.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/poll.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/poll.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/poll.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,23 @@
+#ifndef __ASM_ST200_POLL_H
+#define __ASM_ST200_POLL_H
+
+#define POLLIN		(1 << 0)
+#define POLLPRI		(1 << 1)
+#define POLLOUT		(1 << 2)
+#define POLLERR		(1 << 3)
+#define POLLHUP		(1 << 4)
+#define POLLNVAL	(1 << 5)
+#define POLLRDNORM	(1 << 6)
+#define POLLRDBAND	(1 << 7)
+#define POLLWRNORM	(1 << 8)
+#define POLLWRBAND	(1 << 9)
+#define POLLMSG		(1 << 10)
+#define POLLREMOVE	(1 << 11)
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+#endif /* _ASM_ST200_POLL_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/posix_types.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/posix_types.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/posix_types.h	2005-02-10 10:09:08.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+ * include/asm-st200/posix_types.h
+ */
+
+#ifndef _ASM_ST200_POSIX_TYPES_H
+#define _ASM_ST200_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+typedef unsigned int	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned int	__kernel_ipc_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short  __kernel_old_dev_t;
+
+typedef long long	__kernel_loff_t;
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+#endif /* _ASM_ST200_POSIX_TYPES_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/processor.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/processor.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/processor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/processor.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,152 @@
+/*
+ * include/asm-st200/processor.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PROCESSOR_H
+#define _ASM_ST200_PROCESSOR_H
+
+#include <asm/ptrace.h>
+#include <asm/page.h>
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l;})
+
+#ifdef UNKNOWN
+struct cpuinfo_st200 {
+
+};
+
+/*
+ * capabilities of CPUs
+ */
+
+extern struct cpuinfo_st200 boot_cpu_data;
+#endif
+
+#ifdef CONFIG_SMP
+extern struct cpuinfo_st200 cpu_data[];
+#define current_cpu_data cpu_data[smp_processor_id()]
+#else
+#define cpu_data (&boot_cpu_data)
+#define current_cpu_data boot_cpu_data
+#endif
+
+#if defined(CONFIG_EISA) || defined(CONFIG_MCA)
+#error Bus handling need updating
+#endif
+#define EISA_bus (0)
+#define EISA_bus__is_a_macro /* for versions in ksyms.c */
+#define MCA_bus  (0)
+#define MCA_bus__is_a_macro /* for versions in ksyms.c */
+
+
+#ifdef CONFIG_MMU
+/*
+ * User space process size.
+ */
+
+#define TASK_SIZE	        (PAGE_OFFSET)
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))
+#else
+#define TASK_SIZE               0xffff0000UL
+#define TASK_UNMAPPED_BASE	0
+#endif
+
+
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
+/* Flags for struct thread_struct flags field */
+#define ST200_THREAD_DEBUG_VALID	(1<<0)
+#define ST200_THREAD_TRACE_VALID	(1<<1)
+
+/* Offsets into this struct are used in __switchto */
+struct thread_struct {
+	unsigned long sp;
+	unsigned long pc;
+
+	unsigned long flags;
+
+	/* Debug registers */
+	struct {
+		unsigned long dbreak_control;
+		unsigned long dbreak_lower;
+		unsigned long dbreak_upper;
+		unsigned long ibreak_control;
+		unsigned long ibreak_lower;
+		unsigned long ibreak_upper;
+	} debug;
+
+	/* Trace registers */
+	struct {
+		unsigned long trace;
+	} trace;
+};
+
+
+#define KSTK_EIP(tsk)  ((tsk)->thread.pc)
+#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
+
+#define INIT_THREAD  { .flags = 0 }
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+struct mm_struct;
+
+/* Do necessary setup to start up a newly executed thread.  */
+extern void start_thread(struct pt_regs *, unsigned long, unsigned long);
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+/* Prepare to copy thread state - unlazy all lazy status */
+#define prepare_to_copy(tsk)	do { } while (0)
+
+/* create a kernel thread without removing it from tasklists */
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/* Return saved PC of a blocked thread.  */
+/* This is probably not 100% correct */
+
+static inline unsigned long thread_saved_pc(struct thread_struct *t)
+{
+        return t->pc;
+}
+
+
+unsigned long get_wchan(struct task_struct *p);
+
+#define cpu_relax()	barrier()
+
+#ifdef UNKNOWN
+
+#define ARCH_HAS_PREFETCH
+#define ARCH_HAS_PREFETCHW
+#define ARCH_HAS_SPINLOCK_PREFETCH
+
+extern inline void prefetch(const void *x)
+{
+	 __asm__ __volatile__ ("prefetch (%0)" : : "r"(x));
+}
+
+extern inline void prefetchw(const void *x)
+{
+	 __asm__ __volatile__ ("prefetchw (%0)" : : "r"(x));
+}
+
+#define spin_lock_prefetch(x)	prefetchw(x)
+
+#endif
+
+#endif /* _ASM_ST200_PROCESSOR_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ptrace.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ptrace.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ptrace.h	2005-05-31 16:19:19.405000000 +0100
@@ -0,0 +1,133 @@
+/*
+ * include/asm-st200/ptrace.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_PTRACE_H
+#define _ASM_ST200_PTRACE_H
+
+/*
+ * This struct defines the way the registers are stored on the
+ * kernel stack during a system call or other kernel entry
+ *
+ * To improve performance, this only contains the scratch registers,
+ * including the system call parameters (in case we need to restart
+ * the system call), and a few other fundamental registers.
+ *
+ * All preserved registers will be naturally preserved or saved in
+ * switch_stack.
+ *
+ * Note that in the case of a system call, only the argument registers
+ * may be present.
+ *
+ * A few system calls (notably fork and friends) and signal handling
+ * require the full register state. This is handled in special stubs,
+ * which push a struct switch_stack immediatly below the struct pt_regs.
+ *
+ * To keep stack alignment simple, both structs should be multiples of 32
+ * bytes.
+ */
+
+struct pt_regs {
+	unsigned long psw;
+        unsigned long pc;
+	unsigned long br;
+	unsigned long lr;	/* Link */
+
+	unsigned long r8;	/* scratch */
+	unsigned long r9;	/* scratch */
+	unsigned long r10;	/* scratch */
+	unsigned long r11;	/* scratch */
+	unsigned long r12;	/* SP */
+	unsigned long r15;	/* scratch/syscall no */
+	unsigned long r16;	/* arg0 */
+	unsigned long r17;	/* arg1 */
+	unsigned long r18;	/* arg2 */
+	unsigned long r19;	/* arg3 */
+	unsigned long r20;	/* arg4 */
+	unsigned long r21;	/* arg5 */
+	unsigned long r22;	/* arg6 */
+	unsigned long r23;	/* arg7 */
+	unsigned long r24;	/* scratch */
+	unsigned long r25;	/* scratch */
+	unsigned long r26;	/* scratch */
+	unsigned long r27;	/* scratch */
+	unsigned long r28;	/* scratch */
+	unsigned long r29;	/* scratch */
+	unsigned long r30;	/* scratch */
+	unsigned long r31;	/* scratch */
+	unsigned long r32;	/* scratch */
+	unsigned long r33;	/* scratch */
+	unsigned long r34;	/* scratch */
+	unsigned long r35;	/* scratch */
+	unsigned long r36;	/* scratch */
+	unsigned long r37;	/* scratch */
+	unsigned long r38;	/* scratch */
+	unsigned long r39;	/* scratch */
+	unsigned long r40;	/* scratch */
+	unsigned long r41;	/* scratch */
+	unsigned long r42;	/* scratch */
+	unsigned long r43;	/* scratch */
+	unsigned long r44;	/* scratch */
+	unsigned long r45;	/* scratch */
+	unsigned long r46;	/* scratch */
+	unsigned long r47;	/* scratch */
+	unsigned long r48;	/* scratch */
+	unsigned long r49;	/* scratch */
+	unsigned long r50;	/* scratch */
+	unsigned long r51;	/* scratch */
+	unsigned long r52;	/* scratch */
+	unsigned long r53;	/* scratch */
+	unsigned long r54;	/* scratch */
+	unsigned long r55;	/* scratch */
+	unsigned long r56;	/* scratch */
+	unsigned long r57;	/* scratch */
+	unsigned long r58;	/* scratch */
+	unsigned long r59;	/* scratch */
+	unsigned long r60;	/* scratch */
+	unsigned long r61;	/* scratch */
+	unsigned long r62;	/* scratch */
+	unsigned long pad[1];   /* Align to 8 bytes*/
+};
+
+/*
+ * This is the extended stack used by signal handlers and the context
+ * switcher: it's pushed after the normal "struct pt_regs".
+ */
+struct switch_stack {
+	unsigned long r1;
+	unsigned long r2;
+	unsigned long r3;
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	unsigned long r7;
+        unsigned long r13;	/* Reserved for TLS (thread local storage) */
+	unsigned long r14;	/* GOT pointer */
+	unsigned long pad[1];   /* To align to 8 byte boundary */
+};
+
+#define _PSW_USER 1
+#define user_mode(regs) ((regs)->psw & _PSW_USER)
+#define instruction_pointer(regs) ((regs)->pc)
+#define profile_pc(regs) instruction_pointer(regs)
+
+#define force_successful_syscall_return() (st200_task_regs(current_thread_info())->r15 = 0)
+
+/* Dump register state. Pass NULL if ss not available */
+void st200_show_regs(struct pt_regs* regs, struct switch_stack *ss);
+
+/* Register numbers in the ptrace system call interface */
+
+#define PT_PC		0
+#define PT_R0		1
+#define PT_R(x)		((x)+PT_R0)
+#define PT_B(x)		((x)+65)
+#define PT_PSW		73
+#define PT_DEBUG(x)	((x)+74)
+#define PT_TRACE	80
+
+#endif /* _ASM_ST200_PTRACE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/scatterlist.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/scatterlist.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/scatterlist.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/scatterlist.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,25 @@
+#ifndef _ASM_ST200_SCATTERLIST_H
+#define _ASM_ST200_SCATTERLIST_H
+
+#include <asm/types.h>
+
+struct scatterlist {
+	struct page	*page;		/* buffer page			 */
+	unsigned int	offset;		/* buffer offset		 */
+	dma_addr_t	dma_address;	/* dma address			 */
+	unsigned int	length;		/* length			 */
+};
+
+/*
+ * These macros should be used after a pci_map_sg call has been done
+ * to get bus addresses of each of the SG entries and their lengths.
+ * You should only work with the number of sg entries pci_map_sg
+ * returns, or alternatively stop on the first sg_dma_len(sg) which
+ * is 0.
+ */
+#define sg_dma_address(sg)      ((sg)->dma_address)
+#define sg_dma_len(sg)          ((sg)->length)
+
+#define ISA_DMA_THRESHOLD (0xffffffff)
+
+#endif /* _ASM_ST200_SCATTERLIST_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/scu.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/scu.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/scu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/scu.h	2005-05-31 16:23:35.739001000 +0100
@@ -0,0 +1,29 @@
+#ifndef _ASM_ST200_SCU__H
+#define _ASM_ST200_SCU_H_
+
+ /*
+ * These routines manage allocation of slots in the SCU. Although speculative loads
+ * are not supported in either user or kernel mode, we still support prefetching. For
+ * the prefetch to complete you must have an SCU region allocated, otherwise it will do
+ * nothing. For this reason, these routines are still used.
+ * We do not have all the dreadful problems with prefetch that we had with speculation,
+ * because prefetch is a no-op if it misses the TLB, and of course it is only a performance
+ * issue rather than a correctness one. We could disable all the SCU regions and the program
+ * would still function correctly.
+ */
+ 
+
+/* Request a physical address range for valid speculation. start and  size
+ * must be page aligned and a multiple of page size. If the region requested 
+ * is wholly contained in another existing region, then the reference count 
+ * for that region is incremented.
+ * 
+ *  Returns 0 on success, - on failure
+ */
+int request_scu_region(unsigned long region_start,unsigned region_size);
+
+/* Release a region from the scu */
+void release_scu_region(unsigned long region_start,unsigned region_size);
+
+
+#endif /* _ASM_ST200_SCU_H_ */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/segment.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/segment.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/segment.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/segment.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _ASM_ST200_SEGMENT_H
+#define _ASM_ST200_SEGMENT_H
+
+/* Only here because we have some old header files that expect it.. */
+
+#endif /* _ASM_ST200_SEGMENT_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/semaphore.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/semaphore.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/semaphore.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,127 @@
+/*
+ * include/asm-st200/io.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Copied from include/asm-ia64/semaphore.h which was:
+ *	Copyright (C) 1998-2000 Hewlett-Packard Co
+ *	Copyright (C) 1998-2000 David Mosberger-Tang <davidm@hpl.hp.com>
+ */
+
+
+#ifndef _ASM_ST200_SEMAPHORE_H
+#define _ASM_ST200_SEMAPHORE_H
+
+#include <linux/wait.h>
+#include <linux/rwsem.h>
+
+#include <asm/atomic.h>
+
+struct semaphore {
+	atomic_t count;
+	int sleepers;
+	wait_queue_head_t wait;
+#if WAITQUEUE_DEBUG
+	long __magic;		/* initialized by __SEM_DEBUG_INIT() */
+#endif
+};
+
+#if WAITQUEUE_DEBUG
+# define __SEM_DEBUG_INIT(name)		, (long) &(name).__magic
+#else
+# define __SEM_DEBUG_INIT(name)
+#endif
+
+#define __SEMAPHORE_INITIALIZER(name,count)					\
+{										\
+	ATOMIC_INIT(count), 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)	\
+	__SEM_DEBUG_INIT(name)							\
+}
+
+#define __MUTEX_INITIALIZER(name)	__SEMAPHORE_INITIALIZER(name,1)
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count)					\
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name, count)
+
+#define DECLARE_MUTEX(name)		__DECLARE_SEMAPHORE_GENERIC(name, 1)
+#define DECLARE_MUTEX_LOCKED(name)	__DECLARE_SEMAPHORE_GENERIC(name, 0)
+
+static inline void
+sema_init (struct semaphore *sem, int val)
+{
+	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
+}
+
+static inline void
+init_MUTEX (struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void
+init_MUTEX_LOCKED (struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+extern void __down (struct semaphore * sem);
+extern int  __down_interruptible (struct semaphore * sem);
+extern int  __down_trylock (struct semaphore * sem);
+extern void __up (struct semaphore * sem);
+
+/*
+ * Atomically decrement the semaphore's count.  If it goes negative,
+ * block the calling thread in the TASK_UNINTERRUPTIBLE state.
+ */
+static inline void
+down (struct semaphore *sem)
+{
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	if (atomic_dec_return(&sem->count) < 0)
+		__down(sem);
+}
+
+/*
+ * Atomically decrement the semaphore's count.  If it goes negative,
+ * block the calling thread in the TASK_INTERRUPTIBLE state.
+ */
+static inline int
+down_interruptible (struct semaphore * sem)
+{
+	int ret = 0;
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	if (atomic_dec_return(&sem->count) < 0)
+		ret = __down_interruptible(sem);
+	return ret;
+}
+
+static inline int
+down_trylock (struct semaphore *sem)
+{
+	int ret = 0;
+
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	if (atomic_dec_return(&sem->count) < 0)
+		ret = __down_trylock(sem);
+	return ret;
+}
+
+static inline void
+up (struct semaphore * sem)
+{
+#if WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+	if (atomic_inc_return(&sem->count) <= 0)
+		__up(sem);
+}
+
+#endif /* _ASM_ST200_SEMAPHORE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/sembuf.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/sembuf.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/sembuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/sembuf.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,25 @@
+#ifndef _ASM_ST200_SEMBUF_H
+#define _ASM_ST200_SEMBUF_H
+
+/* 
+ * The semid64_ds structure for ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_ST200_SEMBUF_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/serial.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/serial.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/serial.h	2005-02-10 12:06:33.000000000 +0000
@@ -0,0 +1,21 @@
+/*
+ * include/asm-sh/serial.h
+ *
+ * Configuration details for 8250, 16450, 16550, etc. serial ports
+ */
+
+#ifndef _ASM_SERIAL_H
+#define _ASM_SERIAL_H
+
+#include <linux/kernel.h>
+
+/*
+ * This assumes you have a 1.8432 MHz clock for your UART.
+ *
+ */
+#define BASE_BAUD ( 18432000 / 16 )
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#define STD_SERIAL_PORT_DEFNS 
+#define SERIAL_PORT_DFNS STD_SERIAL_PORT_DEFNS
+
+#endif /* _ASM_SERIAL_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/setup.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/setup.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/setup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/setup.h	2005-06-01 08:33:00.708000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __ASM_ST200_SETUP_H
+#define __ASM_ST200_SETUP_H
+
+#define COMMAND_LINE_SIZE	1024
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/shmbuf.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/shmbuf.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/shmbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/shmbuf.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,42 @@
+#ifndef _ASM_ST200_SHMBUF_H
+#define _ASM_ST200_SHMBUF_H
+
+/* 
+ * The shmid64_ds structure for the ST200 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	unsigned long		__unused1;
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	unsigned long		__unused2;
+	__kernel_time_t		shm_ctime;	/* last change time */
+	unsigned long		__unused3;
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_ST200_SHMBUF_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/shmparam.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/shmparam.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/shmparam.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/shmparam.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef _ASM_ST200_SHMPARAM_H
+#define _ASM_ST200_SHMPARAM_H
+
+/* We have no problems with D cache aliasing on the ST200 */
+
+#define	SHMLBA PAGE_SIZE
+
+#endif /* _ASM_ST200_SHMPARAM_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/sigcontext.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/sigcontext.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/sigcontext.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,19 @@
+#ifndef _ASM_ST200_SIGCONTEXT_H
+#define _ASM_ST200_SIGCONTEXT_H
+
+#include <asm/ptrace.h>
+
+struct sigcontext {
+	unsigned long		sc_flags;
+	struct pt_regs		sc_regs;	/* registers to restore */
+	struct switch_stack	sc_ss;		/* registers to restore */
+	stack_t			sc_stack;	/* previously active stack */
+	unsigned long		sc_reserved[8];
+	/*
+	 * The mask must come last so we can increase _NSIG_WORDS
+	 * without breaking binary compatibility.
+	 */
+	sigset_t		sc_mask;	/* signal mask to restore after handler returns */
+};
+
+#endif /* _ASM_ST200_SIGCONTEXT_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/siginfo.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/siginfo.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/siginfo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/siginfo.h	2005-06-01 10:55:04.335004000 +0100
@@ -0,0 +1,8 @@
+#ifndef _ASM_ST200_SIGINFO_H
+#define _ASM_ST200_SIGINFO_H
+
+#define __ARCH_SI_TRAPNO
+
+#include <linux/siginfo.h>
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/simtrace.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/simtrace.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/simtrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/simtrace.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,21 @@
+/*
+ * include/asm-st200/simtrace.h
+ *
+ * Copyright (C) 2003 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ */
+
+/* Simulator trace plug-in interface */
+
+#ifndef _ASM_ST200_SIMTRACE_H
+#define _ASM_ST200_SIMTRACE_H
+
+#ifdef CONFIG_SIMULATOR_TRACE_DEVICE
+void sim_trace_on(int mode);
+void sim_trace_off(void);
+#else
+static __inline__ void sim_trace_on(int mode) { }
+static __inline__ void sim_trace_off(void) { }
+#endif
+
+#endif /* _ASM_ST200_SIMTRACE_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/smp.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/smp.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/smp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/smp.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,4 @@
+#ifndef __ASM_ST200_SMP_H
+#define __ASM_ST200_SMP_H
+
+#endif /* __ASM_ST200_SMP_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/socket.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/socket.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/socket.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/socket.h	2005-02-10 10:16:24.000000000 +0000
@@ -0,0 +1,50 @@
+#ifndef _ASM_ST200_SOCKET_H
+#define _ASM_ST200_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockopt(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME		28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC		31
+
+#endif /* _ASM_ST200_SOCKET_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/sockios.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/sockios.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/sockios.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/sockios.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,16 @@
+#ifndef __ASM_ST200_SOCKIOS_H
+#define __ASM_ST200_SOCKIOS_H
+
+#include <asm/ioctl.h>
+
+/* Socket-level I/O control calls. */
+#define FIOGETOWN	_IOR('f', 123, int)
+#define FIOSETOWN 	_IOW('f', 124, int)
+
+#define SIOCATMARK	_IOR('s', 7, int)
+#define SIOCSPGRP	_IOW('s', 8, pid_t)
+#define SIOCGPGRP	_IOR('s', 9, pid_t)
+
+#define SIOCGSTAMP	_IOR('s', 100, struct timeval) /* Get stamp - linux-specific */
+
+#endif /* __ASM_ST200_SOCKIOS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/softirq.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/softirq.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/softirq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/softirq.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,21 @@
+#ifndef _ASM_ST200_SOFTIRQ_H
+#define _ASM_ST200_SOFTIRQ_H
+
+#include <linux/preempt.h>
+#include <asm/hardirq.h>
+
+#define local_bh_disable() \
+		do { preempt_count() += SOFTIRQ_OFFSET; barrier(); } while (0)
+#define __local_bh_enable() \
+		do { barrier(); preempt_count() -= SOFTIRQ_OFFSET; } while (0)
+
+#define local_bh_enable()					\
+do {								\
+	__local_bh_enable();					\
+	if (unlikely(!in_interrupt() &&				\
+		     softirq_pending(smp_processor_id())))	\
+		do_softirq();					\
+	preempt_check_resched();				\
+} while (0)
+
+#endif /* _ASM_ST200_SOFTIRQ_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/stat.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/stat.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/stat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/stat.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,63 @@
+#ifndef _ASM_ST200_STAT_H
+#define _ASM_ST200_STAT_H
+
+struct stat {
+	unsigned long	st_dev;
+	unsigned long	st_ino;
+	unsigned long	st_nlink;
+	unsigned int	st_mode;
+	unsigned int	st_uid;
+	unsigned int	st_gid;
+	unsigned int	__pad0;
+	unsigned long	st_rdev;
+	unsigned long	st_size;
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+	unsigned long	st_blksize;
+	long		st_blocks;
+	unsigned long	__unused[3];
+};
+
+#define STAT_HAVE_NSEC 1
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned short	st_dev;
+	unsigned char	__pad0[10];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned long	__st_ino;
+
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned short	st_rdev;
+	unsigned char	__pad3[10];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+
+	long long	st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned int	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#endif /* _ASM_ST200_STAT_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/string.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/string.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/string.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/string.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,33 @@
+/*
+ * include/asm-st200/string.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Thierry Strudel <thierry.strudel@st.com>
+ *
+ */
+
+#ifndef _ASM_SH_STRING_H
+#define _ASM_SH_STRING_H
+
+
+extern char *strcpy(char *__dest, const char *__src);
+
+extern char *strncpy(char *__dest, const char *__src, size_t __n);
+
+extern int strcmp(const char *__cs, const char *__ct);
+
+extern int strncmp(const char *__cs, const char *__ct, size_t __n);
+
+extern void *memset(void *__s, int __c, size_t __count);
+
+#define __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+
+extern void *memmove(void *__dest, __const__ void *__src, size_t __n);
+
+extern void *memchr(const void *__s, int __c, size_t __n);
+
+#define __HAVE_ARCH_MEMSET
+extern void * memset(void * s,int c,size_t count);
+
+#endif /* _ASM_SH_STRING_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/syscallparams.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/syscallparams.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/syscallparams.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/syscallparams.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,47 @@
+/*
+ *  include/asm-st200/syscallparams.h
+ *
+ *  Copyright (C) 2003 STMicroelectronics Limited
+ *      Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_SYSCALLPARAM_H
+#define _ASM_ST200_SYSCALLPARAM_H
+
+/*
+ * The LX ABI specifies that the first eight parameters to a function are
+ * passed in registers, the remaining parameters are passed on the stack.
+ * This allows us to 'pass' the registers pushed onto the stack by the
+ * system call entry code to the C code. However there are some restrictions
+ * on the alignment of these parameters, there is the 16 byte scratch area
+ * which every function has, and some additional padding needed to align
+ * the stack on a 32 byte boundary. So by defining these structures,
+ * and passing them as the 9th parameter, we can make use of this facility,
+ * and avoid the above problems.
+ */
+
+struct syscallparams {
+	unsigned int pad[4];
+	struct pt_regs regs;
+};
+
+struct syscallparams_ss {
+	unsigned int pad[4];
+	struct switch_stack ss;
+	struct pt_regs regs;
+};
+
+/*
+ * This demonstrates how it is possible to return two results from a
+ * system call.
+ */
+union syscallresult {
+	unsigned long result1;
+	struct {
+		unsigned long r16;
+		unsigned long r17;
+	} result2;
+};
+
+#endif /* _ASM_ST200_SYSCALLPARAM_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/system.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/system.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/system.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/system.h	2005-06-01 08:35:51.025000000 +0100
@@ -0,0 +1,147 @@
+#ifndef __ASM_ST200_SYSTEM_H
+#define __ASM_ST200_SYSTEM_H
+
+#include <linux/kernel.h>
+
+#include <asm/segment.h>
+#include <asm/ptrace.h>
+#include <asm/ctrlregdef.h>
+
+#ifdef __KERNEL__
+
+#define SWITCH_DEBUG_FLAGS (ST200_THREAD_DEBUG_VALID | ST200_THREAD_TRACE_VALID)
+#define switch_to(prev, next, last) do {			\
+	extern struct task_struct* __switch_to(struct thread_struct* prev_ts,	\
+		struct thread_struct* next_ts, unsigned long ssp,	\
+		task_t* prev);						\
+	extern void clear_debugregs(struct task_struct*);		\
+	extern void set_debugregs(struct task_struct*);			\
+	if (prev->thread.flags & SWITCH_DEBUG_FLAGS)			\
+		clear_debugregs(prev);					\
+	if (next->thread.flags & SWITCH_DEBUG_FLAGS)			\
+		set_debugregs(next);					\
+	last = __switch_to(&prev->thread, &next->thread,		\
+			(unsigned long)next->thread_info + THREAD_SIZE, prev);	\
+} while (0)
+
+#endif	/* __KERNEL__ */
+
+
+/*
+ * Force strict CPU ordering.
+ * And yes, this is required on UP too when we're talking
+ * to devices.
+ *
+ */
+ 
+/* FIXME : We need to issue a sync() call somehow. There is an intrinsic to 
+ * do this, alternatively we call to assembler. I've stuck in a function 
+ * call for now.
+ */
+extern void __sync(void);
+
+#define mb()		__sync()
+#define rmb()		mb()
+#define wmb()		mb()
+#define smp_mb()	mb()
+#define smp_rmb()	mb()
+#define smp_wmb()	mb()
+#define smp_read_barrier_depends()	do { } while(0)
+#define read_barrier_depends()		do { } while(0)
+
+#define set_mb(var, value)		do { var = value; mb(); } while (0)
+#define set_wmb(var, value)		do { var = value; wmb(); } while (0)
+
+/* interrupt control.. */
+#define local_irq_disable() __asm__ volatile ("pswclr %0\n"         \
+                                              : /* No output */     \
+					      : "r" (PSW_INT_ENABLE)\
+                                              : "memory"         \
+                                             );
+
+
+#define local_irq_enable() __asm__ volatile ("pswset %0\n"         \
+                                              : /* No output */     \
+					      : "r" (PSW_INT_ENABLE)\
+                                              : "memory"         \
+                                             );
+
+
+#define local_save_flags(x) do { __asm__ volatile ("ldw %0 = %1[$r0]\n" \
+                                                   :"=r" (x)            \
+                                                   :"i" (PSW)           \
+					          ); } while(0)
+
+
+#define local_irq_restore(x) do { __asm__ volatile ("pswset %0 \n"   \
+                                                    ";;\n"           \
+                                                    "pswclr %1 \n"   \
+                                                   : /* No output */ \
+                                                   :"r" (x), "r" (~x)\
+                                                   : "memory"        \
+					          ); } while(0)
+
+    
+#define irqs_disabled()			\
+({					\
+	unsigned long flags;		\
+	local_save_flags(flags);	\
+	!(flags & PSW_INT_ENABLE);	\
+})
+
+/* For spinlocks etc */
+#define local_irq_save(x)  do { local_save_flags(x); local_irq_disable(); } while (0)
+
+#define xchg(ptr,v) ((__typeof__(*(ptr)))__xchg((unsigned long)(v),(ptr),sizeof(*(ptr))))
+
+extern void __xchg_called_with_bad_pointer(void);
+
+static __inline__ unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+{
+	unsigned long retval;
+
+	switch (size) {
+	case 4:
+		asm volatile("1: ldw %0    = 0[%1]\n"
+			     "   mov $r62  = 1b\n"
+			     "   or  $r12  = $r12,1\n"
+			     "   ;;\n"
+			     "   stw 0[%1] = %2\n"
+			     "   and $r12  = $r12,~1\n"
+			     : "=&r" (retval)
+			     : "r" (ptr), "r" (x)
+			     : "memory","r62" );
+		break;
+	case 2:
+		asm volatile("1: ldhu %0    = 0[%1]\n"
+			     "   mov $r62  = 1b\n"
+			     "   or  $r12  = $r12,1\n"
+			     "   ;;\n"
+			     "   sth 0[%1] = %2\n"
+			     "   and $r12  = $r12,~1\n"
+			     : "=&r" (retval)
+			     : "r" (ptr), "r" (x)
+			     : "memory","r62" );
+		break;
+	case 1:
+		asm volatile("1: ldbu %0    = 0[%1]\n"
+			     "   mov $r62  = 1b\n"
+			     "   or  $r12  = $r12,1\n"
+			     "   ;;\n"
+			     "   stb 0[%1] = %2\n"
+			     "   and $r12  = $r12,~1\n"
+			     : "=&r" (retval)
+			     : "r" (ptr), "r" (x)
+			     : "memory","r62" );
+		break;
+	default:
+		__xchg_called_with_bad_pointer();
+		break;
+	}
+
+	return retval;
+}
+
+extern void die_if_kernel(const char *str, struct pt_regs *regs) __attribute__ ((noreturn));
+
+#endif /* __ASM_ST200_SYSTEM_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/termbits.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/termbits.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/termbits.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/termbits.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,175 @@
+#ifndef _ASM_ST200_TERMBITS_H
+#define _ASM_ST200_TERMBITS_H
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */        
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8   0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/termios.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/termios.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/termios.h	2005-02-10 10:20:27.000000000 +0000
@@ -0,0 +1,60 @@
+#ifndef _ASM_ST200_TERMIOS_H
+#define _ASM_ST200_TERMIOS_H
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+/* line disciplines */
+#define N_TTY		0
+#define N_SLIP		1
+#define N_MOUSE		2
+#define N_PPP		3
+#define N_STRIP		4
+#define N_AX25		5
+#define N_X25		6	/* X.25 async */
+#define N_6PACK		7
+#define N_MASC		8	/* Reserved for Mobitex module <kaz@cafe.net> */
+#define N_R3964		9	/* Reserved for Simatic R3964 module */
+#define N_PROFIBUS_FDL	10	/* Reserved for Profibus <Dave@mvhi.com> */
+#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
+#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
+#define N_HDLC		13	/* synchronous HDLC */
+#define N_SYNC_PPP	14	/* synchronous PPP */
+#define N_HCI		15  /* Bluetooth HCI UART */
+
+#endif	/* _ASM_ST200_TERMIOS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/timex.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/timex.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/timex.h	2005-06-01 08:38:29.396001000 +0100
@@ -0,0 +1,24 @@
+/*
+ *  include/asm-st200/timex.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_TIMEX_H
+#define _ASM_ST200_TIMEX_H
+
+/* FIXME: Will need updating */
+//#define CLOCK_TICK_RATE 1193180 /* Underlying HZ */
+#define CLOCK_TICK_RATE 1000000 /* Underlying HZ */
+
+typedef unsigned long long cycles_t;
+
+/* FIXME: ST200 does have a cycle counter */
+static inline cycles_t get_cycles (void)
+{
+	return 0;
+}
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/tlbflush.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/tlbflush.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/tlbflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/tlbflush.h	2005-02-10 12:05:43.000000000 +0000
@@ -0,0 +1,64 @@
+#ifndef _ASM_ST200_TLBFLUSH_H
+#define _ASM_ST200_TLBFLUSH_H
+
+#include <linux/mm.h>
+
+#include <asm/processor.h>
+#include <asm/mmu_context.h>
+
+#include "unimplemented.h"
+
+/*
+ * TLB flushing:
+ *
+ *  - flush_tlb() flushes the current mm struct TLBs
+ *  - flush_tlb_all() flushes all processes TLBs
+ *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
+ *  - flush_tlb_page(vma, vmaddr) flushes one page
+ *  - flush_tlb_range(vma, start, end) flushes a range of pages
+ *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
+ *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
+ *
+ */
+
+extern void flush_tlb(void);
+extern void flush_tlb_all(void);
+extern void __flush_tlb_mm(unsigned long context);
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	if (context_valid(mm->context)) {
+		__flush_tlb_mm(mm->context & ASID_MASK);
+	}
+}
+
+extern void __flush_tlb_page(unsigned long context, unsigned long addr);
+static inline void flush_tlb_page(struct vm_area_struct *vma,
+	unsigned long addr)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	if (context_valid(mm->context)) {
+		__flush_tlb_page(mm->context & ASID_MASK, addr & PAGE_MASK);
+	}
+}
+
+extern void __flush_tlb_range(unsigned long context,
+			    unsigned long start, unsigned long end);
+static inline void flush_tlb_range(struct vm_area_struct *vma,
+	unsigned long start, unsigned long end)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	if (context_valid(mm->context)) {
+		__flush_tlb_range(mm->context & ASID_MASK,
+				  start & PAGE_MASK, end & PAGE_MASK);
+	}
+}
+
+#define flush_tlb_kernel_range(start, end) flush_tlb_all()
+
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
+				      unsigned long start, unsigned long end)
+{
+	unimplemented(__FUNCTION__);
+}
+
+#endif /* _ASM_ST200_TLBFLUSH_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/types.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/types.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/types.h	2005-02-16 12:37:09.000000000 +0000
@@ -0,0 +1,32 @@
+#ifndef _ASM_ST200_TYPES_H
+#define _ASM_ST200_TYPES_H
+
+#define BITS_PER_LONG 32
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+/* LXFIXME: GNUC MACRO */
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/uaccess.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/uaccess.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/uaccess.h	2005-06-01 08:42:53.316000000 +0100
@@ -0,0 +1,288 @@
+/*
+ * include/asm-st200/uaccess.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_UACCESS_H
+#define _ASM_ST200_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/sched.h>
+#include <asm/errno.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+/* Returns 0 if exception not found and fixup otherwise.  */
+extern unsigned long search_exception_table(unsigned long);
+
+/*
+ * The fs value determines whether argument validity checking should be
+ * performed or not.  If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons (Data Segment Register?), these macros are misnamed.
+ */
+
+#define get_ds()	(KERNEL_DS)
+#define get_fs()	(current_thread_info()->addr_limit)
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
+
+#define MAKE_MM_SEG(s)  ((mm_segment_t) { (s) })
+
+/* addr_limit is the maximum accessible address for the task. we misuse
+ * the KERNEL_DS and USER_DS values to both assign and compare the 
+ * addr_limit values through the equally misnamed get/set_fs macros.
+ * (see above)
+ */
+
+#define KERNEL_DS	MAKE_MM_SEG(0xffffffff)
+#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
+
+/*
+ * Ideally we should be doing this using assembler:
+ *   This needs 33-bit arithmetic. We have a carry..
+ *
+ *   sum := addr + size;  carry? --> result = false;
+ *   if (sum >= addr_limit) result = false;
+ *   otherwise result = true
+ *
+ * but we don't have inline asm, so hack it using long longs.
+ */
+static inline int access_ok(int type, const void* addr, unsigned long size)
+{
+#ifdef CONFIG_MMU
+	return ((unsigned long long)(unsigned long)addr + (unsigned long long)size) <=
+		(unsigned long long)current_thread_info()->addr_limit.seg;
+#else
+	return 1; /* We should at least check for sensible physical */
+#endif
+}
+
+static inline int verify_area(int type, const void * addr, unsigned long size)
+{
+	return access_ok(type, addr, size) ? 0 : -EFAULT;
+}
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ *
+ * As the ST200 uses the same address space for kernel and user
+ * data, we can just do these as direct assignments.  (Of course, the
+ * exception handling means that it's no longer "just"...)
+ *
+ * Careful to not
+ * (a) re-use the arguments for side effects (sizeof/typeof is ok)
+ * (b) require any knowledge of processes at this stage
+ *
+ * These functions return 0 on success and -EFAULT on error.
+ */
+#define put_user(x,ptr) \
+  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+#define get_user(x,ptr) \
+  __get_user_check((x),(ptr),sizeof(*(ptr)))
+
+/*
+ * The "__xxx" versions do not do address space checking, useful when
+ * doing multiple accesses to the same area (the programmer has to do the
+ * checks by hand with "access_ok()")
+ */
+#define __put_user(x,ptr) \
+  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+#define __get_user(x,ptr) \
+  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))
+
+extern long __get_user_asm_byte(const void* ptr, long* retval);
+extern long __get_user_asm_half(const void* ptr, long* retval);
+extern long __get_user_asm_word(const void* ptr, long* retval);
+extern long long __get_user_asm_double(const void* ptr, long* retval);
+extern long __get_user_bad(void);
+
+extern void __put_user_asm_byte(long x, void *ptr, long* retval);
+extern void __put_user_asm_half(long x, void *ptr, long* retval);
+extern void __put_user_asm_word(long x, void *ptr, long* retval);
+extern void __put_user_asm_double(long long x, void *ptr, long* retval);
+extern void __put_user_bad(void);
+
+#define __get_user_check(x,ptr,size)					\
+({									\
+	long __gu_err = -EFAULT;					\
+	__typeof(*(ptr)) __gu_val = 0;					\
+	const __typeof__(*(ptr)) *__gu_addr = (ptr);			\
+	if (access_ok(VERIFY_READ,__gu_addr,size)) {			\
+		__gu_err = 0;						\
+		__get_user_size(__gu_val,__gu_addr,(size),__gu_err);	\
+	}								\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_nocheck(x,ptr,size)					\
+({									\
+	long __gu_err = 0;						\
+	__typeof(*(ptr)) __gu_val;					\
+	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+#define __put_user_check(x,ptr,size)					\
+({									\
+	long __pu_err = -EFAULT;					\
+	__typeof__(*(ptr)) *__pu_addr = (ptr);				\
+	if (access_ok(VERIFY_WRITE,__pu_addr,size)) {			\
+		__pu_err = 0;						\
+		__put_user_size((x),__pu_addr,(size),__pu_err);		\
+	}								\
+	__pu_err;							\
+})
+
+#define __put_user_nocheck(x,ptr,size)					\
+({									\
+	long __pu_err = 0;						\
+	__typeof__(*(ptr)) *__pu_addr = (ptr);				\
+	__put_user_size((x),__pu_addr,(size),__pu_err);			\
+	__pu_err;							\
+})
+
+#define __get_user_size(x,ptr,size,retval)				\
+do {									\
+	switch (size) {							\
+	case 1:	(x) = __get_user_asm_byte(ptr,&retval);	break;		\
+	case 2:	(x) = __get_user_asm_half(ptr,&retval);	break;		\
+	case 4:	(x) = __get_user_asm_word(ptr,&retval);	break;		\
+	case 8:	(x) = __get_user_asm_double(ptr,&retval); break;	\
+	default: (x) = __get_user_bad();				\
+	}								\
+} while (0)
+
+#define __put_user_size(x,ptr,size,retval)				\
+do {									\
+	switch (size) {							\
+	case 1: __put_user_asm_byte(x,ptr,&retval);	break;	\
+	case 2: __put_user_asm_half(x,ptr,&retval);	break;	\
+	case 4: __put_user_asm_word(x,ptr,&retval);	break;	\
+	case 8: __put_user_asm_double(x,ptr,&retval);	break;	\
+	default: __put_user_bad();					\
+	}								\
+} while (0)
+
+unsigned long __do_copy_user(void *to, const void *from, unsigned long n);
+unsigned long __do_clear_user (void *to, unsigned long n);
+long __do_strncpy_from_user (char *dst, const char *src, long count);
+long __do_strnlen_user(const char *s, long n);
+
+/*
+ * All the {__,}copy_{to,from}_user and {__,}clear_user functions
+ * return the number of bytes NOT copied.
+ */
+static __inline__ unsigned long copy_from_user(void *to, const void *from, unsigned long n)
+{
+	if (access_ok(VERIFY_READ, from, n))
+		n = __do_copy_user(to, from, n);
+	else /* security hole - plug it */
+		memset(to, 0, n);
+	return n;
+}
+
+static __inline__ unsigned long __copy_from_user_inatomic(void *to, const void *from, unsigned long n)
+{
+	return __do_copy_user(to, from, n);
+}
+
+static inline unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
+{
+	might_sleep();
+	return __copy_from_user_inatomic(to, from, n);
+}
+
+static __inline__ unsigned long copy_to_user(void *to, const void *from, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __do_copy_user(to, from, n);
+	return n;
+}
+
+static __inline__ unsigned long __copy_to_user_inatomic(void *to, const void *from, unsigned long n)
+{
+	return __do_copy_user(to, from, n);
+}
+
+static inline unsigned long __copy_to_user(void __user *to, const void *from, unsigned long n)
+{
+	might_sleep();
+	return __copy_to_user_inatomic(to, from, n);
+}
+		
+static __inline__ unsigned long clear_user (void *to, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		n = __do_clear_user(to, n);
+	return n;
+}
+
+static __inline__ unsigned long __clear_user (void *to, unsigned long n)
+{
+	return __do_clear_user(to, n);
+}
+
+/*
+ * {__,}strcpy_from_user returns -EFAULT if exception, count if the entire
+ * buffer filled, else strlen (without trailing nul).
+ */
+static __inline__ long strncpy_from_user (char *dst, const char *src, long count)
+{
+	long res = -EFAULT;
+	if (access_ok(VERIFY_READ, src, 1))
+		res = __do_strncpy_from_user(dst, src, count);
+	return res;
+}
+
+static __inline__ long __strncpy_from_user (char *dst, const char *src, long count)
+{
+	return __do_strncpy_from_user(dst, src, count);
+}
+
+/*
+ * strnlen_user returns 0 if exception before NUL or reaching the
+ * supplied limit (N), a value greater than N if the limit would be
+ * exceeded, else strlen (including trailing nul).
+ */
+static inline long strnlen_user(const char *s, long n)
+{
+	unsigned long res = 0;
+
+	if (access_ok(VERIFY_READ,s,0))
+		res = __do_strnlen_user(s, n);
+	return res;
+}
+
+#define strlen_user(s)	strnlen_user(s, ~0UL >> 1)
+
+#endif /* _ASM_ST200_UACCESS_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/ucontext.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/ucontext.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/ucontext.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,21 @@
+/*
+ * Single Unix Specification defines the third paramater to a signal
+ * handler as a pointer to a ucontext_t.
+ */
+
+#ifndef _ASM_ST200_UCONTEXT_H
+#define _ASM_ST200_UCONTEXT_H
+
+#include <asm/sigcontext.h>
+
+typedef struct sigcontext mcontext_t;
+
+typedef struct ucontext {
+	mcontext_t uc_mcontext;
+} ucontext_t;
+
+#define uc_link		uc_mcontext.sc_flags	/* wrong type; nobody cares */
+#define uc_sigmask	uc_mcontext.sc_sigmask
+#define uc_stack	uc_mcontext.sc_stack
+
+#endif /* _ASM_ST200_UCONTEXT_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/unaligned.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/unaligned.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/unaligned.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/unaligned.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * include/asm-st200/unaligned.h
+ *
+ * Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * Copied from include/asm-arm/unaligned.h
+ */
+
+#ifndef _ASM_ST200_UNALIGNED_H
+#define _ASM_ST200_UNALIGNED_H
+
+#include <asm/types.h>
+
+extern int __bug_unaligned_x(void *ptr);
+
+#define __get_unaligned_2(__p)					\
+	(__p[0] | __p[1] << 8)
+
+#define __get_unaligned_4(__p)					\
+	(__p[0] | __p[1] << 8 | __p[2] << 16 | __p[3] << 24)
+
+#define get_unaligned(ptr)					\
+	({							\
+		__typeof__(*(ptr)) __v;				\
+		__u8 *__p = (__u8 *)(ptr);			\
+		switch (sizeof(*(ptr))) {			\
+		case 1:	__v = *(ptr);			break;	\
+		case 2: __v = __get_unaligned_2(__p);	break;	\
+		case 4: __v = __get_unaligned_4(__p);	break;	\
+		case 8: {					\
+				unsigned int __v1, __v2;	\
+				__v2 = __get_unaligned_4((__p+4)); \
+				__v1 = __get_unaligned_4(__p);	\
+				__v = ((unsigned long long)__v2 << 32 | __v1);	\
+			}					\
+			break;					\
+		default: __v = __bug_unaligned_x(__p);	break;	\
+		}						\
+		__v;						\
+	})
+
+static inline void __put_unaligned_2(__u32 __v, register __u8 *__p)
+{
+	*__p++ = __v;
+	*__p++ = __v >> 8;
+}
+
+static inline void __put_unaligned_4(__u32 __v, register __u8 *__p)
+{
+	__put_unaligned_2(__v >> 16, __p + 2);
+	__put_unaligned_2(__v, __p);
+}
+
+static inline void __put_unaligned_8(const unsigned long long __v, register __u8 *__p)
+{
+	__put_unaligned_4(__v >> 32, __p+4);
+	__put_unaligned_4(__v, __p);
+}
+
+/*
+ * Try to store an unaligned value as efficiently as possible.
+ */
+#define put_unaligned(val,ptr)					\
+	({							\
+		switch (sizeof(*(ptr))) {			\
+		case 1:						\
+			*(ptr) = (val);				\
+			break;					\
+		case 2: __put_unaligned_2((val),(__u8 *)(ptr));	\
+			break;					\
+		case 4:	__put_unaligned_4((val),(__u8 *)(ptr));	\
+			break;					\
+		case 8:	__put_unaligned_8((val),(__u8 *)(ptr)); \
+			break;					\
+		default: __bug_unaligned_x(ptr);		\
+			break;					\
+		}						\
+		(void) 0;					\
+	})
+
+#endif /* _ASM_ST200_UNALIGNED_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/unimplemented.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/unimplemented.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/unimplemented.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/unimplemented.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1 @@
+void unimplemented(const char* fn);
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/unistd.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/unistd.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/unistd.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,351 @@
+/*
+ *  include/asm-st200/unistd.h
+ *
+ *  Copyright (C) 2002 STMicroelectronics Limited
+ *	Author: David McKay <david.mckay@st.com>
+ *
+ */
+
+#ifndef _ASM_ST200_UNISTD_H
+#define _ASM_ST200_UNISTD_H
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_syscall                0
+#define __NR_exit                   1
+#define __NR_fork                   2
+#define __NR_read                   3
+#define __NR_write                  4
+#define __NR_open                   5
+#define __NR_close                  6
+/* #define __NR_waitpid                7 */
+/* #define __NR_creat                  8 */
+#define __NR_link                   9
+#define __NR_unlink                10
+#define __NR_execve                11
+#define __NR_chdir                 12
+/* #define __NR_time                  13 */
+#define __NR_mknod                 14
+#define __NR_chmod                 15
+#define __NR_lchown                16
+#define __NR_socket                17
+#define __NR_stat                  18
+#define __NR_lseek                 19
+#define __NR_getpid                20
+#define __NR_mount                 21
+#define __NR_bind                  22
+#define __NR_setuid                23
+#define __NR_getuid                24
+/* #define __NR_stime                 25 */
+#define __NR_ptrace                26
+/* #define __NR_alarm                 27 */
+#define __NR_fstat                 28
+#define __NR_pause                 29
+#define __NR_utimes                30
+#define __NR_connect               31
+#define __NR_listen                32
+#define __NR_access                33
+/* #define __NR_nice                  34 */
+#define __NR_accept                35
+#define __NR_sync                  36
+#define __NR_kill                  37
+#define __NR_rename                38
+#define __NR_mkdir                 39
+#define __NR_rmdir                 40
+#define __NR_dup                   41
+#define __NR_pipe                  42
+#define __NR_times                 43
+#define __NR_getsockname           44
+#define __NR_brk                   45
+#define __NR_setgid                46
+#define __NR_getgid                47
+/* #define __NR_signal                48 */
+#define __NR_geteuid               49
+#define __NR_getegid               50
+#define __NR_acct                  51
+#define __NR_umount2               52
+#define __NR_getpeername           53
+#define __NR_ioctl                 54
+#define __NR_fcntl                 55
+#define __NR_socketpair            56
+#define __NR_setpgid               57
+#define __NR_send                  58
+#define __NR_uname                 59
+#define __NR_umask                 60
+#define __NR_chroot                61
+#define __NR_ustat                 62
+#define __NR_dup2                  63
+#define __NR_getppid               64
+#define __NR_getpgrp               65
+#define __NR_setsid                66
+#define __NR_pivot_root            67
+/* #define __NR_sgetmask              68 */
+/* #define __NR_ssetmask              69 */
+#define __NR_setreuid              70
+#define __NR_setregid              71
+#define __NR_mincore               72
+/* #define __NR_sigpending            73 */
+#define __NR_sethostname           74
+#define __NR_setrlimit             75
+#define __NR_getrlimit             76
+#define __NR_getrusage             77
+#define __NR_gettimeofday          78
+#define __NR_settimeofday          79
+#define __NR_getgroups             80
+#define __NR_setgroups             81
+#define __NR_sendto                82
+#define __NR_symlink               83
+#define __NR_lstat                 84
+#define __NR_readlink              85
+#define __NR_uselib                86
+#define __NR_swapon                87
+#define __NR_reboot                88
+/* #define __NR_mmap2                 89 */
+#define __NR_mmap                  90
+#define __NR_munmap                91
+#define __NR_truncate              92
+#define __NR_ftruncate             93
+#define __NR_fchmod                94
+#define __NR_fchown                95
+#define __NR_getpriority           96
+#define __NR_setpriority           97
+#define __NR_recv                  98
+#define __NR_statfs                99
+#define __NR_fstatfs              100
+#define __NR_stat64               101
+/* #define __NR_socketcall        102 */
+#define __NR_syslog               103
+#define __NR_setitimer            104
+#define __NR_getitimer            105
+#define __NR_capget               106
+#define __NR_capset               107
+#define __NR_pread64              108
+#define __NR_pwrite64             109
+#define __NR_getcwd               110
+#define __NR_vhangup              111
+#define __NR_fstat64              112
+#define __NR_vfork                113
+#define __NR_wait4                114
+#define __NR_swapoff              115
+#define __NR_sysinfo              116
+#define __NR_shutdown             117
+#define __NR_fsync                118
+#define __NR_madvise              119
+#define __NR_clone                120
+#define __NR_setdomainname        121
+#define __NR_sendfile             122
+#define __NR_recvfrom             123
+#define __NR_adjtimex             124
+#define __NR_mprotect             125
+/* #define __NR_sigprocmask          126 */
+#define __NR_create_module        127
+#define __NR_init_module          128
+#define __NR_delete_module        129
+#define __NR_get_kernel_syms      130
+#define __NR_quotactl             131
+#define __NR_getpgid              132
+#define __NR_fchdir               133
+#define __NR_bdflush              134
+#define __NR_sysfs                135
+#define __NR_personality          136
+#define __NR_afs_syscall          137 /* Syscall for Andrew File System */
+#define __NR_setfsuid             138
+#define __NR_setfsgid             139
+#define __NR__llseek              140
+#define __NR_getdents             141
+#define __NR__newselect           142
+#define __NR_flock                143
+#define __NR_msync                144
+#define __NR_readv                145
+#define __NR_writev               146
+#define __NR_getsid               147
+#define __NR_fdatasync            148
+#define __NR__sysctl              149
+#define __NR_mlock                150
+#define __NR_munlock              151
+#define __NR_mlockall             152
+#define __NR_munlockall           153
+#define __NR_sched_setparam               154
+#define __NR_sched_getparam               155
+#define __NR_sched_setscheduler           156
+#define __NR_sched_getscheduler           157
+#define __NR_sched_yield                  158
+#define __NR_sched_get_priority_max       159
+#define __NR_sched_get_priority_min       160
+#define __NR_sched_rr_get_interval        161
+#define __NR_nanosleep            162
+#define __NR_mremap               163
+#define __NR_setresuid            164
+#define __NR_getresuid            165
+#define __NR_sigaltstack          166
+#define __NR_query_module         167
+#define __NR_poll                 168
+#define __NR_nfsservctl           169
+#define __NR_setresgid            170
+#define __NR_getresgid            171
+#define __NR_prctl                172
+#define __NR_rt_sigreturn         173
+#define __NR_rt_sigaction         174
+#define __NR_rt_sigprocmask       175
+#define __NR_rt_sigpending        176
+#define __NR_rt_sigtimedwait      177
+#define __NR_rt_sigqueueinfo      178
+#define __NR_rt_sigsuspend        179
+#define __NR_chown                180
+#define __NR_setsockopt           181
+#define __NR_getsockopt           182
+#define __NR_sendmsg              183
+#define __NR_recvmsg              184
+#define __NR_semop                185
+#define __NR_semget               186
+#define __NR_semctl               187
+#define __NR_msgsnd               188
+#define __NR_msgrcv               189
+#define __NR_msgget               190
+#define __NR_msgctl               191
+#define __NR_shmat                192
+#define __NR_shmdt                193
+#define __NR_shmget               194
+#define __NR_shmctl               195
+#define __NR_getpmsg              196      /* some people actually want streams */
+#define __NR_putpmsg              197      /* some people actually want streams */
+#define __NR_lstat64              198
+#define __NR_truncate64           199
+#define __NR_ftruncate64          200
+#define __NR_getdents64           201
+#define __NR_fcntl64              202
+#define __NR_attrctl              203
+#define __NR_acl_get              204
+#define __NR_acl_set              205
+#define __NR_gettid               206
+#define __NR_readahead            207
+#define __NR_tkill		  208
+#define __NR_restart_syscall	  209
+#define __NR_semtimedop           210
+#define __NR_set_tid_address      211
+#define __NR_sched_setaffinity    212
+#define __NR_sched_getaffinity    213
+#define __NR_futex                214
+#define __NR_exit_group           215
+ 
+#define __NR_Linux_syscalls       216
+
+#ifndef __ASSEMBLY__
+
+/* errno setting is handled in the _syscalln() code */
+#define __syscall_return(type, res) \
+do { \
+	return (type) (res); \
+} while (0)
+
+#ifdef __KERNEL_SYSCALLS__
+
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/linkage.h>
+#include <asm/ptrace.h>
+
+extern unsigned long __syscall0(unsigned long nr);
+extern unsigned long __syscall1(unsigned long p1, unsigned long nr);
+extern unsigned long __syscall2(unsigned long p1, unsigned long p2,
+				unsigned long nr);
+extern unsigned long __syscall3(unsigned long p1, unsigned long p2,
+				unsigned long p3, unsigned long nr);
+extern unsigned long __syscall4(unsigned long p1, unsigned long p2,
+				unsigned long p3, unsigned long p4,
+				unsigned long nr);
+
+#endif /* __KERNEL_SYSCALLS__ */
+
+#define _syscall0(type,name) \
+type name(void) \
+{ \
+	unsigned long __res; \
+	__res = __syscall0(__NR_##name); \
+	__syscall_return(type,__res); \
+}
+
+#define _syscall1(type,name,type1,arg1) \
+type name(type1 arg1) \
+{ \
+	unsigned long __res; \
+	__res = __syscall1((unsigned long)arg1, __NR_##name); \
+	__syscall_return(type,__res); \
+}
+
+
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+	unsigned long __res; \
+	__res = __syscall2((unsigned long)arg1,(unsigned long)arg2, \
+			   __NR_##name); \
+	__syscall_return(type,__res); \
+}
+
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+	unsigned long __res; \
+	__res = __syscall3((unsigned long)arg1, (unsigned long)arg2, \
+			(unsigned long)arg3, __NR_##name); \
+	__syscall_return(type,__res); \
+}
+
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \
+type name(type1 arg1,type2 arg2,type3 arg3,type4 arg4) \
+{ \
+	unsigned long __res; \
+	__res = __syscall4((unsigned long)arg1, (unsigned long)arg2, \
+			(unsigned long)arg3, (unsigned long)arg4, \
+			__NR_##name); \
+	__syscall_return(type,__res); \
+}
+
+
+#ifdef __KERNEL__
+/* FIXME : We should ditch pause and getpgrp before we release */
+
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+
+#endif
+
+#ifdef __KERNEL_SYSCALLS__
+
+#define __NR__exit __NR_exit
+struct rusage;
+
+static inline _syscall0(pid_t,setsid)
+static inline _syscall3(int,write,int,fd,const char *,buf,off_t,count)
+static inline _syscall3(int,read,int,fd,char *,buf,off_t,count)
+static inline _syscall3(off_t,lseek,int,fd,off_t,offset,int,count)
+static inline _syscall1(int,dup,int,fd)
+static inline _syscall3(int,execve,const char *,file,char **,argv,char **,envp)
+static inline _syscall3(int,open,const char *,file,int,flag,int,mode)
+static inline _syscall1(int,close,int,fd)
+static inline _syscall1(int,_exit,int,exitcode)
+static inline _syscall4(pid_t,wait4,pid_t,pid,int *,wait_stat,int,options,struct rusage*, rusage)
+
+static inline pid_t
+waitpid (int pid, int *wait_stat, int flags)
+{
+	return wait4(pid, wait_stat, flags, NULL);
+}
+
+#endif	/* __KERNEL_SYSCALLS__ */
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * "Conditional" syscalls
+ */
+#define cond_syscall(x) asm("\t.section .text\n\t.weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall\n\t.previous");
+
+#endif /* _ASM_ST200_UNISTD_H_ */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/user.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/user.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/user.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/user.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,62 @@
+#ifndef _ASM_ST200_USER_H
+#define _ASM_ST200_USER_H
+
+#include <asm/page.h>
+
+
+
+/*
+ * Core file format: The core file is written in such a way that gdb
+ * can understand it and provide useful information to the user (under
+ * linux we use the `trad-core' bfd, NOT the osf-core).  The file contents
+ * are as follows:
+ *
+ *  upage: 1 page consisting of a user struct that tells gdb
+ *	what is present in the file.  Directly after this is a
+ *	copy of the task_struct, which is currently not used by gdb,
+ *	but it may come in handy at some point.  All of the registers
+ *	are stored as part of the upage.  The upage should always be
+ *	only one page long.
+ *  data: The data segment follows next.  We use current->end_text to
+ *	current->brk to pick up all of the user variables, plus any memory
+ *	that may have been sbrk'ed.  No attempt is made to determine if a
+ *	page is demand-zero or if a page is totally unused, we just cover
+ *	the entire range.  All of the addresses are rounded in such a way
+ *	that an integral number of pages is written.
+ *  stack: We need the stack information in order to get a meaningful
+ *	backtrace.  We need to write the data from usp to
+ *	current->start_stack, so we round each of these in order to be able
+ *	to write an integer number of pages.
+ */
+
+struct user_regs_struct {
+	unsigned long	pc;			/* program counter */
+	unsigned long	regs[64];		/* integer regs */
+	unsigned long	br[8];			/* branch bits */
+	unsigned long	psw;			/* processor status word */
+	unsigned long	debugregs[6];		/* debug registers */
+	unsigned long	traceregs[1];		/* trace registers */
+	unsigned long	unused[64];		/* future expansion */
+};
+
+struct user {
+	struct user_regs_struct regs;		/* entire machine state */
+	size_t		u_tsize;		/* text size (pages) */
+	size_t		u_dsize;		/* data size (pages) */
+	size_t		u_ssize;		/* stack size (pages) */
+	unsigned long	start_code;		/* text starting address */
+	unsigned long	start_data;		/* data starting address */
+	unsigned long	start_stack;		/* stack starting address */
+	long int	signal;			/* signal causing core dump */
+	struct regs *	u_ar0;			/* help gdb find registers */
+	unsigned long	magic;			/* identifies a core file */
+	char		u_comm[32];		/* user command name */
+};
+
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif /* _ASM_ST200_USER_H */
diff -Naur linux-libc-headers-2.6.11.2/include/asm-st200/vga.h linux-libc-headers-2.6.11.2-stm/include/asm-st200/vga.h
--- linux-libc-headers-2.6.11.2/include/asm-st200/vga.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/asm-st200/vga.h	2004-10-12 14:21:37.000000000 +0100
@@ -0,0 +1,20 @@
+/*
+ *	Access to VGA videoram
+ *
+ *	(c) 1998 Martin Mares <mj@ucw.cz>
+ */
+
+#ifndef _LINUX_ASM_VGA_H_
+#define _LINUX_ASM_VGA_H_
+
+/*
+ *	On the PC, we can just recalculate addresses and then
+ *	access the videoram directly without any black magic.
+ */
+
+#define VGA_MAP_MEM(x) (unsigned long)phys_to_virt(x)
+
+#define vga_readb(x) (*(x))
+#define vga_writeb(x,y) (*(y) = (x))
+
+#endif
diff -Naur linux-libc-headers-2.6.11.2/include/linux/stpio.h linux-libc-headers-2.6.11.2-stm/include/linux/stpio.h
--- linux-libc-headers-2.6.11.2/include/linux/stpio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.11.2-stm/include/linux/stpio.h	2005-05-31 15:28:01.832001000 +0100
@@ -0,0 +1,61 @@
+/*
+ * include/linux/st_pio.h
+ *
+ * Copyright (c) 2004 STMicroelectronics Limited
+ * Author: Stuart Menefy <stuart.menefy@st.com>
+ *
+ * ST40 General Purpose IO pins support.
+ *
+ * This layer enables other device drivers to configure PIO
+ * pins, get and set their values, and register an interrupt
+ * routine for when input pins change state.
+ */
+
+#ifndef _LINUX_ST_PIO_H_
+#define _LINUX_ST_PIO_H_ 1
+
+
+/* Pin configuration constants */
+
+#define STPIO_NONPIO		0	/* Non-PIO function (ST40 defn) */
+#define STPIO_BIDIR_Z1     	0	/* Input weak pull-up (arch defn) */
+#define STPIO_BIDIR		1	/* Bidirectonal open-drain */
+#define STPIO_OUT		2	/* Output push-pull */
+/*efine STPIO_BIDIR		3	 * Bidirectional open drain */
+#define STPIO_IN		4	/* Input Hi-Z */
+/*efine STPIO_IN		5	 * Input Hi-Z */
+#define STPIO_ALT_OUT		6	/* Alt output push-pull (arch defn) */
+#define STPIO_ALT_BIDIR		7	/* Alt bidir open drain (arch defn) */
+
+struct stpio_pin;	
+
+/* Request and release exclusive use of a PIO pin */
+struct stpio_pin* stpio_request_pin(unsigned portno, unsigned pinno,
+				    const char* name, int direction);
+void stpio_free_pin(struct stpio_pin* pin);
+
+/* Get, set value */
+void stpio_set_pin(struct stpio_pin* pin, unsigned int value);
+unsigned int stpio_get_pin(struct stpio_pin* pin);
+
+int __init stpio_init(unsigned long base_addr,int nports);
+
+
+/* Little macro to construct bitmask for contiguous ranges of bits */
+#define SYSCONFIG_BITMASK(t,b) (((unsigned)(1U << (((t)-(b)+1)))-1)  << (b))
+#define SYSCONFIG_MASK(mask) SYSCONFIG_BITMASK(1?mask,0?mask)
+
+#define SYSCONFIG_BANK(n) ((n)>>24)
+#define SYSCONFIG_MAGIC(bank,offset) ( ((bank)<<24)|(offset)/4 )
+
+/* Returns zero on success */
+int __init stsyconfig_int(unsigned long base_addr,int nregs,char *name);
+
+/*
+ * The value is shifted up by the lowest bit in the mask 
+ * Use the above macros to defined bit fields.
+ */
+
+int stsysconfig_set(int regno,unsigned mask,unsigned value);
+
+#endif /* _LINUX_ST_PIO_H_ */
