diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb102/cb102.py opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb102/cb102.py
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb102/cb102.py	2009-02-05 12:42:19.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb102/cb102.py	2009-02-05 12:41:35.521494762 +0000
@@ -1,4 +1,4 @@
-# TargetScript for connecting to and disconnecting from an cb102 (STi7200 cut 2)
+# TargetScript for connecting to and disconnecting from an cb102 (STi7200)
 
 import sttp
 import sttp.logging
@@ -26,7 +26,7 @@
     root = sttp.targetpack.get_tree()
     # Add the board TargetPack parameters
     p.update(root.parameters)
-
+    
     # TCK must be slow until ClockGen setup to run CPU at full speed
     utilities.set_tck_frequency(True, parameters)
 
@@ -36,12 +36,12 @@
     if not (parameters.has_key("no_pokes") and (int(parameters["no_pokes"]) == 1)):
         sttp.pokepeek.enable()
         cb = sttp.targetpack.get_callback("pre_poke")
-        if cb:
+        if cb: 
             cb(parameters)
 
         sttp.logging.print_out( "cb102 initialization start ..." )
         cb = sttp.targetpack.get_callback("setup_pokes")
-        if cb:
+        if cb: 
             cb(parameters)
         else:
             cb102_setup(parameters)
@@ -52,26 +52,28 @@
                 sti7200.sti7200_boot_companions(parameters)
 
         cb = sttp.targetpack.get_callback("post_poke")
-        if cb:
+        if cb: 
             cb(parameters)
 
     utilities.set_tck_frequency(False, parameters)
-
+    
     # NEVER, EVER change TCK after calling this
     sti7200.complete_connect(parameters)
-
+    
     sttp.logging.print_out( "cb102 initialization complete" )
 
 def cb102_disconnect():
     pass
 
+# Get the cb102 SoC and board versions
+def cb102_version():
+    # Return a tuple of STi7200 SoC version and PCB version from EPLD register
+    return (sti7200.sti7200_version(), sttp.pokepeek.peek(0xa5020000) & 0xFF)
+
 # Configure the cb102
 def cb102_setup(parameters):
     if not (parameters.has_key("no_clockgen_config") and (int(parameters["no_clockgen_config"]) == 1)):
-        if parameters.has_key("slow_lmi") and (int(parameters["slow_lmi"])):
-            cb102_clockgen_configure(1)
-        else:
-            cb102_clockgen_configure(0)
+        cb102_clockgen_configure()
     # Use test_pokepeek_timeout in conjunction with no_clockgen_config to cause access to hang.
     if parameters.has_key("test_pokepeek_timeout"):
         sttp.logging.print_out("Testing peek from LMI0")
@@ -80,7 +82,6 @@
     sti7200.sti7200_displayclocks()
     cb102_sysconf_configure()
     cb102_emi_configure()
-
     cb102_lmi0_configure()
     cb102_lmi1_configure()
 
@@ -92,13 +93,27 @@
         cb102_switch_on_se("se29")
 
     ccn = sttp_root.sti7200.st40.CCN.st40_ccn_regs
-    ccn.CCN_CCR.poke(0x8000090d)
 
-# cb102 CLOCKGEN Configuration
-def cb102_clockgen_configure(slow_lmi):
+    if parameters.has_key("cache") and (int(parameters["cache"]) == 0):
+        # no data or instruction cache
+        ccn.CCN_CCR.poke(0x80000808) 
+    else:
+        # data and instruction cache enabled
+        ccn.CCN_CCR.poke(0x8000090d)
 
-    # Set CKGA_PLL0 nominal to 900MHz
-    sti7200.sti7200_set_clockgen_a_newpll0(0x01, 0x0f)
+# cb102 CLOCKGEN Configuration
+def cb102_clockgen_configure():
+    (soc_ver, pcb_ver) = cb102_version()
+    
+    if (soc_ver == 0xa0):
+        # Set CKGA_PLL0 nominal to 700MHz
+        sti7200.sti7200_set_clockgen_a_pll0(0x03, 0x23, 0x0)
+    elif (soc_ver == 0xa1):
+        # Set CKGA_PLL0 nominal to 800MHz
+        sti7200.sti7200_set_clockgen_a_newpll0(0x03, 0x28)
+    else:
+        # Set CKGA_PLL0 nominal to 900MHz
+        sti7200.sti7200_set_clockgen_a_newpll0(0x01, 0x0f)
 
     # Set CKGA_PLL1 nominal to 450MHz
     sti7200.sti7200_set_clockgen_a_pll1(0x01, 0x0f)
@@ -109,33 +124,51 @@
     # Set CKGB_PLL0 nominal to 800MHz
     sti7200.sti7200_set_clockgen_b_pll0(0x03, 0x28, 0x0)
 
-    if slow_lmi:
-        # Set LMI clock to 666MHz
-        sti7200.sti7200_set_clockgen_lmi_pll(0x05, 0x6f)
+    if (soc_ver == 0xa0):
+        # Read EPLD version register
+        if pcb_ver == 0x0a:
+            # On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz
+            sti7200.sti7200_set_clockgen_lmi_pll(0x03, 0x28)
+        else:
+            # Set LMI clock to 666MHz
+            sti7200.sti7200_set_clockgen_lmi_pll(0x05, 0x6f)
+    elif (soc_ver == 0xa1):
+        # Read EPLD version register
+        if pcb_ver == 0x0a:
+            # On PCB rev A, we have a limitation on LMI1: Set LMI clock to 400MHz
+            sti7200.sti7200_set_clockgen_lmi_pll(0x03, 0x28)
+        else:
+            # Set LMI clock to 666MHz
+            sti7200.sti7200_set_clockgen_lmi_pll(0x05, 0x6f)
     else:
         # Set LMI clock to 800MHz
         sti7200.sti7200_set_clockgen_lmi_pll(0x03, 0x50)
+#            sti7200.sti7200_set_clockgen_lmi_pll(0x05, 0x6f)
 
 # cb102 detect chip and board config
 def cb102_detect():
     sysconf = sttp_root.sti7200.SYSCONF.sti7200_sysconf_regs
     deviceid = sti7200.sti7200_deviceid()
     sttp.logging.print_out("Device id : 0x%08x" % deviceid)
-    chipversion = sti7200.sti7200_version()
+    chipversion = sti7200.sti7200_version()    
     sttp.logging.print_out("STi7200 cut %x" % chipversion)
     modepins = sysconf.SYSCONF_SYS_STA01.peek()
     sttp.logging.print_out("Mode_pin : 0x%08x" % modepins)
-
+    data = sttp.pokepeek.peek(0xa5000000) & 0xFF
+    sttp.logging.print_out("EPLD revision %d.%d" % (data>>4,data & 0xf))
+    data = sttp.pokepeek.peek(0xa5020000) & 0xFF
+    sttp.logging.print_out("PCB board revision %c" % ((data & 0xf)+55))
+    
 # cb102 SYSCONF Configuration
 def cb102_sysconf_configure():
     sysconf = sttp_root.sti7200.SYSCONF.sti7200_sysconf_regs
-
+    
     # PLI_CLOCK_ENABLE set to 0
     sysconf.SYSCONF_SYS_CFG58.poke(sysconf.SYSCONF_SYS_CFG58.peek() & ~(1<<0))
 
     # LMI sub-sys & pl exit from reset
-    sysconf.SYSCONF_SYS_CFG11.poke(sysconf.SYSCONF_SYS_CFG11.peek() | 0x00000001 | 1 << 27)
-    sysconf.SYSCONF_SYS_CFG15.poke(sysconf.SYSCONF_SYS_CFG15.peek() | 0x00000001 | 1 << 27)
+    sysconf.SYSCONF_SYS_CFG11.poke(sysconf.SYSCONF_SYS_CFG11.peek() | 0x00000001 | 1 << 27| 0 << 16)
+    sysconf.SYSCONF_SYS_CFG15.poke(sysconf.SYSCONF_SYS_CFG15.peek() | 0x00000001 | 1 << 27| 0 << 16)
 
     sttp.stmc.delay(200)
 
@@ -149,15 +182,75 @@
     sysconf.SYSCONF_SYS_STA05.while_and_ne((1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
 
     # Adjust proga, progb, zoutproga, and receiver mode for LMI0
-    sysconf.SYSCONF_SYS_CFG12.poke(0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+    sysconf.SYSCONF_SYS_CFG12.poke(0xa2000001)
+    lmipl_func_proga_dqdqsdm=1          #was 1
+    lmipl_func_progb_dqdqsdm=1          #was 0
+    lmipl_func_proga_ck=1               #was 1
+    lmipl_func_progb_ck=1               #was 0
+    lmipl_func_proga_cmd=1              #was 1
+    lmipl_func_progb_cmd=1              #was 0
+    lmipl_func_zoutproga_dqdqsdm=0      #was 0
+    lmipl_func_zoutproga_ck=0           #was 0
+    lmipl_func_zoutproga_cmd=0          #was 0
+    lmipl_func_modezi=0                 #was 0 (diff 1.8V receiver; 1 is 1.8V dig CMOS receiver)
+    lmipl_func_odta=1                   #was 1 (a&b : 00=disabled, 01 or 10 = 150ohms, 11=75ohms)
+    lmipl_func_odtb=1                   #was 1  
+    lmipl_func_usepad_vref=1            #was 1 (USEPAD setting for VREFIN pad)
+    lmipl_func_tq_vref=1                #was 1 (TQ setting for VREFIN pad control)
+
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_proga_dqdqsdm << 1))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_proga_ck << 2))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_proga_cmd << 3))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_progb_dqdqsdm << 4))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_progb_ck << 5))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_progb_cmd << 6)) 
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_zoutproga_dqdqsdm << 7))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_zoutproga_ck << 8))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_zoutproga_cmd << 9))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_modezi << 10))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_odta << 11))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_odtb << 12)) 
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_usepad_vref << 13))
+    sysconf.SYSCONF_SYS_CFG12.poke(sysconf.SYSCONF_SYS_CFG12.peek() | (lmipl_func_tq_vref << 14))
+    sttp.logging.print_out("sysconf12 %x" % (sysconf.SYSCONF_SYS_CFG12.peek()))
 
     # Adjust proga, progb, zoutproga, and receiver mode for LMI1
-    sysconf.SYSCONF_SYS_CFG16.poke(0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-
+    sysconf.SYSCONF_SYS_CFG16.poke(0xa2000001)
+    lmipl_func_proga_dqdqsdm=1          #was 1
+    lmipl_func_progb_dqdqsdm=1          #was 0
+    lmipl_func_proga_ck=1               #was 1
+    lmipl_func_progb_ck=1               #was 0
+    lmipl_func_proga_cmd=1              #was 1
+    lmipl_func_progb_cmd=1              #was 0
+    lmipl_func_zoutproga_dqdqsdm=0      #was 0
+    lmipl_func_zoutproga_ck=0           #was 0
+    lmipl_func_zoutproga_cmd=0          #was 0
+    lmipl_func_modezi=0                 #was 0 (diff 1.8V receiver; 1 is 1.8V dig CMOS receiver)
+    lmipl_func_odta=1                   #was 1 (a&b : 00=disabled, 01 or 10 = 150ohms, 11=75ohms)
+    lmipl_func_odtb=1                   #was 1  
+    lmipl_func_usepad_vref=1            #was 1 (USEPAD setting for VREFIN pad)
+    lmipl_func_tq_vref=1                #was 1 (TQ setting for VREFIN pad control)
+
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_proga_dqdqsdm << 1))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_proga_ck << 2))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_proga_cmd << 3))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_progb_dqdqsdm << 4))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_progb_ck << 5))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_progb_cmd << 6)) 
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_zoutproga_dqdqsdm << 7))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_zoutproga_ck << 8))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_zoutproga_cmd << 9))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_modezi << 10))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_odta << 11))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_odtb << 16)) 
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_usepad_vref << 13))
+    sysconf.SYSCONF_SYS_CFG16.poke(sysconf.SYSCONF_SYS_CFG16.peek() | (lmipl_func_tq_vref << 14))
+    sttp.logging.print_out("sysconf16 %x" % (sysconf.SYSCONF_SYS_CFG16.peek()))
+    
     # Enable AutoPrecharge
     sysconf.SYSCONF_SYS_CFG38.poke(0x000FFD08)
     sysconf.SYSCONF_SYS_CFG39.poke(0x000FFD18)
-
+    
     # Force DLL1 and DLL2 commands of LMI0
     sysconf.SYSCONF_SYS_CFG13.poke(0x00000002)
     sysconf.SYSCONF_SYS_CFG14.poke(0x00000002)
@@ -171,19 +264,11 @@
     sysconf.SYSCONF_SYS_CFG55.poke(0x03fc2004|(0<<10)|((filter&0x7)<<7))
     sysconf.SYSCONF_SYS_CFG56.poke(0x03fc2004|(0<<10)|((filter&0x7)<<7))
 
-    # PDL offsets
-    # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
-    # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
-    #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
-    #sysconf.SYSCONF_CFG43.poke(0x000001F5)
-
-    #TO BE UPDATED FOR 7200/cb102
-    sysconf.SYSCONF_SYS_CFG42.poke(0x00000000)
-    sysconf.SYSCONF_SYS_CFG43.poke(0x00000000)
-
-    sysconf.SYSCONF_SYS_CFG44.poke(0x00000000)
-    sysconf.SYSCONF_SYS_CFG45.poke(0x00000000)
-
+    #PDL offsets
+    sysconf.SYSCONF_SYS_CFG42.poke(0x00000000|(0x1fA<<0)|(0x1fA<<9)|(0x1fA<<18))
+    sysconf.SYSCONF_SYS_CFG43.poke(0x00000000|(0x1fA<<0)|(0xa<<18))
+    sysconf.SYSCONF_SYS_CFG44.poke(0x00000000|(0x1fA<<0)|(0x1fA<<9)|(0x1fA<<18))
+    sysconf.SYSCONF_SYS_CFG45.poke(0x00000000|(0x1fA<<0))
 
 #  cb102 EMI Configuration
 def cb102_emi_configure():
@@ -205,11 +290,19 @@
 
     # Bank 1 - Not configured
 
-    # Bank 2 - Not configured
+    # Bank 2 - 16MB DVB-CI at address 0x03000000 -> 0x03FFFFFF
+    emi.EMI_BANK2_EMICONFIGDATA0.poke(0x002046f9)
+    emi.EMI_BANK2_EMICONFIGDATA1.poke(0xa5a00000)
+    emi.EMI_BANK2_EMICONFIGDATA2.poke(0xa5a20000)
+    emi.EMI_BANK2_EMICONFIGDATA3.poke(0x00000000)
 
     # Bank 3 - Not configured
 
-    # Bank 4 - Not configured
+    # Bank 4 - EPLD Registers at address 0x05000000 -> 0x05FFFFFF
+    emi.EMI_BANK4_EMICONFIGDATA0.poke(0x042086f1)
+    emi.EMI_BANK4_EMICONFIGDATA1.poke(0x8a002200)
+    emi.EMI_BANK4_EMICONFIGDATA2.poke(0x8a004200)
+    emi.EMI_BANK4_EMICONFIGDATA3.poke(0x00000000)
 
     # Program other EMI registers
     emi.EMI_GENCFG.poke(0x00000050)
@@ -222,7 +315,8 @@
 
     # SDRAM Timing Register
     lmi.LMI_STR_0.poke(0xcd2db41b)
-    lmi.LMI_STR_1.poke(0x002202d6)
+    lmi.LMI_STR_1.poke(0x00222ed6)
+
 
     # SDRAM Row Attribute 0
     # lmi base address 0x08000000 + 256Mbytes
@@ -232,9 +326,6 @@
     # lmi base address 0x08000000 + 256Mbytes
     lmi.LMI_SDRA1_0.poke(0x18001a20)
 
-    # SDRAx can be reset later after detection
-    # of 'SE' mode see cb102_se_mode_prep
-
     # SDRAM Control Register
     sttp.stmc.delay(200000)
     # Enable clock with NOP command
@@ -266,21 +357,18 @@
     lmi.LMI_SCR_0.poke(0x00020021)
 
     # Issue EMRS2
-#    lmi.LMI_SDMR0_0.poke(0x00000800)
     lmi.LMI_SDMR0_0.poke(0x00010000)
 
     # Issue EMRS3
-#    lmi.LMI_SDMR0_0.poke(0x00000c00)
     lmi.LMI_SDMR0_0.poke(0x00018000)
 
     # Issue EMRS1 to enable DLL
-#    lmi.LMI_SDMR0_0.poke(0x00000400)
     lmi.LMI_SDMR0_0.poke(0x00008004)
 
     # Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
-#    lmi.LMI_SDMR0_0.poke(0x00002353)
     lmi.LMI_SDMR0_0.poke(0x00000b53)
 
+
     # Wait NOP command for 400 nsec
     lmi.LMI_SCR_0.poke(0x00020021)
     lmi.LMI_SCR_0.poke(0x00020021)
@@ -300,14 +388,13 @@
     lmi.LMI_SCR_0.poke(0x00020024)
 
     # Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
-#    lmi.LMI_SDMR0_0.poke(0x00002253)
     lmi.LMI_SDMR0_0.poke(0x00000a53)
 
     # Issue EMRS1 for OCD calibration default
-#    lmi.LMI_SDMR0_0.poke(0x000007c4)
+    lmi.LMI_SDMR0_0.poke(0x00008384)
 
     # Issue EMRS1 for OCD calibration exit
-#    lmi.LMI_SDMR0_0.poke(0x00000404)
+    lmi.LMI_SDMR0_0.poke(0x00008004)
 
     # Enable auto refresh
     lmi.LMI_MIM_0.poke(0x07f6035b)
@@ -316,9 +403,8 @@
     lmi.LMI_SCR_0.poke(0x00020021)
     lmi.LMI_SCR_0.poke(0x00020021)
 
-#    lmi.LMI_GCC_0.poke(0x00382003)
     lmi.LMI_GCC_0.poke(0x00000000)
-
+    
     sttp.pokepeek.poke(0xa8000000, 0x0)
     sttp.pokepeek.poke(0xa8000000, 0xaaaaaaaa)
     sttp.logging.print_out("LMI0 0xAAAAAAAA check=0x%08x" % (sttp.pokepeek.peek(0xa8000000)))
@@ -328,7 +414,7 @@
     sttp.pokepeek.poke(0xa8002000, 0x0)
     sttp.pokepeek.poke(0xa8002000, 0x12345678)
     sttp.logging.print_out("LMI0 0x12345678 check=0x%08x" % (sttp.pokepeek.peek(0xa8002000)))
-
+    
 # cb102 LMI1 Configuration
 def cb102_lmi1_configure():
     lmi = sttp_root.sti7200.LMI1.st40_lmigp_regs
@@ -337,7 +423,7 @@
 
     # SDRAM Timing Register
     lmi.LMI_STR_0.poke(0xcd2db41b)
-    lmi.LMI_STR_1.poke(0x002202d6)
+    lmi.LMI_STR_1.poke(0x00222ed6)
 
     # SDRAM Row Attribute 0
     # lmi base address 0x18000000 + 64Mbytes
@@ -346,7 +432,7 @@
     # SDRAM Row Attribute 1
     # lmi base address 0x18000000 + 64Mbytes
     lmi.LMI_SDRA1_0.poke(0x1c001a20)
-
+    
     # SDRAM Control Register
     sttp.stmc.delay(200000)
     # Enable clock with NOP command
@@ -378,19 +464,15 @@
     lmi.LMI_SCR_0.poke(0x00020021)
 
     # Issue EMRS2
-#    lmi.LMI_SDMR0_0.poke(0x00000800)
     lmi.LMI_SDMR0_0.poke(0x00010000)
 
     # Issue EMRS3
-#    lmi.LMI_SDMR0_0.poke(0x00000c00)
     lmi.LMI_SDMR0_0.poke(0x00018000)
 
     # Issue EMRS1 to enable DLL
-#    lmi.LMI_SDMR0_0.poke(0x00000400)
     lmi.LMI_SDMR0_0.poke(0x00008004)
 
     # Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
-#    lmi.LMI_SDMR0_0.poke(0x00002353)
     lmi.LMI_SDMR0_0.poke(0x00000b53)
 
     # Wait NOP command for 400 nsec
@@ -412,14 +494,13 @@
     lmi.LMI_SCR_0.poke(0x00020024)
 
     # Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
-#    lmi.LMI_SDMR0_0.poke(0x00002253)
     lmi.LMI_SDMR0_0.poke(0x00000a53)
 
     # Issue EMRS1 for OCD calibration default
-#    lmi.LMI_SDMR0_0.poke(0x000007c4)
+    lmi.LMI_SDMR0_0.poke(0x00008384)
 
     # Issue EMRS1 for OCD calibration exit
-#    lmi.LMI_SDMR0_0.poke(0x00000404)
+    lmi.LMI_SDMR0_0.poke(0x00008004)
 
     # Enable auto refresh
     lmi.LMI_MIM_0.poke(0x07f6035b)
@@ -428,7 +509,6 @@
     lmi.LMI_SCR_0.poke(0x00020021)
     lmi.LMI_SCR_0.poke(0x00020021)
 
-#    lmi.LMI_GCC_0.poke(0x00382003)
     lmi.LMI_GCC_0.poke(0x00000000)
 
     sttp.pokepeek.poke(0xb8000000, 0x0)
@@ -452,10 +532,14 @@
     sysconf.SYSCONF_SYS_CFG38.poke((sysconf.SYSCONF_SYS_CFG38.peek() & 0xFFFFFF00) | 0x00000040)
     sysconf.SYSCONF_SYS_CFG39.poke((sysconf.SYSCONF_SYS_CFG39.peek() & 0xFFFFFF00) | 0x00000080)
     # Change LMI upper bound addresses
-    lmi0.LMI_SDRA0_0.poke(0x50001a00)
-    lmi0.LMI_SDRA1_0.poke(0x50001a00)
-    lmi1.LMI_SDRA0_0.poke(0x90001a00)
-    lmi1.LMI_SDRA1_0.poke(0x90001a00)
+    #lmi0.LMI_SDRA0_0.poke(0x50001a00)
+    #lmi0.LMI_SDRA1_0.poke(0x50001a00)
+    #lmi1.LMI_SDRA0_0.poke(0x90001a00)
+    #lmi1.LMI_SDRA1_0.poke(0x90001a00)
+    lmi0.LMI_SDRA0_0.poke((lmi0.LMI_SDRA0_0.peek() & 0x001FFFFF) | 0x50000000)
+    lmi0.LMI_SDRA1_0.poke((lmi0.LMI_SDRA1_0.peek() & 0x001FFFFF) | 0x50000000)
+    lmi1.LMI_SDRA0_0.poke((lmi1.LMI_SDRA0_0.peek() & 0x001FFFFF) | 0x90000000)
+    lmi1.LMI_SDRA1_0.poke((lmi1.LMI_SDRA1_0.peek() & 0x001FFFFF) | 0x90000000)
 
 def cb102_switch_on_se(mode):
     cb102_se_mode_prep()
@@ -464,22 +548,29 @@
     st40_pmb_regs.st40_pmb_control_initialise()
     st40_pmb_regs.st40_clear_all_pmbs()
     if mode=="seuc":
-        # Enable (as un-cached) 256MB + 256MB in the PMB
         st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128, 0, 0, 1)
-        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128, 0, 0, 1)
+        #st40_pmb_regs.st40_set_pmb(1, 0xa0, 0x80, 128, 0, 0, 1)
+	st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128, 0, 0, 1)
         st40_pmb_regs.st40_set_pmb(2, 0xa0, 0x80, 128, 0, 0, 1)
         st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x88, 128, 0, 0, 1)
     elif mode=="se29":
         st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128)
-        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x80, 128)
-        st40_pmb_regs.st40_set_pmb(2, 0xa0, 0x40, 128, 0, 0, 1)
-        st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x80, 128, 0, 0, 1)
+        #st40_pmb_regs.st40_set_pmb(1, 0x88, 0x80, 128)
+        #st40_pmb_regs.st40_set_pmb(2, 0xa0, 0x40, 128, 0, 0, 1)
+        #st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x80, 128, 0, 0, 1) 
+	st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
+        st40_pmb_regs.st40_set_pmb(2, 0x90, 0x80, 128)
+        st40_pmb_regs.st40_set_pmb(3, 0x98, 0x88, 128)
+        st40_pmb_regs.st40_set_pmb(4, 0xa0, 0x40, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(5, 0xa8, 0x48, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(6, 0xb0, 0x80, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(7, 0xb8, 0x88, 128, 0, 0, 1)
     else: # Default is normal SE mode
-        # Enable (as cached) 256MB + 256MB in the PMB
         st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128)
-        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
+        #st40_pmb_regs.st40_set_pmb(1, 0xa0, 0x80, 128)
+	st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
         st40_pmb_regs.st40_set_pmb(2, 0xa0, 0x80, 128)
-        st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x88, 128)
+	st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x88, 128)
 
     # Switch to 32-bit SE mode
     st40_pmb_regs.st40_enhanced_mode(1)
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb161/cb161.py opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb161/cb161.py
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb161/cb161.py	1970-01-01 00:00:00.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb161/cb161.py	2009-02-05 12:41:35.521494762 +0000
@@ -0,0 +1,480 @@
+# TargetScript for connecting to and disconnecting from an cb161 (STi7200)
+
+import sttp
+import sttp.logging
+import sttp.targetpack
+import sttp.stmc
+
+# TargetPack imports
+import st40_pmb_regs
+import sti7200
+import utilities
+
+global sttp_root
+sttp_root = sttp.targetpack.get_tree()
+
+def cb161_connect(parameters):
+    sttp.logging.print_out("cb161 connect start - parameters", parameters)
+
+    # is there a user supplied module and funtion to call?
+    utilities.import_user_module(parameters)
+
+    if parameters.has_key("no_init") and (int(parameters["no_init"]) == 1):
+        return
+
+    p = sttp.stmc.get_target_params()
+    root = sttp.targetpack.get_tree()
+    # Add the board TargetPack parameters
+    p.update(root.parameters)
+    
+    # TCK must be slow until ClockGen setup to run CPU at full speed
+    utilities.set_tck_frequency(True, parameters)
+
+    # Connect to STi7200 SoC
+    sti7200.connect(parameters)
+
+    if not (parameters.has_key("no_pokes") and (int(parameters["no_pokes"]) == 1)):
+        sttp.pokepeek.enable()
+        cb = sttp.targetpack.get_callback("pre_poke")
+        if cb: 
+            cb(parameters)
+        
+        sttp.logging.print_out( "cb161 initialization start ..." )
+        cb = sttp.targetpack.get_callback("setup_pokes")
+        if cb: 
+            cb(parameters)
+        else:
+            cb161_setup(parameters)
+
+            if parameters.has_key("boot_companions") and (int(parameters["boot_companions"]) == 0):
+                pass
+            else:
+                sti7200.sti7200_boot_companions(parameters)
+
+        cb = sttp.targetpack.get_callback("post_poke")
+        if cb: 
+            cb(parameters)
+
+    utilities.set_tck_frequency(False, parameters)
+    
+    # NEVER, EVER change TCK after calling this
+    sti7200.complete_connect(parameters)
+    
+    sttp.logging.print_out( "cb161 initialization complete" )
+
+def cb161_disconnect():
+    pass
+
+# Get the cb161 SoC and board versions
+def cb161_version():
+    # Return a tuple of STi7200 SoC version and PCB version from EPLD register
+    return (sti7200.sti7200_version(), sttp.pokepeek.peek(0xa5020000) & 0xFF)
+
+# Configure the cb161
+def cb161_setup(parameters):
+    
+    if not (parameters.has_key("no_clockgen_config") and (int(parameters["no_clockgen_config"]) == 1)):
+        cb161_clockgen_configure()
+    # Use test_pokepeek_timeout in conjunction with no_clockgen_config to cause access to hang.
+    if parameters.has_key("test_pokepeek_timeout"):
+        sttp.logging.print_out("Testing peek from LMI0")
+        sttp.logging.print_out("TEST Peek from LMI0 : $s\n" % (sttp.pokepeek.peek(0xa800000)))
+    cb161_detect()
+    sti7200.sti7200_displayclocks()
+    cb161_sysconf_configure()   
+    cb161_emi_configure()
+    cb161_lmi0_configure()
+    cb161_lmi1_configure()
+
+    
+    if parameters.has_key("se") and (int(parameters["se"]) == 1):
+        cb161_switch_on_se("se")
+    elif parameters.has_key("seuc") and (int(parameters["seuc"]) == 1):
+        cb161_switch_on_se("seuc")
+    elif parameters.has_key("se29") and (int(parameters["se29"]) == 1):
+        cb161_switch_on_se("se29")
+       
+    ccn = sttp_root.sti7200.st40.CCN.st40_ccn_regs
+    ccn.CCN_CCR.poke(0x8000090d)
+    
+# cb161 CLOCKGEN Configuration
+def cb161_clockgen_configure():
+
+    # Set CKGA_PLL0 nominal to 900MHz
+    sti7200.sti7200_set_clockgen_a_newpll0(0x01, 0x0f)
+
+    # Set CKGA_PLL1 nominal to 450MHz
+    sti7200.sti7200_set_clockgen_a_pll1(0x01, 0x0f)
+
+    # Set CKGA_PLL2 nominal to 800MHz
+    sti7200.sti7200_set_clockgen_a_pll2(0x03, 0x28, 0x0)
+
+    # Set CKGB_PLL0 nominal to 800MHz
+    sti7200.sti7200_set_clockgen_b_pll0(0x03, 0x28, 0x0)
+
+    # Set LMI clock to 800MHz
+    sti7200.sti7200_set_clockgen_lmi_pll(0x03, 0x50)
+
+# cb161 detect chip and board config
+def cb161_detect():
+    sysconf = sttp_root.sti7200.SYSCONF.sti7200_sysconf_regs
+    deviceid = sti7200.sti7200_deviceid()
+    sttp.logging.print_out("Device id : 0x%08x" % deviceid)
+    chipversion = sti7200.sti7200_version()    
+    sttp.logging.print_out("STi7200 cut %x" % chipversion)
+    modepins = sysconf.SYSCONF_SYS_STA01.peek()
+    sttp.logging.print_out("Mode_pin : 0x%08x" % modepins)
+    
+# cb161 SYSCONF Configuration
+def cb161_sysconf_configure():
+    sysconf = sttp_root.sti7200.SYSCONF.sti7200_sysconf_regs
+    
+    # PLI_CLOCK_ENABLE set to 0
+    sysconf.SYSCONF_SYS_CFG58.poke(sysconf.SYSCONF_SYS_CFG58.peek() & ~(1<<0))
+
+    # LMI sub-sys & pl exit from reset
+    sysconf.SYSCONF_SYS_CFG11.poke(sysconf.SYSCONF_SYS_CFG11.peek() | 0x00000001 | 1 << 27)
+    sysconf.SYSCONF_SYS_CFG15.poke(sysconf.SYSCONF_SYS_CFG15.peek() | 0x00000001 | 1 << 27)
+
+    sttp.stmc.delay(200)
+
+    # PLI_CLOCK_ENABLE set to 1
+    sysconf.SYSCONF_SYS_CFG58.poke(sysconf.SYSCONF_SYS_CFG58.peek() | (1<<0))
+
+    # Check both DLL on LMI0 are locked
+    sysconf.SYSCONF_SYS_STA03.while_and_ne((1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+    # Check both DLL on LMI1 are locked
+    sysconf.SYSCONF_SYS_STA05.while_and_ne((1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
+
+    # Adjust proga, progb, zoutproga, and receiver mode for LMI0
+    sysconf.SYSCONF_SYS_CFG12.poke(0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+    # Adjust proga, progb, zoutproga, and receiver mode for LMI1
+    sysconf.SYSCONF_SYS_CFG16.poke(0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+
+    # Enable AutoPrecharge
+    sysconf.SYSCONF_SYS_CFG38.poke(0x000FFD08)
+    sysconf.SYSCONF_SYS_CFG39.poke(0x000FFD18)
+
+    # Force DLL1 and DLL2 commands of LMI0
+    sysconf.SYSCONF_SYS_CFG13.poke(0x00000002)
+    sysconf.SYSCONF_SYS_CFG14.poke(0x00000002)
+
+    # Force DLL1 and DLL2 commands of LMI1
+    sysconf.SYSCONF_SYS_CFG17.poke(0x00000002)
+    sysconf.SYSCONF_SYS_CFG18.poke(0x00000002)
+
+    # Set cfg55 and cfg56
+    filter = 7
+    sysconf.SYSCONF_SYS_CFG55.poke(0x03fc2004|(0<<10)|((filter&0x7)<<7))
+    sysconf.SYSCONF_SYS_CFG56.poke(0x03fc2004|(0<<10)|((filter&0x7)<<7))
+
+    # PDL offsets
+    # -11=1F5 => 42=0x07D7EBF5, 43=0x000001F5
+    # -21=1EB => 42=0x07afd7eb, 43=0x000001eb
+    #sysconf.SYSCONF_CFG42.poke(0x07D7EBF5)
+    #sysconf.SYSCONF_CFG43.poke(0x000001F5)
+
+    #TO BE UPDATED FOR 7200/cb161
+    sysconf.SYSCONF_SYS_CFG42.poke(0x00000000)
+    sysconf.SYSCONF_SYS_CFG43.poke(0x00000000)
+
+    sysconf.SYSCONF_SYS_CFG44.poke(0x00000000)
+    sysconf.SYSCONF_SYS_CFG45.poke(0x00000000)
+
+
+#  cb161 EMI Configuration
+def cb161_emi_configure():
+    emi = sttp_root.sti7200.EMI.st40_emi_regs
+    # Reprogram bank addresses
+    emi.EMI_BANK_ENABLE.poke(0x00000005)
+    ## NOTE: bits [0,5] define bottom address bits [22,27] of bank
+    emi.EMI_BANK0_BASEADDRESS.poke(0x00000000)
+    emi.EMI_BANK1_BASEADDRESS.poke(0x00000008)
+    emi.EMI_BANK2_BASEADDRESS.poke(0x0000000c)
+    emi.EMI_BANK3_BASEADDRESS.poke(0x00000010)
+    emi.EMI_BANK4_BASEADDRESS.poke(0x00000014)
+
+    # Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff
+    emi.EMI_BANK0_EMICONFIGDATA0.poke(0x021016d1)
+    emi.EMI_BANK0_EMICONFIGDATA1.poke(0x9d200000)
+    emi.EMI_BANK0_EMICONFIGDATA2.poke(0x9d220000)
+    emi.EMI_BANK0_EMICONFIGDATA3.poke(0x00000000)
+
+    # Bank 1 - NAND Bank 1 (configured from kernel)
+    # Bank 2 - NAND Bank 2 (configured from kernel)
+    # Bank 3 - Not configured
+    # Bank 4 - Not configured
+
+    # Program other EMI registers
+    emi.EMI_GENCFG.poke(0x00004050)
+
+# cb161 LMI0 Configuration
+def cb161_lmi0_configure():
+    lmi = sttp_root.sti7200.LMI0.st40_lmigp_regs
+    lmi.LMI_MIM_0.poke(0x07f6015b)
+    lmi.LMI_MIM_1.poke(0x000000b0)
+
+    # SDRAM Timing Register
+    lmi.LMI_STR_0.poke(0xcd2db41b)
+    lmi.LMI_STR_1.poke(0x002202d6)
+
+    # SDRAM Row Attribute 0
+    # lmi base address 0x08000000 + 256Mbytes
+    lmi.LMI_SDRA0_0.poke(0x18001a20)
+
+    # SDRAM Row Attribute 1
+    # lmi base address 0x08000000 + 256Mbytes
+    lmi.LMI_SDRA1_0.poke(0x18001a20)
+
+    # SDRAM Control Register
+    sttp.stmc.delay(200000)
+    # Enable clock with NOP command
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020023)
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Precharge all
+    lmi.LMI_SCR_0.poke(0x00020022)
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Issue EMRS2
+#    lmi.LMI_SDMR0_0.poke(0x00000800)
+    lmi.LMI_SDMR0_0.poke(0x00010000)
+
+    # Issue EMRS3
+#    lmi.LMI_SDMR0_0.poke(0x00000c00)
+    lmi.LMI_SDMR0_0.poke(0x00018000)
+
+    # Issue EMRS1 to enable DLL
+#    lmi.LMI_SDMR0_0.poke(0x00000400)
+    lmi.LMI_SDMR0_0.poke(0x00008004)
+
+    # Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
+#    lmi.LMI_SDMR0_0.poke(0x00002353)
+    lmi.LMI_SDMR0_0.poke(0x00000b53)
+
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Precharge all
+    lmi.LMI_SCR_0.poke(0x00020022)
+    # 2 CBR (auto refresh)
+    lmi.LMI_SCR_0.poke(0x00020024)
+    lmi.LMI_SCR_0.poke(0x00020024)
+
+    # Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
+#    lmi.LMI_SDMR0_0.poke(0x00002253)
+    lmi.LMI_SDMR0_0.poke(0x00000a53)
+
+    # Issue EMRS1 for OCD calibration default
+#    lmi.LMI_SDMR0_0.poke(0x000007c4)
+
+    # Issue EMRS1 for OCD calibration exit
+#    lmi.LMI_SDMR0_0.poke(0x00000404)
+
+    # Enable auto refresh
+    lmi.LMI_MIM_0.poke(0x07f6035b)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+#    lmi.LMI_GCC_0.poke(0x00382003)
+    lmi.LMI_GCC_0.poke(0x00000000)
+    
+    sttp.pokepeek.poke(0xa8000000, 0x0)
+    sttp.pokepeek.poke(0xa8000000, 0xaaaaaaaa)
+    sttp.logging.print_out("LMI0 0xAAAAAAAA check=0x%08x" % (sttp.pokepeek.peek(0xa8000000)))
+    sttp.pokepeek.poke(0xa8001000, 0x0)
+    sttp.pokepeek.poke(0xa8001000, 0x55555555)
+    sttp.logging.print_out("LMI0 0x55555555 check=0x%08x" % (sttp.pokepeek.peek(0xa8001000)))
+    sttp.pokepeek.poke(0xa8002000, 0x0)
+    sttp.pokepeek.poke(0xa8002000, 0x12345678)
+    sttp.logging.print_out("LMI0 0x12345678 check=0x%08x" % (sttp.pokepeek.peek(0xa8002000)))
+    
+# cb161 LMI1 Configuration
+def cb161_lmi1_configure():
+    lmi = sttp_root.sti7200.LMI1.st40_lmigp_regs
+    lmi.LMI_MIM_0.poke(0x07f6015b)
+    lmi.LMI_MIM_1.poke(0x000000b0)
+
+    # SDRAM Timing Register
+    lmi.LMI_STR_0.poke(0xcd2db41b)
+    lmi.LMI_STR_1.poke(0x002202d6)
+
+    # SDRAM Row Attribute 0
+    # lmi base address 0x18000000 + 64Mbytes
+    lmi.LMI_SDRA0_0.poke(0x1c001a20)
+
+    # SDRAM Row Attribute 1
+    # lmi base address 0x18000000 + 64Mbytes
+    lmi.LMI_SDRA1_0.poke(0x1c001a20)
+
+    # SDRAM Control Register
+    sttp.stmc.delay(200000)
+    # Enable clock with NOP command
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020023)
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Precharge all
+    lmi.LMI_SCR_0.poke(0x00020022)
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Issue EMRS2
+#    lmi.LMI_SDMR0_0.poke(0x00000800)
+    lmi.LMI_SDMR0_0.poke(0x00010000)
+
+    # Issue EMRS3
+#    lmi.LMI_SDMR0_0.poke(0x00000c00)
+    lmi.LMI_SDMR0_0.poke(0x00018000)
+
+    # Issue EMRS1 to enable DLL
+#    lmi.LMI_SDMR0_0.poke(0x00000400)
+    lmi.LMI_SDMR0_0.poke(0x00008004)
+
+    # Issue MRS with DLL reset, CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
+#    lmi.LMI_SDMR0_0.poke(0x00002353)
+    lmi.LMI_SDMR0_0.poke(0x00000b53)
+
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Precharge all
+    lmi.LMI_SCR_0.poke(0x00020022)
+    # 2 CBR (auto refresh)
+    lmi.LMI_SCR_0.poke(0x00020024)
+    lmi.LMI_SCR_0.poke(0x00020024)
+
+    # Issue MRS with CAS 5, Write recovery 6, Sequentiel, Burst lengh 8
+#    lmi.LMI_SDMR0_0.poke(0x00002253)
+    lmi.LMI_SDMR0_0.poke(0x00000a53)
+
+    # Issue EMRS1 for OCD calibration default
+#    lmi.LMI_SDMR0_0.poke(0x000007c4)
+
+    # Issue EMRS1 for OCD calibration exit
+#    lmi.LMI_SDMR0_0.poke(0x00000404)
+
+    # Enable auto refresh
+    lmi.LMI_MIM_0.poke(0x07f6035b)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+#    lmi.LMI_GCC_0.poke(0x00382003)
+    lmi.LMI_GCC_0.poke(0x00000000)
+
+    sttp.pokepeek.poke(0xb8000000, 0x0)
+    sttp.pokepeek.poke(0xb8000000, 0xaaaaaaaa)
+    sttp.logging.print_out("LMI1 0xAAAAAAAA check=0x%08x" % (sttp.pokepeek.peek(0xb8000000)))
+    sttp.pokepeek.poke(0xb8001000, 0x0)
+    sttp.pokepeek.poke(0xb8001000, 0x55555555)
+    sttp.logging.print_out("LMI1 0x55555555 check=0x%08x" % (sttp.pokepeek.peek(0xb8001000)))
+    sttp.pokepeek.poke(0xb8002000, 0x0)
+    sttp.pokepeek.poke(0xb8002000, 0x12345678)
+    sttp.logging.print_out("LMI1 0x12345678 check=0x%08x" % (sttp.pokepeek.peek(0xb8002000)))
+
+# SE mode functions setup the PMBs based on the RAM fitted to the board
+
+# cb161 switch to 32-bit SE mode
+def cb161_se_mode_prep():
+    sysconf = sttp_root.sti7200.SYSCONF.sti7200_sysconf_regs
+    lmi0 = sttp_root.sti7200.LMI0.st40_lmigp_regs
+    lmi1 = sttp_root.sti7200.LMI1.st40_lmigp_regs
+    # Poke LMI control register to move LMI base addresses to SE mode addresses
+    sysconf.SYSCONF_SYS_CFG38.poke((sysconf.SYSCONF_SYS_CFG38.peek() & 0xFFFFFF00) | 0x00000040)
+    sysconf.SYSCONF_SYS_CFG39.poke((sysconf.SYSCONF_SYS_CFG39.peek() & 0xFFFFFF00) | 0x00000080)
+    # Change LMI upper bound addresses
+    lmi0.LMI_SDRA0_0.poke((lmi0.LMI_SDRA0_0.peek() & 0x001FFFFF) | 0x50000000)
+    lmi0.LMI_SDRA1_0.poke((lmi0.LMI_SDRA1_0.peek() & 0x001FFFFF) | 0x50000000)
+    lmi1.LMI_SDRA0_0.poke((lmi1.LMI_SDRA0_0.peek() & 0x001FFFFF) | 0x90000000)
+    lmi1.LMI_SDRA1_0.poke((lmi1.LMI_SDRA1_0.peek() & 0x001FFFFF) | 0x90000000)
+
+def cb161_switch_on_se(mode):
+    cb161_se_mode_prep()
+
+    # Configure the PMBs
+    st40_pmb_regs.st40_pmb_control_initialise()
+    st40_pmb_regs.st40_clear_all_pmbs()
+    if mode=="seuc":
+        st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(2, 0xa0, 0x80, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x88, 128, 0, 0, 1)
+    elif mode=="se29":
+        st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128)
+        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
+        st40_pmb_regs.st40_set_pmb(2, 0x90, 0x80, 128)
+        st40_pmb_regs.st40_set_pmb(3, 0x98, 0x88, 128)
+        st40_pmb_regs.st40_set_pmb(4, 0xa0, 0x40, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(5, 0xa8, 0x48, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(6, 0xb0, 0x80, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(7, 0xb8, 0x88, 128, 0, 0, 1)
+    else: # Default is normal SE mode
+        st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128)
+        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
+        st40_pmb_regs.st40_set_pmb(2, 0xa0, 0x80, 128)
+        st40_pmb_regs.st40_set_pmb(3, 0xa8, 0x88, 128)
+
+    # Switch to 32-bit SE mode
+    st40_pmb_regs.st40_enhanced_mode(1)
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb161/cb161.xml opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb161/cb161.xml
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb161/cb161.xml	1970-01-01 00:00:00.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb161/cb161.xml	2009-02-05 12:41:35.521494762 +0000
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<spirit:component xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.2" xmlns:sttp="http://www.st.com/XMLSchema/TargetPack">
+  <spirit:vendor>ST</spirit:vendor>
+  <spirit:library>cb161</spirit:library>
+  <spirit:name>cb161</spirit:name>
+  <spirit:version>1.0</spirit:version>
+  <spirit:model>
+    <spirit:views>
+      <spirit:view>
+        <spirit:name>cb161</spirit:name>
+        <spirit:envIdentifier>::</spirit:envIdentifier>
+        <spirit:hierarchyRef spirit:vendor="ST" spirit:library="cb161_design" spirit:name="cb161_design" spirit:version="1.0"/>
+      </spirit:view>
+    </spirit:views>
+  </spirit:model>
+
+  <!-- Board/SoC configuration -->
+  <spirit:configurators>
+     <sttp:initFunction>cb161_connect</sttp:initFunction>
+     <sttp:deInitFunction>cb161_disconnect</sttp:deInitFunction>
+  </spirit:configurators>
+
+  <!-- Files used to for board/SoC configuration -->
+  <spirit:fileSets>
+    <spirit:fileSet spirit:fileSetId="TargetScript">
+      <spirit:file>
+        <spirit:name>cb161.py</spirit:name>
+        <spirit:fileType>unknown</spirit:fileType>
+      </spirit:file>
+    </spirit:fileSet>
+  </spirit:fileSets>
+
+  <!-- Files used to for board/SoC configuration -->
+  <spirit:parameter spirit:name="jtagpinout">STMC_Type_A</spirit:parameter>
+  <spirit:parameter spirit:name="tck_bypass_max">12500000</spirit:parameter>
+  <spirit:parameter spirit:name="tck_tapmux_max">25000000</spirit:parameter>
+  <spirit:parameter spirit:name="tck_stmc1_max">10000000</spirit:parameter>
+
+  <!--debugram reserved for ST200 toolset when in 29 bit mode-->
+  <spirit:parameter spirit:name="debugram_base">0x1BFFC000</spirit:parameter>
+  <spirit:parameter spirit:name="debugram_size">16384</spirit:parameter>
+
+  <!--debugram reserved for ST200 toolset when in 32 bit (Space Enhanced) mode-->
+  <spirit:parameter spirit:name="debugram_base_se">0x87FFC000</spirit:parameter>
+  <spirit:parameter spirit:name="debugram_size_se">16384</spirit:parameter>
+</spirit:component>
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb161/cb161_design.xml opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb161/cb161_design.xml
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/cb161/cb161_design.xml	1970-01-01 00:00:00.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/cb161/cb161_design.xml	2009-02-05 12:41:35.521494762 +0000
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<spirit:design
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.2"
+  xmlns:sttp="http://www.st.com/XMLSchema/TargetPack">
+
+  <spirit:vendor>ST</spirit:vendor>
+  <spirit:library>cb161_design</spirit:library>
+  <spirit:name>cb161_design</spirit:name>
+  <spirit:version>1.0</spirit:version>
+
+  <spirit:componentInstances>
+    <spirit:componentInstance>
+      <spirit:instanceName>sti7200</spirit:instanceName>
+      <spirit:componentRef spirit:library="sti7200" spirit:name="sti7200"
+                           spirit:vendor="ST" spirit:version="1.0" />
+    </spirit:componentInstance>
+  </spirit:componentInstances>
+
+</spirit:design>
+
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/mb680/mb680.py opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb680/mb680.py
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/mb680/mb680.py	2009-02-05 12:42:19.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb680/mb680.py	2009-02-05 12:41:35.521494762 +0000
@@ -176,7 +176,8 @@
         clockgen_configure(parameters)
 
     stx7105.displayclocks()
-    ddr2_pli_configure(parameters)
+    sysconf_configure(parameters)
+    # ddr2_pli_configure(parameters)
     emi_configure()
     lmi0_configure(parameters)
 
@@ -204,6 +205,9 @@
 
     # Ensure USB is powered by SYSCLKIN/OSC
     sysconf.SYSCONF_CFG40.poke((sysconf.SYSCONF_CFG40.peek() | (0x1<<2)))
+    # Since cut 2, to start USB PLL to generate 48 MHz
+    if stx7105.version() != 0xA0:
+        sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() | (0x1<<7)))
 
     # Ensure clockgen B is powered by SYSCLKIN/OSC
     sttp.pokepeek.poke(0xfe000010, 0xc0de)
@@ -334,7 +338,8 @@
     else:
         lmi2xfreq = 800
     set_lmi2x_freq(lmi2xfreq)
-
+    #stx7105.set_clockgen_lmi_pll(0x3, 0x50) to set 800MHz
+    
 
 def set_lmi2x_freq(freq):
     refclock = 30.0
@@ -357,433 +362,55 @@
     stx7105.set_clockgen_lmi_pll(int(pll_rdiv), int(pll_ddiv))
     #sttp.logging.print_out("set_lmi2x_freq: freq=%d.000 rdiv=0x%x, ddiv=0x%x" % (freq, pll_rdiv, pll_ddiv))
 
-def set_field(register, upper, lower, value):
-   content = register.peek()
-   mask = 0
-   for i in range(upper-lower):
-     mask = mask | (1<<(i+lower))
-   value = value << lower
-   content = content & ~mask
-   content = content | value
-   register.poke(content)
-   
 
-# DDR2 PLI Configuration (mostly SYSCONF registers)
-# The PLI is the PadLogic Interface, or PHY, for the external DDR2 SDRAM Memory Parts.
-def ddr2_pli_configure(parameters):
+# SYSCONF Configuration
+def sysconf_configure(parameters):
+
     sysconf = sttp_root.stx7105.SYSCONF.stx7105_sysconf_regs
     
-    # LMI settings
-    lmi_pwrd_req               = 0
-    lmi_hp_en_ap               = 0x3
-    lmi_lp_en_ap               = 0x3
-    lmi_mem_base_addr          = 0x0c
+    # PLI_CLOCK_ENABLE set to 0
+    sysconf.SYSCONF_CFG04.poke(sysconf.SYSCONF_CFG04.peek() & ~(1<<2))
 
-    #######################################################################################################
-    # Static configuration (before the clock to the PLI,LMI,etc is enabled)
+    # LMI sub-sys & pl exit from reset
+    sysconf.SYSCONF_CFG11.poke(sysconf.SYSCONF_CFG11.peek() | 0x00024001 | 1 << 27)
 
-    # PLI_CLOCK_ENABLE set to 0
-    # The default state following reset should be off, so this is redundant.
-    pli_clock_enable = 0    
-    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2)) | pli_clock_enable <<2)
-
-    # Interface with LMI
-    double_width               = 0
-    retime_pli_lmi             = 1
-    # Exit from reset for PLI, LMI, etc.  rst_n_lmi (CFG11.27) rst_n_lmipl (CFG11.0)
-    rst_lmi_n                  = 1
-    # For 7105 default single_rank=1 (CFG11.14)
-    # For 7111 default single_rank=0 (CFG11.17) (Hard wired to 0 in 7111c1, but CSN[1], CKE[1], ODT[1] are bonded.)
-    single_rank                = 1
-    # Control the phase relationship between multiple instances of PLI (0,1,2,3 steps of T/4)
-    phase_shift                = 0
-
-    # Delay Locked Loop for T/4
-    dll1_usr_cmd               = 0
-    dll1_lock_con              = 0
-    dll1_int_cmd_con           = 0
-    dll1_ext_cmd_con           = 0
-    dll1_soft_rst              = 0
-    # There is a further option which controls when the DLL code + offset is loaded into the PDL.
-    #   This is an historical option from DDR1 days.
-    #   For DDR2, since more than one edge can be propagating through the PDL, the timing of the update does not matter.
-    #   However, in order to avoid the requirement for an initial dummy read, keep pdl_clk_opz_dll1=1
-    pdl_clk_opz_dll1           = 1
-
-    # Delay Locked Loop for 3T/4 (or T/2)
-    dll2_usr_cmd               = 0
-    dll2_lock_con              = 0
-    dll2_int_cmd_con           = 0
-    dll2_ext_cmd_con           = 0
-    dll2_soft_rst              = 0
-    # There is a further option which controls when the DLL code + offset is loaded into the PDL.
-    #   This is an historical option from DDR1 days.
-    #   For DDR2, since more than one edge can be propagating through the PDL, the timing of the update does not matter.
-    #   However, in order to avoid the requirement for an initial dummy read, keep pdl_clk_opz_dll2=1
-    pdl_clk_opz_dll2           = 1
-
-    # Filter the output of the DLL before it used by each slave PDL
-    # 0 = no filtering, 7 = maximum filtering
-    filter_shift_param         = 7
-
-    # Read Data Capture Point Positioning
-    usermode_pdl_dqs           = 0
-    dqs0_offset                = 0
-    dqs1_offset                = 0
-    dqs2_offset                = 0
-    dqs3_offset                = 0
-
-    # Read Strobe Valid Positioning (rdqs_valid)
-    # rdqs_valid coarse settings in steps of T/4, separately for rise and fall,
-    #   in positions -2 -1 0 1 2 3, computed as follows:
-    #     rdqs_valid_rise    = rdqs_sel_rise - (rdqs_valid_minus_2 * 2)
-    #     rdqs_valid_fall    = rdqs_sel_fall - (rdqs_valid_minus_2 * 2)
-    # Note that rdqs_valid_minus_2 (0 or 1) is shared across both rise and fall edges 
-    # rdqs_sel_rise and rdqs_sel_rise can have values of 0, 1, 2, 3
-    rdqs_sel_rise        = 1
-    rdqs_sel_fall        = 1
-    rdqs_valid_minus_2   = 1
-    # rdqs_valid fine position is automatically adjusted to T/4 via the DLL
-    #   this can be adjusted via the offset (0x1ff for -256, to 0x0ff for +255)
-    #   or the fine adjust can be completely bypassed using bypass_pdl_dqs_valid (reducing delay by ~ T/4)
-    dqs_valid_offset     = 0x20
-    bypass_pdl_dqs_valid = 0
-    # rdqs_valid also includes a refinement to balance the IOPadBuffer delay and the PCB trace delay
-    bypass_pad_dqs_valid = 0
-    dummy_pcb_trace      = 1
-    # Workaround for observation of lock and command: keep usermode_pdl_dqs_valid=0 and user_command_dqs_valid=0x1ff
-    usermode_pdl_dqs_valid     = 0
-    user_command_dqs_valid     = 0x1ff
-
-    # Control timing of data transfer from capture into FIFO
-    usermode_pdl_dqs270_del    = 0
-    dqs270_del0_offset         = 0
-    dqs270_del1_offset         = 0
-    dqs270_del2_offset         = 0
-    dqs270_del3_offset         = 0
-    # For slower frequencies the delay through the PDL can be set to T/2 (dqs270_del_opz=1), instead of 3T/4
-    dqs270_del_opz             = 0
-    # 0 : 2 flops are used.
-    # 1 : 3 flops are used.
-    # 2 : 4 flops are used.
-    # 3 : 1 flop is used. For test/characterization only.
-    sel_sync_flop_nb           = 0
-    sel_sync_flop_half         = 0
-    sel_clk_phase              = 1
-
-
-    # DDR2 Interface timing options
-    sel_oen_del                = 0
-    # Control the timing of the On Die Termination
-    disable_odtint             = 0
-    # Default ODT timing
-    sel_odt_int_del            = 0
-    force_odt_int_minus_half   = 0
-    # Shrink ODT so it is only active when driven by memory parts
-    #  (So that there is not an edge as the ODT turns on, pulling to centre, when memory is still tri-state)
-    # This setting is desirable for diagnostic statistical edge position detection.
-    # sel_odt_int_del<3,2,1,0> = <0,0,1,1> fall, rise (CFG43.30:27)
-    #sel_odt_int_del            = 3
-    #force_odt_int_minus_half   = 1
-    # For DDR2 the turnaround time between write and read is too short,
-    #  so force the input enable (enable_enzi=0) permenantly, rather than just on reads (enable_enzi=1).
-    # At lower frequencies (say below 533MHz) there is a minor power saving by setting enable_enzi=1.
-    enable_enzi                = 0
+    sttp.stmc.delay(200)
 
-    if parameters.has_key("lmi_16bits_mode"):
-        lower_16bit_only         = 1
-    else:
-        lower_16bit_only         = 0
+    # PLI_CLOCK_ENABLE set to 1
+    sysconf.SYSCONF_CFG04.poke(sysconf.SYSCONF_CFG04.peek() | (1<<2))
+
+    # Check both DLL on LMI0 are locked
+    sysconf.SYSCONF_STA3.while_and_ne((1 << 10) | (1 << 20), (1 << 10) | (1 << 20))
 
-    # IOPadBuffer settings
-    func_pdn_active_hi  = 1
-    func_pu_active_hi   = 0
-    func_pdn_active_lo  = 1
-    func_pu_active_lo   = 0
-    ioref_tq            = 0
-    ioref_ddr_comp      = 0
-    ioref_accurate      = 0
-    ioref_freeze        = 0
-    ioref_comptq        = 0
-    ioref_compen        = 0
-    # 7 bit one hot compensation
-    ioref_rasrc         = 0
-    func_tq_vref        = 1
-    func_usepad_vref    = 1
-    # On Die Termination resistor values
-    # 0 DISABLED
-    # 1 RTT2 = 150 ohms
-    # 2 RTT2 = 150 ohms
-    # 3 RTT1 = 75 ohms
-    func_odt            = 3
-    func_modezi         = 0
     # Adjust proga, progb, zoutproga, and receiver mode for LMI0
-    #Settings for 333Mhz.
-    #PROGA=1
-    #PROGB=0
-    #ZOUTPROGA=0
-    #sysconf.SYSCONF_CFG12.poke(0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
-    #Settings for 400Mhz.
-    #PROGA=1
-    #PROGB=1
-    #ZOUTPROGA=0
-    #sysconf.SYSCONF_CFG12.poke(0xa2007801 | (0x7 << 1) | (0x7 << 4) | (0x0 << 7) | (0x0 << 10))
-    func_zoutproga_abc  = 0
-    func_zoutproga_k    = 0
-    func_zoutproga_d    = 0
-    func_progb_abc      = 1
-    func_progb_k        = 1
-    func_progb_d        = 1
-    func_proga_abc      = 1
-    func_proga_k        = 1
-    func_proga_d        = 1
-    # 0 DDR1 operation mode (2.5V)
-    # 1 DDR2 operation mode (1.8V)
-    func_ddr            = 1
-
-    # Diagnostics
-    if parameters.has_key("diagnose"):
-      pli_reg_access             = int(parameters["diagnose"]) & 0x1
+    sysconf.SYSCONF_CFG12.poke(0xa0007801 | (0x7 << 1) | (0x7 << 4) | (0x0 << 7) | (0x0 << 10))
+
+    # Enable AutoPrecharge
+    sysconf.SYSCONF_CFG38.poke(0x002f000c)
+
+    # Force DLL1 and DLL2 commands of LMI0
+    sysconf.SYSCONF_CFG13.poke(0x00400002)
+    sysconf.SYSCONF_CFG14.poke(0x00000002)
+
+    # Set cfg55
+    if parameters.has_key("lmi_filter"):
+        filter = int(parameters["lmi_filter"])
     else:
-      pli_reg_access             = 0
-    pli_oversample             = 0
-    # Use a non-zero sample_scale to avoid floating nodes
-    sample_scale = 0x7
-    if parameters.has_key("scale"):
-      sample_scale = int(parameters["scale"]) & 0x7
-
-    #RGW080415 These obsolete variable names are not so convenient to use.
-    #force_dqs_valid_minus_half = 0
-    #sel_dqs_valid_del          = 0
-    #ddr2_diag_control          = 4
-
-    # Load all the variables defined above into the various configuration registers
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<28))  | dqs270_del_opz       <<28)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<27))  | rst_lmi_n            <<27)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<17))  | single_rank          <<17)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<16))  | bypass_pdl_dqs_valid <<16)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<15))  | bypass_pad_dqs_valid <<15)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<14))  | single_rank          <<14)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<13))  | enable_enzi          <<13)
-    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<0))   | rst_lmi_n            <<0)
-    
-    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() &
-                            ~((0x1 << 28) |
-                              (0x1 << 27) |
-                              (0x1 << 17) |
-                              (0x1 << 16) |
-                              (0x1 << 15) |
-                              (0x1 << 14) |
-                              (0x1 << 13) |
-                              (0x1 << 0))) |
-                           ((dqs270_del_opz       << 28) |
-                            (rst_lmi_n            << 27) |
-                            (single_rank          << 17) |
-                            (bypass_pdl_dqs_valid << 16) |
-                            (bypass_pad_dqs_valid << 15) |
-                            (single_rank          << 14) |
-                            (enable_enzi          << 13) |
-                            (rst_lmi_n            << 0)))
-
-
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<31))  | func_pdn_active_hi  <<31)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<30))  | func_pu_active_hi   <<30)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<29))  | func_pdn_active_lo  <<29)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<28))  | func_pu_active_lo   <<28)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<27))  | ioref_tq            <<27)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<26))  | ioref_ddr_comp      <<26)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<25))  | ioref_accurate      <<25)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<24))  | ioref_freeze        <<24)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<23))  | ioref_comptq        <<23)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<22))  | ioref_compen        <<22)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x3f<<15)) | ioref_rasrc         <<15)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<14))  | func_tq_vref        <<14)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<13))  | func_usepad_vref    <<13)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x3<<11))  | func_odt            <<11)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<10))  | func_modezi         <<10)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<9))   | func_zoutproga_abc  <<9)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<8))   | func_zoutproga_k    <<8)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<7))   | func_zoutproga_d    <<7)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<6))   | func_progb_abc      <<6)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<5))   | func_progb_k        <<5)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<4))   | func_progb_d        <<4)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<3))   | func_proga_abc      <<3)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<2))   | func_proga_k        <<2)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<1))   | func_proga_d        <<1)
-    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<0))   | func_ddr            <<0)
-
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<22))  | rdqs_valid_minus_2         <<22)
-    #sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<22)) | force_dqs_valid_minus_half <<22)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<21))  | force_odt_int_minus_half   <<21)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<17))  | sel_oen_del                <<17)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1ff<<8)) | dll1_usr_cmd               <<8)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0xf<<4))   | dll1_lock_con              <<4)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<3))   | dll1_int_cmd_con           <<3)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<2))   | dll1_ext_cmd_con           <<2)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<1))   | pdl_clk_opz_dll1           <<1)
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<0))   | dll1_soft_rst              <<0)
-
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1ff<<8)) | dll2_usr_cmd               <<8)
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0xf<<4))   | dll2_lock_con              <<4)
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<3))   | dll2_int_cmd_con           <<3)
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<2))   | dll2_ext_cmd_con           <<2)
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<1))   | pdl_clk_opz_dll2           <<1)
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<0))   | dll2_soft_rst              <<0)
-
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<23))  | sel_sync_flop_nb           <<23)
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<22))  | sel_sync_flop_half         <<22)
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<21))  | sel_clk_phase              <<21)
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<20))  | lmi_pwrd_req               <<20)
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x3<<18))  | lmi_hp_en_ap               <<18)
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x3<<16))  | lmi_lp_en_ap               <<16)
-    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0xff<<0))  | lmi_mem_base_addr          <<0)
-
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x3<<29))  | rdqs_sel_fall              <<29)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x3<<27))  | rdqs_sel_rise              <<27)
-    #sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0xf<<27)) | sel_dqs_valid_del          <<27)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<18))| dqs2_offset                <<18)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<9)) | dqs1_offset                <<9)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<0)) | dqs0_offset                <<0)
-
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1<<31))  | disable_odtint             <<31)
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0xf<<27))  | sel_odt_int_del            <<27)
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<18))| dqs_valid_offset           <<18)
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<0)) | dqs3_offset                <<0)
-
-    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<16))| dqs270_del1_offset         <<16)
-    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<0)) | dqs270_del0_offset         <<0)
-
-    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<16))| dqs270_del3_offset         <<16)
-    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<0)) | dqs270_del2_offset         <<0)
-
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<29))  | usermode_pdl_dqs_valid     <<29)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<28))  | usermode_pdl_dqs270_del    <<28)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<27))  | usermode_pdl_dqs           <<27)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1ff<<18))| user_command_dqs_valid     <<18)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<13))  | retime_pli_lmi             <<13)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x3<<11))  | phase_shift                <<11)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<10))  | lower_16bit_only           <<10)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x7<<7))   | filter_shift_param         <<7)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<6))   | dummy_pcb_trace            <<6)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<5))   | double_width               <<5)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x7<<0))   | sample_scale               <<2)
-    # Defer setting diagnostic features until after DLL codes have been read
-    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_reg_access             <<1)
-    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_oversample             <<0)
-    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1f<<0)) | ddr2_diag_control          <<0)
-
-
-    # Start the clock to the PLI, LMI, etc.
-    pli_clock_enable = 1
-    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2)) | pli_clock_enable <<2)
-    sttp.stmc.delay(10)
-
-    #######################################################################################################
-    # Dynamic configuration (after the clock to the PLI/LMI/etc is enabled)
-
-    # Temporarily turn off reg_access so that DLL codes become visible
-    # (No need to do this if diagnostic settings are deferred.)
-    #temp_pli_reg_access = 0
-    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | temp_pli_reg_access        <<1)
-    # RGW071108 Need to change phase to "unlock" the register access code.
-    #temp_phase_shift = (phase_shift+1)&0x3
-    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x3<<11))  | temp_phase_shift           <<11)
-
-    dll1_code  = (sysconf.SYSCONF_STA3.peek() >> 1 ) & 0x1ff
-    dll2_code  = (sysconf.SYSCONF_STA3.peek() >> 11 ) & 0x1ff
-    pll_rdiv   = (sysconf.SYSCONF_CFG11.peek() >> 9 ) & 0x3
-    pll_ddiv   = (sysconf.SYSCONF_CFG11.peek() >> 1 ) & 0xff
-    pll_ref    = 30.0
-    pll_freq   = pll_ref * float(pll_ddiv) / float(pll_rdiv);
-    pll_period = 1000000 / pll_freq
-    ddr_period = 2000000 / pll_freq
-    # An approximation for the DLL step size can be deduced and used subsequently for variant optimizations dependent on PVT
-    # dll1_code is T/4 and dll2_code is 3T/4 (or T/2, when dqs270_del_opz=1)
-    if 1 == dqs270_del_opz:
-      dll_period = 4 * (dll2_code-dll1_code)
+        filter = 7
+    if parameters.has_key("lmi_16bitsmode"):
+        lmi16bits = 1
     else:
-      dll_period = 2 * (dll2_code-dll1_code)
-    dll_step     = ddr_period / dll_period
-    
+        lmi16bits = 0
+    dummy = 1
+    sysconf.SYSCONF_CFG55.poke(0x07fc201c|(lmi16bits<<10)|((filter&0x7)<<7)|((dummy&1)<<6))
+
+    sysconf.SYSCONF_CFG42.poke((0x1eb<<18)|(0x1eb<<9)|(0x1eb))
+    sysconf.SYSCONF_CFG43.poke((0x2c<<18)|0x1eb)
+
+    # Set DQS270 offsets
+    sysconf.SYSCONF_CFG51.poke((0x1eb<<16)|(0x1eb))
+    sysconf.SYSCONF_CFG52.poke((0x1eb<<16)|(0x1eb))
 
-    dqs_valid_offset     = int(0.125 * dll_period) & 0xff
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<18))| dqs_valid_offset           <<18)
-
-    #sttp.logging.print_out("ddr2_diagnostics: dll1_code        = 0x%03x (%d)" % (dll1_code,dll1_code))   
-    #sttp.logging.print_out("ddr2_diagnostics: dll2_code        = 0x%03x (%d)" % (dll2_code,dll2_code))   
-    #sttp.logging.print_out("ddr2_diagnostics: pll_freq         = %8.3fMHz" % (pll_freq))   
-    #sttp.logging.print_out("ddr2_diagnostics: pll_period       = %8.3fps" % (pll_period))   
-    #sttp.logging.print_out("ddr2_diagnostics: rdiv             = 0x%x     (%d)" % (pll_rdiv,pll_rdiv))   
-    #sttp.logging.print_out("ddr2_diagnostics: ddiv             = 0x%02x    (%d)" % (pll_ddiv,pll_ddiv))   
-    #sttp.logging.print_out("ddr2_diagnostics: DLL period (T)  ~= %d steps" % (int(dll_period)))   
-    #sttp.logging.print_out("ddr2_diagnostics: DLL step        ~= %6.3fps" % (dll_step))   
-    #sttp.logging.print_out("ddr2_diagnostics: dqs_valid_offset = 0x%02x" % (dqs_valid_offset))   
-
-    
-    if 1 == pli_reg_access:
-        # In order to observe diagnostic registers, the DLL's must be held in reset, and the offsets adjusted accordingly
-        dll1_soft_rst       = 1
-        dll2_soft_rst       = 1
-        dqs0_offset         = dqs0_offset        + dll1_code
-        dqs1_offset         = dqs1_offset        + dll1_code
-        dqs2_offset         = dqs2_offset        + dll1_code
-        dqs3_offset         = dqs3_offset        + dll1_code
-        dqs_valid_offset    = dqs_valid_offset   + dll1_code
-        dqs270_del0_offset  = dqs270_del0_offset + dll2_code
-        dqs270_del1_offset  = dqs270_del1_offset + dll2_code
-        dqs270_del2_offset  = dqs270_del2_offset + dll2_code
-        dqs270_del3_offset  = dqs270_del3_offset + dll2_code
-    # Allow offset value to be overriden
-    if parameters.has_key("capture"):
-        dqs0_offset         = int(parameters["capture"]) & 0xff
-        dqs1_offset         = int(parameters["capture"]) & 0xff
-        dqs2_offset         = int(parameters["capture"]) & 0xff
-        dqs3_offset         = int(parameters["capture"]) & 0xff
-
-    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<0))   | dll1_soft_rst              <<0)
-    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<0))   | dll2_soft_rst              <<0)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<0)) | dqs0_offset                <<0)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<9)) | dqs1_offset                <<9)
-    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<18))| dqs2_offset                <<18)
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<0)) | dqs3_offset                <<0)
-    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<18))| dqs_valid_offset           <<18)
-    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<0)) | dqs270_del0_offset         <<0)
-    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<16))| dqs270_del1_offset         <<16)
-    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<0)) | dqs270_del2_offset         <<0)
-    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<16))| dqs270_del3_offset         <<16)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_reg_access             <<1)
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_oversample             <<0)
-    # RGW071108 Need to change phase to "unlock" the register access code.
-    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x3<<11))  | phase_shift                <<11)
-
-
-    # Sequence through reset to ensure correct propagation of configuration settings into PLI
-    temp_pli_clock_enable = 0
-    temp_rst_lmi_n        = 0
-    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2))   | temp_pli_clock_enable       <<2)
-    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<27))  | temp_rst_lmi_n              <<27)
-    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<0))   | temp_rst_lmi_n              <<0)
-    sttp.stmc.delay(10)
-    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<27))  | rst_lmi_n                   <<27)
-    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<0))   | rst_lmi_n                   <<0)
-    sttp.stmc.delay(10)
-    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2))   | pli_clock_enable            <<2)
-    sttp.stmc.delay(10)
-
-    # Show summary of configuration settings
-    #sttp.logging.print_out("ddr2_diagnostics: STA3  = 0x%08x" % (sysconf.SYSCONF_STA3.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG11 = 0x%08x" % (sysconf.SYSCONF_CFG11.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG12 = 0x%08x" % (sysconf.SYSCONF_CFG12.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG13 = 0x%08x" % (sysconf.SYSCONF_CFG13.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG14 = 0x%08x" % (sysconf.SYSCONF_CFG14.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG38 = 0x%08x" % (sysconf.SYSCONF_CFG38.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG40 = 0x%08x" % (sysconf.SYSCONF_CFG40.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG42 = 0x%08x" % (sysconf.SYSCONF_CFG42.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG43 = 0x%08x" % (sysconf.SYSCONF_CFG43.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG51 = 0x%08x" % (sysconf.SYSCONF_CFG51.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG52 = 0x%08x" % (sysconf.SYSCONF_CFG52.peek()))   
-    #sttp.logging.print_out("ddr2_diagnostics: CFG55 = 0x%08x" % (sysconf.SYSCONF_CFG55.peek()))   
-        
 
 #  EMI Configuration
 def emi_configure():
@@ -857,7 +484,7 @@
     else:
         refresh = 2038
     #sttp.logging.print_out("LMI2X=%d Mhz => refresh val=%d" % (lmi2x,refresh))
-    if parameters.has_key("lmi_16bits_mode"):
+    if parameters.has_key("lmi_16bitsmode"):
         lmi.LMI_MIM_0.poke((refresh << 16) | 0x0000013b)
     else:
         lmi.LMI_MIM_0.poke((refresh << 16) | 0x0000017b)
@@ -878,24 +505,18 @@
     lmi.LMI_STR_1.poke(0x00222ed6)
 
     # SDRAM Array Attribute Register
-    # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10 - For 7111
     # Upper LMI addr=0x0C000000 + 256Mbytes=0x1C000000, 13x10, 8 Banks -  For 7105
     
-    if parameters.has_key("lmi_16bits_mode"):
-        lmi.LMI_SDRA0_0.poke(0x10000a20)
+    if parameters.has_key("lmi_16bitsmode"):
+        lmi.LMI_SDRA0_0.poke(0x14001a20)
     else:
-        #lmi.LMI_SDRA0_0.poke(0x14000a20)
-        #update for 7105
         lmi.LMI_SDRA0_0.poke(0x1c001a20)
 
     # SDRAM Array Attribute Register
-    # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10 - For 7111
-    # Upper LMI addr=0x0C000000 + 256Mbytes=0x1C000000, 13x10, 8 Banks -  For 7105
-    if parameters.has_key("lmi_16bits_mode"):
-        lmi.LMI_SDRA1_0.poke(0x10000a20)
+    # Upper LMI addr=0x0C000000 + 256Mbytes=0x1C000000, 13x10, 8 Banks
+    if parameters.has_key("lmi_16bitsmode"):
+        lmi.LMI_SDRA1_0.poke(0x14001a20)
     else:
-        #lmi.LMI_SDRA1_0.poke(0x14000a20)
-        #update for 7105
         lmi.LMI_SDRA1_0.poke(0x1c001a20)
 
     # SDRAM Control Register
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/mb680/mb680.xml opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb680/mb680.xml
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/mb680/mb680.xml	2009-02-05 12:42:19.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/mb680/mb680.xml	2009-02-05 12:41:35.521494762 +0000
@@ -42,7 +42,7 @@
 
   <!-- Files used to for board/SoC configuration -->
   <spirit:parameter spirit:name="jtagpinout">STMC_Type_A</spirit:parameter>
-  <spirit:parameter spirit:name="jtagpinout_lvds">STMC_Type_F</spirit:parameter>
+  <spirit:parameter spirit:name="jtagpinout_lvds">STMC_Type_G</spirit:parameter>
 
   <spirit:parameter spirit:name="tck_boot_max">3000000</spirit:parameter>
   <spirit:parameter spirit:name="tck_bypass_max">12500000</spirit:parameter>
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/sdk7105/sdk7105.py opt/STM/STLinux-2.3/host/stmc/targetpack/boards/sdk7105/sdk7105.py
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/sdk7105/sdk7105.py	1970-01-01 00:00:00.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/sdk7105/sdk7105.py	2009-02-05 12:41:35.521494762 +0000
@@ -0,0 +1,1056 @@
+# @(#)sdk7105.py 1.5 Bob Warren 08/04/16 18:52:36 ST Confidential
+# /design/C6DDR2/c6ddr2_pli_lib/silicon_7105/dev/targetpack/boards/sdk7105/SCCS/s.sdk7105.py
+
+# TargetScript for connecting to and disconnecting from an sdk7105 (STx7105)
+
+import sttp
+import sttp.logging
+import sttp.targetpack
+import sttp.stmc
+import sttp.pokepeek
+
+# TargetPack imports
+import st40_pmb_regs
+import stx7105
+import utilities
+
+global sttp_root
+sttp_root = sttp.targetpack.get_tree()
+
+stmc_release_101 = {'major': '1', 'minor': '0', 'patch': '1'}
+
+def sdk7105_connect(parameters):
+    sttp.logging.print_out("sdk7105 connect start - parameters", parameters)
+
+    stmc_release = sttp.get_release_info()
+
+    if stmc_release_101 != stmc_release:
+        # is there a user supplied module and funtion to call (R111 onwards only)?
+        import utilities
+        utilities.import_user_module(parameters)
+
+    if parameters.has_key("no_init") and (int(parameters["no_init"]) == 1):
+        return
+
+    sdk7105_check_target_connection()
+
+    if not parameters.has_key("reset_low_period"):         
+        parameters["reset_low_period"] = 360000
+
+    p = sttp.stmc.get_target_params()
+    root = sttp.targetpack.get_tree()
+    # Add the board TargetPack parameters
+    p.update(root.parameters)
+
+    # TCK must be slow until ClockGen setup to run CPU at full speed
+    utilities.set_tck_frequency(True, parameters)
+
+    # Connect to STx7105 SoC
+    stx7105.connect(parameters)
+
+    if not (parameters.has_key("no_pokes") and (int(parameters["no_pokes"]) == 1)):
+        sttp.pokepeek.enable()
+        cb = sttp.targetpack.get_callback("pre_poke")
+        if cb:
+            cb(parameters)
+
+        sttp.logging.print_out( "sdk7105 initialization start ..." )
+        cb = sttp.targetpack.get_callback("setup_pokes")
+        if cb:
+            cb(parameters)
+        else:
+            setup(parameters)
+
+            if parameters.has_key("boot_companions") and (int(parameters["boot_companions"]) == 0):
+                pass
+            else:
+                stx7105.boot_companions(parameters)
+
+        cb = sttp.targetpack.get_callback("post_poke")
+        if cb:
+            cb(parameters)
+
+    utilities.set_tck_frequency(False, parameters)
+    
+    # NEVER, EVER change TCK after calling this
+    stx7105.complete_connect(parameters)
+    
+    sttp.logging.print_out( "sdk7105 initialization complete" )
+
+def sdk7105_disconnect():
+    pass
+
+def sdk7105_check_target_connection():
+    typeACode = 3
+    typeFCode = 5
+    stmc_release = sttp.get_release_info()
+
+    if stmc_release_101 == stmc_release:
+        # R101 libraries do not recognize the LVDS board code "5"
+        # This "hack" stops R101 libraries from checking the LVDS code
+
+        del sttp_root.parameters["jtagpinout"]
+        code = sttp.stmc.get_converter_code()
+        if code != typeACode and code != typeFCode:
+            raise sttp.STTPException("Target not connected or unexpected STMC I/O convertor found")
+    elif sttp.stmc.get_stmc_type() != "STMC1":
+        # hack to allow use of TTL [Type A] and LVDS [Type F (code 5)]
+        if sttp.stmc.get_convertor_code() == typeFCode:
+            sttp_root.parameters["jtagpinout"] = "STMC_Type_F"
+
+
+# Get the sdk7105 SoC and board versions
+def version():
+    # Return a tuple of STx7105 SoC version and PCB version from EPLD register
+    return (stx7105.version(), sttp.pokepeek.peek(0xa5020000) & 0xFF)
+
+def sdk7105_set_tck_frequency(initialize, parameters):
+    # We cannot run the ST40 core's tck faster than the core
+    # clock and when initializing in x1 mode, this may be as low 27MHz/8
+    # In TAPmux mode the tck is divided by 8 to get the ST40 core tck.
+
+    # On STMC2 use the API sttp.stmc.set_tck_frequency() to set the tck frequency based on the supplied
+    # argument. The parameter "tck_frequency" if set will to override the supplied argument.
+    # The STMC2 will choose the GREATEST frequency that LESS THAN OR EQUAL to the requested value.
+    # and the chosen value is returned by sttp.stmc.set_tck_frequency().
+    # The API sttp.stmc.set_tck_frequency_no_override() does NOT use the parameter "tck_frequency"
+    # to override the supplied argument.
+
+    # On STMC1 sttp.stmc.set_tck_frequency() does not work - we set the parameter "linkspeed"
+    # No way of discovering what TCK has actually been selected - this is internal to the ST40 toolset
+
+    p = sttp.stmc.get_target_params()
+
+    if initialize:
+        # TCK to ST40 core must be slow until ClockGen setup to run CPU at full speed
+        # Assume worst case where system is in x1 mode (core clock == 27 Mhz)
+        if parameters.has_key("boot_tck"):
+            boot_tck = int(parameters["boot_tck"])
+        else:
+            boot_tck = int(p["tck_boot_max"])
+
+        if not sttp.stmc.get_stmc_type() == "STMC1":
+            real_tck = sttp.stmc.set_tck_frequency_no_override(boot_tck)
+        else:
+            p["linkspeed"] = str(boot_tck)
+            real_tck = boot_tck
+        sttp.logging.print_out("Initialization TCK frequency set to %d Hz" % (real_tck,))
+
+    else:
+        # Note : Once In TAPmux mode NEVER EVER change tck
+        # Set the preferred TCK frequency
+        if sttp.stmc.get_stmc_type() == "STMC1":
+            # Bypass with STMC1 mode
+            tck = int(p["tck_stmc1_max"])
+        elif parameters.has_key("tapmux_mux") and (int(parameters["tapmux_mux"]) == 1):
+            # TAPmux mode
+            tck = int(p["tck_tapmux_max"])
+        else:
+            # STMC2 Bypass mode
+            tck = int(p["tck_bypass_max"])
+
+        if (parameters.has_key("no_pokes") and (int(parameters["no_pokes"]) == 1)):
+            # If clockgen etc not configured, Must TCK leave in "slow" mode for GDB to be able to communicate with SoC
+            tck = int(p["tck_boot_max"])
+
+        if not sttp.stmc.get_stmc_type() == "STMC1":
+            real_tck = sttp.stmc.set_tck_frequency(tck)
+        else:
+            if parameters.has_key("tck_frequency"):
+                tck = int(parameters["tck_frequency"])
+            p["linkspeed"] = str(tck)
+            real_tck = tck
+        sttp.logging.print_out("TCK frequency set to %d Hz" % (real_tck,))
+
+    sttp.targetinfo.set_target_info("tck_frequency", real_tck)
+    sttp.stmc.set_target_params(p)
+
+# Configure the sdk7105
+def setup(parameters):
+
+    sttp.logging.print_out("sdk7105_setup - parameters", parameters)
+
+    stx7105.detectchip()
+
+    if not (parameters.has_key("no_clockgen_config") and (int(parameters["no_clockgen_config"]) == 1)):
+        clockgen_configure(parameters)
+
+    stx7105.displayclocks()
+    ddr2_pli_configure(parameters)
+    emi_configure()
+    lmi0_configure(parameters)
+      
+    # Interco/plugs default settings
+    if not (parameters.has_key("ic_noinit") and (int(parameters["ic_noinit"]) == 1)):
+        stx7105.interco_init()
+   
+    if parameters.has_key("se") and (int(parameters["se"]) == 1):
+        switch_on_se("se")
+    elif parameters.has_key("seuc") and (int(parameters["seuc"]) == 1):
+        switch_on_se("seuc")
+    elif parameters.has_key("se29") and (int(parameters["se29"]) == 1):
+        switch_on_se("se29")
+
+    ccn = sttp_root.stx7105.st40.CCN.st40_ccn_regs
+    ccn.CCN_CCR.poke(0x8000090d)
+
+
+# CLOCKGEN Configuration
+def clockgen_configure(parameters):
+
+    #sttp.logging.print_out("clockgen_configure")
+    
+    sysconf = sttp_root.stx7105.SYSCONF.stx7105_sysconf_regs
+
+    # Ensure USB is powered by SYSCLKIN/OSC
+    sysconf.SYSCONF_CFG40.poke((sysconf.SYSCONF_CFG40.peek() | (0x1<<2)))
+    # Since cut 2, to start USB PLL to generate 48 MHz
+    if stx7105.version() != 0xA0:
+        sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() | (0x1<<7)))
+
+    # Ensure clockgen B is powered by SYSCLKIN/OSC
+    sttp.pokepeek.poke(0xfe000010, 0xc0de)
+    sttp.pokepeek.poke(0xfe0000b8, 1)
+    sttp.pokepeek.poke(0xfe000010, 0xc1a0)
+
+    # Ensure clockgen C is powered by SYSCLKIN/OSC
+    sttp.pokepeek.poke(0xfe210000, sttp.pokepeek.peek(0xfe210000) | (0x00800000) )
+
+    # Ensure clockgen D is powered by SYSCLKIN/OSC
+    sysconf.SYSCONF_CFG40.poke((sysconf.SYSCONF_CFG40.peek() | (0x1)))
+    #
+    # Clockgen A initial setup
+    #
+
+    # Different default mode according to chip version
+    # cut1.0: default = IC WA2 @800Mhz
+    # cut2.0: default = NO WA @ 800Mhz
+    if parameters.has_key("ic_wa"):
+        ic_wa_mode = int(parameters["ic_wa"])
+    else:
+        if stx7105.version() == 0xA0:
+            ic_wa_mode = 1
+        else:
+            ic_wa_mode = 0
+
+    # Set dividers clocks
+    # Correct values:
+    # div 2=0x001   div  7=0x306   div 16=0x70F
+    # div 3=0x102   div  8=0x307   div 18=0x811
+    # div 4=0x103   div  9=0x408   div 24=0xB17
+    # div 5=0x204   
+    # div 6=0x205   
+    ckg = sttp_root.stx7105.CLOCKGENA.stx7105_clockgena_regs
+  
+    # Set source clocks to OSC
+    ckg.CKGA_CLKOPSRC_SWITCH_CFG.poke(0x0)
+    ckg.CKGA_CLKOPSRC_SWITCH_CFG2.poke(0x00000000)
+
+    # Wait CLKGEN_PLL0_ENABLE_FB to be stopped
+    ckg.CKGA_PLL0_ENABLE_FB.while_and_ne(0xFFFFFFFF, 0x00000000)
+
+    # Wait CLKGEN_PLL1_ENABLE_FB to be stopped
+    ckg.CKGA_PLL1_ENABLE_FB.while_and_ne(0xFFFFFFFF, 0x00000000)
+  
+    if ic_wa_mode == 1:
+        sttp.logging.print_out("Info: STNoc bug (GNBvdxxxxx) WA")
+
+        # Set PLL0LS clock to 450MHz (PLL0HS to 900MHz)
+        stx7105.set_clockgen_a_pll0(0x01, 0xf)
+    
+        # Set CLOCKGENA PLL1 into BYPASS...
+        ckg.CKGA_PLL1_CFG.poke(ckg.CKGA_PLL1_CFG.peek() | 0x00100000)
+    
+        ckg.CKGA_PLL1_DIV0_CFG.poke(0x00000103)         # STNOC=200    
+        ckg.CKGA_PLL1_DIV1_CFG.poke(0x00000001)         # FDMA0=400
+        ckg.CKGA_PLL1_DIV2_CFG.poke(0x00000001)         # FDMA1=400    
+        ckg.CKGA_PLL1_DIV3_CFG.poke(0x00000103)
+        ckg.CKGA_PLL0LS_DIV4_CFG.poke(0x00010100)       # ST40_ICK=450
+        ckg.CKGA_PLL1_DIV5_CFG.poke(0x00000307)         # IC_IF_100=100
+        ckg.CKGA_PLL0LS_DIV6_CFG.poke(0x00010100)       # LX_DMU_CPU=450
+        ckg.CKGA_PLL0LS_DIV7_CFG.poke(0x00010100)       # LX_AUD_CPU=450
+        ckg.CKGA_PLL1_DIV8_CFG.poke(0x00000103)         # IC_BDISP_200=200
+        ckg.CKGA_PLL1_DIV9_CFG.poke(0x00000103)         # IC_DISP_200=200
+        ckg.CKGA_PLL1_DIV10_CFG.poke(0x00000103)        # IC_TS_200=200
+        ckg.CKGA_PLL1_DIV11_CFG.poke(0x00000103)        # DISP_PIPE_200=200
+        ckg.CKGA_PLL1_DIV12_CFG.poke(0x00000103)        # BLIT_PROC/IC_DELTA_200=200
+        ckg.CKGA_PLL0LS_DIV13_CFG.poke(0x00000811)      # ETH_PHY
+        ckg.CKGA_PLL1_DIV14_CFG.poke(0x0000050B)        # PCI
+        ckg.CKGA_PLL1_DIV15_CFG.poke(0x00000307)        # EMI_MASTER
+        ckg.CKGA_PLL1_DIV16_CFG.poke(0x00000103)        # IC_COMPO_200=200
+        ckg.CKGA_PLL1_DIV17_CFG.poke(0x00000103)        # IC_IF_200=200
+    
+        # Power down CLOCKGENA PLL1...
+        ckg.CKGA_POWER_CFG.poke(ckg.CKGA_POWER_CFG.peek() | 0x00000002)
+    
+        # Configure CLOCKGENA PLL1...
+        ckg.CKGA_PLL1_CFG.poke((ckg.CKGA_PLL1_CFG.peek() & 0xfff80000) | (0 << 16) | (0x28 << 8) | (0x03))
+    
+        # Enable CLOCKGENA PLL1...
+        ckg.CKGA_POWER_CFG.poke(ckg.CKGA_POWER_CFG.peek() & 0xfffffffd)
+    
+        # Wait for CLOCKGENA PLL1 to lock...
+        ckg.CKGA_PLL1_CFG.while_and_ne(0x80000000, 0x80000000)
+        
+        # Clear CLOCKGENA PLL1 from BYPASS...
+        ckg.CKGA_PLL1_CFG.poke(ckg.CKGA_PLL1_CFG.peek() & 0xffefffff)
+    
+        ckg.CKGA_CLKOPSRC_SWITCH_CFG.poke(0xA6AA59AA)
+        ckg.CKGA_CLKOPSRC_SWITCH_CFG2.poke(0x0000000A)
+
+    else:
+       
+    	# Set PLL0LS clock to 450MHz (PLL0HS to 900MHz)
+    	stx7105.set_clockgen_a_pll0(0x01, 0xf)
+
+        # Set PLL1 clock to 800MHz
+        stx7105.set_clockgen_a_pll1(0x03, 0x28, 0x0)
+
+        # Set dividers clocks
+    	ckg.CKGA_PLL1_DIV0_CFG.poke(0x00000001)        	# STNOC=400    
+    	ckg.CKGA_PLL1_DIV1_CFG.poke(0x00000001)         # FDMA0=400
+    	ckg.CKGA_PLL1_DIV2_CFG.poke(0x00000001)         # FDMA1=400    
+    	ckg.CKGA_PLL1_DIV3_CFG.poke(0x00000103)
+    	ckg.CKGA_PLL0LS_DIV4_CFG.poke(0x00010100)       # ST40_ICK=450
+    	ckg.CKGA_PLL1_DIV5_CFG.poke(0x00000307)         # IC_IF_100=100
+    	ckg.CKGA_PLL0LS_DIV6_CFG.poke(0x00010100)       # LX_DMU_CPU=450
+    	ckg.CKGA_PLL0LS_DIV7_CFG.poke(0x00010100)       # LX_AUD_CPU=450
+    	ckg.CKGA_PLL1_DIV8_CFG.poke(0x00000103)        	# IC_BDISP_200=200
+    	ckg.CKGA_PLL1_DIV9_CFG.poke(0x00000103)        	# IC_DISP_200=200
+    	ckg.CKGA_PLL1_DIV10_CFG.poke(0x00000103)        # IC_TS_200=200
+    	ckg.CKGA_PLL1_DIV11_CFG.poke(0x00000103)        # DISP_PIPE_200=200
+    	ckg.CKGA_PLL1_DIV12_CFG.poke(0x00000102)       	# BLIT_PROC/IC_DELTA_200=266
+    	ckg.CKGA_PLL0LS_DIV13_CFG.poke(0x00000811)      # ETH_PHY
+    	ckg.CKGA_PLL1_DIV14_CFG.poke(0x0000050B)        # PCI
+    	ckg.CKGA_PLL1_DIV15_CFG.poke(0x00000307)        # EMI_MASTER
+    	ckg.CKGA_PLL1_DIV16_CFG.poke(0x00000103)       	# IC_COMPO_200=200
+    	ckg.CKGA_PLL1_DIV17_CFG.poke(0x00000103)        # IC_IF_200=200
+
+        # Set source clocks
+    	ckg.CKGA_CLKOPSRC_SWITCH_CFG.poke(0xA6AA59AA)
+    	ckg.CKGA_CLKOPSRC_SWITCH_CFG2.poke(0x0000000A)
+
+
+    # Is the LMI2X frequency given as parameter ?
+    if parameters.has_key("lmi_2xfreq"):
+        lmi2xfreq = int(parameters["lmi_2xfreq"])
+    else:
+            lmi2xfreq = 800
+    set_lmi2x_freq(lmi2xfreq)
+
+
+def set_lmi2x_freq(freq):
+    refclock = 30.0
+    deviation = freq
+    ddiv = 0
+    # python range(7) is (0,1,2,3,4,5,6); so rdiv is 1,2,3,4,5,6,7
+    for i in range(7):
+        rdiv = i + 1
+        ddiv = int((rdiv*freq)/refclock)
+        for j in range(3):
+            new_freq = int((refclock*ddiv)/rdiv)
+            new_deviation = new_freq - freq
+            if ( new_deviation < 0 ):
+                new_deviation = -new_deviation
+            if ((new_deviation<deviation) and (ddiv<=0xff)):
+                pll_rdiv    = rdiv;
+                pll_ddiv    = ddiv;
+                deviation    = new_deviation;
+            ddiv = ddiv + 1.0
+    stx7105.set_clockgen_lmi_pll(int(pll_rdiv), int(pll_ddiv))
+    #sttp.logging.print_out("set_lmi2x_freq: freq=%d.000 rdiv=0x%x, ddiv=0x%x" % (freq, pll_rdiv, pll_ddiv))
+
+def set_field(register, upper, lower, value):
+   content = register.peek()
+   mask = 0
+   for i in range(upper-lower):
+     mask = mask | (1<<(i+lower))
+   value = value << lower
+   content = content & ~mask
+   content = content | value
+   register.poke(content)
+   
+
+# DDR2 PLI Configuration (mostly SYSCONF registers)
+# The PLI is the PadLogic Interface, or PHY, for the external DDR2 SDRAM Memory Parts.
+def ddr2_pli_configure(parameters):
+    sysconf = sttp_root.stx7105.SYSCONF.stx7105_sysconf_regs
+    
+    jitter_low=1
+    # LMI settings
+    lmi_pwrd_req               = 0
+    lmi_hp_en_ap               = 0x3
+    lmi_lp_en_ap               = 0x3
+    lmi_mem_base_addr          = 0x0c
+
+    #######################################################################################################
+    # Static configuration (before the clock to the PLI,LMI,etc is enabled)
+
+    # PLI_CLOCK_ENABLE set to 0
+    # The default state following reset should be off, so this is redundant.
+    pli_clock_enable = 0    
+    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2)) | pli_clock_enable <<2)
+
+    # Interface with LMI
+    double_width               = 0
+    retime_pli_lmi             = 1
+    # Exit from reset for PLI, LMI, etc.  rst_n_lmi (CFG11.27) rst_n_lmipl (CFG11.0)
+    rst_lmi_n                  = 1
+    # For 7105 default single_rank=1 (CFG11.14)
+    # For 7111 default single_rank=0 (CFG11.17) (Hard wired to 0 in 7111c1, but CSN[1], CKE[1], ODT[1] are bonded.)
+    single_rank                = 0
+    lmi_pll_clock_select       = 1
+    # Control the phase relationship between multiple instances of PLI (0,1,2,3 steps of T/4)
+    phase_shift                = 0
+
+    # Delay Locked Loop for T/4
+    dll1_usr_cmd               = 0
+    dll1_lock_con              = 0
+    dll1_int_cmd_con           = 0
+    dll1_ext_cmd_con           = 0
+    dll1_soft_rst              = 0
+    # There is a further option which controls when the DLL code + offset is loaded into the PDL.
+    #   This is an historical option from DDR1 days.
+    #   For DDR2, since more than one edge can be propagating through the PDL, the timing of the update does not matter.
+    #   However, in order to avoid the requirement for an initial dummy read, keep pdl_clk_opz_dll1=1
+    pdl_clk_opz_dll1           = 0
+
+    # Delay Locked Loop for 3T/4 (or T/2)
+    dll2_usr_cmd               = 0
+    dll2_lock_con              = 0
+    dll2_int_cmd_con           = 0
+    dll2_ext_cmd_con           = 0
+    dll2_soft_rst              = 0
+    # There is a further option which controls when the DLL code + offset is loaded into the PDL.
+    #   This is an historical option from DDR1 days.
+    #   For DDR2, since more than one edge can be propagating through the PDL, the timing of the update does not matter.
+    #   However, in order to avoid the requirement for an initial dummy read, keep pdl_clk_opz_dll2=1
+    pdl_clk_opz_dll2           = 0
+
+    # Filter the output of the DLL before it used by each slave PDL
+    # 0 = no filtering, 7 = maximum filtering
+    filter_shift_param         = 5
+
+    # Read Data Capture Point Positioning
+    usermode_pdl_dqs           = 0
+    dqs0_offset                = 0x1ee
+    dqs1_offset                = 0x1ee
+    dqs2_offset                = 0x1ee
+    dqs3_offset                = 0x1ee
+
+    # Read Strobe Valid Positioning (rdqs_valid)
+    # rdqs_valid coarse settings in steps of T/4, separately for rise and fall,
+    #   in positions -2 -1 0 1 2 3, computed as follows:
+    #     rdqs_valid_rise    = rdqs_sel_rise - (rdqs_valid_minus_2 * 2)
+    #     rdqs_valid_fall    = rdqs_sel_fall - (rdqs_valid_minus_2 * 2)
+    # Note that rdqs_valid_minus_2 (0 or 1) is shared across both rise and fall edges 
+    # rdqs_sel_rise and rdqs_sel_rise can have values of 0, 1, 2, 3
+    rdqs_sel_rise        = 1
+    rdqs_sel_fall        = 1
+    rdqs_valid_minus_2   = 1
+    # rdqs_valid fine position is automatically adjusted to T/4 via the DLL
+    #   this can be adjusted via the offset (0x1ff for -256, to 0x0ff for +255)
+    #   or the fine adjust can be completely bypassed using bypass_pdl_dqs_valid (reducing delay by ~ T/4)
+    dqs_valid_offset     = 40 #40 for Pace cut2 board
+    bypass_pdl_dqs_valid = 0
+    # rdqs_valid also includes a refinement to balance the IOPadBuffer delay and the PCB trace delay
+    bypass_pad_dqs_valid = 0
+    dummy_pcb_trace      = 1
+    # Workaround for observation of lock and command: keep usermode_pdl_dqs_valid=0 and user_command_dqs_valid=0x1ff
+    usermode_pdl_dqs_valid     = 0
+    user_command_dqs_valid     = 0x1ff
+
+    # Control timing of data transfer from capture into FIFO
+    usermode_pdl_dqs270_del    = 0
+    dqs270_del0_offset         = 0
+    dqs270_del1_offset         = 0
+    dqs270_del2_offset         = 0
+    dqs270_del3_offset         = 0
+    # For slower frequencies the delay through the PDL can be set to T/2 (dqs270_del_opz=1), instead of 3T/4
+    dqs270_del_opz             = 0
+    # 0 : 2 flops are used.
+    # 1 : 3 flops are used.
+    # 2 : 4 flops are used.
+    # 3 : 1 flop is used. For test/characterization only.
+    sel_sync_flop_nb           = 0
+    sel_sync_flop_half         = 0
+    sel_clk_phase              = 1
+
+
+    # DDR2 Interface timing options
+    sel_oen_del                = 0
+    # Control the timing of the On Die Termination
+    disable_odtint             = 0
+    # Default ODT timing
+    if jitter_low:
+      sel_odt_int_del            = 3 #was 0
+      force_odt_int_minus_half   = 1 #was 0
+    else:
+      sel_odt_int_del            = 0 #was 0
+      force_odt_int_minus_half   = 0 #was 0
+    # Shrink ODT so it is only active when driven by memory parts
+    #  (So that there is not an edge as the ODT turns on, pulling to centre, when memory is still tri-state)
+    # This setting is desirable for diagnostic statistical edge position detection.
+    # sel_odt_int_del<3,2,1,0> = <0,0,1,1> fall, rise (CFG43.30:27)
+    #sel_odt_int_del            = 3
+    #force_odt_int_minus_half   = 1
+    # For DDR2 the turnaround time between write and read is too short,
+    #  so force the input enable (enable_enzi=0) permenantly, rather than just on reads (enable_enzi=1).
+    # At lower frequencies (say below 533MHz) there is a minor power saving by setting enable_enzi=1.
+    enable_enzi                = 0
+
+    if parameters.has_key("lmi_16bits_mode"):
+        lower_16bit_only         = 1
+    else:
+        lower_16bit_only         = 0
+
+    # IOPadBuffer settings
+    func_pdn_active_hi  = 1
+    func_pu_active_hi   = 0
+    func_pdn_active_lo  = 1
+    func_pu_active_lo   = 0
+    ioref_tq            = 0
+    ioref_ddr_comp      = 0
+    ioref_accurate      = 1
+    ioref_freeze        = 0
+    ioref_comptq        = 0
+    ioref_compen        = 0
+    # 7 bit one hot compensation
+    ioref_rasrc         = 0
+    func_tq_vref        = 1
+    func_usepad_vref    = 1
+    # On Die Termination resistor values
+    # 0 DISABLED
+    # 1 RTT2 = 150 ohms
+    # 2 RTT2 = 150 ohms
+    # 3 RTT1 = 75 ohms
+    if jitter_low:
+      func_odt            = 1 #was 3
+    else:
+      func_odt            = 3
+    func_modezi         = 0
+    # Adjust proga, progb, zoutproga, and receiver mode for LMI0
+    #Settings for 333Mhz.
+    #PROGA=1
+    #PROGB=0
+    #ZOUTPROGA=0
+    #sysconf.SYSCONF_CFG12.poke(0xa2007801 | (0x7 << 1) | (0x0 << 4) | (0x0 << 7) | (0x0 << 10))
+    #Settings for 400Mhz.
+    #PROGA=1
+    #PROGB=1
+    #ZOUTPROGA=0
+    #sysconf.SYSCONF_CFG12.poke(0xa2007801 | (0x7 << 1) | (0x7 << 4) | (0x0 << 7) | (0x0 << 10))
+    func_zoutproga_abc  = 0
+    func_zoutproga_k    = 0
+    func_zoutproga_d    = 0
+    func_progb_abc      = 1
+    func_progb_k        = 1
+    func_progb_d        = 1
+    func_proga_abc      = 1
+    func_proga_k        = 1
+    func_proga_d        = 1
+    # 0 DDR1 operation mode (2.5V)
+    # 1 DDR2 operation mode (1.8V)
+    func_ddr            = 1
+
+    # Diagnostics
+    if parameters.has_key("diagnose"):
+      pli_reg_access             = int(parameters["diagnose"]) & 0x1
+    else:
+      pli_reg_access             = 0
+    pli_oversample             = 0
+    # Use a non-zero sample_scale to avoid floating nodes
+    sample_scale = 0x1
+    if parameters.has_key("scale"):
+      sample_scale = int(parameters["scale"]) & 0x7
+
+    #RGW080415 These obsolete variable names are not so convenient to use.
+    #force_dqs_valid_minus_half = 0
+    #sel_dqs_valid_del          = 0
+    #ddr2_diag_control          = 4
+
+    # Load all the variables defined above into the various configuration registers
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<28))  | dqs270_del_opz       <<28)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<27))  | rst_lmi_n            <<27)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<17))  | single_rank          <<17)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<16))  | bypass_pdl_dqs_valid <<16)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<15))  | bypass_pad_dqs_valid <<15)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<14))  | single_rank          <<14)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<13))  | enable_enzi          <<13)
+    #sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<0))   | rst_lmi_n            <<0)
+    
+    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() &
+                            ~((0x1 << 28) |
+                              (0x1 << 27) |
+                              (0x1 << 17) |
+                              (0x1 << 16) |
+                              (0x1 << 15) |
+                              (0x1 << 14) |
+                              (0x1 << 13) |
+                              (0x1 << 0))) |
+                           ((dqs270_del_opz       << 28) |
+                            (rst_lmi_n            << 27) |
+                            (single_rank          << 17) |
+                            (bypass_pdl_dqs_valid << 16) |
+                            (bypass_pad_dqs_valid << 15) |
+                            (single_rank          << 14) |
+                            (enable_enzi          << 13) |
+                            (rst_lmi_n            << 0)))
+
+
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<31))  | func_pdn_active_hi  <<31)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<30))  | func_pu_active_hi   <<30)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<29))  | func_pdn_active_lo  <<29)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<28))  | func_pu_active_lo   <<28)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<27))  | ioref_tq            <<27)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<26))  | ioref_ddr_comp      <<26)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<25))  | ioref_accurate      <<25)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<24))  | ioref_freeze        <<24)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<23))  | ioref_comptq        <<23)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<22))  | ioref_compen        <<22)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x3f<<15)) | ioref_rasrc         <<15)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<14))  | func_tq_vref        <<14)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<13))  | func_usepad_vref    <<13)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x3<<11))  | func_odt            <<11)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<10))  | func_modezi         <<10)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<9))   | func_zoutproga_abc  <<9)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<8))   | func_zoutproga_k    <<8)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<7))   | func_zoutproga_d    <<7)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<6))   | func_progb_abc      <<6)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<5))   | func_progb_k        <<5)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<4))   | func_progb_d        <<4)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<3))   | func_proga_abc      <<3)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<2))   | func_proga_k        <<2)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<1))   | func_proga_d        <<1)
+    sysconf.SYSCONF_CFG12.poke((sysconf.SYSCONF_CFG12.peek() & ~(0x1<<0))   | func_ddr            <<0)
+
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<22))  | rdqs_valid_minus_2         <<22)
+    #sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<22)) | force_dqs_valid_minus_half <<22)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<21))  | force_odt_int_minus_half   <<21)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<17))  | sel_oen_del                <<17)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1ff<<8)) | dll1_usr_cmd               <<8)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0xf<<4))   | dll1_lock_con              <<4)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<3))   | dll1_int_cmd_con           <<3)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<2))   | dll1_ext_cmd_con           <<2)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<1))   | pdl_clk_opz_dll1           <<1)
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<0))   | dll1_soft_rst              <<0)
+
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1ff<<8)) | dll2_usr_cmd               <<8)
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0xf<<4))   | dll2_lock_con              <<4)
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<3))   | dll2_int_cmd_con           <<3)
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<2))   | dll2_ext_cmd_con           <<2)
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<1))   | pdl_clk_opz_dll2           <<1)
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<0))   | dll2_soft_rst              <<0)
+
+ #   sysconf.SYSCONF_CFG38.poke(0xfe00)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<23))  | sel_sync_flop_nb           <<23)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<22))  | sel_sync_flop_half         <<22)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<21))  | sel_clk_phase              <<21)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x1<<20))  | lmi_pwrd_req               <<20)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x3<<18))  | lmi_hp_en_ap               <<18)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0x3<<16))  | lmi_lp_en_ap               <<16)
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & ~(0xff<<0))  | lmi_mem_base_addr          <<0)
+
+#    sysconf.SYSCONF_CFG40.poke((sysconf.SYSCONF_CFG40.peek() & ~(0x3<<0))   | lmi_pll_clock_select       <<0)
+
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x3<<29))  | rdqs_sel_fall              <<29)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x3<<27))  | rdqs_sel_rise              <<27)
+    #sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0xf<<27)) | sel_dqs_valid_del          <<27)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<18))| dqs2_offset                <<18)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<9)) | dqs1_offset                <<9)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<0)) | dqs0_offset                <<0)
+
+    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1<<31))  | disable_odtint             <<31)
+    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0xf<<27))  | sel_odt_int_del            <<27)
+    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<18))| dqs_valid_offset           <<18)
+    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<0)) | dqs3_offset                <<0)
+
+    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<16))| dqs270_del1_offset         <<16)
+    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<0)) | dqs270_del0_offset         <<0)
+
+    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<16))| dqs270_del3_offset         <<16)
+    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<0)) | dqs270_del2_offset         <<0)
+
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<29))  | usermode_pdl_dqs_valid     <<29)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<28))  | usermode_pdl_dqs270_del    <<28)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<27))  | usermode_pdl_dqs           <<27)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1ff<<18))| user_command_dqs_valid     <<18)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<13))  | retime_pli_lmi             <<13)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x3<<11))  | phase_shift                <<11)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<10))  | lower_16bit_only           <<10)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x7<<7))   | filter_shift_param         <<7)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<6))   | dummy_pcb_trace            <<6)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<5))   | double_width               <<5)
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x7<<2))   | sample_scale               <<2)
+    # Defer setting diagnostic features until after DLL codes have been read
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_reg_access             <<1)
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_oversample             <<0)
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1f<<0)) | ddr2_diag_control          <<0)
+
+
+    # Start the clock to the PLI, LMI, etc.
+    pli_clock_enable = 1
+    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2)) | pli_clock_enable <<2)
+    sttp.stmc.delay(10)
+
+    #######################################################################################################
+    # Dynamic configuration (after the clock to the PLI/LMI/etc is enabled)
+
+    # Temporarily turn off reg_access so that DLL codes become visible
+    # (No need to do this if diagnostic settings are deferred.)
+    #temp_pli_reg_access = 0
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | temp_pli_reg_access        <<1)
+    # RGW071108 Need to change phase to "unlock" the register access code.
+    #temp_phase_shift = (phase_shift+1)&0x3
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x3<<11))  | temp_phase_shift           <<11)
+
+    dll1_code  = (sysconf.SYSCONF_STA3.peek() >> 1 ) & 0x1ff
+    dll2_code  = (sysconf.SYSCONF_STA3.peek() >> 11 ) & 0x1ff
+    pll_rdiv   = (sysconf.SYSCONF_CFG11.peek() >> 9 ) & 0x3
+    pll_ddiv   = (sysconf.SYSCONF_CFG11.peek() >> 1 ) & 0xff
+    pll_ref    = 30.0
+    pll_freq   = pll_ref * float(pll_ddiv) / float(pll_rdiv);
+    pll_period = 1000000 / pll_freq
+    ddr_period = 2000000 / pll_freq
+    # An approximation for the DLL step size can be deduced and used subsequently for variant optimizations dependent on PVT
+    # dll1_code is T/4 and dll2_code is 3T/4 (or T/2, when dqs270_del_opz=1)
+    if 1 == dqs270_del_opz:
+      dll_period = 4 * (dll2_code-dll1_code)
+    else:
+      dll_period = 2 * (dll2_code-dll1_code)
+    dll_step     = 0 #ddr_period / dll_period
+    
+
+    #dqs_valid_offset     = int(0.125 * dll_period) & 0xff
+    #sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<18))| dqs_valid_offset           <<18)
+
+    #sttp.logging.print_out("ddr2_diagnostics: dll1_code        = 0x%03x (%d)" % (dll1_code,dll1_code))   
+    #sttp.logging.print_out("ddr2_diagnostics: dll2_code        = 0x%03x (%d)" % (dll2_code,dll2_code))   
+    #sttp.logging.print_out("ddr2_diagnostics: pll_freq         = %8.3fMHz" % (pll_freq))   
+    #sttp.logging.print_out("ddr2_diagnostics: pll_period       = %8.3fps" % (pll_period))   
+    #sttp.logging.print_out("ddr2_diagnostics: rdiv             = 0x%x     (%d)" % (pll_rdiv,pll_rdiv))   
+    #sttp.logging.print_out("ddr2_diagnostics: ddiv             = 0x%02x    (%d)" % (pll_ddiv,pll_ddiv))   
+    #sttp.logging.print_out("ddr2_diagnostics: DLL period (T)  ~= %d steps" % (int(dll_period)))   
+    #sttp.logging.print_out("ddr2_diagnostics: DLL step        ~= %6.3fps" % (dll_step))   
+    #sttp.logging.print_out("ddr2_diagnostics: dqs_valid_offset = 0x%02x" % (dqs_valid_offset))   
+
+    
+    if 1 == pli_reg_access:
+        # In order to observe diagnostic registers, the DLL's must be held in reset, and the offsets adjusted accordingly
+        dll1_soft_rst       = 1
+        dll2_soft_rst       = 1
+        dqs0_offset         = dqs0_offset        + dll1_code
+        dqs1_offset         = dqs1_offset        + dll1_code
+        dqs2_offset         = dqs2_offset        + dll1_code
+        dqs3_offset         = dqs3_offset        + dll1_code
+        dqs_valid_offset    = dqs_valid_offset   + dll1_code
+        dqs270_del0_offset  = dqs270_del0_offset + dll2_code
+        dqs270_del1_offset  = dqs270_del1_offset + dll2_code
+        dqs270_del2_offset  = dqs270_del2_offset + dll2_code
+        dqs270_del3_offset  = dqs270_del3_offset + dll2_code
+    # Allow offset value to be overriden
+    if parameters.has_key("capture"):
+        dqs0_offset         = int(parameters["capture"]) & 0xff
+        dqs1_offset         = int(parameters["capture"]) & 0xff
+        dqs2_offset         = int(parameters["capture"]) & 0xff
+        dqs3_offset         = int(parameters["capture"]) & 0xff
+
+    sysconf.SYSCONF_CFG13.poke((sysconf.SYSCONF_CFG13.peek() & ~(0x1<<0))   | dll1_soft_rst              <<0)
+    sysconf.SYSCONF_CFG14.poke((sysconf.SYSCONF_CFG14.peek() & ~(0x1<<0))   | dll2_soft_rst              <<0)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<0)) | dqs0_offset                <<0)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<9)) | dqs1_offset                <<9)
+    sysconf.SYSCONF_CFG42.poke((sysconf.SYSCONF_CFG42.peek() & ~(0x1ff<<18))| dqs2_offset                <<18)
+    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<0)) | dqs3_offset                <<0)
+    sysconf.SYSCONF_CFG43.poke((sysconf.SYSCONF_CFG43.peek() & ~(0x1ff<<18))| dqs_valid_offset           <<18)
+    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<0)) | dqs270_del0_offset         <<0)
+    sysconf.SYSCONF_CFG51.poke((sysconf.SYSCONF_CFG51.peek() & ~(0x1ff<<16))| dqs270_del1_offset         <<16)
+    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<0)) | dqs270_del2_offset         <<0)
+    sysconf.SYSCONF_CFG52.poke((sysconf.SYSCONF_CFG52.peek() & ~(0x1ff<<16))| dqs270_del3_offset         <<16)
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_reg_access             <<1)
+    #sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x1<<0))   | pli_oversample             <<0)
+    # RGW071108 Need to change phase to "unlock" the register access code.
+    sysconf.SYSCONF_CFG55.poke((sysconf.SYSCONF_CFG55.peek() & ~(0x3<<11))  | phase_shift                <<11)
+
+
+    # Sequence through reset to ensure correct propagation of configuration settings into PLI
+    temp_pli_clock_enable = 0
+    temp_rst_lmi_n        = 0
+    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2))   | temp_pli_clock_enable       <<2)
+    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<27))  | temp_rst_lmi_n              <<27)
+    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<0))   | temp_rst_lmi_n              <<0)
+    sttp.stmc.delay(10)
+    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<27))  | rst_lmi_n                   <<27)
+    sysconf.SYSCONF_CFG11.poke((sysconf.SYSCONF_CFG11.peek() & ~(0x1<<0))   | rst_lmi_n                   <<0)
+    sttp.stmc.delay(10)
+    sysconf.SYSCONF_CFG04.poke((sysconf.SYSCONF_CFG04.peek() & ~(0x1<<2))   | pli_clock_enable            <<2)
+    sttp.stmc.delay(10)
+
+    # Show summary of configuration settings
+    #sttp.logging.print_out("ddr2_diagnostics: STA3  = 0x%08x" % (sysconf.SYSCONF_STA3.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG11 = 0x%08x" % (sysconf.SYSCONF_CFG11.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG12 = 0x%08x" % (sysconf.SYSCONF_CFG12.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG13 = 0x%08x" % (sysconf.SYSCONF_CFG13.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG14 = 0x%08x" % (sysconf.SYSCONF_CFG14.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG38 = 0x%08x" % (sysconf.SYSCONF_CFG38.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG40 = 0x%08x" % (sysconf.SYSCONF_CFG40.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG42 = 0x%08x" % (sysconf.SYSCONF_CFG42.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG43 = 0x%08x" % (sysconf.SYSCONF_CFG43.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG51 = 0x%08x" % (sysconf.SYSCONF_CFG51.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG52 = 0x%08x" % (sysconf.SYSCONF_CFG52.peek()))   
+    #sttp.logging.print_out("ddr2_diagnostics: CFG55 = 0x%08x" % (sysconf.SYSCONF_CFG55.peek()))   
+        
+
+#  EMI Configuration
+def emi_configure():
+
+    emi = sttp_root.stx7105.EMI.st40_emi_regs
+    
+    # Reprogram bank addresses
+    emi.EMI_BANK_ENABLE.poke(0x00000005)
+    ## NOTE: bits [0,5] define bottom address bits [22,27] of bank
+    emi.EMI_BANK0_BASEADDRESS.poke(0x00000000)
+    emi.EMI_BANK1_BASEADDRESS.poke(0x00000010)
+    emi.EMI_BANK2_BASEADDRESS.poke(0x00000018)
+    emi.EMI_BANK3_BASEADDRESS.poke(0x0000001a)
+    emi.EMI_BANK4_BASEADDRESS.poke(0x0000001c)
+
+    # Bank 0 - On-board 32MBytes Flash at address 0x00000000 -> 0x01ffffff
+    emi.EMI_BANK0_EMICONFIGDATA0.poke(0x001016d1)
+    emi.EMI_BANK0_EMICONFIGDATA1.poke(0x9d200000)
+    emi.EMI_BANK0_EMICONFIGDATA2.poke(0x9d220000)
+    emi.EMI_BANK0_EMICONFIGDATA3.poke(0x00000000)
+
+    # Bank 1 - STEM 8 MBytes 0x04000000 -> 0x047fffff
+    emi.EMI_BANK1_EMICONFIGDATA0.poke(0x002016d1)
+    emi.EMI_BANK1_EMICONFIGDATA1.poke(0x9d222200)
+    emi.EMI_BANK1_EMICONFIGDATA2.poke(0x9d220044)
+    emi.EMI_BANK1_EMICONFIGDATA3.poke(0x00000000)
+
+    # Bank 2 - 16MB DVB-CI at address 0x04800000 -> 0x04FFFFFF
+    emi.EMI_BANK2_EMICONFIGDATA0.poke(0x002046f9)
+    emi.EMI_BANK2_EMICONFIGDATA1.poke(0xa5a00000)
+    emi.EMI_BANK2_EMICONFIGDATA2.poke(0xa5a20000)
+    emi.EMI_BANK2_EMICONFIGDATA3.poke(0x00000000)
+
+    # Bank 3 - 32MB Boards register and either DVBCI notCe2 or
+    #          STEM notCS1 (16MB + 16MB split bank) 0x05000000 -> 0x06ffffff
+    emi.EMI_BANK3_EMICONFIGDATA0.poke(0x002016d1)
+    emi.EMI_BANK3_EMICONFIGDATA1.poke(0x9d222200)
+    emi.EMI_BANK3_EMICONFIGDATA2.poke(0x9d220044)
+    emi.EMI_BANK3_EMICONFIGDATA3.poke(0x00000000)
+
+    # Bank 4 - STEM 8 MBytes  0x07000000 -> 0x07ffffff
+    emi.EMI_BANK4_EMICONFIGDATA0.poke(0x002016d1)
+    emi.EMI_BANK4_EMICONFIGDATA1.poke(0x9d222200)
+    emi.EMI_BANK4_EMICONFIGDATA2.poke(0x9d220044)
+    emi.EMI_BANK4_EMICONFIGDATA3.poke(0x00000000)
+
+    # Program other EMI registers
+    emi.EMI_GENCFG.poke(0x00000010) 
+
+
+# LMI0 Configuration
+def lmi0_configure(parameters):
+
+    lmi = sttp_root.stx7105.LMI0.st40_lmigp_regs
+    sysconf = sttp_root.stx7105.SYSCONF.stx7105_sysconf_regs
+
+    # Configuring LMI0 for DDR2 SDRAM Elpida EDE5116AHBG-8E-E
+
+    # Refresh interval compute (from Ignazio, 11jan08)
+    # 300 Mhz --->  T=3.4ns => MIM[28:16]=2038 ((2294-256)+ACo-3.4ns<+AH4-7.8us)
+    # 330 Mhz --->  T=3.1ns => MIM[28:16]=2260 ((2516-256)+ACo-3.1ns<+AH4-7.8us)
+    # 360 Mhz --->  T=2.8ns => MIM[28:16]=2529 ((2785-256)+ACo-2.8ns<+AH4-7.8us)
+    # 400 Mhz --->  T=2.5ns => MIM[28:16]=2864 ((3120-256)+ACo-2.5ns=7.8us)
+    lmi2x = stx7105.get_clockgen_lmi_frq(30.0)
+    if lmi2x == 800:
+        refresh = 2864
+    elif lmi2x == 720:
+        refresh = 2529
+    elif lmi2x == 660:
+        refresh = 2260
+    else:
+        refresh = 2038
+    #sttp.logging.print_out("LMI2X=%d Mhz => refresh val=%d" % (lmi2x,refresh))
+    if parameters.has_key("lmi_16bits_mode"):
+        lmi.LMI_MIM_0.poke((refresh << 16) | 0x0000013b)
+    else:
+        lmi.LMI_MIM_0.poke((refresh << 16) | 0x0000017b)
+    # Note: refresh is enabled in later steps
+
+    # set bandwidth limiter
+    lmi.LMI_MIM_1.poke(0x000000b0)
+
+    # SDRAM Timing Register
+    # lmi.LMI_STR_0.poke(0x4c2db41b)
+    # FCh, 19/mar/08: change according to Raffaele G feebacks
+    #                 1-cycle additional delay between RD and WR
+    #lmi.LMI_STR_0.poke(0xcc2db41b)
+    #update for 7105. TRFC(min) = 195 ns(78 Clk) instead of 105nS(42 Clk)
+    lmi.LMI_STR_0.poke(0xCF35B424)
+    #lmi.LMI_STR_1.poke(0x002202d6)
+    #RGW080411 tfaw changed to best for 800MHz
+    lmi.LMI_STR_1.poke(0x242ED8)
+
+    # SDRAM Array Attribute Register
+    # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10 - For 7111
+    # Upper LMI addr=0x0C000000 + 256Mbytes=0x1C000000, 13x10, 8 Banks -  For 7105
+    
+    if parameters.has_key("lmi_16bits_mode"):
+        lmi.LMI_SDRA0_0.poke(0x20000e20)
+    else:
+        #lmi.LMI_SDRA0_0.poke(0x14000a20)
+        #update for 7105
+        lmi.LMI_SDRA0_0.poke(0x2c001e20)
+
+    # SDRAM Array Attribute Register
+    # Upper LMI addr=0x0C000000 + 128Mbytes=0x14000000, 13x10 - For 7111
+    # Upper LMI addr=0x0C000000 + 256Mbytes=0x1C000000, 13x10, 8 Banks -  For 7105
+    if parameters.has_key("lmi_16bits_mode"):
+        lmi.LMI_SDRA1_0.poke(0x20000e20)
+    else:
+        #lmi.LMI_SDRA1_0.poke(0x14000a20)
+        #update for 7105
+        lmi.LMI_SDRA1_0.poke(0x2c001e20)
+
+    # SDRAM Control Register
+    sttp.stmc.delay(200000)
+    # Enable clock with NOP command
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020023)
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Precharge all
+    lmi.LMI_SCR_0.poke(0x00020022)
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Issue EMRS2
+#    lmi.LMI_SDMR0_0.poke(0x00000800)
+    lmi.LMI_SDMR0_0.poke(0x00010000)
+
+    # Issue EMRS3
+#    lmi.LMI_SDMR0_0.poke(0x00000c00)
+    lmi.LMI_SDMR0_0.poke(0x00018000)
+
+    # Issue EMRS1 to enable DLL
+    #lmi.LMI_SDMR0_0.poke(0x00000400)
+    lmi.LMI_SDMR0_0.poke(0x00008004)
+
+    # Issue MRS with DLL reset, CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+    # lmi.LMI_SDMR0_0.poke(0x00000953)
+    # FCh, 19/mar/08: change according to Raffaele G feebacks
+    lmi.LMI_SDMR0_0.poke(0x00004363)
+
+    # Wait NOP command for 400 nsec
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    # Precharge all
+    lmi.LMI_SCR_0.poke(0x00020022)
+    # 2 CBR (auto refresh)
+    lmi.LMI_SCR_0.poke(0x00020024)
+    lmi.LMI_SCR_0.poke(0x00020024)
+
+    # Issue MRS with CAS 5, Write recovery 5, Sequentiel, Burst lengh 8
+    # lmi.LMI_SDMR0_0.poke(0x00000853)
+    # FCh, 19/mar/08: change according to Raffaele G feebacks
+    lmi.LMI_SDMR0_0.poke(0x00004263)
+
+    # Issue EMRS1 for OCD calibration default
+#    lmi.LMI_SDMR0_0.poke(0x000007c4)
+
+    # Issue EMRS1 for OCD calibration exit
+#    lmi.LMI_SDMR0_0.poke(0x00000444)
+
+    # Enable auto refresh
+    # lmi.LMI_MIM_0.poke(0x0c30037b)
+    # FCh, 12/feb/08: cleaner to modify only refresh bit
+    lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() | (1<<9))
+    
+    # DQS recovery mechanism (1=enabled)
+    # RGW080410 Surely it should be enabled
+    lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() | (1 << 5))
+    # FCh, 14/jan/08, NO DQS recovery
+    #lmi.LMI_MIM_0.poke(lmi.LMI_MIM_0.peek() & ~(1 << 5))
+
+    #sttp.logging.print_out("MIM0=0x%X" % (lmi.LMI_MIM_0.peek()))
+    
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+    lmi.LMI_SCR_0.poke(0x00020021)
+
+    lmi.LMI_GCC_0.poke(0x00000000)
+
+# SE mode functions setup the PMBs based on the RAM fitted to the board
+
+# Switch to 32-bit SE mode
+
+def se_mode_prep():
+    sysconf = sttp_root.stx7105.SYSCONF.stx7105_sysconf_regs
+    lmi0 = sttp_root.stx7105.LMI0.st40_lmigp_regs
+   
+    # Poke LMI control register to move LMI base addresses to SE mode addresses
+    sysconf.SYSCONF_CFG38.poke((sysconf.SYSCONF_CFG38.peek() & 0xFFFFFF00) | 0x00000040)
+   
+    # Change LMI upper bound addresses
+    # Upper LMI addr=0x40000000 + 512Mbytes=0x60000000
+    uba = 0x60000000 & 0xFFE00000
+    lmi0.LMI_SDRA0_0.poke((lmi0.LMI_SDRA0_0.peek()&0x1FFFFF)|uba)
+    lmi0.LMI_SDRA1_0.poke((lmi0.LMI_SDRA1_0.peek()&0x1FFFFF)|uba)
+
+def switch_on_se(mode):
+    se_mode_prep()
+
+    # Configure the PMBs
+    st40_pmb_regs.st40_pmb_control_initialise()
+    st40_pmb_regs.st40_clear_all_pmbs()
+    if mode=="seuc":
+        st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(2, 0x90, 0x50, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(3, 0x98, 0x58, 128, 0, 0, 1)
+    elif mode=="se29":
+        st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128)
+        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
+        st40_pmb_regs.st40_set_pmb(2, 0x90, 0x50, 128)
+        st40_pmb_regs.st40_set_pmb(3, 0x98, 0x58, 128)
+        st40_pmb_regs.st40_set_pmb(4, 0xa0, 0x40, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(5, 0xa8, 0x48, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(6, 0xb0, 0x50, 128, 0, 0, 1)
+        st40_pmb_regs.st40_set_pmb(7, 0xb8, 0x58, 128, 0, 0, 1)
+    else: # Default is normal SE mode
+        st40_pmb_regs.st40_set_pmb(0, 0x80, 0x40, 128)
+        st40_pmb_regs.st40_set_pmb(1, 0x88, 0x48, 128)
+        st40_pmb_regs.st40_set_pmb(2, 0x90, 0x50, 128)
+        st40_pmb_regs.st40_set_pmb(3, 0x98, 0x58, 128)
+
+    # Switch to 32-bit SE mode
+    st40_pmb_regs.st40_enhanced_mode(1)
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/sdk7105/sdk7105.xml opt/STM/STLinux-2.3/host/stmc/targetpack/boards/sdk7105/sdk7105.xml
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/sdk7105/sdk7105.xml	1970-01-01 00:00:00.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/sdk7105/sdk7105.xml	2009-02-05 12:41:35.521494762 +0000
@@ -0,0 +1,60 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<spirit:component
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.2"
+  xmlns:sttp="http://www.st.com/XMLSchema/TargetPack">
+
+  <spirit:vendor>ST</spirit:vendor>
+  <spirit:library>sdk7105</spirit:library>
+  <spirit:name>sdk7105</spirit:name>
+  <spirit:version>1.0</spirit:version>
+
+  <spirit:model>
+    <spirit:views>
+      <spirit:view>
+        <spirit:name>sdk7105</spirit:name>
+        <spirit:envIdentifier>::</spirit:envIdentifier>
+        <spirit:hierarchyRef
+         spirit:vendor="ST"
+         spirit:library="sdk7105_design"
+         spirit:name="sdk7105_design"
+         spirit:version="1.0"/>
+      </spirit:view>
+    </spirit:views>
+  </spirit:model>
+
+  <!-- Board/SoC configuration -->
+  <spirit:configurators>
+     <sttp:initFunction>sdk7105_connect</sttp:initFunction>
+     <sttp:deInitFunction>sdk7105_disconnect</sttp:deInitFunction>
+  </spirit:configurators>
+
+  <!-- Files used to for board/SoC configuration -->
+  <spirit:fileSets>
+    <spirit:fileSet spirit:fileSetId="TargetScript">
+      <spirit:file>
+        <spirit:name>sdk7105.py</spirit:name>
+        <spirit:fileType>unknown</spirit:fileType>
+      </spirit:file>
+    </spirit:fileSet>
+  </spirit:fileSets>
+
+  <!-- Files used to for board/SoC configuration -->
+  <spirit:parameter spirit:name="jtagpinout">STMC_Type_A</spirit:parameter>
+  <spirit:parameter spirit:name="jtagpinout_lvds">STMC_Type_F</spirit:parameter>
+
+  <spirit:parameter spirit:name="tck_boot_max">3000000</spirit:parameter>
+  <spirit:parameter spirit:name="tck_bypass_max">12500000</spirit:parameter>
+  <spirit:parameter spirit:name="tck_tapmux_max">25000000</spirit:parameter>
+  <spirit:parameter spirit:name="tck_stmc1_max">10000000</spirit:parameter>
+
+  <!--debugram reserved for ST200 toolset when in 29 bit mode-->
+  <spirit:parameter spirit:name="debugram_base">0x1BFFC000</spirit:parameter>
+  <spirit:parameter spirit:name="debugram_size">16384</spirit:parameter>
+
+  <!--debugram reserved for ST200 toolset when in 32 bit (Space Enhanced) mode-->
+  <spirit:parameter spirit:name="debugram_base_se">0x4FFFC000</spirit:parameter>
+  <spirit:parameter spirit:name="debugram_size_se">16384</spirit:parameter>
+</spirit:component>
+
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/sdk7105/sdk7105_design.xml opt/STM/STLinux-2.3/host/stmc/targetpack/boards/sdk7105/sdk7105_design.xml
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/boards/sdk7105/sdk7105_design.xml	1970-01-01 00:00:00.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/boards/sdk7105/sdk7105_design.xml	2009-02-05 12:41:35.521494762 +0000
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<spirit:design
+  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.2"
+  xmlns:sttp="http://www.st.com/XMLSchema/TargetPack">
+
+  <spirit:vendor>ST</spirit:vendor>
+  <spirit:library>sdk7105_design</spirit:library>
+  <spirit:name>sdk7105_design</spirit:name>
+  <spirit:version>1.0</spirit:version>
+
+  <spirit:componentInstances>
+    <spirit:componentInstance>
+      <spirit:instanceName>stx7105</spirit:instanceName>
+      <spirit:componentRef spirit:library="stx7105" spirit:name="stx7105"
+                           spirit:vendor="ST" spirit:version="1.0" />
+    </spirit:componentInstance>
+  </spirit:componentInstances>
+
+</spirit:design>
+
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/socs/stx7105/stx7105.py opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7105/stx7105.py
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/socs/stx7105/stx7105.py	2009-02-05 12:42:19.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/socs/stx7105/stx7105.py	2009-02-05 12:41:35.521494762 +0000
@@ -526,17 +526,17 @@
     sttp.pokepeek.poke(0xfe1fff04,0x254608)
     sttp.pokepeek.poke(0xfeafff04,0x254608)
     
-    # SATA (power down must be disabled first)
-    sttp.pokepeek.poke(0xfe001180, sttp.pokepeek.peek(0xfe001180) & ~(0x800) )
-    sttp.pokepeek.poke(0xfe001180, sttp.pokepeek.peek(0xfe001180) | (0x400) )
-    sttp.pokepeek.poke(0xfe209000,0x13)
-    sttp.pokepeek.poke(0xfe209004,0x3)
-    sttp.pokepeek.poke(0xfe209008,0x0)
-    sttp.pokepeek.poke(0xfd100000,0x13)
-    sttp.pokepeek.poke(0xfd100004,0x3)
-    sttp.pokepeek.poke(0xfd100008,0x0) 
+    # SATA (to be adjusted)
+    #sttp.pokepeek.poke(0xfe001180, sttp.pokepeek.peek(0xfe001180) & ~(0x800) )
+    #sttp.pokepeek.poke(0xfe001180, sttp.pokepeek.peek(0xfe001180) | (0x400) )
+    #sttp.pokepeek.poke(0xfe209000,0x13)
+    #sttp.pokepeek.poke(0xfe209004,0x3)
+    #sttp.pokepeek.poke(0xfe209008,0x0)
+    #sttp.pokepeek.poke(0xfd100000,0x13)
+    #sttp.pokepeek.poke(0xfd100004,0x3)
+    #sttp.pokepeek.poke(0xfd100008,0x0) 
 
-    # Ethernet (power down must be disbaled first)
+    # Ethernet (power down must be disabled first)
     sttp.pokepeek.poke(0xfe00111C, sttp.pokepeek.peek(0xfe00111C) | (0x10000) )
     sttp.pokepeek.poke(0xfd117000,0x25c608)
     sttp.pokepeek.poke(0xfd111000,0x201004) 
diff -Nur opt/STM/STLinux-2.3.orig/host/stmc/targetpack/sttp.xml opt/STM/STLinux-2.3/host/stmc/targetpack/sttp.xml
--- opt/STM/STLinux-2.3.orig/host/stmc/targetpack/sttp.xml	2009-02-05 12:42:19.000000000 +0000
+++ opt/STM/STLinux-2.3/host/stmc/targetpack/sttp.xml	2009-02-05 12:41:35.521494762 +0000
@@ -24,8 +24,10 @@
     <sttp:directory sttp:path="$STTPROOT/boards/mb618"/>
     <sttp:directory sttp:path="$STTPROOT/boards/mb628"/>
     <sttp:directory sttp:path="$STTPROOT/boards/mb671"/>
+    <sttp:directory sttp:path="$STTPROOT/boards/cb161"/>
     <sttp:directory sttp:path="$STTPROOT/boards/mb680"/>
     <sttp:directory sttp:path="$STTPROOT/boards/mb704"/>
+    <sttp:directory sttp:path="$STTPROOT/boards/sdk7105"/>
     <sttp:directory sttp:path="$STTPROOT/boards/st20board"/>
     <sttp:directory sttp:path="$STTPROOT/boards/stx710xboard"/>
     <sttp:directory sttp:path="$STTPROOT/boards/sti7200board"/>
