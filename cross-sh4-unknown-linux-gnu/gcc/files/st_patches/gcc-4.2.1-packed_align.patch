
Index: gcc-4.2.1/gcc/tree.h
===================================================================
--- gcc-4.2.1.orig/gcc/tree.h	2007-03-12 04:40:09.000000000 +0000
+++ gcc-4.2.1/gcc/tree.h	2008-02-14 09:39:50.000000000 +0000
@@ -4112,6 +4112,12 @@
 				 tree *, enum machine_mode *, int *, int *,
 				 bool);
 
+/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,
+   look for whether EXP or any nested component-refs within EXP is marked
+   as PACKED.  */
+
+extern bool contains_packed_reference (tree exp);
+
 /* Return 1 if T is an expression that get_inner_reference handles.  */
 
 extern int handled_component_p (tree);
Index: gcc-4.2.1/gcc/testsuite/gcc.dg/packed-array.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gcc-4.2.1/gcc/testsuite/gcc.dg/packed-array.c	2008-02-14 09:39:50.000000000 +0000
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-inline" } */
+
+struct usb_interface_descriptor {
+ unsigned short wMaxPacketSize;
+  char e;
+} __attribute__ ((packed));
+
+struct usb_device {
+ int devnum;
+ struct usb_interface_descriptor if_desc[2];
+};
+
+extern int printf (const char *, ...);
+
+void foo (unsigned short a)
+{
+  printf ("%d\n", a);
+}
+
+struct usb_device ndev;
+
+void usb_set_maxpacket(int n)
+{
+  int i;
+
+  for(i=0; i<n;i++)
+    foo((&ndev)->if_desc[i].wMaxPacketSize);
+}
+
+int
+main()
+{
+  usb_set_maxpacket(2);
+  return 0;
+}
+
+
+
+
Index: gcc-4.2.1/gcc/testsuite/ChangeLog.STM
===================================================================
--- gcc-4.2.1.orig/gcc/testsuite/ChangeLog.STM	2008-02-14 09:34:27.000000000 +0000
+++ gcc-4.2.1/gcc/testsuite/ChangeLog.STM	2008-02-14 09:45:10.000000000 +0000
@@ -1,5 +1,9 @@
+2008-01-28  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=3313
+	* gcc.dg/packed-array.c: New testcase.
+
 2007-06-20  Christian Bruel  <christian.bruel@st.com>
 
 	* gcc.dg/attr-isr.c: Test delay slot content.
 
-	
\ No newline at end of file
Index: gcc-4.2.1/gcc/tree-ssa-loop-ivopts.c
===================================================================
--- gcc-4.2.1.orig/gcc/tree-ssa-loop-ivopts.c	2006-10-06 20:32:04.000000000 +0100
+++ gcc-4.2.1/gcc/tree-ssa-loop-ivopts.c	2008-02-14 09:45:10.000000000 +0000
@@ -1433,10 +1433,13 @@
   return true;
 }
 
+static bool loop_offset_multiple_of (struct ivopts_data *, tree, tree);
+static tree iv_value (struct iv *, tree);
+
 /* Returns true if memory reference REF may be unaligned.  */
 
 static bool
-may_be_unaligned_p (tree ref)
+may_be_unaligned_p (struct ivopts_data *data, tree ref)
 {
   tree base;
   tree base_type;
@@ -1460,11 +1463,18 @@
   base_type = TREE_TYPE (base);
   base_align = TYPE_ALIGN (base_type);
 
-  if (mode != BLKmode
-      && (base_align < GET_MODE_ALIGNMENT (mode)
-	  || bitpos % GET_MODE_ALIGNMENT (mode) != 0
-	  || bitpos % BITS_PER_UNIT != 0))
-    return true;
+  if (mode != BLKmode) {
+    if (base_align < GET_MODE_ALIGNMENT (mode)
+	|| bitpos % GET_MODE_ALIGNMENT (mode) != 0
+	|| bitpos % BITS_PER_UNIT != 0)
+      return true;
+
+    if (toffset && contains_packed_reference (ref)) {
+      tree al = build_int_cst (NULL_TREE, GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT);
+      if (!loop_offset_multiple_of (data, toffset, al))
+	return true;
+    }
+  }
 
   return false;
 }
@@ -1522,7 +1532,7 @@
     goto fail;
 
   if (STRICT_ALIGNMENT
-      && may_be_unaligned_p (base))
+      && may_be_unaligned_p (data, base))
     goto fail;
 
   base = unshare_expr (base);
@@ -2609,8 +2619,8 @@
       if (TREE_CODE (bot) != INTEGER_CST)
 	return false;
 
-      p0 = double_int_sext (tree_to_double_int (bot), precision);
-      p1 = double_int_sext (tree_to_double_int (top), precision);
+      p0 = double_int_sext (tree_to_double_int (top), precision);
+      p1 = double_int_sext (tree_to_double_int (bot), precision);
       if (double_int_zero_p (p1))
 	return false;
       *mul = double_int_sext (double_int_sdivmod (p0, p1, FLOOR_DIV_EXPR, &res),
@@ -2622,6 +2632,56 @@
     }
 }
 
+/* Returns true if OFFSET is always a multiple of alignment AL
+   even if loop carried.  */
+
+static bool
+loop_offset_multiple_of (struct ivopts_data *data, tree offset, tree al)
+{
+  double_int mul;
+
+  STRIP_NOPS (offset);
+
+  if (TREE_CODE (offset) == SSA_NAME) {
+    if (constant_multiple_of (offset, al, &mul))
+      return true;
+  }
+
+  if (TREE_CODE (offset) == MULT_EXPR) {
+    tree op0 = TREE_OPERAND (offset, 0);
+    tree op1 = TREE_OPERAND (offset, 1);
+    STRIP_NOPS (op0);
+    STRIP_NOPS (op1);
+
+    if (TREE_CODE (op1) != INTEGER_CST)
+      return false;
+
+    if (TREE_CODE (op0) == SSA_NAME) {
+      struct iv *civ = get_iv (data, op0);
+      if (!civ || zero_p (civ->step)
+	  || constant_multiple_of (iv_value (civ, op1), al, &mul))
+	return true;
+
+    }
+    else if (loop_offset_multiple_of (data, op0, al))
+      return true;
+  }
+
+  else if (TREE_CODE (offset) == PLUS_EXPR || TREE_CODE (offset) == MINUS_EXPR) {
+    tree op0 = TREE_OPERAND (offset, 0);
+    tree op1 = TREE_OPERAND (offset, 1);
+    if (loop_offset_multiple_of (data, op0, al) &&
+	loop_offset_multiple_of (data, op1, al))
+      return true;
+  }
+
+  else if (TREE_CODE (offset) == INTEGER_CST) {
+    return constant_multiple_of (offset, al, &mul);
+  }
+
+  return false;
+}
+
 /* Sets COMB to CST.  */
 
 static void
Index: gcc-4.2.1/gcc/expr.c
===================================================================
--- gcc-4.2.1.orig/gcc/expr.c	2007-04-23 02:57:48.000000000 +0100
+++ gcc-4.2.1/gcc/expr.c	2008-02-14 09:45:10.000000000 +0000
@@ -5789,6 +5789,47 @@
   return exp;
 }
 
+/* Given an expression EXP that may be a COMPONENT_REF or an ARRAY_REF,
+   look for whether EXP or any nested component-refs within EXP is marked
+   as PACKED.  */
+
+bool
+contains_packed_reference (tree exp)
+{
+  bool packed_p = false;
+
+  while (1)
+    {
+      switch (TREE_CODE (exp))
+	{
+	case COMPONENT_REF:
+	  {
+	    tree field = TREE_OPERAND (exp, 1);
+	    packed_p = DECL_PACKED (field)
+		       || TYPE_PACKED (TREE_TYPE (field))
+		       || TYPE_PACKED (TREE_TYPE (exp));
+	    if (packed_p)
+	      goto done;
+	  }
+	  break;
+
+	case BIT_FIELD_REF:
+	case ARRAY_REF:
+	case ARRAY_RANGE_REF:
+	case REALPART_EXPR:
+	case IMAGPART_EXPR:
+	case VIEW_CONVERT_EXPR:
+	  break;
+
+	default:
+	  goto done;
+	}
+      exp = TREE_OPERAND (exp, 0);
+    }
+ done:
+  return packed_p;
+}
+
 /* Return a tree of sizetype representing the size, in bytes, of the element
    of EXP, an ARRAY_REF.  */
 
Index: gcc-4.2.1/gcc/ChangeLog.STM
===================================================================
--- gcc-4.2.1.orig/gcc/ChangeLog.STM	2008-02-14 09:34:27.000000000 +0000
+++ gcc-4.2.1/gcc/ChangeLog.STM	2008-02-14 09:44:43.000000000 +0000
@@ -1,3 +1,12 @@
+
+2008-01-28  Christian Bruel  <christian.bruel@st.com>
+
+	https://bugzilla.stlinux.com/show_bug.cgi?id=3313
+	* tree-ssa-loop-ivopts.c (may_be_unaligned_p): Check loop offset.
+	(loop_offset_multiple_of): New function.
+	* tree.h (contains_packed_reference): Backmerge proto from trunk.
+	* expr.c (contains_packed_reference): Backmerge function from trunk.
+
 2007-07-16  Christian Bruel  <christian.bruel@st.com>
 
 	* config/sh/sh.h (MOVE_MAX_PIECES): Tuned for TARGET_SH1.
