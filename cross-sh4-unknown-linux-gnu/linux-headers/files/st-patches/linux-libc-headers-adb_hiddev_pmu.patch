diff -upNr linux-libc-headers-2.6.16.16/include/linux/adb.h linux-libc-headers-2.6.16.16-stm/include/linux/adb.h
--- linux-libc-headers-2.6.16.16/include/linux/adb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.16.16-stm/include/linux/adb.h	2006-09-07 14:00:11.496970880 +0200
@@ -0,0 +1,36 @@
+/*
+ * Definitions for ADB (Apple Desktop Bus) support.
+ */
+#ifndef __ADB_H
+#define __ADB_H
+
+/* ADB commands */
+#define ADB_BUSRESET		0
+#define ADB_FLUSH(id)		(0x01 | ((id) << 4))
+#define ADB_WRITEREG(id, reg)	(0x08 | (reg) | ((id) << 4))
+#define ADB_READREG(id, reg)	(0x0C | (reg) | ((id) << 4))
+
+/* ADB default device IDs (upper 4 bits of ADB command byte) */
+#define ADB_DONGLE	1	/* "software execution control" devices */
+#define ADB_KEYBOARD	2
+#define ADB_MOUSE	3
+#define ADB_TABLET	4
+#define ADB_MODEM	5
+#define ADB_MISC	7	/* maybe a monitor */
+
+#define ADB_RET_OK	0
+#define ADB_RET_TIMEOUT	3
+
+/* The kind of ADB request. The controller may emulate some
+   or all of those CUDA/PMU packet kinds */
+#define ADB_PACKET	0
+#define CUDA_PACKET	1
+#define ERROR_PACKET	2
+#define TIMER_PACKET	3
+#define POWER_PACKET	4
+#define MACIIC_PACKET	5
+#define PMU_PACKET	6
+
+
+
+#endif /* __ADB_H */
diff -upNr linux-libc-headers-2.6.16.16/include/linux/hiddev.h linux-libc-headers-2.6.16.16-stm/include/linux/hiddev.h
--- linux-libc-headers-2.6.16.16/include/linux/hiddev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.16.16-stm/include/linux/hiddev.h	2006-09-07 14:00:02.957269112 +0200
@@ -0,0 +1,174 @@
+#ifndef _HIDDEV_H
+#define _HIDDEV_H
+
+/*
+ * $Id: hiddev.h,v 1.2 2001/10/31 16:18:26 arjanv Exp $
+ *
+ *  Copyright (c) 1999-2000 Vojtech Pavlik
+ *
+ *  Sponsored by SuSE
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or 
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * 
+ * Should you need to contact me, the author, you can do so either by
+ * e-mail - mail your message to <vojtech@suse.cz>, or by paper mail:
+ * Vojtech Pavlik, Ucitelska 1576, Prague 8, 182 00 Czech Republic
+ */
+
+/*
+ * The event structure itself
+ */
+
+struct hiddev_event {
+	unsigned hid;
+	signed int value;
+};
+
+struct hiddev_devinfo {
+	unsigned int bustype;
+	unsigned int busnum;
+	unsigned int devnum;
+	unsigned int ifnum;
+	short vendor;
+	short product;
+	short version;
+	unsigned num_applications;
+};
+
+#define HID_STRING_SIZE 256
+struct hiddev_string_descriptor {
+	int index;
+	char value[HID_STRING_SIZE];
+};
+
+struct hiddev_report_info {
+	unsigned report_type;
+	unsigned report_id;
+	unsigned num_fields;
+};
+
+/* To do a GUSAGE/SUSAGE, fill in at least usage_code,  report_type and 
+ * report_id.  Set report_id to REPORT_ID_UNKNOWN if the rest of the fields 
+ * are unknown.  Otherwise use a usage_ref struct filled in from a previous 
+ * successful GUSAGE/SUSAGE call to save time.  To actually send a value
+ * to the device, perform a SUSAGE first, followed by a SREPORT.  If an
+ * INITREPORT is done, a GREPORT isn't necessary before a GUSAGE.
+ */
+#define HID_REPORT_ID_UNKNOWN 0xffffffff
+#define HID_REPORT_ID_FIRST   0x00000100
+#define HID_REPORT_ID_NEXT    0x00000200
+#define HID_REPORT_ID_MASK    0x000000ff
+#define HID_REPORT_ID_MAX     0x000000ff
+
+#define HID_REPORT_TYPE_INPUT	1
+#define HID_REPORT_TYPE_OUTPUT	2
+#define HID_REPORT_TYPE_FEATURE	3
+#define HID_REPORT_TYPE_MIN     1
+#define HID_REPORT_TYPE_MAX     3
+
+struct hiddev_field_info {
+	unsigned report_type;
+	unsigned report_id;
+	unsigned field_index;
+	unsigned maxusage;
+	unsigned flags;
+	unsigned physical;		/* physical usage for this field */
+	unsigned logical;		/* logical usage for this field */
+	unsigned application;		/* application usage for this field */
+	__s32 logical_minimum;
+	__s32 logical_maximum;
+	__s32 physical_minimum;
+	__s32 physical_maximum;
+	unsigned unit_exponent;
+	unsigned unit;
+};
+
+/* Fill in report_type, report_id and field_index to get the information on a
+ * field.
+ */
+#define HID_FIELD_CONSTANT		0x001
+#define HID_FIELD_VARIABLE		0x002
+#define HID_FIELD_RELATIVE		0x004
+#define HID_FIELD_WRAP			0x008	
+#define HID_FIELD_NONLINEAR		0x010
+#define HID_FIELD_NO_PREFERRED		0x020
+#define HID_FIELD_NULL_STATE		0x040
+#define HID_FIELD_VOLATILE		0x080
+#define HID_FIELD_BUFFERED_BYTE		0x100
+
+struct hiddev_usage_ref {
+	unsigned report_type;
+	unsigned report_id;
+	unsigned field_index;
+	unsigned usage_index;
+	unsigned usage_code;
+	__s32 value;
+};
+
+
+/*
+ * Protocol version.
+ */
+
+#define HID_VERSION		0x010002
+
+/*
+ * IOCTLs (0x00 - 0x7f)
+ */
+
+#define HIDIOCGVERSION		_IOR('H', 0x01, int)
+#define HIDIOCAPPLICATION	_IO('H', 0x02)
+#define HIDIOCGDEVINFO		_IOR('H', 0x03, struct hiddev_devinfo)
+#define HIDIOCGSTRING		_IOR('H', 0x04, struct hiddev_string_descriptor)
+#define HIDIOCINITREPORT	_IO('H', 0x05)
+#define HIDIOCGNAME(len)	_IOC(_IOC_READ, 'H', 0x06, len)
+#define HIDIOCGREPORT		_IOW('H', 0x07, struct hiddev_report_info)
+#define HIDIOCSREPORT		_IOW('H', 0x08, struct hiddev_report_info)
+#define HIDIOCGREPORTINFO       _IOWR('H', 0x09, struct hiddev_report_info)
+#define HIDIOCGFIELDINFO        _IOWR('H', 0x0A, struct hiddev_field_info)
+#define HIDIOCGUSAGE            _IOWR('H', 0x0B, struct hiddev_usage_ref)
+#define HIDIOCSUSAGE            _IOW('H', 0x0C, struct hiddev_usage_ref)
+#define HIDIOCGUCODE            _IOWR('H', 0x0D, struct hiddev_usage_ref)
+
+/* To traverse the input report descriptor info for a HID device, perform the 
+ * following:
+ *
+ *  rinfo.report_type = HID_REPORT_TYPE_INPUT;
+ *  rinfo.report_id = HID_REPORT_ID_FIRST;
+ *  ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);
+ *
+ *  while (ret >= 0) {
+ *      for (i = 0; i < rinfo.num_fields; i++) { 
+ *	    finfo.report_type = rinfo.report_type;
+ *          finfo.report_id = rinfo.report_id;
+ *          finfo.field_index = i;
+ *          ioctl(fd, HIDIOCGFIELDINFO, &finfo);
+ *          for (j = 0; j < finfo.maxusage; j++) {
+ *              uref.field_index = i;
+ *		uref.usage_index = j;
+ *		ioctl(fd, HIDIOCGUCODE, &uref);
+ *		ioctl(fd, HIDIOCGUSAGE, &uref);
+ *          }
+ *	}
+ *	uref.report_id |= HID_REPORT_ID_NEXT;
+ *	ret = ioctl(fd, HIDIOCGREPORTINFO, &uref);
+ *  }
+ */
+
+
+
+#endif
diff -upNr linux-libc-headers-2.6.16.16/include/linux/pmu.h linux-libc-headers-2.6.16.16/include/linux/pmu.h
--- linux-libc-headers-2.6.16.16/include/linux/pmu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-libc-headers-2.6.16.16-stm/include/linux/pmu.h	2006-09-07 14:00:18.947838176 +0200
@@ -0,0 +1,116 @@
+/*
+ * Definitions for talking to the PMU.  The PMU is a microcontroller
+ * which controls battery charging and system power on PowerBook 3400
+ * and 2400 models as well as the RTC and various other things.
+ *
+ * Copyright (C) 1998 Paul Mackerras.
+ */
+
+#include <linux/config.h>
+
+#define PMU_DRIVER_VERSION	2
+
+/*
+ * PMU commands
+ */
+#define PMU_POWER_CTRL0		0x10	/* control power of some devices */
+#define PMU_POWER_CTRL		0x11	/* control power of some devices */
+#define PMU_ADB_CMD		0x20	/* send ADB packet */
+#define PMU_ADB_POLL_OFF	0x21	/* disable ADB auto-poll */
+#define PMU_WRITE_NVRAM		0x33	/* write non-volatile RAM */
+#define PMU_READ_NVRAM		0x3b	/* read non-volatile RAM */
+#define PMU_SET_RTC		0x30	/* set real-time clock */
+#define PMU_READ_RTC		0x38	/* read real-time clock */
+#define PMU_SET_VOLBUTTON	0x40	/* set volume up/down position */
+#define PMU_BACKLIGHT_BRIGHT	0x41	/* set backlight brightness */
+#define PMU_GET_VOLBUTTON	0x48	/* get volume up/down position */
+#define PMU_PCEJECT		0x4c	/* eject PC-card from slot */
+#define PMU_BATTERY_STATE	0x6b	/* report battery state etc. */
+#define PMU_SMART_BATTERY_STATE	0x6f	/* report battery state (new way) */
+#define PMU_SET_INTR_MASK	0x70	/* set PMU interrupt mask */
+#define PMU_INT_ACK		0x78	/* read interrupt bits */
+#define PMU_SHUTDOWN		0x7e	/* turn power off */
+#define PMU_SLEEP		0x7f	/* put CPU to sleep */
+#define PMU_POWER_EVENTS	0x8f	/* Send power-event commands to PMU */
+#define PMU_RESET		0xd0	/* reset CPU */
+#define PMU_GET_BRIGHTBUTTON	0xd9	/* report brightness up/down pos */
+#define PMU_GET_COVER		0xdc	/* report cover open/closed */
+#define PMU_SYSTEM_READY	0xdf	/* tell PMU we are awake */
+#define PMU_GET_VERSION		0xea	/* read the PMU version */
+
+/* Bits to use with the PMU_POWER_CTRL0 command */
+#define PMU_POW0_ON		0x80	/* OR this to power ON the device */
+#define PMU_POW0_OFF		0x00	/* leave bit 7 to 0 to power it OFF */
+#define PMU_POW0_HARD_DRIVE	0x04	/* Hard drive power (on wallstreet/lombard ?) */
+
+/* Bits to use with the PMU_POWER_CTRL command */
+#define PMU_POW_ON		0x80	/* OR this to power ON the device */
+#define PMU_POW_OFF		0x00	/* leave bit 7 to 0 to power it OFF */
+#define PMU_POW_BACKLIGHT	0x01	/* backlight power */
+#define PMU_POW_CHARGER		0x02	/* battery charger power */
+#define PMU_POW_IRLED		0x04	/* IR led power (on wallstreet) */
+#define PMU_POW_MEDIABAY	0x08	/* media bay power (wallstreet/lombard ?) */
+
+/* Bits in PMU interrupt and interrupt mask bytes */
+#define PMU_INT_PCEJECT		0x04	/* PC-card eject buttons */
+#define PMU_INT_SNDBRT		0x08	/* sound/brightness up/down buttons */
+#define PMU_INT_ADB		0x10	/* ADB autopoll or reply data */
+#define PMU_INT_BATTERY		0x20	/* Battery state change */
+#define PMU_INT_ENVIRONMENT	0x40	/* Environment interrupts */
+#define PMU_INT_TICK		0x80	/* 1-second tick interrupt */
+
+/* Other bits in PMU interrupt valid when PMU_INT_ADB is set */
+#define PMU_INT_ADB_AUTO	0x04	/* ADB autopoll, when PMU_INT_ADB */
+#define PMU_INT_WAITING_CHARGER	0x01	/* ??? */
+#define PMU_INT_AUTO_SRQ_POLL	0x02	/* ??? */
+
+/* Bits in the environement message (either obtained via PMU_GET_COVER,
+ * or via PMU_INT_ENVIRONMENT on core99 */
+#define PMU_ENV_LID_CLOSED	0x01	/* The lid is closed */
+
+/* Kind of PMU (model) */
+enum {
+	PMU_UNKNOWN,
+	PMU_OHARE_BASED,	/* 2400, 3400, 3500 (old G3 powerbook) */
+	PMU_HEATHROW_BASED,	/* PowerBook G3 series */
+	PMU_PADDINGTON_BASED,	/* 1999 PowerBook G3 */
+	PMU_KEYLARGO_BASED,	/* Core99 motherboard (PMU99) */
+};
+
+/* PMU PMU_POWER_EVENTS commands */
+enum {
+	PMU_PWR_GET_POWERUP_EVENTS	= 0x00,
+	PMU_PWR_SET_POWERUP_EVENTS	= 0x01,
+	PMU_PWR_CLR_POWERUP_EVENTS	= 0x02,
+	PMU_PWR_GET_WAKEUP_EVENTS	= 0x03,
+	PMU_PWR_SET_WAKEUP_EVENTS	= 0x04,
+	PMU_PWR_CLR_WAKEUP_EVENTS	= 0x05,
+};
+
+/* Power events wakeup bits */
+enum {
+	PMU_PWR_WAKEUP_KEY		= 0x01,	/* Wake on key press */
+	PMU_PWR_WAKEUP_AC_INSERT	= 0x02, /* Wake on AC adapter plug */
+	PMU_PWR_WAKEUP_AC_CHANGE	= 0x04,
+	PMU_PWR_WAKEUP_LID_OPEN		= 0x08,
+	PMU_PWR_WAKEUP_RING		= 0x10,
+};
+	
+/*
+ * Ioctl commands for the /dev/pmu device
+ */
+#include <linux/ioctl.h>
+
+/* no param */
+#define PMU_IOC_SLEEP		_IO('B', 0)
+/* out param: u32*	backlight value: 0 to 15 */
+#define PMU_IOC_GET_BACKLIGHT	_IOR('B', 1, sizeof(__u32*))
+/* in param: u32	backlight value: 0 to 15 */
+#define PMU_IOC_SET_BACKLIGHT	_IOW('B', 2, sizeof(__u32))
+/* out param: u32*	PMU model */
+#define PMU_IOC_GET_MODEL	_IOR('B', 3, sizeof(__u32*))
+/* out param: u32*	has_adb: 0 or 1 */
+#define PMU_IOC_HAS_ADB		_IOR('B', 4, sizeof(__u32*)) 
+/* out param: u32*	can_sleep: 0 or 1 */
+#define PMU_IOC_CAN_SLEEP	_IOR('B', 5, sizeof(__u32*)) 
+
