--- glibc/linuxthreads/tst-cancel8.c	2003-10-02 19:47:57.000000000 +0100
+++ glibc-carl/linuxthreads/tst-cancel8.c	2005-03-01 10:57:30.000000000 +0000
@@ -43,12 +43,13 @@
 static void __attribute__ ((noinline))
 clobber_lots_of_regs (void)
 {
-#define X1(n) long r##n = 10##n; __asm __volatile ("" : "+r" (r##n));
+	
+#define X1(n) { long r##n = 10##n; __asm __volatile ("" : "=r" (r##n)); }
 #define X2(n) X1(n##0) X1(n##1) X1(n##2) X1(n##3) X1(n##4)
 #define X3(n) X2(n##0) X2(n##1) X2(n##2) X2(n##3) X2(n##4)
   X3(0) X3(1) X3(2) X3(3) X3(4)
 #undef X1
-#define X1(n) __asm __volatile ("" : : "r" (r##n));
+#define X1(n) { long r##n = 10##n; __asm __volatile ("" : : "r" (r##n)); }
   X3(0) X3(1) X3(2) X3(3) X3(4)
 #undef X1
 #undef X2
@@ -63,6 +64,11 @@
   int ret = 0;
   int fd[2];
 
+  struct sigaction sa;
+  struct itimerval it;
+  char fname[] = "/tmp/tst-lt-cancel8-dir-XXXXXX\0foo/bar";
+  char *enddir;
+
   rc = pipe (fd);
   if (rc < 0)
     error (EXIT_FAILURE, errno, "couldn't create pipe");
@@ -116,11 +122,11 @@
       ret = 1;
     }
 
-  struct sigaction sa = { .sa_handler = handler, .sa_flags = 0 };
+  sa.sa_handler = handler;
+  sa.sa_flags = 0;
   sigemptyset (&sa.sa_mask);
   sigaction (SIGALRM, &sa, NULL);
 
-  struct itimerval it;
   it.it_value.tv_sec = 1;
   it.it_value.tv_usec = 0;
   it.it_interval = it.it_value;
@@ -169,8 +175,7 @@
       ret = 1;
     }
 
-  char fname[] = "/tmp/tst-lt-cancel8-dir-XXXXXX\0foo/bar";
-  char *enddir = strchr (fname, '\0');
+  enddir = strchr (fname, '\0');
   if (mkdtemp (fname) == NULL)
     {
       error (0, errno, "mkdtemp failed");
--- glibc/locale/setlocale.c	2004-08-04 22:55:05.000000000 +0100
+++ glibc-carl/locale/setlocale.c	2005-07-19 11:50:27.000000000 +0100
@@ -38,8 +38,7 @@
 
 # define DEFINE_CATEGORY(category, category_name, items, a) \
     extern char _nl_current_##category##_used; \
-    weak_extern (_nl_current_##category##_used) \
-    weak_extern (_nl_current_##category)
+    weak_extern (_nl_current_##category##_used)
 # include "categories.def"
 # undef	DEFINE_CATEGORY
 
@@ -485,7 +484,6 @@
   if (CATEGORY_USED (category))						      \
     {									      \
       extern struct locale_data _nl_C_##category;			      \
-      weak_extern (_nl_C_##category)					      \
       free_category (category, *_nl_current_##category, &_nl_C_##category);   \
     }
 # include "categories.def"
--- glibc/locale/uselocale.c	2004-03-14 20:40:48.000000000 +0000
+++ glibc-carl/locale/uselocale.c	2005-07-19 11:50:27.000000000 +0100
@@ -53,8 +53,6 @@
 # define DEFINE_CATEGORY(category, category_name, items, a) \
       {									      \
 	extern char _nl_current_##category##_used;			      \
-	weak_extern (_nl_current_##category##_used)			      \
-	weak_extern (_nl_current_##category)				      \
 	if (&_nl_current_##category##_used != 0)			      \
 	  _nl_current_##category = &locobj->__locales[category];	      \
       }
--- glibc/Makeconfig	2004-08-05 04:34:28.000000000 +0100
+++ glibc-carl/Makeconfig	2005-03-01 10:57:25.000000000 +0000
@@ -522,16 +522,19 @@
 
 ifndef gnulib
 ifneq ($(have-as-needed),yes)
- libgcc_eh := -lgcc_eh
+ libgcc_eh := 
+#-lgcc_eh
 else
  libgcc_eh := -Wl,--as-needed -lgcc_s$(libgcc_s_suffix) -Wl,--no-as-needed
 endif
 ifneq ($(have-cc-with-libunwind),yes)
  gnulib := -lgcc $(libgcc_eh)
- static-gnulib := -lgcc -lgcc_eh
+ static-gnulib := -lgcc 
+#-lgcc_eh
 else
  gnulib := -lgcc $(libgcc_eh) -lunwind
- static-gnulib := -lgcc -lgcc_eh -lunwind
+ static-gnulib := -lgcc -lunwind
+# static-gnulib := -lgcc -lgcc_eh -lunwind
 endif
 endif
 ifeq ($(elf),yes)
@@ -625,7 +628,7 @@
 ifndef	+cflags
 # If `CFLAGS' was defined, use that.
 ifdef		CFLAGS
-+cflags	:= $(filter-out -I%,$(CFLAGS))
++cflags	:= $(CFLAGS)
 endif		# CFLAGS
 endif	# +cflags
 
--- glibc/dlfcn/Makefile	2004-08-21 10:25:46.000000000 +0100
+++ glibc-carl/dlfcn/Makefile	2005-03-01 10:57:25.000000000 +0000
@@ -66,6 +66,8 @@
 test-modules = $(addprefix $(objpfx),$(addsuffix .so,$(modules-names)))
 $(test-modules): $(objpfx)%.so: $(objpfx)%.os $(common-objpfx)shlib.lds
 	$(build-module)
+# without following rule, test-modules don't get built when cross-compiling
+tests: $(test-modules)
 
 ifeq ($(build-shared),yes)
 # Build all the modules even when not actually running test programs.
--- glibc/Makerules	2004-07-05 18:33:07.000000000 +0100
+++ glibc-carl/Makerules	2005-03-01 10:57:25.000000000 +0000
@@ -352,6 +352,7 @@
 $(common-objpfx)sysd-versions: $(common-objpfx)Versions.all \
 			       $(common-objpfx)Versions.v \
 			       $(..)scripts/versions.awk
+			       echo -e "\n\n\nIn Makerules sysd-versions:\n\n"
 	( echo 'sysd-versions-subdirs = $(all-subdirs) $(config-sysdirs)' ; \
 	  cat $(word 2,$^) \
 	  | LC_ALL=C $(AWK) -v buildroot=$(common-objpfx) -v defsfile=$< \
@@ -479,11 +480,18 @@
 ifeq (yes,$(elf))
 # binutils only position loadable notes into the first page for binaries,
 # not for shared objects
+#
+#	$(LD) -shared -O1 \
+#		  -nostdlib -nostartfiles -dynamic-linker=/lib/ld.so.1 \
+#		  --verbose 2>&1 | \
+
 $(common-objpfx)shlib.lds: $(common-objpfx)config.make $(..)Makerules
-	$(LINK.o) -shared -Wl,-O1 \
-		  -nostdlib -nostartfiles \
-		  $(sysdep-LDFLAGS) $(config-LDFLAGS) $(LDFLAGS.so) \
-		  -Wl,--verbose 2>&1 | \
+	@rm -f dummy.c
+	@touch dummy.c
+	$(LINK.o) dummy.c -shared -Wl,-O1 \
+                  -nostdlib -nostartfiles \
+                  $(sysdep-LDFLAGS) $(config-LDFLAGS) $(LDFLAGS.so) \
+                  -Wl,--verbose 2>&1 | \
 	  sed > $@T \
 	      -e '/^=========/,/^=========/!d;/^=========/d' \
 	      -e 's/^.*\.hash[ 	]*:.*$$/  .note.ABI-tag : { *(.note.ABI-tag) } &/' \
@@ -968,8 +976,8 @@
 	 echo '   Use the shared library, but some functions are only in';\
 	 echo '   the static library, so try that secondarily.  */';\
 	 cat $<; \
-	 echo 'GROUP ( $(slibdir)/libc.so$(libc.so-version)' \
-	      '$(libdir)/$(patsubst %,$(libtype.oS),$(libprefix)$(libc-name))'\
+	 echo 'GROUP (libc.so$(libc.so-version)' \
+	      '$(patsubst %,$(libtype.oS),$(libprefix)$(libc-name))'\
 	      ')' \
 	) > $@.new
 	mv -f $@.new $@
--- glibc/nptl/sysdeps/pthread/bits/libc-lock.h	2003-12-11 04:50:49.000000000 +0000
+++ glibc-carl/nptl/sysdeps/pthread/bits/libc-lock.h	2005-07-19 11:48:24.000000000 +0100
@@ -415,6 +415,13 @@
     f->__cancel_routine (f->__cancel_arg);
 }
 
+/* [SC] hack for st200 compiler which does not yet support cleanup. */
+#ifdef __st200__
+#define __libc_cleanup_push(fct, arg) \
+  __libc_cleanup_region_start (1, fct, arg)
+#define __libc_cleanup_pop(execute) \
+  __libc_cleanup_region_end (execute)
+#else
 #define __libc_cleanup_push(fct, arg) \
   do {									      \
     struct __pthread_cleanup_frame __clframe				      \
@@ -425,7 +432,7 @@
 #define __libc_cleanup_pop(execute) \
     __clframe.__do_it = (execute);					      \
   } while (0)
-
+#endif
 
 /* Create thread-specific key.  */
 #define __libc_key_create(KEY, DESTRUCTOR) \
--- glibc/nptl/sysdeps/pthread/bits/stdio-lock.h	2003-11-04 23:43:10.000000000 +0000
+++ glibc-carl/nptl/sysdeps/pthread/bits/stdio-lock.h	2005-07-19 11:48:24.000000000 +0100
@@ -87,6 +87,17 @@
 
 #if defined _LIBC && !defined NOT_IN_libc
 
+/* [SC] hack for st200 compiler which does not yet support cleanup. */
+#ifdef __st200__
+#  define _IO_acquire_lock(_fp) \
+  do {                                                                        \
+     _IO_FILE *_IO_acquire_lock_file = (_fp);                                 \
+     _IO_flockfile (_IO_acquire_lock_file);                                   \
+     __libc_cleanup_region_start (1, _IO_acquire_lock_fct, &_IO_acquire_lock_file)
+#  define _IO_release_lock(_fp) \
+     __libc_cleanup_region_end (1)                                            \
+  } while (0)
+#else
 # ifdef __EXCEPTIONS
 #  define _IO_acquire_lock(_fp) \
   do {									      \
@@ -101,5 +112,6 @@
 # define _IO_release_lock(_fp) ; } while (0)
 
 #endif
+#endif
 
 #endif /* bits/stdio-lock.h */
--- glibc/nptl/sysdeps/pthread/configure	2003-12-03 06:50:01.000000000 +0000
+++ glibc-carl/nptl/sysdeps/pthread/configure	2005-07-19 11:48:24.000000000 +0100
@@ -23,19 +23,22 @@
   esac
 fi
 
-
 echo "$as_me:$LINENO: checking for forced unwind support" >&5
 echo $ECHO_N "checking for forced unwind support... $ECHO_C" >&6
 if test "${libc_cv_forced_unwind+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
+
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+#include "confdefs.h"
 #include <unwind.h>
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
 int
 main ()
 {
@@ -49,21 +52,11 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>conftest.er1
+  (eval $ac_link) 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
+         { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -72,12 +65,10 @@
   libc_cv_forced_unwind=yes
 else
   echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
+cat conftest.$ac_ext >&5
 libc_cv_forced_unwind=no
 fi
-rm -f conftest.err conftest.$ac_objext \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $libc_cv_forced_unwind" >&5
 echo "${ECHO_T}$libc_cv_forced_unwind" >&6
@@ -87,21 +78,24 @@
 _ACEOF
 
   old_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -Werror -fexceptions"
+  CFLAGS="$CFLAGS -fexceptions"
   echo "$as_me:$LINENO: checking for C cleanup handling" >&5
 echo $ECHO_N "checking for C cleanup handling... $ECHO_C" >&6
 if test "${libc_cv_c_cleanup+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
     cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
+#line $LINENO "configure"
+#include "confdefs.h"
 
 #include <stdio.h>
 void cl (void *a) { }
+#ifdef F77_DUMMY_MAIN
+#  ifdef __cplusplus
+     extern "C"
+#  endif
+   int F77_DUMMY_MAIN() { return 1; }
+#endif
 int
 main ()
 {
@@ -114,21 +108,11 @@
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>conftest.er1
+  (eval $ac_link) 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag"
-			 || test ! -s conftest.err'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
+         { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
@@ -137,12 +121,10 @@
   libc_cv_c_cleanup=yes
 else
   echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
+cat conftest.$ac_ext >&5
 libc_cv_c_cleanup=no
 fi
-rm -f conftest.err conftest.$ac_objext \
-      conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $libc_cv_c_cleanup" >&5
 echo "${ECHO_T}$libc_cv_c_cleanup" >&6
@@ -152,8 +134,4 @@
 echo "$as_me: error: the compiler must support C cleanup handling" >&2;}
    { (exit 1); exit 1; }; }
   fi
-else
-  { { echo "$as_me:$LINENO: error: forced unwind support is required" >&5
-echo "$as_me: error: forced unwind support is required" >&2;}
-   { (exit 1); exit 1; }; }
 fi
--- glibc/nptl/sysdeps/st200/jmpbuf-unwind.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/jmpbuf-unwind.h	2005-07-19 11:48:24.000000000 +0100
@@ -0,0 +1,28 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < (uintptr_t) (_jmpbuf)[_JB_STACK_PTR] - (_adj))
--- glibc/nptl/sysdeps/st200/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/Makefile	2005-07-19 11:48:24.000000000 +0100
@@ -0,0 +1,25 @@
+# Copyright (C) 2003 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-pt-initfini.c += -CG:emit_bb_freqs=0 -fno-verbose-asm
+endif
--- glibc/nptl/sysdeps/st200/pthreaddef.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/pthreaddef.h	2005-07-19 11:48:24.000000000 +0100
@@ -0,0 +1,41 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(4 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  The ABI requires 16.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	4096
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+/* Location of current stack frame.  */
+#define __builtin_frame_address(N) \
+    ({ unsigned long sp __asm__("r12"); sp; })
+
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
+
+/* XXX Until we have a better place keep the definitions here.  */
+
+/* While there is no such syscall.  */
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
--- glibc/nptl/sysdeps/st200/pthread_spin_init.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/pthread_spin_init.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,26 @@
+/* POSIX spinlock implementation.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthreadP.h>
+
+int
+pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+  return *lock = 0;
+}
--- glibc/nptl/sysdeps/st200/pthread_spin_lock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/pthread_spin_lock.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,44 @@
+/* POSIX spinlock implementation.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthreadP.h>
+
+int
+pthread_spin_lock (pthread_spinlock_t *lock)
+{
+  unsigned int tmp;
+
+  asm volatile ("	call $r63 = 1f \n"
+		"	;;\n"
+		"1:\n"
+		"	mov $r62 = $r63\n"
+		"	or $r12, $r12, 1\n"
+		"	ldw %0 = 0[ %1 ]\n"
+		"	;;\n"
+		"	cmpne $b0 = %0 , 0 \n"
+		"	stw 0[ %1 ] = $r62 \n"
+		"	and $r12 = $r12 , ~1\n"
+		"	;;\n"
+		"	br $b0, 1b"
+                : "=&r" (tmp)
+                : "r" (lock)
+                : "memory", "r62", "r63", "b0");
+
+  return 0;
+}
--- glibc/nptl/sysdeps/st200/pthread_spin_trylock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/pthread_spin_trylock.c	2005-07-19 11:48:24.000000000 +0100
@@ -0,0 +1,40 @@
+/* POSIX spinlock implementation.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthreadP.h>
+
+int
+pthread_spin_trylock (pthread_spinlock_t *lock)
+{
+  unsigned int tmp;
+
+  asm volatile ("	call $r63 = 1f \n"
+		"	;;\n"
+		"1:	mov $r62 = $r63\n"
+		"	or $r12, $r12, 1\n"
+		"	ldw %0 = 0 [ %1 ]\n"
+		"	;;\n"
+		"	stw 0[ %1 ] = $r62\n"
+		"	and $r12 = $r12,~1\n"
+                : "=&r" (tmp)
+                : "r" (lock)
+                : "memory", "r62", "r63");
+  return tmp ? EBUSY : 0;
+}
--- glibc/nptl/sysdeps/st200/pthread_spin_unlock.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/pthread_spin_unlock.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,27 @@
+/* POSIX spinlock implementation.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthreadP.h>
+
+int
+pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+  return *lock = 0;
+}
+
--- glibc/nptl/sysdeps/st200/tcb-offsets.sym	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/st200/tcb-offsets.sym	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,6 @@
+#include <sysdep.h>
+#include <tls.h>
+
+PID			offsetof (struct pthread, pid) - sizeof (struct pthread)
+MULTIPLE_THREADS_OFFSET offsetof (struct pthread, header.multiple_threads) - sizeof (struct pthread)
+SYSINFO_OFFSET          offsetof (tcbhead_t, private)
--- glibc-carl/nptl/sysdeps/st200/tls.h	2005-07-19 11:48:24.000000000 +0100
+++ libc/nptl/sysdeps/st200/tls.h	2006-03-09 17:01:16.000000000 +0000
@@ -0,0 +1,142 @@
+/* Definition for thread-local data handling.  nptl/ST200 version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TLS_H
+#define _TLS_H	1
+
+#include <dl-sysdep.h>
+#ifndef __ASSEMBLER__
+# include <stddef.h>
+# include <stdint.h>
+# include <stdlib.h>
+# include <list.h>
+
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  void *pointer;
+} dtv_t;
+
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+  void *private2;
+  void *private3;
+} tcbhead_t;
+
+register struct pthread *__thread_self __asm__("r13");
+
+# define TLS_MULTIPLE_THREADS_IN_TCB 1
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif
+
+
+/* We require TLS support in the tools.  */
+#ifndef HAVE_TLS_SUPPORT
+# error "TLS support is required."
+#endif
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+/* Alignment requirement for the stack.  */
+#define STACK_ALIGN	16
+
+#ifndef __ASSEMBLER__
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* This is the size of the initial TCB.  */
+# define TLS_INIT_TCB_SIZE sizeof (tcbhead_t)
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN __alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+# define TLS_TCB_SIZE sizeof (tcbhead_t)
+
+/* This is the size we need before TCB.  */
+# define TLS_PRE_TCB_SIZE sizeof (struct pthread)
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN __alignof__ (struct pthread)
+
+/* The DTV is allocated at the TP; the TCB is placed elsewhere.  */
+# define TLS_DTV_AT_TP	1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+#  define INSTALL_DTV(descr, dtvp) \
+  ((tcbhead_t *) (descr))->dtv = (dtvp) + 1
+
+/* Install new dtv for current thread.  */
+#  define INSTALL_NEW_DTV(DTV) \
+  (((tcbhead_t *)__thread_self)->dtv = (DTV))
+
+/* Return dtv of given thread descriptor.  */
+#  define GET_DTV(descr) \
+  (((tcbhead_t *) (descr))->dtv)
+
+#define THREAD_SELF_SYSINFO	(((tcbhead_t *) __thread_self)->private)
+#define THREAD_SYSINFO(pd)	(((tcbhead_t *) ((pd) + 1))->private)
+
+#if defined NEED_DL_SYSINFO
+# define INIT_SYSINFO   THREAD_SELF_SYSINFO = (void *) GLRO(dl_sysinfo)
+#else
+# define INIT_SYSINFO   NULL
+#endif
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+# define TLS_INIT_TP(thrdescr, secondcall) \
+  (__thread_self = (thrdescr), INIT_SYSINFO, NULL)
+
+/* Return the address of the dtv for the current thread.  */
+#  define THREAD_DTV() \
+  (((tcbhead_t *)__thread_self)->dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF (__thread_self - 1)
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF REGISTER (32, 32, PT_R(13) * 4, -sizeof (struct pthread))
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  descr->member
+#define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+#define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+#define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/aio_cancel.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/aio_cancel.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,33 @@
+#include <shlib-compat.h>
+
+#define aio_cancel64 XXX
+#include <aio.h>
+#undef aio_cancel64
+#include <errno.h>
+
+extern __typeof (aio_cancel) __new_aio_cancel;
+extern __typeof (aio_cancel) __old_aio_cancel;
+
+#define aio_cancel	__new_aio_cancel
+
+#include <sysdeps/pthread/aio_cancel.c>
+
+#undef aio_cancel
+strong_alias (__new_aio_cancel, __new_aio_cancel64);
+versioned_symbol (librt, __new_aio_cancel, aio_cancel, GLIBC_2_3);
+versioned_symbol (librt, __new_aio_cancel64, aio_cancel64, GLIBC_2_3);
+
+#if SHLIB_COMPAT (librt, GLIBC_2_1, GLIBC_2_3)
+
+#undef ECANCELED
+#define aio_cancel	__old_aio_cancel
+#define ECANCELED	125
+
+#include <sysdeps/pthread/aio_cancel.c>
+
+#undef aio_cancel
+strong_alias (__old_aio_cancel, __old_aio_cancel64);
+compat_symbol (librt, __old_aio_cancel, aio_cancel, GLIBC_2_1);
+compat_symbol (librt, __old_aio_cancel64, aio_cancel64, GLIBC_2_1);
+
+#endif
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/bits/local_lim.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/bits/local_lim.h	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,89 @@
+/* Minimum guaranteed maximum values for system limits.  Linux/Alpha version.
+   Copyright (C) 1993-1998,2000,2002,2003,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* The kernel header pollutes the namespace with the NR_OPEN symbol
+   and defines LINK_MAX although filesystems have different maxima.  A
+   similar thing is true for OPEN_MAX: the limit can be changed at
+   runtime and therefore the macro must not be defined.  Remove this
+   after including the header if necessary.  */
+#ifndef NR_OPEN
+# define __undef_NR_OPEN
+#endif
+#ifndef LINK_MAX
+# define __undef_LINK_MAX
+#endif
+#ifndef OPEN_MAX
+# define __undef_OPEN_MAX
+#endif
+
+/* The kernel sources contain a file with all the needed information.  */
+#include <linux/limits.h>
+
+/* Have to remove NR_OPEN?  */
+#ifdef __undef_NR_OPEN
+# undef NR_OPEN
+# undef __undef_NR_OPEN
+#endif
+/* Have to remove LINK_MAX?  */
+#ifdef __undef_LINK_MAX
+# undef LINK_MAX
+# undef __undef_LINK_MAX
+#endif
+/* Have to remove OPEN_MAX?  */
+#ifdef __undef_OPEN_MAX
+# undef OPEN_MAX
+# undef __undef_OPEN_MAX
+#endif
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* We have no predefined limit on the number of threads.  */
+#undef PTHREAD_THREADS_MAX
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	24576
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
+
+/* Maximum tty name length.  */
+#define TTY_NAME_MAX		32
+
+/* Maximum login name length.  This is arbitrary.  */
+#define LOGIN_NAME_MAX		256
+
+/* Maximum host name length.  */
+#define HOST_NAME_MAX		64
+
+/* Maximum message queue priority level.  */
+#define MQ_PRIO_MAX		32768
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/bits/pthreadtypes.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/bits/pthreadtypes.h	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,158 @@
+/* Machine-specific pthread type layouts.  Alpha version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#define __SIZEOF_PTHREAD_ATTR_T		56
+#define __SIZEOF_PTHREAD_MUTEX_T	40
+#define __SIZEOF_PTHREAD_MUTEXATTR_T	4
+#define __SIZEOF_PTHREAD_COND_T		48
+#define __SIZEOF_PTHREAD_CONDATTR_T	4
+#define __SIZEOF_PTHREAD_RWLOCK_T	56
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T	8
+#define __SIZEOF_PTHREAD_BARRIER_T	32
+#define __SIZEOF_PTHREAD_BARRIERATTR_T	4
+
+
+/* Thread identifiers.  The structure of the attribute type is
+   deliberately not exposed.  */
+typedef unsigned long int pthread_t;
+
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+} pthread_attr_t;
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    unsigned int __nusers;
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+    int __spins;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    unsigned long long int __total_seq;
+    unsigned long long int __wakeup_seq;
+    unsigned long long int __woken_seq;
+    void *__mutex;
+    int __clock;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#ifdef __USE_UNIX98
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+
+    unsigned int __reserved[6];
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/bits/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/bits/semaphore.h	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,37 @@
+/* Machine-specific POSIX semaphore type layouts.  Alpha version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+# define __SIZEOF_SEM_T	32
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   (2147483647)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/createthread.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/createthread.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,23 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE (pd + 1)
+
+/* Get the real implementation.	 */
+#include <nptl/sysdeps/pthread/createthread.c>
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/fork.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/fork.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,30 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <tls.h>
+
+
+#define ARCH_FORK()							\
+  INLINE_SYSCALL (clone, 5,						\
+		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
+		  NULL, NULL, &THREAD_SELF->tid, NULL)
+
+#include "../fork.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/lowlevellock.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/lowlevellock.h	2005-07-19 11:48:25.000000000 +0100
@@ -0,0 +1,216 @@
+/* Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Libr	\ary; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+
+/* Initializer for compatibility lock.	*/
+#define LLL_MUTEX_LOCK_INITIALIZER (0)
+
+#define lll_futex_wait(futexp, val) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (futexp), FUTEX_WAIT, (val), 0);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err)? -__ret : __ret;		      \
+  })
+
+#define lll_futex_timed_wait(futexp, val, timespec) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (futexp), FUTEX_WAIT, (val), (timespec));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err)? -__ret : __ret;		      \
+  })
+
+#define lll_futex_wake(futexp, nr) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4,				      \
+			      (futexp), FUTEX_WAKE, (nr), 0);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err)? -__ret : __ret;		      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6,				      \
+			      (futexp), FUTEX_CMP_REQUEUE, (nr_wake),	      \
+			      (nr_move), (mutex), (val));		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+static inline int __attribute__((always_inline))
+__lll_mutex_trylock(int *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 1, 0) != 0;
+}
+#define lll_mutex_trylock(lock)	__lll_mutex_trylock (&(lock))
+
+
+static inline int __attribute__((always_inline))
+__lll_mutex_cond_trylock(int *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 2, 0) != 0;
+}
+#define lll_mutex_cond_trylock(lock)	__lll_mutex_cond_trylock (&(lock))
+
+
+extern void __lll_lock_wait (int *futex) attribute_hidden;
+
+static inline void __attribute__((always_inline))
+__lll_mutex_lock(int *futex)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    __lll_lock_wait (futex);
+}
+#define lll_mutex_lock(futex) __lll_mutex_lock (&(futex))
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_cond_lock (int *futex)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0)
+    __lll_lock_wait (futex);
+}
+#define lll_mutex_cond_lock(futex) __lll_mutex_cond_lock (&(futex))
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *)
+	attribute_hidden;
+
+static inline int __attribute__ ((always_inline))
+__lll_mutex_timedlock (int *futex, const struct timespec *abstime)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    result = __lll_timedlock_wait (futex, abstime);
+  return result;
+}
+#define lll_mutex_timedlock(futex, abstime) \
+  __lll_mutex_timedlock (&(futex), abstime)
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_unlock (int *futex)
+{
+  int val = atomic_exchange_rel (futex, 0);
+  if (__builtin_expect (val > 1, 0))
+    lll_futex_wake (futex, 1);
+}
+#define lll_mutex_unlock(futex) __lll_mutex_unlock(&(futex))
+
+
+static inline void __attribute__ ((always_inline))
+__lll_mutex_unlock_force (int *futex)
+{
+  (void) atomic_exchange_rel (futex, 0);
+  lll_futex_wake (futex, 1);
+}
+#define lll_mutex_unlock_force(futex) __lll_mutex_unlock_force(&(futex))
+
+
+#define lll_mutex_islocked(futex) \
+  (futex != 0)
+
+
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Type for lock object.  */
+typedef int lll_lock_t;
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+extern int lll_unlock_wake_cb (int *__futex) attribute_hidden;
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
+#define lll_trylock(lock)	lll_mutex_trylock (lock)
+#define lll_lock(lock)		lll_mutex_lock (lock)
+#define lll_unlock(lock)	lll_mutex_unlock (lock)
+#define lll_islocked(lock)	lll_mutex_islocked (lock)
+
+/* The kernel notifies a process which uses CLONE_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != 0)	\
+      lll_futex_wait (&(tid), __tid);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+
+/* Conditional variable handling.  */
+
+extern void __lll_cond_wait (pthread_cond_t *cond)
+     attribute_hidden;
+extern int __lll_cond_timedwait (pthread_cond_t *cond,
+				 const struct timespec *abstime)
+     attribute_hidden;
+extern void __lll_cond_wake (pthread_cond_t *cond)
+     attribute_hidden;
+extern void __lll_cond_broadcast (pthread_cond_t *cond)
+     attribute_hidden;
+
+#define lll_cond_wait(cond) \
+  __lll_cond_wait (cond)
+#define lll_cond_timedwait(cond, abstime) \
+  __lll_cond_timedwait (cond, abstime)
+#define lll_cond_wake(cond) \
+  __lll_cond_wake (cond)
+#define lll_cond_broadcast(cond) \
+  __lll_cond_broadcast (cond)
+
+#endif	/* lowlevellock.h */
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/pthread_once.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/pthread_once.c	2005-07-19 11:48:25.000000000 +0100
@@ -0,0 +1,108 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+unsigned long int __fork_generation attribute_hidden;
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX);
+}
+
+int
+__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
+{
+  for (;;)
+    {
+      int oldval;
+      int newval;
+      unsigned int tmp;
+
+      /* Pseudo code:
+	 newval = __fork_generation | 1;
+	 oldval = *once_control;
+	 if ((oldval & 2) == 0)
+	   *once_control = newval;
+	 Do this atomically.
+      */
+      newval = __fork_generation | 1;
+      __asm __volatile (
+		"	call $r63 = 1f         \n"
+		"	;;                     \n"
+		"1:                            \n"
+		"	mov $r62 = $r63        \n"
+		"	or $r12, $r12, 1       \n"
+		"	ldw %0 = 0[ %3 ]       \n"
+		"	;;                     \n"
+		"	and %1 = %0, 2         \n"
+		"	;;                     \n"
+		"	cmpne $b0 = %1, 0      \n"
+		"	;;                     \n"
+		"	br $b0, 2f             \n"
+		"	;;                     \n"
+		"	stw 0[ %3 ] = %2       \n"
+                "       and $r12 = $r12, ~1    \n"
+		"       ;;                     \n"
+		"2:                            \n"
+		"	and $r12 = $r12, ~1    \n"
+		: "=&r" (oldval), "=&r" (tmp)
+		: "r" (newval), "r" (once_control)
+		: "memory", "r62", "r63", "b0");
+
+      /* Check if the initializer has already been done.  */
+      if ((oldval & 2) != 0)
+	return 0;
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) == 0)
+	break;
+
+      /* Check whether the initializer execution was interrupted by a fork.  */
+      if (oldval != newval)
+	break;
+
+      /* Same generation, some other thread was faster. Wait.  */
+      lll_futex_wait (once_control, oldval);
+    }
+
+  /* This thread is the first here.  Do the initialization.
+     Register a cleanup handler so that in case the thread gets
+     interrupted the initialization can be restarted.  */
+  pthread_cleanup_push (clear_once_control, once_control);
+
+  init_routine ();
+
+  pthread_cleanup_pop (0);
+
+  /* Add one to *once_control to take the bottom 2 bits from 01 to 10.  */
+  atomic_exchange_and_add (once_control, 1);
+
+  /* Wake up all other threads.  */
+  lll_futex_wake (once_control, INT_MAX);
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+strong_alias (__pthread_once, __pthread_once_internal)
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/pt-initfini.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/pt-initfini.c	2005-07-14 18:33:54.000000000 +0100
@@ -0,0 +1,103 @@
+/* Special .init and .fini section support for ST200. LinuxThreads version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file is compiled into assembly code which is then munged by a sed
+   script into two files: crti.s and crtn.s.
+
+   * crti.s puts a function prologue at the beginning of the
+   .init and .fini sections and defines global symbols for
+   those addresses, so they can be called as functions.
+
+   * crtn.s puts the corresponding function epilogues
+   in the .init and .fini sections. */
+
+__asm__ ("\n\n"
+"#include \"defs.h\"                                                        \n"
+"/*define SHARED*/                                                          \n"
+"#define sp $r12                                                            \n"
+"#define gp $r14                                                            \n"
+"                                                                           \n"
+"/*@HEADER_ENDS*/                                                           \n"
+"                                                                           \n"
+"/*@TESTS_BEGIN*/                                                           \n"
+"                                                                           \n"
+"/*@TESTS_END*/                                                             \n"
+"                                                                           \n"
+"/*@_init_PROLOG_BEGINS*/                                                   \n"
+"       .section .init, \"ax\", @progbits                                   \n"
+"	.align 32                                                           \n"
+"	.global _init                                                       \n"
+"_init:                                                                     \n"
+"       add     sp    = sp, -32                                             \n"
+"       stw     -16[sp] = $r63                                              \n"
+"       ;;                                                                  \n"
+"       stw     20[sp] = gp                                                 \n"
+"       call    $r63 = 0f                                                   \n"
+"       ;;                                                                  \n"
+"0:                                                                         \n"
+"       add     gp = $r63, @neggprel(0b)                                    \n"
+"       call    $r63 = __pthread_initialize_minimal                         \n"
+"       ;;                                                                  \n"
+"/*@_init_PROLOG_ENDS*/                                                     \n"
+"                                                                           \n"
+"/*@_init_EPILOG_BEGINS*/                                                   \n"
+"	.section .init                                                      \n"
+"       ldw     $r63 = 16[sp]                                               \n"
+"       ;;                                                                  \n"
+"       ldw     gp = 20[sp]                                                 \n"
+"       add     sp     = sp, 32                                             \n"
+"       ;;                                                                  \n"
+"       return  $r63                                                        \n"
+"       ;;                                                                  \n"
+"/*@_init_EPILOG_ENDS*/                                                     \n"
+"                                                                           \n"
+"/*@_fini_PROLOG_BEGINS*/                                                   \n"
+"	.section .fini, \"ax\", @progbits                                   \n"
+"	.align 32                                                           \n"
+"	.global _fini                                                       \n"
+"_fini:                                                                     \n"
+"       add     sp    = sp, -32                                             \n"
+"       stw     -16[sp] = $r63                                              \n"
+"       ;;                                                                  \n"
+"       stw     20[sp] = gp                                                 \n"
+"       call    $r63 = 0f                                                   \n"
+"       ;;                                                                  \n"
+"0:                                                                         \n"
+"       add     gp = $r63, @neggprel(0b)                                    \n"
+"       ;;                                                                  \n"
+"/*@_fini_PROLOG_ENDS*/                                                     \n"
+"	call    $r63 = i_am_not_a_leaf                                      \n"
+"	;;                                                                  \n"
+"                                                                           \n"
+"/*@_fini_EPILOG_BEGINS*/                                                   \n"
+"	.section .fini                                                      \n"
+"       ldw     $r63 = 16[sp]                                               \n"
+"       ;;                                                                  \n"
+"       ldw     gp     = 20[sp]                                             \n"
+"       add     sp     = sp, 32                                             \n"
+"       ;;                                                                  \n"
+"       return  $r63                                                        \n"
+"       ;;                                                                  \n"
+"                                                                           \n"
+"/*@_fini_EPILOG_ENDS*/                                                     \n"
+"                                                                           \n"
+"/*@TRAILER_BEGINS*/                                                        \n"
+"       .weak   __gmon_start__                                              \n"
+);
+
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/pt-vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/pt-vfork.S	2005-07-19 11:48:25.000000000 +0100
@@ -0,0 +1,74 @@
+/* Copyright (C) 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <sysdep.h>
+#define _SIGNAL_H
+#include <bits/signum.h>
+#include <tcb-offsets.h>
+
+/* The following are defined in linux/sched.h, which unfortunately	*/
+/* is not safe for inclusion in an assembly file.			*/
+#define CLONE_VM        0x00000100      /* set if VM shared between processes */
+#define CLONE_VFORK     0x00004000      /* set if the parent wants the child to wake it up on mm_release */
+
+/* pid_t vfork(void); */
+/* Implemented as __clone_syscall(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)	*/
+
+ENTRY(__vfork)
+	/* Load the current cached pid value across the vfork.  */
+	ldw 	$r8 = PID[$r13]
+	;;
+	/* If the cached value is initialized (nonzero), then write
+	   back its negation, otherwise INT_MIN to indicate that the pid
+	   value is uninitialized in the the child, and in the window
+	   between here and the point at which we restore the value.  */ 
+	sub 	$r9 = $r0, $r8
+	;;
+	/* Call syscall clone */
+	stw	PID[$r13] = $r9
+	;; 
+	mov 	$r16 = CLONE_VM+CLONE_VFORK+SIGCHLD
+	mov	$r17 = $r0 
+	DO_CALL (SYS_ify(clone));
+        ;;
+	brf     $b0, 2f  /* Was there an error? */
+	;;
+	SYSCALL_ERROR_HANDLER
+        mov     $r16 = -1
+	;;
+	return	$r63
+	;;
+2:
+	cmpeq	$b0 = $r16, $r0  /* in the child? */
+	;;
+	br	$b0, 3f
+	;;
+	/* If we're back in the parent, restore the saved pid.  */
+	ldw 	$r8 = PID[$r13]
+	;;
+	sub	$r9 = $r0, $r8  /* re-invert the PID */
+	;;
+	stw     PID[$r13] = $r9
+	;;
+3:
+	return  $r63
+	;;
+PSEUDO_END(__vfork)
+libc_hidden_def (__vfork)
+weak_alias (__vfork, vfork)
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/sem_post.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/sem_post.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,5 @@
+/* ??? This is an ass-backwards way to do this.  We should simply define
+   the acquire/release semantics of atomic_exchange_and_add.  And even if
+   we don't do this, we should be using atomic_full_barrier or otherwise.  */
+#define __lll_rel_instr  "mb"
+#include "../sem_post.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/sysdep-cancel.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/sysdep-cancel.h	2005-07-19 11:48:25.000000000 +0100
@@ -0,0 +1,146 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+
+#if !defined NOT_IN_libc || defined IS_IN_libpthread || defined IS_IN_librt
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)			\
+   ENTRY (name)                                                 \
+	SINGLE_THREAD_P($b0,$r8)			       ;\
+        ;;                                                     ;\
+        brf     $b0,1f                                         ;\
+        ;;                                                     ;\
+        DO_CALL (SYS_ify (syscall_name))                       ;\
+        ;;                                                     ;\
+        br      $b0,2f                                         ;\
+        ;;                                                     ;\
+        goto    4f                                             ;\
+        ;;                                                     ;\
+1:                                                              \
+        /* Open up a new stack frame. In the new frame,         \
+           R12+0..R12+15 are kept for called fns,               \
+           R16+16..R12+39 hold saved arguments,                 \
+           R12+40..R12+43 hold saved return address.            \
+           R12+44..R12+47 are unused.                           \
+           Note that R12+32..R12+47 are the 16 free bytes above \
+           the SP passed in, so we only adjust R12 by 32. */    \
+	add	$r12 = $r12, -32 			       ;\
+        ;;                                                     ;\
+	stw	40[$r12] = $r63  			       ;\
+        ;;                                                     ;\
+	SAVE_ARGS_##args				       ;\
+        ;;                                                     ;\
+	CENABLE  					       ;\
+        ;;                                                     ;\
+	/* Save the CENABLE return value in R63. That register	\
+	   is preserved across syscall and the real return 	\
+	   address is saved on the stack.  */			\
+        mov     $r63 = $r16                                    ;\
+        ;;                                                     ;\
+	LOAD_ARGS_##args  				       ;\
+        ;;                                                     ;\
+        DO_CALL (SYS_ify (syscall_name))                       ;\
+        ;;                                                     ;\
+        stw     16[$r12] = $r16                                ;\
+        mov     $r16 = $r63                                    ;\
+        br      $b0, 3f                                        ;\
+        ;;                                                     ;\
+	CDISABLE					       ;\
+        ;;                                                     ;\
+        ldw     $r63 = 40[$r12]                                ;\
+        ;;                                                     ;\
+        ldw     $r16= 16[$r12]                                 ;\
+        add     $r12 = $r12, 32                                ;\
+	ret						       ;\
+        ;;                                                     ;\
+3:                                                              \
+	CDISABLE 					       ;\
+        ;;                                                     ;\
+	ldw	$r63 = 40[$r12] 		               ;\
+        ;;                                                     ;\
+        ldw     $r16 = 16[$r12]                                ;\
+        add     $r12 = $r12, 32                                ;\
+        ;;                                                     ;\
+2:                                                              \
+	SYSCALL_ERROR_HANDLER				       ;\
+        mov     $r16 = -1                                      ;\
+        ;;                                                     ;\
+4:
+
+# undef PSEUDO_END
+# define PSEUDO_END(sym)					\
+        .endp                                                  ;\
+        .size sym, .-sym
+
+# define SAVE_ARGS_0	/* Nothing.  */
+# define SAVE_ARGS_1	                  stw 16[$r12] = $r16;
+# define SAVE_ARGS_2	SAVE_ARGS_1; ;; ; stw 20[$r12] = $r17;
+# define SAVE_ARGS_3	SAVE_ARGS_2; ;; ; stw 24[$r12] = $r18;
+# define SAVE_ARGS_4	SAVE_ARGS_3; ;; ; stw 28[$r12] = $r19;
+# define SAVE_ARGS_5	SAVE_ARGS_4; ;; ; stw 32[$r12] = $r20;
+# define SAVE_ARGS_6	SAVE_ARGS_5; ;; ; stw 36[$r12] = $r21;
+
+# define LOAD_ARGS_0	/* Nothing.  */
+# define LOAD_ARGS_1	                  ldw $r16 = 16[$r12];
+# define LOAD_ARGS_2	LOAD_ARGS_1; ;; ; ldw $r17 = 20[$r12];
+# define LOAD_ARGS_3	LOAD_ARGS_2; ;; ; ldw $r18 = 24[$r12];
+# define LOAD_ARGS_4	LOAD_ARGS_3; ;; ; ldw $r19 = 28[$r12];
+# define LOAD_ARGS_5	LOAD_ARGS_4; ;; ; ldw $r20 = 32[$r12];
+# define LOAD_ARGS_6	LOAD_ARGS_5; ;; ; ldw $r21 = 36[$r12];
+
+# ifdef IS_IN_libpthread
+#  define __local_enable_asynccancel	__pthread_enable_asynccancel
+#  define __local_disable_asynccancel	__pthread_disable_asynccancel
+#  define __local_multiple_threads	__pthread_multiple_threads
+# elif !defined NOT_IN_libc
+#  define __local_enable_asynccancel	__libc_enable_asynccancel
+#  define __local_disable_asynccancel	__libc_disable_asynccancel
+#  define __local_multiple_threads	__libc_multiple_threads
+# elif defined IS_IN_librt
+#  define __local_enable_asynccancel	__librt_enable_asynccancel
+#  define __local_disable_asynccancel	__librt_disable_asynccancel
+# else
+#  error Unsupported library
+# endif
+
+# define CENABLE	call $r63 = __local_enable_asynccancel
+# define CDISABLE	call $r63 = __local_disable_asynccancel
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P \
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+	 		                header.multiple_threads) == 0, 1)
+# else
+#  define SINGLE_THREAD_P(breg,greg) \
+         ldw greg = MULTIPLE_THREADS_OFFSET[$r13]            ;\
+         ;;                                                   ;\
+         cmpeq breg = greg, $r0
+# endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/timer_create.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/timer_create.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1 @@
+#include "../x86_64/timer_create.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/timer_delete.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/timer_delete.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1 @@
+#include "../x86_64/timer_delete.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/timer_getoverr.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/timer_getoverr.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1 @@
+#include "../x86_64/timer_getoverr.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/timer_gettime.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/timer_gettime.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1 @@
+#include "../x86_64/timer_gettime.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/timer_settime.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/timer_settime.c	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1 @@
+#include "../x86_64/timer_settime.c"
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/Versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/Versions	2005-03-01 10:57:38.000000000 +0000
@@ -0,0 +1,13 @@
+libpthread {
+  GLIBC_2.3.3 {
+    # Changed PTHREAD_STACK_MIN.
+    pthread_attr_setstack; pthread_attr_setstacksize;
+  }
+}
+librt {
+  GLIBC_2.3.3 {
+    # Changed timer_t.
+    timer_create; timer_delete; timer_getoverrun; timer_gettime;
+    timer_settime;
+  }
+}
--- glibc/nptl/sysdeps/unix/sysv/linux/st200/vfork.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/nptl/sysdeps/unix/sysv/linux/st200/vfork.S	2005-07-19 11:48:25.000000000 +0100
@@ -0,0 +1,89 @@
+/* Copyright (C) 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <sysdep.h>
+#define _SIGNAL_H
+#include <bits/signum.h>
+#include <tcb-offsets.h>
+
+/* The following are defined in linux/sched.h, which unfortunately	*/
+/* is not safe for inclusion in an assembly file.			*/
+#define CLONE_VM        0x00000100      /* set if VM shared between processes */
+#define CLONE_VFORK     0x00004000      /* set if the parent wants the child to wake it up on mm_release */
+
+/* pid_t vfork(void); */
+/* Implemented as __clone_syscall(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)	*/
+
+ENTRY(__vfork)
+	/* Load the current cached pid value across the vfork.  */
+	ldw 	$r8 = PID[$r13]
+	;;
+	/* If the cached value is initialized (nonzero), then write
+	   back its negation, otherwise INT_MIN to indicate that the pid
+	   value is uninitialized in the the child, and in the window
+	   between here and the point at which we restore the value.  */ 
+	sub 	$r9 = $r0,$r8
+	cmpeq 	$b0 = $r8,$r0
+	;;
+	brf 	$b0, 1f	
+	;;
+	mov 	$r9 = 0x80000000
+	;;
+1:
+	/* Call syscall clone */
+	stw	PID[$r13] = $r9
+	;;
+	mov 	$r16 = CLONE_VM+CLONE_VFORK+SIGCHLD
+	mov	$r17 = $r0 
+	DO_CALL (SYS_ify(clone));
+        ;;
+	brf     $b0, 2f  /* There was an error... */
+	;;
+	SYSCALL_ERROR_HANDLER
+        mov     $r16 = -1
+	;;
+	return	$r63
+	;;
+2:
+	/* Check if we're in the child or parent */
+	cmpeq	$b0 = $r16, $r0
+	;;
+	br	$b0, 4f
+	;;
+	/* If we're back in the parent, restore the saved pid.  */
+	ldw 	$r8 = PID[$r13]
+	;;
+	sub	$r9 = $r0, $r8  /* re-invert the PID */
+	and	$r10 = $r8, 0xeffffff
+	;;
+	cmpeq	$b0 = $r10, $r0
+	;;
+	brf	$b0, 3f
+	;;
+	mov	$r9 = $r10	
+	;;
+3:
+	stw     PID[$r13] = $r9
+	;;
+4:
+	return  $r63
+	;;
+PSEUDO_END(__vfork)
+libc_hidden_def (__vfork)
+weak_alias (__vfork, vfork)
--- glibc/ChangeLog.ST	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/ChangeLog.ST	2005-07-19 11:50:26.000000000 +0100
@@ -0,0 +1,831 @@
+2003-05-30  Stephen Clarke <stephen.clarke@st.com>
+
+	* configure.in: Add support for st200 target.
+	* elf/elf.h: Likewise.
+	* scripts/config.sub: Likewise.
+	* sysdeps/unix/sysv/linux/configure.in: Likewise.
+	* configure: Regenerate.
+	* sysdeps/unix/sysv/linux/configure: Likewise.
+	* sysdeps/st200/Dist: New file.
+	* sysdeps/st200/Implies: New file.
+	* sysdeps/st200/Makefile: New file.
+	* sysdeps/st200/__longjmp.S: New file.
+	* sysdeps/st200/bsd-_setjmp.S: New file.
+	* sysdeps/st200/bsd-setjmp.S: New file.
+	* sysdeps/st200/dl-fptr.c: New file.
+	* sysdeps/st200/dl-lookupcfg.h: New file.
+	* sysdeps/st200/dl-machine.h: New file.
+	* sysdeps/st200/dl-symaddr.c: New file.
+	* sysdeps/st200/setjmp.S: New file.
+	* sysdeps/st200/stackinfo.h: New file.
+	* sysdeps/st200/sysdep.h: New file.
+	* sysdeps/st200/bits/endian.h: New file.
+	* sysdeps/st200/bits/link.h: New file.
+	* sysdeps/st200/bits/setjmp.h: New file.
+	* sysdeps/st200/elf/configure: New file.
+	* sysdeps/st200/elf/configure.in: New file.
+	* sysdeps/st200/elf/entry.h: New file.
+	* sysdeps/st200/elf/initfini.c: New file.
+	* sysdeps/st200/elf/start.S: New file.
+	* sysdeps/unix/sysv/linux/st200/Dist: New file.
+	* sysdeps/unix/sysv/linux/st200/brk.c: New file.
+	* sysdeps/unix/sysv/linux/st200/clone.S: New file.
+	* sysdeps/unix/sysv/linux/st200/kernel_sigaction.h: New file.
+	* sysdeps/unix/sysv/linux/st200/kernel_stat.h: New file.
+	* sysdeps/unix/sysv/linux/st200/kernel_termios.h: New file.
+	* sysdeps/unix/sysv/linux/st200/pipe.S: New file.
+	* sysdeps/unix/sysv/linux/st200/profil-counter.h: New file.
+	* sysdeps/unix/sysv/linux/st200/socket.S: New file.
+	* sysdeps/unix/sysv/linux/st200/syscall.S: New file.
+	* sysdeps/unix/sysv/linux/st200/syscalls.list: New file.
+	* sysdeps/unix/sysv/linux/st200/sysdep.c: New file.
+	* sysdeps/unix/sysv/linux/st200/sysdep.h: New file.
+	* sysdeps/unix/sysv/linux/st200/umount.c: New file.
+	* sysdeps/unix/sysv/linux/st200/bits/fcntl.h: New file.
+	* sysdeps/unix/sysv/linux/st200/bits/mman.h: New file.
+	* sysdeps/unix/sysv/linux/st200/bits/sigcontext.h: New file.
+	* sysdeps/unix/sysv/linux/st200/bits/sigstack.h: New file.
+	* sysdeps/unix/sysv/linux/st200/sys/procfs.h: New file.
+	* dlfcn/eval.c (funcall, eval): Disable functionality that requires
+	__builtin_return and __builtin_apply.
+	* elf/dl-close.c (mark_removed): Rewrite as non-nested function.
+	(dl_close): Braces for declaration within statements.
+	* elf/dl-conflict.c (dl_resolve_conflicts): Remove include
+	of dynamic-link.h as it contains nested functions.
+	* elf/dl-deps.c (preload): Rewrite as non-nested function.
+	(dl_map_object_deps): Adjust calls to preload.
+	* elf/dl-error.c (dl_catch_error): Braces for declarations within
+	statements.
+	* elf/dl-init.c (call_init): Likewise.
+	* elf/dl-reloc.c (RESOLVE_MAP, RESOLVE, CHECK_STATIC_TLS): Move
+	outside of function.
+	* elf/dl-runtime.c (ElfW): Make global to prevent compiler
+	thinking it is unused.
+	* elf/dl-support.c: Only use __rtld_lock_define_initialized_recursive
+	if it is defined.
+	* elf/do-rel.h (elf_dynamic_do_rel): Pass non-local variables as
+	arguments.  Pass non-locals as arguments to elf_machine_rel.
+	* elf/dynamic-link.h: Remove nested function definitions.
+	* iconv/iconvconfig.c (name_insert): Convert to non-nested
+	definition.
+	(write_output): Initialize static variables for indirect calls
+	to name_insert.
+	* include/libc-symbols.h (RETURN_ADDRESS): Remove use of
+	__builtin_extract_return_addr.
+	* inet/rcmd.c (rcmd_af): Braces for declarations within
+	statements.
+	(rresvport_af): Likewise.
+	* inet/rexec.c (rexec_af): Likewise.
+	* locale/duplocale.c (__duplocale): Likewise.
+	* locale/programs/locarchive.c (add_locale_to_archive):
+	Likewise.
+	* malloc/malloc.c (mALLOPt): Likewise.
+	* nscd/nscd.c (main): Likewise.
+	* nss/getent.c (print_hosts): Likewise.
+	* resolv/res_init.c (res_thread_freeres): Likewise.
+	* resolv/nss_dns/dns-network.c (getanswer_r): Likewise.
+	* sysdeps/generic/libc-start.c (__libc_start_main): Likewise.
+	* sysdeps/generic/pselect.c (__pselect): Likewise.
+	* sysdeps/posix/sigpause.c (__sigpause): Likewise.
+	* sysdeps/posix/system.c (__libc_system): Likewise.
+	* sysdeps/posix/waitid.c (__waitid): Likewise.
+	* sysdeps/pthread/aio_notify.c (__aio_notify_only): Likewise.
+	* sysdeps/unix/sysv/linux/fexecve.c (fexecve): Likewise.
+	* sysdeps/unix/sysv/linux/fxstat.c (__fxstat): Likewise.
+	* sysdeps/unix/sysv/linux/getdents.c (__GETDENTS): Likewise.
+	* sysdeps/unix/sysv/linux/llseek.c (__llseek): Likewise.
+	* sysdeps/unix/sysv/linux/lxstat.c (__lxstat): Likewise.
+	* sysdeps/unix/sysv/linux/open64.c (__libc_open64): Likewise.
+	* sysdeps/unix/sysv/linux/poll.c (__poll): Likewise.
+	* sysdeps/unix/sysv/linux/pread.c (__libc_pread): Likewise.
+	* sysdeps/unix/sysv/linux/pread64.c (__libc_pread64): Likewise.
+	* sysdeps/unix/sysv/linux/pwrite.c (__libc_pwrite): Likewise.
+	* sysdeps/unix/sysv/linux/pwrite64.c (__libc_pwrite64): Likewise.
+	* sysdeps/unix/sysv/linux/readv.c (__libc_readv): Likewise.
+	* sysdeps/unix/sysv/linux/sigsuspend.c (__sigsuspend): Likewise.
+	* sysdeps/unix/sysv/linux/sigtimedwait.c (__sigtimedwait): Likewise.
+	* sysdeps/unix/sysv/linux/sigwait.c (__sigwait): Likewise.
+	* sysdeps/unix/sysv/linux/sigwaitinfo.c (__sigwaitinfo): Likewise.
+	* sysdeps/unix/sysv/linux/tcdrain.c (__libc_tcdrain): Likewise.
+	* sysdeps/unix/sysv/linux/wait.c (__libc_wait): Likewise.
+	* sysdeps/unix/sysv/linux/waitpid.c (__libc_waitpid): Likewise.
+	* sysdeps/unix/sysv/linux/writev.c (__libc_writev): Likewise.
+	* sysdeps/unix/sysv/linux/xstat.c (__xstat): Likewise.
+	* locale/programs/ld-collate.c (add_to_tablewc): Rewrite as
+	non-nested function.
+	(add_to_tablewc_weightpool, add_to_tablewc_collate,
+	add_to_tablewc_tablewc, add_to_tablewc_extrapool,
+	add_to_tablewc_indirectpool): State for add_to_tablewc.
+	(collate_output): Set up state for add_to_tablewc.
+	* locale/programs/ld-ctype.c (set_default): Rewrite as
+	non-nested function.
+	(set_class_defaults): Adjust calls to set_default.
+	* locale/programs/locale.c (get_source): Rewrite as
+	non-nested function.
+	(show_locale_vars): Adjust calls to get_source.
+	(show_info): Likewise.
+	(print_item): Rewrite as non-nested function.
+	* math/Makefile (libm-calls): Remove complex function files.
+	* posix/fnmatch_loop.c (findidxwc): Rewrite as non-nested
+	function.
+	(findidxc): Likewise.
+	(FCT): Don't include files with nested function definitions.
+	Adjust calls to findidx.
+	* posix/regcomp.c (seek_collating_symbol_entry): Rewrite as
+	non-nested function.
+	(lookup_collation_sequence_value, build_range_exp,
+	build_collating_symbol): Likewise.
+	(build_equiv_class): Don't include file with nested function.
+	Adjust calls to findidx.
+	* posix/regex_internal.h (findidx): Non-nested definition.
+	(re_string_elem_size_at): Don't include file with nested function.
+	Adjust calls to findidx.
+	* posix/regexec.c (check_node_accept_bytes): Likewise.
+	* stdio-common/printf_fp.c (hack_digit): Rewrite as non-nested
+	definition.
+	(__print_fp): Adjust calls to hack_digit.
+	* stdlib/rpmatch.c (try): Rewrite as non-nested definition.
+	(rpmatch): Adjust calls to try.
+	* string/strcoll.c (findidx): Rewrite as non-nested definition.
+	(STRCOLL): Don't include file with nested function definition.
+	Adjust calls to findidx.
+	* string/strxfrm.c (findidx): Rewrite as non-nested definition.
+	(STRXFRM): Don't include file with nested function definition.
+	Adjust calls to findidx.
+	
+2003-07-30  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/st200/Versions: New file.
+	* Makeconfig: Delete the code that filters -I options from cflags,
+	because it mistakenly removes the option -INLINE:xxx.
+	* shlib-versions: Add entry for ST200.
+	* csu/defs.awk: Don't put function name on .endp directive
+	because ST200 assembler does not allow it.
+	* elf/Makefile: Add dummy file to link for ld.so, because
+	st200 cc driver does not behave like gcc when there are no sources or
+	objects on the link line.
+	* elf/dl-conflict.c: Undo previous hack (see 2003-05-30) that
+	removed include of dynamic-link.h.
+	* elf/dl-deps.c (preload): Rewrite as prepro macro.
+	* elf/dl-reloc.c (RESOLVE_MAP, RESOLVE, CHECK_STATIC_TLS): Undo
+	previous hack (see 2003-05-30), thus restoring original glibc code.
+	* elf/do-rel.h (elf_dynamic_do_rela): Define in terms of
+	elf_dynamic_do_rel.
+	(elf_dynamic_do_rel): Ifdef out inline fn definition.  Add prepro
+	macro definition instead.
+	(LAZY_PLT_ELSE, L_ADDR_TEST, IF_REL_RELATIVE_REQUIRED,
+	IF_VERSYMIDX, ELSE_DO_ELF_MACHINE_REL): New macros used by
+	elf_dynamic_do_rel.
+	* elf/dynamic-link.h: Undo previous hack that ifdef'd out fn
+	prototypes.
+	(elf_get_dynamic_info): Ifdef out inline fn definition. Add prepro
+	macro definition instead.
+	(CHECK_NULL_DYN, ADJUST_DT_RELA, ADJUST_DT_REL, ADJUST_DYNAMIC,
+	DT_ASSERT, DT_RELA_ASSERT, DT_REL_ASSERT, DT_FLAGS_INIT,
+	DT_RPATH_INIT): New macros used by elf_get_dynamic_info.
+	(ELF_DYNAMIC_DO_RELOC): Hack to force use of elf_dynamic_do_rela.
+	* elf/rtld.c (_rtld_local): Rewrite strong_alias as asm due to
+	compiler problems with strong_alias.
+	(_dl_start): Give global visibility to prevent compiler removing it.
+	Braces for declaration within statements.
+	* iconvdata/cp1255.c, iconvdata/ibm932.c, iconvdata/ibm943.c,
+	locale/lc-ctype.c, sysdeps/generic/segfault.c:
+	Braces for declaration within statements.
+	* string/strxfrm.c (findidx): Separate version for wide char.
+	* sysdeps/st200/Dist: Add divdi3.c.
+	* sysdeps/st200/dl-fptr.c (local): Make externally visible,
+	rename as __local_internal.
+	(make_fdesc): Correct mistake in asm insert.
+	* sysdeps/st200/dl-lookupcfg.h
+	(DL_AUTO_FUNCTION_ADDRESS, DL_STATIC_FUNCTION_ADDRESS): Make
+	synthetic fn descriptor volatile to prevent compiler optimizing it
+	away.
+	* sysdeps/st200/dl-machine.h (__st200_init_bootstrap_fdesc_table,
+	elf_machine_dynamic, elf_machine_load_address):
+	Correct mistake in asm insert.
+	(TRAMPOLINE_TEMPLATE): Reloc offset is in r9 not r8.
+	fixup() returns ptr to fn descriptor, so load r63 and gp from this,
+	Surround asm with .text ... .previous.
+	(start, _dl_start_user): ST200 assembler does not accept
+	name in .proc and .endp directives.  Restore sp before tail-calling
+	user code.
+	(elf_machine_fixup_plt): Remove comment about release, it is about
+	ia64 not st200.
+	(elf_machine_rela, elf_machine_rela_relative,
+	elf_machine_lazy_rel): Remove inline fn definition, add prepro macro
+	definition.
+	(COPY_UNALIGNED_WORD, MAP_COMPAR, REL32_ACTION): Macros used by
+	elf_machine_rela.
+	* sysdeps/st200/elf/initfini.c, sysdeps/st200/elf/start.S:
+	Fix to work for PIC ABI.
+	* sysdeps/unix/sysv/linux/init-first.c (init): Rename as
+	__init_internal, make externally visible.
+	* sysdeps/unix/sysv/linux/st200/clone.S (__clone): Fix to work
+	for PIC ABI.
+	* sysdeps/unix/sysv/linux/st200/syscall.S (__syscall_stub0):
+	Save r14 around syscall. Return -1 in r16 on error.
+	* sysdeps/unix/sysv/linux/st200/sysdep.h (PSEUDO): Save r14
+	around syscall.
+	(SYSCALL_ERROR_HANDLER): Fix to work for PIC ABI.
+	* sysdeps/unix/sysv/linux/st200/mmap.c: New file.
+
+2003-07-31  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/Makefile: Fix dummy file hack so that it does not fail
+	if dummy.c does not exist.
+	* sysdeps/st200/dl-lookupcfg.h (DL_AUTO_FUNCTION_ADDRESS,
+	DL_STATIC_FUNCTION_ADDRESS): Add memory barrier to prevent
+	compiler reordering fn descriptor accesses.
+
+2003-09-15  Stephen Clarke <stephen.clarke@st.com>
+
+	* csu/abi-note.S: Ugh - temprary hack to force PIC ABI on this
+	target-independent asm file.  Sorry.  Will go away when we abandon the
+	PIC ABI.
+	* sysdeps/unix/sysv/linux/st200/sysdep.h: Force PIC ABI in .s files.
+	* sysdeps/st200/__longjmp.S: Force PIC ABI.
+	* sysdeps/st200/bsd-_setjmp.S: Likewise.
+	* sysdeps/st200/bsd-setjmp.S: Likewise.
+	* sysdeps/st200/setjmp.S: Likewise.
+	* sysdeps/st200/elf/start.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/clone.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/pipe.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/socket.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/syscall.S: Likewise.
+
+2003-09-15  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/st200/dl-machine.h: Allow loading of ELF files marked as
+	PIC ABI.
+
+2003-10-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* csu/Makefile: Remove special case for CPPFLAGS-elf-init.oS
+	and CFLAGS-elf-init.oS.  Merged from FSF source, see
+	libc/ChangeLog entry for 2003-05-13.
+
+2003-10-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* csu/abi-note.S: Make unpleasant PIC ABI stuff conditional on
+	PIC_ABI preprocessor macro, so it is no longer default.
+
+2003-10-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/dl-misc.c (INTERNAL_SYSCALL): Add braces for declaration
+	within statements (this gnu extension not yet supported by
+	st200 compiler).
+
+2003-10-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/dynamic-link.h (elf_get_dynamic_info): Change return to
+	goto in prepro macro version of inline function.
+
+2003-10-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/elf.h (R_LX_NEG_GPREL_HI23, R_LX_NEG_GPREL_LO9,
+	R_LX_COPY, R_LX_JMP_SLOT): New ST200 relocation types for
+	PIC/callee-sets-gp.
+
+2003-10-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/st200/__longjmp.S: Make PIC ABI stuff conditional on
+	PIC_ABI.
+	 (__longjmp): Restore r13 and r14, as these are now callee-save
+	in embedded ABI.
+	* sysdeps/st200/setjmp.S: Make PIC ABI version conditional
+	on PIC_ABI.
+	(__sigsetjmp): Save r13 and r14, as these are now callee-save
+	in embedded ABI.
+	* sysdeps/st200/bits/setjmp.h: Likewise.
+	* sysdeps/st200/bsd-_setjmp.S: Make PIC ABI stuff conditional on
+	PIC_ABI.
+	* sysdeps/st200/bsd-setjmp.S: Likewise.
+	* sysdeps/st200/dl-fptr.c (dl_lookup_address): Define for
+	PIC ABI only.
+	* sysdeps/st200/dl-lookupcfg.h (ELF_FUNCTION_PTR_IS_SPECIAL,
+	DL_SYMBOL_ADDRESS, DL_LOOKUP_ADDRESS, DL_AUTO_FUNCTION_ADDRESS,
+	DL_STATIC_FUNCTION_ADDRESS, DL_DT_INIT_ADDRESS,
+	DL_DT_FINI_ADDRESS, DL_UNMAP_IS_SPECIAL, DL_UNMAP):
+	Define for PIC ABI only.
+	* sysdeps/st200/dl-machine.h (USING_PIC_ABI): Define.
+	(ST200_BOOT_FPTR_TABLE_LEN, st200_fdesc_table,
+	__st200_init_bootstrap_fdesc_table,
+	ELF_MACHINE_BEFORE_RTLD_RELOC): Define for PIC ABI only.
+	(elf_machine_runtime_setup): Make function descriptor
+	manipulation conditional on PIC ABI.
+	(TRAMPOLINE_TEMPLATE): Make PIC ABI stuff conditional.
+	Add embedded ABI version.
+	(RTLD_START): Use new @neggprel assembler operator.
+	Make PIC ABI version conditional, add embedded ABI version.
+	(elf_machine_type_class): Add support for R_LX_COPY reloc.
+	(ELF_MACHINE_JMP_SLOT): Add support for R_LX_JMP_SLOT.
+	(ELF_MACHINE_START_ADDRESS): Define for PIC ABI only.
+	(elf_machine_fixup_plt): Make PIC ABI conditional.  Add
+	support for embedded ABI.
+	(elf_machine_rela): Support R_LX_JMP_SLOT.
+	Rename version to emr_version in case of name clashes in
+	heavily nested prepro macros.
+	Add support for R_LX_COPY.
+	Make PIC ABI reloc support conditional.
+	(elf_machine_lazy_rel): Make PIC ABI reloc support
+	conditional.
+	* sysdeps/st200/dl-symaddr.c (dl_symbol_address): Define
+	for PIC ABI only.
+ 	* sysdeps/st200/elf/entry.h (_start): Make hidden, now
+	that we have visibility attributes.
+	(ENTRY_POINT): Make PIC ABI version conditional, add
+	embedded ABI version.
+	* sysdeps/st200/elf/initfini.c (FPTR): Make PIC ABI version
+	conditional, add embedded ABI version.
+	(_init): Make PIC ABI bits conditional, add embedded ABI
+	version.
+	* sysdeps/st200/elf/start.S: Make PIC ABI conditional, add
+	support for embedded ABI.
+	(_start): Use new @neggprel assembler operator.
+	* sysdeps/unix/sysv/linux/st200/clone.S: Make PIC ABI stuff
+	conditional.
+	* sysdeps/unix/sysv/linux/st200/pipe.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/socket.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/syscall.S: Remove
+	__syscall_stub entry points.
+	Make PIC ABI stuff conditional.
+	* sysdeps/unix/sysv/linux/st200/sysdep.h (PSEUDO): Preserve
+	r13 around syscall.  This is now preserved, but older kernels
+	will not preserve it, so be cautious and explicitly save it.
+	(INLINE_SYSCALL): Reimplement as a proper inline asm.
+	(INTERNAL_SYSCALL_DECL, INTERNAL_SYSCALL,
+	INTERNAL_SYSCALL_ERROR_P, INTERNAL_SYSCALL_ERRNO): Define.
+
+2003-10-23  Stephen Clarke <stephen.clarke@st.com>
+	
+	* sysdeps/st200/setjmp.S (__sigsetjmp): For PIC code, set up GP
+	for call to __sigjmp_save.  Turn tailcall to __sigjmp_save into
+	call, so that r14 can be restored afterwards.
+	(_setjmp): Define in this file so that it can directly call
+	sigsetjmp.
+	(setjmp): Likewise.
+	* sysdeps/st200/bsd-setjmp.S: Move definition of setjmp from
+	here to setjmp.S.
+	* sysdeps/st200/bsd-_setjmp.S: Move definition of _setjmp from
+	here to setjmp.S.
+
+2003-11-05  Stephen Clarke <stephen.clarke@st.com>
+	
+	* sysdeps/unix/sysv/linux/st200/clone.S (__clone): Take new
+	version from uclibc implementation.  Fix to work with
+	embedded ABI PIC code.
+
+2003-11-10  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/unix/sysv/linux/st200/syscalls.list (ptrace): Add
+	ptrace, since it does not require the generic Linux mangling
+	of its arguments.
+
+2003-11-11  Stephen Clarke <stephen.clarke@st.com>
+
+	* stdio-common/printf_fp.c (hack_digit): Pass fracsize by
+	reference, because it is updated.
+
+2004-02-24  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/unix/sysv/linux/st200/sysdep.h (INLINE_SYSCALL): Do
+	not use retval as local variable name because this descopes
+	a macro argument in llseek.c.
+
+2004-02-24  Stephen Clarke <stephen.clarke@st.com>
+
+	* stdio-common/printf_fp.c (hack_digit): Pass exponent by
+	reference, because it is updated.
+
+2004-03-03  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/st200/elf/initfini.c (fini): Establish gp on entry.
+	Remove PIC_ABI and EMBEDDED_ABI conditional compilation: now
+	only the embedded ABI is supported.
+
+2004-03-08  Stephen Clarke <stephen.clarke@st.com>
+
+	* csu/abi-note.S: Remove support for PIC_ABI and the old
+	(non-GP-aware) EMBEDDED_ABI.  Now only the approved ST200
+	embedded ABI is supported.
+	* linuxthreads/sysdeps/unix/sysv/linux/st200/pt-initfini.c:
+	Likewise.
+	* sysdeps/st200/Makefile: Likewise.
+	* sysdeps/st200/__longjmp.S: Likewise.
+	* sysdeps/st200/dl-fptr.c: Likewise.
+	* sysdeps/st200/dl-lookupcfg.h: Likewise.
+	* sysdeps/st200/dl-machine.h: Likewise.
+	* sysdeps/st200/dl-symaddr.c: Likewise.
+	* sysdeps/st200/setjmp.S: Likewise.
+	* sysdeps/st200/elf/entry.h: Likewise.
+	* sysdeps/st200/elf/start.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/clone.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/pipe.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/socket.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/syscall.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/sysdep.h: Likewise.
+
+2004-03-08  Stephen Clarke <stephen.clarke@st.com>
+
+	* test-skeleton.c (main): Braces for declarations
+	within statements.
+	* iconvdata/tst-iconv4.c (do_test): Likewise.
+	* intl/tst-gettext.c (do_test): Likewise.
+	* io/ftwtest.c (main): Likewise.
+	* libio/bug-wfflush.c (do_test): Likewise.
+	* linuxthreads/tst-cancel4.c: Likewise.
+	* linuxthreads/tst-cancel6.c: Likewise.
+	* linuxthreads/Examples/ex6.c: Likewise.
+	* stdio-common/bug14.c: Likewise.
+	* stdlib/tst-strtod.c: Likewise.
+	* string/tester.c: Likewise.
+	* wcsmbs/tst-mbrtowc.c: Likewise.
+
+2004-03-08  Stephen Clarke <stephen.clarke@st.com>
+
+	* string/test-string.h: (FOR_EACH_IMPL): Braces for
+	declarations within statements.
+	(END_FOR_EACH_IMPL): Define.
+	* string/test-memchr.c: Use END_FOR_EACH_IMPL.
+	* string/test-memcmp.c: Use END_FOR_EACH_IMPL.
+	* string/test-memcpy.c: Use END_FOR_EACH_IMPL.
+	* string/test-memmove.c: Use END_FOR_EACH_IMPL.
+	* string/test-memset.c: Use END_FOR_EACH_IMPL.
+	* string/test-strcat.c: Use END_FOR_EACH_IMPL.
+	* string/test-strchr.c: Use END_FOR_EACH_IMPL.
+	* string/test-strcmp.c: Use END_FOR_EACH_IMPL.
+	* string/test-strcpy.c: Use END_FOR_EACH_IMPL.
+	* string/test-strlen.c: Use END_FOR_EACH_IMPL.
+	* string/test-strncmp.c: Use END_FOR_EACH_IMPL.
+	* string/test-strncpy.c: Use END_FOR_EACH_IMPL.
+	* string/test-strpbrk.c: Use END_FOR_EACH_IMPL.
+	* string/test-strrchr.c: Use END_FOR_EACH_IMPL.
+	* string/test-strspn.c: Use END_FOR_EACH_IMPL.
+
+2004-03-08  Stephen Clarke <stephen.clarke@st.com>
+
+	* gnulib/tst-gcc.c: Remove complex type from tests, it is
+	not supported by st200cc.
+	* math/Makefile: Likewise.
+	* math/libm-test.inc: Likewise.
+	* math/test-fenv.c: Likewise.
+	* math/tgmath.h: Likewise.
+	* math/Makefile: Remove -fno-inline on float and double
+	tests, the use appears to be incorrect.
+
+2004-03-08  Stephen Clarke <stephen.clarke@st.com>
+	* linuxthreads/sysdeps/unix/sysv/linux/st200/pt-initfini.c:
+	Set up GP on entry to _init, restore on exit.
+	Set up GP on entry to _fini, restore on exit.
+
+2004-03-09  Stephen Clarke <stephen.clarke@st.com>
+	* sysdeps/unix/sysv/linux/st200/sysdep.h
+	(SYSCALL_ERROR_HANDLER): Save r14 around errno
+	handling.
+
+2004-03-09  Stephen Clarke <stephen.clarke@st.com>
+	* sysdeps/unix/sysv/linux/st200/pread.c: New file.
+	Accommodate ST200 ABI conventions for passing 64-bit
+	integers.
+	* sysdeps/unix/sysv/linux/st200/pread64.c: Likewise.
+	* sysdeps/unix/sysv/linux/st200/pwrite.c: Likewise.
+	* sysdeps/unix/sysv/linux/st200/pwrite64.c: Likewise.
+	* sysdeps/unix/sysv/linux/st200/ftruncate64.c: Likewise.
+	* sysdeps/unix/sysv/linux/st200/truncate64.c: Likewise.
+
+2004-03-11  Stephen Clarke <stephen.clarke@st.com>
+	* include/libc-symbols.h (libc_freeres_ptr): Modify
+	disgusting gcc hack to work with open64 compiler.
+
+2004-03-11  Stephen Clarke <stephen.clarke@st.com>
+	* posix/regcomp.c (seek_collating_symbol_entry): Pass
+	more non-local variables as parameters.
+	(lookup_collation_sequence_value): Likewise.
+	(build_range_exp): Likewise.
+	(build_collating_symbol): Likewise.
+
+2004-03-11  Stephen Clarke <stephen.clarke@st.com>
+	* inet/test-ifaddrs.c (addr_string): Rewrite as
+	non-nested function.
+	* string/test-ffs.c (try): Likewise.
+	* linuxthreads/Makefile: Removed tst-cancel, it does
+	not build for st200.
+	* stdlib/Makefile: Removed test isomac as st200 does
+	not yet have the required header file iso646.h.
+
+2004-05-07  Stephen Clarke <stephen.clarke@st.com>
+	* dlfcn/Makefile: Build test-modules when cross-compiling.
+	(Change imported from crosstool-027, see http://kegel.com/crosstool).
+	* elf/Makefile: Likewise.
+
+2004-05-07  Stephen Clarke <stephen.clarke@st.com>
+	* elf/lateglobal.c (main): Correct check for dlopen failures.
+ 	(This fix was submitted to, and accepted by, the glibc maintainers.)
+	* posix/tst-chmod.c (do_test): Correct directory name.
+ 	(This fix was submitted to, and accepted by, the glibc maintainers.)
+
+2004-05-07  Stephen Clarke <stephen.clarke@st.com>
+	* sysdeps/st200/__init_trampoline.c: New file.  Support for nested
+	functions.
+	* sysdeps/st200/Makefile: Add __init_trampoline.
+
+2004-07-14  Stephen Clarke <stephen.clarke@st.com>
+	* sysdeps/unix/sysv/linux/st200/sydep.h (PSEUDO): No need to save
+	r13/r14 around syscall.
+	(SYSCALL_ERROR_HANDLER): Add non-PIC version.  Save r14 around
+	call to __errno_location.  Establish gp before call to
+	__errno_location.  Establish gp before using it to access errno.
+	(INTERNAL_SYSCALL): No need to save r14 around syscall.
+	* sysdeps/unix/sysv/linux/st200/clone.S: Rewrite using new
+	SYSCALL_ERROR_HANDLER.
+	* sysdeps/unix/sysv/linux/st200/pipe.S: Likewise.
+	* sysdeps/unix/sysv/linux/st200/syscall.S: Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/st200/elf/configure.in: Check for TLS support.
+	* sysdeps/st200/elf/configure: Regenerate.
+	* sysdeps/st200/dl-tls.h: New file.
+	* elf/elf.h: Add ST200 TLS relocations.
+	* elf/tls-macros.h: Add ST200 macros.
+	* sysdeps/st200/dl-machine.h (elf_machine_type_class): Handle TLS
+	relocations.
+	(elf_machine_rela): Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/dl-close.c (dl_close): Braces for declarations within
+	statements.
+	* elf/rtld.c: Likewise.
+	* elf/tst-tls9.c: Likewise.
+	* sysdeps/generic/dl-tls.c (dl_tls_setup): Likewise.
+	(dl_allocate_tls_init): Likewise.
+	* sysdeps/generic/libc-tls.c (__libc_setup_tls): Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* locale/setlocale.c (DEFINE_CATEGORY): Work around bug in st200cc
+	preprocessor.
+	(libc_freeres_fn): Likewise.
+	* locale/uselocale.c (DEFINE_CATEGORY): Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/check-textrel.c: Braces for declarations within
+	statements.
+	* elf/dl-reloc.c: Likewise.
+	* elf/tst-execstack.c: Likewise.
+	* elf/tst-tls14.c: Likewise.
+	* elf/tst-tlsmod14a.c: Likewise.
+	* misc/error.c: Likewise.
+	* nptl/allocatestack.c: Likewise.
+	* nptl/cancellation.c: Likewise.
+	* nptl/cleanup_defer.c: Likewise.
+	* nptl/cleanup_defer_compat.c: Likewise.
+	* nptl/eintr.c: Likewise.
+	* nptl/init.c: Likewise.
+	* nptl/libc-cancellation.c: Likewise.
+	* nptl/pthread_attr_setschedparam.c: Likewise.
+	* nptl/pthread_cancel.c: Likewise.
+	* nptl/pthread_condattr_setclock.c: Likewise.
+	* nptl/pthread_condattr_setpshared.c: Likewise.
+	* nptl/pthread_create.c: Likewise.
+	* nptl/pthread_detach.c: Likewise.
+	* nptl/pthread_getattr_np.c: Likewise.
+	* nptl/pthread_getschedparam.c: Likewise.
+	* nptl/pthread_getspecific.c: Likewise.
+	* nptl/pthread_join.c: Likewise.
+	* nptl/pthread_mutex_lock.c: Likewise.
+	* nptl/pthread_setcancelstate.c: Likewise.
+	* nptl/pthread_setcanceltype.c: Likewise.
+	* nptl/pthread_setschedparam.c: Likewise.
+	* nptl/pthread_timedjoin.c: Likewise.
+	* nptl/sem_init.c: Likewise.
+	* nptl/sem_open.c: Likewise.
+	* nptl/sem_unlink.c: Likewise.
+	* nptl/tst-align.c: Likewise.
+	* nptl/tst-atfork2.c: Likewise.
+	* nptl/tst-attr2.c: Likewise.
+	* nptl/tst-attr3.c: Likewise.
+	* nptl/tst-backtrace1.c: Likewise.
+	* nptl/tst-basic1.c: Likewise.
+	* nptl/tst-basic2.c: Likewise.
+	* nptl/tst-basic4.c: Likewise.
+	* nptl/tst-basic5.c: Likewise.
+	* nptl/tst-basic6.c: Likewise.
+	* nptl/tst-cancel1.c: Likewise.
+	* nptl/tst-cancel10.c: Likewise.
+	* nptl/tst-cancel11.c: Likewise.
+	* nptl/tst-cancel12.c: Likewise.
+	* nptl/tst-cancel13.c: Likewise.
+	* nptl/tst-cancel14.c: Likewise.
+	* nptl/tst-cancel15.c: Likewise.
+	* nptl/tst-cancel18.c: Likewise.
+	* nptl/tst-cancel20.c: Likewise.
+	* nptl/tst-cancel21.c: Likewise.
+	* nptl/tst-cancel22.c: Likewise.
+	* nptl/tst-cancel6.c: Likewise.
+	* nptl/tst-cancel7.c: Likewise.
+	* nptl/tst-cancel8.c: Likewise.
+	* nptl/tst-cancel9.c: Likewise.
+	* nptl/tst-cleanup1.c: Likewise.
+	* nptl/tst-cleanup3.c: Likewise.
+	* nptl/tst-cleanup4.c: Likewise.
+	* nptl/tst-clock2.c: Likewise.
+	* nptl/tst-cond11.c: Likewise.
+	* nptl/tst-cond12.c: Likewise.
+	* nptl/tst-cond14.c: Likewise.
+	* nptl/tst-cond18.c: Likewise.
+	* nptl/tst-cond19.c: Likewise.
+	* nptl/tst-cond2.c: Likewise.
+	* nptl/tst-cond8.c: Likewise.
+	* nptl/tst-cond9.c: Likewise.
+	* nptl/tst-context1.c: Likewise.
+	* nptl/tst-eintr1.c: Likewise.
+	* nptl/tst-eintr2.c: Likewise.
+	* nptl/tst-eintr3.c: Likewise.
+	* nptl/tst-eintr4.c: Likewise.
+	* nptl/tst-eintr5.c: Likewise.
+	* nptl/tst-exec1.c: Likewise.
+	* nptl/tst-exec2.c: Likewise.
+	* nptl/tst-exec3.c: Likewise.
+	* nptl/tst-exec4.c: Likewise.
+	* nptl/tst-fini1mod.c: Likewise.
+	* nptl/tst-flock1.c: Likewise.
+	* nptl/tst-flock2.c: Likewise.
+	* nptl/tst-fork1.c: Likewise.
+	* nptl/tst-fork2.c: Likewise.
+	* nptl/tst-fork3.c: Likewise.
+	* nptl/tst-fork4.c: Likewise.
+	* nptl/tst-join2.c: Likewise.
+	* nptl/tst-join3.c: Likewise.
+	* nptl/tst-join4.c: Likewise.
+	* nptl/tst-key1.c: Likewise.
+	* nptl/tst-key2.c: Likewise.
+	* nptl/tst-key3.c: Likewise.
+	* nptl/tst-key4.c: Likewise.
+	* nptl/tst-kill1.c: Likewise.
+	* nptl/tst-kill2.c: Likewise.
+	* nptl/tst-kill3.c: Likewise.
+	* nptl/tst-kill4.c: Likewise.
+	* nptl/tst-kill6.c: Likewise.
+	* nptl/tst-mutex2.c: Likewise.
+	* nptl/tst-mutex3.c: Likewise.
+	* nptl/tst-mutex8.c: Likewise.
+	* nptl/tst-once3.c: Likewise.
+	* nptl/tst-once4.c: Likewise.
+	* nptl/tst-rwlock14.c: Likewise.
+	* nptl/tst-rwlock6.c: Likewise.
+	* nptl/tst-rwlock7.c: Likewise.
+	* nptl/tst-sched1.c: Likewise.
+	* nptl/tst-sem6.c: Likewise.
+	* nptl/tst-signal1.c: Likewise.
+	* nptl/tst-signal2.c: Likewise.
+	* nptl/tst-signal4.c: Likewise.
+	* nptl/tst-signal5.c: Likewise.
+	* nptl/tst-signal6.c: Likewise.
+	* nptl/tst-stack1.c: Likewise.
+	* nptl/tst-stack2.c: Likewise.
+	* nptl/tst-stack3.c: Likewise.
+	* nptl/tst-stdio2.c: Likewise.
+	* nptl/tst-sysconf.c: Likewise.
+	* nptl/tst-tls1.c: Likewise.
+	* nptl/tst-tls4.c: Likewise.
+	* nptl/tst-tsd3.c: Likewise.
+	* nptl/tst-tsd4.c: Likewise.
+	* nptl/tst-tsd5.c: Likewise.
+	* nptl/tst-umask1.c: Likewise.
+	* nptl/sysdeps/pthread/createthread.c: Likewise.
+	* nptl/sysdeps/pthread/librt-cancellation.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_barrier_wait.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_cond_broadcast.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_cond_wait.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_rwlock_rdlock.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_rwlock_wrlock.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_sigmask.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/fork.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/getpid.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/pthread_attr_getaffinity.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/pthread_attr_setaffinity.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/pthread_kill.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/register-atfork.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/sem_wait.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/unregister-atfork.c: Likewise.
+	* nptl_db/td_ta_thr_iter.c: Likewise.
+	* nptl_db/td_thr_validate.c: Likewise.
+	* stdlib/fmtmsg.c: Likewise.
+	* sysdeps/unix/sysv/linux/sched_setaffinity.c: Likewise.
+	* sysdeps/unix/sysv/linux/sigwait.c: Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/unix/sysv/linux/sched_setaffinity.c: Fix merge
+	problem.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* linuxthreads/sysdeps/st200/pt-machine.h: Add definitions for
+	TLS.
+	* linuxthreads/sysdeps/st200/tls.h: New file.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* nptl/tst-attr1.c: Add braces for declarations within
+	statements. Increase timeout for davesim.
+	* nptl/tst-barrier4.c: Likewise.
+	* nptl/tst-cancel16.c: Likewise.
+	* nptl/tst-cond10.c: Likewise.
+	* nptl/tst-cond15.c: Likewise.
+	* nptl/tst-cond7.c: Likewise.
+	* nptl/tst-exit1.c: Likewise.
+	* nptl/tst-join5.c: Likewise.
+	* nptl/tst-mutex9.c: Likewise.
+	* nptl/tst-rwlock12.c: Likewise.
+	* nptl/tst-tls2.c: Likewise.
+	* nptl/tst-tls3.c: Likewise.
+	* nptl/tst-barrier2.c: Increase timeout for davesim.
+	* nptl/tst-cond1.c: Likewise.
+	* nptl/tst-dlsym1.c: Likewise.
+	* nptl/tst-mutex7.c: Likewise.
+	* nptl/tst-cancel17.c: Add braces for declarations within
+	statements.  Increase timeout for davesim.
+	Increase write size for davesim.
+	* nptl/tst-cancel19.c: Adjust __asm because "+r" is not
+	supported on st200.
+	Add braces for declarations within statements.
+	Rewrite initializers to avoid st200 compiler bug.
+	Increase timeout for davesim.
+	* nptl/tst-cancel2.c: Increse write size for davesim.
+	* nptl/tst-cancel4.c: Add braces for declarations within
+	statements.  Increase read and write size for davesim.
+	Increase timeout for davesim.
+	* nptl/tst-cond16.c: Add braces for declarations within
+	statements.
+	(n, exiting): Declare thread-shared as volatile.
+	* nptl/tst-signal3.c: Add braces for declarations within
+	statements.  Rewrite initializer to avoid st200 compiler
+	bug.  Increase timeout for davesim.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* elf/tst-tls13.c: Increase timeout for davesim.
+	* nptl/sysdeps/pthread/pthread_cond_timedwait.c: Add
+	braces for declarations within statements.
+	* nptl/sysdeps/pthread/pthread_rwlock_timedrdlock.c: Likewise.
+	* nptl/sysdeps/pthread/pthread_rwlock_timedwrlock.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/aio_misc.h: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/lowlevellock.c: Likewise.
+	* nptl/sysdeps/unix/sysv/linux/sem_timedwait.c: Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* nptl/sysdeps/st200/Makefile (CFLAGS-pt-initfini.c): Extra
+	options to make the assembly output cleaner.
+	* nptl/sysdeps/st200/jmpbuf-unwind.h (_JMPBUF_UNWINDS_ADJ):
+	Fix typo.
+	* nptl/sysdeps/st200/pthread_spin_trylock.c (pthread_spin_trylock):
+	Correct return value.
+	* nptl/sysdeps/st200/pthreaddef.h (__builtin_frame_address):
+	Dummy setting until compiler supports it properly.
+	* nptl/sysdeps/st200/tls.h (tcbhead_t): Add all the dummy fields.
+	* nptl/sysdeps/unix/sysv/linux/st200/Makefile (libpthread-routines):
+	Deleted.
+	* nptl/sysdeps/unix/sysv/linux/st200/lowlevellock.h
+	(__NR_futex): Don't define here, take it from unistd.h.
+	* nptl/sysdeps/unix/sysv/linux/st200/pt-initfini.c: New file.
+	* nptl/sysdeps/unix/sysv/linux/st200/pt-vfork.S (__vfork):
+	Fix typos.
+	* nptl/sysdeps/unix/sysv/linux/st200/pthread_once.c (__pthread_once):
+	Fix atomicity bug. Reformat.
+	* nptl/sysdeps/unix/sysv/linux/st200/sysdep-cancel.h: Reimplement
+	for st200.
+	* nptl/sysdeps/unix/sysv/linux/st200/vfork.S (__vfork): Fix
+	typos.
+	* sysdeps/st200/bits/setjmp.h: Fix typos.
+	* sysdeps/unix/sysv/linux/st200/clone.S: Fix typos.
+	(__clone): Fix argument ordering for clone syscall.
+	* sysdeps/unix/sysv/linux/st200/syscalls.list (semtimedop):
+	Fix alternative names.
+	* sysdeps/unix/sysv/linux/st200/sysdep.h (inline_syscall_clobbers):
+	Syscalls do not clobber r13, r14.
+	* sysdeps/unix/sysv/linux/st200/bits/atomic.h: New file.
+	* sysdeps/unix/sysv/linux/st200/sys/procfs.h (elf_greg_t): Define.
+	(elf_gregset_t, elf_fpregset_t): Likewise.
+
+2005-07-13  Stephen Clarke <stephen.clarke@st.com>
+
+	* nptl/sysdeps/pthread/configure.in (CFLAGS): Remove -Werror
+	because we get warnings about exception support on st200.
+	Allow non-forced-unwind configuration.
+	* nptl/sysdeps/pthread/configure: Regenerate.
+	* nptl/sysdeps/pthread/bits/libc-lock.h (__libc_cleanup_push,
+	__libc_cleanup_pop): Define specially for __st200__ so
+	that non-forced-unwind configuration works.
+	* nptl/sysdeps/pthread/bits/stdio-lock.h (__IO_acquire_lock,
+	_IO_release_lock): Likewise.
+	* nptl/Makefile: Remove tst-tls6 because it does not work
+	for cross-testing environment.
+	* sysdeps/generic/libc-start.c: Work around st200 compiler
+	problem with function-scope weak attributes.
+	Add braces for declarations within statements.
--- glibc/elf/elf.h	2004-05-07 02:56:25.000000000 +0100
+++ glibc-carl/elf/elf.h	2005-07-19 11:50:26.000000000 +0100
@@ -250,6 +250,8 @@
 #define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
 #define EM_NUM		95
 
+#define EM_LX         0x64      
+
 /* If it is necessary to assign new unofficial EM_* values, please
    pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
    chances of collision with official or non-GNU unofficial values.  */
@@ -2462,6 +2464,52 @@
 
 #define R_X86_64_NUM		24
 
+/* ST200 specific declarations.  */
+enum
+{
+  R_LX_NONE = 0,
+  R_LX_16,
+  R_LX_32,
+  R_LX_32_PCREL,
+  R_LX_23_PCREL,
+  R_LX_HI23,
+  R_LX_LO9,
+  R_LX_GPREL_HI23,
+  R_LX_GPREL_LO9,
+  R_LX_REL32,
+  R_LX_GOTOFF_HI23,
+  R_LX_GOTOFF_LO9,
+  R_LX_GOTOFFX_HI23,
+  R_LX_GOTOFFX_LO9,
+  R_LX_LTV32,
+  R_LX_SEGREL32,
+  R_LX_FPTR32,
+  R_LX_PLTOFF_HI23,
+  R_LX_PLTOFF_LO9,
+  R_LX_GOTOFF_FPTR_HI23,
+  R_LX_GOTOFF_FPTR_LO9,
+  R_LX_IPLT,
+  R_LX_NEG_GPREL_HI23,
+  R_LX_NEG_GPREL_LO9,
+  R_LX_COPY,
+  R_LX_JMP_SLOT,
+  R_LX_TPREL_HI23,
+  R_LX_TPREL_LO9,
+  R_LX_TPREL32,
+  R_LX_GOTOFF_TPREL_HI23,
+  R_LX_GOTOFF_TPREL_LO9,
+  R_LX_GOTOFF_DTPLDM_HI23,
+  R_LX_GOTOFF_DTPLDM_LO9,
+  R_LX_DTPREL_HI23,
+  R_LX_DTPREL_LO9,
+  R_LX_DTPMOD32,
+  R_LX_DTPREL32,
+  R_LX_GOTOFF_DTPNDX_HI23,
+  R_LX_GOTOFF_DTPNDX_LO9,
+  R_LX_NUM
+};
+
+
 __END_DECLS
 
 #endif	/* elf.h */
--- glibc-carl/README.clarkes	2005-07-19 11:50:26.000000000 +0100
+++ glibc-clarkes/README.clarkes	2005-07-28 16:41:53.000000000 +0100
@@ -0,0 +1,3 @@
+To configure for ST200, use something like:
+
+CC=st230-linux-opencc  CFLAGS="-O2 -INLINE:all_inline -OPT:Olimit=0 -fno-verbose-asm" ../../glibc/configure --with-headers=/home/afra/users/clarkes/st200/linux/kernel/linux-2.6/include --prefix=/home/afra/users/clarkes/st200/linux/lx-linux-tools/target/usr --without-cvs --build=i686-pc-linux-gnu --host=st200-linux --disable-profile --enable-add-ons=nptl --disable-debug --with-tls
--- glibc/scripts/config.sub	2003-12-03 01:30:27.000000000 +0000
+++ glibc-carl/scripts/config.sub	2005-03-01 10:57:40.000000000 +0000
@@ -263,6 +263,7 @@
 	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
+	| st2[0-9][0-9] \
 	| strongarm \
 	| tahoe | thumb | tic4x | tic80 | tron \
 	| v850 | v850e \
@@ -336,7 +337,7 @@
 	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
-	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
+	| sparcv9-* | sparcv9b-* | st2[0-9][0-9]-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tron-* \
@@ -880,6 +881,9 @@
 	spur)
 		basic_machine=spur-unknown
 		;;
+	st2[0-9][0-9])
+		basic_machine=st200-stm
+		;;
 	st2000)
 		basic_machine=m68k-tandem
 		;;
--- glibc/shlib-versions	2002-09-05 10:32:03.000000000 +0100
+++ glibc-carl/shlib-versions	2005-07-18 09:58:12.000000000 +0100
@@ -25,6 +25,7 @@
 cris-.*-linux.*		DEFAULT			GLIBC_2.2
 x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
 powerpc64-.*-linux.*	DEFAULT			GLIBC_2.3
+st2[0-9][0-9]-.*-linux.*	DEFAULT			GLIBC_2.3.2
 .*-.*-gnu-gnu.*		DEFAULT			GLIBC_2.2.6
 
 # Configuration		Library=version		Earliest symbol set (optional)
@@ -73,6 +74,7 @@
 powerpc64.*-.*-linux.*	ld=ld64.so.1		GLIBC_2.3
 cris-.*-linux.*		ld=ld.so.1		GLIBC_2.2
 x86_64-.*-linux.*	ld=ld-linux-x86-64.so.2	GLIBC_2.2.5
+
 # We use the ELF ABI standard name for the default.
 .*-.*-.*		ld=ld.so.1
 
--- glibc/elf/rtld-Rules	2003-07-25 04:31:13.000000000 +0100
+++ glibc-carl/elf/rtld-Rules	2005-03-01 10:57:25.000000000 +0000
@@ -30,9 +30,9 @@
 # When run from the elf/Makefile to build rtld-libc.a, $(subdir) is elf.
 ifeq ($(subdir),elf)
 
-ifndef rtld-subdirs
-error This makefile is a subroutine of elf/Makefile not to be used directly
-endif
+# ifndef rtld-subdirs
+# error This makefile is a subroutine of elf/Makefile not to be used directly
+# endif
 
 include ../Makeconfig
 
--- glibc/elf/tls-macros.h	2004-06-11 10:55:50.000000000 +0100
+++ glibc-carl/elf/tls-macros.h	2005-07-19 11:50:26.000000000 +0100
@@ -731,6 +731,52 @@
       __result;  \
   })
 
+#elif defined __st200__
+
+# define __TLS_CALL_CLOBBERS \
+ "r8",  "r9",  "r10", "r11", "r15", "r16", "r17", "r18", "r19", \
+ "r20", "r21", "r22", "r23", "r24", "r25", "r26", "r27", "r28", "r29", \
+ "r30", "r31", "r32", "r33", "r34", "r35", "r36", "r37", "r38", "r39", \
+ "r40", "r41", "r42", "r43", "r44", "r45", "r46", "r47", "r48", "r49", \
+ "r50", "r51", "r52", "r53", "r54", "r55", "r56", "r57", "r58", "r59", \
+ "r60", "r61", "r62", "r63"
+
+# define TLS_LE(x) \
+  ({ void *__l; \
+     asm ("add %0=$r13,@tprel(" #x ")\n;;\n" \
+         : "=r" (__l)); __l; })
+
+# define TLS_IE(x) \
+  ({ void *__l; \
+     asm ("call $r63=1f\n;;\n1:\nadd %0=$r63,@neggprel(1b)\n;;\n" \
+          "ldw %0=@gotoff(@tprel(" #x "))[%0]\n;;\n" \
+          "add %0=%0,$r13\n;;\n" \
+          : "=&r" (__l) : : "r63" ); __l; })
+
+# define TLS_LD(x) \
+  ({ void *__l; \
+     asm("mov  $r1=$r14\n" \
+         "add  $r12=$r12,-16\n" \
+         "call $r63=1f\n;;\n1:\nadd $r14=$r63,@neggprel(1b)\n;;\n" \
+         "add  $r16=$r14,@gotoff(@dtpldm(" #x "))\n" \
+         "call $r63=__tls_get_addr\n;;\n" \
+         "add  %0=$r16,@dtprel(" #x ")\n" \
+         "add  $r12=$r12,16\n" \
+         "mov  $r14=$r1\n;;\n" \
+         : "=r" (__l) :: "r1", __TLS_CALL_CLOBBERS); __l; })
+
+# define TLS_GD(x) \
+  ({ void *__l; \
+     asm("mov  $r1=$r14\n" \
+         "add  $r12=$r12,-16\n" \
+         "call $r63=1f\n;;\n1:\nadd $r14=$r63,@neggprel(1b)\n;;\n" \
+         "add  $r16=$r14,@gotoff(@dtpndx(" #x "))\n" \
+         "call $r63=__tls_get_addr\n;;\n" \
+         "mov  %0=$r16\n" \
+         "add  $r12,$r12,16\n" \
+         "mov  $r14=$r1\n;;\n" \
+         : "=r" (__l) :: "r1", __TLS_CALL_CLOBBERS); __l; })
+
 #else
 # error "No support for this architecture so far."
 #endif
--- glibc/STremoveExceptions	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/STremoveExceptions	2005-03-01 10:57:25.000000000 +0000
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+filelist=`find . | grep Makefile`
+
+for pfile in $filelist; do
+	cp $pfile $pfile.orig
+	sed -e 's/-fexceptions//g' -i $pfile
+	sed -e 's/-fasynchronous-unwind-tables//g' -i $pfile
+done
+
--- glibc/sysdeps/st200/bits/endian.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/bits/endian.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,37 @@
+/* Copyright (C) 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* ST200 can be little or big endian.  Hopefully gcc will know...  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#ifdef __BIG_ENDIAN__
+# ifdef __LITTLE_ENDIAN__
+#  error Both BIG_ENDIAN and LITTLE_ENDIAN defined!
+# endif
+# define __BYTE_ORDER __BIG_ENDIAN
+#else
+# ifdef __LITTLE_ENDIAN__
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# else
+#  warning Cannot determine current byte order, assuming little-endian.
+#  define __BYTE_ORDER __LITTLE_ENDIAN
+# endif
+#endif
--- glibc/sysdeps/st200/bits/link.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/bits/link.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,5 @@
+struct link_map_machine
+  {
+    size_t fptr_table_len;
+    Elf32_Addr *fptr_table;
+  };
--- glibc/sysdeps/st200/bits/setjmp.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/bits/setjmp.h	2005-07-19 11:50:36.000000000 +0100
@@ -0,0 +1,46 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Define the machine-dependent type `jmp_buf'.  ST200 version. */
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H  1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+ /* 0:    stack pointer  (r12)
+  * 1:    link register  (r63)
+  * 2-10: preserved regs (r1-r7, r13, r14)
+  */
+#define _JBLEN (2 + 9)
+
+#define _JB_STACK_PTR  0
+#define _JB_LINK       4
+#define _JB_PRE(n)     (8+(n)<<2)
+
+#ifndef __ASSEMBLER__
+typedef long int __jmp_buf[_JBLEN];
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void *) (jmpbuf)[_JB_STACK_PTR])
+#endif
+
+#endif  /* bits/setjmp.h */
--- glibc/sysdeps/st200/bsd-_setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/bsd-_setjmp.S	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1 @@
+/* _setjmp is in setjmp.S  */
--- glibc/sysdeps/st200/bsd-setjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/bsd-setjmp.S	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1 @@
+/* setjmp is in setjmp.S */
--- glibc/sysdeps/st200/Dist	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/Dist	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,4 @@
+divdi3.c
+dl-symaddr.c
+dl-fptr.c
+elf/entry.h
--- glibc/sysdeps/st200/divdi3.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/divdi3.c	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,75 @@
+/* 64-bit multiplication and division
+   Copyright (C) 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clarkes:
+   ST200 compiler does not use standard gcc names for these
+   functions, for example it uses __divl instead of __divdi3.
+   Compiler-generated calls to __divl pull in the appropriate module
+   of libarith.a, but that also contains a definition of
+   __divdi3 (which is the same code as __divl).  That definition
+   then clashes with the glibc definition of __divdi3, which is normally
+   in this file.
+   So why does glibc need to define __divdi3 et al.?  Not entirely
+   sure at the moment: there are clues on the glibc mailing list -
+   something to do with the version in libgcc.so being hidden.
+   This will need to be revisited when we have a libgcc.so.
+*/
+
+/* Prototypes of exported functions.  */
+extern long long __divdi3_internal (long long u, long long v);
+extern long long __moddi3_internal (long long u, long long v);
+extern unsigned long long __udivdi3_internal (unsigned long long u,
+					      unsigned long long v);
+extern unsigned long long __umoddi3_internal (unsigned long long u,
+					      unsigned long long v);
+
+long long
+__divdi3_internal (long long u, long long v)
+{
+  return __divl (u, v);
+}
+
+long long
+__moddi3_internal (long long u, long long v)
+{
+  return __modl (u, v);
+}
+
+unsigned long long
+__udivdi3_internal (unsigned long long u, unsigned long long v)
+{
+  return __divul (u, v);
+}
+
+unsigned long long
+__umoddi3_internal (unsigned long long u, unsigned long long v)
+{
+  return __modul (u, v);
+}
+
+/* We declare these with compat_symbol so that they are not visible at
+   link time.  Programs must use the functions from libgcc.  */
+#if defined HAVE_ELF && defined SHARED && defined DO_VERSIONING
+# include <shlib-compat.h>
+compat_symbol (libc, __divdi3_internal, __divdi3, GLIBC_2_0);
+compat_symbol (libc, __moddi3_internal, __moddi3, GLIBC_2_0);
+compat_symbol (libc, __udivdi3_internal, __udivdi3, GLIBC_2_0);
+compat_symbol (libc, __umoddi3_internal, __umoddi3, GLIBC_2_0);
+#endif
--- glibc/sysdeps/st200/dl-fptr.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/dl-fptr.c	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,20 @@
+/* Manage function descriptors.  ST200 version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Not needed for standard ST200 ABI. */
--- glibc/sysdeps/st200/dl-lookupcfg.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/dl-lookupcfg.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,27 @@
+/* Configuration of lookup functions.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* ST200 needs more information from the symbol lookup function
+   than just the address. */
+#define DL_LOOKUP_RETURNS_MAP
+
+/* Forward declaration.  */
+struct link_map;
+
--- glibc.2.3.3-virgin/sysdeps/st200/dl-machine.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc.2.3.3/sysdeps/st200/dl-machine.h	2006-03-30 18:44:06.000000000 +0100
@@ -0,0 +1,639 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  ST200 version.
+   Copyright (C) 1995-1997, 2000-2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h 1
+
+#define ELF_MACHINE_NAME "ST200"
+
+#include <assert.h>
+#include <string.h>
+#include <link.h>
+#include <errno.h>
+#include <tls.h>
+
+#define _ELF_LX_ABI_BIT	(0)                             /* 1st bit position in byte */
+#define ELF_LX_ABI_MASK		(0x7<<_ELF_LX_ABI_BIT)           /* mask */
+#define ELF_LX_ABI_NO		(0x0<<_ELF_LX_ABI_BIT)
+#define ELF_LX_ABI_PIC		(0x3<<_ELF_LX_ABI_BIT)
+
+#define VALID_ELF_ABIVERSION(ver) \
+  (((ver) & ELF_LX_ABI_MASK) == ELF_LX_ABI_NO || \
+   ((ver) & ELF_LX_ABI_MASK) == ELF_LX_ABI_PIC)
+#define VALID_ELF_OSABI(osabi) \
+  ((osabi) == ELFOSABI_SYSV)
+#define VALID_ELF_HEADER(hdr,exp,size) \
+  memcmp (hdr,exp,size-2) == 0 \
+  && VALID_ELF_OSABI (hdr[EI_OSABI]) \
+  && VALID_ELF_ABIVERSION (hdr[EI_ABIVERSION])
+
+/* Translate a processor specific dynamic tag to the index
+   in l_info array.  */
+#define DT_ST200(x) (DT_ST200_##x - DT_LOPROC + DT_NUM)
+
+extern Elf32_Addr __st200_make_fptr (struct link_map *, const Elf32_Sym *,
+				     Elf32_Addr);
+
+/* An FDESC is a function descriptor.  */
+
+struct st200_fdesc
+  {
+    Elf32_Addr ip;	/* code entry point */
+    Elf32_Addr gp;	/* global pointer */
+  };
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute__((unused))
+elf_machine_matches_host (const Elf64_Ehdr *ehdr)
+{
+  return ehdr->e_machine == EM_LX;
+}
+
+
+/* Return the link-time address of _DYNAMIC.  */
+static inline Elf32_Addr
+elf_machine_dynamic (void)
+{
+  Elf32_Addr *p;
+
+  __asm__ (
+	".section .data\n"
+	"	.type __dynamic_ltv, @object\n"
+	"	.size __dynamic_ltv, 4\n"
+	"__dynamic_ltv:\n"
+	"	.data4	@ltv(_DYNAMIC)\n"
+	".previous\n"
+	"	add %0 = $r0.14, @gprel(__dynamic_ltv)\n"
+        "       ;;\n"
+	: "=r" (p));
+
+  return *p;
+}
+
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr
+elf_machine_load_address (void)
+{
+  Elf32_Addr ip;
+  int *p;
+
+  __asm__ (
+	   "      call $r0.63 = 1f                                              \n"
+           "      ;;                                                            \n" 
+	   "1:    mov  %0 = $r0.63                                              \n"
+           "      ;;                                                            \n"
+	   ".section .data                                                      \n"
+	   "2:    .data4 @ltv(1b)                                               \n"
+	   "      .align 8                                                      \n"
+	   ".previous                                                           \n"
+	   "      add  %1 = $r0.14, @gprel(2b)                                  \n"
+           "      ;;                                                            \n"
+	   : "=r" (ip), "=r" (p)
+           :: "r63");
+
+  return ip - (Elf32_Addr) *p;
+}
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+
+static inline int
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+  extern void _dl_runtime_resolve (void);
+  extern void _dl_runtime_profile (void);
+
+  if (l->l_info[DT_JMPREL] && lazy)
+    {
+      register Elf32_Addr gp __asm__ ("r14");
+      Elf32_Addr *got, doit;
+
+       /* The GOT entries for functions in the PLT have not yet been filled
+	 in.  Their initial contents will arrange when called to load an
+	 offset into the .rela.plt section and _GLOBAL_OFFSET_TABLE_[1],
+	 and then jump to _GLOBAL_OFFSET_TABLE[2].  */
+      got = (Elf32_Addr *) D_PTR (l, l_info[DT_PLTGOT]);
+
+      /* Identify this shared object.  */
+      got[0] = (Elf32_Addr) l;
+
+      /* This function will be called to perform the relocation.  */
+      if (!profile)
+	{
+	  doit = (Elf32_Addr) &_dl_runtime_resolve;
+	}
+      else
+	{
+	  /* Say that we really want profiling and the timers are started.  */
+	  doit = (Elf32_Addr) &_dl_runtime_profile;
+	  GL(dl_profile_map) = l;
+	}
+
+      got[1] = doit;
+      got[2] = gp;
+    }
+
+  return lazy;
+}
+
+
+/*
+   This code is used in dl-runtime.c to call the `fixup' function
+   and then redirect to the address it returns.
+ */
+/*
+   On entry to this trampoline we have
+   r8 =caller gp (PIC ABI only)
+   r9 = relocation index
+   r10 = link map address
+   r14 = gp for 'fixup' (PIC ABI only)
+   r14 = caller gp (embedded ABI only)
+   r15 .. r23 = function arguments
+   r63 = caller return address.
+   We need to save the arguments, and return address, then call
+   the fixup function.
+   The normal fixup() function needs two arguments:
+   r16 = link map address.
+   r17 = relocation index
+   profile_fixup() needs an extra argument:
+   r18 = caller return address
+ */
+
+#define SET_FUN_ADDR \
+"       mov  $r0.63     = $r0.16                                          \n"\
+"       ;;                                                                \n"
+
+#define SAVE_CALLER_GP \
+"       stw  56[$r0.12] = $r0.14                                          \n"\
+"       ;;                                                                \n"
+
+#define RESTORE_CALLER_GP \
+"       ldw  $r0.14     = 56[$r0.12]                                      \n"\
+"       ;;                                                                \n"
+
+#define TRAMPOLINE_TEMPLATE(tramp_name, fixup_name)			     \
+  extern void tramp_name (void);					     \
+  __asm__ (								     \
+"       .text                                                             \n"\
+"	.global " #tramp_name "                                           \n"\
+"       .type " #tramp_name ", @function                                  \n"\
+"	.proc                                                             \n"\
+#tramp_name ":                                                            \n"\
+"       add  $r0.12     = $r0.12, -64                                     \n"\
+"       ;;                                                                \n"\
+"       stw  16[$r0.12] = $r0.15                                          \n"\
+"       ;;                                                                \n"\
+"       stw  20[$r0.12] = $r0.16                                          \n"\
+"       ;;                                                                \n"\
+"       stw  24[$r0.12] = $r0.17                                          \n"\
+"       ;;                                                                \n"\
+"       stw  28[$r0.12] = $r0.18                                          \n"\
+"       ;;                                                                \n"\
+"       stw  32[$r0.12] = $r0.19                                          \n"\
+"       ;;                                                                \n"\
+"       stw  36[$r0.12] = $r0.20                                          \n"\
+"       ;;                                                                \n"\
+"       stw  40[$r0.12] = $r0.21                                          \n"\
+"       ;;                                                                \n"\
+"       stw  44[$r0.12] = $r0.22                                          \n"\
+"       ;;                                                                \n"\
+"       stw  48[$r0.12] = $r0.23                                          \n"\
+"       ;;                                                                \n"\
+"       stw  52[$r0.12] = $r0.63                                          \n"\
+"       ;;                                                                \n"\
+SAVE_CALLER_GP                                                               \
+"       mov  $r0.16     = $r0.10                                          \n"\
+"       mov  $r0.17     = $r0.9                                           \n"\
+"       mov  $r0.18     = $r0.63    /* needed by profile_fixup */         \n"\
+"       ;;                                                                \n"\
+"       call $r0.63     = " #fixup_name "                                 \n"\
+"       ;;                                                                \n"\
+SET_FUN_ADDR                                                                 \
+"       ldw  $r0.8      = 52[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.15     = 16[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.16     = 20[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.17     = 24[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.18     = 28[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.19     = 32[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.20     = 36[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.21     = 40[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.22     = 44[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+"       ldw  $r0.23     = 48[$r0.12]                                      \n"\
+"       ;;                                                                \n"\
+RESTORE_CALLER_GP                                                            \
+"       goto $r0.63                                                       \n"\
+"       mov  $r0.63     = $r0.8                                           \n"\
+"       add  $r0.12     = $r0.12, +64                                     \n"\
+"       ;;                                                                \n"\
+"       .endp                                                             \n"\
+"       .previous                                                         \n"\
+);
+
+#ifndef PROF
+#define ELF_MACHINE_RUNTIME_TRAMPOLINE 				\
+  TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup)		\
+  TRAMPOLINE_TEMPLATE (_dl_runtime_profile, profile_fixup)
+#else
+#define ELF_MACHINE_RUNTIME_TRAMPOLINE				\
+  TRAMPOLINE_TEMPLATE (_dl_runtime_resolve, fixup)		\
+  strong_alias (_dl_runtime_resolve, _dl_runtime_profile)
+#endif
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+
+/* When we arrive at _start, the program stack looks like this:
+        argc            argument counter (integer)
+        argv[0]         program name (pointer)
+        argv[1...N]     program args (pointers)
+        argv[argc-1]    end of args (integer)
+	NULL
+        env[0...N]      environment variables (pointers)
+        NULL
+
+	When we are done here, we want
+	a1=argc
+	a2=argv[0]
+	a3=argv[argc+1]
+*/
+
+#ifndef RTLD_START_SPECIAL_INIT
+#define RTLD_START_SPECIAL_INIT /* nothing */
+#endif
+
+#define USER_ENTRY_ADDR \
+"       mov     $r0.63 = $r0.1                                             \n"
+#define DL_FINI_ADDR \
+"       ldw     $r0.16 = @gotoff(_dl_fini)[$r0.14]                         \n"\
+"       ;;                                                                 \n"
+
+
+#define RTLD_START __asm__ (						      \
+".text                                                                     \n"\
+"       .align 8                                                           \n"\
+"	.global _start						           \n"\
+"	.proc   						           \n"\
+"_start:								   \n"\
+"       add     $r0.12 = $r0.12, -32                                       \n"\
+"       # Set up gp                                                        \n"\
+"       call    $r0.63 = 0f                                                \n"\
+"       ;;                                                                 \n"\
+"       # We calculate gp using                                            \n"\
+"       # gp = true_address(label 0) - gprel(label 0).                     \n"\
+"       # Note that gprel(label 0) is a data - text calculation, so this   \n"\
+"       # prevents us from moving the data seg relative to the text seg.   \n"\
+"0:     add     $r0.14 = $r0.63, @neggprel(0b)                             \n"\
+"       ;;                                                                 \n"\
+"       # Call _dl_start(&argc)                                            \n"\
+"       add     $r0.16 = $r0.12, 32                                        \n"\
+"       call    $r0.63 = _dl_start                                         \n"\
+"       ;;                                                                 \n"\
+"       .endp                                                              \n"\
+"       # Fall through                                                     \n"\
+"       .global _dl_start_user                                             \n"\
+"       .proc                                                              \n"\
+"_dl_start_user:                                                           \n"\
+"       # Save pointer to user entry point fdsc in $r0.1.                  \n"\
+"       mov     $r0.1  = $r0.16                                            \n"\
+"       # Store the highest stack address in __libc_stack_end.             \n"\
+"       ldw     $r0.8  = @gotoff(__libc_stack_end)[$r0.14]                 \n"\
+"       ;;                                                                 \n"\
+"       add     $r0.9  = $r0.12, 32                                        \n"\
+"       ;;                                                                 \n"\
+"       stw     0[$r0.8] = $r0.9                                           \n"\
+"       ;;                                                                 \n"\
+"       # See if we were run as a command with the executable file name as \n"\
+"       # an extra leading argument.                                       \n"\
+"       ldw     $r0.8  = @gprel(_dl_skip_args)[$r0.14]                     \n"\
+"       ;;                                                                 \n"\
+"       # Get the original argument count.                                 \n"\
+"       ldw     $r0.9  = 32[$r0.12]                                        \n"\
+"       ;;                                                                 \n"\
+"       add     $r0.10 = $r0.12, 36  # r10 = original argv on stack        \n"\
+"       ;;                                                                 \n"\
+"       # Here $r0.8 is the value of _dl_skip_args                         \n"\
+"       # $r0.9 is the original argc                                       \n"\
+"       # We need to                                                       \n"\
+"       #    1. Overwrite argc on stack with (argc - _dl_skip_args)        \n"\
+"       #    2. Move argv down on stack, to overwrite skipped args         \n"\
+"       #       (cannot just adjust sp since we must keep sp aligned)      \n"\
+"       #    3. Move envp down on stack, to keep it next to argv           \n"\
+"       #    4. Update _dl_argv                                            \n"\
+"       # Subtract _dl_skip_args from original argument count.             \n"\
+"       sub     $r0.17 = $r0.9,  $r0.8                                     \n"\
+"       sh2add  $r0.11 = $r0.8,  $r0.10  # r11 = argv we want to move      \n"\
+"       ;;                                                                 \n"\
+"       # Step 1: overwrite argc on stack                                  \n"\
+"       stw     32[$r0.12] = $r0.17                                        \n"\
+"       ;;                                                                 \n"\
+"       ldw     $r0.9  = @gotoff(_dl_argv)[$r0.14]  # r9 = &_dl_argv       \n"\
+"       ;;                                                                 \n"\
+"       # Step 2: loop to move argv down the stack                         \n"\
+"       # Note that we enter this loop even when _dl_skip_args is zero -   \n"\
+"       # in that case we copy argv over itself.                           \n"\
+"1:     ldw     $r0.16 = 0[$r0.11]                                         \n"\
+"       ;;                                                                 \n"\
+"       add     $r0.11 = $r0.11, 4                                         \n"\
+"       ;;                                                                 \n"\
+"       cmpne   $b0.0  = $r0.16, 0                                         \n"\
+"       ;;                                                                 \n"\
+"       stw     0[$r0.10] = $r0.16                                         \n"\
+"       ;;                                                                 \n"\
+"       add     $r0.10 = $r0.10, 4                                         \n"\
+"       ;;                                                                 \n"\
+"       br      $b0.0, 1b                                                  \n"\
+"       ;;                                                                 \n"\
+"       ldw     $r0.18 = 0[$r0.9]              # r18 = _dl_argv            \n"\
+"       shl     $r0.8  = $r0.8, 2              # r8  = 4 * _dl_skip_args   \n"\
+"       mov     $r0.19 = $r0.10                # r19 = updated &envp       \n"\
+"       ;;                                                                 \n"\
+"       # Step 3: loop to move envp down the stack                         \n"\
+"1:     ldw     $r0.16 = 0[$r0.11]                                         \n"\
+"       ;;                                                                 \n"\
+"       add     $r0.11 = $r0.11, 4                                         \n"\
+"       ;;                                                                 \n"\
+"       cmpne   $b0.0  = $r0.16, 0                                         \n"\
+"       ;;                                                                 \n"\
+"       stw     0[$r0.10] = $r0.16                                         \n"\
+"       ;;                                                                 \n"\
+"       add     $r0.10 = $r0.10, 4                                         \n"\
+"       ;;                                                                 \n"\
+"       br      $b0.0, 1b                                                  \n"\
+"       ;;                                                                 \n"\
+"       sub  $r0.18 = $r0.18, $r0.8  # r18 = _dl_argv - (4 * _dl_skip_args)\n"\
+"       ;;                                                                 \n"\
+"       # Step 4: overwrite _dl_argv                                       \n"\
+"       stw     0[$r0.9] = $r0.18                                          \n"\
+"       ;;                                                                 \n"\
+RTLD_START_SPECIAL_INIT                                                       \
+"       # Now call _dl_init(_rtld_local, argc, argv, envp).                \n"\
+"       ldw     $r0.16 = @gprel(_rtld_local)[$r0.14]                       \n"\
+"       ;;                                                                 \n"\
+"       # r17 already contains argc.                                       \n"\
+"       add     $r0.18 = $r0.12, 36                                        \n"\
+"       # r19 already contains &envp                                       \n"\
+"       call    $r0.63 = _dl_init_internal                                 \n"\
+"       ;;                                                                 \n"\
+"       # Now call (*user_entry)(_dl_fini).                                \n"\
+DL_FINI_ADDR                                                                  \
+USER_ENTRY_ADDR                                                               \
+"       add     $r0.12 = $r0.12, 32                                        \n"\
+"       ;;                                                                 \n"\
+"       goto    $r0.63                                                     \n"\
+"       ;;                                                                 \n"\
+"       .endp                                                              \n"\
+"       .align 8                                                           \n"\
+".previous                                                                 \n"\
+);
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or TLS
+   variable, so undefined references should not be allowed to define the
+   value.
+   ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
+   of the main executable's symbols, as for a COPY reloc. */
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || USE___THREAD)
+#define elf_machine_type_class(type) \
+  (((((type) == R_LX_IPLT)           \
+      | ((type) == R_LX_JMP_SLOT)    \
+      | ((type) == R_LX_DTPMOD32)    \
+      | ((type) == R_LX_DTPREL32)    \
+      | ((type) == R_LX_TPREL32)) * ELF_RTYPE_CLASS_PLT)\
+   | (((type) == R_LX_COPY) * ELF_RTYPE_CLASS_COPY))
+#else
+#define elf_machine_type_class(type) \
+  (((((type) == R_LX_IPLT) | ((type) == R_LX_JMP_SLOT)) * ELF_RTYPE_CLASS_PLT)\
+   | (((type) == R_LX_COPY) * ELF_RTYPE_CLASS_COPY))
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
+#define ELF_MACHINE_JMP_SLOT	 (R_LX_JMP_SLOT)
+
+/* Rela is always used.  */
+#define ELF_MACHINE_NO_REL 1
+
+#define elf_machine_profile_fixup_plt(l, reloc, rel_addr, value) \
+  elf_machine_fixup_plt (l, reloc, rel_addr, value)
+
+#define elf_machine_profile_plt(reloc_addr) ((Elf32_Addr) (reloc_addr))
+
+/* Fixup a PLT entry to bounce directly to the function at VALUE.  */
+static inline Elf32_Addr __attribute__ ((always_inline))
+elf_machine_fixup_plt (struct link_map *l, lookup_t t,
+		       const Elf32_Rela *reloc,
+		       Elf32_Addr *reloc_addr, Elf32_Addr value)
+{
+  /* l is the link_map for the caller, t is the link_map for the object
+   * being called */
+  /* got has already been relocated in elf_get_dynamic_info() */
+  reloc_addr[0] = value;
+  return value;
+}
+
+/* Return the final value of a plt relocation.  */
+static inline Elf32_Addr
+elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
+		       Elf32_Addr value)
+{
+  /* No need to handle rel vs rela since ST200 is rela only */
+  return value + reloc->r_addend;
+}
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+#define R_ST200_TYPE(R)	 ((R) & -8)
+#define R_ST200_FORMAT(R) ((R) & 7)
+
+/* Perform the relocation specified by RELOC and SYM (which is fully
+   resolved).  MAP is the object containing the reloc.  */
+static inline void
+elf_machine_rela (struct link_map *map,
+		  const Elf32_Rela *reloc,
+		  const Elf32_Sym *sym,
+		  const struct r_found_version *version,
+		  void *const reloc_addr_arg)
+{
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
+  Elf32_Addr value;
+
+#define COPY_UNALIGNED_WORD(swp, twp, align) \
+  { \
+    void *__s = (swp), *__t = (twp); \
+    if ((align) == 0) \
+      *(unsigned long *) __t = *(unsigned long *) __s; \
+    else if ((align) == 2) \
+      { \
+        *((unsigned short *) __t)++ = *((unsigned short *) __s)++; \
+	*((unsigned short *) __t) = *((unsigned short *) __s); \
+      } \
+    else \
+      { \
+        *((unsigned char *) __t)++ = *((unsigned char *) __s)++; \
+        *((unsigned char *) __t)++ = *((unsigned char *) __s)++; \
+        *((unsigned char *) __t)++ = *((unsigned char *) __s)++; \
+        *((unsigned char *) __t) = *((unsigned char *) __s); \
+      } \
+  }
+
+#if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC && !defined SHARED
+  /* This is defined in rtld.c, but nowhere in the static libc.a; make the
+     reference weak so static programs can still link.  This declaration
+     cannot be done when compiling rtld.c (i.e.  #ifdef RTLD_BOOTSTRAP)
+     because rtld.c contains the common defn for _dl_rtld_map, which is
+     incompatible with a weak decl in the same file.  */
+  weak_extern (_dl_rtld_map);
+#endif
+
+  /* We cannot use a switch here because we may not be able to locate the
+     switch jump table until we've self-relocated (depends how the compiler
+     code generates a switch).  */
+
+#if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
+  if (__builtin_expect (r_type == R_LX_REL32, 0))
+    {
+      COPY_UNALIGNED_WORD (reloc_addr, &value, (int) reloc_addr & 3);
+# if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC
+      /* Already done in dynamic linker.  */
+      if (map != &GL(dl_rtld_map))
+# endif
+        value += map->l_addr;
+    }
+  else
+#endif
+    if (__builtin_expect (r_type == R_LX_NONE, 0))
+      return;
+  else
+    {
+      const Elf32_Sym *const refsym = sym;
+      struct link_map *sym_map;
+
+      /* RESOLVE_MAP() will return NULL if it fail to locate the symbol.  */
+      if ((sym_map = RESOLVE_MAP (&sym, version, r_type)))
+        {
+	  value = sym_map->l_addr + sym->st_value + reloc->r_addend;
+
+	  if (r_type == R_LX_32)
+	    ;/* No adjustment.  */
+	  else if (r_type == ELF_MACHINE_JMP_SLOT)
+	    {
+	      elf_machine_fixup_plt (NULL, sym_map, reloc, reloc_addr, value);
+	      return;
+	    }
+	  else if (r_type == R_LX_32_PCREL)
+	    value -= (Elf32_Addr) reloc_addr;
+          else if (r_type == R_LX_COPY)
+            {
+              if (sym == NULL)
+                /* This can happen in trace mode if an object could not be \
+                   found. */
+                return;
+              if (sym->st_size > refsym->st_size
+		  || (sym->st_size < refsym->st_size && GLRO(dl_verbose)))
+	        {
+                  const char *strtab;
+
+                  strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
+                  _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				    rtld_progname ?: "<program name unknown>",
+				    strtab + refsym->st_name);
+		}
+              memcpy (reloc_addr, (void *) value, MIN (sym->st_size,
+                      refsym->st_size));
+              return;
+	    }
+#if defined USE_TLS && (!defined RTLD_BOOTSTRAP || defined USE___THREAD)
+	  else if (r_type == R_LX_DTPMOD32)
+# ifdef RTLD_BOOTSTRAP
+	    /* During startup the dynamic linker is always index 1.  */
+	    value = 1;
+# else	      
+	    /* Get the information from the link map returned by the
+	       resolv function.  */
+	    value = sym_map->l_tls_modid;
+# endif
+	  else if (r_type == R_LX_DTPREL32)
+	    value -= sym_map->l_addr;
+	  else if (r_type == R_LX_TPREL32)
+	    {
+# ifndef RTLD_BOOTSTRAP
+	      CHECK_STATIC_TLS (map, sym_map);
+# endif
+	      value += sym_map->l_tls_offset - sym_map->l_addr;
+	    }
+#endif
+	  else
+	    _dl_reloc_bad_type (map, r_type, 0);
+	}
+      else
+	value = 0;
+    }
+
+  COPY_UNALIGNED_WORD (&value, reloc_addr, (int) reloc_addr & 3);
+}
+
+/* Let do-rel.h know that on ST200 if l_addr is 0, all RELATIVE relocs
+   can be skipped.  */
+#define ELF_MACHINE_REL_RELATIVE 1
+
+static inline void
+elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
+			   void *const reloc_addr_arg)
+{
+  Elf32_Addr value;
+
+  assert (reloc->r_info == R_LX_REL32);
+  value = l_addr + reloc->r_addend;
+  COPY_UNALIGNED_WORD (&value, reloc_addr_arg, (int) reloc_addr_arg & 3);
+
+#undef COPY_UNALIGNED_WORD
+}
+
+/* Perform a RELATIVE reloc on the .got entry that transfers to the .plt.  */
+static inline void
+elf_machine_lazy_rel (struct link_map *map,
+		      Elf32_Addr l_addr, const Elf32_Rela *reloc)
+{
+  Elf32_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
+
+  if (r_type == ELF_MACHINE_JMP_SLOT)
+    {
+      reloc_addr[0] += l_addr;
+    }
+  else if (r_type == R_LX_NONE)
+    return;
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+#endif /* RESOLVE_MAP */
--- glibc/sysdeps/st200/dl-symaddr.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/dl-symaddr.c	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,20 @@
+/* Get the symbol address.  ST200 version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Not needed for standard ST200 ABI. */
--- glibc/sysdeps/st200/dl-tls.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/dl-tls.h	2005-07-13 14:43:21.000000000 +0100
@@ -0,0 +1,29 @@
+/* Thread-local storage handling in the ELF dynamic linker.  st200 version.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
--- glibc/sysdeps/st200/elf/configure	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/elf/configure	2005-07-19 11:50:36.000000000 +0100
@@ -0,0 +1,58 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/st200/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+echo "$as_me:$LINENO: checking for st200 TLS support" >&5
+echo $ECHO_N "checking for st200 TLS support... $ECHO_C" >&6
+if test "${libc_cv_st200_tls+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat > conftest.s <<\EOF
+	.section ".tdata", "awT", @progbits
+	.global foo
+foo:	.long	1
+	.section ".tbss", "awT", @nobits
+	.global bar
+bar:	.skip	4
+	.text
+baz:	ldw	$r1=@tprel(bar)[$r13]
+	;;
+	ldw	$r1=@gotoff(@tprel(foo))[$r14]
+	;;
+	ldw	$r1=@dtprel(bar)[$r1]
+	;;
+	ldw	$r1=@gotoff(@dtpndx(foo))[$r14]
+	;;
+	ldw	$r1=@gotoff(@dtpldm(bar))[$r14]
+	;;
+EOF
+if { ac_try='${CC-cc} -v -c $CFLAGS conftest.s 1>&5'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  libc_cv_st200_tls=yes
+else
+  libc_cv_st200_tls=no
+fi
+rm -f conftest*
+fi
+echo "$as_me:$LINENO: result: $libc_cv_st200_tls" >&5
+echo "${ECHO_T}$libc_cv_st200_tls" >&6
+if test $libc_cv_st200_tls = yes; then
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_TLS_SUPPORT 1
+_ACEOF
+
+fi
+fi
+
+cat >>confdefs.h <<\_ACEOF
+#define PI_STATIC_AND_HIDDEN 1
+_ACEOF
+
+
+
--- glibc/sysdeps/st200/elf/configure.in	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/elf/configure.in	2005-07-19 11:50:36.000000000 +0100
@@ -0,0 +1,43 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/st200/elf.
+
+if test "$usetls" != no; then
+# Check for support of thread-local storage handling in assembler and
+# linker.
+AC_CACHE_CHECK(for st200 TLS support, libc_cv_st200_tls, [dnl
+cat > conftest.s <<\EOF
+	.section ".tdata", "awT", @progbits
+	.global foo
+foo:	.long	1
+	.section ".tbss", "awT", @nobits
+	.global bar
+bar:	.skip	4
+	.text
+baz:	ldw	$r1=@tprel(bar)[[$r13]]
+	;;
+	ldw	$r1=@gotoff(@tprel(foo))[[$r14]]
+	;;
+	ldw	$r1=@dtprel(bar)[[$r1]]
+	;;
+	ldw	$r1=@gotoff(@dtpndx(foo))[[$r14]]
+	;;
+	ldw	$r1=@gotoff(@dtpldm(bar))[[$r14]]
+	;;
+EOF
+dnl
+if AC_TRY_COMMAND(${CC-cc} -v -c $CFLAGS conftest.s 1>&AS_MESSAGE_LOG_FD); then
+  libc_cv_st200_tls=yes
+else
+  libc_cv_st200_tls=no
+fi
+rm -f conftest*])
+if test $libc_cv_st200_tls = yes; then
+  AC_DEFINE(HAVE_TLS_SUPPORT)
+fi
+fi
+
+dnl It is always possible to access static and hidden symbols in an
+dnl position independent way.
+AC_DEFINE(PI_STATIC_AND_HIDDEN)
+
+
--- glibc/sysdeps/st200/elf/entry.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/elf/entry.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,6 @@
+#ifndef __ASSEMBLY__
+extern void _start (void) attribute_hidden;
+#endif
+
+#define ENTRY_POINT _start
+
--- glibc/sysdeps/st200/elf/initfini.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/elf/initfini.c	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,118 @@
+/* Special .init and .fini section support for ST200.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file is compiled into assembly code which is then munged by a sed
+   script into two files: crti.s and crtn.s.
+
+   * crti.s puts a function prologue at the beginning of the
+   .init and .fini sections and defines global symbols for
+   those addresses, so they can be called as functions.
+
+   * crtn.s puts the corresponding function epilogues
+   in the .init and .fini sections. */
+
+__asm__ ("\n\n"
+"#include \"defs.h\"                                                        \n"
+"/*define SHARED*/                                                          \n"
+"#define sp $r0.12                                                          \n"
+"#define gp $r0.14                                                          \n"
+"                                                                           \n"
+"/*@HEADER_ENDS*/                                                           \n"
+"                                                                           \n"
+"/*@TESTS_BEGIN*/                                                           \n"
+"                                                                           \n"
+"/*@TESTS_END*/                                                             \n"
+"                                                                           \n"
+"/*@_init_PROLOG_BEGINS*/                                                   \n"
+"       .section .init, \"ax\", @progbits                                   \n"
+"	.align 32                                                           \n"
+"	.global _init                                                       \n"
+"_init:                                                                     \n"
+"       add     sp    = sp, -32                                             \n"
+"       ;;                                                                  \n"
+"       stw     16[sp] = $r0.63                                             \n"
+"       ;;                                                                  \n"
+"       stw     20[sp] = gp                                                 \n"
+"       ;;                                                                  \n"
+"       call    $r0.63 = 0f                                                 \n"
+"       ;;                                                                  \n"
+"0:                                                                         \n"
+"       add     gp = $r0.63, @neggprel(0b)                                  \n"
+"       ;;                                                                  \n"
+"	.weak	__gmon_start__                                              \n"
+"       ldw     $r0.63 = @gotoff(__gmon_start__)[gp]                        \n"
+"       ;;                                                                  \n"
+"       cmpeq   $b0.0  = $r0.63, 0                                          \n"
+"       ;;                                                                  \n"
+"       br      $b0.0, 1f                                                   \n"
+"       ;;                                                                  \n"
+"       call    $r0.63 = $r0.63                                             \n"
+"       ;;                                                                  \n"
+"1:                                                                         \n"
+"/*@_init_PROLOG_ENDS*/                                                     \n"
+"                                                                           \n"
+"/*@_init_EPILOG_BEGINS*/                                                   \n"
+"	.section .init                                                      \n"
+"       ldw     $r0.63 = 16[sp]                                             \n"
+"       ;;                                                                  \n"
+"       ldw     gp     = 20[sp]                                             \n"
+"       ;;                                                                  \n"
+"       add     sp     = sp, 32                                             \n"
+"       ;;                                                                  \n"
+"       goto    $r0.63                                                      \n"
+"       ;;                                                                  \n"
+"/*@_init_EPILOG_ENDS*/                                                     \n"
+"                                                                           \n"
+"/*@_fini_PROLOG_BEGINS*/                                                   \n"
+"	.section .fini, \"ax\", @progbits                                   \n"
+"	.align 32                                                           \n"
+"	.global _fini                                                       \n"
+"_fini:                                                                     \n"
+"       add     sp    = sp, -32                                             \n"
+"       ;;                                                                  \n"
+"       stw     16[sp] = $r0.63                                             \n"
+"       ;;                                                                  \n"
+"       stw     20[sp] = gp                                                 \n"
+"       ;;                                                                  \n"
+"       call    $r0.63 = 0f                                                 \n"
+"       ;;                                                                  \n"
+"0:                                                                         \n"
+"       add     gp = $r0.63, @neggprel(0b)                                  \n"
+"       ;;                                                                  \n"
+"                                                                           \n"
+"/*@_fini_PROLOG_ENDS*/                                                     \n"
+"	call    $r0.63 = i_am_not_a_leaf                                    \n"
+"	;;                                                                  \n"
+"                                                                           \n"
+"/*@_fini_EPILOG_BEGINS*/                                                   \n"
+"	.section .fini                                                      \n"
+"       ldw     $r0.63 = 16[sp]                                             \n"
+"       ;;                                                                  \n"
+"       ldw     gp     = 20[sp]                                             \n"
+"       ;;                                                                  \n"
+"       add     sp     = sp, 32                                             \n"
+"       ;;                                                                  \n"
+"       goto    $r0.63                                                      \n"
+"       ;;                                                                  \n"
+"                                                                           \n"
+"/*@_fini_EPILOG_ENDS*/                                                     \n"
+"                                                                           \n"
+"/*@TRAILER_BEGINS*/                                                        \n"
+);
+
--- glibc/sysdeps/st200/elf/start.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/elf/start.S	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,87 @@
+/* Startup code for ST200 and ELF.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#define sp $r0.12
+#define gp $r0.14
+	
+/* This is the canonical entry point, usually the first thing in the text
+   segment.
+
+	Note that the code in the .init section has already been run.
+	This includes _init and _libc_init
+
+	At this entry point, most registers' values are unspecified, except:
+
+   r16		Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   sp		The stack contains the arguments and environment:
+		0(sp)			argc
+		4(sp)			argv[0]
+		...
+		(4*argc)(sp)		NULL
+		(4*(argc+1))(sp)	envp[0]
+		...
+					NULL
+*/
+	.global _start
+
+	.proc
+	.type _start,@function
+_start:
+	/* Allocate scratch area for callees, preserve stack alignment */
+	add	sp  = sp, -32
+	call	$r0.63 = 0f
+	;;
+0:	add     gp = $r0.63, @neggprel(0b) /* Note that gprel(0b) is text-data calc. */
+	mov	$r0.21 = $r0.16    /* rtld_fini */	
+	;;
+	/* QQQ:	 Do we need to do anything for backtracing here? */
+	/* Call __libc_start_main(main, argc, argv, init, fini, rtld_fini,
+	                          stack_end) */
+
+	ldw	$r0.16 = @gotoff(main)[gp]
+	;;
+	ldw	$r0.17 = 32[sp]
+	add	$r0.18 = sp, 36
+	;;
+	ldw	$r0.19 = @gotoff(__libc_csu_init)[gp]
+	;;
+	ldw	$r0.20 = @gotoff(__libc_csu_fini)[gp]
+	/* r21 already contains rtld_fini */
+	add	$r0.22 = sp, 32
+	;;
+	call	$r0.63 = __libc_start_main
+	;; 
+	/* Die	horribly if we ever come back from here */
+	call	$r0.63 = abort
+	;;
+	.endp
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- glibc/sysdeps/st200/frame.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/frame.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,32 @@
+/* Definition of stack frame structure.  ST200 version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* ST200 compiler does not yet support the gcc builtins required for
+   backtrace.  So this is all stubbed out - backtracing is not
+   supported.
+*/
+
+struct layout
+{
+  void *__unbounded next;
+  void *__unbounded return_address;
+};
+
+#define FIRST_FRAME_POINTER (0)
+#define ADVANCE_STACK_FRAME(next) (0)
--- glibc/sysdeps/st200/Implies	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/Implies	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,3 @@
+wordsize-32
+ieee754/flt-32
+ieee754/dbl-64
--- glibc/sysdeps/st200/__init_trampoline.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/__init_trampoline.c	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,65 @@
+/* Nested function trampoline for ST200.
+   Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <string.h>
+
+static const int even_trampoline_template[] =
+  {
+    0x00009fc0, /* mov $r9 = $r63 */
+    0x08000fc0, /* mov $r63 = function & 0x1ff */
+    0x95000000, /* imml (function >> 9) & 0x7fffff ;; */
+    0x08000200, /* mov $r8 = context & 0x1ff */
+    0x95000000, /* imml (context >> 9) & 0x7fffff ;; */
+    0x31800000, /* goto $r63 */
+    0x8003f240  /* mov  $r63 = $r9 ;; */
+  };
+
+static void flush_data_cache(void *addr, int sz)
+{
+  __st220prgadd((int)addr, 0);
+  __st220prgadd((int)addr, 32);
+  __st220sync();
+}
+
+static void purge_instruction_cache(void *addr, int sz)
+{
+  __st220prgins();
+  /* No need for syncins, because the following bundle is
+     known to be good. */
+}
+
+void __init_trampoline (int *trampoline,
+			void *function,
+			void *context)
+{
+  trampoline[0] = even_trampoline_template[0];
+  trampoline[1] = even_trampoline_template[1]
+    | (((int)function) & 0x1ff) << 12;
+  trampoline[2] = even_trampoline_template[2]
+    | (((int)function) >> 9) & 0x7fffff;
+  trampoline[3] = even_trampoline_template[3]
+    | (((int)context) & 0x1ff) << 12;
+  trampoline[4] = even_trampoline_template[4]
+    | (((int)context) >> 9) & 0x7fffff;
+  memcpy(&trampoline[5], &even_trampoline_template[5],
+	 sizeof (even_trampoline_template)
+	 - (5 * sizeof(even_trampoline_template[0])));
+  flush_data_cache (trampoline, sizeof(even_trampoline_template));
+  purge_instruction_cache (trampoline, sizeof(even_trampoline_template));
+}
--- glibc/sysdeps/st200/__longjmp.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/__longjmp.S	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,54 @@
+/* longjmp for ST200.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sysdep.h>
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+/* __longjmp(jmpbuf, val) */
+
+ENTRY(__longjmp)
+	ldw	$r0.63 = _JB_LINK[$r0.16]
+	;;
+	ldw	$r0.12 = _JB_STACK_PTR[$r0.16]
+	;;
+	ldw	$r0.1 = _JB_PRE(0)[$r0.16]
+	;;
+	ldw	$r0.2 = _JB_PRE(1)[$r0.16]
+	;;
+	ldw	$r0.3 = _JB_PRE(2)[$r0.16]
+	;;
+	ldw	$r0.4 = _JB_PRE(3)[$r0.16]
+	;;
+	ldw	$r0.5 = _JB_PRE(4)[$r0.16]
+	;;
+	ldw	$r0.6 = _JB_PRE(5)[$r0.16]
+	;;
+	ldw	$r0.7 = _JB_PRE(6)[$r0.16]
+	;;
+	ldw	$r0.13 = _JB_PRE(7)[$r0.16]
+	;;
+	ldw	$r0.14 = _JB_PRE(8)[$r0.16]
+	;;
+	mov	$r0.16 = $r0.17
+	goto	$r0.63
+	;;
+END(__longjmp)
+	
+
--- glibc/sysdeps/st200/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/Makefile	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,10 @@
+ifeq ($(subdir), csu)
+CPPFLAGS-start.S = -D__ASSEMBLY__
+endif
+
+# [SC] st200 compiler does not support complex type
+no-complex-fcts = yes
+
+ifeq ($(subdir),gnulib)
+sysdep_routines += __init_trampoline
+endif
--- glibc/sysdeps/st200/memusage.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/memusage.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,21 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("r12"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
--- glibc-carl/sysdeps/st200/setjmp.S	2005-03-01 10:57:59.000000000 +0000
+++ glibc-clarkes/sysdeps/st200/setjmp.S	2005-07-19 13:30:51.000000000 +0100
@@ -0,0 +1,69 @@
+/* setjmp for ST200.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#define _SETJMP_H
+#include <sysdep.h>
+#include <bits/setjmp.h>	
+
+ENTRY(__sigsetjmp)
+$sigsetjmp_local:
+	stw	_JB_STACK_PTR[$r0.16] = $r0.12
+	;;
+	stw	_JB_LINK[$r0.16] = $r0.63
+	;;
+	stw	_JB_PRE(0)[$r0.16] = $r0.1
+	;;
+	stw	_JB_PRE(1)[$r0.16] = $r0.2
+	;;
+	stw	_JB_PRE(2)[$r0.16] = $r0.3
+	;;
+	stw	_JB_PRE(3)[$r0.16] = $r0.4
+	;;
+	stw	_JB_PRE(4)[$r0.16] = $r0.5
+	;;
+	stw	_JB_PRE(5)[$r0.16] = $r0.6
+	;;
+	stw	_JB_PRE(6)[$r0.16] = $r0.7
+	;;
+	stw	_JB_PRE(7)[$r0.16] = $r0.13
+	;;
+	stw	_JB_PRE(8)[$r0.16] = $r0.14
+	;;
+	goto	__sigjmp_save
+	;; 
+END(__sigsetjmp)
+
+/* Put these traditional entry points in the same file so that we can
+   elide much of the nonsense in trying to jmp to the real function.  */
+
+ENTRY(_setjmp)
+	mov	$r0.17 = 0
+	goto	$sigsetjmp_local
+	;;
+END(_setjmp)
+libc_hidden_def (_setjmp)
+
+ENTRY(setjmp)
+	mov	$r0.17 = 1
+	goto	$sigsetjmp_local
+	;;
+END(setjmp)
+
+weak_extern(_setjmp)
+weak_extern(setjmp)
--- glibc/sysdeps/st200/stackinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/stackinfo.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,28 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On ST200 the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
--- glibc/sysdeps/st200/sysdep.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/sysdep.h	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,55 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef __ASSEMBLER__
+
+#define ENTRY(name)				\
+	.text; 					\
+	.proc;                   		\
+	.global C_SYMBOL_NAME(name); 		\
+	C_LABEL(name)				\
+	CALL_MCOUNT
+
+#define LOCAL_ENTRY(name)			\
+	.text; 					\
+	.proc;                    		\
+	C_LABEL(name)				\
+	CALL_MCOUNT
+
+#define LEAF(name)				\
+  .text;  					\
+  .proc;                 			\
+  .global C_SYMBOL_NAME(name); 			\
+  C_LABEL(name)
+
+#define LOCAL_LEAF(name)			\
+  .text; 					\
+  .proc;                 			\
+  C_LABEL(name)                                 \
+
+/* Mark the end of function SYM.  */
+#define END(name)                                            \
+        .size  C_SYMBOL_NAME(name), . - C_SYMBOL_NAME(name); \
+       .endp
+
+/* Profile counting not yet supported */
+#define CALL_MCOUNT
+
+#include <sysdeps/generic/sysdep.h>
+
+#endif /* ASSEMBLER */
--- glibc/sysdeps/st200/Versions	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/st200/Versions	2005-03-01 10:57:59.000000000 +0000
@@ -0,0 +1,13 @@
+ld {
+  GLIBC_PRIVATE {
+    # st200 specific functions in the dynamic linker, but used by libc.so.
+    _dl_symbol_address; _dl_unmap; _dl_lookup_address;
+    _dl_function_address;
+  }
+}
+libc {
+  GLIBC_2.3 {
+    # Functions from libgcc.
+    __divdf3; __divsf3; __divdi3; __moddi3; __udivdi3; __umoddi3;
+  }
+}
--- glibc/sysdeps/unix/sysv/linux/configure	2004-07-06 05:13:42.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/configure	2005-03-01 10:57:53.000000000 +0000
@@ -142,6 +142,9 @@
     libc_cv_gcc_unwind_find_fde=yes
     arch_minimum_kernel=2.0.10
     ;;
+  st200*)
+    arch_minimum_kernel=2.5.55
+    ;;
   x86_64*)
     arch_minimum_kernel=2.4.0
     ;;
--- glibc/sysdeps/unix/sysv/linux/configure.in	2004-07-06 05:11:40.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/configure.in	2005-03-01 10:57:53.000000000 +0000
@@ -102,6 +102,9 @@
     libc_cv_gcc_unwind_find_fde=yes
     arch_minimum_kernel=2.0.10
     ;;
+  st200)
+    arch_minimum_kernel=2.5.55
+    ;;
   x86_64*)
     arch_minimum_kernel=2.4.0
     ;;
--- glibc/sysdeps/unix/sysv/linux/kernel-features.h	2004-08-16 00:33:02.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/kernel-features.h	2005-05-13 14:45:15.000000000 +0100
@@ -160,6 +160,16 @@
 # define __ASSUME_STAT64_SYSCALL	1
 #endif
 
+/*  ST200 kernel only existed from 2.6  */
+#if defined __st200__
+# define __ASSUME_IPC64			1
+# define __ASSUME_FCNTL64	        1
+# define __ASSUME_UTIMES		1
+# define __ASSUME_TRUNCATE64_SYSCALL	1
+# define __ASSUME_STAT64_SYSCALL	1
+//# define __ASSUME_CLONE_THREAD_FLAGS	1
+#endif
+
 /* The changed st_ino field appeared in 2.4.0-test6.  But we cannot
    distinguish this version from other 2.4.0 releases.  Therefore play
    save and assume it available is for 2.4.1 and up.  However, SH is lame,
@@ -171,7 +181,7 @@
 /* To support locking of large files a new fcntl() syscall was introduced
    in 2.4.0-test7.  We test for 2.4.1 for the earliest version we know
    the syscall is available.  */
-#if __LINUX_KERNEL_VERSION >= 132097 && (defined __i386__ || defined __sparc__)
+#if __LINUX_KERNEL_VERSION >= 132097 && (defined __i386__ || defined __sparc__ )
 # define __ASSUME_FCNTL64		1
 #endif
 
@@ -228,8 +238,8 @@
 # define __ASSUME_MMAP2_SYSCALL		1
 #endif
 
-/* Starting with 2.4.21 PowerPC implements the new prctl syscall.
-   This allows applications to get/set the Floating Point Exception Mode.  */
+/* Starting with 2.4.21 PowerPC implements the new prctl syscall. */
+/*   This allows applications to get/set the Floating Point Exception Mode.  */
 #if __LINUX_KERNEL_VERSION >= (132096+21) && defined __powerpc__
 # define __ASSUME_NEW_PRCTL_SYSCALL		1
 #endif
@@ -358,7 +368,7 @@
    forever.  For x86 it was introduced after 2.5.75, for x86-64 in
    2.6.0-test3.  */
 #if defined __alpha__ || defined __ia64__ || defined __hppa__ \
-    || defined __sparc__ \
+    || defined __sparc__ || defined __st200__ \
     || (__LINUX_KERNEL_VERSION > 132427 && defined __i386__) \
     || (__LINUX_KERNEL_VERSION > 132609 && defined __x86_64__) \
     || (__LINUX_KERNEL_VERSION >= 132609 && defined __sh__)
--- glibc/sysdeps/unix/sysv/linux/st200/bits/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/bits/atomic.h	2005-07-14 18:33:54.000000000 +0100
@@ -0,0 +1,206 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdint.h>
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+
+#define atomic_full_barrier()	__asm ("sync" ::: "memory")
+#define atomic_write_barrier()	__asm ("sync" ::: "memory")
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval)      \
+  (abort (), 0)
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval)     \
+  (abort (), 0)
+
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval)     \
+({			                                                \
+  __typeof (*(mem)) __st200_tmp;                                        \
+  __typeof (mem) __st200_memp = (mem);                                  \
+  						                        \
+  __asm__ __volatile__ (						\
+        "       call    $r63  = 1f                                   \n"\
+        "       ;;                                                   \n"\
+        "1:     ldw     %0    = 0[%1]                                \n"\
+        "       mov     $r62  = $r63                                 \n"\
+        "       or      $r12  = $r12, 1                              \n"\
+        "       ;;                                                   \n"\
+        "       cmpeq   $b0   = %0, %2                               \n"\
+        "       ;;                                                   \n"\
+        "       brf     $b0, 2f                                      \n"\
+        "       ;;                                                   \n"\
+        "       stw     0[%1] = %3                                   \n"\
+        "       and     $r12  = $r12, ~1                             \n"\
+        "       ;;                                                   \n"\
+        "2:     and     $r12  = $r12, ~1                             \n"\
+        : "=&r" (__st200_tmp)                                           \
+        : "r" (__st200_memp), "r" (oldval), "r" (newval)                \
+	: "b0","r62","r63","memory" );                                  \
+  __st200_tmp;                                                          \
+})
+
+# define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+  
+#define __arch_atomic_exchange_32_acq(mem, value)                       \
+({			                                                \
+  __typeof (*(mem)) __st200_val;                                        \
+  __typeof (mem) __st200_memp = (mem);                                  \
+  						                        \
+  __asm__ __volatile__ (						\
+        "       call    $r63  = 1f                                   \n"\
+        "       ;;                                                   \n"\
+        "1:     ldw     %0    = 0[%1]                                \n"\
+        "       mov     $r62  = $r63                                 \n"\
+        "       or      $r12  = $r12, 1                              \n"\
+        "       ;;                                                   \n"\
+        "       stw     0[%1] = %2                                   \n"\
+        "       and     $r12  = $r12, ~1                             \n"\
+        : "=&r" (__st200_val)                                           \
+        : "r" (__st200_memp), "r" (value)                               \
+	: "r62","r63","memory" );                                       \
+  __st200_val;                                                          \
+})
+
+#define atomic_exchange_acq(mem, value) \
+({                                                                     \
+  __typeof (*(mem)) __st200_result;                                    \
+  if (sizeof (*mem) == 4)                                              \
+    __st200_result = __arch_atomic_exchange_32_acq (mem, value);       \
+  else                                                                 \
+    abort ();                                                          \
+  __st200_result;                                                      \
+})
+
+#define __arch_atomic_exchange_and_add_32(mem, value)                   \
+({			                                                \
+  __typeof (*(mem)) __st200_val, __st200_tmp;                           \
+  __typeof (mem) __st200_memp = (mem);                                  \
+  						                        \
+  __asm__ __volatile__ (						\
+        "       call    $r63  = 1f                                   \n"\
+        "       ;;                                                   \n"\
+        "1:     ldw     %0    = 0[%2]                                \n"\
+        "       mov     $r62  = $r63                                 \n"\
+        "       or      $r12  = $r12, 1                              \n"\
+        "       ;;                                                   \n"\
+        "       add     %1    = %0, %3                               \n"\
+        "       ;;                                                   \n"\
+        "       stw     0[%2] = %1                                   \n"\
+        "       and     $r12  = $r12, ~1                             \n"\
+        : "=&r" (__st200_val), "=&r" (__st200_tmp)                      \
+        : "r" (__st200_memp), "r" (value)                               \
+	: "r62","r63","memory" );                                       \
+  __st200_val;                                                          \
+})
+
+#define atomic_exchange_and_add(mem, value) \
+  ({									      \
+    __typeof (*(mem)) __st200_result;					      \
+    if (sizeof (*mem) == 4)						      \
+      __st200_result = __arch_atomic_exchange_and_add_32 (mem, value);	      \
+    else 								      \
+       abort ();							      \
+    __st200_result;							      \
+  })
+
+#define __arch_atomic_decrement_if_positive_32(mem)                     \
+({			                                                \
+  __typeof (*(mem)) __st200_tmp, __st200_val;                           \
+  __typeof (mem) __st200_memp = (mem);                                  \
+  						                        \
+  __asm__ __volatile__ (						\
+        "       call    $r63  = 1f                                   \n"\
+        "       ;;                                                   \n"\
+        "1:     ldw     %0    = 0[%2]                                \n"\
+        "       mov     $r62  = $r63                                 \n"\
+        "       or      $r12  = $r12, 1                              \n"\
+        "       ;;                                                   \n"\
+        "       cmpgt   $b0   = %0, $r0                              \n"\
+        "       add     %1    = %0, -1                               \n"\
+        "       ;;                                                   \n"\
+        "       brf     $b0, 2f                                      \n"\
+        "       ;;                                                   \n"\
+        "       stw     0[%2] = %1                                   \n"\
+        "       and     $r12  = $r12, ~1                             \n"\
+        "       ;;                                                   \n"\
+        "2:     and     $r12  = $r12, ~1                             \n"\
+        : "=&r" (__st200_val), "=&r" (__st200_tmp)                      \
+        : "r" (__st200_memp)                                            \
+	: "b0","r62","r63","memory" );                                  \
+  __st200_val;                                                          \
+})
+
+/* Decrement *MEM if it is > 0, and return the old value.  */
+#define atomic_decrement_if_positive(mem) \
+  ({ __typeof (*(mem)) __st200_result;					      \
+    if (sizeof (*mem) == 4)						      \
+      __st200_result = __arch_atomic_decrement_if_positive_32 (mem);	      \
+    else								      \
+       abort ();							      \
+    __st200_result;							      \
+  })
+
+#define __arch_atomic_bit_test_set_32(mem, bit)                         \
+({			                                                \
+  __typeof (*(mem)) __st200_tmp, __st200_val;                           \
+  __typeof (mem) __st200_memp = (mem);                                  \
+  __typeof (*(mem)) __st200_mask = ((__typeof (*mem))1 << (bit));       \
+  						                        \
+  __asm__ __volatile__ (						\
+        "       call    $r63  = 1f                                   \n"\
+        "       ;;                                                   \n"\
+        "1:     ldw     %0    = 0[%2]                                \n"\
+        "       mov     $r62  = $r63                                 \n"\
+        "       or      $r12  = $r12, 1                              \n"\
+        "       ;;                                                   \n"\
+        "       or      %1    = %0, %3                               \n"\
+        "       and     %0    = %0, %3                               \n"\
+        "       ;;                                                   \n"\
+        "       stw     0[%2] = %1                                   \n"\
+        "       and     $r12  = $r12, ~1                             \n"\
+        : "=&r" (__st200_val), "=&r" (__st200_tmp)                      \
+        : "r" (__st200_memp), "r" (__st200_mask)                        \
+	: "r62","r63","memory" );                                       \
+  __st200_val;                                                          \
+})
+
+#define atomic_bit_test_set(mem, bit) \
+  ({ __typeof (*(mem)) __st200_result;					      \
+    if (sizeof (*mem) == 4)						      \
+      __st200_result = __arch_atomic_bit_test_set_32 (mem, bit);	      \
+    else								      \
+       abort ();							      \
+    __st200_result;							      \
+  })
+
--- glibc/sysdeps/unix/sysv/linux/st200/bits/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/bits/fcntl.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,180 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECT	 040000	/* Direct disk access.	*/
+# define O_DIRECTORY	0200000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0400000	/* Do not follow links.	 */
+# define O_STREAMING	04000000/* streaming access */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0100000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/bits/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/bits/mman.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,93 @@
+/* Definitions for POSIX memory map interface.  Linux/ST200 version.
+   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never include this file directly.  Use <sys/mman.h> instead"
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/bits/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/bits/sigcontext.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,25 @@
+/* Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#include <bits/sigstack.h>
+/* #include <bits/sigset.h> */
+#include <asm/sigcontext.h>
--- glibc/sysdeps/unix/sysv/linux/st200/bits/sigstack.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/bits/sigstack.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,59 @@
+/* sigstack, sigaltstack definitions.
+   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#ifndef _SIGSTACK_H
+#define _SIGSTACK_H	1
+
+/* Structure describing a signal stack (obsolete).  */
+struct sigstack
+  {
+    void *ss_sp;		/* Signal stack pointer.  */
+    int ss_onstack;		/* Nonzero if executing on this stack.  */
+  };
+
+
+/* Possible values for `ss_flags.'.  */
+enum
+{
+  SS_ONSTACK = 1,
+#define SS_ONSTACK	SS_ONSTACK
+  SS_DISABLE
+#define SS_DISABLE	SS_DISABLE
+};
+
+/* Minimum stack size for a signal handler.  */
+#define MINSIGSTKSZ	2048
+
+/* System default stack size.  */
+#define SIGSTKSZ	8192
+
+
+/* Alternate, preferred interface.  */
+typedef struct sigaltstack
+  {
+    void *ss_sp;
+    int ss_flags;
+    size_t ss_size;
+  } stack_t;
+
+#endif	/* bits/sigstack.h */
--- glibc/sysdeps/unix/sysv/linux/st200/brk.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/brk.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,44 @@
+/* brk system call for ST200 Linux.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+/* This must be initialized data because commons can't have aliases.  */
+void *__curbrk = 0;
+
+int
+__brk (void *addr)
+{
+  void *newbrk;
+
+  __curbrk = newbrk = (void *) INLINE_SYSCALL (brk, 1, addr);
+
+  if (newbrk < addr)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  return 0;
+}
+weak_alias (__brk, brk)
+
--- glibc/sysdeps/unix/sysv/linux/st200/clone.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/clone.S	2005-07-19 11:50:37.000000000 +0100
@@ -0,0 +1,100 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+/* 'cris' version allows (child_stack==NULL), which makes the kernel
+   allocate stack. Implementing that version, requires the syscall
+   returning saved registers to the new thread, since we have no
+   stack to store them. */
+
+#include <sysdep.h>
+#include <linux/linkage.h>
+#define _ERRNO_H        1
+#include <bits/errno.h>
+#include <asm/unistd.h>
+
+// int __clone(int (*fn)(void *), void *child_stack, int flags, void *arg,
+//             pid_t *ptid, void *tls, pid_t *ctid)
+
+ENTRY (__clone)
+	andl    $b0 = $r16, $r17   /* Test for NULL fn ptr or NULL stack ptr */
+	;;
+	brf	$b0, L?error_einval
+	add	$r17 = $r17, -32	/* speculate */
+	;; 
+
+	stw	24[$r17] = $r16	/* save user's function ... */
+	;;
+	// We have r18 = flags, r17 = usp, r20 = ptid, r22 = ctid, r21 = tls
+        // For the clone syscall we want
+	//  r16 = flags, r17 = usp, r18 = ptid, r19 = ctid, r20 = tls
+	// so shuffle registers for the syscall 
+	stw	20[$r17] = $r19	/* ... and arguments in the new stack */
+	mov	$r16 = $r18
+	mov	$r18 = $r20
+	mov	$r19 = $r22
+	;; 
+	mov	$r20 = $r21
+	DO_CALL(__NR_clone)
+	;;
+	br	$b0, L?error
+	cmpeq	$b0 = $r16, 0
+	;;
+	br	$b0, thread_start
+	;;
+	ret
+
+/* New thread execution latency can be decreased by loading lr in the bundle
+ * that follows syscall, no matter which is the sp value. But the code becomes
+ * less readable. Do it after debug. */
+/* Note: 16 byte scratch area already allocated by parent */
+thread_start:
+	ldw	$r63 = 24[$r12]	/* from the new thread's sp */
+	;;
+	ldw	$r16 = 20[$r12]
+	;;
+	call	$r63 = $r63		/* call the user's function */
+	;;
+L?1:
+#ifdef PIC
+	/* need to establish our GP so we can call _exit */
+	call $r63 = 0f
+	;;
+0:	add  $r14 = $r63, @neggprel(0b)
+	;;
+#endif /* PIC */
+	call	$r63 = _exit	/* r16 has the return value */
+	;; 
+	mov	$r16 = 1
+	goto	L?1
+	;;
+
+L?error_einval:
+	mov	$r16 = EINVAL
+	;;
+
+/* errno=r16; return -1; */
+L?error:
+	SYSCALL_ERROR_HANDLER
+	mov $r16 = -1
+	ret
+END(__clone)
+
+weak_alias(__clone, clone)
--- glibc/sysdeps/unix/sysv/linux/st200/Dist	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/Dist	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,6 @@
+kernel_termios.h
+kernel_stat.h
+kernel_sigaction.h
+clone.S
+syscall.S
+
--- glibc/sysdeps/unix/sysv/linux/st200/ftruncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/ftruncate64.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,80 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_ftruncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+extern int __have_no_truncate64;
+#endif
+
+/* The order of hight, low depends on endianness.  */
+extern int __syscall_ftruncate64 (int fd, int dummy, int high_length, int low_length);
+
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+__ftruncate64 (int fd, off64_t length)
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! __have_no_truncate64)
+#endif
+    {
+      unsigned int low = length & 0xffffffff;
+      unsigned int high = length >> 32;
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      /* On ST200, 64-bit arguments are aligned in even/odd register pairs. */
+      int result = INLINE_SYSCALL (ftruncate64, 4, fd, 0,
+				   __LONG_LONG_PAIR (high, low));
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      __have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return __ftruncate (fd, (off_t) length);
+#endif
+}
+weak_alias (__ftruncate64, ftruncate64)
+
+#else
+/* Use the generic implementation.  */
+# include <sysdeps/generic/ftruncate64.c>
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/ioctl.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,68 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdarg.h>
+#include <termios.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sysdep.h>
+#include <errno.h>
+
+/* The user-visible size of struct termios has changed.  Catch ioctl calls
+   using the new-style struct termios, and translate them to old-style.  */
+
+extern int __syscall_ioctl (int fd, unsigned long int request, ...);
+
+int
+__ioctl (int fd, unsigned long int request, ...)
+{
+  void *arg;
+  va_list ap;
+  int result;
+
+  va_start (ap, request);
+  arg = va_arg (ap, void *);
+
+  switch (request)
+    {
+    case TCGETS:
+      result = tcgetattr (fd, (struct termios *) arg);
+      break;
+
+    case TCSETS:
+      result = tcsetattr (fd, TCSANOW, (struct termios *) arg);
+      break;
+
+    case TCSETSW:
+      result = tcsetattr (fd, TCSADRAIN, (struct termios *) arg);
+      break;
+
+    case TCSETSF:
+      result = tcsetattr (fd, TCSAFLUSH, (struct termios *) arg);
+      break;
+
+    default:
+      result = INLINE_SYSCALL (ioctl, 3, fd, request, arg);
+      break;
+    }
+
+  va_end (ap);
+
+  return result;
+}
+weak_alias (__ioctl, ioctl)
--- glibc/sysdeps/unix/sysv/linux/st200/kernel_sigaction.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/kernel_sigaction.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,14 @@
+
+#undef HAVE_SA_RESTORER
+
+/* No definition of old_kernel_sigaction, because there is
+   no st200 linux kernel that does not have the rt sigactions,
+   so __ASSUME_REALTIME_SIGNALS is never 0.                       */
+
+/* This is the sigaction structure from the Linux 2.5.66 kernel.  */
+
+struct kernel_sigaction {
+	__sighandler_t k_sa_handler;
+	unsigned long sa_flags;
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
--- glibc/sysdeps/unix/sysv/linux/st200/kernel_stat.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/kernel_stat.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,26 @@
+/* definition of "struct stat" from the kernel, version 2.5.66. */
+/* The st_atim, st_mtim and st_ctim fields have
+   different types compared to the kernel version, but their
+   layout matches the kernel version.  This allows
+   the "linux generic" code in xconvstat.c to be used.  */
+
+struct kernel_stat {
+	unsigned long	st_dev;
+	unsigned long	st_ino;
+	unsigned long	st_nlink;
+	unsigned int	st_mode;
+	unsigned int	st_uid;
+	unsigned int	st_gid;
+	unsigned int	__pad0;
+	unsigned long	st_rdev;
+	unsigned long	st_size;
+        struct timespec st_atim;
+        struct timespec st_mtim;
+        struct timespec st_ctim;
+	unsigned long	st_blksize;
+	long		st_blocks;
+	unsigned long	__unused[3];
+};
+
+#define _HAVE_STAT_NSEC
+#define _HAVE_STAT64_NSEC
--- glibc/sysdeps/unix/sysv/linux/st200/kernel_termios.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/kernel_termios.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,48 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KERNEL_TERMIOS_H
+#define _KERNEL_TERMIOS_H 1
+/* The following corresponds to the values from the Linux 2.1.20 kernel.  */
+
+#define __KERNEL_NCCS 19
+#define _HAVE_C_ISPEED 1
+#define _HAVE_C_OSPEED 1
+
+struct __kernel_termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_line;		/* line discipline */
+    cc_t c_cc[__KERNEL_NCCS];	/* control characters */
+    speed_t c_ispeed;		/* input speed */
+    speed_t c_ospeed;		/* output speed */        
+  };
+
+#undef  TCGETS
+#undef  TCSETS
+#undef  TCSETSW
+#undef  TCSETSF
+#define TCGETS	_IOR ('t', 19, struct __kernel_termios)
+#define TCSETS	_IOW ('t', 20, struct __kernel_termios)
+#define TCSETSW	_IOW ('t', 21, struct __kernel_termios)
+#define TCSETSF	_IOW ('t', 22, struct __kernel_termios)
+
+#endif /* kernel_termios.h */
--- glibc/sysdeps/unix/sysv/linux/st200/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/mmap.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,41 @@
+/* mmap() code for st200
+   Copyright (C) 2003 by STMicroelectronics Limited
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+#include <sys/param.h>
+
+#define MMAP2_PAGE_SHIFT 12
+
+void *
+__mmap(void *addr, size_t len, int prot, int flags,
+     int fd, off_t offset)
+{
+  if (offset & ((1 << (MMAP2_PAGE_SHIFT + 1) ) - 1)) {
+    __set_errno (EINVAL);
+    return MAP_FAILED; 
+  }
+
+  return (void *) INLINE_SYSCALL (mmap, 6, addr, len, prot, flags, fd,
+				  offset >> MMAP2_PAGE_SHIFT);
+}
+
+weak_alias (__mmap, mmap)
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/pread64.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,97 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_pread64		/* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+extern ssize_t __syscall_pread (int fd, void *__unbounded buf, size_t count,
+				int dummy, off_t offset_hi, off_t offset_lo);
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread64 (int fd, void *buf, size_t count,
+				  off64_t offset) internal_function;
+# endif
+
+
+static ssize_t
+do_pread64 (int fd, void *buf, size_t count, off64_t offset)
+{
+  ssize_t result;
+
+  /* First try the syscall.  */
+  /* On ST200, 64-bit arguments are aligned in even/odd register pairs. */
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
+					     (off_t) (offset & 0xffffffff)));
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread64 (fd, buf, count, offset);
+# endif
+
+  return result;
+}
+
+
+ssize_t
+__libc_pread64 (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off64_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pread64 (fd, buf, count, offset);
+  {
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pread64 (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+}
+
+weak_alias (__libc_pread64, __pread64)
+weak_alias (__libc_pread64, pread64)
+
+# define __libc_pread64(fd, buf, count, offset) \
+     static internal_function __emulate_pread64 (fd, buf, count, offset)
+#endif
+
+# if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread64.c>
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/pread.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/pread.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,99 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_pread64		/* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pread
+#  error "__NR_pread and __NR_pread64 both defined???"
+# endif
+# define __NR_pread __NR_pread64
+#endif
+
+#if defined __NR_pread || __ASSUME_PREAD_SYSCALL > 0
+
+/* The order of hi, lo depends on endianness.  */
+extern ssize_t __syscall_pread (int fd, void *__unbounded buf, size_t count,
+				int dummy, off_t offset_hi, off_t offset_lo);
+
+# if __ASSUME_PREAD_SYSCALL == 0
+static ssize_t __emulate_pread (int fd, void *buf, size_t count,
+				off_t offset) internal_function;
+# endif
+
+
+static ssize_t
+do_pread (int fd, void *buf, size_t count, off_t offset)
+{
+  ssize_t result;
+
+  /* First try the syscall.  */
+  assert (sizeof (offset) == 4);
+  /* On ST200, 64-bit arguments are aligned in even/odd register pairs. */
+  result = INLINE_SYSCALL (pread, 6, fd, CHECK_N (buf, count), count,
+			   0, __LONG_LONG_PAIR (offset >> 31, offset));
+# if __ASSUME_PREAD_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pread (fd, buf, count, offset);
+# endif
+
+  return result;
+}
+
+
+ssize_t
+__libc_pread (fd, buf, count, offset)
+     int fd;
+     void *buf;
+     size_t count;
+     off_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pread (fd, buf, count, offset);
+  {
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pread (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+  }
+}
+
+strong_alias (__libc_pread, __pread)
+weak_alias (__libc_pread, pread)
+
+# define __libc_pread(fd, buf, count, offset) \
+     static internal_function __emulate_pread (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PREAD_SYSCALL == 0
+# include <sysdeps/posix/pread.c>
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/profil-counter.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/profil-counter.h	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,27 @@
+/* Machine-dependent SIGPROF signal handler.  IA-64 version.
+   Copyright (C) 1996, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* In many Unix systems signal handlers are called like this
+   and the interrupted PC is easily findable in the `struct sigcontext'.  */
+
+static void
+profil_counter (int signr, int code, struct sigcontext *scp)
+{
+  profil_count ((void *)scp->sc_regs.pc);
+}
--- glibc/sysdeps/unix/sysv/linux/st200/pwrite64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/pwrite64.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,98 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_pwrite64		/* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+extern ssize_t __syscall_pwrite (int fd, const void *__unbounded buf, size_t count,
+				 int dummy, off_t offset_hi, off_t offset_lo);
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite64 (int fd, const void *buf, size_t count,
+				   off64_t offset) internal_function;
+# endif
+
+
+static ssize_t
+do_pwrite64 (int fd, const void *buf, size_t count, off64_t offset)
+{
+  ssize_t result;
+
+  /* First try the syscall.  */
+  /* On ST200, 64-bit values are aligned in even/odd register pairs. */
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count, 0,
+			   __LONG_LONG_PAIR ((off_t) (offset >> 32),
+					     (off_t) (offset & 0xffffffff)));
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite64 (fd, buf, count, offset);
+# endif
+
+  return result;
+}
+
+
+ssize_t
+__libc_pwrite64 (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off64_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pwrite64 (fd, buf, count, offset);
+  {
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pwrite64 (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+}
+
+weak_alias (__libc_pwrite64, __pwrite64)
+libc_hidden_weak (__pwrite64)
+weak_alias (__libc_pwrite64, pwrite64)
+
+# define __libc_pwrite64(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite64 (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite64.c>
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/pwrite.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/pwrite.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,100 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_pwrite64		/* Newer kernels renamed but it's the same.  */
+# ifdef __NR_pwrite
+#  error "__NR_pwrite and __NR_pwrite64 both defined???"
+# endif
+# define __NR_pwrite __NR_pwrite64
+#endif
+
+#if defined __NR_pwrite || __ASSUME_PWRITE_SYSCALL > 0
+
+/* The order of hi, lo depends on endianness.  */
+extern ssize_t __syscall_pwrite (int fd, const void *__unbounded buf,
+				 size_t count, int dummy, off_t offset_hi,
+				 off_t offset_lo);
+
+# if __ASSUME_PWRITE_SYSCALL == 0
+static ssize_t __emulate_pwrite (int fd, const void *buf, size_t count,
+				 off_t offset) internal_function;
+# endif
+
+
+static ssize_t
+do_pwrite (int fd, const void *buf, size_t count, off_t offset)
+{
+  ssize_t result;
+
+  /* First try the syscall.  */
+  assert (sizeof (offset) == 4);
+  /* On ST200, 64-bit values are aligned in even/odd register pairs. */
+  result = INLINE_SYSCALL (pwrite, 6, fd, CHECK_N (buf, count), count,
+			   0, __LONG_LONG_PAIR (offset >> 31, offset));
+# if __ASSUME_PWRITE_SYSCALL == 0
+  if (result == -1 && errno == ENOSYS)
+    /* No system call available.  Use the emulation.  */
+    result = __emulate_pwrite (fd, buf, count, offset);
+# endif
+
+  return result;
+}
+
+
+ssize_t
+__libc_pwrite (fd, buf, count, offset)
+     int fd;
+     const void *buf;
+     size_t count;
+     off_t offset;
+{
+  if (SINGLE_THREAD_P)
+    return do_pwrite (fd, buf, count, offset);
+  {
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  ssize_t result = do_pwrite (fd, buf, count, offset);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+}
+
+strong_alias (__libc_pwrite, __pwrite)
+weak_alias (__libc_pwrite, pwrite)
+
+# define __libc_pwrite(fd, buf, count, offset) \
+     static internal_function __emulate_pwrite (fd, buf, count, offset)
+#endif
+
+#if __ASSUME_PWRITE_SYSCALL == 0
+# include <sysdeps/posix/pwrite.c>
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/socket.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/socket.S	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,10 @@
+#include <sysdep.h>
+
+	.global __socket
+PSEUDO(__socket, socket, 3)
+
+PSEUDO_END(__socket)
+
+#ifndef NO_WEAK_ALIAS
+weak_alias (__socket, socket)
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/sys/procfs.h	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/sys/procfs.h	2005-07-19 11:50:37.000000000 +0100
@@ -0,0 +1,118 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG	(sizeof(struct user_regs_struct) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct { } elf_fpregset_t;
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    __uid_t pr_uid;
+    __gid_t pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
--- glibc/sysdeps/unix/sysv/linux/st200/syscall.S	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/syscall.S	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,51 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <linux/linkage.h>	
+#include <sys/syscall.h>
+			
+	.text
+	.proc
+	.global C_SYMBOL_NAME(__syscall)
+C_LABEL(__syscall)	
+	CALL_MCOUNT
+/* The syscall number is in R16, should be in r15 */		
+/* This simply shuffles the args, and then invokes the syscall */
+	mov $r15 = $r16
+	mov $r16 = $r17
+	mov $r17 = $r18
+	mov $r18 = $r19
+	;;
+	mov $r19 = $r20
+	mov $r20 = $r21
+	mov $r21 = $r22
+	mov $r22 = $r23
+	;;
+	syscall 0	
+	;;
+	br	$b0, 1f
+	;;
+	ret
+1:
+	SYSCALL_ERROR_HANDLER
+	mov $r16 = -1
+	ret
+	.endp
+
+weak_alias (__syscall, syscall)
--- glibc/sysdeps/unix/sysv/linux/st200/syscalls.list	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/syscalls.list	2005-07-19 11:50:37.000000000 +0100
@@ -0,0 +1,40 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+umount2		-	umount		2	__umount2	umount2
+ptrace          -       ptrace          4       __ptrace        ptrace
+
+# semaphore and shm system calls
+msgctl		-	msgctl		i:iip	__msgctl	msgctl
+msgget		-	msgget		i:ii	__msgget	msgget
+msgrcv		-	msgrcv		Ci:ibnii __msgrcv	msgrcv
+msgsnd		-	msgsnd		Ci:ibni	__msgsnd	msgsnd
+shmat		-	shmat		i:ipi	__shmat		shmat
+shmctl		-	shmctl		i:iip	__shmctl	shmctl
+shmdt		-	shmdt		i:s	__shmdt		shmdt
+shmget		-	shmget		i:iii	__shmget	shmget
+semop		-	semop		i:ipi	__semop		semop
+semget		-	semget		i:iii	__semget	semget
+semctl		-	semctl		i:iiii	__semctl	semctl
+semtimedop      -       semtimedop      i:ipip  __semtimedop    semtimedop
+
+# proper socket implementations:
+accept		-	accept		Ci:iBN	__libc_accept	__accept accept
+bind		-	bind		i:ipi	__bind		bind
+connect		-	connect		Ci:ipi	__libc_connect	__connect_internal __connect connect 
+getpeername	-	getpeername	i:ipp	__getpeername	getpeername
+getsockname	-	getsockname	i:ipp	__getsockname	getsockname
+getsockopt	-	getsockopt	i:iiiBN	__getsockopt	getsockopt
+listen		-	listen		i:ii	__listen	listen
+recv		-	recv		Ci:ibni	__libc_recv	__recv recv
+recvfrom	-	recvfrom	Ci:ibniBN	__libc_recvfrom	__recvfrom recvfrom
+recvmsg		-	recvmsg		Ci:ipi	__libc_recvmsg	__recvmsg recvmsg
+send		-	send		Ci:ibni	__libc_send	__send send
+sendmsg		-	sendmsg		Ci:ipi	__libc_sendmsg	__sendmsg sendmsg
+sendto		-	sendto		Ci:ibnibn	__libc_sendto	__sendto sendto
+setsockopt	-	setsockopt	i:iiibn	__setsockopt	setsockopt
+shutdown	-	shutdown	i:ii	__shutdown	shutdown
+socket		-	socket		i:iii	__socket	socket
+socketpair	-	socketpair	i:iiif	__socketpair	socketpair
+
+setrlimit	-	setrlimit	i:ip	__setrlimit	setrlimit	
+getrlimit	-	getrlimit	i:ip	__getrlimit	getrlimit
--- glibc/sysdeps/unix/sysv/linux/st200/sysdep.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/sysdep.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,29 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+/* This routine is jumped to by all the syscall handlers, to stash
+   an error number into errno.  */
+int
+__syscall_error (int err_no)
+{
+  __set_errno (err_no);
+  return -1;
+}
--- glibc-clarkes/sysdeps/unix/sysv/linux/st200/sysdep.h	2005-07-18 15:08:41.000000000 +0100
+++ libc/sysdeps/unix/sysv/linux/st200/sysdep.h	2006-02-24 17:36:45.000000000 +0000
@@ -0,0 +1,254 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_ST200_SYSDEP_H
+#define _LINUX_ST200_SYSDEP_H 1
+
+#include <sysdeps/st200/sysdep.h>
+#include <sysdeps/unix/sysdep.h>
+
+#undef SYS_ify
+#define SYS_ify(syscall_name)	(__NR_##syscall_name)
+
+#ifdef __ASSEMBLER__
+
+/* ST200 syscalls return:
+     b0 = 0 for success, 1 for failure
+     r16 = result (or failure code on failure)
+     r17 = second result for those syscalls that have two results.
+*/
+
+#undef PSEUDO
+#define	PSEUDO(name, syscall_name, args)	\
+  ENTRY(name)					\
+    DO_CALL (SYS_ify(syscall_name))            ;\
+        ;;                                     ;\
+        br      $b0, 1f                        ;\
+        ;;                                     ;\
+        ret                                    ;\
+        ;;                                     ;\
+1:                                              \
+        SYSCALL_ERROR_HANDLER                  ;\
+        mov     $r16 = -1                      ;\
+        ;;
+
+#undef PSEUDO_END
+#define PSEUDO_END(name)	.endp
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+    ENTRY(name)					 \
+    DO_CALL (SYS_ify(syscall_name))             ;\
+        ;;
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name) .endp
+
+#define ret_NOERRNO ret
+
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+    ENTRY(name)					\
+    DO_CALL (SYS_ify(syscall_name))            ;\
+        ;;
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name)  .endp
+
+#define ret_ERRVAL ret
+
+#define DO_CALL(num)				\
+	mov $r15=num			       ;\
+        ;;                                     ;\
+	syscall 0
+
+#define ret return $r63                          ;\
+        ;;
+
+#ifndef PIC
+#define SYSCALL_ERROR_HANDLER \
+        goto    __syscall_error ;\
+        ;;
+#else
+# if defined _LIBC_REENTRANT
+#  if USE___THREAD
+#  error USE___THREAD not supported
+#  else
+/* Store r16 into location returned by __errno_location */
+/* Note GP (r14) needs to be set up before call to __errno_location
+   in case that call goes through the PLT. */
+#   define SYSCALL_ERROR_HANDLER                   \
+        add     $r12       = $r12, -32            ;\
+        stw     -16[$r12]  = $r63                 ;\
+        ;;                                        ;\
+        stw     20[$r12]   = $r1                  ;\
+	mov     $r1        = $r16                 ;\
+        call    $r63       = 1f                   ;\
+        ;;                                        ;\
+1:      stw     24[$r12]   = $r14                 ;\
+        add     $r14       = $r63, @neggprel(1b)  ;\
+        call    $r63       = __errno_location     ;\
+        ;;                                        ;\
+        ldw     $r63       = 16[$r12]             ;\
+        ;;                                        ;\
+        stw     0[$r16]    = $r1                  ;\
+        ;;                                        ;\
+        ldw     $r1        = 20[$r12]             ;\
+        ;;                                        ;\
+        ldw     $r14       = 24[$r12]             ;\
+	add     $r12       = $r12, 32
+#  endif /* USE___THREAD */
+# else
+/* Store r16 into errno.  */
+/* Need to set up GP so we can load the address of errno.
+   We can put the GP into a scratch register (r8) because
+   we are in a leaf routine, this avoids having to callee-save
+   r14.  However, we must save the old value of r63, because r63
+   is overwritten by the code to calculate the GP. */
+#   define SYSCALL_ERROR_HANDLER	            \
+        add     $r12       = $r12, -32             ;\
+        stw     -16[$r12]  = $r63                  ;\
+        call    $r63       = 1f                    ;\
+        ;;                                         ;\
+1:      add     $r8        = $r63, @neggprel(1b)   ;\
+        ;;                                         ;\
+        ldw     $r8        = @gotoff(errno)[$r8]   ;\
+        ;;                                         ;\
+        ldw     $r63       = 16[$r12]              ;\
+        ;;                                         ;\
+        stw     0[$r8]     = $r16                  ;\
+        add     $r12       = $r12, 32
+# endif	/* _LIBC_REENTRANT */
+#endif /* PIC */
+
+#else /* not __ASSEMBLER__ */
+
+#define ASMFMT_0
+#define ASMFMT_1 \
+	ASMFMT_0, "r" (r16)
+#define ASMFMT_2 \
+	ASMFMT_1, "r" (r17)
+#define ASMFMT_3 \
+	ASMFMT_2, "r" (r18)
+#define ASMFMT_4 \
+	ASMFMT_3, "r" (r19)
+#define ASMFMT_5 \
+	ASMFMT_4, "r" (r20)
+#define ASMFMT_6 \
+	ASMFMT_5, "r" (r21)
+#define ASMFMT_7 \
+	ASMFMT_6, "r" (r22)
+
+#define inline_syscall_clobbers                                         \
+                       "memory",                                        \
+                       "r8",  "r9",  "r10", "r11",                      \
+                                                                 "r23", \
+                       "r24", "r25", "r26", "r27", "r28", "r29", "r30", \
+                       "r31", "r32", "r33", "r34", "r35", "r36", "r37", \
+                       "r38", "r39", "r40", "r41", "r42", "r43", "r44", \
+                       "r45", "r46", "r47", "r48", "r49", "r50", "r51", \
+                       "r52", "r53", "r54", "r55", "r56", "r57", "r58", \
+                       "r59", "r60", "r61", "r62",                      \
+                       "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7"
+
+#define INLINE_SYSCALL_CLOBBERS_7 inline_syscall_clobbers
+#define INLINE_SYSCALL_CLOBBERS_6 \
+        INLINE_SYSCALL_CLOBBERS_7 , "r22"
+#define INLINE_SYSCALL_CLOBBERS_5 \
+        INLINE_SYSCALL_CLOBBERS_6 , "r21"
+#define INLINE_SYSCALL_CLOBBERS_4 \
+        INLINE_SYSCALL_CLOBBERS_5 , "r20"
+#define INLINE_SYSCALL_CLOBBERS_3 \
+        INLINE_SYSCALL_CLOBBERS_4 , "r19"
+#define INLINE_SYSCALL_CLOBBERS_2 \
+        INLINE_SYSCALL_CLOBBERS_3 , "r18"
+#define INLINE_SYSCALL_CLOBBERS_1 \
+        INLINE_SYSCALL_CLOBBERS_2 , "r17"
+#define INLINE_SYSCALL_CLOBBERS_0 \
+        INLINE_SYSCALL_CLOBBERS_1
+
+#define SUBSTITUTE_ARGS_0()
+#define SUBSTITUTE_ARGS_1(arg1)                                     \
+        register long r16 __asm__("r16") = (long)(arg1)
+
+#define SUBSTITUTE_ARGS_2(arg1, arg2)                               \
+        SUBSTITUTE_ARGS_1(arg1);                                    \
+        register long r17 __asm__("r17") = (long)(arg2)
+
+#define SUBSTITUTE_ARGS_3(arg1, arg2, arg3)                         \
+        SUBSTITUTE_ARGS_2(arg1, arg2);                              \
+        register long r18 __asm__("r18") = (long)(arg3)
+
+#define SUBSTITUTE_ARGS_4(arg1, arg2, arg3, arg4)                   \
+        SUBSTITUTE_ARGS_3(arg1, arg2, arg3);                        \
+        register long r19 __asm__("r19") = (long)(arg4)
+
+#define SUBSTITUTE_ARGS_5(arg1, arg2, arg3, arg4, arg5)             \
+        SUBSTITUTE_ARGS_4(arg1, arg2, arg3, arg4);                  \
+        register long r20 __asm__("r20") = (long)(arg5)
+
+#define SUBSTITUTE_ARGS_6(arg1, arg2, arg3, arg4, arg5, arg6)       \
+        SUBSTITUTE_ARGS_5(arg1, arg2, arg3, arg4, arg5);            \
+        register long r21 __asm__("r21") = (long)(arg6)
+
+#define SUBSTITUTE_ARGS_7(arg1, arg2, arg3, arg4, arg5, arg6, arg7) \
+        SUBSTITUTE_ARGS_6(arg1, arg2, arg3, arg4, arg5, arg6);      \
+        register long r22 __asm__("r22") = (long)(arg7)
+
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)                   \
+  ({                                                        \
+     INTERNAL_SYSCALL_DECL(err);                            \
+     int _retval;                                           \
+     _retval = INTERNAL_SYSCALL(name, err, nr, args);       \
+     if (INTERNAL_SYSCALL_ERROR_P(_ retval, err))           \
+       {                                                    \
+	 __set_errno (INTERNAL_SYSCALL_ERRNO(_retval, err)); \
+         _retval = -1;                                      \
+       }                                                    \
+    (int) _retval; })
+     
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) int err
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)           \
+  ({                                                        \
+    int resultvar;                                          \
+    register long r15 __asm__ ("r15") = SYS_ify (name);     \
+    SUBSTITUTE_ARGS_##nr(args);                             \
+    __asm__ volatile (                                      \
+      ";;                                               \n" \
+      "syscall 0                                        \n" \
+      ";;                                               \n" \
+      "mov     %0 = $r16                                \n" \
+      "mfb     %1 = $b0                                 \n" \
+      ";;                                               \n" \
+               : "=&r" (resultvar), "=&r" (err)             \
+               : "r"  (r15) ASMFMT_##nr                     \
+               : INLINE_SYSCALL_CLOBBERS_##nr);             \
+    (int) resultvar; })
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)      (err)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)	(val)
+
+#endif	/* __ASSEMBLER__ */
+
+#endif /* linux/st200/sysdep.h */
--- glibc/sysdeps/unix/sysv/linux/st200/truncate64.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/truncate64.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,80 @@
+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <endian.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <bp-checks.h>
+
+#include "kernel-features.h"
+
+#ifdef __NR_truncate64
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+/* The variable is shared between all wrappers around *truncate64 calls.  */
+int __have_no_truncate64;
+#endif
+
+/* The order of hight, low depends on endianness.  */
+extern int __syscall_truncate64 (const char *__unbounded path, int dummy,
+				 int high_length, int low_length);
+
+/* Truncate the file FD refers to to LENGTH bytes.  */
+int
+truncate64 (const char *path, off64_t length)
+{
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if (! __have_no_truncate64)
+#endif
+    {
+      unsigned int low = length & 0xffffffff;
+      unsigned int high = length >> 32;
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      int saved_errno = errno;
+#endif
+      /* On ST200, 64-bit arguments are aligned in even/odd register pairs. */
+      int result = INLINE_SYSCALL (truncate64, 4, CHECK_STRING (path),
+				   0, __LONG_LONG_PAIR (high, low));
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      if (result != -1 || errno != ENOSYS)
+#endif
+	return result;
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+      __set_errno (saved_errno);
+      __have_no_truncate64 = 1;
+#endif
+    }
+
+#ifndef __ASSUME_TRUNCATE64_SYSCALL
+  if ((off_t) length != length)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return truncate (path, (off_t) length);
+#endif
+}
+
+#else
+/* Use the generic implementation.  */
+# include <sysdeps/generic/truncate64.c>
+#endif
--- glibc/sysdeps/unix/sysv/linux/st200/umount.c	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/sysdeps/unix/sysv/linux/st200/umount.c	2005-03-01 10:57:53.000000000 +0000
@@ -0,0 +1,30 @@
+/* Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Since we don't have an old umount system call, do what the kernel
+   does down here.  */
+
+extern long int __umount2 (const char *name, int flags);
+
+long int
+__umount (const char *name)
+{
+  return __umount2 (name, 0);
+}
+
+weak_alias (__umount, umount);
--- glibc/configure	2004-08-26 23:13:22.000000000 +0100
+++ glibc-carl/configure	2005-11-09 15:30:40.000000000 +0000
@@ -1971,6 +1971,7 @@
 		base_machine=sparc machine=sparc/sparc64 ;;
 sparc64b | ultrasparc3)
 		base_machine=sparc machine=sparc/sparc64/sparcv9b ;;
+st2[0-9][0-9])	base_machine=st200 machine=st200/$machine ;;
 thumb*)		base_machine=thumb machine=arm/thumb/$machine ;;
 *)		base_machine=$machine ;;
 esac
@@ -4083,10 +4084,19 @@
 echo $ECHO_N "checking version of $CC... $ECHO_C" >&6
   ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*version \([egcygnustpi-]*[0-9.]*\).*$/\1/p'`
   case $ac_prog_version in
-    '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
+    '') ac_prog_version=`$CC -v 2>&1 | sed -n 's/^.*Version \([egcygnustpi-]*[0-9.]*\).*$/\1/p'`
+	case $ac_prog_version in
+	'') ac_prog_version="v. ?.??, bad"; ac_verc_fail=no;;
+	'1.0') ac_prog_version="$ac_prog_version, ok (for st200)"; ac_verc_fail=no;;
+	esac;;
     3.[2-9]*)
        ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
-    *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
+    2.95.2) ac_prog_version=`$CC -v 2>&1 | grep Pro64`
+	case $ac_prog_version in
+	'') ac_prog_version="v. ?.??, bad"; ac_verc_fail=no;;
+	*) ac_prog_version="$ac_prog_version, ok (for st200)"; ac_verc_fail=no;;
+	esac;;	       
+    *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=no;;
 
   esac
   echo "$as_me:$LINENO: result: $ac_prog_version" >&5
@@ -6242,6 +6252,9 @@
   no_whole_archive=-Wl,--no-whole-archive
 fi
 
+# XXX CRS - open64 does not fail this test, so we need to force exceptions off XXX
+libc_cv_gcc_exceptions=no
+
 echo "$as_me:$LINENO: checking for gcc -fexceptions" >&5
 echo $ECHO_N "checking for gcc -fexceptions... $ECHO_C" >&6
 if test "${libc_cv_gcc_exceptions+set}" = set; then
--- glibc/include/libc-symbols.h	2004-05-03 23:38:21.000000000 +0100
+++ glibc-carl/include/libc-symbols.h	2005-03-01 10:57:28.000000000 +0000
@@ -216,7 +216,7 @@
 
 /* Determine the return address.  */
 #define RETURN_ADDRESS(nr) \
-  __builtin_extract_return_addr (__builtin_return_address (nr))
+  __builtin_return_address (nr)
 
 /* When a reference to SYMBOL is encountered, the linker will emit a
    warning message MSG.  */
@@ -249,6 +249,7 @@
 #  define libc_freeres_ptr(decl) \
   __make_section_unallocated ("__libc_freeres_ptrs, \"aw\", %nobits") \
   decl __attribute__ ((section ("__libc_freeres_ptrs" __sec_comment)))
+/*  decl __attribute__ ((section ("__libc_freeres_ptrs, \"aw\", @nobits" __sec_comment))) */
 #  define __libc_freeres_fn_section \
   __attribute__ ((section ("__libc_freeres_fn")))
 # else /* Not ELF: a.out */
--- glibc/configure.in	2004-08-26 23:13:24.000000000 +0100
+++ glibc-carl/configure.in	2005-03-01 10:57:25.000000000 +0000
@@ -475,6 +475,7 @@
 		base_machine=sparc machine=sparc/sparc64 ;;
 sparc64b | ultrasparc3)
 		base_machine=sparc machine=sparc/sparc64/sparcv9b ;;
+st2[0-9][0-9])	base_machine=st200 machine=st200/$machine ;;
 thumb*)		base_machine=thumb machine=arm/thumb/$machine ;;
 *)		base_machine=$machine ;;
 esac
@@ -1719,6 +1720,9 @@
 fi
 AC_SUBST(no_whole_archive)dnl
 
+# XXX CRS force exceptions off as open64 will not fail this test XXX
+libc_cv_gcc_exceptions=no
+
 AC_CACHE_CHECK(for gcc -fexceptions, libc_cv_gcc_exceptions, [dnl
 cat > conftest.c <<\EOF
 _start () {}
--- glibc/intl/translit.po	2000-11-02 03:09:48.000000000 +0000
+++ glibc-carl/intl/translit.po	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-msgid ""
-msgstr ""
-"Content-Type: text/plain; charset=ISO-8859-1\n"
-
-msgid "test"
-msgstr ""
-
-msgid "onemore"
-msgstr "*="
--- glibc/intl/tstcodeset.po	2001-04-10 00:32:36.000000000 +0100
+++ glibc-carl/intl/tstcodeset.po	1970-01-01 01:00:00.000000000 +0100
@@ -1,8 +0,0 @@
-msgid ""
-msgstr ""
-"MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=ISO-8859-1\n"
-"Content-Transfer-Encoding: 8-bit\n"
-
-msgid "cheese"
-msgstr "Kse"
--- glibc/intl/tstlang1.po	2000-10-31 03:08:28.000000000 +0000
+++ glibc-carl/intl/tstlang1.po	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-msgid ""
-msgstr ""
-"MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=US-ASCII\n"
-"Content-Transfer-Encoding: 7-bit\n"
-
-#: tst-gettext2.c:33
-msgid "First string for testing."
-msgstr "Lang1: 1st string"
-
-#: tst-gettext2.c:34
-msgid "Another string for testing."
-msgstr "Lang1: 2nd string"
--- glibc/intl/tstlang2.po	2000-10-31 03:08:28.000000000 +0000
+++ glibc-carl/intl/tstlang2.po	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-msgid ""
-msgstr ""
-"MIME-Version: 1.0\n"
-"Content-Type: text/plain; charset=US-ASCII\n"
-"Content-Transfer-Encoding: 7-bit\n"
-
-#: tst-gettext2.c:33
-msgid "First string for testing."
-msgstr "Lang2: 1st string"
-
-#: tst-gettext2.c:34
-msgid "Another string for testing."
-msgstr "Lang2: 2nd string"
--- glibc/linuxthreads/ChangeLog.ST	1970-01-01 01:00:00.000000000 +0100
+++ glibc-carl/linuxthreads/ChangeLog.ST	2005-03-01 10:57:30.000000000 +0000
@@ -0,0 +1,18 @@
+2003-05-30  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/unix/sysv/linux/st200/fork.h : New file.
+	* sysdeps/unix/sysv/linux/st200/jmp-unwind.c: New file.
+	* sysdeps/unix/sysv/linux/st200/sysdep-cancel.h: New file.
+	* sysdeps/st200/pspinlock.c: New file.
+	* sysdeps/st200/pt-machine.h: New file.
+	* pthread.c (__pthread_initial_thread): Remove designated
+	initializer that fails to compile.
+	* spinlock.c (__pthread_release): Remove __asm with memory
+	constraint that fails to compile.
+	* sysdeps/unix/sysv/linux/unregister-atfork.c (__unregister_atfork):
+	Braces for declarations within statements.
+
+2003-07-30  Stephen Clarke <stephen.clarke@st.com>
+
+	* sysdeps/unix/sysv/linux/st200/pt-initfini.c: New file.
+
--- glibc-carl/math/math.h	2005-03-01 10:57:35.000000000 +0000
+++ glibc-clarkes/math/math.h	2005-08-05 12:15:26.000000000 +0100
@@ -362,7 +362,7 @@
 # define __NO_MATH_INLINES	1
 #endif
 
-#if __USE_ISOC99 && __GNUC_PREREQ(2,97)
+#if __USE_ISOC99 && __GNUC_PREREQ(2,97) && ! __ST200__
 /* ISO C99 defines some macros to compare number while taking care for
    unordered numbers.  Many FPUs provide special instructions to support
    these operations.  Generic support in GCC for these as builtins went
--- /dev/null	2003-09-15 14:02:32.000000000 +0100
+++ libc/sysdeps/unix/sysv/linux/st200/getpgrp.c	2006-04-24 14:52:04.000000000 +0100
@@ -0,0 +1 @@
+#include <sysdeps/generic/getpgrp.c>
