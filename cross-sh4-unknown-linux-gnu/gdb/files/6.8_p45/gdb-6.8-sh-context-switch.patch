Identify Linux kernel context switch stack frames, and do special things to
make backtrace work.

Signed-off-by: Chris Smith <chris.smith@st.com>

Index: gdb-6.8/gdb/annotate.c
===================================================================
--- gdb-6.8.orig/gdb/annotate.c	2008-09-18 13:34:47.000000000 +0100
+++ gdb-6.8/gdb/annotate.c	2008-09-18 13:37:17.000000000 +0100
@@ -451,6 +451,13 @@
 }
 
 void
+annotate_context_entry (void)
+{
+  if (annotation_level == 2)
+    printf_filtered ("\n\032\032context-switch\n");
+}
+
+void
 annotate_frame_address (void)
 {
   if (annotation_level == 2)
Index: gdb-6.8/gdb/annotate.h
===================================================================
--- gdb-6.8.orig/gdb/annotate.h	2008-09-18 13:34:47.000000000 +0100
+++ gdb-6.8/gdb/annotate.h	2008-09-18 13:37:17.000000000 +0100
@@ -79,6 +79,7 @@
 extern void annotate_frame_begin (int, CORE_ADDR);
 extern void annotate_function_call (void);
 extern void annotate_signal_handler_caller (void);
+extern void annotate_context_entry (void);
 extern void annotate_frame_address (void);
 extern void annotate_frame_address_end (void);
 extern void annotate_frame_function_name (void);
Index: gdb-6.8/gdb/frame.h
===================================================================
--- gdb-6.8.orig/gdb/frame.h	2008-09-18 13:34:47.000000000 +0100
+++ gdb-6.8/gdb/frame.h	2008-09-18 13:37:17.000000000 +0100
@@ -200,7 +200,10 @@
   SIGTRAMP_FRAME,
   /* Sentinel or registers frame.  This frame obtains register values
      direct from the inferior's registers.  */
-  SENTINEL_FRAME
+  SENTINEL_FRAME,
+  /* Kernel context switch frame. Shouldn't be printed in info threads
+   * listing. */
+  CONTEXT_FRAME
 };
 
 /* For every stopped thread, GDB tracks two frames: current and
Index: gdb-6.8/gdb/linux-tdep.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gdb-6.8/gdb/linux-tdep.c	2008-09-18 15:28:40.000000000 +0100
@@ -0,0 +1,125 @@
+/* Target-dependent code for Linux kernel.
+
+   Copyright 2004 LinSysSoft Technologies Pvt. Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "frame.h"
+#include "gdbarch.h"
+#include "frame-unwind.h"
+#include "gdb_assert.h"
+#include "symtab.h"
+#include "objfiles.h"
+#include "linux-tdep.h"
+
+/* Identifier for a context frame is composed of simply the sp and pc derived
+ * from next frame, which is a sentinel frame */
+static void
+linux_context_frame_this_id (struct frame_info *next_frame, void **this_cache,
+		      struct frame_id *this_id)
+{
+  int optimized;
+  enum lval_type lvalp;
+  CORE_ADDR addr;
+  int realnum;
+  gdb_byte spaddr;
+  struct minimal_symbol *s;
+  struct frame_data *unwind_data = linux_context_frame_unwinder.unwind_data;
+
+  frame_register_unwind(next_frame, gdbarch_sp_regnum(current_gdbarch), &optimized, &lvalp, &addr,
+			&realnum, &spaddr);
+  spaddr += unwind_data->spshift;
+  s = lookup_minimal_symbol("__switch_to_begin", NULL, symfile_objfile);
+  (*this_id) = frame_id_build(spaddr, SYMBOL_VALUE_ADDRESS(s));
+}
+
+/*
+ * The pc of the frame previous to a context frame is reported at the
+ * instruction just past the last instruction of switch_to kernel macro. The
+ * sp may also need some adjustments because the switch_to macro may contain
+ * code that changes sp
+ */
+static void
+linux_context_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+			    int regnum, int *optimizedp,
+			    enum lval_type *lvalp, CORE_ADDR *addrp,
+			    int *realnump, gdb_byte *valuep)
+{
+  struct minimal_symbol *s;
+  struct frame_data *unwind_data = linux_context_frame_unwinder.unwind_data;
+  frame_register_unwind(next_frame, regnum, optimizedp, lvalp, addrp,
+			realnump, valuep);
+  if (regnum == gdbarch_pc_regnum(current_gdbarch))
+    {
+      *addrp = 0;
+      s = lookup_minimal_symbol("__switch_to_end", NULL, symfile_objfile);
+      (*(CORE_ADDR*)valuep) = SYMBOL_VALUE_ADDRESS(s);
+    }
+  else if (regnum == gdbarch_sp_regnum(current_gdbarch))
+    {
+      *addrp = 0;
+      if (valuep)
+	(*(CORE_ADDR*)valuep) += unwind_data->spshift;
+    }
+}
+
+/* If pc is in the section .sched.text and if the next frame is a sentinel
+ * frame, it has to be a context switch call frame */
+static int
+linux_context_frame_sniffer (const struct frame_unwind *self,
+			 struct frame_info *next_frame,
+			 void **this_prologue_cache)
+{
+  CORE_ADDR pc;
+  struct minimal_symbol *s;
+
+  extern int debugkernel;
+  if (!debugkernel)
+      return 0;
+
+  if (get_frame_type(next_frame) == SENTINEL_FRAME)
+    {
+      pc = frame_pc_unwind(next_frame);
+      s = lookup_minimal_symbol("__switch_to_begin", NULL, symfile_objfile);
+      if (!s || pc < SYMBOL_VALUE_ADDRESS(s))
+	return 0;
+      s = lookup_minimal_symbol("__switch_to_end", NULL, symfile_objfile);
+      if (!s || pc >= SYMBOL_VALUE_ADDRESS(s))
+	return 0;
+      return 1;
+    }
+  return 0;
+}
+
+static struct frame_data linux_context_unwind_data;
+
+const struct frame_unwind linux_context_frame_unwinder =
+{
+  CONTEXT_FRAME,
+  linux_context_frame_this_id,
+  linux_context_frame_prev_register,
+  &linux_context_unwind_data,
+  linux_context_frame_sniffer
+};
+
+/* Provide a prototype to silence -Wmissing-prototypes.  */
+extern void _initialize_linux_tdep (void);
+
+void
+_initialize_linux_tdep (void)
+{
+}
Index: gdb-6.8/gdb/linux-tdep.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gdb-6.8/gdb/linux-tdep.h	2008-09-18 15:17:24.000000000 +0100
@@ -0,0 +1,38 @@
+/* Target-dependent code for Linux kernel.
+
+   Copyright 2004 LinSysSoft Technologies Pvt. Ltd.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef LINUX_TDEP_H
+#define LINUX_TDEP_H
+
+/* CONTEXT_FRAME unwind data */
+struct frame_data
+{
+	/* These two fields record the difference between pc and sp of context
+	 * and the previous frame (the schedule kernel function)
+	 * We use these fields and the pc and sp of the frame next to the
+	 * context frame (sentinel frame) to figure out the pc and sp of the
+	 * schedule function frame.
+	 */
+	int pcshift;
+	int spshift;
+};
+
+extern const struct frame_unwind linux_context_frame_unwinder;
+
+#endif /* #ifndef LINUX_TDEP_H */
Index: gdb-6.8/gdb/sh-linux-tdep.c
===================================================================
--- gdb-6.8.orig/gdb/sh-linux-tdep.c	2008-09-18 13:34:49.000000000 +0100
+++ gdb-6.8/gdb/sh-linux-tdep.c	2008-09-18 15:28:26.000000000 +0100
@@ -32,6 +32,7 @@
 #include "solib-svr4.h"
 #include "osabi.h"
 #include "symtab.h"
+#include "linux-tdep.h"
 
 #include "sh-tdep.h"
 #include "glibc-tdep.h"
@@ -318,6 +319,7 @@
                    struct gdbarch *gdbarch)
 {
   int i;
+  struct frame_data *unwind_data;
 
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
@@ -331,6 +333,12 @@
   set_gdbarch_register_name (gdbarch, sh_linux_register_name);
 
   frame_unwind_append_sniffer (gdbarch, sh_linux_sigtramp_frame_sniffer);
+
+  unwind_data = linux_context_frame_unwinder.unwind_data;
+  /* From kernel/include/asm-sh/system.h  */
+  unwind_data->pcshift = 0;
+  unwind_data->spshift = 9*4;
+  frame_unwind_prepend_unwinder (gdbarch, &linux_context_frame_unwinder);
 }
 
 void
Index: gdb-6.8/gdb/stack.c
===================================================================
--- gdb-6.8.orig/gdb/stack.c	2008-09-18 13:34:47.000000000 +0100
+++ gdb-6.8/gdb/stack.c	2008-09-18 15:27:26.000000000 +0100
@@ -5,6 +5,8 @@
    Free Software Foundation, Inc.
    Copyright (C) 2008 STMicroelectronics
 
+   Copyright 2004 LinSysSoft Technologies Pvt. Ltd.
+
    This file is part of GDB.
 
    This program is free software; you can redistribute it and/or modify
@@ -44,6 +46,7 @@
 #include "regcache.h"
 #include "solib.h"
 #include "valprint.h"
+#include "objfiles.h"
 
 #include "gdb_assert.h"
 #include <ctype.h>
@@ -467,9 +470,14 @@
   struct symtab_and_line sal;
   int source_print;
   int location_print;
+  CORE_ADDR pc;
+  struct frame_id fid;
+  struct minimal_symbol *schedbegin;
+  struct minimal_symbol *schedend;
 
   if (get_frame_type (frame) == DUMMY_FRAME
-      || get_frame_type (frame) == SIGTRAMP_FRAME)
+      || get_frame_type (frame) == SIGTRAMP_FRAME
+      || (get_frame_type (frame) == CONTEXT_FRAME && print_level != 0))
     {
       struct cleanup *uiout_cleanup
 	= make_cleanup_ui_out_tuple_begin_end (uiout, "frame");
@@ -502,6 +510,12 @@
 	  annotate_signal_handler_caller ();
           ui_out_field_string (uiout, "func", "<signal handler called>");
         }
+      else if (get_frame_type (frame) == CONTEXT_FRAME)
+        {
+	  annotate_context_entry ();
+	  ui_out_field_string (uiout, "func", "<context switch>");
+        }
+
       ui_out_text (uiout, "\n");
       annotate_frame_end ();
 
@@ -509,6 +523,28 @@
       return;
     }
 
+    /* Don't print context switch and scheduler frames if we are at level 0.  */
+    if (get_frame_type (frame) == CONTEXT_FRAME)
+      {
+        schedbegin = lookup_minimal_symbol("__sched_text_start", NULL,
+                                         symfile_objfile);
+        schedend = lookup_minimal_symbol("__sched_text_end", NULL,
+                                       symfile_objfile);
+        if (schedbegin && schedend)
+        while ((frame = get_prev_frame(frame)) != NULL)
+          {
+            fid = get_frame_id(frame);
+            pc = 0;
+            if (!fid.code_addr_p)
+              break;
+            pc = get_frame_id(frame).code_addr;
+             if (SYMBOL_VALUE_ADDRESS(schedbegin) >= pc)
+              break;
+            if (SYMBOL_VALUE_ADDRESS(schedend) <= pc)
+              break;
+          }
+      }
+
   /* If FRAME is not the innermost frame, that normally means that
      FRAME->pc points to *after* the call instruction, and we want to
      get the line containing the call, never the next line.  But if
Index: gdb-6.8/gdb/configure.tgt
===================================================================
--- gdb-6.8.orig/gdb/configure.tgt	2008-09-18 13:36:08.000000000 +0100
+++ gdb-6.8/gdb/configure.tgt	2008-09-18 15:27:26.000000000 +0100
@@ -371,7 +371,8 @@
 sh*-*-linux*)
 	# Target: GNU/Linux Super-H
 	gdb_target_obs="sh-tdep.o sh64-tdep.o sh-linux-tdep.o monitor.o \
-			dsrec.o shtdi.o solib.o solib-svr4.o symfile-mem.o"
+			dsrec.o shtdi.o solib.o solib-svr4.o symfile-mem.o \
+			linux-tdep.o"
 	gdb_sim=
 	build_gdbserver=yes
 	;;
Index: gdb-6.8/gdb/frame-unwind.h
===================================================================
--- gdb-6.8.orig/gdb/frame-unwind.h	2008-09-11 10:35:35.000000000 +0100
+++ gdb-6.8/gdb/frame-unwind.h	2008-09-18 15:28:20.000000000 +0100
@@ -137,7 +137,7 @@
      here?  */
   frame_this_id_ftype *this_id;
   frame_prev_register_ftype *prev_register;
-  const struct frame_data *unwind_data;
+  struct frame_data *unwind_data;
   frame_sniffer_ftype *sniffer;
   frame_prev_pc_ftype *prev_pc;
   frame_dealloc_cache_ftype *dealloc_cache;
