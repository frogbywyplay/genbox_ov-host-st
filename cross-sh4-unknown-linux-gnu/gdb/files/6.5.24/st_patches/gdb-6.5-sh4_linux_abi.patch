Index: gdb-6.5/gdb/sh-linux-tdep.c
===================================================================
--- gdb-6.5.orig/gdb/sh-linux-tdep.c	2005-12-17 22:34:02.000000000 +0000
+++ gdb-6.5/gdb/sh-linux-tdep.c	2007-09-18 16:59:42.000000000 +0100
@@ -1,6 +1,5 @@
-/* Target-dependent code for GNU/Linux Super-H.
-
-   Copyright (C) 2005 Free Software Foundation, Inc.
+/* GNU/Linux on SuperH target support.
+   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
    This file is part of GDB.
 
@@ -19,24 +18,325 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
+#include <string.h>
+
 #include "defs.h"
+#include "target.h"
+#include "value.h"
+#include "gdbtypes.h"
+#include "floatformat.h"
+#include "gdbcore.h"
+#include "gdb_assert.h"
+#include "frame.h"
+#include "frame-unwind.h"
+#include "regcache.h"
+#include "doublest.h"
+#include "solib-svr4.h"
+#include "symtab.h"
 #include "osabi.h"
 
-#include "solib-svr4.h"
+#include "sh-tdep.h"
+#include "glibc-tdep.h"
+
+/* Signal trampolines */
+
+/* Instructions used in signal trampolines */
+/* TODO: these should be in natural order and extracted from a buffer using extract_unsigned_int() */
+#define MOVW(n)	 ((n)-2), 0x93		/* Move mem word at PC+n to R3 */
+#define TRAP16	 0x10, 0xc3		/* Syscall w/no args (NR in R3) */
+#define OR_R0_R0 0x0b, 0x20		/* or r0,r0 (insert to avoid hardware bug) */
+#define SH__NR_sigreturn 0x77, 0x00     /* __NR_sigreturn 119 */
+#define SH__NR_rt_sigreturn 0xad, 0x00  /* __NR_rt_sigreturn 173 */
+
+static const unsigned char sh_linux_sigtramp_code[] =
+{
+  MOVW(7),
+  TRAP16,
+  OR_R0_R0,
+  OR_R0_R0,
+  OR_R0_R0,
+  OR_R0_R0,
+  OR_R0_R0,
+  SH__NR_sigreturn
+};
+#define SH_LINUX_SIGTRAMP_LEN (sizeof(sh_linux_sigtramp_code))
+
+static CORE_ADDR
+sh_linux_sigtramp_start (struct frame_info *next_frame)
+{
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+  unsigned char buf[SH_LINUX_SIGTRAMP_LEN];
+
+  /* We only recognize a signal trampoline if PC is at the start of
+     the first two instructions.  */
+
+  if (!safe_frame_unwind_memory (next_frame, pc, buf, SH_LINUX_SIGTRAMP_LEN))
+    return 0;
+    
+  if (0 == memcmp(buf, sh_linux_sigtramp_code+2, 2))
+    {
+      pc -= 2;
+      if (!safe_frame_unwind_memory (next_frame, pc, buf, SH_LINUX_SIGTRAMP_LEN))
+        return 0;
+    }
+
+  if (memcmp (buf, sh_linux_sigtramp_code, SH_LINUX_SIGTRAMP_LEN) != 0)
+    return 0;
+
+  return pc;
+}
+
+static const unsigned char sh_linux_rt_sigtramp_code[] =
+{
+  MOVW(7),
+  TRAP16,
+  OR_R0_R0,
+  OR_R0_R0,
+  OR_R0_R0,
+  OR_R0_R0,
+  OR_R0_R0,
+  SH__NR_rt_sigreturn
+};
+#define SH_LINUX_RT_SIGTRAMP_LEN (sizeof(sh_linux_sigtramp_code))
+
+static CORE_ADDR
+sh_linux_rt_sigtramp_start (struct frame_info *next_frame)
+{
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+  unsigned char buf[SH_LINUX_RT_SIGTRAMP_LEN];
+
+  /* We only recognize a signal trampoline if PC is at the start of
+     the first two instructions.  */
+
+  if (!safe_frame_unwind_memory (next_frame, pc, buf, SH_LINUX_RT_SIGTRAMP_LEN))
+    return 0;
+    
+  if (0 == memcmp(buf, sh_linux_rt_sigtramp_code+2, 2))
+    {
+      pc -= 2;
+      if (!safe_frame_unwind_memory (next_frame, pc, buf, SH_LINUX_RT_SIGTRAMP_LEN))
+        return 0;
+    }
+
+  if (memcmp (buf, sh_linux_rt_sigtramp_code, SH_LINUX_RT_SIGTRAMP_LEN) != 0)
+    return 0;
+
+  return pc;
+}
+
+/* Return whether the frame preceding NEXT_FRAME corresponds to a
+   GNU/Linux sigtramp routine.  */
+
+static int
+sh_linux_sigtramp_p (struct frame_info *next_frame)
+{
+  CORE_ADDR pc = frame_pc_unwind (next_frame);
+  struct symbol *symbol = find_pc_function(pc);
+  
+  /* If symbolic lookup of the PC matches a symbol of function type then
+   * it cannot be a signal trampoline since (on SH) these are always found
+   * on the real stack (no symbol) or the alternate stack (not of function 
+   * type so not found by find_pc_function).
+   */
+  if (NULL == symbol)
+    return (0 != sh_linux_sigtramp_start (next_frame)
+            || 0 != sh_linux_rt_sigtramp_start (next_frame));
+  
+  return 0;
+}
+
+#define SH_LINUX_SIZEOF_SIGCONTEXT 232
+#define SH_LINUX_SIZEOF_UCONTEXT 260
+#define SH_LINUX_SIZEOF_TRAMPOLINE 16
+#define SH_LINUX_UCONTEXT_SIGCONTEXT_OFFSET 20
+
+static CORE_ADDR
+sh_linux_sigcontext_addr (struct frame_info *next_frame)
+{
+  CORE_ADDR pc;
+  CORE_ADDR sp;
+  char buf[4];
+
+  frame_unwind_register (next_frame, SP_REGNUM, buf);
+  sp = extract_unsigned_integer (buf, 4);
+  
+  pc = sh_linux_sigtramp_start (next_frame);
+  if (pc)
+    {
+      /* The sigcontext structure lives on the stack as part of this
+       * structure in which pc pointers to the first element of retcode:
+       *   struct sigframe 
+       *     {
+       *       struct sigcontext sc;
+       *       unsigned long extramask[_NSIG_WORDS-1];
+       *       u16 retcode[8];
+       *     };
+       */
+      return pc - 4 - SH_LINUX_SIZEOF_SIGCONTEXT;
+    }
+
+  pc = sh_linux_rt_sigtramp_start (next_frame);
+  if (pc)
+    {
+      /* The sigcontext structure lives on the stack as part of this
+       * structure in which pc pointers to the first element of retcode:
+       *   struct rt_sigframe
+       *     {
+       *       struct siginfo info;
+       *       struct ucontext uc;
+       *       u16 retcode[8];
+       *     };
+       */
+      return pc - SH_LINUX_SIZEOF_UCONTEXT + SH_LINUX_UCONTEXT_SIGCONTEXT_OFFSET;
+    }
+
+  error ("Couldn't recognize signal trampoline.");
+  return 0;
+}
+
+/* offsets into struct sigcontext */
+enum sigcontextsc_pr
+  {
+    SC_OLDMASK,
+    SC_R0_REGNUM,
+    SC_PC_REGNUM = SC_R0_REGNUM + 16,
+    SC_PR_REGNUM,
+    SC_SR_REGNUM,
+    SC_GBR_REGNUM,
+    SC_MACH_REGNUM,
+    SC_MACL_REGNUM,
+    SC_FP0_REGNUM,
+    SC_XFP0_REGNUM = SC_FP0_REGNUM + 16,
+    SC_FPSCR_REGNUM,
+    SC_FPUL_REGNUM,
+    SC_OWNEDFP_REGNUM
+  };
+
+/* Populate a frame cache structure with offsets into struct sigcontext */
+
+static struct sh_frame_cache *
+sh_linux_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  struct sh_frame_cache *cache;
+  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  CORE_ADDR addr;
+  char buf[4];
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = sh_alloc_frame_cache ();
+
+  frame_unwind_register (next_frame, SP_REGNUM, buf);
+  cache->base = extract_unsigned_integer (buf, 4);
+
+  addr = sh_linux_sigcontext_addr (next_frame);
+  if (addr)
+    {
+      int i;
+
+      for (i=0; i<16; i++)
+	cache->saved_regs[R0_REGNUM+i] = addr + 4*(SC_R0_REGNUM+i);
+
+      cache->saved_regs[PC_REGNUM] = addr + (4*SC_PC_REGNUM);
+      cache->saved_regs[PR_REGNUM] = addr + (4*SC_PC_REGNUM);
+      cache->saved_regs[SR_REGNUM] = addr + (4*SC_SR_REGNUM);
+      cache->saved_regs[GBR_REGNUM] = addr + (4*SC_GBR_REGNUM);
+      cache->saved_regs[MACH_REGNUM] = addr + (4*SC_MACH_REGNUM);
+      cache->saved_regs[MACL_REGNUM] = addr + (4*SC_MACL_REGNUM);
+
+      if (-1 != FP0_REGNUM)
+        {
+	  gdb_assert(25 == FP0_REGNUM);
+
+	  for (i=0; i<16; i++)
+            cache->saved_regs[FP0_REGNUM+i] = addr + 4*(SC_FP0_REGNUM+i);
+
+          cache->saved_regs[FPSCR_REGNUM] = addr + (4*SC_FPSCR_REGNUM);
+          cache->saved_regs[FPUL_REGNUM] = addr + (4*SC_FPUL_REGNUM);
+	}
+    }
+
+  *this_cache = cache;
+  return cache;
+}
 
 static void
-sh_linux_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
+sh_linux_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
+			         struct frame_id *this_id)
 {
-  /* GNU/Linux uses SVR4-style shared libraries.  */
-  set_solib_svr4_fetch_link_map_offsets
-    (gdbarch, svr4_ilp32_fetch_link_map_offsets);
+  struct sh_frame_cache *cache = sh_linux_sigtramp_frame_cache (next_frame, this_cache);
+
+  (*this_id) = frame_id_build (cache->base, frame_pc_unwind (next_frame));
 }
 
-/* Provide a prototype to silence -Wmissing-prototypes.  */
-extern void _initialize_sh_linux_tdep (void);
+static void
+sh_linux_sigtramp_frame_prev_register (struct frame_info *next_frame,
+		                       void **this_cache,
+				       int regnum, int *optimizedp,
+				       enum lval_type *lvalp, CORE_ADDR *addrp,
+				       int *realnump, void *valuep)
+{
+  /* Make sure we've initialized the cache.  */
+  struct sh_frame_cache *cache = sh_linux_sigtramp_frame_cache (next_frame, this_cache);
+
+  sh_frame_prev_register (next_frame, this_cache, regnum,
+			  optimizedp, lvalp, addrp, realnump, valuep);
+}
+
+static const struct frame_unwind sh_linux_sigtramp_frame_unwind =
+{
+  SIGTRAMP_FRAME,
+  sh_linux_sigtramp_frame_this_id,
+  sh_linux_sigtramp_frame_prev_register
+};
+
+static const struct frame_unwind *
+sh_linux_sigtramp_frame_sniffer (struct frame_info *next_frame)
+{
+  if (sh_linux_sigtramp_p (next_frame))
+    return &sh_linux_sigtramp_frame_unwind;
+    
+  return NULL;
+}
+
+
+/* Hide the supervisor mode registers */
+
+static const char *sh_linux_register_names[SH_NUM_REGS];
+
+static const char *
+sh_linux_register_name (int reg_nr)
+{
+  if (reg_nr < 0 || reg_nr >= SH_NUM_REGS)
+    return NULL;
+
+  return sh_linux_register_names[reg_nr];
+}
+
+static void
+sh_linux_init_abi (struct gdbarch_info info,
+		    struct gdbarch *gdbarch)
+{
+  int i;
+
+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
+
+  /* extract the pre-existing architectural names for each of the registers */
+  for (i=0; i<SH_NUM_REGS; i++) 
+    sh_linux_register_names[i] = gdbarch_register_name(gdbarch, i);
+
+  /* hide the supervisor mode registers from the debugger */
+  sh_linux_register_names[SSR_REGNUM] = "";
+  sh_linux_register_names[SPC_REGNUM] = "";
+  set_gdbarch_register_name (gdbarch, sh_linux_register_name);
+
+  frame_unwind_append_sniffer (gdbarch, sh_linux_sigtramp_frame_sniffer);
+}
 
 void
 _initialize_sh_linux_tdep (void)
 {
-  gdbarch_register_osabi (bfd_arch_sh, 0, GDB_OSABI_LINUX, sh_linux_init_abi);
+  gdbarch_register_osabi (bfd_arch_sh, 0, GDB_OSABI_LINUX,
+			  sh_linux_init_abi);
 }
Index: gdb-6.5/gdb/sh-tdep.h
===================================================================
--- gdb-6.5.orig/gdb/sh-tdep.h	2006-04-03 15:31:14.000000000 +0100
+++ gdb-6.5/gdb/sh-tdep.h	2007-09-18 16:59:42.000000000 +0100
@@ -24,6 +24,8 @@
 
 /* Contributed by Steve Chamberlain sac@cygnus.com */
 
+#include "defs.h"
+
 /* Registers for all SH variants.  Used also by sh3-rom.c. */
 enum
   {
@@ -84,7 +86,30 @@
     FV_LAST_REGNUM = 79
   };
 
-extern gdbarch_init_ftype sh64_gdbarch_init;
-extern void sh64_show_regs (void);
+/* TODO: why is SH_NUM_REGS < RV_LAST_REGNUM */
+#define SH_NUM_REGS 67
+
+struct sh_frame_cache
+  {
+    /* Base address.  */
+    CORE_ADDR base;
+    LONGEST sp_offset;
+    CORE_ADDR pc;
+	
+    /* Flag showing that a frame has been created in the prologue code. */
+    int uses_fp;
+	
+    /* Saved registers.  */
+    CORE_ADDR saved_regs[SH_NUM_REGS];
+    CORE_ADDR saved_sp;
+  };
+
+extern struct sh_frame_cache *sh_alloc_frame_cache (void);
+extern void sh_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+			            int regnum, int *optimizedp,
+			            enum lval_type *lvalp, CORE_ADDR *addrp,
+			            int *realnump, gdb_byte *valuep);
 
+ extern gdbarch_init_ftype sh64_gdbarch_init;
+ extern void sh64_show_regs (void);
 #endif /* SH_TDEP_H */
Index: gdb-6.5/gdb/sh-tdep.c
===================================================================
--- gdb-6.5.orig/gdb/sh-tdep.c	2007-09-18 16:55:25.000000000 +0100
+++ gdb-6.5/gdb/sh-tdep.c	2007-09-18 16:59:42.000000000 +0100
@@ -59,23 +59,6 @@
 
 static void (*sh_show_regs) (void);
 
-#define SH_NUM_REGS 67
-
-struct sh_frame_cache
-{
-  /* Base address.  */
-  CORE_ADDR base;
-  LONGEST sp_offset;
-  CORE_ADDR pc;
-
-  /* Flag showing that a frame has been created in the prologue code. */
-  int uses_fp;
-
-  /* Saved registers.  */
-  CORE_ADDR saved_regs[SH_NUM_REGS];
-  CORE_ADDR saved_sp;
-};
-
 static const char *
 sh_sh_register_name (int reg_nr)
 {
@@ -2167,7 +2150,7 @@
     reg->how = DWARF2_FRAME_REG_UNDEFINED;
 }
 
-static struct sh_frame_cache *
+struct sh_frame_cache *
 sh_alloc_frame_cache (void)
 {
   struct sh_frame_cache *cache;
@@ -2246,7 +2229,7 @@
   return cache;
 }
 
-static void
+void
 sh_frame_prev_register (struct frame_info *next_frame, void **this_cache,
 			int regnum, int *optimizedp,
 			enum lval_type *lvalp, CORE_ADDR *addrp,
